uint64_t sub_1011048B0(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v4;
  void v5[6];
  void *v6;
  void **block;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  void *v10;
  unsigned __int16 *v11;
  void *v12;
  unsigned __int16 v13;

  v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1011086EC;
  v5[3] = &unk_101A8F478;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  v2 = a1 + 24;
  v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_101108740;
    v10 = &unk_101A8F4B8;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    v13 = 0;
    block = _NSConcreteStackBlock;
    v8 = 0x40000000;
    v9 = sub_101108704;
    v10 = &unk_101A8F498;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

uint64_t sub_1011049D8(uint64_t a1)
{
  if (a1)
  {
    if (CPRecordStoreGetDatabase() && CPSqliteDatabaseConnectionForWriting())
    {
      CPSqliteConnectionBegin();
      int v1 = CPSqliteConnectionIntegerForPropertyWithDefaultValue();
      CPSqliteDatabaseReleaseSqliteConnection();
      BOOL v2 = v1 != 0;
      if (v1 == -1) {
        BOOL v2 = 0;
      }
      int v3 = v1 != -1;
    }
    else
    {
      BOOL v2 = 0;
      int v3 = 0;
    }
  }
  else
  {
    BOOL v2 = 0;
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

void sub_101104A68(uint64_t a1, char a2)
{
  uint64_t v4 = a1;
  char v5 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10110877C;
  block[3] = &unk_101A8F4D8;
  block[4] = a1 + 8;
  block[5] = &v4;
  uint64_t v3 = a1 + 24;
  BOOL v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void *sub_101104AF4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v4[0] = off_101A8FF28;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = v4;
  sub_1011074D4(a1, (uint64_t)v4);
  return sub_10110C5FC(v4);
}

void sub_101104B7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10110C5FC((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101104B90(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_101108798;
  v5[3] = &unk_101A8F4F8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  v6 = v5;
  uint64_t v2 = a1 + 24;
  int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    v9 = sub_101108740;
    v10 = &unk_101A8F4B8;
    v11 = &v13;
    v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    v9 = sub_101108704;
    v10 = &unk_101A8F498;
    v11 = &v13;
    v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_101104CB8(uint64_t a1, char a2)
{
  uint64_t v4 = a1;
  char v5 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1011087B0;
  block[3] = &unk_101A8F518;
  block[4] = a1 + 8;
  block[5] = &v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

uint64_t sub_101104D44(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1011087CC;
  v7[3] = &unk_101A8F538;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    v11 = sub_101108A14;
    v12 = &unk_101A8F578;
    unsigned __int16 v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    v11 = sub_1011089D8;
    v12 = &unk_101A8F558;
    unsigned __int16 v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void *sub_101104E74(void *a1, uint64_t a2, int a3)
{
  int v4 = a3;
  *a1 = 0;
  v6[0] = off_101A8FFA8;
  v6[1] = &v4;
  v6[3] = v6;
  v5[0] = off_101A90028;
  v5[1] = a1;
  v5[3] = v5;
  sub_101106400(a2, (uint64_t)&off_101A8EF68, @"SELECT * from subscriber_info WHERE (tag == ?) ORDER BY last_update_time DESC;",
    0,
    (uint64_t)v6,
    (uint64_t)v5);
  sub_100A10BB4(v5);
  return sub_10110A738(v6);
}

void sub_101104F54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100A10BB4((uint64_t *)va);
  sub_10110A738((uint64_t *)va1);
  sub_1000577C4(v2);
  _Unwind_Resume(a1);
}

void sub_101104F78(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_10110507C(uint64_t a1, uint64_t a2, const __CFNumber *a3)
{
  CFNumberRef v7 = 0;
  CFNumberRef valuePtr = a3;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v7;
    CFNumberRef v7 = v3;
    CFNumberRef valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v6 = v7;
  CFNumberRef v7 = 0;
  sub_1000570E8((const void **)&v7);
  CPRecordSetProperty();
  return sub_1000570E8((const void **)&v6);
}

void sub_101105118(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101105138(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101108BD0;
  v7[3] = &unk_101A8F598;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    v11 = sub_101108DB8;
    v12 = &unk_101A8F5D8;
    unsigned __int16 v13 = &v15;
    v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    v11 = sub_101108D7C;
    v12 = &unk_101A8F5B8;
    unsigned __int16 v13 = &v15;
    v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_101105268(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_10110535C(uint64_t a1, uint64_t a2, int a3)
{
  CFNumberRef v7 = 0;
  LODWORD(valuePtr) = a3;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v7;
    CFNumberRef v7 = v3;
    CFNumberRef valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v6 = v7;
  CFNumberRef v7 = 0;
  sub_1000570E8((const void **)&v7);
  CPRecordSetProperty();
  return sub_1000570E8((const void **)&v6);
}

void sub_1011053F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101105418(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101108F58;
  v10[3] = &unk_101A8F5F8;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  CFNumberRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108740;
    unsigned int v15 = &unk_101A8F4B8;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108704;
    unsigned int v15 = &unk_101A8F498;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }
  uint64_t v5 = v18;
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5;
}

void sub_101105594(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  __int16 v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1011056FC(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101109344;
  v10[3] = &unk_101A8F618;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  CFNumberRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108740;
    unsigned int v15 = &unk_101A8F4B8;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108704;
    unsigned int v15 = &unk_101A8F498;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }
  uint64_t v5 = v18;
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5;
}

void sub_101105878(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  __int16 v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1011059E0(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_1011096DC;
  v10[3] = &unk_101A8F638;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  CFNumberRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108740;
    unsigned int v15 = &unk_101A8F4B8;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108704;
    unsigned int v15 = &unk_101A8F498;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }
  uint64_t v5 = v18;
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5;
}

void sub_101105B5C(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  __int16 v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_101105CC4(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101109A74;
  v10[3] = &unk_101A8F658;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  CFNumberRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108740;
    unsigned int v15 = &unk_101A8F4B8;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108704;
    unsigned int v15 = &unk_101A8F498;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }
  uint64_t v5 = v18;
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5;
}

void sub_101105E40(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  __int16 v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_101105FA8(uint64_t a1, long long *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v7 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v9 = *((void *)a2 + 2);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101109E0C;
  v10[3] = &unk_101A8F678;
  v10[4] = v3;
  v10[5] = &v7;
  v11 = v10;
  CFNumberRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108740;
    unsigned int v15 = &unk_101A8F4B8;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    unsigned __int16 v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    v14 = sub_101108704;
    unsigned int v15 = &unk_101A8F498;
    uint64_t v16 = &v18;
    v17 = &v11;
    dispatch_sync(v4, &block);
  }
  uint64_t v5 = v18;
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  return v5;
}

void sub_101106124(uint64_t a1, uint64_t a2, char a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  char v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10110628C(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1011063E8;
  v4[3] = &unk_101A8EEB0;
  void v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10110A55C;
  v6[3] = &unk_101A8F718;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  char v7 = v6;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10110A5E8;
    v11 = &unk_101A8F758;
    v12 = a2;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10110A570;
    v11 = &unk_101A8F738;
    v12 = a2;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_1011063E8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_101104864(a2, *(void *)(*(void *)(a1 + 32) + 64));
}

uint64_t sub_101106400(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = CPRecordStoreGetDatabase();
  if (result)
  {
    uint64_t result = a4 ? CPSqliteDatabaseStatementForReading() : CPSqliteDatabaseStatementForWriting();
    uint64_t v10 = (const void *)result;
    if (result)
    {
      if (*(void *)(result + 8))
      {
        uint64_t v11 = *(void *)(a5 + 24);
        v14 = v10;
        if (!v11) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, const void **))(*(void *)v11 + 48))(v11, &v14);
        v12 = (const void *)CPRecordStoreProcessStatement();
        v14 = v12;
        if (v12) {
          uint64_t v13 = sub_100083F10;
        }
        else {
          uint64_t v13 = 0;
        }
        if (v13) {
          sub_100A159F4(a6, (uint64_t)v12);
        }
        CPSqliteStatementReset();
        sub_100044D00(&v14);
      }
      return CPSqliteDatabaseReleaseSqliteStatement();
    }
  }
  return result;
}

void sub_10110650C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101106520(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 64);
  if (!v3) {
    return result;
  }
  uint64_t v5 = result;
  unsigned int v13 = 0;
  if (a3 == 2)
  {
    unsigned int v6 = 4;
    goto LABEL_6;
  }
  if (!a3)
  {
    unsigned int v6 = 16;
LABEL_6:
    unsigned int v13 = v6;
  }
  int v12 = 20;
  char v11 = 1;
  v19[0] = off_101A8F898;
  v19[1] = a2;
  v19[3] = v19;
  char v7 = operator new(0x30uLL);
  *char v7 = off_101A8F918;
  v7[1] = v5;
  v7[2] = a2;
  v7[3] = &v13;
  v7[4] = &v12;
  v7[5] = &v11;
  v18[3] = v7;
  sub_101106400(v3, (uint64_t)&off_101A8EED0, @"SELECT * from bundle_info WHERE (bundle_id == ?) ORDER BY bundle_id DESC;",
    0,
    (uint64_t)v19,
    (uint64_t)v18);
  sub_100A10BB4(v18);
  sub_10110A738(v19);
  if (v11)
  {
    uint64_t v8 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v9 = a2;
      }
      else {
        uint64_t v9 = *(void *)a2;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v15 = v9;
      __int16 v16 = 1024;
      unsigned int v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding new bundle entry: %{public}s with notification state set to: 0x%08X", buf, 0x12u);
    }
    uint64_t v10 = (const void *)CPRecordCreate();
    sub_10110A9FC((uint64_t)v10, a2);
    sub_10110ABA4((uint64_t)v10, v12, v13);
    CPRecordStoreAddRecord();
    CFRelease(v10);
  }
  return sub_101102EF4(v5);
}

void sub_101106700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_100A10BB4((uint64_t *)va);
  sub_10110A738((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10110672C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 64);
  if (!v3) {
    return result;
  }
  uint64_t v5 = result;
  unsigned int v13 = 0;
  if (a3 == 2)
  {
    unsigned int v6 = 8;
    goto LABEL_6;
  }
  if (!a3)
  {
    unsigned int v6 = 32;
LABEL_6:
    unsigned int v13 = v6;
  }
  int v12 = 40;
  char v11 = 1;
  v19[0] = off_101A8F998;
  v19[1] = a2;
  v19[3] = v19;
  uint64_t v7 = operator new(0x30uLL);
  *uint64_t v7 = off_101A8FA18;
  v7[1] = v5;
  v7[2] = a2;
  v7[3] = &v13;
  v7[4] = &v12;
  v7[5] = &v11;
  v18[3] = v7;
  sub_101106400(v3, (uint64_t)&off_101A8EED0, @"SELECT * from bundle_info WHERE (bundle_id == ?) ORDER BY bundle_id DESC;",
    0,
    (uint64_t)v19,
    (uint64_t)v18);
  sub_100A10BB4(v18);
  sub_10110A738(v19);
  if (v11)
  {
    uint64_t v8 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v9 = a2;
      }
      else {
        uint64_t v9 = *(void *)a2;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v15 = v9;
      __int16 v16 = 1024;
      unsigned int v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding new bundle entry: %{public}s with notification state set to: 0x%08X", buf, 0x12u);
    }
    uint64_t v10 = (const void *)CPRecordCreate();
    sub_10110A9FC((uint64_t)v10, a2);
    sub_10110ABA4((uint64_t)v10, v12, v13);
    CPRecordStoreAddRecord();
    CFRelease(v10);
  }
  return sub_101102EF4(v5);
}

void sub_10110690C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_100A10BB4((uint64_t *)va);
  sub_10110A738((uint64_t *)va1);
  _Unwind_Resume(a1);
}

BOOL sub_101106938(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  v19 = 0;
  sub_101106AE0(&v19, a1, a2, a3);
  if (v19) {
    uint64_t v8 = sub_100080934;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    Property = (const void *)CPRecordGetProperty();
    uint64_t v11 = Property;
    if (Property)
    {
      CFTypeID v12 = CFGetTypeID(Property);
      unsigned int v13 = v12 == CFNumberGetTypeID() ? (unsigned int *)v11 : 0;
    }
    else
    {
      unsigned int v13 = 0;
    }
    *(_DWORD *)buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v13, v10);
    int v14 = *(_DWORD *)buf;
    *a4 = *(_DWORD *)buf;
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v16 = a2;
      }
      else {
        uint64_t v16 = *(void *)a2;
      }
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v17 = a3;
      }
      else {
        uint64_t v17 = *(void *)a3;
      }
      *(_DWORD *)buf = 136315650;
      uint64_t v21 = v16;
      __int16 v22 = 2080;
      uint64_t v23 = v17;
      __int16 v24 = 1024;
      int v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Subscriber %s and mdn %s have tag %u", buf, 0x1Cu);
    }
  }
  sub_1000577C4(&v19);
  return v8 != 0;
}

void sub_101106AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void *sub_101106AE0(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = 0;
  uint64_t v4 = *(unsigned __int8 *)(a4 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a4 + 8);
  }
  if (v4)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(a2 + 64);
    v12[0] = off_101A900A8;
    v12[1] = a3;
    v12[2] = a4;
    v12[3] = v12;
    CFNumberRef v10 = operator new(0x28uLL);
    void *v10 = off_101A90128;
    v10[1] = v8;
    v10[2] = a2;
    v10[3] = a3;
    v10[4] = a4;
    v11[3] = v10;
    sub_101106400(v9, (uint64_t)&off_101A8EF68, @"SELECT * from subscriber_info WHERE (subscriber_id == ?) AND (subscriber_mdn == ?) ORDER BY last_update_time DESC;",
      0,
      (uint64_t)v12,
      (uint64_t)v11);
    sub_100A10BB4(v11);
    return sub_10110A738(v12);
  }
  return result;
}

void sub_101106BFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100A10BB4((uint64_t *)va);
  sub_10110A738((uint64_t *)va1);
  sub_1000577C4(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_101106C28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  unsigned __int8 v18 = a5;
  char v17 = 0;
  char v16 = 0;
  uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  if (v9)
  {
    CFStringRef v10 = @"SELECT * from subscriber_info WHERE (subscriber_id == ?) OR (subscriber_mdn == ?) ORDER BY last_update_time DESC;";
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Subscriber mdn is empty", v15, 2u);
    }
    CFStringRef v10 = @"SELECT * from subscriber_info WHERE (subscriber_id == ?) ORDER BY last_update_time DESC;";
  }
  uint64_t v12 = *(void *)(a1 + 64);
  v21[0] = off_101A8FC98;
  v21[1] = a2;
  v21[2] = a3;
  v21[3] = v21;
  v20 = 0;
  unsigned int v13 = operator new(0x40uLL);
  *unsigned int v13 = off_101A8FD18;
  v13[1] = a1;
  v13[2] = &v16;
  v13[3] = a4;
  v13[4] = &v18;
  v13[5] = a2;
  v13[6] = a3;
  v13[7] = &v17;
  v20 = v13;
  sub_101106400(v12, (uint64_t)&off_101A8EF68, (uint64_t)v10, 0, (uint64_t)v21, (uint64_t)v19);
  sub_100A10BB4(v19);
  sub_10110A738(v21);
  if (v16) {
    return sub_101106C28(a1, a2, a3, a4, v18);
  }
  else {
    return v17 != 0;
  }
}

void sub_101106DD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

const void **sub_101106E04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a3;
    uint64_t v6 = *(void *)(a3 + 16);
  }
  if (SHIBYTE(v6) < 0)
  {
    sub_10004FC84(__dst, v5[0], (unint64_t)v5[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v5;
    uint64_t v10 = v6;
  }
  uint64_t v8 = 0;
  if (SHIBYTE(v10) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v12 = v10;
  }
  unsigned int v13 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v3 = v8;
    uint64_t v8 = v13;
    int v14 = v3;
    sub_1000558F4(&v14);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = v8;
  uint64_t v8 = 0;
  sub_1000558F4(&v8);
  if (SHIBYTE(v10) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
  CPRecordSetProperty();
  return sub_1000558F4(&v7);
}

void sub_101106F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

const void **sub_101106FBC(double a1)
{
  CFNumberRef v5 = 0;
  CFNumberRef valuePtr = *(CFNumberRef *)&a1;
  CFNumberRef v1 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
  if (v1)
  {
    CFNumberRef v2 = v5;
    CFNumberRef v5 = v1;
    CFNumberRef valuePtr = v2;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v4 = v5;
  CFNumberRef v5 = 0;
  sub_1000570E8((const void **)&v5);
  CPRecordSetProperty();
  return sub_1000570E8((const void **)&v4);
}

void sub_101107044(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_101107064(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (***v15)(uint64_t *__return_ptr, void, void **);
  char v16;
  long long v17;
  NSObject *v18;
  void *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  void *__p[2];
  uint64_t *v23;
  unsigned char buf[24];

  __p[0] = 0;
  __p[1] = 0;
  uint64_t v23 = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v6 = *(uint64_t **)(a3 + 16);
    uint64_t v23 = v6;
  }
  v20 = 0;
  uint64_t v21 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a2 + 48));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = (void (***)(uint64_t *__return_ptr, void, void **))v13[3];
    int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  int v14 = 0;
  char v16 = 1;
LABEL_12:
  (**v15)(&v20, v15, __p);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v20)
  {
    if (*(char *)(v20 + 95) < 0)
    {
      sub_10004FC84((unsigned char *)a1, *(void **)(v20 + 72), *(void *)(v20 + 80));
    }
    else
    {
      char v17 = *(_OWORD *)(v20 + 72);
      *(void *)(a1 + 16) = *(void *)(v20 + 88);
      *(_OWORD *)a1 = v17;
    }
  }
  else
  {
    unsigned __int8 v18 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        v19 = (void *)a3;
      }
      else {
        v19 = *(void **)a3;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No personality info for %s", buf, 0xCu);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
}

void sub_101107294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011072EC(uint64_t a1, uint64_t a2)
{
  unsigned int v9 = 0;
  if ((sub_10110743C(a1, a2, &v9) & 1) == 0)
  {
    int v8 = 0;
    memset(__p, 0, sizeof(__p));
    sub_101107064((uint64_t)__p, a1, a2);
    unsigned int v4 = sub_101103BA0(a1, a2, (uint64_t)__p, &v8);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    unsigned int v9 = v4;
    CFNumberRef v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v6 = (void *)a2;
      }
      else {
        uint64_t v6 = *(void **)a2;
      }
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = v6;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v4;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Could not find tag for %s.  Added a new one (%d) based on subscriber id only at the expense of tag %d", (uint8_t *)__p, 0x18u);
    }
  }
  return v9;
}

void sub_101107418(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10110743C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  sub_101107064((uint64_t)__p, a1, a2);
  uint64_t v6 = sub_10110320C(a1, a2, (uint64_t)__p, a3);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_1011074B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011074D4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(void *)(a2 + 24))
    {
      uint64_t result = CPRecordStoreGetDatabase();
      if (result)
      {
        uint64_t result = CPSqliteDatabaseConnectionForWriting();
        if (result)
        {
          uint64_t v3 = result;
          CPSqliteConnectionBegin();
          uint64_t v4 = *(void *)(a2 + 24);
          uint64_t v5 = v3;
          if (!v4) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, &v5);
          CPSqliteConnectionCommit();
          return CPSqliteDatabaseReleaseSqliteConnection();
        }
      }
    }
  }
  return result;
}

void *sub_101107584(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  uint64_t v6 = *(void *)(a2 + 64);
  v10[0] = off_101A901A8;
  v10[1] = a3;
  v10[3] = v10;
  uint64_t v7 = operator new(0x20uLL);
  *uint64_t v7 = off_101A90228;
  v7[1] = a1;
  v7[2] = a2;
  v7[3] = a3;
  v9[3] = v7;
  sub_101106400(v6, (uint64_t)&off_101A8EF68, @"SELECT * from subscriber_info WHERE (subscriber_id == ?) AND ((subscriber_mdn is null) OR (subscriber_mdn == '')) ORDER BY last_update_time DESC;",
    0,
    (uint64_t)v10,
    (uint64_t)v9);
  sub_100A10BB4(v9);
  return sub_10110A738(v10);
}

void sub_101107678(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100A10BB4((uint64_t *)va);
  sub_10110A738((uint64_t *)va1);
  sub_1000577C4(v2);
  _Unwind_Resume(a1);
}

const void **sub_1011076A4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(void *)a2;
    }
    uint64_t v6 = a2 + 24;
    if (*(char *)(a2 + 47) < 0) {
      uint64_t v6 = *(void *)(a2 + 24);
    }
    uint64_t v7 = a2 + 48;
    if (*(char *)(a2 + 71) < 0) {
      uint64_t v7 = *(void *)(a2 + 48);
    }
    *(_DWORD *)buf = 136381187;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2081;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2081;
    uint64_t v61 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Plan Transfer from %{private}s to %{private}s with mdn %{private}s", buf, 0x20u);
  }
  v57 = 0;
  sub_101106AE0(&v57, a1, a2, a2 + 48);
  if (v57) {
    uint64_t v8 = sub_100080934;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8
    || ((sub_101107584(&__p, a1, a2),
         *(void *)buf = v57,
         v57 = __p,
         long long __p = 0,
         sub_1000577C4((const void **)buf),
         sub_1000577C4((const void **)&__p),
         v57)
      ? (uint64_t v9 = sub_100080934)
      : (uint64_t v9 = 0),
        v9))
  {
    v56 = 0;
    sub_101106AE0(&v56, a1, a2 + 24, a2 + 48);
    uint64_t v10 = *(unsigned __int8 *)(a2 + 71);
    int v11 = (char)v10;
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *(void *)(a2 + 56);
    }
    if (v10 && (v56 ? (unsigned int v12 = sub_100080934) : (unsigned int v12 = 0), v12))
    {
      unsigned int v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 47) >= 0) {
          uint64_t v14 = a2 + 24;
        }
        else {
          uint64_t v14 = *(void *)(a2 + 24);
        }
        uint64_t v15 = *(void *)(a2 + 48);
        if (v11 >= 0) {
          uint64_t v15 = a2 + 48;
        }
        *(_DWORD *)buf = 136380931;
        *(void *)&uint8_t buf[4] = v14;
        *(_WORD *)&buf[12] = 2081;
        *(void *)&buf[14] = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N Exact match for plan transfer with to subscriberId %{private}s and phone number %{private}s exists.  Removing.", buf, 0x16u);
      }
      Property = (unsigned int *)CPRecordGetProperty();
      unsigned __int8 v18 = Property;
      if (Property)
      {
        CFTypeID v19 = CFGetTypeID(Property);
        if (v19 == CFNumberGetTypeID()) {
          v20 = v18;
        }
        else {
          v20 = 0;
        }
      }
      else
      {
        v20 = 0;
      }
      *(_DWORD *)buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v20, v17);
      unsigned int v22 = *(_DWORD *)buf;
      CPRecordStoreRemoveRecord();
      int v21 = 1;
    }
    else
    {
      int v21 = 0;
      unsigned int v22 = -1;
    }
    long long __p = 0;
    long long v55 = 0uLL;
    int v25 = (void **)CPRecordGetProperty();
    v26 = v25;
    if (v25)
    {
      CFGetTypeID(v25);
      CFStringGetTypeID();
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(void *)((char *)&v55 + 7) = *(void *)&buf[15];
      v26 = *(void ***)buf;
      unsigned int v27 = buf[23];
      long long __p = *(void **)buf;
      *(void *)&long long v55 = *(void *)&buf[8];
      HIBYTE(v55) = buf[23];
      size_t v28 = *(void *)&buf[8];
    }
    else
    {
      size_t v28 = 0;
      unsigned int v27 = 0;
    }
    uint64_t v29 = v27;
    if ((v27 & 0x80u) == 0) {
      size_t v30 = v27;
    }
    else {
      size_t v30 = v28;
    }
    if (!v30)
    {
      xpc_object_t v59 = 0;
      sub_101107584(&v59, a1, a2 + 24);
      if (v59) {
        v31 = sub_100080934;
      }
      else {
        v31 = 0;
      }
      if (v31)
      {
        unsigned int v52 = v22;
        v32 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 47) >= 0) {
            uint64_t v33 = a2 + 24;
          }
          else {
            uint64_t v33 = *(void *)(a2 + 24);
          }
          *(_DWORD *)buf = 136380675;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Removing record that contains only to subscriberId %{private}s", buf, 0xCu);
        }
        CPRecordStoreRemoveRecord();
        unsigned int v22 = v52;
      }
      sub_1000577C4((const void **)&v59);
    }
    sub_101106E04((uint64_t)v57, 0, a2 + 24);
    uint64_t v34 = *(unsigned __int8 *)(a2 + 71);
    int v35 = (char)v34;
    if ((v34 & 0x80u) != 0) {
      uint64_t v34 = *(void *)(a2 + 56);
    }
    if (v30 == v34)
    {
      if (v35 >= 0) {
        v36 = (unsigned __int8 *)(a2 + 48);
      }
      else {
        v36 = *(unsigned __int8 **)(a2 + 48);
      }
      if ((v29 & 0x80) == 0)
      {
        if (v29)
        {
          p_p = &__p;
          uint64_t v38 = v29;
          while (*(unsigned __int8 *)p_p == *v36)
          {
            p_p = (void **)((char *)p_p + 1);
            ++v36;
            if (!--v38) {
              goto LABEL_76;
            }
          }
          goto LABEL_75;
        }
LABEL_76:
        v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v40 = a2;
          }
          else {
            uint64_t v40 = *(void *)a2;
          }
          v41 = &__p;
          if ((v29 & 0x80u) != 0) {
            v41 = v26;
          }
          if (*(char *)(a2 + 47) >= 0) {
            uint64_t v42 = a2 + 24;
          }
          else {
            uint64_t v42 = *(void *)(a2 + 24);
          }
          if (*(char *)(a2 + 71) >= 0) {
            uint64_t v43 = a2 + 48;
          }
          else {
            uint64_t v43 = *(void *)(a2 + 48);
          }
          *(_DWORD *)buf = 136381443;
          *(void *)&uint8_t buf[4] = v40;
          *(_WORD *)&buf[12] = 2081;
          *(void *)&buf[14] = v41;
          *(_WORD *)&buf[22] = 2081;
          uint64_t v61 = v42;
          __int16 v62 = 2081;
          uint64_t v63 = v43;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Record transferred from %{private}s %{private}s to %{private}s %{private}s", buf, 0x2Au);
        }
        double Current = CFAbsoluteTimeGetCurrent();
        sub_101106FBC(Current);
        if (v21)
        {
          v45 = (unsigned int *)CPRecordGetProperty();
          v47 = v45;
          if (v45)
          {
            CFTypeID v48 = CFGetTypeID(v45);
            if (v48 == CFNumberGetTypeID()) {
              v49 = v47;
            }
            else {
              v49 = 0;
            }
          }
          else
          {
            v49 = 0;
          }
          *(_DWORD *)buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v49, v46);
          if (v22 == *(_DWORD *)buf)
          {
            v50 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v22;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#N Tag to rectify is equal to replacement tag %u", buf, 8u);
            }
          }
          else
          {
            v53[0] = v22;
            v53[1] = *(_DWORD *)buf;
            xpc_object_t v59 = 0;
            sub_1004CBAFC(v53, &v59);
            sub_100058DB0(buf, "/cc/events/rectify_tag");
            xpc_object_t object = v59;
            xpc_object_t v59 = xpc_null_create();
            ctu::RestModule::sendEvent();
            xpc_release(object);
            xpc_object_t object = 0;
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            xpc_release(v59);
          }
        }
        sub_101102EF4(a1);
        if (SHIBYTE(v55) < 0) {
          operator delete(__p);
        }
        sub_1000577C4(&v56);
        return sub_1000577C4((const void **)&v57);
      }
      if (!memcmp(v26, v36, v28)) {
        goto LABEL_76;
      }
    }
LABEL_75:
    sub_101106E04((uint64_t)v57, 1, a2 + 48);
    goto LABEL_76;
  }
  uint64_t v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v24 = a2;
    }
    else {
      uint64_t v24 = *(void *)a2;
    }
    *(_DWORD *)buf = 136380675;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No record with subscriberId %{private}s exists", buf, 0xCu);
  }
  return sub_1000577C4((const void **)&v57);
}

void sub_101107D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, const void *a18, const void *a19, xpc_object_t object,xpc_object_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a18);
  sub_1000577C4(&a19);
  _Unwind_Resume(a1);
}

void sub_101107E4C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B131B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B131B0))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B131A8, kCtLoggingSystemName, "cu.store");
    __cxa_guard_release(&qword_101B131B0);
  }
}

void sub_101107ECC(_Unwind_Exception *a1)
{
}

void sub_101107EE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101107F20(uint64_t a1)
{
}

uint64_t sub_101107F3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101107F80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101107FAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_101107FBC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101107FD8(uint64_t a1)
{
  CFNumberRef v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101107FE8(ServiceManager::Service *this)
{
  *(void *)this = off_101A8F208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101108044(ServiceManager::Service *this)
{
  *(void *)this = off_101A8F208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1011080B4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "custore");
}

unsigned char *sub_1011080C4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 1;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101108104(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_101108160()
{
  return 0;
}

uint64_t sub_101108168()
{
  return 1;
}

uint64_t sub_101108170()
{
  return 0;
}

void sub_10110817C(uint64_t a1)
{
  CFNumberRef v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10110825C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_101108370(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

void sub_101108384(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

void sub_1011083F4(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

void *sub_101108464(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void *sub_101108478(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_10110848C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

void sub_1011084A0(uint64_t a1)
{
  (*(void (**)(char ***__return_ptr))(**(void **)(a1 + 40) + 16))(&v7);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v2 + 8;
  sub_10005CD2C(v2, *(char **)(v2 + 8));
  *(void *)uint64_t v2 = v7;
  uint64_t v4 = v8;
  *(void *)(v2 + 8) = v8;
  uint64_t v5 = v9;
  *(void *)(v2 + 16) = v9;
  if (v5)
  {
    uint64_t v6 = 0;
    *((void *)v4 + 2) = v3;
    uint64_t v7 = &v8;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    *(void *)uint64_t v2 = v3;
    uint64_t v6 = v8;
  }
  sub_10005CD2C((uint64_t)&v7, v6);
}

void sub_101108544(uint64_t a1)
{
  (*(void (**)(char ***__return_ptr))(**(void **)(a1 + 40) + 16))(&v7);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v2 + 8;
  sub_10005CD2C(v2, *(char **)(v2 + 8));
  *(void *)uint64_t v2 = v7;
  uint64_t v4 = v8;
  *(void *)(v2 + 8) = v8;
  uint64_t v5 = v9;
  *(void *)(v2 + 16) = v9;
  if (v5)
  {
    uint64_t v6 = 0;
    *((void *)v4 + 2) = v3;
    uint64_t v7 = &v8;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    *(void *)uint64_t v2 = v3;
    uint64_t v6 = v8;
  }
  sub_10005CD2C((uint64_t)&v7, v6);
}

void *sub_1011085E8(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1011085FC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_101108638(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_101108674(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

__n128 sub_101108688(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t sub_1011086EC(uint64_t a1)
{
  return sub_1011049D8(*(void *)(**(void **)(a1 + 40) + 64));
}

uint64_t sub_101108704(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_101108740(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

void *sub_10110877C(uint64_t a1)
{
  return sub_101104AF4(*(void *)(**(void **)(a1 + 40) + 64), *(unsigned __int8 *)(*(void *)(a1 + 40) + 8), @"kGreenTea");
}

uint64_t sub_101108798(uint64_t a1)
{
  return sub_1011049D8(*(void *)(**(void **)(a1 + 40) + 64));
}

void *sub_1011087B0(uint64_t a1)
{
  return sub_101104AF4(*(void *)(**(void **)(a1 + 40) + 64), *(unsigned __int8 *)(*(void *)(a1 + 40) + 8), @"kDataUsageCollectionEnabled");
}

uint64_t sub_1011087CC(uint64_t a1)
{
  CFNumberRef v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = *((_DWORD *)v1 + 2);
  v20 = 0;
  sub_101104E74(&v20, *(void *)(v2 + 64), v3);
  if (v20) {
    __n128 v4 = sub_100080934;
  }
  else {
    __n128 v4 = 0;
  }
  if (v4)
  {
    Property = (uint64_t *)CPRecordGetProperty();
    uint64_t v7 = Property;
    if (Property)
    {
      CFTypeID v8 = CFGetTypeID(Property);
      if (v8 == CFNumberGetTypeID()) {
        uint64_t v9 = v7;
      }
      else {
        uint64_t v9 = 0;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    *(void *)buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v9, v6);
    uint64_t v11 = *(void *)buf;
    unsigned int v12 = (uint64_t *)CPRecordGetProperty();
    uint64_t v14 = v12;
    if (v12)
    {
      CFTypeID v15 = CFGetTypeID(v12);
      if (v15 == CFNumberGetTypeID()) {
        char v16 = v14;
      }
      else {
        char v16 = 0;
      }
    }
    else
    {
      char v16 = 0;
    }
    *(void *)buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v16, v13);
    uint64_t v17 = *(void *)buf;
    unsigned __int8 v18 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218496;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v22 = 2048;
      uint64_t v23 = v17;
      __int16 v24 = 1024;
      int v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I home budget %llu roaming budget %llu for tag: %u", buf, 0x1Cu);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find tag %u when getting user entered budget", buf, 8u);
    }
    uint64_t v11 = 0;
  }
  sub_1000577C4(&v20);
  return v11;
}

void sub_1011089BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1011089D8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  int v3 = *(uint64_t **)(a1 + 32);
  *int v3 = result;
  v3[1] = v4;
  return result;
}

uint64_t sub_101108A14(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  int v3 = *(uint64_t **)(a1 + 32);
  *int v3 = result;
  v3[1] = v4;
  return result;
}

void sub_101108A50(uint64_t **a1)
{
  uint64_t v1 = **a1;
  CFNumberRef v2 = (const __CFNumber *)(*a1)[1];
  CFNumberRef v3 = (const __CFNumber *)(*a1)[2];
  int v4 = *((_DWORD *)*a1 + 6);
  uint64_t v7 = 0;
  sub_101104E74(&v7, *(void *)(v1 + 64), v4);
  if (v7) {
    uint64_t v5 = sub_100080934;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    sub_10110507C(v7, 5, v2);
    sub_10110507C(v7, 6, v3);
    sub_101102EF4(v1);
  }
  else
  {
    CFNumberRef v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v9 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find tag %u when setting user entered budget", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v7);
  operator delete();
}

void sub_101108B94()
{
}

uint64_t sub_101108BD0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = *((_DWORD *)v1 + 2);
  uint64_t v14 = 0;
  sub_101104E74(&v14, *(void *)(v2 + 64), v3);
  if (v14) {
    int v4 = sub_100080934;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    Property = (int *)CPRecordGetProperty();
    uint64_t v7 = Property;
    if (Property)
    {
      CFTypeID v8 = CFGetTypeID(Property);
      if (v8 == CFNumberGetTypeID()) {
        int v9 = v7;
      }
      else {
        int v9 = 0;
      }
    }
    else
    {
      int v9 = 0;
    }
    *(_DWORD *)buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v9, v6);
    uint64_t v11 = *(unsigned int *)buf;
    unsigned int v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      int v16 = v11;
      __int16 v17 = 1024;
      int v18 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I user entered billing end day of month %d for tag: %u", buf, 0xEu);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v16 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find tag %u when getting user entered billing end day of the month", buf, 8u);
    }
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  sub_1000577C4(&v14);
  return v11;
}

void sub_101108D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_101108D7C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_101108DB8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_101108DF4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v3 = *((_DWORD *)*a1 + 2);
  int v2 = *((_DWORD *)*a1 + 3);
  uint64_t v6 = 0;
  sub_101104E74(&v6, *(void *)(v1 + 64), v2);
  if (v6) {
    int v4 = sub_100080934;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    sub_10110535C(v6, 7, v3);
    sub_101102EF4(v1);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v8 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find tag %u when setting user entered billing end day of the month", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v6);
  operator delete();
}

void sub_101108F1C()
{
}

uint64_t sub_101108F58(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v17 = 0;
  if (sub_10110743C(v2, (uint64_t)(v1 + 1), &v17))
  {
    int v3 = v17;
    int v18 = 0;
    sub_101104E74(&v18, *(void *)(v2 + 64), v17);
    if (v18) {
      int v4 = sub_100080934;
    }
    else {
      int v4 = 0;
    }
    if (v4)
    {
      Property = (int *)CPRecordGetProperty();
      uint64_t v6 = Property;
      if (Property)
      {
        CFTypeID v7 = CFGetTypeID(Property);
        if (v7 == CFNumberGetTypeID()) {
          int v9 = v6;
        }
        else {
          int v9 = 0;
        }
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v9, v8);
        int v10 = *(_DWORD *)buf;
        BOOL v11 = *(_DWORD *)buf != 0;
        unsigned int v12 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          BOOL v20 = v10 != 0;
          __int16 v21 = 1024;
          int v22 = v3;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Low data mode %d for tag: %u", buf, 0xEu);
        }
        int v13 = 1;
        goto LABEL_19;
      }
      CFTypeID v15 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        BOOL v20 = v3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Low data mode not stored for tag: %u", buf, 8u);
      }
    }
    else
    {
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        BOOL v20 = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting low data mode", buf, 8u);
      }
    }
    int v13 = 0;
    BOOL v11 = 0;
LABEL_19:
    sub_1000577C4(&v18);
    return v11 | (v13 << 8);
  }
  int v13 = 0;
  BOOL v11 = 0;
  return v11 | (v13 << 8);
}

void sub_101109160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101109180(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_1011072EC(*(void *)v1, v1 + 8);
  unsigned int v4 = *(unsigned __int16 *)(v1 + 32);
  uint64_t v10 = 0;
  sub_101104E74(&v10, *(void *)(v2 + 64), v3);
  if (v10) {
    uint64_t v5 = sub_100080934;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    if (v4 >= 0x100) {
      sub_10110535C(v10, 8, v4);
    }
    else {
      CPRecordSetProperty();
    }
    sub_101102EF4(v2);
  }
  else
  {
    uint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v12 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting low power mode", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v10);
  sub_1011092EC(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1011092C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000577C4((const void **)va2);
  sub_1011092EC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011092EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_101109344(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v17 = 0;
  if (sub_10110743C(v2, (uint64_t)(v1 + 1), &v17))
  {
    int v16 = 0;
    sub_101104E74(&v16, *(void *)(v2 + 64), v17);
    if (v16) {
      uint64_t v3 = sub_100080934;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      Property = (int *)CPRecordGetProperty();
      uint64_t v5 = Property;
      if (Property)
      {
        CFTypeID v6 = CFGetTypeID(Property);
        if (v6 == CFNumberGetTypeID()) {
          CFNumberRef v8 = v5;
        }
        else {
          CFNumberRef v8 = 0;
        }
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v8, v7);
        int v9 = *(_DWORD *)buf;
        BOOL v10 = *(_DWORD *)buf != 0;
        BOOL v11 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          int v19 = v9 != 0;
          __int16 v20 = 1024;
          int v21 = v17;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Smart data mode %d for tag: %u", buf, 0xEu);
        }
        int v12 = 1;
        goto LABEL_19;
      }
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Smart data mode not stored for tag: %u", buf, 8u);
      }
    }
    else
    {
      int v13 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting smart data mode", buf, 8u);
      }
    }
    int v12 = 0;
    BOOL v10 = 0;
LABEL_19:
    sub_1000577C4(&v16);
    return v10 | (v12 << 8);
  }
  int v12 = 0;
  BOOL v10 = 0;
  return v10 | (v12 << 8);
}

void sub_101109554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t *sub_101109574(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_1011072EC(*(void *)v1, v1 + 8);
  uint64_t v9 = 0;
  sub_101104E74(&v9, *(void *)(v2 + 64), v3);
  if (v9) {
    unsigned int v4 = sub_100080934;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4)
  {
    if (*(unsigned char *)(v1 + 33)) {
      sub_10110535C(v9, 10, *(unsigned __int8 *)(v1 + 32));
    }
    else {
      CPRecordSetProperty();
    }
    sub_101102EF4(v2);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting smart data mode", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v9);
  sub_1011092EC(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1011096B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000577C4((const void **)va2);
  sub_1011092EC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011096DC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v17 = 0;
  if (sub_10110743C(v2, (uint64_t)(v1 + 1), &v17))
  {
    int v16 = 0;
    sub_101104E74(&v16, *(void *)(v2 + 64), v17);
    if (v16) {
      uint64_t v3 = sub_100080934;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      Property = (int *)CPRecordGetProperty();
      uint64_t v5 = Property;
      if (Property)
      {
        CFTypeID v6 = CFGetTypeID(Property);
        if (v6 == CFNumberGetTypeID()) {
          uint64_t v8 = v5;
        }
        else {
          uint64_t v8 = 0;
        }
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v8, v7);
        int v9 = *(_DWORD *)buf;
        BOOL v10 = *(_DWORD *)buf != 0;
        int v11 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          int v19 = v9 != 0;
          __int16 v20 = 1024;
          int v21 = v17;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Interface cost expensive %d for tag: %u", buf, 0xEu);
        }
        int v12 = 1;
        goto LABEL_19;
      }
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Interface cost not stored for tag: %u", buf, 8u);
      }
    }
    else
    {
      int v13 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting interface cost", buf, 8u);
      }
    }
    int v12 = 0;
    BOOL v10 = 0;
LABEL_19:
    sub_1000577C4(&v16);
    return v10 | (v12 << 8);
  }
  int v12 = 0;
  BOOL v10 = 0;
  return v10 | (v12 << 8);
}

void sub_1011098EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t *sub_10110990C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_1011072EC(*(void *)v1, v1 + 8);
  uint64_t v9 = 0;
  sub_101104E74(&v9, *(void *)(v2 + 64), v3);
  if (v9) {
    unsigned int v4 = sub_100080934;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4)
  {
    if (*(unsigned char *)(v1 + 33)) {
      sub_10110535C(v9, 11, *(unsigned __int8 *)(v1 + 32));
    }
    else {
      CPRecordSetProperty();
    }
    sub_101102EF4(v2);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting interface cost", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v9);
  sub_1011092EC(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101109A48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000577C4((const void **)va2);
  sub_1011092EC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101109A74(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v17 = 0;
  if (sub_10110743C(v2, (uint64_t)(v1 + 1), &v17))
  {
    int v16 = 0;
    sub_101104E74(&v16, *(void *)(v2 + 64), v17);
    if (v16) {
      uint64_t v3 = sub_100080934;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      Property = (int *)CPRecordGetProperty();
      uint64_t v5 = Property;
      if (Property)
      {
        CFTypeID v6 = CFGetTypeID(Property);
        if (v6 == CFNumberGetTypeID()) {
          uint64_t v8 = v5;
        }
        else {
          uint64_t v8 = 0;
        }
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v8, v7);
        int v9 = *(_DWORD *)buf;
        BOOL v10 = *(_DWORD *)buf != 0;
        int v11 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          int v19 = v9 != 0;
          __int16 v20 = 1024;
          int v21 = v17;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy %d for tag: %u", buf, 0xEu);
        }
        int v12 = 1;
        goto LABEL_19;
      }
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy not stored for tag: %u", buf, 8u);
      }
    }
    else
    {
      int v13 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v19 = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting privacy proxy", buf, 8u);
      }
    }
    int v12 = 0;
    BOOL v10 = 0;
LABEL_19:
    sub_1000577C4(&v16);
    return v10 | (v12 << 8);
  }
  int v12 = 0;
  BOOL v10 = 0;
  return v10 | (v12 << 8);
}

void sub_101109C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t *sub_101109CA4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_1011072EC(*(void *)v1, v1 + 8);
  uint64_t v9 = 0;
  sub_101104E74(&v9, *(void *)(v2 + 64), v3);
  if (v9) {
    unsigned int v4 = sub_100080934;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4)
  {
    if (*(unsigned char *)(v1 + 33)) {
      sub_10110535C(v9, 12, *(unsigned __int8 *)(v1 + 32));
    }
    else {
      CPRecordSetProperty();
    }
    sub_101102EF4(v2);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting privacy proxy", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v9);
  sub_1011092EC(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101109DE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000577C4((const void **)va2);
  sub_1011092EC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101109E0C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v17 = 0;
  if (sub_10110743C(v2, (uint64_t)(v1 + 1), &v17))
  {
    int v3 = v17;
    int v18 = 0;
    sub_101104E74(&v18, *(void *)(v2 + 64), v17);
    if (v18) {
      unsigned int v4 = sub_100080934;
    }
    else {
      unsigned int v4 = 0;
    }
    if (v4)
    {
      Property = (int *)CPRecordGetProperty();
      CFTypeID v6 = Property;
      if (Property)
      {
        CFTypeID v7 = CFGetTypeID(Property);
        if (v7 == CFNumberGetTypeID()) {
          uint64_t v9 = v6;
        }
        else {
          uint64_t v9 = 0;
        }
        *(_DWORD *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v9, v8);
        int v10 = *(_DWORD *)buf;
        BOOL v11 = *(_DWORD *)buf != 0;
        int v12 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          BOOL v20 = v10 != 0;
          __int16 v21 = 1024;
          int v22 = v3;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Reliable network fallback %d for tag: %u", buf, 0xEu);
        }
        int v13 = 1;
        goto LABEL_19;
      }
      CFTypeID v15 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        BOOL v20 = v3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Reliable network fallback not stored for tag: %u", buf, 8u);
      }
    }
    else
    {
      uint64_t v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        BOOL v20 = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when getting reliable network fallback", buf, 8u);
      }
    }
    int v13 = 0;
    BOOL v11 = 0;
LABEL_19:
    sub_1000577C4(&v18);
    return v11 | (v13 << 8);
  }
  int v13 = 0;
  BOOL v11 = 0;
  return v11 | (v13 << 8);
}

void sub_10110A014(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10110A034(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_1011072EC(*(void *)v1, v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 32);
  uint64_t v10 = 0;
  sub_101104E74(&v10, *(void *)(v2 + 64), v3);
  if (v10) {
    uint64_t v5 = sub_100080934;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    sub_10110535C(v10, 9, v4);
    sub_101102EF4(v2);
  }
  else
  {
    CFTypeID v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      int v12 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find record for tag %u when setting reliable network fallback", buf, 8u);
    }
  }
  sub_1000577C4((const void **)&v10);
  sub_10023CBF8(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10110A15C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000577C4((const void **)va2);
  sub_10023CBF8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10110A188(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 80));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10110A1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_10110A1EC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v3, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100058DB0(&__p, "/cc/events/service_transferred");
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = off_101A8F6A8;
  v2[1] = v1;
  v2[2] = sub_1011076A4;
  v2[3] = 0;
  v7[3] = v2;
  ctu::RestModule::observeEvent();
  sub_10003F600(v7);
  if (v6 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_10110A30C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_10110A378()
{
}

__n128 sub_10110A38C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A8F6A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10110A3E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8F6A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110A418(void *a1)
{
  uint64_t v9 = 0;
  long long v7 = 0u;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)char v6 = 0u;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  if (SHIBYTE(v6[0]) < 0) {
    operator delete(v5[0]);
  }
}

void sub_10110A4D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10110A510(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110A550()
{
}

uint64_t sub_10110A55C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

const void **sub_10110A570(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    char v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

const void **sub_10110A5E8(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    char v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

void sub_10110A664()
{
}

void *sub_10110A678()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A8F788;
  return result;
}

void sub_10110A6B0(uint64_t a1, void *a2)
{
  *a2 = off_101A8F788;
}

uint64_t sub_10110A6D8(uint64_t a1, uint64_t a2)
{
  return sqlite3_bind_int64(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, 3);
}

uint64_t sub_10110A6EC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10110A72C()
{
}

void *sub_10110A738(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10110A7C0()
{
}

void *sub_10110A7D4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A8F818;
  result[1] = v3;
  return result;
}

uint64_t sub_10110A81C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A8F818;
  a2[1] = v2;
  return result;
}

void sub_10110A848(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  CFIndex Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = (const void *)CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v13 = 0;
      long long v14 = 0uLL;
      uint64_t v15 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = v14;
      uint64_t v13 = v15;
      uint64_t v8 = *(void *)(a1 + 8);
      unint64_t v9 = *(void *)(v8 + 8);
      if (v9 >= *(void *)(v8 + 16))
      {
        uint64_t v11 = sub_100048008(*(uint64_t **)(a1 + 8), (long long *)__p);
      }
      else
      {
        if (SHIBYTE(v13) < 0)
        {
          sub_10004FC84(*(unsigned char **)(v8 + 8), __p[0], (unint64_t)__p[1]);
        }
        else
        {
          long long v10 = *(_OWORD *)__p;
          *(void *)(v9 + 16) = v13;
          *(_OWORD *)unint64_t v9 = v10;
        }
        uint64_t v11 = v9 + 24;
        *(void *)(v8 + 8) = v9 + 24;
      }
      *(void *)(v8 + 8) = v11;
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10110A974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  *(void *)(v20 + 8) = v21;
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10110A9B0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10110A9F0()
{
}

const void **sub_10110A9FC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v4, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v5) < 0)
  {
    sub_10004FC84(__p, v4[0], (unint64_t)v4[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v4;
    uint64_t v9 = v5;
  }
  long long v7 = 0;
  if (SHIBYTE(v9) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v11 = v9;
  }
  int v12 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v2 = v7;
    long long v7 = v12;
    uint64_t v13 = v2;
    sub_1000558F4(&v13);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)__dst);
  }
  char v6 = v7;
  long long v7 = 0;
  sub_1000558F4(&v7);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v5) < 0) {
    operator delete(v4[0]);
  }
  CPRecordSetProperty();
  return sub_1000558F4(&v6);
}

void sub_10110AB40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_10110ABA4(uint64_t a1, int a2, unsigned int a3)
{
  Property = (uint64_t *)CPRecordGetProperty();
  if (Property)
  {
    long long v7 = Property;
    CFTypeID v8 = CFGetTypeID(Property);
    if (v8 == CFNumberGetTypeID()) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  unint64_t valuePtr = 0;
  ctu::cf::assign((ctu::cf *)&valuePtr, v9, v6);
  if ((a3 | a2) == a2)
  {
    CFNumberRef v14 = 0;
    unint64_t valuePtr = valuePtr & ~a2 | (unint64_t)a3;
    CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v10)
    {
      unint64_t v11 = (unint64_t)v14;
      CFNumberRef v14 = v10;
      unint64_t valuePtr = v11;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v13 = v14;
    CFNumberRef v14 = 0;
    sub_1000570E8((const void **)&v14);
    CPRecordSetProperty();
    sub_1000570E8((const void **)&v13);
  }
  else
  {
    sub_101107E4C();
    int v12 = qword_101B131A8;
    if (os_log_type_enabled((os_log_t)qword_101B131A8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(valuePtr) = 67109376;
      HIDWORD(valuePtr) = a3;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Value (0x%08X) has bits set outside of the mask (0x%08X)", (uint8_t *)&valuePtr, 0xEu);
    }
  }
}

void sub_10110AD2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_10110AD58()
{
}

void *sub_10110AD6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A8F898;
  result[1] = v3;
  return result;
}

uint64_t sub_10110ADB4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A8F898;
  a2[1] = v2;
  return result;
}

uint64_t sub_10110ADE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const char **)(a1 + 8);
  if (v2[23] < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  return sqlite3_bind_text(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_10110AE08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110AE48()
{
}

void sub_10110AE58()
{
}

__n128 sub_10110AE6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A8F918;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_10110AEC8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8F918;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110AF08(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (CFArrayGetCount(*a2) >= 1)
  {
    uint64_t v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFNumberRef v6 = *(uint64_t **)(a1 + 16);
      if (*((char *)v6 + 23) < 0) {
        CFNumberRef v6 = (uint64_t *)*v6;
      }
      int v7 = **(_DWORD **)(a1 + 24);
      int v9 = 136446466;
      CFNumberRef v10 = v6;
      __int16 v11 = 1024;
      int v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating bundle entry: %{public}s with notification state set to: 0x%08X", (uint8_t *)&v9, 0x12u);
    }
    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    sub_10110ABA4((uint64_t)ValueAtIndex, **(_DWORD **)(a1 + 32), **(_DWORD **)(a1 + 24));
    **(unsigned char **)(a1 + 40) = 0;
  }
}

uint64_t sub_10110B00C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B04C()
{
}

void sub_10110B05C()
{
}

void *sub_10110B070(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A8F998;
  result[1] = v3;
  return result;
}

uint64_t sub_10110B0B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A8F998;
  a2[1] = v2;
  return result;
}

uint64_t sub_10110B0E4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const char **)(a1 + 8);
  if (v2[23] < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  return sqlite3_bind_text(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_10110B10C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B14C()
{
}

void sub_10110B15C()
{
}

__n128 sub_10110B170(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A8FA18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_10110B1CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FA18;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110B20C(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (CFArrayGetCount(*a2) >= 1)
  {
    uint64_t v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFNumberRef v6 = *(uint64_t **)(a1 + 16);
      if (*((char *)v6 + 23) < 0) {
        CFNumberRef v6 = (uint64_t *)*v6;
      }
      int v7 = **(_DWORD **)(a1 + 24);
      int v9 = 136446466;
      CFNumberRef v10 = v6;
      __int16 v11 = 1024;
      int v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating bundle entry: %{public}s with notification state set to: 0x%08X", (uint8_t *)&v9, 0x12u);
    }
    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    sub_10110ABA4((uint64_t)ValueAtIndex, **(_DWORD **)(a1 + 32), **(_DWORD **)(a1 + 24));
    **(unsigned char **)(a1 + 40) = 0;
  }
}

uint64_t sub_10110B310(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B350()
{
}

void sub_10110B360()
{
}

void *sub_10110B374()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A8FA98;
  return result;
}

void sub_10110B3AC(uint64_t a1, void *a2)
{
  *a2 = off_101A8FA98;
}

uint64_t sub_10110B3D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B418()
{
}

void sub_10110B428()
{
}

__n128 sub_10110B43C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A8FB18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110B488(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FB18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110B4B8(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  CFIndex Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; v6 != i; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = (const void *)CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v23 = 0;
      memset(buf, 0, sizeof(buf));
      uint64_t v25 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v23 = v25;
      int v9 = (uint64_t *)CPRecordGetProperty();
      __int16 v11 = v9;
      if (v9)
      {
        CFTypeID v12 = CFGetTypeID(v9);
        if (v12 == CFNumberGetTypeID()) {
          CFNumberRef v13 = v11;
        }
        else {
          CFNumberRef v13 = 0;
        }
      }
      else
      {
        CFNumberRef v13 = 0;
      }
      *(void *)buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v13, v10);
      if ((buf[0] & 0x14) == 0x10)
      {
        int v17 = *(uint64_t ***)(a1 + 16);
        *(void *)buf = __p;
        *((_DWORD *)sub_100BA51AC(v17, __p, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = 0;
      }
      else
      {
        if ((buf[0] & 0x14) == 4)
        {
          int v18 = *(uint64_t ***)(a1 + 16);
          *(void *)buf = __p;
          uint64_t v15 = sub_100BA51AC(v18, __p, (uint64_t)&unk_10144E20E, (long long **)buf);
          int v16 = 2;
        }
        else
        {
          if ((buf[0] & 0x14) != 0)
          {
            int v19 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              if (v23 >= 0) {
                uint64_t v20 = __p;
              }
              else {
                uint64_t v20 = (void **)__p[0];
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Invalid authorization state for %{public}s", buf, 0xCu);
            }
            uint64_t v21 = *(uint64_t ***)(a1 + 16);
            *(void *)buf = __p;
            *((_DWORD *)sub_100BA51AC(v21, __p, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = 0;
            sub_101106520(v4, (uint64_t)__p, 0);
            goto LABEL_23;
          }
          CFNumberRef v14 = *(uint64_t ***)(a1 + 16);
          *(void *)buf = __p;
          uint64_t v15 = sub_100BA51AC(v14, __p, (uint64_t)&unk_10144E20E, (long long **)buf);
          int v16 = 1;
        }
        *((_DWORD *)v15 + 14) = v16;
      }
LABEL_23:
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10110B744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10110B780(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B7C0()
{
}

void sub_10110B7D0()
{
}

void *sub_10110B7E4()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A8FB98;
  return result;
}

void sub_10110B81C(uint64_t a1, void *a2)
{
  *a2 = off_101A8FB98;
}

uint64_t sub_10110B848(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110B888()
{
}

void sub_10110B898()
{
}

__n128 sub_10110B8AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A8FC18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110B8F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FC18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110B928(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  CFIndex Count = CFArrayGetCount(*a2);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; v6 != i; ++i)
    {
      CFArrayGetValueAtIndex(v3, i);
      Property = (const void *)CPRecordGetProperty();
      if (Property)
      {
        CFGetTypeID(Property);
        CFStringGetTypeID();
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v23 = 0;
      memset(buf, 0, sizeof(buf));
      uint64_t v25 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v23 = v25;
      int v9 = (uint64_t *)CPRecordGetProperty();
      __int16 v11 = v9;
      if (v9)
      {
        CFTypeID v12 = CFGetTypeID(v9);
        if (v12 == CFNumberGetTypeID()) {
          CFNumberRef v13 = v11;
        }
        else {
          CFNumberRef v13 = 0;
        }
      }
      else
      {
        CFNumberRef v13 = 0;
      }
      *(void *)buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v13, v10);
      if ((buf[0] & 0x28) == 0x20)
      {
        int v17 = *(uint64_t ***)(a1 + 16);
        *(void *)buf = __p;
        *((_DWORD *)sub_100BA51AC(v17, __p, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = 0;
      }
      else
      {
        if ((buf[0] & 0x28) == 8)
        {
          int v18 = *(uint64_t ***)(a1 + 16);
          *(void *)buf = __p;
          uint64_t v15 = sub_100BA51AC(v18, __p, (uint64_t)&unk_10144E20E, (long long **)buf);
          int v16 = 2;
        }
        else
        {
          if ((buf[0] & 0x28) != 0)
          {
            int v19 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              if (v23 >= 0) {
                uint64_t v20 = __p;
              }
              else {
                uint64_t v20 = (void **)__p[0];
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Invalid authorization state for %{public}s", buf, 0xCu);
            }
            uint64_t v21 = *(uint64_t ***)(a1 + 16);
            *(void *)buf = __p;
            *((_DWORD *)sub_100BA51AC(v21, __p, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = 0;
            sub_10110672C(v4, (uint64_t)__p, 0);
            goto LABEL_23;
          }
          CFNumberRef v14 = *(uint64_t ***)(a1 + 16);
          *(void *)buf = __p;
          uint64_t v15 = sub_100BA51AC(v14, __p, (uint64_t)&unk_10144E20E, (long long **)buf);
          int v16 = 1;
        }
        *((_DWORD *)v15 + 14) = v16;
      }
LABEL_23:
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10110BBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10110BBF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110BC30()
{
}

void sub_10110BC40()
{
}

__n128 sub_10110BC54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A8FC98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110BCA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FC98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10110BCD0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(const char **)(a1 + 8);
  if (v4[23] < 0) {
    uint64_t v4 = *(const char **)v4;
  }
  uint64_t result = sqlite3_bind_text(*(sqlite3_stmt **)(*a2 + 8), 1, v4, -1, 0);
  CFIndex v6 = *(uint64_t **)(a1 + 16);
  if (*((char *)v6 + 23) < 0)
  {
    if (!v6[1]) {
      return result;
    }
    CFIndex v6 = (uint64_t *)*v6;
  }
  else if (!*((unsigned char *)v6 + 23))
  {
    return result;
  }
  int v7 = *(sqlite3_stmt **)(v3 + 8);

  return sqlite3_bind_text(v7, 2, (const char *)v6, -1, 0);
}

uint64_t sub_10110BD64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110BDA4()
{
}

void sub_10110BDB4()
{
}

__n128 sub_10110BDC8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = off_101A8FD18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 sub_10110BE2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FD18;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110BE74(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (CFArrayGetCount(*a2) < 1) {
    return;
  }
  uint64_t v29 = a1;
  uint64_t v30 = v4;
  if (CFArrayGetCount(v3) < 2) {
    goto LABEL_20;
  }
  CFIndex Count = CFArrayGetCount(v3);
  if (Count < 1) {
    goto LABEL_20;
  }
  CFIndex v6 = Count;
  CFIndex v7 = 0;
  v31 = 0;
  CFTypeID v8 = 0;
  BOOL v9 = 1;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, v7);
    Property = (const void *)CPRecordGetProperty();
    uint64_t v12 = CPRecordGetProperty();
    if (!Property) {
      goto LABEL_19;
    }
    CFNumberRef v13 = (const void *)v12;
    CFTypeID v14 = CFGetTypeID(Property);
    CFStringRef v15 = v14 == CFStringGetTypeID() ? (const __CFString *)Property : 0;
    if (!CFStringGetLength(v15)) {
      goto LABEL_19;
    }
    if (v13)
    {
      CFTypeID v16 = CFGetTypeID(v13);
      CFStringRef v17 = v16 == CFStringGetTypeID() ? (const __CFString *)v13 : 0;
      if (CFStringGetLength(v17))
      {
        CFTypeID v8 = ValueAtIndex;
        ValueAtIndex = v31;
      }
    }
    if (v8 && ValueAtIndex) {
      break;
    }
    v31 = ValueAtIndex;
LABEL_19:
    BOOL v9 = ++v7 < v6;
    if (v6 == v7) {
      goto LABEL_20;
    }
  }
  CPRecordStoreRemoveRecord();
  if (v9)
  {
    **(unsigned char **)(v29 + 16) = 1;
    return;
  }
LABEL_20:
  int v18 = CFArrayGetValueAtIndex(v3, 0);
  int v19 = (unsigned int *)CPRecordGetProperty();
  if (v19)
  {
    uint64_t v21 = v19;
    CFTypeID v22 = CFGetTypeID(v19);
    if (v22 == CFNumberGetTypeID()) {
      uint64_t v23 = v21;
    }
    else {
      uint64_t v23 = 0;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  *(_DWORD *)buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v23, v20);
  **(_DWORD **)(v29 + 24) = *(_DWORD *)buf;
  if (**(unsigned char **)(v29 + 32))
  {
    sub_101106E04((uint64_t)v18, 0, *(void *)(v29 + 40));
    sub_101106E04((uint64_t)v18, 1, *(void *)(v29 + 48));
    double Current = CFAbsoluteTimeGetCurrent();
    sub_101106FBC(Current);
  }
  **(unsigned char **)(v29 + 56) = 1;
  uint64_t v25 = *(NSObject **)(v30 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = *(uint64_t **)(v29 + 40);
    if (*((char *)v26 + 23) < 0) {
      v26 = (uint64_t *)*v26;
    }
    unsigned int v27 = *(uint64_t **)(v29 + 48);
    if (*((char *)v27 + 23) < 0) {
      unsigned int v27 = (uint64_t *)*v27;
    }
    int v28 = **(_DWORD **)(v29 + 24);
    *(_DWORD *)buf = 136315650;
    uint64_t v33 = v26;
    __int16 v34 = 2080;
    int v35 = v27;
    __int16 v36 = 1024;
    int v37 = v28;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Found best match for subscriber %s and mdn %s with tag: %u", buf, 0x1Cu);
  }
}

uint64_t sub_10110C130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110C170()
{
}

void sub_10110C180()
{
}

void *sub_10110C194(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A8FD98;
  result[1] = v3;
  return result;
}

uint64_t sub_10110C1DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A8FD98;
  a2[1] = v2;
  return result;
}

uint64_t sub_10110C208(uint64_t a1, uint64_t a2)
{
  return sqlite3_bind_int64(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, **(int **)(a1 + 8));
}

uint64_t sub_10110C224(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110C264()
{
}

void sub_10110C274()
{
}

__n128 sub_10110C288(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A8FE18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10110C2DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FE18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110C314(uint64_t a1, const __CFArray **a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFIndex Count = CFArrayGetCount(v3);
    uint64_t v7 = **(void **)(a1 + 16);
    int v8 = **(_DWORD **)(a1 + 24);
    int v16 = 134218496;
    CFIndex v17 = Count;
    __int16 v18 = 2048;
    uint64_t v19 = v7;
    __int16 v20 = 1024;
    int v21 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Found: %ld subscriber records in the database. Maximum allowed are: %lu for slot index: %d", (uint8_t *)&v16, 0x1Cu);
  }
  if (CFArrayGetCount(v3) > **(void **)(a1 + 16))
  {
    CFArrayGetValueAtIndex(v3, 0);
    Property = (unsigned int *)CPRecordGetProperty();
    if (Property)
    {
      __int16 v11 = Property;
      CFTypeID v12 = CFGetTypeID(Property);
      if (v12 == CFNumberGetTypeID()) {
        CFNumberRef v13 = v11;
      }
      else {
        CFNumberRef v13 = 0;
      }
    }
    else
    {
      CFNumberRef v13 = 0;
    }
    int v16 = 0;
    ctu::cf::assign((ctu::cf *)&v16, v13, v10);
    **(_DWORD **)(a1 + 32) = v16;
    CPRecordStoreRemoveRecord();
    CFTypeID v14 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = **(_DWORD **)(a1 + 32);
      int v16 = 67109120;
      LODWORD(v17) = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Removing old subscriber with tag: %u", (uint8_t *)&v16, 8u);
    }
  }
}

uint64_t sub_10110C4C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110C500()
{
}

void sub_10110C510()
{
}

__n128 sub_10110C524(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A8FE98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110C570(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FE98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10110C5A0(uint64_t a1, void *a2)
{
  return _CPSqliteConnectionSetValueForProperty(*a2, *(void *)(a1 + 16), *(void *)(a1 + 8));
}

uint64_t sub_10110C5B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110C5F0()
{
}

void *sub_10110C5FC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10110C684()
{
}

__n128 sub_10110C698(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A8FF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110C6E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A8FF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10110C714()
{
  return CPSqliteConnectionSetIntegerForProperty();
}

uint64_t sub_10110C728(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10110C768()
{
}

void sub_10110C778()
{
}

void *sub_10110C78C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A8FFA8;
  result[1] = v3;
  return result;
}

uint64_t sub_10110C7D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A8FFA8;
  a2[1] = v2;
  return result;
}

uint64_t sub_10110C800(uint64_t a1, uint64_t a2)
{
  return sqlite3_bind_int(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, **(_DWORD **)(a1 + 8));
}

uint64_t sub_10110C81C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10110C85C()
{
}

void sub_10110C86C()
{
}

void *sub_10110C880(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A90028;
  result[1] = v3;
  return result;
}

uint64_t sub_10110C8C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A90028;
  a2[1] = v2;
  return result;
}

CFIndex sub_10110C8F4(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  CFIndex result = CFArrayGetCount(*a2);
  if (result >= 1)
  {
    CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    return (CFIndex)sub_100057DAC(*(const void ***)(a1 + 8), &ValueAtIndex);
  }
  return result;
}

uint64_t sub_10110C94C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10110C98C()
{
}

void sub_10110C99C()
{
}

__n128 sub_10110C9B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A900A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10110C9FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A900A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10110CA2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(const char **)(a1 + 8);
  if (v4[23] < 0) {
    uint64_t v4 = *(const char **)v4;
  }
  sqlite3_bind_text(*(sqlite3_stmt **)(*a2 + 8), 1, v4, -1, 0);
  uint64_t v5 = *(sqlite3_stmt **)(v3 + 8);
  CFIndex v6 = *(const char **)(a1 + 16);
  if (v6[23] < 0) {
    CFIndex v6 = *(const char **)v6;
  }

  return sqlite3_bind_text(v5, 2, v6, -1, 0);
}

uint64_t sub_10110CAA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110CAE4()
{
}

void sub_10110CAF4()
{
}

__n128 sub_10110CB08(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A90128;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10110CB5C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A90128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110CB94(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (CFArrayGetCount(*a2) >= 1)
  {
    *(void *)BOOL v9 = CFArrayGetValueAtIndex(v3, 0);
    sub_100057DAC(*(const void ***)(a1 + 8), (CFTypeRef *)v9);
    double Current = CFAbsoluteTimeGetCurrent();
    sub_101106FBC(Current);
    CFIndex v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(uint64_t ***)(a1 + 24);
      if (*((char *)v7 + 23) < 0) {
        uint64_t v7 = (uint64_t **)*v7;
      }
      int v8 = *(uint64_t **)(a1 + 32);
      if (*((char *)v8 + 23) < 0) {
        int v8 = (uint64_t *)*v8;
      }
      *(_DWORD *)BOOL v9 = 136315394;
      *(void *)&void v9[4] = v7;
      __int16 v10 = 2080;
      __int16 v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Found exact match for subscriber %s and mdn %s", v9, 0x16u);
    }
  }
}

uint64_t sub_10110CCAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110CCEC()
{
}

void sub_10110CCFC()
{
}

void *sub_10110CD10(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A901A8;
  result[1] = v3;
  return result;
}

uint64_t sub_10110CD58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A901A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_10110CD84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const char **)(a1 + 8);
  if (v2[23] < 0) {
    uint64_t v2 = *(const char **)v2;
  }
  return sqlite3_bind_text(*(sqlite3_stmt **)(*(void *)a2 + 8), 1, v2, -1, 0);
}

uint64_t sub_10110CDB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110CDF0()
{
}

void sub_10110CE00()
{
}

__n128 sub_10110CE14(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A90228;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10110CE68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A90228;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10110CEA0(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (CFArrayGetCount(*a2) >= 1)
  {
    *(void *)int v8 = CFArrayGetValueAtIndex(v3, 0);
    sub_100057DAC(*(const void ***)(a1 + 8), (CFTypeRef *)v8);
    double Current = CFAbsoluteTimeGetCurrent();
    sub_101106FBC(Current);
    CFIndex v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(uint64_t ***)(a1 + 24);
      if (*((char *)v7 + 23) < 0) {
        uint64_t v7 = (uint64_t **)*v7;
      }
      *(_DWORD *)int v8 = 136315138;
      *(void *)&v8[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Found exact match for subscriber %s and no mdn", v8, 0xCu);
    }
  }
}

uint64_t sub_10110CF9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10110CFDC()
{
}

void sub_10110CFE8(void *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  id v6 = a1;
  uint64_t v5 = operator new(0x48uLL);
  v5[1] = 0;
  v5[2] = 0;
  *uint64_t v5 = off_101A902E8;
  *a3 = sub_1007B996C(v5 + 3, v6, a2);
  a3[1] = v5;
}

void sub_10110D074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);

  _Unwind_Resume(a1);
}

void sub_10110D0A0(DataUsageCacheManagerFactoryInterface *a1)
{
  DataUsageCacheManagerFactoryInterface::~DataUsageCacheManagerFactoryInterface(a1);

  operator delete();
}

void sub_10110D0D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A902E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10110D0F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A902E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10110D14C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

BOOL sub_10110D174(void **a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v4 = (void *)*v1;
  uint64_t v2 = v1 + 1;
  CFArrayRef v3 = v4;
  if (v4 == v2) {
    return 0;
  }
  do
  {
    BOOL result = *((unsigned char *)v3 + 64) == 0;
    if (!*((unsigned char *)v3 + 64)) {
      break;
    }
    id v6 = (void *)v3[1];
    if (v6)
    {
      do
      {
        uint64_t v7 = v6;
        id v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        uint64_t v7 = (void *)v3[2];
        BOOL v8 = *v7 == (void)v3;
        CFArrayRef v3 = v7;
      }
      while (!v8);
    }
    CFArrayRef v3 = v7;
  }
  while (v7 != v2);
  return result;
}

void **sub_10110D1DC@<X0>(void **result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *result;
  if (!*result) {
    goto LABEL_15;
  }
  uint64_t v7 = (void *)*v4;
  uint64_t v5 = v4 + 1;
  id v6 = v7;
  if (v7 != v5)
  {
    while (*((_DWORD *)v6 + 8) != a2)
    {
      BOOL v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          BOOL v9 = v8;
          BOOL v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          BOOL v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          id v6 = v9;
        }
        while (!v10);
      }
      id v6 = v9;
      if (v9 == v5) {
        goto LABEL_14;
      }
    }
  }
  if (v6 == v5)
  {
LABEL_14:
    LOBYTE(v4) = 0;
LABEL_15:
    *(unsigned char *)a3 = 0;
    goto LABEL_18;
  }
  if (*((char *)v6 + 63) < 0)
  {
    BOOL result = (void **)sub_10004FC84((unsigned char *)a3, (void *)v6[5], v6[6]);
  }
  else
  {
    long long v11 = *(_OWORD *)(v6 + 5);
    *(void *)(a3 + 16) = v6[7];
    *(_OWORD *)a3 = v11;
  }
  LOBYTE(v4) = 1;
LABEL_18:
  *(unsigned char *)(a3 + 24) = (_BYTE)v4;
  return result;
}

uint64_t sub_10110D2A0(void **a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v4 = (unsigned __int8 *)(v2 + 1);
  CFArrayRef v3 = (unsigned __int8 *)*v2;
  if ((void *)*v2 != v2 + 1)
  {
    while (!sub_10001D294(v3 + 40, a2))
    {
      uint64_t v7 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (unsigned __int8 *)*((void *)v3 + 2);
          BOOL v9 = *(void *)v8 == (void)v3;
          CFArrayRef v3 = v8;
        }
        while (!v9);
      }
      CFArrayRef v3 = v8;
      if (v8 == v4)
      {
        CFArrayRef v3 = v4;
        break;
      }
    }
    uint64_t v2 = *a1;
  }
  if (v3 == (unsigned __int8 *)(v2 + 1)) {
    return 0;
  }
  else {
    return *((unsigned int *)v3 + 8);
  }
}

const void **sub_10110D34C(uint64_t a1, int a2, const void **a3)
{
  *(void *)int v16 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v7 = *(__CFDictionary **)v16;
    *(void *)int v16 = Mutable;
    *(void *)buf = v7;
    sub_10005717C((const void **)buf);
  }
  if (a2 == 1) {
    __int16 v8 = 13;
  }
  else {
    __int16 v8 = 12;
  }
  *(_WORD *)(a1 + 48) = v8;
  CFTypeRef v15 = 0;
  sub_100BE0CF4(a3, &v15);
  if (v15) {
    BOOL v9 = sub_100080778;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    sub_1001C6A4C(*(__CFDictionary **)v16, @"MessagePayload", (uint64_t)v15);
  }
  else
  {
    sub_10110D508();
    BOOL v10 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "The message doesn't have a payload", buf, 2u);
    }
  }
  sub_10004EFE4(&v13, (CFTypeRef *)v16);
  sub_10110D5A0(&v14, v13);
  long long v11 = (void *)(a1 + 56);
  if ((const void **)(a1 + 56) != &v14)
  {
    *(void *)buf = *v11;
    void *v11 = v14;
    CFTypeID v14 = 0;
    sub_100030068((const void **)buf);
  }
  sub_100030068(&v14);
  sub_100057D78((const void **)&v13);
  sub_100057D78(&v15);
  return sub_10005717C((const void **)v16);
}

void sub_10110D4C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_10110D508()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B131F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B131F8))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B131F0, kCtLoggingSystemName, "lasd.ids.msg");
    __cxa_guard_release(&qword_101B131F8);
  }
}

void sub_10110D588(_Unwind_Exception *a1)
{
}

void sub_10110D5A0(void *a1, void *a2)
{
  id v3 = a2;
  id v12 = 0;
  uint64_t v4 = +[NSKeyedArchiver archivedDataWithRootObject:v3 requiringSecureCoding:1 error:&v12];
  id v5 = v12;
  id v6 = v5;
  if (v4)
  {
    if (!v5)
    {
      *a1 = v4;
      CFRetain(v4);
      goto LABEL_8;
    }
    sub_10110D508();
    uint64_t v7 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      CFTypeID v14 = v6;
      __int16 v8 = "Error archiving message dictionary : %@";
      BOOL v9 = v7;
      uint32_t v10 = 12;
LABEL_10:
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
    }
  }
  else
  {
    sub_10110D508();
    uint64_t v11 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      __int16 v8 = "nil data";
      BOOL v9 = v11;
      uint32_t v10 = 2;
      goto LABEL_10;
    }
  }
  *a1 = 0;
LABEL_8:
}

void sub_10110D6FC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10110D73C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFDictionaryRef theDict = 0;
  sub_10002FD9C((const void **)&v13, (const void **)(a1 + 56));
  sub_10110D930(&theDict, v13);
  sub_100030068((const void **)&v13);
  if (theDict) {
    id v3 = sub_100080778;
  }
  else {
    id v3 = 0;
  }
  if (v3)
  {
    Value = CFDictionaryGetValue(theDict, @"MessagePayload");
    id v5 = Value;
    if (Value && (CFTypeID v6 = CFGetTypeID(Value), v6 == CFDictionaryGetTypeID()))
    {
      *(void *)buf = v5;
      uint64_t v7 = sub_100080778;
      CFRetain(v5);
    }
    else
    {
      uint64_t v7 = 0;
      *(void *)buf = 0;
    }
    if (v7)
    {
      sub_100BE0F3C((CFDictionaryRef *)buf, (uint64_t)a2);
    }
    else
    {
      sub_10110D508();
      BOOL v9 = qword_101B131F0;
      if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get version info", v11, 2u);
      }
      a2[2] = 0;
      a2[1] = 0;
      *a2 = a2 + 1;
    }
    sub_100057D78((const void **)buf);
  }
  else
  {
    sub_10110D508();
    __int16 v8 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to decode the message", buf, 2u);
    }
    a2[2] = 0;
    a2[1] = 0;
    *a2 = a2 + 1;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_10110D8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_10110D930(void *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v12 = 0;
    id v4 = [objc_alloc((Class)NSKeyedUnarchiver) initForReadingFromData:v3 error:&v12];
    id v5 = v12;
    if (v5)
    {
      sub_10110D508();
      uint64_t v6 = qword_101B131F0;
      if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        id v14 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Error creating the UnArchiver : %@", buf, 0xCu);
      }
      *a1 = 0;
    }
    else
    {
      [v4 setRequiresSecureCoding:1];
      uint64_t v8 = objc_opt_class();
      BOOL v9 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v8, objc_opt_class(), 0);
      uint32_t v10 = [v4 decodeObjectOfClasses:v9 forKey:NSKeyedArchiveRootObjectKey];

      if (v10)
      {
        *a1 = v10;
        CFRetain(v10);
      }
      else
      {
        sub_10110D508();
        uint64_t v11 = qword_101B131F0;
        if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "message dictionary is nil", buf, 2u);
        }
        *a1 = 0;
      }
    }
  }
  else
  {
    sub_10110D508();
    uint64_t v7 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Message data is NULL", buf, 2u);
    }
    *a1 = 0;
  }
}

void sub_10110DB64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **sub_10110DBC0(uint64_t a1, int a2, const void **a3, const char *a4)
{
  int v21 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    BOOL v9 = v21;
    int v21 = Mutable;
    *(void *)buf = v9;
    sub_10005717C((const void **)buf);
  }
  if (a2 == 1) {
    __int16 v10 = 15;
  }
  else {
    __int16 v10 = 14;
  }
  *(_WORD *)(a1 + 48) = v10;
  uint64_t v20 = 0;
  sub_100BE0CF4(a3, &v20);
  sub_1001C6A4C(v21, @"MessagePayload", v20);
  if (a4[23] < 0) {
    a4 = *(const char **)a4;
  }
  CFStringRef v19 = CFStringCreateWithCString(kCFAllocatorDefault, a4, 0x8000100u);
  CFURLRef v18 = CFURLCreateWithFileSystemPath(0, v19, kCFURLPOSIXPathStyle, 0);
  if (v18) {
    uint64_t v11 = sub_1000FCC20;
  }
  else {
    uint64_t v11 = 0;
  }
  if (v11 && (v19 ? (id v12 = sub_1000810B8) : (id v12 = 0), v12))
  {
    sub_1003C4D24((const void **)(a1 + 64), (const void **)&v18);
    sub_10004EFE4(&v16, (CFTypeRef *)&v21);
    sub_10110D5A0(&v17, v16);
    CFNumberRef v13 = (void *)(a1 + 56);
    if ((const void **)(a1 + 56) != &v17)
    {
      *(void *)buf = *v13;
      *CFNumberRef v13 = v17;
      CFIndex v17 = 0;
      sub_100030068((const void **)buf);
    }
    sub_100030068(&v17);
    sub_100057D78((const void **)&v16);
  }
  else
  {
    sub_10110D508();
    id v14 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid db path, cannot send the db file", buf, 2u);
    }
  }
  sub_1000FE824((const void **)&v18);
  sub_1000558F4((const void **)&v19);
  sub_100057D78((const void **)&v20);
  return sub_10005717C((const void **)&v21);
}

void sub_10110DDBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12, const void *a13, const void *a14)
{
}

const void **sub_10110DE1C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFDictionaryRef v30 = 0;
  sub_10002FD9C((const void **)&v29, (const void **)(a1 + 56));
  sub_10110D930(&v30, v29);
  sub_100030068((const void **)&v29);
  if (v30) {
    id v4 = sub_100080778;
  }
  else {
    id v4 = 0;
  }
  if (v4)
  {
    int v28 = 0;
    Value = CFDictionaryGetValue(v30, @"MessagePayload");
    uint64_t v6 = Value;
    if (Value && (CFTypeID v7 = CFGetTypeID(Value), v7 == CFDictionaryGetTypeID()))
    {
      int v28 = v6;
      CFRetain(v6);
      uint64_t v8 = v6;
    }
    else
    {
      uint64_t v8 = 0;
      int v28 = 0;
    }
    if (v8) {
      BOOL v9 = sub_100080778;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9)
    {
      sub_10110D508();
      CFNumberRef v13 = qword_101B131F0;
      if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v20[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get the bundle info", (uint8_t *)v20, 2u);
      }
      a2[2] = 0;
      a2[1] = 0;
      *a2 = a2 + 1;
      goto LABEL_42;
    }
    uint64_t v25 = 0;
    v26 = 0;
    uint64_t v27 = 0;
    sub_100BE0F3C((CFDictionaryRef *)&v28, (uint64_t)&v25);
    if (v27 == 1)
    {
      CFURLRef v14 = *(const __CFURL **)(a1 + 64);
      if (v14)
      {
        CFStringRef v24 = CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
        v20[0] = 0;
        v20[1] = 0;
        __p[0] = 0;
        ctu::cf::assign();
        v23[0] = 0;
        *(_DWORD *)((char *)v23 + 3) = 0;
        a2[1] = 0;
        CFTypeRef v15 = v25;
        *a2 = a2 + 1;
        a2[2] = 0;
        if (v15 != &v26)
        {
          do
          {
            *(_OWORD *)long long __p = 0u;
            long long v22 = 0u;
            *(_OWORD *)uint64_t v20 = 0u;
            if (*((char *)v15 + 63) < 0)
            {
              sub_10004FC84(v20, v15[5], (unint64_t)v15[6]);
            }
            else
            {
              *(_OWORD *)uint64_t v20 = *(_OWORD *)(v15 + 5);
              __p[0] = v15[7];
            }
            __p[1] = 0;
            *(void *)&long long v22 = 0;
            DWORD2(v22) = v23[0];
            *(_DWORD *)((char *)&v22 + 11) = *(_DWORD *)((char *)v23 + 3);
            HIBYTE(v22) = 0;
            sub_100A0B5C4((uint64_t)a2, (int *)v15 + 8, (_DWORD *)v15 + 8, (long long *)v20);
            if (SHIBYTE(v22) < 0) {
              operator delete(__p[1]);
            }
            if (SHIBYTE(__p[0]) < 0) {
              operator delete(v20[0]);
            }
            int v16 = v15[1];
            if (v16)
            {
              do
              {
                CFIndex v17 = (char **)v16;
                int v16 = *(char **)v16;
              }
              while (v16);
            }
            else
            {
              do
              {
                CFIndex v17 = (char **)v15[2];
                BOOL v18 = *v17 == (char *)v15;
                CFTypeRef v15 = v17;
              }
              while (!v18);
            }
            CFTypeRef v15 = v17;
          }
          while (v17 != &v26);
        }
        sub_1000558F4((const void **)&v24);
        goto LABEL_41;
      }
      sub_10110D508();
      __int16 v10 = qword_101B131F0;
      if (!os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
      {
LABEL_40:
        a2[2] = 0;
        a2[1] = 0;
        *a2 = a2 + 1;
LABEL_41:
        sub_1000886C0((uint64_t)&v25, v26);
LABEL_42:
        sub_100057D78(&v28);
        return sub_100057D78((const void **)&v30);
      }
      LOWORD(v20[0]) = 0;
      uint64_t v11 = "Invalid resource URL";
    }
    else
    {
      if (!v27) {
        goto LABEL_40;
      }
      sub_10110D508();
      __int16 v10 = qword_101B131F0;
      if (!os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR)) {
        goto LABEL_40;
      }
      LOWORD(v20[0]) = 0;
      uint64_t v11 = "Only 1 file and metadata are expected at a time";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)v20, 2u);
    goto LABEL_40;
  }
  sub_10110D508();
  id v12 = qword_101B131F0;
  if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to decode the message", (uint8_t *)v20, 2u);
  }
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  return sub_100057D78((const void **)&v30);
}

void sub_10110E1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,char *a24,uint64_t a25,const void *a26)
{
  sub_1000886C0((uint64_t)&a21, a24);
  sub_100057D78(&a26);
  sub_100057D78((const void **)(v26 - 72));
  _Unwind_Resume(a1);
}

uint64_t sub_10110E2B8(uint64_t a1)
{
  BOOL v9 = 0;
  sub_10002FD9C((const void **)&v8, (const void **)(a1 + 56));
  sub_10110D930(&v9, v8);
  sub_100030068((const void **)&v8);
  if (v9) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    unsigned __int16 v3 = *(_WORD *)(a1 + 48) - 12;
    if (v3 <= 3u) {
      unsigned __int8 v4 = v3 + 1;
    }
    else {
      unsigned __int8 v4 = 0;
    }
  }
  else
  {
    sub_10110D508();
    id v5 = qword_101B131F0;
    if (os_log_type_enabled((os_log_t)qword_101B131F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeID v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to decode the message", v7, 2u);
    }
    unsigned __int8 v4 = 0;
  }
  sub_100057D78(&v9);
  return v4;
}

void sub_10110E394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10110E3B8(uint64_t a1, void *a2)
{
  sub_100058DB0(&__p, "com.apple.commcenter.cupolicy.xpc");
  xpc_object_t mach_service = xpc_connection_create_mach_service("com.apple.commcenter.cupolicy.xpc", 0, 1uLL);
  if (!mach_service) {
    xpc_object_t mach_service = xpc_null_create();
  }
  dispatch_object_t object = 0;
  ctu::XpcServer::XpcServer();
  xpc_release(mach_service);
  xpc_object_t mach_service = 0;
  if (v11 < 0) {
    operator delete(__p.var0);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "na.policy.xpc");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 80), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)a1 = off_101A90338;
  *(void *)(a1 + 8) = off_101A90390;
  unsigned __int8 v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UNSPECIFIED, 0);
  dispatch_queue_t v5 = dispatch_queue_create_with_target_V2("ConcreteNetworkAccessPolicyServer", v4, *(dispatch_queue_t *)(a1 + 32));
  *(void *)a1 = off_101A90338;
  *(void *)(a1 + 8) = off_101A90390;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v5;
  *(void *)(a1 + 96) = a1 + 104;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 136) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 144) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10110E568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  ctu::XpcServer::~XpcServer(v18);
  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(v17);
  _Unwind_Resume(a1);
}

void sub_10110E5EC()
{
}

void sub_10110E658()
{
}

void sub_10110E67C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
  }
  operator new();
}

void sub_10110E718(uint64_t a1, dispatch_object_t *a2)
{
  unsigned __int16 v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  unsigned __int8 v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10110E818(uint64_t a1@<X0>, xpc_connection_t *a2@<X1>, void **a3@<X8>)
{
  pid_t pid = xpc_connection_get_pid(*a2);
  BOOL v7 = sub_1012F638C((xpc_object_t *)a2);
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t object = v8;
  uint64_t v29 = 0;
  memset(buffer, 0, sizeof(buffer));
  if (proc_pidinfo(pid, 17, 1uLL, buffer, 56) == 56)
  {
    xpc_object_t v9 = xpc_uuid_create((const unsigned __int8 *)buffer);
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    xpc_object_t object = v9;
    xpc_release(v8);
  }
  else
  {
    uu[0] = 0uLL;
    uuid_clear((unsigned __int8 *)uu);
    xpc_object_t v10 = xpc_uuid_create((const unsigned __int8 *)uu);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    xpc_object_t object = v10;
    xpc_release(v8);
    char v11 = *(NSObject **)(a1 + 80);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = pid;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unable to extract macho uuid for pid: %d, defaulting to all 0 uuid", (uint8_t *)__p, 8u);
    }
  }
  id v12 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    xpc_connection_t v13 = *a2;
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    CFURLRef v14 = "false";
    if (v7) {
      CFURLRef v14 = "true";
    }
    LODWORD(uu[0]) = 134218754;
    if (v27 >= 0) {
      CFTypeRef v15 = __p;
    }
    else {
      CFTypeRef v15 = (void **)__p[0];
    }
    *(void *)((char *)uu + 4) = v13;
    WORD6(uu[0]) = 1024;
    *(_DWORD *)((char *)uu + 14) = pid;
    WORD1(uu[1]) = 2080;
    *(void *)((char *)&uu[1] + 4) = v14;
    WORD6(uu[1]) = 2080;
    *(void *)((char *)&uu[1] + 14) = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received new client connection: %p from pid: %d, entitled: %s, uuid: %s", (uint8_t *)uu, 0x26u);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
  }
  int v16 = *a2;
  *(void *)&uu[0] = v16;
  if (v16)
  {
    xpc_retain(v16);
  }
  else
  {
    int v16 = xpc_null_create();
    *(void *)&uu[0] = v16;
  }
  DWORD2(uu[0]) = pid;
  BYTE12(uu[0]) = v7;
  memset(&uu[1], 0, 24);
  BOOL v18 = (void *)(a1 + 104);
  CFIndex v17 = *(void **)(a1 + 104);
  if (v17)
  {
    while (1)
    {
      while (1)
      {
        CFStringRef v19 = v17;
        unint64_t v20 = v17[4];
        if (v20 <= (unint64_t)v16) {
          break;
        }
        CFIndex v17 = (void *)*v19;
        BOOL v18 = v19;
        if (!*v19) {
          goto LABEL_28;
        }
      }
      if (v20 >= (unint64_t)v16) {
        break;
      }
      CFIndex v17 = (void *)v19[1];
      if (!v17)
      {
        BOOL v18 = v19 + 1;
        goto LABEL_28;
      }
    }
  }
  else
  {
    CFStringRef v19 = (void *)(a1 + 104);
LABEL_28:
    int v21 = operator new(0x48uLL);
    void v21[4] = v16;
    if (v16) {
      xpc_retain(v16);
    }
    else {
      void v21[4] = xpc_null_create();
    }
    *((_DWORD *)v21 + 10) = DWORD2(uu[0]);
    *((unsigned char *)v21 + 44) = BYTE12(uu[0]);
    *((_OWORD *)v21 + 3) = uu[1];
    v21[8] = *(void *)&uu[2];
    memset(&uu[1], 0, 24);
    *int v21 = 0;
    v21[1] = 0;
    v21[2] = v19;
    *BOOL v18 = v21;
    uint64_t v22 = **(void **)(a1 + 96);
    if (v22)
    {
      *(void *)(a1 + 96) = v22;
      int v21 = (void *)*v18;
    }
    sub_100046C90(*(uint64_t **)(a1 + 104), v21);
    ++*(void *)(a1 + 112);
    if (SBYTE7(uu[2]) < 0) {
      operator delete(*(void **)&uu[1]);
    }
  }
  xpc_release(*(xpc_object_t *)&uu[0]);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  _DWORD v23[2] = sub_10110EC60;
  v23[3] = &unk_101A903B8;
  v23[4] = a1;
  *a3 = _Block_copy(v23);
  xpc_release(object);
}

void sub_10110EBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, char a15)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10110EC1C(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

void sub_10110EC60(uint64_t a1, xpc_object_t *a2, void **a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v6 = *a3;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  BOOL v7 = *(void **)(v4 + 104);
  if (v7)
  {
    uint64_t v8 = v4 + 104;
    do
    {
      unint64_t v9 = v7[4];
      BOOL v10 = v9 >= (unint64_t)v5;
      if (v9 >= (unint64_t)v5) {
        char v11 = v7;
      }
      else {
        char v11 = v7 + 1;
      }
      if (v10) {
        uint64_t v8 = (uint64_t)v7;
      }
      BOOL v7 = (void *)*v11;
    }
    while (*v11);
    if (v8 != v4 + 104 && (unint64_t)v5 >= *(void *)(v8 + 32))
    {
      xpc_connection_t v13 = *(NSObject **)(v4 + 80);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = *(_DWORD *)(v8 + 40);
        xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&object);
        CFTypeRef v15 = v72 >= 0 ? &__p : (long long *)__p;
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v14;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Client [%d] checking in: %s", buf, 0x12u);
        if (SHIBYTE(v72) < 0) {
          operator delete((void *)__p);
        }
      }
      memset(buf, 0, 24);
      v67[0] = &object;
      v67[1] = "kRequest";
      sub_100048BAC((uint64_t)v67, &p_object);
      long long __p = 0uLL;
      uint64_t v72 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v72) < 0) {
        operator delete((void *)__p);
      }
      xpc_release(p_object);
      uint64_t v16 = buf[23];
      int v17 = (char)buf[23];
      if ((buf[23] & 0x80u) != 0) {
        uint64_t v16 = *(void *)&buf[8];
      }
      switch(v16)
      {
        case 23:
          BOOL v18 = *(uint8_t **)buf;
          if ((buf[23] & 0x80u) == 0) {
            BOOL v18 = buf;
          }
          uint64_t v19 = *(void *)v18;
          uint64_t v20 = *((void *)v18 + 1);
          uint64_t v21 = *(void *)(v18 + 15);
          if (v19 != 0x657473696765526BLL || v20 != 0x63696C6F50554372 || v21 != 0x746E65696C437963) {
            goto LABEL_97;
          }
          p_xpc_object_t object = &object;
          v66 = "kProgName";
          sub_100048BAC((uint64_t)&p_object, &v69);
          long long __p = 0uLL;
          uint64_t v72 = 0;
          xpc::dyn_cast_or_default();
          if (SHIBYTE(v72) < 0) {
            operator delete((void *)__p);
          }
          CFStringRef v24 = (void **)(v8 + 48);
          if (*(char *)(v8 + 71) < 0) {
            operator delete(*v24);
          }
          *(_OWORD *)CFStringRef v24 = *(_OWORD *)v67;
          xpc_object_t v25 = v69;
          *(void *)(v8 + 64) = v68;
          HIBYTE(v68) = 0;
          LOBYTE(v67[0]) = 0;
          xpc_release(v25);
          *(void *)&long long __p = v5;
          if (v5)
          {
            xpc_retain(v5);
            xpc_object_t v26 = v5;
          }
          else
          {
            xpc_object_t v26 = xpc_null_create();
            *(void *)&long long __p = v26;
          }
          sub_10110F6A0(v4, (xpc_object_t *)&__p, (unsigned int *)(v8 + 40));
          xpc_release(v26);
          goto LABEL_98;
        case 24:
        case 26:
        case 28:
          goto LABEL_97;
        case 25:
          CFDictionaryRef v30 = *(uint8_t **)buf;
          if ((buf[23] & 0x80u) == 0) {
            CFDictionaryRef v30 = buf;
          }
          uint64_t v31 = *(void *)v30;
          uint64_t v32 = *((void *)v30 + 1);
          uint64_t v33 = *((void *)v30 + 2);
          int v34 = v30[24];
          if (v31 != 0x73696765726E556BLL || v32 != 0x6C6F505543726574 || v33 != 0x6E65696C43796369 || v34 != 116) {
            goto LABEL_97;
          }
          sub_101111820((uint64_t **)(v4 + 96), (unint64_t)v5);
          goto LABEL_98;
        case 27:
          uint64_t v38 = *(uint8_t **)buf;
          if ((buf[23] & 0x80u) == 0) {
            uint64_t v38 = buf;
          }
          uint64_t v39 = *(void *)v38;
          uint64_t v40 = *((void *)v38 + 1);
          uint64_t v41 = *((void *)v38 + 2);
          uint64_t v42 = *(void *)(v38 + 19);
          if (v39 != 0x654E74654755436BLL
            || v40 != 0x6363416B726F7774
            || v41 != 0x63696C6F50737365
            || v42 != 0x73656963696C6F50)
          {
            goto LABEL_97;
          }
          p_xpc_object_t object = 0;
          p_xpc_object_t object = xpc_null_create();
          if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
            goto LABEL_122;
          }
          xpc_object_t reply = xpc_dictionary_create_reply(object);
          xpc_object_t v47 = reply;
          if (reply)
          {
            *(void *)&long long __p = reply;
          }
          else
          {
            xpc_object_t v47 = xpc_null_create();
            *(void *)&long long __p = v47;
            if (!v47)
            {
              xpc_object_t v62 = xpc_null_create();
              xpc_object_t v47 = 0;
              goto LABEL_120;
            }
          }
          if (xpc_get_type(v47) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v47);
            goto LABEL_121;
          }
          xpc_object_t v62 = xpc_null_create();
LABEL_120:
          *(void *)&long long __p = v62;
LABEL_121:
          sub_101111214(&p_object, (xpc_object_t *)&__p);
          xpc_release((xpc_object_t)__p);
          *(void *)&long long __p = 0;
          xpc_release(v47);
LABEL_122:
          long long __p = 0uLL;
          if (xpc_get_type(p_object) == (xpc_type_t)&_xpc_type_dictionary) {
            operator new();
          }
          v67[0] = 0;
          v67[1] = 0;
          xpc_release(p_object);
          sub_10110FED0(v4, (unsigned int *)(v8 + 40), v67);
          goto LABEL_98;
        case 29:
          CFTypeID v48 = *(uint8_t **)buf;
          if ((buf[23] & 0x80u) == 0) {
            CFTypeID v48 = buf;
          }
          uint64_t v49 = *(void *)v48;
          uint64_t v50 = *((void *)v48 + 1);
          uint64_t v51 = *((void *)v48 + 2);
          uint64_t v52 = *(void *)(v48 + 21);
          if (v49 != 0x6F6672655055436BLL
            || v50 != 0x4E74737269466D72
            || v51 != 0x73556B726F777465
            || v52 != 0x776F6C466573556BLL)
          {
            goto LABEL_97;
          }
          v67[0] = 0;
          v67[1] = 0;
          uint64_t v68 = 0;
          p_xpc_object_t object = &object;
          v66 = "kCUPolicyKeyBundleID";
          sub_100048BAC((uint64_t)&p_object, &v69);
          long long __p = 0uLL;
          uint64_t v72 = 0;
          xpc::dyn_cast_or_default();
          if (SHIBYTE(v72) < 0) {
            operator delete((void *)__p);
          }
          xpc_release(v69);
          *(void *)&long long __p = &object;
          *((void *)&__p + 1) = "kCUIgnoreFGApp";
          sub_100048BAC((uint64_t)&__p, &p_object);
          uint64_t v58 = xpc::dyn_cast_or_default((xpc *)&p_object, 0, v57);
          xpc_release(p_object);
          xpc_object_t v69 = 0;
          xpc_object_t v69 = xpc_null_create();
          if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
            goto LABEL_128;
          }
          xpc_object_t v59 = xpc_dictionary_create_reply(object);
          xpc_object_t v60 = v59;
          if (v59)
          {
            *(void *)&long long __p = v59;
          }
          else
          {
            xpc_object_t v60 = xpc_null_create();
            *(void *)&long long __p = v60;
            if (!v60)
            {
              xpc_object_t v63 = xpc_null_create();
              xpc_object_t v60 = 0;
              goto LABEL_126;
            }
          }
          if (xpc_get_type(v60) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v60);
            goto LABEL_127;
          }
          xpc_object_t v63 = xpc_null_create();
LABEL_126:
          *(void *)&long long __p = v63;
LABEL_127:
          sub_101111214(&v69, (xpc_object_t *)&__p);
          xpc_release((xpc_object_t)__p);
          *(void *)&long long __p = 0;
          xpc_release(v60);
LABEL_128:
          long long __p = 0uLL;
          if (xpc_get_type(v69) == (xpc_type_t)&_xpc_type_dictionary) {
            operator new();
          }
          p_xpc_object_t object = 0;
          v66 = 0;
          xpc_release(v69);
          sub_10110FCD8((void *)v4, v8 + 40, (uint64_t)v67, v58, (uint64_t *)&p_object);
          if (SHIBYTE(v68) < 0) {
            operator delete(v67[0]);
          }
LABEL_98:
          if (((char)buf[23] & 0x80000000) == 0) {
            goto LABEL_19;
          }
          uint64_t v29 = *(void **)buf;
          break;
        default:
          if (v16)
          {
LABEL_97:
            v56 = *(NSObject **)(v4 + 80);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              uint64_t v61 = *(uint8_t **)buf;
              if (v17 >= 0) {
                uint64_t v61 = buf;
              }
              LODWORD(__p) = 136315138;
              *(void *)((char *)&__p + 4) = v61;
              _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Received unsupported message request: %s", (uint8_t *)&__p, 0xCu);
            }
          }
          else
          {
            char v27 = *(NSObject **)(v4 + 80);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__p) = 0;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Received malformed message format: missing kRequest", (uint8_t *)&__p, 2u);
            }
          }
          goto LABEL_98;
      }
      goto LABEL_100;
    }
  }
  id v12 = *(NSObject **)(v4 + 80);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&object);
    int v28 = v72 >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v28;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Received message %s from unknown connection %p", buf, 0x16u);
    if (SHIBYTE(v72) < 0)
    {
      uint64_t v29 = (void *)__p;
LABEL_100:
      operator delete(v29);
    }
  }
LABEL_19:
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
}

void sub_10110F4EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10110F698(uint64_t a1@<X0>, xpc_connection_t *a2@<X1>, void **a3@<X8>)
{
}

void sub_10110F6A0(uint64_t a1, xpc_object_t *a2, unsigned int *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4)
  {
    BOOL v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 120);
      if (v8)
      {
        unint64_t v9 = (uint64_t *)*((unsigned __int8 *)a3 + 4);
        if (*((unsigned char *)a3 + 4))
        {
          xpc_object_t v10 = *a2;
          object[0] = (xpc_object_t)a1;
          object[1] = v10;
          if (v10) {
            xpc_retain(v10);
          }
          else {
            object[1] = xpc_null_create();
          }
          int v43 = *a3;
          char v44 = *((unsigned char *)a3 + 4);
          if (*((char *)a3 + 31) < 0)
          {
            sub_10004FC84(&__p, *((void **)a3 + 1), *((void *)a3 + 2));
          }
          else
          {
            long long __p = *(_OWORD *)(a3 + 2);
            uint64_t v46 = *((void *)a3 + 3);
          }
          uint64_t v50 = 0;
          uint64_t v22 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v22 = off_101A90640;
          *(_OWORD *)(v22 + 8) = *(_OWORD *)object;
          object[1] = xpc_null_create();
          *((_DWORD *)v22 + 6) = v43;
          v22[28] = v44;
          uint64_t v23 = v22 + 32;
          if (SHIBYTE(v46) < 0)
          {
            sub_10004FC84(v23, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v23 = __p;
            *((void *)v22 + 6) = v46;
          }
          uint64_t v50 = v22;
          (*(void (**)(uint64_t, void *))(*(void *)v8 + 16))(v8, v49);
          sub_1000E8710(v49);
          if (SHIBYTE(v46) < 0) {
            operator delete((void *)__p);
          }
          xpc_release(object[1]);
          object[1] = 0;
          goto LABEL_28;
        }
        *(void *)buf = 0;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 136));
        xpc_connection_t v13 = ServiceMap;
        if (v14 < 0)
        {
          CFTypeRef v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v16 = 5381;
          do
          {
            uint64_t v14 = v16;
            unsigned int v17 = *v15++;
            uint64_t v16 = (33 * v16) ^ v17;
          }
          while (v17);
        }
        std::mutex::lock(ServiceMap);
        *(void *)uint64_t v51 = v14;
        BOOL v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v51);
        if (v18)
        {
          uint64_t v20 = v18[3];
          uint64_t v19 = (std::__shared_weak_count *)v18[4];
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v13);
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v19);
            char v21 = 0;
LABEL_31:
            (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v20 + 104))(buf, v20, *a3);
            if ((v21 & 1) == 0) {
              sub_10004D2C8(v19);
            }
            uint64_t v24 = HIBYTE(v41);
            if (v41 < 0) {
              uint64_t v24 = v40;
            }
            if (v24)
            {
              v31[0] = (xpc_object_t)a1;
              v31[1] = *a2;
              if (*a2) {
                xpc_retain(*a2);
              }
              else {
                v31[1] = xpc_null_create();
              }
              int v33 = *a3;
              char v34 = *((unsigned char *)a3 + 4);
              if (*((char *)a3 + 31) < 0)
              {
                sub_10004FC84(&v35, *((void **)a3 + 1), *((void *)a3 + 2));
              }
              else
              {
                long long v35 = *(_OWORD *)(a3 + 2);
                uint64_t v36 = *((void *)a3 + 3);
              }
              CFTypeID v48 = 0;
              int v28 = (char *)operator new(0x38uLL);
              *(void *)int v28 = off_101A906C0;
              *(_OWORD *)(v28 + 8) = *(_OWORD *)v31;
              xpc_object_t v32 = xpc_null_create();
              *((_DWORD *)v28 + 6) = v33;
              v28[28] = v34;
              uint64_t v29 = v28 + 32;
              if (SHIBYTE(v36) < 0)
              {
                sub_10004FC84(v29, (void *)v35, *((unint64_t *)&v35 + 1));
              }
              else
              {
                *(_OWORD *)uint64_t v29 = v35;
                *((void *)v28 + 6) = v36;
              }
              CFTypeID v48 = v28;
              (**(void (***)(uint64_t, uint8_t *, void *))v8)(v8, buf, v47);
              sub_1000E8710(v47);
              if (SHIBYTE(v36) < 0) {
                operator delete((void *)v35);
              }
              xpc_release(v32);
            }
            else
            {
              xpc_object_t v25 = *(NSObject **)(a1 + 80);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                int v30 = *a3;
                *(_DWORD *)uint64_t v51 = 67109120;
                *(_DWORD *)&v51[4] = v30;
                _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Not able to get mapped bundle id for process with pid: %d", v51, 8u);
              }
              xpc_object_t v26 = xpc_null_create();
              char v27 = (_xpc_connection_s *)*a2;
              xpc_connection_t v37 = v27;
              uint64_t v38 = v26;
              if (v27)
              {
                xpc_retain(v27);
              }
              else
              {
                char v27 = (_xpc_connection_s *)xpc_null_create();
                xpc_connection_t v37 = v27;
              }
              sub_1011104D0(&v38, &v37);
              xpc_release(v27);
              xpc_connection_t v37 = 0;
              xpc_release(v26);
              uint64_t v38 = 0;
            }
            if (SHIBYTE(v41) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_10;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        std::mutex::unlock(v13);
        uint64_t v19 = 0;
        char v21 = 1;
        goto LABEL_31;
      }
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  char v11 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Policy server is null", buf, 2u);
  }
LABEL_10:
  if (v7) {
LABEL_28:
  }
    sub_10004D2C8(v7);
}

void sub_10110FB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,xpc_object_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  xpc_release(v31[2]);
  operator delete(v31);
  sub_1011106A8((uint64_t)&a9);
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

void sub_10110FCD8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  xpc_object_t v10 = a1[10];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v18[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Got a client request to perform first network use flow", (uint8_t *)v18, 2u);
  }
  if (*(unsigned char *)(a2 + 4))
  {
    char v11 = (std::__shared_weak_count *)a1[16];
    if (v11)
    {
      id v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        uint64_t v13 = a1[15];
        if (v13)
        {
          uint64_t v15 = *a5;
          uint64_t v14 = a5[1];
          if (v14) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
          }
          v18[0] = off_101A90740;
          v18[1] = v15;
          v18[2] = v14;
          v18[3] = v18;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void *))(*(void *)v13 + 8))(v13, a3, a4, 0, v18);
          sub_100060644(v18);
LABEL_16:
          sub_10004D2C8(v12);
          return;
        }
      }
    }
    else
    {
      id v12 = 0;
    }
    unsigned int v17 = a1[10];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Policy server is null", (uint8_t *)v18, 2u);
    }
    if (v12) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v16 = a1[10];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Client is not entitled", (uint8_t *)v18, 2u);
    }
  }
}

void sub_10110FEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100060644(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10110FED0(uint64_t a1, unsigned int *a2, void *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (!v4)
  {
    BOOL v7 = 0;
    goto LABEL_10;
  }
  BOOL v7 = std::__shared_weak_count::lock(v4);
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 120)) == 0)
  {
LABEL_10:
    char v11 = *(NSObject **)(a1 + 80);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Policy server is null", buf, 2u);
    }
LABEL_12:
    if (!v7) {
      return;
    }
    goto LABEL_13;
  }
  unint64_t v9 = (uint64_t *)*((unsigned __int8 *)a2 + 4);
  if (!*((unsigned char *)a2 + 4))
  {
    *(void *)buf = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 136));
    uint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)xpc_object_t v47 = v14;
    BOOL v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v47);
    if (v18)
    {
      uint64_t v20 = v18[3];
      uint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_31:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v20 + 104))(buf, v20, *a2);
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        uint64_t v24 = HIBYTE(v37);
        if (v37 < 0) {
          uint64_t v24 = v36;
        }
        if (v24)
        {
          uint64_t v25 = a3[1];
          *(void *)&long long v30 = *a3;
          *((void *)&v30 + 1) = v25;
          if (v25) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
          }
          int v31 = *a2;
          char v32 = *((unsigned char *)a2 + 4);
          if (*((char *)a2 + 31) < 0)
          {
            sub_10004FC84(&v33, *((void **)a2 + 1), *((void *)a2 + 2));
          }
          else
          {
            long long v33 = *(_OWORD *)(a2 + 2);
            uint64_t v34 = *((void *)a2 + 3);
          }
          char v44 = 0;
          int v28 = (char *)operator new(0x38uLL);
          *(void *)int v28 = off_101A905C0;
          *(_OWORD *)(v28 + 8) = v30;
          *((_DWORD *)v28 + 6) = v31;
          v28[28] = v32;
          uint64_t v29 = v28 + 32;
          if (SHIBYTE(v34) < 0)
          {
            sub_10004FC84(v29, (void *)v33, *((unint64_t *)&v33 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v29 = v33;
            *((void *)v28 + 6) = v34;
          }
          char v44 = v28;
          (**(void (***)(uint64_t, uint8_t *, void *))v8)(v8, buf, v43);
          sub_1000E8710(v43);
          if (SHIBYTE(v34) < 0) {
            operator delete((void *)v33);
          }
        }
        else
        {
          xpc_object_t v26 = *(NSObject **)(a1 + 80);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            int v27 = *a2;
            *(_DWORD *)xpc_object_t v47 = 67109120;
            *(_DWORD *)&v47[4] = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Not able to get mapped bundle id for process with pid: %d", v47, 8u);
          }
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
    goto LABEL_31;
  }
  uint64_t v10 = a3[1];
  *(void *)&long long v38 = *a3;
  *((void *)&v38 + 1) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  int v39 = *a2;
  char v40 = *((unsigned char *)a2 + 4);
  if (*((char *)a2 + 31) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 1), *((void *)a2 + 2));
  }
  else
  {
    long long __p = *(_OWORD *)(a2 + 2);
    uint64_t v42 = *((void *)a2 + 3);
  }
  uint64_t v46 = 0;
  uint64_t v22 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v22 = off_101A90540;
  *(_OWORD *)(v22 + 8) = v38;
  long long v38 = 0uLL;
  *((_DWORD *)v22 + 6) = v39;
  v22[28] = v40;
  uint64_t v23 = v22 + 32;
  if (SHIBYTE(v42) < 0)
  {
    sub_10004FC84(v23, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v23 = __p;
    *((void *)v22 + 6) = v42;
  }
  uint64_t v46 = v22;
  (*(void (**)(uint64_t, void *))(*(void *)v8 + 16))(v8, v45);
  sub_1000E8710(v45);
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)__p);
  }
  if (*((void *)&v38 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v38 + 1));
  }
LABEL_13:
  sub_10004D2C8(v7);
}

void sub_101110368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  int v31 = (std::__shared_weak_count *)v29[2];
  if (v31) {
    sub_10004D2C8(v31);
  }
  operator delete(v29);
  sub_10111044C((uint64_t)&a9);
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_10111044C(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_10111048C(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_1011104D0(void **a1, xpc_connection_t *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v14 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v14 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v12 = xpc_BOOL_create(1);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  char v11 = "kDataUsagePolicyNotification";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  BOOL v7 = *a1;
  xpc_object_t v8 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v8 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  char v11 = "kDataUsagePolicies";
  sub_10017AC14((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_connection_send_message(*a2, v14);
  xpc_release(v14);
}

void sub_101110638(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

xpc_object_t *sub_101110674(xpc_object_t *a1)
{
  *a1 = 0;
  return a1;
}

uint64_t sub_1011106A8(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_1011106EC(uint64_t a1, xpc_object_t object, xpc_object_t *a3, uint64_t a4)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  if (*a3) {
    xpc_retain(*a3);
  }
  else {
    xpc_null_create();
  }
  if (*(char *)(a4 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(a4 + 8), *(void *)(a4 + 16));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a4 + 8);
    __p[2] = *(void **)(a4 + 24);
  }
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011108D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v11 + 16));
  *(void *)(v11 + 16) = 0;
  xpc_release(*(xpc_object_t *)(v11 + 8));
  *(void *)(v11 + 8) = 0;
  sub_10006A6AC(a1);
}

void sub_101110948(uint64_t a1, long long **a2)
{
  memset(v4, 0, sizeof(v4));
  sub_1011113C4((uint64_t)v4, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  unsigned __int16 v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101110A80(xpc_object_t *a1, uint64_t *a2)
{
  *a1 = 0;
  *a1 = xpc_null_create();
  if (*a2 != a2[1])
  {
    xpc_object_t v4 = xpc_array_create(0, 0);
    if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v4);
        xpc_object_t v5 = v4;
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
    }
    xpc_release(v4);
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v7 = *a1;
    *a1 = v5;
    xpc_release(v7);
    xpc_release(v6);
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
    if (*a2 != v9)
    {
      do
      {
        xpc_object_t value = 0;
        xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v11 = v10;
        if (v10)
        {
          xpc_object_t value = v10;
        }
        else
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t value = v11;
          if (!v11)
          {
            xpc_object_t v12 = xpc_null_create();
            xpc_object_t v11 = 0;
            goto LABEL_16;
          }
        }
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v11);
          goto LABEL_17;
        }
        xpc_object_t v12 = xpc_null_create();
LABEL_16:
        xpc_object_t value = v12;
LABEL_17:
        xpc_release(v11);
        xpc_object_t v23 = xpc_BOOL_create(*(unsigned char *)(v8 + 24));
        if (!v23) {
          xpc_object_t v23 = xpc_null_create();
        }
        p_xpc_object_t value = &value;
        uint64_t v22 = "kCUPolicyKeyDataAllowed";
        sub_100035E70((uint64_t)&p_value, &v23, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v23);
        xpc_object_t v23 = 0;
        xpc_object_t v19 = xpc_BOOL_create(*(unsigned char *)(v8 + 25));
        if (!v19) {
          xpc_object_t v19 = xpc_null_create();
        }
        p_xpc_object_t value = &value;
        uint64_t v22 = "kCUPolicyKeyWiFiAllowed";
        sub_100035E70((uint64_t)&p_value, &v19, &v20);
        xpc_release(v20);
        xpc_object_t v20 = 0;
        xpc_release(v19);
        xpc_object_t v19 = 0;
        xpc_object_t v17 = xpc_BOOL_create(*(unsigned char *)(v8 + 26));
        if (!v17) {
          xpc_object_t v17 = xpc_null_create();
        }
        p_xpc_object_t value = &value;
        uint64_t v22 = "kCUPolicyFirstNetworkUseFlowPerformed";
        sub_100035E70((uint64_t)&p_value, &v17, &v18);
        xpc_release(v18);
        xpc_object_t v18 = 0;
        xpc_release(v17);
        xpc_object_t v17 = 0;
        if (*(char *)(v8 + 23) < 0)
        {
          if (*(void *)(v8 + 8))
          {
            uint64_t v13 = *(const char **)v8;
LABEL_28:
            xpc_object_t v15 = xpc_string_create(v13);
            if (!v15) {
              xpc_object_t v15 = xpc_null_create();
            }
            p_xpc_object_t value = &value;
            uint64_t v22 = "kCUPolicyKeyBundleID";
            sub_100035E70((uint64_t)&p_value, &v15, &v16);
            xpc_release(v16);
            xpc_object_t v16 = 0;
            xpc_release(v15);
          }
        }
        else
        {
          uint64_t v13 = (const char *)v8;
          if (*(unsigned char *)(v8 + 23)) {
            goto LABEL_28;
          }
        }
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary) {
          xpc_array_append_value(*a1, value);
        }
        xpc_release(value);
        v8 += 32;
      }
      while (v8 != v9);
    }
  }
}

void sub_101110DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  sub_101110674(v10);
  _Unwind_Resume(a1);
}

void sub_101110DF8(uint64_t a1, xpc::object *a2)
{
  unsigned __int16 v3 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    xpc::object::to_string((uint64_t *)__p, a2);
    if (v6 >= 0) {
      xpc_object_t v4 = __p;
    }
    else {
      xpc_object_t v4 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v8 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received server error %s", buf, 0xCu);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_101110ED4(uint64_t a1, xpc::object *a2)
{
}

void sub_101110EDC(uint64_t a1, unint64_t *a2)
{
}

void sub_101110EE8(uint64_t a1, unint64_t *a2)
{
}

void sub_101110EF4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  unsigned __int16 v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101110FF4(uint64_t a1)
{
  *(void *)a1 = off_101A90338;
  uint64_t v2 = (ctu::XpcServer *)(a1 + 8);
  *(void *)(a1 + 8) = off_101A90390;
  unsigned __int16 v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_1011114F8(*(void **)(a1 + 104));
  xpc_object_t v5 = *(NSObject **)(a1 + 88);
  if (v5) {
    dispatch_release(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 80));
  ctu::XpcServer::~XpcServer(v2);

  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface((NetworkAccessPolicyServerInterface *)a1);
}

void sub_1011110A0(uint64_t a1)
{
  *(void *)a1 = off_101A90338;
  uint64_t v2 = (ctu::XpcServer *)(a1 + 8);
  *(void *)(a1 + 8) = off_101A90390;
  unsigned __int16 v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_1011114F8(*(void **)(a1 + 104));
  xpc_object_t v5 = *(NSObject **)(a1 + 88);
  if (v5) {
    dispatch_release(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 80));
  ctu::XpcServer::~XpcServer(v2);
  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface((NetworkAccessPolicyServerInterface *)a1);

  operator delete();
}

void sub_101111160(uint64_t a1)
{
  uint64_t v2 = (NetworkAccessPolicyServerInterface *)(a1 - 8);
  *(void *)(a1 - 8) = off_101A90338;
  *(void *)a1 = off_101A90390;
  unsigned __int16 v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_1011114F8(*(void **)(a1 + 96));
  xpc_object_t v5 = *(NSObject **)(a1 + 80);
  if (v5) {
    dispatch_release(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  ctu::XpcServer::~XpcServer((ctu::XpcServer *)a1);

  NetworkAccessPolicyServerInterface::~NetworkAccessPolicyServerInterface(v2);
}

void sub_10111120C(uint64_t a1)
{
}

void **sub_101111214(void **a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  *a2 = xpc_null_create();
  xpc_object_t v4 = *a1;
  *a1 = v3;
  xpc_release(v4);
  return a1;
}

void sub_101111264()
{
}

void sub_1011112FC(void *a1)
{
  __cxa_begin_catch(a1);
  xpc::auto_reply::deleter(v1, v2);
  __cxa_rethrow();
}

void sub_101111310(_Unwind_Exception *a1)
{
}

void sub_101111328(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101111360(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t sub_101111380(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A904B0)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

uint64_t sub_1011113C4(uint64_t result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    xpc_object_t v4 = (void *)result;
    if (a4 >> 59) {
      sub_1000D8578();
    }
    xpc_object_t v7 = (char *)sub_1000F5A68(result + 16, a4);
    uint64_t v8 = v7;
    *xpc_object_t v4 = v7;
    v4[1] = v7;
    v4[2] = &v7[32 * v9];
    xpc_object_t v16 = v7;
    xpc_object_t v17 = v7;
    v14[0] = v4 + 2;
    v14[1] = &v16;
    v14[2] = &v17;
    uint64_t v15 = 0;
    if (a2 != a3)
    {
      xpc_object_t v10 = v7;
      do
      {
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(v10, *(void **)a2, *((void *)a2 + 1));
          xpc_object_t v12 = v17;
        }
        else
        {
          long long v11 = *a2;
          *((void *)v10 + 2) = *((void *)a2 + 2);
          *(_OWORD *)xpc_object_t v10 = v11;
          xpc_object_t v12 = v10;
        }
        __int16 v13 = *((_WORD *)a2 + 12);
        v10[26] = *((unsigned char *)a2 + 26);
        *((_WORD *)v10 + 12) = v13;
        a2 += 2;
        xpc_object_t v10 = v12 + 32;
        xpc_object_t v17 = v12 + 32;
      }
      while (a2 != a3);
      uint64_t v8 = v12 + 32;
    }
    LOBYTE(v15) = 1;
    BOOL result = sub_10016DE78((uint64_t)v14);
    v4[1] = v8;
  }
  return result;
}

void sub_1011114D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1011114F8(void *a1)
{
  if (a1)
  {
    sub_1011114F8(*a1);
    sub_1011114F8(a1[1]);
    sub_10111154C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10111154C(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

void sub_10111158C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101111660(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_101111738);
  __cxa_rethrow();
}

void sub_101111688(_Unwind_Exception *a1)
{
}

void sub_1011116A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011116D8(uint64_t a1)
{
}

uint64_t sub_1011116F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101111738(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_101111764(uint64_t a1)
{
  uint64_t v2 = a1;
  ctu::XpcServer::startListener_sync((ctu::XpcServer *)(*(void *)a1 + 8));
  return sub_100088C88(&v2);
}

void sub_1011117A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100088C88((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011117B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v4 = a1;
  uint64_t v5 = v1;
  Listener_sync = (xpc_connection_t *)ctu::XpcServer::getListener_sync((ctu::XpcServer *)(*(void *)v1 + 8));
  xpc_connection_cancel(*Listener_sync);
  sub_100088C88(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_101111804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_101111820(uint64_t **a1, unint64_t a2)
{
  xpc_object_t v4 = (uint64_t *)(a1 + 1);
  xpc_object_t v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    char v6 = v3;
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v6;
      }
      else {
        uint64_t v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        uint64_t v5 = v6;
      }
      char v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && v5[4] <= a2)
    {
      xpc_object_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          xpc_object_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        xpc_object_t v12 = v5;
        do
        {
          long long v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          xpc_object_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_10005EE6C(v3, v5);
      sub_10111154C((uint64_t)(v5 + 4));
      operator delete(v5);
    }
  }
}

uint64_t sub_101111904(uint64_t a1)
{
  *(void *)a1 = off_101A90540;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101111960(uint64_t a1)
{
  *(void *)a1 = off_101A90540;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011119DC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A90540;
  sub_101111BF0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_101111A30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101111A44(uint64_t a1, void *a2)
{
  *a2 = off_101A90540;
  return sub_101111BF0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_101111A70(uint64_t a1)
{
}

void sub_101111A78(void *a1)
{
  sub_101111C84((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101111AB4(uint64_t a1, long long **a2)
{
  memset(v3, 0, sizeof(v3));
  sub_1011113C4((uint64_t)v3, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  xpc_object_t v7 = 0;
  sub_101110A80(&v7, v3);
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  v4[0] = *(void ***)(a1 + 8);
  v4[1] = (void **)"kDataUsagePolicies";
  sub_10017AC14((uint64_t)v4, &object, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  v4[0] = (void **)v3;
  sub_1000D82FC(v4);
}

void sub_101111B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000D82FC((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101111BA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101111BE4()
{
}

uint64_t sub_101111BF0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 20) = *(unsigned char *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  uint64_t v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_101111C6C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101111C84(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_101111CD8(uint64_t a1)
{
  *(void *)a1 = off_101A905C0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101111D34(uint64_t a1)
{
  *(void *)a1 = off_101A905C0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_101111DB0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A905C0;
  sub_101111FC4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_101111E04(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101111E18(uint64_t a1, void *a2)
{
  *a2 = off_101A905C0;
  return sub_101111FC4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_101111E44(uint64_t a1)
{
}

void sub_101111E4C(void *a1)
{
  sub_101111C84((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101111E88(uint64_t a1, long long **a2)
{
  memset(v3, 0, sizeof(v3));
  sub_1011113C4((uint64_t)v3, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  xpc_object_t v7 = 0;
  sub_101110A80(&v7, v3);
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  v4[0] = *(void ***)(a1 + 8);
  v4[1] = (void **)"kDataUsagePolicies";
  sub_10017AC14((uint64_t)v4, &object, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  v4[0] = (void **)v3;
  sub_1000D82FC(v4);
}

void sub_101111F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000D82FC((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101111F78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101111FB8()
{
}

uint64_t sub_101111FC4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 20) = *(unsigned char *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  uint64_t v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_101112040(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101112058(uint64_t a1)
{
  *(void *)a1 = off_101A90640;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_1011120B8(uint64_t a1)
{
  *(void *)a1 = off_101A90640;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_101112138(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A90640;
  sub_1011123A0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10111218C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011121A0(uint64_t a1, void *a2)
{
  *a2 = off_101A90640;
  return sub_1011123A0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011121CC(uint64_t a1)
{
}

void sub_1011121D4(void *a1)
{
  sub_101112440((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101112210(uint64_t a1, long long **a2)
{
  memset(v6, 0, sizeof(v6));
  sub_1011113C4((uint64_t)v6, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_object_t object = 0;
  sub_101110A80(&object, v6);
  xpc_object_t v4 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  uint64_t v5 = *(void **)(a1 + 16);
  xpc_object_t v7 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  sub_1011106EC(v3, v4, &v7, a1 + 24);
}

void sub_101112300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t *a14)
{
  xpc_release(v15);
  a12 = 0;
  xpc_release(v14);
  xpc_release(object);
  a14 = &a9;
  sub_1000D82FC((void ***)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_101112354(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101112394()
{
}

uint64_t sub_1011123A0(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(void **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *(void *)(a1 + 8) = xpc_null_create();
  }
  int v5 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 20) = *(unsigned char *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v5;
  long long v6 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)long long v6 = v7;
  }
  return a1;
}

void sub_101112420(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void sub_101112440(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_101112480(uint64_t a1)
{
  *(void *)a1 = off_101A906C0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_1011124E0(uint64_t a1)
{
  *(void *)a1 = off_101A906C0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_101112560(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A906C0;
  sub_1011127C8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011125B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011125C8(uint64_t a1, void *a2)
{
  *a2 = off_101A906C0;
  return sub_1011127C8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011125F4(uint64_t a1)
{
}

void sub_1011125FC(void *a1)
{
  sub_101112868((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101112638(uint64_t a1, long long **a2)
{
  memset(v6, 0, sizeof(v6));
  sub_1011113C4((uint64_t)v6, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_object_t object = 0;
  sub_101110A80(&object, v6);
  xpc_object_t v4 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  int v5 = *(void **)(a1 + 16);
  xpc_object_t v7 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  sub_1011106EC(v3, v4, &v7, a1 + 24);
}

void sub_101112728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t *a14)
{
  xpc_release(v15);
  a12 = 0;
  xpc_release(v14);
  xpc_release(object);
  a14 = &a9;
  sub_1000D82FC((void ***)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_10111277C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011127BC()
{
}

uint64_t sub_1011127C8(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(void **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *(void *)(a1 + 8) = xpc_null_create();
  }
  int v5 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 20) = *(unsigned char *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v5;
  long long v6 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)long long v6 = v7;
  }
  return a1;
}

void sub_101112848(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void sub_101112868(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
}

void *sub_1011128A8(void *a1)
{
  *a1 = off_101A90740;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011128F4(void *a1)
{
  *a1 = off_101A90740;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_101112960(uint64_t a1)
{
  BOOL result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *BOOL result = off_101A90740;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011129BC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A90740;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011129F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101112A04(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_101112A44(uint64_t a1, BOOL *a2)
{
  xpc_object_t v4 = xpc_BOOL_create(*a2);
  if (!v4) {
    xpc_object_t v4 = xpc_null_create();
  }
  v3[0] = *(void *)(a1 + 8);
  v3[1] = "kCUFirstNetworkUseFlowPeformedResult";
  sub_100035E70((uint64_t)v3, &v4, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v4);
}

uint64_t sub_101112AC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101112B08()
{
}

uint64_t *sub_101112B14(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  xpc_object_t v2 = *(xpc_object_t *)(v1 + 8);
  BOOL v8 = v2;
  if (v2)
  {
    xpc_retain(v2);
  }
  else
  {
    xpc_object_t v2 = xpc_null_create();
    BOOL v8 = v2;
  }
  uint64_t v3 = *(_xpc_connection_s **)(v1 + 16);
  xpc_connection_t v7 = v3;
  if (v3)
  {
    xpc_retain(v3);
  }
  else
  {
    uint64_t v3 = (_xpc_connection_s *)xpc_null_create();
    xpc_connection_t v7 = v3;
  }
  sub_1011104D0(&v8, &v7);
  xpc_release(v3);
  xpc_release(v2);
  sub_101112C00(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_101112BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  xpc_release(v11);
  xpc_release(v10);
  sub_101112C00(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101112C00(uint64_t *result)
{
  uint64_t v1 = *result;
  *BOOL result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    xpc_release(*(xpc_object_t *)(v1 + 16));
    *(void *)(v1 + 16) = 0;
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_101112C78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v40 = a1;
  uint64_t v41 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  sub_1011113C4((uint64_t)&v42, *(long long **)(v1 + 8), *(long long **)(v1 + 16), (uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 5);
  object[0] = 0;
  sub_101110A80(object, &v42);
  uint64_t v3 = *(void **)(v2 + 96);
  if (v3 != (void *)(v2 + 104))
  {
    while (1)
    {
      xpc_object_t v4 = (uint64_t *)*((unsigned __int8 *)v3 + 44);
      if (!*((unsigned char *)v3 + 44)) {
        break;
      }
      xpc_object_t v5 = object[0];
      xpc_object_t v56 = object[0];
      if (object[0])
      {
        xpc_retain(object[0]);
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
        xpc_object_t v56 = v5;
      }
      xpc_object_t v16 = (_xpc_connection_s *)v3[4];
      xpc_connection_t v55 = v16;
      if (v16)
      {
        xpc_retain(v16);
      }
      else
      {
        xpc_object_t v16 = (_xpc_connection_s *)xpc_null_create();
        xpc_connection_t v55 = v16;
      }
      sub_1011104D0(&v56, &v55);
      xpc_release(v16);
      xpc_connection_t v55 = 0;
      xpc_release(v5);
      xpc_object_t v56 = 0;
LABEL_62:
      uint64_t v36 = (void *)v3[1];
      if (v36)
      {
        do
        {
          uint64_t v37 = v36;
          uint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v37 = (void *)v3[2];
          BOOL v38 = *v37 == (void)v3;
          uint64_t v3 = v37;
        }
        while (!v38);
      }
      uint64_t v3 = v37;
      if (v37 == (void *)(v2 + 104)) {
        goto LABEL_68;
      }
    }
    v53[0] = 0;
    v53[1] = 0;
    uint64_t v54 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 136));
    xpc_connection_t v7 = ServiceMap;
    if (v8 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    v58[0] = (void **)v8;
    xpc_object_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v58);
    if (v12)
    {
      uint64_t v14 = v12[3];
      BOOL v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_18:
        (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v14 + 104))(v53, v14, *((unsigned int *)v3 + 10));
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        uint64_t v17 = v42;
        uint64_t v18 = v43;
        if (SHIBYTE(v54) < 0)
        {
          sub_10004FC84(__p, v53[0], (unint64_t)v53[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)v53;
          uint64_t v52 = v54;
        }
        uint64_t v19 = HIBYTE(v52);
        if (v17 != v18)
        {
          char v21 = __p[0];
          xpc_object_t v20 = __p[1];
          if (v52 >= 0) {
            uint64_t v22 = (void *)HIBYTE(v52);
          }
          else {
            uint64_t v22 = __p[1];
          }
          do
          {
            xpc_object_t v23 = (void *)*(unsigned __int8 *)(v17 + 23);
            int v24 = (char)v23;
            if ((char)v23 < 0) {
              xpc_object_t v23 = *(void **)(v17 + 8);
            }
            if (v22 == v23)
            {
              if (v24 >= 0) {
                uint64_t v25 = (unsigned __int8 *)v17;
              }
              else {
                uint64_t v25 = *(unsigned __int8 **)v17;
              }
              if ((v19 & 0x80) != 0)
              {
                if (!memcmp(v21, v25, (size_t)v20)) {
                  goto LABEL_43;
                }
              }
              else
              {
                if (!v19) {
                  goto LABEL_44;
                }
                xpc_object_t v26 = __p;
                uint64_t v27 = v19;
                while (*(unsigned __int8 *)v26 == *v25)
                {
                  xpc_object_t v26 = (void **)((char *)v26 + 1);
                  ++v25;
                  if (!--v27) {
                    goto LABEL_42;
                  }
                }
              }
            }
            v17 += 32;
          }
          while (v17 != v18);
          uint64_t v17 = v18;
        }
LABEL_42:
        if ((v19 & 0x80) != 0) {
LABEL_43:
        }
          operator delete(__p[0]);
LABEL_44:
        if (v17 != v43)
        {
          xpc_object_t v50 = 0;
          if (*(char *)(v17 + 23) < 0)
          {
            sub_10004FC84(&__dst, *(void **)v17, *(void *)(v17 + 8));
          }
          else
          {
            long long v28 = *(_OWORD *)v17;
            uint64_t v63 = *(void *)(v17 + 16);
            long long __dst = v28;
          }
          __int16 v29 = *(_WORD *)(v17 + 24);
          char v65 = *(unsigned char *)(v17 + 26);
          __int16 v64 = v29;
          CFTypeID v48 = 0;
          uint64_t v49 = 0;
          xpc_object_t v47 = 0;
          object[1] = &v47;
          xpc_object_t object[2] = 0;
          long long v30 = (char *)operator new(0x20uLL);
          int v31 = v30;
          xpc_object_t v47 = v30;
          CFTypeID v48 = v30;
          uint64_t v49 = v30 + 32;
          xpc_object_t v60 = v30;
          uint64_t v61 = v30;
          v58[0] = (void **)&v49;
          v58[1] = (void **)&v60;
          v58[2] = (void **)&v61;
          uint64_t v59 = 0;
          if (SHIBYTE(v63) < 0)
          {
            sub_10004FC84(v30, (void *)__dst, *((unint64_t *)&__dst + 1));
            char v32 = v61;
          }
          else
          {
            *(_OWORD *)long long v30 = __dst;
            *((void *)v30 + 2) = v63;
            char v32 = v30;
          }
          *((_WORD *)v31 + 12) = v64;
          v31[26] = v65;
          long long v33 = v32 + 32;
          uint64_t v61 = v32 + 32;
          LOBYTE(v59) = 1;
          sub_10016DE78((uint64_t)v58);
          CFTypeID v48 = v33;
          sub_101110A80(&v50, (uint64_t *)&v47);
          v58[0] = (void **)&v47;
          sub_1000D82FC(v58);
          if (SHIBYTE(v63) < 0) {
            operator delete((void *)__dst);
          }
          xpc_object_t v34 = v50;
          xpc_object_t v46 = v50;
          if (v50)
          {
            xpc_retain(v50);
          }
          else
          {
            xpc_object_t v34 = xpc_null_create();
            xpc_object_t v46 = v34;
          }
          long long v35 = (_xpc_connection_s *)v3[4];
          xpc_connection_t v45 = v35;
          if (v35)
          {
            xpc_retain(v35);
          }
          else
          {
            long long v35 = (_xpc_connection_s *)xpc_null_create();
            xpc_connection_t v45 = v35;
          }
          sub_1011104D0(&v46, &v45);
          xpc_release(v35);
          xpc_connection_t v45 = 0;
          xpc_release(v34);
          xpc_object_t v46 = 0;
          xpc_release(v50);
        }
        if (SHIBYTE(v54) < 0) {
          operator delete(v53[0]);
        }
        goto LABEL_62;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    BOOL v13 = 0;
    char v15 = 1;
    goto LABEL_18;
  }
LABEL_68:
  xpc_release(object[0]);
  v58[0] = (void **)&v42;
  sub_1000D82FC(v58);
  sub_1011132BC(&v41);
  return sub_100046B58((uint64_t *)&v40);
}

void sub_101113164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,xpc_object_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,xpc_object_t object,char a40,uint64_t a41,uint64_t a42)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_1011132BC(uint64_t *result)
{
  uint64_t v1 = *result;
  *BOOL result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 8);
    sub_1000D82FC(&v2);
    operator delete();
  }
  return result;
}

void sub_10111331C(uint64_t **a1)
{
  xpc_connection_t v7 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (*a1)[1];
  uint64_t v4 = (*a1)[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v5 = *(std::__shared_weak_count **)(v2 + 128);
  *(void *)(v2 + 120) = v3;
  *(void *)(v2 + 128) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)v1[2];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  operator delete();
}

uint64_t sub_10111339C(uint64_t a1, const void **a2, _DWORD *a3, unsigned __int8 *a4)
{
  memset(&v11, 0, sizeof(v11));
  CC_SHA1_Init(&v11);
  for (; a1; --a1)
  {
    uint64_t v9 = *a2++;
    uint64_t v8 = v9;
    LODWORD(v9) = *a3;
    a3 += 2;
    CC_SHA1_Update(&v11, v8, (CC_LONG)v9);
  }
  return CC_SHA1_Final(a4, &v11);
}

uint64_t sub_101113418(const void *a1, unint64_t a2, int8x16_t *a3, unint64_t a4)
{
  if (a2 >= 0x40) {
    size_t v7 = 64;
  }
  else {
    size_t v7 = a2;
  }
  if (v7 <= 0x3F) {
    size_t v8 = 64 - v7;
  }
  else {
    size_t v8 = 0;
  }
  bzero(&__dst[v7], v8);
  memcpy(__dst, a1, v7);
  bzero(&__dst[v7], 64 - v7);
  unint64_t v9 = a4 / 0x28;
  if ((int)v9 >= 1)
  {
    int v10 = 0;
    do
    {
      char v11 = 1;
      do
      {
        char v12 = v11;
        memset(&c.Nl, 0, 76);
        *(_OWORD *)&c.h0 = xmmword_1015C1B70;
        c.h4 = -1009589776;
        CC_SHA1_Update(&c, __dst, 0x40u);
        unsigned int v13 = bswap32(c.h4);
        *a3 = vrev32q_s8(*(int8x16_t *)&c.h0);
        a3[1].i32[0] = v13;
        int v14 = 1;
        for (uint64_t i = 19; i != -1; --i)
        {
          unsigned int v16 = v14 + __dst[i] + a3->u8[i];
          __dst[i] = v16;
          int v14 = v16 >> 8;
        }
        char v11 = 0;
        a3 = (int8x16_t *)((char *)a3 + 20);
      }
      while ((v12 & 1) != 0);
      ++v10;
    }
    while (v10 != v9);
  }
  return 0;
}

void sub_10111359C(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, unint64_t *a5@<X8>)
{
  v13[0] = 0;
  v13[1] = 0;
  int v14 = 0;
  uint64_t v7 = *((unsigned __int8 *)a1 + 23);
  if ((v7 & 0x80u) == 0) {
    size_t v8 = a1;
  }
  else {
    size_t v8 = (uint64_t *)*a1;
  }
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = a1[1];
  }
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  *(void *)key = v7;
  *(void *)v12.ctx = v8;
  *(void *)&v12.ctx[2] = v9;
  *(void *)&v12.ctx[4] = v10;
  *(int64x2_t *)&key[8] = vdupq_n_s64(0x10uLL);
  sub_10111339C(3, (const void **)&v12, key, (unsigned __int8 *)v13);
  memset(&v12, 0, 160);
  sub_101113418(v13, 0x14uLL, (int8x16_t *)&v12, 0xA0uLL);
  *(_OWORD *)key = *(_OWORD *)&v12.ctx[4];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  sub_10008E4E8(a5, 0x14uLL);
  memset(&v12, 0, sizeof(v12));
  CCHmacInit(&v12, 0, key, 0x10uLL);
  CCHmacUpdate(&v12, *(const void **)a2, *(void *)(a2 + 8) - *(void *)a2);
  CCHmacFinal(&v12, (void *)*a5);
  unint64_t v11 = a5[1] - *a5;
  if (v11 > 0xF)
  {
    if (v11 != 16) {
      a5[1] = *a5 + 16;
    }
  }
  else
  {
    sub_10011FDF0(a5, 16 - v11);
  }
}

void sub_101113730(_Unwind_Exception *exception_object)
{
}

uint64_t NetworkUsageStrategy::NetworkUsageStrategy(uint64_t a1, void *a2, void *a3, dispatch_object_t *a4)
{
  size_t v8 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "cu.data.nwusage");
  if (v8)
  {
    dispatch_retain(v8);
    uint64_t v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    dispatch_retain(v8);
    dispatch_retain(v8);
    uint64_t v10 = dispatch_queue_create_with_target_V2("NetworkUsage", v9, v8);
  }
  else
  {
    unint64_t v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    uint64_t v10 = dispatch_queue_create("NetworkUsage", v11);
  }
  CCHmacContext v12 = v10;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  if (v12) {
    dispatch_release(v12);
  }
  if (v8)
  {
    dispatch_release(v8);
    dispatch_release(v8);
    dispatch_release(v8);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (v8) {
    dispatch_release(v8);
  }
  *(void *)a1 = off_101A90828;
  *(void *)(a1 + 48) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 56) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a3;
  uint64_t v14 = a3[1];
  *(void *)(a1 + 72) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "NetworkUsage");
  char v15 = *(NSObject **)(a1 + 24);
  uint64_t v18 = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  xpc_object_t object = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v18) {
    dispatch_release(v18);
  }
  if (v20 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(_DWORD *)(a1 + 120) = -1;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a1 + 160;
  return a1;
}

void sub_1011139CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_object_t v23 = *(std::__shared_weak_count **)(v19 + 72);
  if (v23) {
    sub_10004D2C8(v23);
  }
  int v24 = *(std::__shared_weak_count **)(v19 + 56);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void NetworkUsageStrategy::~NetworkUsageStrategy(char **this)
{
  *this = (char *)off_101A90828;
  sub_10005CD2C((uint64_t)(this + 19), this[20]);
  sub_1000346F8((uint64_t)(this + 16), this[17]);
  sub_10005CD2C((uint64_t)(this + 12), this[13]);
  uint64_t v2 = (std::__shared_weak_count *)this[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)this[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[7];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(this + 5));
  sub_100087E88(this + 1);
}

void NetworkUsageStrategy::initialize(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void NetworkUsageStrategy::shutdown(NetworkUsageStrategy *this, group_session a2)
{
  uint64_t v2 = (void *)((char *)this + 8);
  uint64_t v3 = *(NSObject **)a2.var0.fObj;
  if (*(void *)a2.var0.fObj)
  {
    dispatch_retain(*(dispatch_object_t *)a2.var0.fObj);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void NetworkUsageStrategy::startCollect(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void NetworkUsageStrategy::stopCollect(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void NetworkUsageStrategy::getTetheringInfo(NSObject **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = (NetworkUsageStrategy *)this;
  if (this[4])
  {
    if (dispatch_workloop_is_current())
    {
      sub_101116114((void **)a2, (uint64_t)this);
      return;
    }
    BOOL v4 = this[4] == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101116300;
  v7[3] = &unk_101A90A30;
  void v7[4] = this + 1;
  v7[5] = &v6;
  size_t v8 = v7;
  xpc_object_t v5 = this[3];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    uint64_t v10 = sub_101116310;
    unint64_t v11 = &unk_101A90A50;
    uint64_t v12 = a2;
    uint64_t v13 = &v8;
    dispatch_sync(v5, block);
  }
  else
  {
    uint64_t v10 = sub_10111637C;
    unint64_t v11 = &unk_101A90A70;
    uint64_t v12 = a2;
    uint64_t v13 = &v8;
    dispatch_async_and_wait(v5, block);
  }
}

void NetworkUsageStrategy::pollAndUpdateSources(NetworkUsageStrategy *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void NetworkUsageStrategy::setupThresholdMonitor_sync(Registry **this)
{
  if (!(*((unsigned int (**)(Registry **))*this + 9))(this)) {
    return;
  }
  uint64_t v2 = this + 8;
  v94 = (os_log_t *)(this + 5);
  int InternetInterfaceIndex = getInternetInterfaceIndex((uint64_t)(this + 5), this + 8);
  int v4 = *((_DWORD *)this + 30);
  if (InternetInterfaceIndex != v4)
  {
    if ((v4 & 0x80000000) == 0)
    {
      xpc_object_t v5 = *v94;
      if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Destroying internet threshold source", buf, 2u);
      }
      (*((void (**)(Registry **))*this + 7))(this);
    }
    uint64_t v6 = *v94;
    if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *((_DWORD *)this + 30);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = InternetInterfaceIndex;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Internet interface index updated, old %d, new %d", buf, 0xEu);
    }
    *((_DWORD *)this + 30) = InternetInterfaceIndex;
  }
  v93 = this;
  char v8 = 0;
  uint64_t v9 = 0;
  *(void *)&uint8_t buf[8] = 0;
  *(void *)&uint8_t buf[16] = 0;
  *(void *)buf = &buf[8];
  *(_OWORD *)v95 = xmmword_1015C1BE0;
  do
  {
    char v10 = v8;
    unint64_t v11 = v95[v9];
    int TetheringInterfaceIndex = getTetheringInterfaceIndex(v94, v2, v11);
    int v13 = TetheringInterfaceIndex;
    if (TetheringInterfaceIndex < 0) {
      goto LABEL_30;
    }
    uint64_t v14 = *(unsigned char **)buf;
    if (*(unsigned char **)buf != &buf[8])
    {
      while (*((_DWORD *)v14 + 10) != TetheringInterfaceIndex)
      {
        char v15 = (void *)*((void *)v14 + 1);
        if (v15)
        {
          do
          {
            unsigned int v16 = v15;
            char v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            unsigned int v16 = (unsigned char *)*((void *)v14 + 2);
            BOOL v28 = *(void *)v16 == (void)v14;
            uint64_t v14 = v16;
          }
          while (!v28);
        }
        uint64_t v14 = v16;
        if (v16 == &buf[8]) {
          goto LABEL_20;
        }
      }
LABEL_30:
      xpc_object_t v23 = *v94;
      if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v96 = 134217984;
        unint64_t v97 = v11;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I No interface for 0x%0llX", v96, 0xCu);
      }
      goto LABEL_32;
    }
LABEL_20:
    int ContextIdForType = getContextIdForType(v2, v11, (uint64_t *)v14);
    uint64_t v18 = *(void **)&buf[8];
    uint64_t v19 = &buf[8];
    char v20 = &buf[8];
    if (*(void *)&buf[8])
    {
      while (1)
      {
        while (1)
        {
          char v20 = v18;
          unint64_t v21 = v18[4];
          if (v21 <= v11) {
            break;
          }
          uint64_t v18 = (void *)*v20;
          uint64_t v19 = v20;
          if (!*v20) {
            goto LABEL_27;
          }
        }
        if (v21 >= v11) {
          break;
        }
        uint64_t v18 = (void *)v20[1];
        if (!v18)
        {
          uint64_t v19 = v20 + 1;
          goto LABEL_27;
        }
      }
    }
    else
    {
LABEL_27:
      uint64_t v22 = operator new(0x38uLL);
      v22[4] = v11;
      *((_DWORD *)v22 + 10) = v13;
      *((_DWORD *)v22 + 11) = ContextIdForType;
      v22[6] = 0;
      *uint64_t v22 = 0;
      v22[1] = 0;
      v22[2] = v20;
      void *v19 = v22;
      if (**(void **)buf)
      {
        *(void *)buf = **(void **)buf;
        uint64_t v22 = (void *)*v19;
      }
      sub_100046C90(*(uint64_t **)&buf[8], v22);
      ++*(void *)&buf[16];
    }
LABEL_32:
    char v8 = 1;
    uint64_t v9 = 1;
  }
  while ((v10 & 1) == 0);
  int v24 = (uint64_t **)(v93 + 16);
  if (*(Registry **)&buf[16] != v93[18])
  {
    xpc_object_t v26 = *v24;
    goto LABEL_55;
  }
  uint64_t v25 = *(void **)buf;
  if (*(unsigned char **)buf == &buf[8])
  {
LABEL_52:
    sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
    long long v33 = v93;
    if (InternetInterfaceIndex != v4) {
      goto LABEL_133;
    }
  }
  else
  {
    xpc_object_t v26 = *v24;
    uint64_t v27 = *v24;
    while (1)
    {
      BOOL v28 = v25[4] == v27[4] && *((_DWORD *)v25 + 10) == *((_DWORD *)v27 + 10);
      if (!v28) {
        break;
      }
      __int16 v29 = (void *)v25[1];
      long long v30 = v25;
      if (v29)
      {
        do
        {
          uint64_t v25 = v29;
          __int16 v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v30[2];
          BOOL v28 = *v25 == (void)v30;
          long long v30 = v25;
        }
        while (!v28);
      }
      int v31 = (uint64_t *)v27[1];
      if (v31)
      {
        do
        {
          char v32 = v31;
          int v31 = (uint64_t *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          char v32 = (uint64_t *)v27[2];
          BOOL v28 = *v32 == (void)v27;
          uint64_t v27 = v32;
        }
        while (!v28);
      }
      uint64_t v27 = v32;
      if (v25 == (void *)&buf[8]) {
        goto LABEL_52;
      }
    }
LABEL_55:
    xpc_object_t v34 = v93 + 17;
    if (v26 != (uint64_t *)(v93 + 17))
    {
      do
      {
        long long v35 = *(void **)&buf[8];
        if (!*(void *)&buf[8]) {
          goto LABEL_66;
        }
        unint64_t v36 = v26[4];
        uint64_t v37 = &buf[8];
        do
        {
          BOOL v38 = v35;
          int v39 = v37;
          unint64_t v40 = v35[4];
          uint64_t v41 = v35 + 1;
          if (v40 >= v36)
          {
            uint64_t v41 = v38;
            uint64_t v37 = v38;
          }
          long long v35 = (void *)*v41;
        }
        while (v35);
        if (v37 != &buf[8] && (v40 >= v36 ? (uint64_t v42 = v38) : (uint64_t v42 = v39), v43 = *((void *)v42 + 4), v36 >= v43))
        {
          if (v40 >= v36) {
            uint64_t v49 = v38;
          }
          else {
            uint64_t v49 = v39;
          }
          int v50 = *((_DWORD *)v49 + 10);
          if (v36 == v43 && *((_DWORD *)v26 + 10) == v50)
          {
            if (v40 >= v36) {
              v53 = v38;
            }
            else {
              v53 = v39;
            }
            *((void *)v53 + 6) = v26[6];
          }
          else
          {
            uint64_t v52 = *v94;
            if (os_log_type_enabled(*v94, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v95[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "context does not equal iterator", (uint8_t *)v95, 2u);
            }
          }
        }
        else
        {
LABEL_66:
          uint64_t v44 = *v94;
          if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = v26[4];
            int v46 = *((_DWORD *)v26 + 10);
            LODWORD(v95[0]) = 134218240;
            *(void *)((char *)v95 + 4) = v45;
            WORD2(v95[1]) = 1024;
            *(_DWORD *)((char *)&v95[1] + 6) = v46;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Destroying tethering threshold source for 0x%08llX, current ifindex: %d", (uint8_t *)v95, 0x12u);
          }
          (*((void (**)(Registry **, uint64_t *))*v93 + 8))(v93, v26 + 4);
        }
        xpc_object_t v47 = (uint64_t *)v26[1];
        if (v47)
        {
          do
          {
            CFTypeID v48 = v47;
            xpc_object_t v47 = (uint64_t *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            CFTypeID v48 = (uint64_t *)v26[2];
            BOOL v28 = *v48 == (void)v26;
            xpc_object_t v26 = v48;
          }
          while (!v28);
        }
        xpc_object_t v26 = v48;
      }
      while (v48 != (uint64_t *)v34);
    }
    if (v24 != (uint64_t **)buf)
    {
      uint64_t v54 = *(unsigned char **)buf;
      if (v93[18]
        && ((v55 = *v24, *int v24 = (uint64_t *)v34, *((void *)*v34 + 2) = 0, *v34 = 0, v93[18] = 0, v55[1])
          ? (uint64_t v56 = v55[1])
          : (uint64_t v56 = (uint64_t)v55),
            v56))
      {
        BOOL v57 = sub_1000EA590(v56);
        if (v54 == &buf[8])
        {
          uint64_t v58 = (void *)v56;
          __int16 v64 = &buf[8];
        }
        else
        {
          do
          {
            uint64_t v58 = v57;
            unint64_t v59 = *((void *)v54 + 4);
            *(void *)(v56 + 32) = v59;
            *(_OWORD *)(v56 + 40) = *(_OWORD *)(v54 + 40);
            xpc_object_t v60 = (uint64_t *)*v34;
            uint64_t v61 = (uint64_t **)(v93 + 17);
            xpc_object_t v62 = (uint64_t **)(v93 + 17);
            if (*v34)
            {
              do
              {
                while (1)
                {
                  uint64_t v61 = (uint64_t **)v60;
                  if (v59 >= v60[4]) {
                    break;
                  }
                  xpc_object_t v60 = (uint64_t *)*v60;
                  xpc_object_t v62 = v61;
                  if (!*v61) {
                    goto LABEL_102;
                  }
                }
                xpc_object_t v60 = (uint64_t *)v60[1];
              }
              while (v60);
              xpc_object_t v62 = v61 + 1;
            }
LABEL_102:
            sub_100046C38(v24, (uint64_t)v61, v62, (uint64_t *)v56);
            if (v57) {
              BOOL v57 = sub_1000EA590((uint64_t)v57);
            }
            else {
              BOOL v57 = 0;
            }
            uint64_t v63 = (void *)*((void *)v54 + 1);
            if (v63)
            {
              do
              {
                __int16 v64 = v63;
                uint64_t v63 = (void *)*v63;
              }
              while (v63);
            }
            else
            {
              do
              {
                __int16 v64 = (unsigned char *)*((void *)v54 + 2);
                BOOL v28 = *(void *)v64 == (void)v54;
                uint64_t v54 = v64;
              }
              while (!v28);
            }
            if (!v58) {
              break;
            }
            uint64_t v56 = (uint64_t)v58;
            uint64_t v54 = v64;
          }
          while (v64 != &buf[8]);
        }
        sub_1000346F8((uint64_t)v24, v58);
        if (v57)
        {
          for (uint64_t i = (void *)v57[2]; i; uint64_t i = (void *)i[2])
            BOOL v57 = i;
          sub_1000346F8((uint64_t)v24, v57);
        }
      }
      else
      {
        __int16 v64 = v54;
      }
      if (v64 != &buf[8])
      {
        do
        {
          v66 = operator new(0x38uLL);
          long long v67 = *((_OWORD *)v64 + 2);
          v66[6] = *((void *)v64 + 6);
          *((_OWORD *)v66 + 2) = v67;
          uint64_t v68 = (uint64_t *)*v34;
          xpc_object_t v69 = (uint64_t **)(v93 + 17);
          v70 = (uint64_t **)(v93 + 17);
          if (*v34)
          {
            do
            {
              while (1)
              {
                xpc_object_t v69 = (uint64_t **)v68;
                if (v66[4] >= (unint64_t)v68[4]) {
                  break;
                }
                uint64_t v68 = (uint64_t *)*v68;
                v70 = v69;
                if (!*v69) {
                  goto LABEL_126;
                }
              }
              uint64_t v68 = (uint64_t *)v68[1];
            }
            while (v68);
            v70 = v69 + 1;
          }
LABEL_126:
          sub_100046C38(v24, (uint64_t)v69, v70, v66);
          v71 = (void *)*((void *)v64 + 1);
          if (v71)
          {
            do
            {
              uint64_t v72 = v71;
              v71 = (void *)*v71;
            }
            while (v71);
          }
          else
          {
            do
            {
              uint64_t v72 = (unsigned char *)*((void *)v64 + 2);
              BOOL v28 = *(void *)v72 == (void)v64;
              __int16 v64 = v72;
            }
            while (!v28);
          }
          __int16 v64 = v72;
        }
        while (v72 != &buf[8]);
      }
    }
    sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
    long long v33 = v93;
LABEL_133:
    if ((v33[15] & 0x80000000) != 0)
    {
      v92 = *v94;
      if (os_log_type_enabled(*v94, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "Unable to determine internet ifindex for threshold monitoring", buf, 2u);
      }
    }
    else
    {
      v73 = (Registry **)v33[16];
      v74 = (uint64_t *)(v33 + 17);
      if (v73 != v33 + 17)
      {
        do
        {
          int v75 = *((_DWORD *)v73 + 10);
          if (v75 < 0)
          {
            v81 = *v94;
            if (os_log_type_enabled(*v94, OS_LOG_TYPE_ERROR))
            {
              v84 = v73[4];
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v75;
              *(_WORD *)&uint8_t buf[8] = 2048;
              *(void *)&buf[10] = v84;
              _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "Tethering interface index (%d) is not valid for 0x%08llX", buf, 0x12u);
            }
          }
          else
          {
            uint64_t InterfaceBytes = getInterfaceBytes(*((_DWORD *)v73 + 10));
            v73[6] = (Registry *)InterfaceBytes;
            v77 = *v94;
            if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
            {
              v78 = v73[4];
              int v79 = *((_DWORD *)v73 + 10);
              int v80 = *((_DWORD *)v73 + 11);
              *(_DWORD *)buf = 134218752;
              *(void *)&uint8_t buf[4] = v78;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v79;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v80;
              __int16 v99 = 2048;
              uint64_t v100 = InterfaceBytes;
              _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I Tethering bytes for 0x%08llX, index %d and context %d starting at: %llu", buf, 0x22u);
            }
          }
          v82 = (uint64_t *)v73[1];
          if (v82)
          {
            do
            {
              v83 = v82;
              v82 = (uint64_t *)*v82;
            }
            while (v82);
          }
          else
          {
            do
            {
              v83 = (uint64_t *)v73[2];
              BOOL v28 = *v83 == (void)v73;
              v73 = (Registry **)v83;
            }
            while (!v28);
          }
          v73 = (Registry **)v83;
        }
        while (v83 != v74);
        v85 = *v24;
        if (*v24 != v74)
        {
          do
          {
            v86 = *v94;
            if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v87 = v85[4];
              int v88 = *((_DWORD *)v85 + 10);
              int v89 = *((_DWORD *)v85 + 11);
              *(_DWORD *)buf = 134218496;
              *(void *)&uint8_t buf[4] = v87;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v88;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v89;
              _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I Threshold source 0x%08llX, Internet ifindex: %d, Tethering ifindex: %d", buf, 0x18u);
            }
            v90 = (uint64_t *)v85[1];
            if (v90)
            {
              do
              {
                v91 = v90;
                v90 = (uint64_t *)*v90;
              }
              while (v90);
            }
            else
            {
              do
              {
                v91 = (uint64_t *)v85[2];
                BOOL v28 = *v91 == (void)v85;
                v85 = v91;
              }
              while (!v28);
            }
            v85 = v91;
          }
          while (v91 != v74);
        }
      }
      (*((void (**)(Registry **))*v33 + 5))(v33);
      (*((void (**)(Registry **))*v33 + 6))(v33);
    }
  }
}

void sub_101114B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24)
{
}

void NetworkUsageStrategy::updateTetheringDataUsage_sync(void *a1, uint64_t *a2)
{
  unint64_t InterfaceBytes = getInterfaceBytes(*((_DWORD *)a2 + 2));
  if (InterfaceBytes)
  {
    unint64_t v5 = InterfaceBytes;
    unint64_t v6 = a2[2];
    uint64_t v7 = InterfaceBytes - v6;
    if (InterfaceBytes <= v6)
    {
      uint64_t v14 = a1[5];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v15 = 134218240;
        unint64_t v16 = v5;
        __int16 v17 = 2048;
        unint64_t v18 = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Ignoring tethering bytes (%llu) since there has been no increase (%llu)", (uint8_t *)&v15, 0x16u);
      }
    }
    else
    {
      char v8 = (std::__shared_weak_count *)a1[7];
      if (v8)
      {
        uint64_t v9 = *a2;
        uint64_t v10 = *((unsigned int *)a2 + 3);
        unint64_t v11 = std::__shared_weak_count::lock(v8);
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = a1[6];
          if (v13) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 24))(v13, v9, v7, v10);
          }
          sub_10004D2C8(v12);
        }
      }
      a2[2] = v5;
    }
  }
}

void sub_101114CBC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101114CD0(void **a1, void *a2)
{
  v38[0] = 0;
  v38[1] = 0;
  uint64_t v37 = v38;
  uint64_t v4 = (uint64_t)(a1 + 12);
  unint64_t v5 = (void **)a1[12];
  unint64_t v6 = a1 + 13;
  int v39 = &v37;
  unint64_t v40 = v38;
  if (v5 == a1 + 13)
  {
    uint64_t v10 = v38;
  }
  else
  {
    do
    {
      if (*((char *)v5 + 55) < 0)
      {
        sub_10004FC84(__p, v5[4], (unint64_t)v5[5]);
      }
      else
      {
        *(_OWORD *)long long __p = *((_OWORD *)v5 + 2);
        *(void *)&__p[16] = v5[6];
      }
      sub_1011153E8((uint64_t)&v39, (void **)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      uint64_t v7 = (void **)v5[1];
      if (v7)
      {
        do
        {
          char v8 = v7;
          uint64_t v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (void **)v5[2];
          BOOL v9 = *v8 == v5;
          unint64_t v5 = v8;
        }
        while (!v9);
      }
      unint64_t v5 = v8;
    }
    while (v8 != v6);
    uint64_t v10 = v37;
  }
  uint64_t v12 = (void **)(a2 + 1);
  unint64_t v11 = (void **)*a2;
  int v39 = &v37;
  unint64_t v40 = v10;
  if (v11 != a2 + 1)
  {
    do
    {
      if (*((char *)v11 + 55) < 0)
      {
        sub_10004FC84(__p, v11[4], (unint64_t)v11[5]);
      }
      else
      {
        *(_OWORD *)long long __p = *((_OWORD *)v11 + 2);
        *(void *)&__p[16] = v11[6];
      }
      sub_1011153E8((uint64_t)&v39, (void **)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      uint64_t v13 = (void **)v11[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void **)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void **)v11[2];
          BOOL v9 = *v14 == v11;
          unint64_t v11 = v14;
        }
        while (!v9);
      }
      unint64_t v11 = v14;
    }
    while (v14 != v12);
    uint64_t v10 = v37;
  }
  if (v10 == v38) {
    goto LABEL_85;
  }
  while (1)
  {
    int v15 = sub_100046F68(v4, (void **)v10 + 4);
    unint64_t v16 = sub_100046F68((uint64_t)a2, (void **)v10 + 4);
    if (v6 == v15) {
      break;
    }
    if (v12 == v16)
    {
      if (*((unsigned char *)v15 + 64) && !*((_DWORD *)v15 + 17))
      {
        uint64_t v22 = a1[5];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          int v31 = (char *)*((unsigned __int8 *)v10 + 55);
          BOOL v32 = (char)v31 < 0;
          if ((char)v31 < 0) {
            int v31 = v10[5];
          }
          if (v32) {
            long long v33 = v10[4];
          }
          else {
            long long v33 = (const char *)(v10 + 4);
          }
          if (v31) {
            uint64_t v27 = v33;
          }
          else {
            uint64_t v27 = "<invalid>";
          }
          uint64_t v28 = asStringBool(0);
          uint64_t v29 = asStringBool(1);
LABEL_83:
          *(_DWORD *)long long __p = 136315650;
          *(void *)&__p[4] = v27;
          *(_WORD *)&__p[12] = 2080;
          *(void *)&__p[14] = v28;
          *(_WORD *)&__p[22] = 2080;
          uint64_t v42 = v29;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I IMS iWLAN over cell registration changed for personality: %s: %s -> %s", __p, 0x20u);
          goto LABEL_84;
        }
        goto LABEL_84;
      }
    }
    else
    {
      if (!*((unsigned char *)v15 + 64))
      {
        if (!*((unsigned char *)v16 + 64) || *((_DWORD *)v16 + 17)) {
          goto LABEL_45;
        }
        BOOL v18 = 0;
        LOBYTE(v19) = 1;
LABEL_73:
        uint64_t v22 = a1[5];
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_84;
        }
        xpc_object_t v34 = (char *)*((unsigned __int8 *)v10 + 55);
        BOOL v35 = (char)v34 < 0;
        if ((char)v34 < 0) {
          xpc_object_t v34 = v10[5];
        }
        if (v35) {
          unint64_t v36 = v10[4];
        }
        else {
          unint64_t v36 = (const char *)(v10 + 4);
        }
        if (v34) {
          uint64_t v27 = v36;
        }
        else {
          uint64_t v27 = "<invalid>";
        }
        uint64_t v28 = asStringBool(v19);
        uint64_t v29 = asStringBool(v18);
        goto LABEL_83;
      }
      int v17 = *((_DWORD *)v15 + 17);
      BOOL v18 = v17 == 0;
      if (!*((unsigned char *)v16 + 64))
      {
        if (v17) {
          goto LABEL_45;
        }
        LOBYTE(v19) = 0;
        BOOL v18 = 1;
        goto LABEL_73;
      }
      BOOL v19 = *((_DWORD *)v16 + 17) == 0;
      if ((v17 == 0) != v19) {
        goto LABEL_73;
      }
    }
LABEL_45:
    char v20 = v10[1];
    if (v20)
    {
      do
      {
        unint64_t v21 = (char **)v20;
        char v20 = *(char **)v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        unint64_t v21 = (char **)v10[2];
        BOOL v9 = *v21 == (char *)v10;
        uint64_t v10 = v21;
      }
      while (!v9);
    }
    uint64_t v10 = v21;
    if (v21 == v38) {
      goto LABEL_85;
    }
  }
  if (!*((unsigned char *)v16 + 64) || *((_DWORD *)v16 + 17)) {
    goto LABEL_45;
  }
  uint64_t v22 = a1[5];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = (char *)*((unsigned __int8 *)v10 + 55);
    BOOL v25 = (char)v24 < 0;
    if ((char)v24 < 0) {
      int v24 = v10[5];
    }
    if (v25) {
      xpc_object_t v26 = v10[4];
    }
    else {
      xpc_object_t v26 = (const char *)(v10 + 4);
    }
    if (v24) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = "<invalid>";
    }
    uint64_t v28 = asStringBool(1);
    uint64_t v29 = asStringBool(0);
    goto LABEL_83;
  }
LABEL_84:
  (*((void (**)(void **, void))*a1 + 10))(a1, 0);
LABEL_85:
  sub_10005CD2C((uint64_t)&v37, v38[0]);
}

void sub_10111510C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

uint64_t sub_101115150(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)buf = 67109120;
    LODWORD(v21) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Internet Interface Index: %d", buf, 8u);
  }
  uint64_t v4 = *(void **)(a1 + 128);
  if (v4 != (void *)(a1 + 136))
  {
    do
    {
      unint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v6 = (void *)v4[4];
        int v7 = *((_DWORD *)v4 + 10);
        int v8 = *((_DWORD *)v4 + 11);
        uint64_t v9 = v4[6];
        *(_DWORD *)buf = 134218752;
        unint64_t v21 = v6;
        __int16 v22 = 1024;
        int v23 = v7;
        __int16 v24 = 1024;
        int v25 = v8;
        __int16 v26 = 2048;
        uint64_t v27 = v9;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Tethering Connection 0x%08llX, TetheringIfIndex: %d, TetheringContextID: %d, LastTetheringBytes: %llu", buf, 0x22u);
      }
      uint64_t v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unint64_t v11 = (void *)v4[2];
          BOOL v12 = *v11 == (void)v4;
          uint64_t v4 = v11;
        }
        while (!v12);
      }
      uint64_t v4 = v11;
    }
    while (v11 != (void *)(a1 + 136));
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Ignored UUIDs:", buf, 2u);
  }
  uint64_t v14 = *(void **)(a1 + 152);
  if (v14 != (void *)(a1 + 160))
  {
    do
    {
      int v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v16 = v14 + 4;
        if (*((char *)v14 + 55) < 0) {
          unint64_t v16 = (void *)*v16;
        }
        *(_DWORD *)buf = 136315138;
        unint64_t v21 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
      }
      int v17 = (void *)v14[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v14[2];
          BOOL v12 = *v18 == (void)v14;
          uint64_t v14 = v18;
        }
        while (!v12);
      }
      uint64_t v14 = v18;
    }
    while (v18 != (void *)(a1 + 160));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
}

uint64_t sub_1011153E8(uint64_t a1, void **a2)
{
  uint64_t v4 = *(uint64_t ***)a1;
  unint64_t v5 = *(uint64_t **)(a1 + 8);
  BOOL v19 = 0;
  char v20 = 0;
  if (v4 + 1 == (uint64_t **)v5 || (sub_100046FE8(a2, (void **)v5 + 4) & 0x80) != 0)
  {
    int v7 = v5;
    if (*v4 == v5) {
      goto LABEL_40;
    }
    int v8 = (uint64_t *)*v5;
    if (*v5)
    {
      do
      {
        int v7 = v8;
        int v8 = (uint64_t *)v8[1];
      }
      while (v8);
    }
    else
    {
      BOOL v12 = v5;
      do
      {
        int v7 = (uint64_t *)v12[2];
        BOOL v13 = *v7 == (void)v12;
        BOOL v12 = v7;
      }
      while (v13);
    }
    if ((sub_100046FE8(v7 + 4, a2) & 0x80) != 0)
    {
LABEL_40:
      if (*v5)
      {
        char v20 = v7;
        unint64_t v5 = v7 + 1;
      }
      else
      {
        char v20 = v5;
      }
LABEL_30:
      unint64_t v6 = (uint64_t **)v5;
      unint64_t v5 = (uint64_t *)*v5;
      if (v5) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
    goto LABEL_17;
  }
  if ((sub_100046FE8(v5 + 4, a2) & 0x80) != 0)
  {
    uint64_t v9 = v5[1];
    if (v9)
    {
      uint64_t v10 = (void *)v5[1];
      do
      {
        uint64_t v11 = (uint64_t)v10;
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
    else
    {
      uint64_t v14 = (uint64_t)v5;
      do
      {
        uint64_t v11 = *(void *)(v14 + 16);
        BOOL v13 = *(void *)v11 == v14;
        uint64_t v14 = v11;
      }
      while (!v13);
    }
    if ((uint64_t **)v11 == v4 + 1) {
      goto LABEL_27;
    }
    if ((sub_100046FE8(a2, (void **)(v11 + 32)) & 0x80) != 0)
    {
      uint64_t v9 = v5[1];
LABEL_27:
      if (v9)
      {
        char v20 = (uint64_t *)v11;
        unint64_t v5 = (uint64_t *)v11;
      }
      else
      {
        char v20 = v5++;
      }
      goto LABEL_30;
    }
LABEL_17:
    unint64_t v5 = sub_100046ED4((uint64_t)v4, &v20, a2);
    goto LABEL_30;
  }
  BOOL v19 = v5;
  char v20 = v5;
  unint64_t v6 = &v19;
  if (v5) {
    goto LABEL_32;
  }
LABEL_31:
  memset(v18, 0, sizeof(v18));
  sub_100C370E8((uint64_t)v4, (uint64_t)a2, v18);
  sub_100046C38(v4, (uint64_t)v20, v6, v18[0]);
  unint64_t v5 = v18[0];
LABEL_32:
  *(void *)(a1 + 8) = v5;
  int v15 = (uint64_t *)v5[1];
  if (v15)
  {
    do
    {
      unint64_t v16 = v15;
      int v15 = (uint64_t *)*v15;
    }
    while (v15);
  }
  else
  {
    do
    {
      unint64_t v16 = (uint64_t *)v5[2];
      BOOL v13 = *v16 == (void)v5;
      unint64_t v5 = v16;
    }
    while (!v13);
  }
  *(void *)(a1 + 8) = v16;
  return a1;
}

void *sub_1011155D8()
{
  v0 = sub_100058DB0(&qword_101B13210, "569F2700-CAF9-483D-B19D-7AF406DCE15E");
  return sub_100058DB0(v0 + 3, "67A03811-DB0A-594E-C2AE-8B0517EDF26F");
}

void sub_101115618(_Unwind_Exception *exception_object)
{
  if (byte_101B13227 < 0) {
    operator delete((void *)qword_101B13210);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10111563C()
{
  return sub_100058DB0(qword_101B13270, "/usr/sbin/pppd");
}

void sub_1011156A4(_Unwind_Exception *exception_object)
{
  while (1)
  {
    if (*(char *)(v2 - 1) < 0) {
      operator delete(*(void **)(v2 - 24));
    }
    v2 -= 24;
    if (v2 == v1) {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_1011156CC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v24, *(Registry **)(v1 + 64));
  ctu::RestModule::connect();
  if (v25) {
    sub_10004D2C8(v25);
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  sub_100058DB0(__p, "/cc/props/ims_registration_state");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A90940;
  v2[1] = v1 + 96;
  v2[2] = v1;
  v2[3] = sub_101114CD0;
  v2[4] = 0;
  uint64_t v29 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v26);
  if (v33 < 0) {
    operator delete(*(void **)__p);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  int v3 = operator new(0x20uLL);
  *int v3 = off_101A909C0;
  v3[1] = v1;
  void v3[2] = sub_101115150;
  uint64_t v3[3] = 0;
  uint64_t v29 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v26);
  if (v33 < 0) {
    operator delete(*(void **)__p);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13200, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13200))
  {
    sub_1011155D8();
    __cxa_guard_release(&qword_101B13200);
  }
  uint64_t v4 = &dword_100000010;
  do
  {
    sub_100046BAC((uint64_t **)(v1 + 152), (void **)((char *)&qword_101B13200 + v4), (uint64_t)&qword_101B13200 + v4);
    v4 += 24;
  }
  while (v4 != 64);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13208, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13208))
  {
    sub_10111563C();
    __cxa_guard_release(&qword_101B13208);
  }
  unint64_t v5 = (char *)&qword_101B13240;
  unint64_t v6 = (uint64_t *)&byte_10144BF80[128];
  while (1)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v1 + 64));
    int v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long __p = v9;
    BOOL v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        if (!v15) {
          goto LABEL_32;
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_32;
    }
LABEL_21:
    if ((*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)v15 + 16))(v15, v5, &v26))
    {
      uint64_t v18 = v26;
      uint64_t v17 = v27;
      while (v18 != v17)
      {
        BOOL v19 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = v18;
          if (*(char *)(v18 + 23) < 0) {
            uint64_t v20 = *(void *)v18;
          }
          unint64_t v21 = v5;
          if (v5[23] < 0) {
            unint64_t v21 = *(char **)v5;
          }
          *(_DWORD *)long long __p = 136446466;
          *(void *)&__p[4] = v20;
          __int16 v31 = 2082;
          BOOL v32 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Going to ignore UUID: %{public}s of process: %{public}s for data usage", __p, 0x16u);
        }
        sub_100046BAC((uint64_t **)(v1 + 152), (void **)v18, v18);
        v18 += 24;
      }
LABEL_32:
      if ((v16 & 1) == 0) {
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    __int16 v22 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    int v23 = v5;
    if (v5[23] < 0) {
      int v23 = *(char **)v5;
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v23;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Unable to parse UUID for process: %s", __p, 0xCu);
    if ((v16 & 1) == 0) {
LABEL_33:
    }
      sub_10004D2C8(v14);
LABEL_34:
    *(void *)long long __p = &v26;
    sub_100047F64((void ***)__p);
    v5 += 24;
    unint64_t v6 = (uint64_t *)&byte_101B13288;
    if (v5 == &byte_101B13288) {
      operator delete();
    }
  }
}

void sub_101115B5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

void sub_101115C38()
{
}

__n128 sub_101115C4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A90940;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101115CA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A90940;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101115CD8(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *int v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_101115D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_101115DB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101115DF0()
{
}

void sub_101115E00()
{
}

__n128 sub_101115E14(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A909C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101115E68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A909C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101115EA0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  int v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101115EE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101115F28()
{
}

uint64_t *sub_101115F34(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 80));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_101115FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_101115FD4(void **a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(*(void *)**a1 + 24))(**a1);
  operator delete();
}

void sub_101116048()
{
}

void sub_101116074(void **a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(*(void *)**a1 + 32))(**a1);
  operator delete();
}

void sub_1011160E8()
{
}

void sub_101116114(void **a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = *(void **)(a2 + 128);
  int v3 = (void *)(a2 + 136);
  if (v2 != (void *)(a2 + 136))
  {
    uint64_t v5 = 0;
    do
    {
      unint64_t InterfaceBytes = getInterfaceBytes(*((_DWORD *)v2 + 10));
      unint64_t v7 = v2[6];
      BOOL v8 = InterfaceBytes >= v7;
      unint64_t v9 = InterfaceBytes - v7;
      if (v8) {
        unint64_t v10 = v9;
      }
      else {
        unint64_t v10 = 0;
      }
      uint64_t v11 = (char *)a1[2];
      if (v5 >= v11)
      {
        uint64_t v14 = (char *)*a1;
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 3);
        unint64_t v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_10006A748();
        }
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v14) >> 3);
        if (2 * v17 > v16) {
          unint64_t v16 = 2 * v17;
        }
        if (v17 >= 0x555555555555555) {
          unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18 > 0xAAAAAAAAAAAAAAALL) {
          sub_10006A7CC();
        }
        BOOL v19 = (char *)operator new(24 * v18);
        uint64_t v20 = v2[4];
        int v21 = *((_DWORD *)v2 + 11);
        __int16 v22 = &v19[24 * v15];
        *(void *)__int16 v22 = v10;
        *((_DWORD *)v22 + 2) = v21;
        *((void *)v22 + 2) = v20;
        if (v5 == v14)
        {
          uint64_t v14 = v5;
          int v23 = &v19[24 * v15];
        }
        else
        {
          int v23 = &v19[24 * v15];
          do
          {
            long long v24 = *(_OWORD *)(v5 - 24);
            *((void *)v23 - 1) = *((void *)v5 - 1);
            *(_OWORD *)(v23 - 24) = v24;
            v23 -= 24;
            v5 -= 24;
          }
          while (v5 != v14);
        }
        uint64_t v5 = v22 + 24;
        *a1 = v23;
        a1[1] = v22 + 24;
        a1[2] = &v19[24 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        uint64_t v12 = v2[4];
        int v13 = *((_DWORD *)v2 + 11);
        *(void *)uint64_t v5 = v10;
        *((_DWORD *)v5 + 2) = v13;
        *((void *)v5 + 2) = v12;
        v5 += 24;
      }
      a1[1] = v5;
      int v25 = (void *)v2[1];
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          int v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (void *)v2[2];
          BOOL v27 = *v26 == (void)v2;
          uint64_t v2 = v26;
        }
        while (!v27);
      }
      uint64_t v2 = v26;
    }
    while (v26 != v3);
  }
}

void sub_1011162D4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_101116300(uint64_t a1@<X0>, void **a2@<X8>)
{
}

double sub_101116310(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

double sub_10111637C(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

void sub_1011163E8(void **a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void))(*(void *)**a1 + 80))(**a1, 0);
  operator delete();
}

void sub_101116460()
{
}

void stewie::ServiceSearch::create()
{
}

void sub_101116574(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

unint64_t stewie::ServiceSearch::getOptimalTarget(uint64_t a1, uint64_t a2, double *a3)
{
  long long v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5 && (BOOL v8 = std::__shared_weak_count::lock(v5)) != 0)
  {
    unint64_t v9 = v8;
    uint64_t v10 = *(void *)(a1 + 24);
    if (v10)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v10 + 16))(&v27, v10);
      if (v27)
      {
        uint64_t v11 = *(void **)(v27 + 16);
        if (v11 == (void *)(v27 + 24))
        {
          __int16 v22 = 0;
          LOBYTE(v12) = 0;
          unsigned int v3 = 0;
        }
        else
        {
          unsigned int v3 = 0;
          LOBYTE(v12) = 0;
          int v13 = 0;
          uint64_t v14 = 0;
          double v15 = 0.0;
          uint64_t v16 = 0;
          double v17 = 0.0;
          do
          {
            unint64_t v18 = (unsigned int *)v11[5];
            if (!*((unsigned char *)v18 + 12) || !*((unsigned char *)v18 + 4))
            {
              uint64_t v24 = 0;
              double v25 = 0.0;
              uint64_t v26 = 0;
              if ((*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t *))(*(void *)v10 + 24))(v10, *v18, a2, &v24))
              {
                if (v25 >= v17)
                {
                  int v12 = *v18;
                  unsigned int v3 = *v18 >> 8;
                  int v13 = 1;
                  uint64_t v14 = v24;
                  uint64_t v16 = v26;
                  double v15 = v25;
                  double v17 = v25;
                }
              }
            }
            BOOL v19 = (void *)v11[1];
            if (v19)
            {
              do
              {
                uint64_t v20 = v19;
                BOOL v19 = (void *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                uint64_t v20 = (void *)v11[2];
                BOOL v21 = *v20 == (void)v11;
                uint64_t v11 = v20;
              }
              while (!v21);
            }
            uint64_t v11 = v20;
          }
          while (v20 != (void *)(v27 + 24));
          if (v13)
          {
            *(void *)a3 = v14;
            a3[1] = v15;
            __int16 v22 = &_mh_execute_header;
            *((void *)a3 + 2) = v16;
          }
          else
          {
            __int16 v22 = 0;
          }
        }
      }
      else
      {
        __int16 v22 = 0;
        LOBYTE(v12) = 0;
      }
      if (v28) {
        sub_10004D2C8(v28);
      }
    }
    else
    {
      LOBYTE(v12) = 0;
      __int16 v22 = 0;
    }
    sub_10004D2C8(v9);
  }
  else
  {
    LOBYTE(v12) = 0;
    __int16 v22 = 0;
  }
  return (unint64_t)v22 & (unint64_t)&_mh_execute_header | v12 | ((*(void *)&v3 & 0xFFFFFFLL) << 8);
}

void sub_1011167B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void stewie::ServiceSearch::getServiceWindow(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (*a2 > *a3)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(unsigned char *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 32) = 0;
    return;
  }
  long long v5 = (os_log_t *)a1;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v6);
    uint64_t v10 = v9;
    if (v9)
    {
      os_log_t v11 = v5[3];
      if (v11)
      {
        uint64_t v36 = a4;
        xpc_object_t v34 = a2;
        BOOL v35 = a3;
        os_log_t v12 = v5[1];
        unint64_t v50 = 1000000000 * (*a2 / 0x3B9ACA00 - (void)v12 - *a2 / 0x3B9ACA00 % (unint64_t)v12);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        unint64_t v43 = *a3;
        v47[0] = *a3;
        v47[1] = v12;
        v47[2] = v11;
        void v47[3] = v9;
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        unint64_t v48 = 0;
        v47[4] = v5;
        unint64_t v49 = 0;
        uint64_t v37 = v9;
        sub_10004D2C8(v9);
        sub_101116DE0(&buf, (uint64_t)v47, &v50);
        uint64_t v38 = 0;
        unint64_t v13 = buf;
        unint64_t v48 = buf;
        BYTE4(v49) = BYTE12(buf);
        LODWORD(v49) = DWORD2(buf);
        uint64_t v14 = BYTE12(buf);
        BOOL v39 = BYTE12(buf) != 0;
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        uint64_t v40 = 0;
        uint64_t v44 = 1000000000 * (void)v12;
        uint64_t v41 = -1000000000 * (void)v12;
        while (1)
        {
          LODWORD(v15) = v14;
          do
          {
            if (v13 >= v43) {
              goto LABEL_49;
            }
            uint64_t v16 = v14;
            *(void *)uint64_t v52 = v44 + v13;
            sub_101116DE0(&buf, (uint64_t)v47, v52);
            unint64_t v13 = buf;
            unint64_t v48 = buf;
            BYTE4(v49) = BYTE12(buf);
            LODWORD(v49) = DWORD2(buf);
            if ((v15 != 0) == (BYTE12(buf) != 0))
            {
              int v27 = 2;
              uint64_t v15 = BYTE4(v49);
              uint64_t v14 = v16;
              continue;
            }
            double v17 = v5;
            unint64_t v18 = *v5;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 134217984;
              *(void *)((char *)&buf + 4) = v13 / 0x3B9ACA00;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I  - advance: detected service change at: %llu", (uint8_t *)&buf, 0xCu);
            }
            unsigned __int8 v19 = BYTE4(v49);
            unint64_t v20 = v13 + v41;
            unint64_t v21 = v49;
            unint64_t v22 = v13;
            if (v13 + v41 <= v13)
            {
              unint64_t v23 = v13;
              do
              {
                *(void *)uint64_t v52 = 1000000000 * (v20 / 0x3B9ACA00 + ((v23 / 0x3B9ACA00 - v20 / 0x3B9ACA00) >> 1));
                sub_101116DE0(&buf, (uint64_t)v47, v52);
                if ((v15 != 0) != (BYTE12(buf) != 0)) {
                  unint64_t v23 = *(void *)v52 - 1000000000;
                }
                else {
                  unint64_t v20 = *(void *)v52 + 1000000000;
                }
              }
              while (v20 <= v23);
              unint64_t v22 = buf;
              unint64_t v21 = DWORD2(buf) | ((unint64_t)BYTE12(buf) << 32);
            }
            if ((v15 != 0) != ((v21 & 0xFF00000000) != 0)) {
              unint64_t v24 = v22;
            }
            else {
              unint64_t v24 = v22 + 1000000000;
            }
            double v25 = *v17;
            if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 134217984;
              *(void *)((char *)&buf + 4) = v24 / 0x3B9ACA00;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I  - advance: second accurate change at: %llu", (uint8_t *)&buf, 0xCu);
            }
            long long buf = 0uLL;
            *(void *)uint64_t v52 = v24 + v44;
            sub_101116DE0(&buf, (uint64_t)v47, v52);
            if ((v15 != 0) == (BYTE12(buf) != 0))
            {
              unint64_t v51 = v13 + v44;
              sub_101116DE0(v52, (uint64_t)v47, &v51);
              BOOL v28 = v15 != 0;
              unint64_t v13 = *(void *)v52;
              unint64_t v48 = *(void *)v52;
              BYTE4(v49) = v54;
              LODWORD(v49) = v53;
              uint64_t v15 = v54;
              char v29 = v28 ^ (v54 != 0);
              uint64_t v26 = *v17;
              BOOL v30 = os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT);
              if ((v29 & 1) == 0)
              {
                if (v30)
                {
                  *(_WORD *)uint64_t v52 = 0;
                  int v27 = 2;
                  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I  - advance: skipping short change", v52, 2u);
                }
                else
                {
                  int v27 = 2;
                }
                unint64_t v24 = v42;
                goto LABEL_36;
              }
              if (v30)
              {
LABEL_30:
                *(_WORD *)uint64_t v52 = 0;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I  - advance: second accurate change is valid", v52, 2u);
              }
            }
            else
            {
              uint64_t v15 = v19;
              uint64_t v26 = *v17;
              if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_30;
              }
            }
            int v27 = 1;
LABEL_36:
            uint64_t v14 = v16;
            unint64_t v42 = v24;
            long long v5 = v17;
          }
          while (v27 == 2);
          if (!v42) {
            goto LABEL_49;
          }
          if (v42 >= *v34)
          {
            if (v14)
            {
              if (!v40)
              {
                BOOL v32 = (unint64_t *)&v46;
LABEL_46:
                unint64_t *v32 = v42;
                uint64_t v31 = v46;
                uint64_t v38 = v45;
                goto LABEL_47;
              }
              int v33 = 270;
            }
            else
            {
              if (!v38)
              {
                BOOL v32 = (unint64_t *)&v45;
                goto LABEL_46;
              }
              int v33 = 277;
            }
            __assert_rtn("getServiceWindow", "ConnectionAssistantServiceSearch_ios.cpp", v33, "false");
          }
          BOOL v39 = v15 != 0;
          unint64_t v50 = v42;
          uint64_t v31 = v40;
LABEL_47:
          uint64_t v14 = v15;
          uint64_t v40 = v31;
          if (v31)
          {
            uint64_t v14 = v15;
            if (v38)
            {
LABEL_49:
              stewie::ServiceWindow::ServiceWindow(v36, &v50, v35, v39, &v46, &v45);
              uint64_t v10 = v37;
              sub_10004D2C8(v37);
              goto LABEL_52;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  if (v10) {
LABEL_52:
  }
    sub_10004D2C8(v10);
}

void sub_101116DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
}

void sub_101116DE0(void *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = **(NSObject ***)(a2 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = *a3 / 0x3B9ACA00uLL;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: %llu", (uint8_t *)&buf, 0xCu);
  }
  long long buf = 0uLL;
  uint64_t v24 = 0;
  if (*(unsigned char *)(a2 + 52)
    && (*(unsigned int (**)(void, void, void *, long long *))(**(void **)(a2 + 16) + 24))(*(void *)(a2 + 16), *(unsigned int *)(a2 + 48), a3, &buf))
  {
    BOOL v8 = **(NSObject ***)(a2 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(unsigned char *)(a2 + 52)) {
        sub_10016C840();
      }
      int v9 = *(_DWORD *)(a2 + 48);
      *(_DWORD *)unint64_t v21 = 67109120;
      *(_DWORD *)&void v21[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: reusing target id: %d", v21, 8u);
    }
    uint64_t v10 = *(void *)(a2 + 48);
    *a1 = *a3;
    a1[1] = v10;
  }
  else
  {
    *(void *)unint64_t v21 = 0;
    unint64_t v22 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a2 + 16) + 16))(v21);
    if (!*(void *)v21 || (os_log_t v11 = *(void **)(*(void *)v21 + 16), v11 == (void *)(*(void *)v21 + 24)))
    {
LABEL_24:
      unint64_t v16 = 0;
      *a1 = *a3;
    }
    else
    {
      while (1)
      {
        uint64_t v12 = v11[5];
        BOOL v13 = *(unsigned char *)(a2 + 52) && *(_DWORD *)v12 == *(_DWORD *)(a2 + 48);
        if (!v13
          && (!*(unsigned char *)(v12 + 12) || !*(unsigned char *)(v12 + 4))
          && (*(unsigned int (**)(void))(**(void **)(a2 + 16) + 24))(*(void *)(a2 + 16)))
        {
          break;
        }
        uint64_t v14 = (void *)v11[1];
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v15 = (void *)v11[2];
            BOOL v13 = *v15 == (void)v11;
            os_log_t v11 = v15;
          }
          while (!v13);
        }
        os_log_t v11 = v15;
        if (v15 == (void *)(*(void *)v21 + 24)) {
          goto LABEL_24;
        }
      }
      double v17 = **(NSObject ***)(a2 + 32);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = *(_DWORD *)v11[5];
        v20[0] = 67109120;
        v20[1] = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I  - getStateAt: tracking target id: %d", (uint8_t *)v20, 8u);
      }
      uint64_t v19 = *(unsigned int *)v11[5];
      *a1 = *a3;
      unint64_t v16 = v19 | (unint64_t)&_mh_execute_header;
    }
    a1[1] = v16;
    if (v22) {
      sub_10004D2C8(v22);
    }
  }
}

void sub_1011170D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void stewie::ServiceSearch::getServicePlot(uint64_t a1@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, void *a4@<X3>, unint64_t *a5@<X8>)
{
  if (*a2 > *a3)
  {
    *((_OWORD *)a5 + 1) = 0u;
    *((_OWORD *)a5 + 2) = 0u;
    *(_OWORD *)a5 = 0u;
    return;
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7)
  {
    int v9 = a3;
    os_log_t v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      uint64_t v12 = *(void *)(a1 + 24);
      if (v12)
      {
        uint64_t v76 = 0;
        v77 = 0;
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v12 + 16))(&v76, v12);
        if (v76)
        {
          unint64_t v13 = *(void *)(a1 + 16);
          unint64_t v14 = 1000000000 * *a2 / 0x3B9ACA00 / v13 * v13;
          v73 = 0;
          v74 = 0;
          int v75 = 0;
          unint64_t v70 = v14;
          double v15 = (double)((*v9 / 0x3B9ACA00 - v14 / 0x3B9ACA00) / v13) * 1.6;
          unint64_t v16 = (unint64_t)v15;
          if ((unint64_t)v15)
          {
            if (v16 > 0x666666666666666) {
              sub_101117994();
            }
            v73 = (char *)sub_10005ED10((uint64_t)&v75, (unint64_t)v15);
            v74 = v73;
            int v75 = &v73[40 * v17];
          }
          int v18 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = v16;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: reserved space for %zu readings", (uint8_t *)&buf, 0xCu);
          }
          xpc_object_t v69 = a5;
          v71 = v9;
          if (*a4 && a4[1] && a4[2])
          {
            uint64_t v19 = a4[3];
            uint64_t v20 = a4[4];
            unint64_t v21 = v70;
            if (v19 != v20)
            {
              unint64_t v21 = v70;
              do
              {
                if (*(void *)v19 >= v21)
                {
                  unint64_t v22 = v74;
                  if (v74 >= v75)
                  {
                    unint64_t v24 = 0xCCCCCCCCCCCCCCCDLL * ((v74 - v73) >> 3);
                    unint64_t v25 = v24 + 1;
                    if (v24 + 1 > 0x666666666666666) {
                      sub_101117994();
                    }
                    if (0x999999999999999ALL * ((v75 - v73) >> 3) > v25) {
                      unint64_t v25 = 0x999999999999999ALL * ((v75 - v73) >> 3);
                    }
                    if (0xCCCCCCCCCCCCCCCDLL * ((v75 - v73) >> 3) >= 0x333333333333333) {
                      unint64_t v26 = 0x666666666666666;
                    }
                    else {
                      unint64_t v26 = v25;
                    }
                    int v27 = (char *)sub_10005ED10((uint64_t)&v75, v26);
                    char v29 = &v27[8 * ((v74 - v73) >> 3)];
                    *(void *)char v29 = *(void *)v19;
                    *((_DWORD *)v29 + 2) = *(_DWORD *)(v19 + 8);
                    *((_OWORD *)v29 + 1) = *(_OWORD *)(v19 + 16);
                    *((void *)v29 + 4) = *(void *)(v19 + 32);
                    BOOL v30 = v73;
                    uint64_t v31 = v74;
                    if (v74 == v73)
                    {
                      xpc_object_t v34 = &v27[40 * v24];
                    }
                    else
                    {
                      uint64_t v32 = 0;
                      do
                      {
                        int v33 = &v29[v32];
                        *((void *)v33 - 5) = *(void *)&v31[v32 - 40];
                        *((_DWORD *)v33 - 8) = *(_DWORD *)&v31[v32 - 32];
                        *(_OWORD *)(v33 - 24) = *(_OWORD *)&v31[v32 - 24];
                        *((void *)v33 - 1) = *(void *)&v31[v32 - 8];
                        v32 -= 40;
                      }
                      while (&v31[v32] != v30);
                      xpc_object_t v34 = &v29[v32];
                    }
                    unint64_t v23 = v29 + 40;
                    v73 = v34;
                    v74 = v29 + 40;
                    int v75 = &v27[40 * v28];
                    if (v30) {
                      operator delete(v30);
                    }
                  }
                  else
                  {
                    *(void *)v74 = *(void *)v19;
                    *((_DWORD *)v22 + 2) = *(_DWORD *)(v19 + 8);
                    *((_OWORD *)v22 + 1) = *(_OWORD *)(v19 + 16);
                    *((void *)v22 + 4) = *(void *)(v19 + 32);
                    unint64_t v23 = v22 + 40;
                  }
                  v74 = v23;
                  unint64_t v21 = *(void *)v19;
                }
                v19 += 40;
              }
              while (v19 != v20);
            }
            if (v73 != v74)
            {
              BOOL v35 = *(NSObject **)a1;
              if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 134217984;
                *(void *)((char *)&buf + 4) = 0xCCCCCCCCCCCCCCCDLL * ((v74 - v73) >> 3);
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: reused %zu readings", (uint8_t *)&buf, 0xCu);
              }
              v21 += 1000000000 * *(void *)(a1 + 16);
            }
            int v9 = v71;
          }
          else
          {
            uint64_t v36 = *(NSObject **)a1;
            unint64_t v21 = v70;
            if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I getServicePlot: lastKnownPlot is invalid, skipping", (uint8_t *)&buf, 2u);
              unint64_t v21 = v70;
            }
          }
          uint64_t v37 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I getServicePlot [", (uint8_t *)&buf, 2u);
          }
          unint64_t v72 = v21;
          unint64_t v38 = *v9;
          if (v21 < *v9)
          {
            uint64_t v39 = v76;
            do
            {
              uint64_t v40 = *(void **)(v39 + 16);
              if (v40 != (void *)(v39 + 24))
              {
                do
                {
                  uint64_t v41 = (unsigned int *)v40[5];
                  if (!*((unsigned char *)v41 + 12) || !*((unsigned char *)v41 + 4))
                  {
                    long long buf = 0uLL;
                    uint64_t v83 = 0;
                    if ((*(unsigned int (**)(uint64_t, void, unint64_t *, long long *))(*(void *)v12 + 24))(v12, *v41, &v72, &buf))
                    {
                      unint64_t v42 = *(NSObject **)a1;
                      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                      {
                        int v43 = *v41;
                        *(_DWORD *)v78 = 67109376;
                        int v79 = v43;
                        __int16 v80 = 2048;
                        double v81 = *((double *)&buf + 1) * 180.0 / 3.14159265;
                        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I  - getServicePlot: id: %d, service: %.2f", v78, 0x12u);
                      }
                      unint64_t v44 = v72;
                      int v45 = *v41;
                      long long v46 = buf;
                      uint64_t v47 = v83;
                      unint64_t v48 = v74;
                      if (v74 >= v75)
                      {
                        unint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * ((v74 - v73) >> 3);
                        unint64_t v51 = v50 + 1;
                        if (v50 + 1 > 0x666666666666666) {
                          sub_101117994();
                        }
                        if (0x999999999999999ALL * ((v75 - v73) >> 3) > v51) {
                          unint64_t v51 = 0x999999999999999ALL * ((v75 - v73) >> 3);
                        }
                        if (0xCCCCCCCCCCCCCCCDLL * ((v75 - v73) >> 3) >= 0x333333333333333) {
                          unint64_t v52 = 0x666666666666666;
                        }
                        else {
                          unint64_t v52 = v51;
                        }
                        int v53 = (char *)sub_10005ED10((uint64_t)&v75, v52);
                        xpc_connection_t v55 = &v53[40 * v50];
                        *(void *)xpc_connection_t v55 = v44;
                        *((_DWORD *)v55 + 2) = v45;
                        *((_OWORD *)v55 + 1) = v46;
                        *((void *)v55 + 4) = v47;
                        uint64_t v56 = v73;
                        BOOL v57 = v74;
                        if (v74 == v73)
                        {
                          xpc_object_t v60 = &v53[40 * v50];
                        }
                        else
                        {
                          uint64_t v58 = 0;
                          do
                          {
                            unint64_t v59 = &v55[v58];
                            *((void *)v59 - 5) = *(void *)&v57[v58 - 40];
                            *((_DWORD *)v59 - 8) = *(_DWORD *)&v57[v58 - 32];
                            *(_OWORD *)(v59 - 24) = *(_OWORD *)&v57[v58 - 24];
                            *((void *)v59 - 1) = *(void *)&v57[v58 - 8];
                            v58 -= 40;
                          }
                          while (&v57[v58] != v56);
                          xpc_object_t v60 = &v55[v58];
                        }
                        unint64_t v49 = v55 + 40;
                        v73 = v60;
                        v74 = v55 + 40;
                        int v75 = &v53[40 * v54];
                        if (v56) {
                          operator delete(v56);
                        }
                      }
                      else
                      {
                        *(void *)v74 = v72;
                        *((_DWORD *)v48 + 2) = v45;
                        *((_OWORD *)v48 + 1) = v46;
                        unint64_t v49 = v48 + 40;
                        *((void *)v48 + 4) = v47;
                      }
                      v74 = v49;
                    }
                  }
                  uint64_t v61 = (void *)v40[1];
                  if (v61)
                  {
                    do
                    {
                      xpc_object_t v62 = v61;
                      uint64_t v61 = (void *)*v61;
                    }
                    while (v61);
                  }
                  else
                  {
                    do
                    {
                      xpc_object_t v62 = (void *)v40[2];
                      BOOL v63 = *v62 == (void)v40;
                      uint64_t v40 = v62;
                    }
                    while (!v63);
                  }
                  uint64_t v39 = v76;
                  uint64_t v40 = v62;
                }
                while (v62 != (void *)(v76 + 24));
                unint64_t v21 = v72;
                unint64_t v38 = *v71;
              }
              v21 += 1000000000 * *(void *)(a1 + 16);
              unint64_t v72 = v21;
            }
            while (v21 < v38);
          }
          __int16 v64 = *(NSObject **)a1;
          BOOL v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
          v66 = v73;
          long long v67 = v74;
          if (v65)
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = 0xCCCCCCCCCCCCCCCDLL * ((v74 - v73) >> 3);
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I getServicePlot ] - %zu readings", (uint8_t *)&buf, 0xCu);
            unint64_t v38 = *v71;
            v66 = v73;
            long long v67 = v74;
          }
          *xpc_object_t v69 = v70;
          v69[1] = v70;
          v69[2] = v38;
          v69[3] = (unint64_t)v66;
          uint64_t v68 = v75;
          v69[4] = (unint64_t)v67;
          v69[5] = (unint64_t)v68;
        }
        else
        {
          *((_OWORD *)a5 + 1) = 0u;
          *((_OWORD *)a5 + 2) = 0u;
          *(_OWORD *)a5 = 0u;
        }
        if (v77) {
          sub_10004D2C8(v77);
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
    os_log_t v11 = 0;
  }
  *((_OWORD *)a5 + 1) = 0u;
  *((_OWORD *)a5 + 2) = 0u;
  *(_OWORD *)a5 = 0u;
LABEL_12:
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_101117944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_10004D2C8(a10);
  _Unwind_Resume(a1);
}

void sub_101117994()
{
}

void sub_1011179AC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101117A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_101117AC4((int)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101117A40(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101117A78(uint64_t a1)
{
}

uint64_t sub_101117A80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_101117AC4(int a1, ctu::OsLogLogger *this)
{
  if (this)
  {
    unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    ctu::OsLogLogger::~OsLogLogger(this);
    operator delete();
  }
}

void sub_101117B20(void *a1, void *a2)
{
  *(void *)operator new(8uLL) = @"Roadside";
  sub_1011241AC(a1, a2, "stw.rs.env");
}

void sub_101117BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  double v15 = v14;
  operator delete(v15);
  sub_101126828(v13);
  _Unwind_Resume(a1);
}

uint64_t sub_101117C38(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = (id *)(a1 + 8);
  long long v5 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting up environment", (uint8_t *)&__p, 2u);
  }

  uint64_t v6 = sub_101117E48(a1);
  LOBYTE(v8) = v7;
  int v9 = sub_100200FB4(v4);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v8;
    if ((_BYTE)v8)
    {
      std::to_string(&__p, (unint64_t)v6);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v19 = (const char *)p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Found stored providerId: %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v19 = "<none>";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Found stored providerId: %{public}s", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v8 = v8;
  }

  int v12 = *a2;
  uint64_t v11 = (uint64_t)(a2 + 8);
  BOOL v13 = v12 != 0;
  if (v8) {
    int v14 = v13;
  }
  else {
    int v14 = 0;
  }
  uint64_t result = sub_1011244F4(a1, v11, v14);
  if (*(unsigned char *)(a1 + 272)) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = v8 != 0;
  }
  if (v16) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 288) + 16))(*(void *)(a1 + 288));
  }
  return result;
}

void sub_101117E30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void *sub_101117E48(uint64_t a1)
{
  long long v5 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 288) + 8))(&v6);
  sub_1000842D0(&v5, &v6);
  sub_1000577C4(&v6);
  if (v5) {
    int v2 = sub_100081E58;
  }
  else {
    int v2 = 0;
  }
  if (v2)
  {
    uint64_t v6 = 0;
    ctu::cf::assign((ctu::cf *)&v6, v5, v1);
    unsigned int v3 = v6;
    sub_1000570E8((const void **)&v5);
  }
  else
  {
    sub_1000570E8((const void **)&v5);
    return 0;
  }
  return v3;
}

void sub_101117F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_101117F28(uint64_t a1, uint64_t a2)
{
  id v3 = +[NSNumber numberWithUnsignedLongLong:a2];
  (***(void (****)(void))(a1 + 288))();
}

void sub_101117FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

const char *sub_101117FD0()
{
  return "com.apple.avocet.quagmire";
}

uint64_t sub_101117FDC()
{
  return 28800;
}

uint64_t sub_101117FE4()
{
  return 0;
}

void sub_101117FEC(uint64_t a1)
{
  sub_1011263E8(a1);
  int v2 = (id *)(a1 + 8);
  id v3 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 273) && *(void *)(a1 + 88))
    {
      uint64_t v4 = "false";
      if (*(void *)(a1 + 152) && *(void *)(a1 + 168)) {
        uint64_t v4 = "true";
      }
    }
    else
    {
      uint64_t v4 = "false";
    }
    int v9 = 136315138;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] Ready: %s", (uint8_t *)&v9, 0xCu);
  }

  long long v5 = (const char *)sub_101117E48(a1);
  if (v6)
  {
    char v7 = v5;
    uint64_t v8 = sub_100200FB4(v2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 134217984;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [d] Provider Id: %llu", (uint8_t *)&v9, 0xCu);
    }
  }
}

void *sub_101118150(void *a1)
{
  *a1 = off_101A90B58;
  uint64_t v2 = a1[36];
  a1[36] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }

  return sub_101126828(a1);
}

void sub_1011181D4(void *a1)
{
  sub_101118150(a1);

  operator delete();
}

uint64_t sub_10111820C(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, void))(*(void *)a1 + 80))(a1, 0);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 80))(a1, ++byte_101B13288);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 80))(a1, 0);
  std::string __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  CSIPhoneNumber::getBaseNumber((uint64_t *)&__p, (CSIPhoneNumber *)(a1 + 8));
  int v4 = HIBYTE(v11);
  if (v11 < 0) {
    int v4 = v10;
  }
  (*(void (**)(uint64_t, void))(*(void *)a1 + 80))(a1, (((v4 + 1) >> 1) + 1));
  uint64_t TypeOfAddress = CSIPhoneNumber::getTypeOfAddress((CSIPhoneNumber *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, TypeOfAddress);
  if (v11 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 112))(a1, p_p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p);
  }
  char v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 80);

  return v7(a1, a2);
}

void sub_1011183EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101118408(uint64_t a1, const char *a2, uint64_t a3)
{
  sub_10111820C(a1, a3);
  if (a2[23] < 0)
  {
    unint64_t v5 = *((unsigned int *)a2 + 2);
    a2 = *(const char **)a2;
  }
  else
  {
    unint64_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  sub_10111F030(a2, v5, (uint64_t *)__p);
  if ((v9 & 0x80u) == 0) {
    char v6 = __p;
  }
  else {
    char v6 = (void **)__p[0];
  }
  if ((v9 & 0x80u) == 0) {
    std::string::size_type v7 = v9;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)__p[1];
  }
  std::string::append((std::string *)(a1 + 280), (const std::string::value_type *)v6, v7);
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10111849C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011184B8(uint64_t a1)
{
  uint64_t v2 = a1 + 280;
  if (*(char *)(a1 + 303) < 0)
  {
    *(void *)(a1 + 288) = 0;
    id v3 = *(unsigned char **)(a1 + 280);
  }
  else
  {
    *(unsigned char *)(a1 + 303) = 0;
    id v3 = (unsigned char *)(a1 + 280);
  }
  *id v3 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  unsigned int v12 = 0;
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 48))(v10, a1, &v12);
  if (*(char *)(a1 + 303) < 0)
  {
    *(void *)(a1 + 288) = 0;
    int v4 = *(unsigned char **)(a1 + 280);
  }
  else
  {
    *(unsigned char *)(a1 + 303) = 0;
    int v4 = (unsigned char *)v2;
  }
  *int v4 = 0;
  sub_10111820C(a1, v12);
  int v9 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v8 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, int *))(*(void *)a1 + 48))(__p, a1, &v9);
  sub_1002055B4((const void **)__p, v10, &v5);
  if (*(char *)(a1 + 303) < 0) {
    operator delete(*(void **)v2);
  }
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10[0]);
  }
}

void sub_101118620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v18 - 25) < 0) {
    operator delete(*(void **)(v18 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_101118658(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v6 = (std::string *)(a1 + 280);
  if (*(char *)(a1 + 303) < 0)
  {
    *(void *)(a1 + 288) = 0;
    std::string::size_type v7 = *(unsigned char **)(a1 + 280);
  }
  else
  {
    *(unsigned char *)(a1 + 303) = 0;
    std::string::size_type v7 = (unsigned char *)(a1 + 280);
  }
  *std::string::size_type v7 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 2);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 80))(a1, *a2);
  uint64_t v54 = 0;
  uint64_t v8 = operator new(1uLL);
  *uint64_t v8 = 0;
  std::string __p = v8;
  xpc_connection_t v55 = v8 + 1;
  uint64_t v9 = a2[31];
  uint64_t v10 = *((void *)a2 + 2);
  uint64_t v11 = operator new(2uLL);
  unsigned int v12 = v11;
  if ((v9 & 0x80u) == 0) {
    uint64_t v13 = v9;
  }
  else {
    uint64_t v13 = v10;
  }
  BOOL v14 = v13 != 0;
  if (a3) {
    char v15 = (4 * v14) | 3;
  }
  else {
    char v15 = 4 * v14;
  }
  v11[1] = v15;
  unsigned char *v11 = 0;
  BOOL v16 = v11 + 2;
  std::string __p = v11;
  xpc_connection_t v55 = v11 + 2;
  operator delete(v8);
  uint64_t v54 = (uint64_t)v16;
  if (a3)
  {
    uint64_t v17 = operator new(4uLL);
    v17[2] = a2[1];
    *(_WORD *)uint64_t v17 = *v12;
    BOOL v16 = v17 + 4;
    std::string __p = v17;
    xpc_connection_t v55 = v17 + 4;
    operator delete(v12);
    v17[3] = a2[2];
    uint64_t v54 = (uint64_t)(v17 + 4);
    unsigned int v12 = v17;
  }
  if ((char)a2[31] < 0)
  {
    uint64_t v18 = *((void *)a2 + 2);
    if (!v18) {
      goto LABEL_54;
    }
  }
  else
  {
    LOBYTE(v18) = a2[31];
    if (!(_BYTE)v18) {
      goto LABEL_54;
    }
  }
  unint64_t v19 = v16 - (unsigned char *)v12;
  uint64_t v20 = v16 - (unsigned char *)v12 + 1;
  if (v20 < 0) {
    sub_10006A748();
  }
  if (2 * v19 > v20) {
    uint64_t v20 = 2 * v19;
  }
  if (v19 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v21 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v21 = v20;
  }
  if (v21) {
    unint64_t v22 = operator new(v21);
  }
  else {
    unint64_t v22 = 0;
  }
  unint64_t v23 = &v22[v21];
  v22[v19] = v18;
  unint64_t v24 = &v22[v19 + 1];
  if (v16 == (unsigned char *)v12) {
    v22 += v19;
  }
  else {
    memcpy(v22, v12, v16 - (unsigned char *)v12);
  }
  std::string __p = v22;
  xpc_connection_t v55 = v23;
  operator delete(v12);
  uint64_t v25 = a2[31];
  uint64_t v54 = (uint64_t)v24;
  if ((v25 & 0x80u) == 0) {
    unint64_t v26 = (char *)(a2 + 8);
  }
  else {
    unint64_t v26 = (char *)*((void *)a2 + 1);
  }
  if ((v25 & 0x80u) != 0) {
    uint64_t v25 = *((void *)a2 + 2);
  }
  if (v25)
  {
    int v27 = &v26[v25];
    do
    {
      char v28 = *v26;
      if (v24 >= v55)
      {
        unint64_t v30 = (unint64_t)__p;
        uint64_t v31 = v24 - (unsigned char *)__p;
        uint64_t v32 = v24 - (unsigned char *)__p + 1;
        if (v32 < 0) {
          sub_10006A748();
        }
        unint64_t v33 = v55 - (unsigned char *)__p;
        if (2 * (v55 - (unsigned char *)__p) > (unint64_t)v32) {
          uint64_t v32 = 2 * v33;
        }
        if (v33 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v34 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v34 = v32;
        }
        if (v34) {
          BOOL v35 = operator new(v34);
        }
        else {
          BOOL v35 = 0;
        }
        uint64_t v36 = (char *)v35 + v34;
        *((unsigned char *)v35 + v31) = v28;
        uint64_t v29 = (uint64_t)v35 + v31 + 1;
        if (v24 == (unsigned char *)v30)
        {
          std::string __p = (char *)v35 + v31;
          xpc_connection_t v55 = v36;
        }
        else
        {
          uint64_t v37 = &v24[~v30];
          do
          {
            char v38 = *--v24;
            (v37--)[(void)v35] = v38;
          }
          while (v24 != (unsigned char *)v30);
          unint64_t v24 = __p;
          std::string __p = v35;
          xpc_connection_t v55 = v36;
          if (!v24) {
            goto LABEL_53;
          }
        }
        operator delete(v24);
      }
      else
      {
        *unint64_t v24 = v28;
        uint64_t v29 = (uint64_t)(v24 + 1);
      }
LABEL_53:
      uint64_t v54 = v29;
      ++v26;
      unint64_t v24 = (unsigned char *)v29;
    }
    while (v26 != v27);
  }
LABEL_54:
  unint64_t v50 = 0;
  std::string::size_type v51 = 0;
  uint64_t v52 = 0;
  ctu::hex();
  ctu::hex0((uint64_t *)&v47, (ctu *)0x41, v39);
  if ((v49 & 0x80u) == 0) {
    uint64_t v40 = (const std::string::value_type *)&v47;
  }
  else {
    uint64_t v40 = (const std::string::value_type *)v47;
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v41 = v49;
  }
  else {
    std::string::size_type v41 = v48;
  }
  std::string::append(v6, v40, v41);
  if ((char)v49 < 0) {
    operator delete(v47);
  }
  ctu::hex0((uint64_t *)&v47, (ctu *)(v54 - (_BYTE)__p), v42);
  if ((v49 & 0x80u) == 0) {
    int v43 = (const std::string::value_type *)&v47;
  }
  else {
    int v43 = (const std::string::value_type *)v47;
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v44 = v49;
  }
  else {
    std::string::size_type v44 = v48;
  }
  std::string::append(v6, v43, v44);
  if ((char)v49 < 0) {
    operator delete(v47);
  }
  if (v52 >= 0) {
    int v45 = (const std::string::value_type *)&v50;
  }
  else {
    int v45 = (const std::string::value_type *)v50;
  }
  if (v52 >= 0) {
    std::string::size_type v46 = HIBYTE(v52);
  }
  else {
    std::string::size_type v46 = v51;
  }
  std::string::append(v6, v45, v46);
  if (SHIBYTE(v52) < 0) {
    operator delete(v50);
  }
  if (__p)
  {
    uint64_t v54 = (uint64_t)__p;
    operator delete(__p);
  }
}

void sub_101118A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101118AD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a1 + 303) < 0)
  {
    *(void *)(a1 + 288) = 0;
    uint64_t v6 = *(unsigned char **)(a1 + 280);
  }
  else
  {
    uint64_t v6 = (unsigned char *)(a1 + 280);
    *(unsigned char *)(a1 + 303) = 0;
  }
  unsigned char *v6 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a3);
  std::string::size_type v7 = *(uint64_t (**)(uint64_t, void))(*(void *)a1 + 80);

  return v7(a1, 0);
}

uint64_t sub_101118C10(uint64_t a1)
{
  if (*(char *)(a1 + 303) < 0)
  {
    *(void *)(a1 + 288) = 0;
    uint64_t v2 = *(unsigned char **)(a1 + 280);
  }
  else
  {
    uint64_t v2 = (unsigned char *)(a1 + 280);
    *(unsigned char *)(a1 + 303) = 0;
  }
  *uint64_t v2 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 6);
  uint64_t v3 = ++byte_101B13288;
  int v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 80);

  return v4(a1, v3);
}

void sub_101118CC4(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v15[0] = 0;
  v15[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v15);
  int v14 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, int *))(*(void *)a1 + 48))(&v11, a1, &v14);
  if (v13 >= 0) {
    int v4 = (const char *)&v11;
  }
  else {
    int v4 = (const char *)v11;
  }
  if (v13 >= 0) {
    unint64_t v5 = HIBYTE(v13);
  }
  else {
    unint64_t v5 = v12;
  }
  ctu::TextConverter::setSource((ctu::TextConverter *)v15, v4, v5);
  ctu::TextConverter::pushConversion();
  std::string __p = 0;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  ctu::TextConverter::readChars((uint64_t *)&__p, (ctu::TextConverter *)v15, 0x7FFFFFFFuLL);
  if (v10 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v10 >= 0) {
    unint64_t v7 = HIBYTE(v10);
  }
  else {
    unint64_t v7 = v9;
  }
  sub_10075526C(a2, p_p, &p_p[v7], v7);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v11);
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v15);
}

void sub_101118DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)(v22 - 48));
  unint64_t v24 = *(void **)v21;
  if (*(void *)v21)
  {
    *(void *)(v21 + 8) = v24;
    operator delete(v24);
  }
  _Unwind_Resume(a1);
}

void sub_101118E48(SmsPduEncoder *a1)
{
  SmsPduEncoder::~SmsPduEncoder(a1);

  operator delete();
}

void sub_101118E80(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v23 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v23 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v23 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v23 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v21 = xpc_BOOL_create(*(unsigned char *)a1);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  unint64_t v19 = &v23;
  uint64_t v20 = "trusted";
  sub_100035E70((uint64_t)&v19, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (*(char *)(a1 + 31) >= 0) {
    unint64_t v7 = (const char *)(a1 + 8);
  }
  else {
    unint64_t v7 = *(const char **)(a1 + 8);
  }
  xpc_object_t v17 = xpc_string_create(v7);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  unint64_t v19 = &v23;
  uint64_t v20 = "name";
  sub_100035E70((uint64_t)&v19, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  if (*(char *)(a1 + 55) >= 0) {
    uint64_t v8 = (const char *)(a1 + 32);
  }
  else {
    uint64_t v8 = *(const char **)(a1 + 32);
  }
  xpc_object_t v15 = xpc_string_create(v8);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  unint64_t v19 = &v23;
  uint64_t v20 = "model";
  sub_100035E70((uint64_t)&v19, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (*(char *)(a1 + 79) >= 0) {
    unint64_t v9 = (const char *)(a1 + 56);
  }
  else {
    unint64_t v9 = *(const char **)(a1 + 56);
  }
  xpc_object_t v13 = xpc_string_create(v9);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  unint64_t v19 = &v23;
  uint64_t v20 = "serial_number";
  sub_100035E70((uint64_t)&v19, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v11 = xpc_double_create(*(double *)(a1 + 80));
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  unint64_t v19 = &v23;
  uint64_t v20 = "last_updated_date";
  sub_100035E70((uint64_t)&v19, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v23;
  *a2 = v23;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v23);
}

void sub_101119174(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    std::string __p = &object;
    xpc_object_t v21 = "trusted";
    sub_100048BAC((uint64_t)&__p, v18);
    *(unsigned char *)a1 = xpc::dyn_cast_or_default((xpc *)v18, 0, v8);
    xpc_release(v18[0]);
    p_xpc_object_t object = &object;
    xpc_object_t v15 = "name";
    sub_100048BAC((uint64_t)&p_object, &v16);
    std::string __p = 0;
    xpc_object_t v21 = 0;
    uint64_t v22 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v22) < 0) {
      operator delete(__p);
    }
    unint64_t v9 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)unint64_t v9 = *(_OWORD *)v18;
    *(void *)(a1 + 24) = v19;
    xpc_release(v16);
    p_xpc_object_t object = &object;
    xpc_object_t v15 = "model";
    sub_100048BAC((uint64_t)&p_object, &v16);
    std::string __p = 0;
    xpc_object_t v21 = 0;
    uint64_t v22 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v22) < 0) {
      operator delete(__p);
    }
    xpc_object_t v10 = (void **)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)xpc_object_t v10 = *(_OWORD *)v18;
    *(void *)(a1 + 48) = v19;
    xpc_release(v16);
    p_xpc_object_t object = &object;
    xpc_object_t v15 = "serial_number";
    sub_100048BAC((uint64_t)&p_object, &v16);
    std::string __p = 0;
    xpc_object_t v21 = 0;
    uint64_t v22 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v22) < 0) {
      operator delete(__p);
    }
    xpc_object_t v11 = (void **)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)xpc_object_t v11 = *(_OWORD *)v18;
    *(void *)(a1 + 72) = v19;
    xpc_release(v16);
    std::string __p = &object;
    xpc_object_t v21 = "last_updated_date";
    sub_100048BAC((uint64_t)&__p, v18);
    xpc::dyn_cast_or_default((xpc *)v18, v12, 0.0);
    *(void *)(a1 + 80) = v13;
    xpc_release(v18[0]);
  }
  else
  {
    *(unsigned char *)a1 = 0;
    xpc_object_t v5 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v5);
    }
    xpc_object_t v6 = (void **)(a1 + 32);
    *xpc_object_t v5 = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v6);
    }
    unint64_t v7 = (void **)(a1 + 56);
    unsigned char *v6 = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*v7);
    }
    *(_OWORD *)unint64_t v7 = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
  }
  xpc_release(object);
}

void sub_101119414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_1011194EC(uint64_t *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v31 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v31 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v31 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v31 = v6;
LABEL_9:
  xpc_release(v5);
  if (a1[1] != *a1)
  {
    xpc_object_t v7 = xpc_array_create(0, 0);
    if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v7);
        xpc_object_t v8 = v7;
      }
      else
      {
        xpc_object_t v8 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
    }
    xpc_release(v7);
    uint64_t v9 = *a1;
    uint64_t v10 = a1[1];
    while (v9 != v10)
    {
      if (*(char *)(v9 + 23) >= 0) {
        xpc_object_t v11 = (const char *)v9;
      }
      else {
        xpc_object_t v11 = *(const char **)v9;
      }
      xpc_object_t v12 = xpc_string_create(v11);
      if (!v12) {
        xpc_object_t v12 = xpc_null_create();
      }
      xpc_array_append_value(v8, v12);
      xpc_release(v12);
      v9 += 24;
    }
    xpc_object_t v29 = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v29 = xpc_null_create();
    }
    int v27 = &v31;
    char v28 = "imeis";
    sub_10017AC14((uint64_t)&v27, &v29, &v30);
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_release(v29);
    xpc_object_t v29 = 0;
    xpc_release(v8);
  }
  xpc_object_t v25 = xpc_BOOL_create(*((unsigned char *)a1 + 24));
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  int v27 = &v31;
  char v28 = "trusted";
  sub_100035E70((uint64_t)&v27, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (*((char *)a1 + 55) >= 0) {
    uint64_t v13 = (const char *)(a1 + 4);
  }
  else {
    uint64_t v13 = (const char *)a1[4];
  }
  xpc_object_t v23 = xpc_string_create(v13);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  int v27 = &v31;
  char v28 = "name";
  sub_100035E70((uint64_t)&v27, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (*((char *)a1 + 79) >= 0) {
    xpc_object_t v14 = (const char *)(a1 + 7);
  }
  else {
    xpc_object_t v14 = (const char *)a1[7];
  }
  xpc_object_t v21 = xpc_string_create(v14);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  int v27 = &v31;
  char v28 = "model";
  sub_100035E70((uint64_t)&v27, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (*((char *)a1 + 103) >= 0) {
    xpc_object_t v15 = (const char *)(a1 + 10);
  }
  else {
    xpc_object_t v15 = (const char *)a1[10];
  }
  xpc_object_t v19 = xpc_string_create(v15);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  int v27 = &v31;
  char v28 = "serial_number";
  sub_100035E70((uint64_t)&v27, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_object_t v17 = xpc_double_create(*((double *)a1 + 13));
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  int v27 = &v31;
  char v28 = "last_updated_date";
  sub_100035E70((uint64_t)&v27, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v16 = v31;
  *a2 = v31;
  if (v16) {
    xpc_retain(v16);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v31);
}

void sub_10111992C(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  xpc_release(*(xpc_object_t *)(v3 - 56));
  _Unwind_Resume(a1);
}

void sub_101119960(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v42 = *a2;
  if (v42 && xpc_get_type(v42) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v42);
    xpc_object_t v3 = v42;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v42 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100047FB8((uint64_t *)a1);
    xpc_object_t object = 0;
    xpc_object_t __p = &v42;
    BOOL v35 = "imeis";
    sub_10005107C((uint64_t)&__p, &object);
    xpc_object_t __p = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t __p = xpc_null_create();
    }
    sub_100048BF4(&v31, &__p, 0);
    xpc_release(__p);
    xpc_object_t __p = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t __p = xpc_null_create();
    }
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(object);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v30, &__p, count);
    xpc_release(__p);
    for (uint64_t i = v32; i != v30[1] || v31 != v30[0]; uint64_t i = ++v32)
    {
      v29[0] = &v31;
      v29[1] = i;
      *(void *)((char *)v44 + 7) = 0;
      v44[0] = 0;
      sub_1000492E0((uint64_t)v29, &v28);
      xpc_object_t __p = 0;
      BOOL v35 = 0;
      uint64_t v36 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v36) < 0) {
        operator delete(__p);
      }
      uint64_t v9 = *(void *)v43;
      v44[0] = *(void *)&v43[8];
      *(void *)((char *)v44 + 7) = *(void *)&v43[15];
      char v10 = v43[23];
      xpc_release(v28);
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)(a1 + 16);
      if (v11 >= v12)
      {
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *(void *)a1) >> 3);
        unint64_t v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - *(void *)a1) >> 3);
        if (2 * v17 > v16) {
          unint64_t v16 = 2 * v17;
        }
        if (v17 >= 0x555555555555555) {
          unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v18 = v16;
        }
        *(void *)&long long v38 = a1 + 16;
        if (v18) {
          xpc_object_t v19 = (char *)sub_10004812C(a1 + 16, v18);
        }
        else {
          xpc_object_t v19 = 0;
        }
        xpc_object_t v20 = &v19[24 * v15];
        xpc_object_t __p = v19;
        BOOL v35 = v20;
        uint64_t v37 = &v19[24 * v18];
        uint64_t v21 = v44[0];
        *(void *)xpc_object_t v20 = v9;
        *((void *)v20 + 1) = v21;
        *(void *)(v20 + 15) = *(void *)((char *)v44 + 7);
        v20[23] = v10;
        uint64_t v36 = v20 + 24;
        sub_100048204((uint64_t *)a1, &__p);
        unint64_t v14 = *(void *)(a1 + 8);
        sub_100048174((uint64_t)&__p);
      }
      else
      {
        uint64_t v13 = v44[0];
        *(void *)unint64_t v11 = v9;
        *(void *)(v11 + 8) = v13;
        *(void *)(v11 + 15) = *(void *)((char *)v44 + 7);
        *(unsigned char *)(v11 + 23) = v10;
        unint64_t v14 = v11 + 24;
        *(void *)(a1 + 8) = v11 + 24;
      }
      *(void *)(a1 + 8) = v14;
    }
    xpc_release(v31);
    xpc_release(v31);
    xpc_object_t __p = &v42;
    BOOL v35 = "trusted";
    sub_100048BAC((uint64_t)&__p, v43);
    *(unsigned char *)(a1 + 24) = xpc::dyn_cast_or_default((xpc *)v43, 0, v22);
    xpc_release(*(xpc_object_t *)v43);
    xpc_object_t v31 = &v42;
    uint64_t v32 = "name";
    sub_100048BAC((uint64_t)&v31, v30);
    xpc_object_t __p = 0;
    BOOL v35 = 0;
    uint64_t v36 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v36) < 0) {
      operator delete(__p);
    }
    xpc_object_t v23 = (void **)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v23);
    }
    *(_OWORD *)xpc_object_t v23 = *(_OWORD *)v43;
    *(void *)(a1 + 48) = *(void *)&v43[16];
    xpc_release(v30[0]);
    xpc_object_t v31 = &v42;
    uint64_t v32 = "model";
    sub_100048BAC((uint64_t)&v31, v30);
    xpc_object_t __p = 0;
    BOOL v35 = 0;
    uint64_t v36 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v36) < 0) {
      operator delete(__p);
    }
    xpc_object_t v24 = (void **)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*v24);
    }
    *(_OWORD *)xpc_object_t v24 = *(_OWORD *)v43;
    *(void *)(a1 + 72) = *(void *)&v43[16];
    xpc_release(v30[0]);
    xpc_object_t v31 = &v42;
    uint64_t v32 = "serial_number";
    sub_100048BAC((uint64_t)&v31, v30);
    xpc_object_t __p = 0;
    BOOL v35 = 0;
    uint64_t v36 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v36) < 0) {
      operator delete(__p);
    }
    xpc_object_t v25 = (void **)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*v25);
    }
    *(_OWORD *)xpc_object_t v25 = *(_OWORD *)v43;
    *(void *)(a1 + 96) = *(void *)&v43[16];
    xpc_release(v30[0]);
    xpc_object_t __p = &v42;
    BOOL v35 = "last_updated_date";
    sub_100048BAC((uint64_t)&__p, v43);
    xpc::dyn_cast_or_default((xpc *)v43, v26, 0.0);
    *(void *)(a1 + 104) = v27;
    xpc_release(*(xpc_object_t *)v43);
    xpc_release(object);
  }
  else
  {
    LOBYTE(v37) = 0;
    long long v38 = 0u;
    memset(v39, 0, sizeof(v39));
    long long v40 = 0u;
    long long v41 = 0u;
    sub_10005CBB4((uint64_t *)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    BOOL v35 = 0;
    uint64_t v36 = 0;
    xpc_object_t __p = 0;
    *(unsigned char *)(a1 + 24) = 0;
    xpc_object_t v4 = (void **)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*v4);
    }
    *xpc_object_t v4 = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    BYTE7(v39[0]) = 0;
    LOBYTE(v38) = 0;
    xpc_object_t v5 = (void **)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = *(_OWORD *)((char *)v39 + 8);
    *(void *)(a1 + 72) = *((void *)&v39[1] + 1);
    HIBYTE(v39[1]) = 0;
    BYTE8(v39[0]) = 0;
    xpc_object_t v6 = (void **)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)xpc_object_t v6 = v40;
    *(void *)(a1 + 96) = v41;
    BYTE7(v41) = 0;
    LOBYTE(v40) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)int v43 = &__p;
    sub_100047F64((void ***)v43);
  }
  xpc_release(v42);
}

void sub_101119F14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

BOOL sub_10111A0B8(uint64_t a1)
{
  if (*(void *)(a1 + 8) == *(void *)a1) {
    return 0;
  }
  if (*(char *)(a1 + 79) < 0)
  {
    CFNumberRef v1 = *(char **)(a1 + 56);
    uint64_t v2 = *(void *)(a1 + 64);
  }
  else
  {
    CFNumberRef v1 = (char *)(a1 + 56);
    uint64_t v2 = *(unsigned __int8 *)(a1 + 79);
  }
  xpc_object_t v4 = &v1[v2];
  if (v2 >= 4)
  {
    xpc_object_t v5 = v1;
    do
    {
      xpc_object_t v6 = (char *)memchr(v5, 105, v2 - 3);
      if (!v6) {
        break;
      }
      if (*(_DWORD *)v6 == 1684099177) {
        return v6 != v4 && v6 - v1 != -1;
      }
      xpc_object_t v5 = v6 + 1;
      uint64_t v2 = v4 - (unsigned char *)v5;
    }
    while (v4 - (unsigned char *)v5 > 3);
  }
  xpc_object_t v6 = v4;
  return v6 != v4 && v6 - v1 != -1;
}

BOOL sub_10111A160(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0)
  {
    CFNumberRef v1 = *(char **)(a1 + 56);
    uint64_t v2 = *(void *)(a1 + 64);
  }
  else
  {
    CFNumberRef v1 = (char *)(a1 + 56);
    uint64_t v2 = *(unsigned __int8 *)(a1 + 79);
  }
  xpc_object_t v3 = &v1[v2];
  if (v2 >= 13)
  {
    xpc_object_t v4 = v1;
    do
    {
      xpc_object_t v5 = (char *)memchr(v4, 82, v2 - 12);
      if (!v5) {
        break;
      }
      if (*(void *)v5 == 0x447974696C616552 && *(void *)(v5 + 5) == 0x6563697665447974) {
        return v5 != v3 && v5 - v1 != -1;
      }
      xpc_object_t v4 = v5 + 1;
      uint64_t v2 = v3 - (unsigned char *)v4;
    }
    while (v3 - (unsigned char *)v4 > 12);
  }
  xpc_object_t v5 = v3;
  return v5 != v3 && v5 - v1 != -1;
}

void ImsSmsPduDecoder::ImsSmsPduDecoder(ImsSmsPduDecoder *this)
{
  SmsPduDecoder::SmsPduDecoder(this);
  *(void *)uint64_t v2 = &off_101A90DC8;
  *(unsigned char *)(v2 + 716) = 0;
  *(_OWORD *)(v2 + 664) = 0u;
  *(_OWORD *)(v2 + 680) = 0u;
  *(_OWORD *)(v2 + 696) = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(v2 + 720));
  *((unsigned char *)this + 856) = 0;
}

void sub_10111A280(_Unwind_Exception *a1)
{
  xpc_object_t v4 = (void *)*((void *)v1 + 86);
  if (v4)
  {
    *((void *)v1 + 87) = v4;
    operator delete(v4);
  }
  xpc_object_t v5 = *v2;
  if (*v2)
  {
    *((void *)v1 + 84) = v5;
    operator delete(v5);
  }
  SmsPduDecoder::~SmsPduDecoder(v1);
  _Unwind_Resume(a1);
}

void sub_10111A2B4(void **this)
{
  *this = &off_101A90DC8;
  if (*((char *)this + 831) < 0) {
    operator delete(this[101]);
  }
  if (*((char *)this + 807) < 0) {
    operator delete(this[98]);
  }
  if (*((char *)this + 775) < 0) {
    operator delete(this[94]);
  }
  if (*((char *)this + 751) < 0) {
    operator delete(this[91]);
  }
  uint64_t v2 = this[86];
  if (v2)
  {
    this[87] = v2;
    operator delete(v2);
  }
  xpc_object_t v3 = this[83];
  if (v3)
  {
    this[84] = v3;
    operator delete(v3);
  }

  SmsPduDecoder::~SmsPduDecoder((SmsPduDecoder *)this);
}

void sub_10111A368(void **a1)
{
  sub_10111A2B4(a1);

  operator delete();
}

BOOL ImsSmsPduDecoder::decodeRpMessage(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(const char **)a2;
  xpc_object_t v3 = *(char **)(a2 + 8);
  if (*(char **)a2 != v3)
  {
    xpc_object_t v6 = (const void **)(a1 + 664);
    if (a1 + 664 != a2)
    {
      sub_10006E4A8((void *)(a1 + 664), *(char **)a2, v3, v3 - v4);
      xpc_object_t v4 = *(const char **)a2;
      xpc_object_t v3 = *(char **)(a2 + 8);
    }
    uint64_t v36 = 0;
    unint64_t v37 = 0;
    uint64_t v38 = 0;
    sub_10111F030(v4, v3 - v4, (uint64_t *)&v36);
    if (v38 >= 0) {
      xpc_object_t v7 = (const char *)&v36;
    }
    else {
      xpc_object_t v7 = (const char *)v36;
    }
    if (v38 >= 0) {
      unint64_t v8 = HIBYTE(v38);
    }
    else {
      unint64_t v8 = v37;
    }
    ctu::TextConverter::setSource((ctu::TextConverter *)(a1 + 16), v7, v8);
    unint64_t v35 = 0;
    char v9 = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, &v35);
    if ((v9 & 1) == 0)
    {
      char v10 = *(NSObject **)(a1 + 8);
      BOOL v11 = 0;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Incoming direction is not MT", buf, 2u);
        BOOL v11 = 0;
      }
      goto LABEL_52;
    }
    uint64_t v13 = v9 & 6;
    *(_DWORD *)(a1 + 712) = v9 & 6;
    if ((v9 & 6) == 4)
    {
      *(void *)long long buf = 0;
      *(unsigned char *)(a1 + 716) = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, (unint64_t *)buf);
      int v16 = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, (unint64_t *)buf);
      if ((v16 - 3) > 0xFFFFFFFD)
      {
        *(unsigned char *)(a1 + 856) = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, (unint64_t *)buf);
      }
      else
      {
        *(unsigned char *)(a1 + 42) = 1;
        unint64_t v17 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v40[0]) = 67109120;
          HIDWORD(v40[0]) = v16;
          unint64_t v15 = "RP-ERROR decode failed - Invalid Cause Element Length: Expected: [1-2], Actual: %d";
          unint64_t v18 = (uint8_t *)v40;
          xpc_object_t v19 = v17;
          uint32_t v20 = 8;
LABEL_47:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v15, v18, v20);
        }
      }
    }
    else if (v13 == 2)
    {
      *(void *)long long buf = 0;
      *(unsigned char *)(a1 + 716) = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, (unint64_t *)buf);
    }
    else
    {
      if ((v9 & 6) != 0)
      {
        uint64_t v21 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          if ((v13 - 2) > 4) {
            BOOL v22 = "RP-DATA";
          }
          else {
            BOOL v22 = off_101A90E20[v13 - 2];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Invalid message type: %s", buf, 0xCu);
        }
        *(unsigned char *)(a1 + 42) = 1;
        goto LABEL_51;
      }
      unint64_t v39 = 0;
      *(unsigned char *)(a1 + 716) = SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, &v39);
      SmsPduDecoder::decodeSmscInfo((SmsPduDecoder *)a1);
      if (*(unsigned char *)(a1 + 42))
      {
        unint64_t v14 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          unint64_t v15 = "SMSC info could not be parsed";
LABEL_46:
          unint64_t v18 = buf;
          xpc_object_t v19 = v14;
          uint32_t v20 = 2;
          goto LABEL_47;
        }
      }
      else
      {
        SmsPduDecoder::getOriginatingServiceCenter((uint64_t *)buf, (SmsPduDecoder *)a1);
        *(void *)(a1 + 720) = *(void *)buf;
        xpc_object_t v23 = (void **)(a1 + 728);
        if (*(char *)(a1 + 751) < 0) {
          operator delete(*v23);
        }
        *(_OWORD *)xpc_object_t v23 = *(_OWORD *)&buf[8];
        *(void *)(a1 + 744) = v43;
        HIBYTE(v43) = 0;
        uint8_t buf[8] = 0;
        xpc_object_t v24 = (void **)(a1 + 752);
        if (*(char *)(a1 + 775) < 0) {
          operator delete(*v24);
        }
        *(_OWORD *)xpc_object_t v24 = v44;
        *(void *)(a1 + 768) = v45;
        HIBYTE(v45) = 0;
        LOBYTE(v44) = 0;
        *(_DWORD *)(a1 + 776) = v46;
        *(unsigned char *)(a1 + 780) = v47;
        xpc_object_t v25 = (void **)(a1 + 784);
        if (*(char *)(a1 + 807) < 0) {
          operator delete(*v25);
        }
        char v26 = 0;
        *(_OWORD *)xpc_object_t v25 = __p;
        *(void *)(a1 + 800) = v49;
        HIBYTE(v49) = 0;
        LOBYTE(__p) = 0;
        uint64_t v27 = (void **)(a1 + 808);
        if (*(char *)(a1 + 831) < 0)
        {
          operator delete(*v27);
          char v26 = HIBYTE(v49);
        }
        *(_OWORD *)uint64_t v27 = v50;
        *(void *)(a1 + 824) = v51;
        HIBYTE(v51) = 0;
        LOBYTE(v50) = 0;
        *(_OWORD *)(a1 + 832) = v52;
        *(unsigned char *)(a1 + 848) = v53;
        if (v26 < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v45) < 0) {
          operator delete((void *)v44);
        }
        if (SHIBYTE(v43) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (!SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, &v39))
        {
          SmsPduDecoder::decodeOctet((SmsPduDecoder *)a1, &v39);
          SourceCFIndex Count = ctu::TextConverter::getSourceCount((ctu::TextConverter *)(a1 + 16));
          if (SourceCount >= 0) {
            int v30 = SourceCount;
          }
          else {
            int v30 = SourceCount + 1;
          }
          xpc_object_t v31 = *v6;
          int64_t v32 = (uint64_t)v30 >> 1;
          memset(buf, 0, sizeof(buf));
          sub_10036CCEC(buf, v31, (uint64_t)v31 + (v30 >> 1), v32);
          sub_100058DB0(v40, "RP-DATA");
          ImsSmsPduDecoder::logPdu(a1, (uint64_t)buf, (uint64_t *)v40);
          if (v41 < 0) {
            operator delete(v40[0]);
          }
          uint64_t v33 = *(void *)(a1 + 664);
          size_t v34 = *(char **)(a1 + 672);
          if ((uint64_t)&v34[-v33] > v32)
          {
            sub_100EB0D5C((void *)(a1 + 688), (char *)(v33 + v32), v34, (unint64_t)&v34[-v33 - v32]);
            sub_100058DB0(v40, "TPDU");
            ImsSmsPduDecoder::logPdu(a1, a1 + 688, (uint64_t *)v40);
            if (v41 < 0) {
              operator delete(v40[0]);
            }
          }
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          goto LABEL_51;
        }
        *(unsigned char *)(a1 + 42) = 1;
        unint64_t v14 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          unint64_t v15 = "RP-DATA decode failed - Non-Zero RP-Terminating-Address length";
          goto LABEL_46;
        }
      }
    }
LABEL_51:
    BOOL v11 = *(unsigned char *)(a1 + 42) == 0;
LABEL_52:
    if (SHIBYTE(v38) < 0) {
      operator delete(v36);
    }
    return v11;
  }
  unint64_t v12 = *(NSObject **)(a1 + 8);
  BOOL v11 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Incoming PDU is empty", buf, 2u);
    return 0;
  }
  return v11;
}

void sub_10111A930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

void ImsSmsPduDecoder::logPdu(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v11[0] = 0;
  v11[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v11);
  ctu::TextConverter::pushConversion();
  ctu::TextConverter::setSource((ctu::TextConverter *)v11, *(const char **)a2, *(void *)(a2 + 8) - *(void *)a2);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  ctu::TextConverter::readChars((uint64_t *)__p, (ctu::TextConverter *)v11, 0x7FFFFFFFuLL);
  xpc_object_t v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a3 + 23) >= 0) {
      xpc_object_t v7 = a3;
    }
    else {
      xpc_object_t v7 = (uint64_t *)*a3;
    }
    unint64_t v8 = __p;
    if (v10 < 0) {
      unint64_t v8 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315395;
    uint64_t v13 = v7;
    __int16 v14 = 2085;
    unint64_t v15 = v8;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "3GPP MT SMS %s (hex): %{sensitive}s", buf, 0x16u);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v11);
}

void sub_10111AAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  _Unwind_Resume(a1);
}

void *sub_10111AAF8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "3GPP");
}

uint64_t sub_10111AB08()
{
  return 0;
}

uint64_t sub_10111AB10()
{
  return 1;
}

uint64_t sub_10111AB18()
{
  return 1;
}

BOOL sub_10111AB20(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 272) && *(unsigned __int8 *)(a1 + 26) == (*(unsigned char *)(v2 + 104) + 1);
}

BOOL sub_10111AB50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 272) && *(unsigned __int8 *)(a1 + 10) == (*(unsigned char *)(v2 + 104) + 1);
}

BOOL sub_10111AB80(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  if (!v2) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)(v2 + 272);
  uint64_t v4 = *(void *)(v2 + 104);
  if (v3)
  {
    int v5 = *(unsigned __int8 *)(a1 + 26);
    if (v5 == (v4 + 1)) {
      return 0;
    }
  }
  else
  {
    int v5 = *(unsigned __int8 *)(a1 + 26);
  }
  return v5 != v4;
}

BOOL sub_10111ABBC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  if (!v2) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)(v2 + 272);
  uint64_t v4 = *(void *)(v2 + 104);
  if (v3)
  {
    int v5 = *(unsigned __int8 *)(a1 + 10);
    if (v5 == (v4 + 1)) {
      return 0;
    }
  }
  else
  {
    int v5 = *(unsigned __int8 *)(a1 + 10);
  }
  return v5 != v4;
}

uint64_t sub_10111ABF8()
{
  return 0;
}

uint64_t sub_10111AC00()
{
  return 0;
}

uint64_t sub_10111AC08(uint64_t a1, os_log_t *a2)
{
  int v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    int v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    xpc_object_t v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10111ACBC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10111ACC4(uint64_t a1, os_log_t *a2)
{
  return sub_10111AC08(a1 - 16, a2);
}

BOOL sub_10111ACCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

BOOL sub_10111AD04(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

uint64_t sub_10111AD3C()
{
  return 1;
}

uint64_t sub_10111AD44()
{
  return 1;
}

void sub_10111AD4C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (!v8)
  {
    BOOL v65 = *(NSObject **)a2;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      uint64_t v68 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v68;
      long long v67 = "[%s] Roadside environment doesn't exist";
      goto LABEL_99;
    }
LABEL_97:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    BOOL v65 = *(NSObject **)a2;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      v66 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v66;
      long long v67 = "[%s] Roadside environment is not ready";
LABEL_99:
      _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, v67, buf, 0xCu);
      goto LABEL_97;
    }
    goto LABEL_97;
  }
  memset(__p, 0, 24);
  unsigned int v9 = sub_10112625C(v8);
  unint64_t v10 = sub_101125A48(*(void *)(a2 + 40));
  unsigned int v11 = v10;
  int v12 = BYTE4(v10);
  uint64_t v13 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v14 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v15 = *(unsigned __int8 *)(a1 + 26);
    if (v9 > 4) {
      int v16 = "???";
    }
    else {
      int v16 = off_101A91B68[(char)v9];
    }
    unint64_t v17 = "yes";
    int v18 = *(unsigned __int8 *)(a1 + 56);
    if (*(unsigned char *)(a1 + 88)) {
      xpc_object_t v19 = "yes";
    }
    else {
      xpc_object_t v19 = "no";
    }
    *(_DWORD *)long long buf = 136316674;
    if (v12) {
      unsigned int v20 = v11;
    }
    else {
      unsigned int v20 = 0;
    }
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 1024;
    if (!v18) {
      unint64_t v17 = "no";
    }
    *(_DWORD *)&buf[14] = v15;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "kAny";
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = v16;
    __int16 v74 = 2080;
    int v75 = v19;
    __int16 v76 = 1024;
    unsigned int v77 = v20;
    __int16 v78 = 2080;
    int v79 = v17;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, lineID: %s, battery: %s, has questionnaire answer: %s, preferred codec id: %u, Has phone number: %s", buf, 0x40u);
  }
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  if (sub_1002B45F4(*(void *)(a2 + 40)))
  {
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
    sub_10024081C((unint64_t *)buf, 5, 6uLL);
    os_log_t v21 = *(os_log_t *)a2;
    if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    BOOL v22 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    unint64_t v23 = *(char *)(a1 + 24);
    if (v23 > 4) {
      xpc_object_t v24 = "???";
    }
    else {
      xpc_object_t v24 = off_101A91B40[v23];
    }
    *(_DWORD *)v71 = 136315650;
    *(void *)&v71[4] = v22;
    *(_WORD *)&v71[12] = 2080;
    *(void *)&v71[14] = v24;
    *(_WORD *)&v71[22] = 2080;
    unint64_t v72 = "kFakeRoadsideStart";
    xpc_object_t v28 = "#I [%s] Mock mode is enabled. Serialized header: Version: %s, MessageType: %s";
    xpc_object_t v29 = v21;
    uint32_t v30 = 32;
  }
  else
  {
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
    os_log_t v25 = *(os_log_t *)a2;
    if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    unint64_t v26 = *(char *)(a1 + 24);
    if (v26 > 4) {
      uint64_t v27 = "???";
    }
    else {
      uint64_t v27 = off_101A91B40[v26];
    }
    xpc_object_t v31 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)v71 = 136315394;
    *(void *)&v71[4] = v27;
    *(_WORD *)&v71[12] = 2080;
    *(void *)&v71[14] = v31;
    xpc_object_t v28 = "#I Serialized header: Version: %s, MessageType: %s";
    xpc_object_t v29 = v25;
    uint32_t v30 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, v71, v30);
LABEL_33:
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 26), 8uLL);
  uint64_t v32 = *(void *)(a2 + 40);
  uint64_t v33 = *(double **)(v32 + 88);
  size_t v34 = *(std::__shared_weak_count **)(v32 + 96);
  if (v34) {
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10104992C(v33, a2, (unint64_t *)buf);
  sub_10024081C((unint64_t *)buf, v9, 2uLL);
  sub_10024081C((unint64_t *)buf, 0, 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 56), 1uLL);
  if (!*(unsigned char *)(a1 + 56))
  {
    sub_10024081C((unint64_t *)buf, 3, 2uLL);
    sub_10024081C((unint64_t *)buf, 0, 1uLL);
LABEL_39:
    if (*(void *)&buf[24]) {
      __TUAssertTrigger();
    }
    sub_10024081C((unint64_t *)buf, 0, 4uLL);
    if (v12)
    {
      unint64_t v38 = v11;
      LODWORD(v39) = v11 & 7;
      if (v11 >= 8uLL)
      {
        do
        {
          sub_10024081C((unint64_t *)buf, v39 | 8, 4uLL);
          uint64_t v39 = (v38 >> 3) & 7;
          BOOL v40 = v38 > 0x3F;
          v38 >>= 3;
        }
        while (v40);
      }
    }
    else
    {
      LODWORD(v39) = 0;
    }
    sub_10024081C((unint64_t *)buf, v39, 4uLL);
    *(void *)&uint8_t buf[24] = 0;
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 30), 1uLL);
    unsigned int v41 = *(unsigned __int16 *)(a1 + 28);
    sub_10024081C((unint64_t *)buf, v41 >> 8, 7uLL);
    sub_10024081C((unint64_t *)buf, v41, 8uLL);
    sub_101117F28(*(void *)(a2 + 40), *(unsigned __int16 *)(a1 + 28));
    if (*(void *)&buf[24]) {
      __TUAssertTrigger();
    }
    if (*(unsigned char *)(a1 + 88))
    {
      xpc_object_t v42 = *(unsigned char **)(a1 + 64);
      uint64_t v43 = *(unsigned char **)(a1 + 72);
      *(void *)v71 = buf;
      while (v42 != v43)
        sub_100240714((unint64_t **)v71, v42++);
    }
    long long v44 = *(_OWORD *)__p;
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    *(_OWORD *)long long buf = v44;
    uint64_t v45 = __p[2];
    __p[2] = *(void **)&buf[16];
    *(void *)&uint8_t buf[16] = v45;
    if (v34)
    {
      sub_10004D2C8(v34);
      int v46 = *(void **)buf;
      if (!*(void *)buf) {
        goto LABEL_55;
      }
    }
    else
    {
      int v46 = (void *)v44;
      if (!(void)v44)
      {
LABEL_55:
        uint64_t v47 = *(void *)(a2 + 40);
        uint64_t v49 = *(void *)(v47 + 168);
        std::string::size_type v48 = *(std::__shared_weak_count **)(v47 + 176);
        if (v48) {
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long v50 = (char *)__p[0];
        uint64_t v51 = *(unsigned __int8 *)__p[0];
        uint64_t v52 = *((unsigned __int8 *)__p[0] + 1);
        char v53 = operator new(8uLL);
        void *v53 = v51 | (v52 << 8);
        *(void *)&v71[8] = v53 + 1;
        *(void *)&v71[16] = v53 + 1;
        *(void *)v71 = v53;
        uint64_t v54 = (char *)((char *)__p[1] - (char *)v50);
        if ((void *)((char *)__p[1] - (char *)v50) <= (void *)2)
        {
          __TUAssertTrigger();
          long long v50 = (char *)__p[0];
          uint64_t v54 = (char *)((char *)__p[1] - (char *)__p[0]);
        }
        memset(buf, 0, 32);
        sub_100BCAA0C((os_log_t *)a2, v49, (uint64_t)v71, v50 + 2, (size_t)(v54 - 2), buf);
        int v55 = buf[24];
        if (buf[24])
        {
          uint64_t v56 = (char *)__p[0];
          unint64_t v57 = (char *)__p[1] - (char *)__p[0];
          if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 2)
          {
            __TUAssertTrigger();
            uint64_t v56 = (char *)__p[0];
            unint64_t v57 = (char *)__p[1] - (char *)__p[0];
          }
          if (v57 > 1)
          {
            if (v57 != 2) {
              __p[1] = v56 + 2;
            }
          }
          else
          {
            sub_10011FDF0((unint64_t *)__p, 2 - v57);
          }
          if (!buf[24]) {
            sub_10016C840();
          }
          xpc_object_t v60 = *(unsigned char **)buf;
          uint64_t v61 = *(unsigned char **)&buf[8];
          *(void *)unint64_t v70 = __p;
          while (v60 != v61)
            sub_100240714((unint64_t **)v70, v60++);
        }
        else
        {
          uint64_t v58 = *(NSObject **)a2;
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            BOOL v63 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)unint64_t v70 = 136315138;
            *(void *)&v70[4] = v63;
            _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v70, 0xCu);
          }
          *(unsigned char *)a3 = 0;
          *(unsigned char *)(a3 + 24) = 0;
        }
        if (buf[24] && *(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        if (*(void *)v71) {
          operator delete(*(void **)v71);
        }
        if (v48) {
          sub_10004D2C8(v48);
        }
        unint64_t v59 = __p[0];
        if (v55)
        {
          *(void **)a3 = __p[0];
          *(_OWORD *)(a3 + 8) = *(_OWORD *)&__p[1];
          *(unsigned char *)(a3 + 24) = 1;
          return;
        }
        goto LABEL_91;
      }
    }
    *(void *)&uint8_t buf[8] = v46;
    operator delete(v46);
    goto LABEL_55;
  }
  unint64_t v35 = sub_10132CC20((const std::string *)(a1 + 32));
  if (v36)
  {
    unint64_t v37 = v35;
    sub_10024081C((unint64_t *)buf, BYTE6(v35), 3uLL);
    sub_10024081C((unint64_t *)buf, BYTE5(v37), 8uLL);
    sub_10024081C((unint64_t *)buf, BYTE4(v37), 8uLL);
    sub_10024081C((unint64_t *)buf, BYTE3(v37), 8uLL);
    sub_10024081C((unint64_t *)buf, BYTE2(v37), 8uLL);
    sub_10024081C((unint64_t *)buf, BYTE1(v37), 8uLL);
    sub_10024081C((unint64_t *)buf, v37, 8uLL);
    goto LABEL_39;
  }
  xpc_object_t v62 = *(NSObject **)a2;
  if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
  {
    __int16 v64 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)v71 = 136315138;
    *(void *)&v71[4] = v64;
    _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "[%s] Failed to encode phone number", v71, 0xCu);
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 24) = 0;
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  unint64_t v59 = __p[0];
LABEL_91:
  if (v59)
  {
    __p[1] = v59;
    operator delete(v59);
  }
}

void sub_10111B60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22)
{
  operator delete(v23);
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10111B6C0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_10111B6C8()
{
  return 0;
}

uint64_t sub_10111B6D0()
{
  return 0;
}

void sub_10111B6D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    sub_101125470(v3);
  }
  else
  {
    uint64_t v4 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      int v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v6 = 136315138;
      xpc_object_t v7 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Roadside environment doesn't exist", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_10111B7C0(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10111B7D0()
{
  return 1;
}

uint64_t sub_10111B7D8()
{
  return 1;
}

uint64_t sub_10111B7E0()
{
  return 0;
}

uint64_t sub_10111B7E8()
{
  return 0;
}

BOOL sub_10111B7F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned __int8 *)(a1 + 26) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_10111B814(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned __int8 *)(a1 + 10) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_10111B838(void *a1, uint64_t a2)
{
  if (!*(void *)(a2 + 40)) {
    return 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 48);
  v6[0] = *(void *)(a2 + 40);
  v6[1] = (uint64_t)v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (sub_1004D0838(a2, v6) == 3 && a1[4] != a1[5])
  {
    BOOL v4 = a1[8] == 0;
    if (!v3) {
      return v4;
    }
    goto LABEL_9;
  }
  BOOL v4 = 0;
  if (v3) {
LABEL_9:
  }
    sub_10004D2C8(v3);
  return v4;
}

void sub_10111B8D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10111B8EC(uint64_t a1, uint64_t a2)
{
  return sub_10111B838((void *)(a1 - 16), a2);
}

void sub_10111B8F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 32;
  if (*(void *)(a1 + 32) == *(void *)(a1 + 40)) {
    __TUAssertTrigger();
  }
  xpc_object_t v7 = *(unsigned char **)(a1 + 64);
  if (v7)
  {
    int v16 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      int v18 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      xpc_object_t v19 = "complete";
      if (!*v7) {
        xpc_object_t v19 = "in progress";
      }
      *(_DWORD *)long long buf = 136315394;
      unint64_t v26 = v18;
      __int16 v27 = 2080;
      xpc_object_t v28 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[%s] Compression attempt is already %s", buf, 0x16u);
    }
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (!v8)
  {
    unint64_t v17 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
    {
      unsigned int v20 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      unint64_t v26 = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "[%s] Roadside environment doesn't exist", buf, 0xCu);
    }
LABEL_14:
    __TUAssertTrigger();
    return;
  }
  unint64_t v9 = sub_101125A48(v8);
  if ((v9 & 0xFF00000000) != 0)
  {
    unint64_t v10 = v9;
    unsigned int v11 = (std::__shared_weak_count *)operator new(0x20uLL);
    v11->__shared_owners_ = 0;
    v11->__shared_weak_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
    LOBYTE(v11[1].__vftable) = 0;
    int v12 = v11 + 1;
    uint64_t v13 = *(std::__shared_weak_count **)(a1 + 72);
    *(void *)(a1 + 64) = v11 + 1;
    *(void *)(a1 + 72) = v11;
    if (!v13
      || (sub_10004D2C8(v13),
          int v12 = *(std::__shared_weak_count **)(a1 + 64),
          (unsigned int v11 = *(std::__shared_weak_count **)(a1 + 72)) != 0))
    {
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(void *)(a2 + 24);
    *(void *)&long long v21 = a1;
    *((void *)&v21 + 1) = v12;
    BOOL v22 = v11;
    sub_10036CD68((uint64_t)v23, a3);
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v24, (const ctu::OsLogLogger *)a2);
    xpc_object_t v29 = 0;
    int v15 = (char *)operator new(0x48uLL);
    *(void *)int v15 = off_101A91A38;
    *(_OWORD *)(v15 + 8) = v21;
    *((void *)v15 + 3) = v22;
    sub_10036CD68((uint64_t)(v15 + 32), (uint64_t)v23);
    ctu::OsLogLogger::OsLogLogger();
    xpc_object_t v29 = v15;
    (*(void (**)(uint64_t, unint64_t, uint64_t, uint8_t *))(*(void *)v14 + 16))(v14, v10, v6, buf);
    sub_1002726E4(buf);
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v24);
    sub_10026E5BC(v23);
  }
  else
  {
    __TUAssertTrigger();
  }
}

void sub_10111BC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t sub_10111BC68(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void sub_10111BC70(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

BOOL sub_10111BC78(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  if (!v2 || !*(unsigned char *)(v2 + 274)) {
    return 0;
  }
  int v5 = *(std::__shared_weak_count **)(a2 + 48);
  v10[0] = *(void *)(a2 + 40);
  v10[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v6 = sub_1004D0838(a2, v10);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v6 >= 2
    && (a1[4] == a1[5] || v6 != 3 || (xpc_object_t v7 = (unsigned char *)a1[8]) != 0 && *v7)
    && (uint64_t v8 = *(void *)(a2 + 40), *(unsigned char *)(v8 + 273))
    && *(void *)(v8 + 88)
    && *(void *)(v8 + 152))
  {
    return *(void *)(v8 + 168) != 0;
  }
  else
  {
    return 0;
  }
}

void sub_10111BD4C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10111BD64(uint64_t a1, uint64_t a2)
{
  return sub_10111BC78((void *)(a1 - 16), a2);
}

uint64_t sub_10111BD6C()
{
  return 0;
}

uint64_t sub_10111BD74()
{
  return 0;
}

void sub_10111BD7C(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  unsigned int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (!v8)
  {
    uint64_t v56 = *(NSObject **)a2;
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    unint64_t v59 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v59;
    uint64_t v58 = "[%s] Roadside environment doesn't exist";
    goto LABEL_80;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    uint64_t v56 = *(NSObject **)a2;
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    unint64_t v57 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v57;
    uint64_t v58 = "[%s] Roadside environment is not ready";
LABEL_80:
    xpc_object_t v62 = v56;
    uint32_t v63 = 12;
LABEL_81:
    _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v58, buf, v63);
    goto LABEL_83;
  }
  if (!*(unsigned char *)(v8 + 274))
  {
    uint64_t v56 = *(NSObject **)a2;
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    xpc_object_t v60 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v60;
    uint64_t v58 = "[%s] Roadside start message hasn't been acked yet";
    goto LABEL_80;
  }
  unint64_t v9 = sub_101117E48(v8);
  if (!v10)
  {
    uint64_t v56 = *(NSObject **)a2;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      uint64_t v61 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v61;
      uint64_t v58 = "[%s] ProviderId is missing in environment";
      goto LABEL_80;
    }
LABEL_83:
    *a3 = 0;
    a3[24] = 0;
    return;
  }
  unsigned int v11 = v9;
  int v12 = (const void *)*(unsigned __int16 *)(a1 + 28);
  if (v9 != v12)
  {
    __int16 v64 = *(NSObject **)a2;
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
      goto LABEL_83;
    }
    BOOL v65 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v65;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v11;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = v12;
    uint64_t v58 = "[%s] Expected providerId: %llu, but attempted providerId is: %hu";
    xpc_object_t v62 = v64;
    uint32_t v63 = 28;
    goto LABEL_81;
  }
  if (*(unsigned char *)(a1 + 60))
  {
    if (!*(_DWORD *)(a1 + 56)) {
      __TUAssertTrigger();
    }
    unint64_t v13 = sub_101125A48(*(void *)(a2 + 40));
    int v14 = v13;
    if ((v13 & 0xFF00000000) == 0) {
      __TUAssertTrigger();
    }
    if (*(_DWORD *)(a1 + 56) == v14) {
      unsigned __int8 v15 = 1;
    }
    else {
      unsigned __int8 v15 = 2;
    }
  }
  else
  {
    unsigned __int8 v15 = 0;
  }
  memset(__p, 0, 24);
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  int v16 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v17 = *(char *)(a1 + 24);
    if (v17 > 4) {
      int v18 = "???";
    }
    else {
      int v18 = off_101A91B40[v17];
    }
    xpc_object_t v19 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)xpc_object_t v69 = 136315394;
    *(void *)&v69[4] = v18;
    *(_WORD *)&v69[12] = 2080;
    *(void *)&v69[14] = v19;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v69, 0x16u);
  }
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 26), 8uLL);
  sub_10024081C((unint64_t *)buf, v15, 2uLL);
  sub_10024081C((unint64_t *)buf, 0, 1uLL);
  unsigned int v20 = *(unsigned __int16 *)(a1 + 30);
  sub_10024081C((unint64_t *)buf, v20 >> 8, 5uLL);
  sub_10024081C((unint64_t *)buf, v20, 8uLL);
  if (v15 == 2)
  {
    unint64_t v21 = *(unsigned int *)(a1 + 56);
    if (v21 >= 0x80)
    {
      do
      {
        sub_10024081C((unint64_t *)buf, v21 | 0x80, 8uLL);
        unint64_t v22 = v21 >> 7;
        unint64_t v23 = v21 >> 14;
        v21 >>= 7;
      }
      while (v23);
    }
    else
    {
      LODWORD(v22) = *(_DWORD *)(a1 + 56);
    }
    sub_10024081C((unint64_t *)buf, v22 & 0x7F, 8uLL);
  }
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  uint64_t v24 = __p[0];
  os_log_t v25 = __p[2];
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  __p[2] = *(void **)&buf[16];
  *(void *)long long buf = v24;
  *(void *)&uint8_t buf[16] = v25;
  unint64_t v26 = *(unsigned char **)(a1 + 32);
  __int16 v27 = *(unsigned char **)(a1 + 40);
  if (v27 == v26)
  {
    uint64_t v49 = *(NSObject **)a2;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      uint64_t v54 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v54;
      _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "[%s] No text. Failed to encode", buf, 0xCu);
    }
    *a3 = 0;
    a3[24] = 0;
    long long v50 = __p[0];
  }
  else
  {
    *(void *)long long buf = __p;
    do
      sub_100240714((unint64_t **)buf, v26++);
    while (v26 != v27);
    xpc_object_t v28 = *(NSObject **)a2;
    if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v29 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      int v30 = *(unsigned __int8 *)(a1 + 26);
      xpc_object_t v31 = off_101A91B28[v15];
      int v32 = *(unsigned __int8 *)(a1 + 60);
      if (*(unsigned char *)(a1 + 60)) {
        int v32 = *(_DWORD *)(a1 + 56);
      }
      int v33 = *(unsigned __int16 *)(a1 + 30);
      uint64_t v34 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136316418;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v30;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v31;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v32;
      __int16 v71 = 1024;
      int v72 = v33;
      __int16 v73 = 2048;
      uint64_t v74 = v34;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], Outgoing sequence number: %hu, Text size: %zu", buf, 0x32u);
    }
    unint64_t v35 = a3;
    uint64_t v36 = *(void *)(a2 + 40);
    uint64_t v38 = *(void *)(v36 + 168);
    unint64_t v37 = *(std::__shared_weak_count **)(v36 + 176);
    if (v37) {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v66 = v37;
    uint64_t v39 = (char *)__p[0];
    uint64_t v40 = *(unsigned __int8 *)__p[0];
    uint64_t v41 = *((unsigned __int8 *)__p[0] + 1);
    uint64_t v42 = *((unsigned __int8 *)__p[0] + 2);
    uint64_t v43 = *((unsigned __int8 *)__p[0] + 3);
    long long v44 = operator new(8uLL);
    *long long v44 = v40 | (v41 << 8) | (v42 << 48) | (v43 << 56);
    *(void *)&v69[8] = v44 + 1;
    *(void *)&v69[16] = v44 + 1;
    *(void *)xpc_object_t v69 = v44;
    uint64_t v45 = (char *)((char *)__p[1] - (char *)v39);
    if ((void *)((char *)__p[1] - (char *)v39) <= (void *)4)
    {
      __TUAssertTrigger();
      uint64_t v39 = (char *)__p[0];
      uint64_t v45 = (char *)((char *)__p[1] - (char *)__p[0]);
    }
    memset(buf, 0, 32);
    sub_100BCAA0C((os_log_t *)a2, v38, (uint64_t)v69, v39 + 4, (size_t)(v45 - 4), buf);
    int v46 = buf[24];
    if (buf[24])
    {
      uint64_t v47 = (char *)__p[0];
      unint64_t v48 = (char *)__p[1] - (char *)__p[0];
      if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 4)
      {
        __TUAssertTrigger();
        uint64_t v47 = (char *)__p[0];
        unint64_t v48 = (char *)__p[1] - (char *)__p[0];
      }
      if (v48 > 3)
      {
        if (v48 != 4) {
          __p[1] = v47 + 4;
        }
      }
      else
      {
        sub_10011FDF0((unint64_t *)__p, 4 - v48);
      }
      if (!buf[24]) {
        sub_10016C840();
      }
      uint64_t v52 = *(unsigned char **)buf;
      char v53 = *(unsigned char **)&buf[8];
      *(void *)uint64_t v68 = __p;
      while (v52 != v53)
        sub_100240714((unint64_t **)v68, v52++);
    }
    else
    {
      uint64_t v51 = *(NSObject **)a2;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        int v55 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)uint64_t v68 = 136315138;
        *(void *)&v68[4] = v55;
        _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v68, 0xCu);
      }
      *unint64_t v35 = 0;
      v35[24] = 0;
    }
    if (buf[24] && *(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (*(void *)v69) {
      operator delete(*(void **)v69);
    }
    if (v66) {
      sub_10004D2C8(v66);
    }
    long long v50 = __p[0];
    if (v46)
    {
      *(void **)unint64_t v35 = __p[0];
      *(_OWORD *)(v35 + 8) = *(_OWORD *)&__p[1];
      v35[24] = 1;
      return;
    }
  }
  if (v50)
  {
    __p[1] = v50;
    operator delete(v50);
  }
}

void sub_10111C54C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,char a24)
{
  operator delete(v24);
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10111C5EC(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
}

uint64_t sub_10111C5F4()
{
  return 0;
}

uint64_t sub_10111C5FC()
{
  return 0;
}

uint64_t sub_10111C614()
{
  return 0;
}

uint64_t sub_10111C61C()
{
  return 0;
}

uint64_t sub_10111C624()
{
  return 0;
}

uint64_t sub_10111C62C()
{
  return 0;
}

BOOL sub_10111C634(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned __int8 *)(a1 + 26) != *(unsigned __int8 *)(v2 + 104);
}

BOOL sub_10111C658(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned __int8 *)(a1 + 10) != *(unsigned __int8 *)(v2 + 104);
}

uint64_t sub_10111C67C()
{
  return 0;
}

uint64_t sub_10111C684()
{
  return 0;
}

uint64_t sub_10111C68C(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    int v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    xpc_object_t v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_10111C740(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_10111C748(uint64_t a1, os_log_t *a2)
{
  return sub_10111C68C(a1 - 16, a2);
}

BOOL sub_10111C750(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

BOOL sub_10111C788(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  return v2 && *(unsigned char *)(v2 + 273) && *(void *)(v2 + 88) && *(void *)(v2 + 152) && *(void *)(v2 + 168) != 0;
}

uint64_t sub_10111C7C0()
{
  return 0;
}

uint64_t sub_10111C7C8()
{
  return 0;
}

void sub_10111C7D0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (!v8)
  {
    int v46 = *(NSObject **)a2;
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    uint64_t v49 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v49;
    unint64_t v48 = "[%s] Roadside environment doesn't exist";
    goto LABEL_73;
  }
  if (!*(unsigned char *)(v8 + 273) || !*(void *)(v8 + 88) || !*(void *)(v8 + 152) || !*(void *)(v8 + 168))
  {
    int v46 = *(NSObject **)a2;
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    uint64_t v47 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v47;
    unint64_t v48 = "[%s] Roadside environment is not ready";
LABEL_73:
    _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v48, buf, 0xCu);
    goto LABEL_74;
  }
  if (!*(unsigned char *)(v8 + 274))
  {
    int v46 = *(NSObject **)a2;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      long long v50 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v50;
      unint64_t v48 = "[%s] Roadside start message hasn't been acked yet";
      goto LABEL_73;
    }
LABEL_74:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    return;
  }
  memset(__p, 0, 24);
  unsigned int v9 = sub_10112625C(v8);
  __int16 v10 = sub_1011257BC(*(void *)(a2 + 40));
  if (((v10 + 1) & 0x100) != 0) {
    char v11 = 1;
  }
  else {
    char v11 = v10 + 1;
  }
  if ((v10 & 0xFF00) != 0) {
    unsigned __int8 v12 = v11;
  }
  else {
    unsigned __int8 v12 = 0;
  }
  sub_1011258D4(*(void *)(a2 + 40));
  uint64_t v13 = *(void *)(a2 + 40);
  uint64_t v14 = *(void *)(v13 + 104);
  int v15 = *(unsigned __int8 *)(v13 + 276);
  *(unsigned char *)(v13 + 276) = 0;
  memset(buf, 0, 32);
  sub_10024060C((uint64_t)buf, 0xC8uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
  sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
  int v16 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v17 = *(char *)(a1 + 24);
    if (v17 > 4) {
      int v18 = "???";
    }
    else {
      int v18 = off_101A91B40[v17];
    }
    xpc_object_t v19 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
    *(_DWORD *)char v53 = 136315394;
    *(void *)&v53[4] = v18;
    *(_WORD *)&v53[12] = 2080;
    *(void *)&v53[14] = v19;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v53, 0x16u);
  }
  sub_10024081C((unint64_t *)buf, v14, 8uLL);
  sub_10024081C((unint64_t *)buf, v12, 8uLL);
  uint64_t v20 = *(void *)(a2 + 40);
  unint64_t v21 = *(double **)(v20 + 88);
  unint64_t v22 = *(std::__shared_weak_count **)(v20 + 96);
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10104992C(v21, a2, (unint64_t *)buf);
  sub_10024081C((unint64_t *)buf, v9, 2uLL);
  sub_10024081C((unint64_t *)buf, 0, 1uLL);
  sub_10024081C((unint64_t *)buf, v15, 2uLL);
  sub_10024081C((unint64_t *)buf, 0, 3uLL);
  if (*(void *)&buf[24]) {
    __TUAssertTrigger();
  }
  long long v23 = *(_OWORD *)__p;
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  *(_OWORD *)long long buf = v23;
  uint64_t v24 = __p[2];
  __p[2] = *(void **)&buf[16];
  *(void *)&uint8_t buf[16] = v24;
  if (!v22)
  {
    os_log_t v25 = (void *)v23;
    if (!(void)v23) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  sub_10004D2C8(v22);
  os_log_t v25 = *(void **)buf;
  if (*(void *)buf)
  {
LABEL_26:
    *(void *)&uint8_t buf[8] = v25;
    operator delete(v25);
  }
LABEL_27:
  unint64_t v26 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v27 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    if (v9 > 4) {
      xpc_object_t v28 = "???";
    }
    else {
      xpc_object_t v28 = off_101A91B68[(char)v9];
    }
    *(_DWORD *)long long buf = 136316162;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v14;
    if (v15) {
      xpc_object_t v29 = "Yes";
    }
    else {
      xpc_object_t v29 = "No";
    }
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v12;
    *(_WORD *)&uint8_t buf[24] = 2080;
    *(void *)&buf[26] = v28;
    __int16 v55 = 2080;
    uint64_t v56 = v29;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, location sequence num: %hhu, battery: %s, Is Resume: %s", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a2 + 40);
  uint64_t v32 = *(void *)(v30 + 168);
  xpc_object_t v31 = *(std::__shared_weak_count **)(v30 + 176);
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v33 = (char *)__p[0];
  uint64_t v34 = *(unsigned __int8 *)__p[0];
  uint64_t v35 = *((unsigned __int8 *)__p[0] + 1);
  uint64_t v36 = *((unsigned __int8 *)__p[0] + 2);
  unint64_t v37 = operator new(8uLL);
  *unint64_t v37 = v34 | (v35 << 8) | (v36 << 56);
  *(void *)&v53[8] = v37 + 1;
  *(void *)&v53[16] = v37 + 1;
  *(void *)char v53 = v37;
  uint64_t v38 = (char *)((char *)__p[1] - (char *)v33);
  if ((void *)((char *)__p[1] - (char *)v33) <= (void *)3)
  {
    __TUAssertTrigger();
    int v33 = (char *)__p[0];
    uint64_t v38 = (char *)((char *)__p[1] - (char *)__p[0]);
  }
  memset(buf, 0, 32);
  sub_100BCAA0C((os_log_t *)a2, v32, (uint64_t)v53, v33 + 3, (size_t)(v38 - 3), buf);
  int v39 = buf[24];
  if (buf[24])
  {
    uint64_t v40 = (char *)__p[0];
    unint64_t v41 = (char *)__p[1] - (char *)__p[0];
    if ((char *)__p[1] - (char *)__p[0] != *(void *)&buf[8] - *(void *)buf + 3)
    {
      __TUAssertTrigger();
      uint64_t v40 = (char *)__p[0];
      unint64_t v41 = (char *)__p[1] - (char *)__p[0];
    }
    if (v41 > 2)
    {
      if (v41 != 3) {
        __p[1] = v40 + 3;
      }
    }
    else
    {
      sub_10011FDF0((unint64_t *)__p, 3 - v41);
    }
    if (!buf[24]) {
      sub_10016C840();
    }
    uint64_t v43 = *(unsigned char **)buf;
    long long v44 = *(unsigned char **)&buf[8];
    *(void *)uint64_t v52 = __p;
    while (v43 != v44)
      sub_100240714((unint64_t **)v52, v43++);
  }
  else
  {
    uint64_t v42 = *(NSObject **)a2;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      uint64_t v45 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)uint64_t v52 = 136315138;
      *(void *)&v52[4] = v45;
      _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "[%s] Failed to encrypt", v52, 0xCu);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  if (buf[24] && *(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (*(void *)v53) {
    operator delete(*(void **)v53);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (v39)
  {
    *(void **)a3 = __p[0];
    *(_OWORD *)(a3 + 8) = *(_OWORD *)&__p[1];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_10111CE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22)
{
  operator delete(v23);
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10111CED8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_10111CEE0()
{
  return 0;
}

uint64_t sub_10111CEE8()
{
  return 0;
}

BOOL sub_10111CF00(uint64_t a1)
{
  return *(unsigned char *)(a1 + 40) && !*(void *)(a1 + 72) && *(void *)(a1 + 48) != *(void *)(a1 + 56);
}

BOOL sub_10111CF28(uint64_t a1)
{
  return *(unsigned char *)(a1 + 24) && !*(void *)(a1 + 56) && *(void *)(a1 + 32) != *(void *)(a1 + 40);
}

void sub_10111CF50(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 40) || *(void *)(a1 + 72) || *(void *)(a1 + 48) == *(void *)(a1 + 56)) {
    __TUAssertTrigger();
  }
  if (!a3[5]) {
    goto LABEL_16;
  }
  xpc_object_t v7 = (std::__shared_weak_count *)a3[6];
  *(void *)&long long buf = a3[5];
  *((void *)&buf + 1) = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = sub_1004D0838((uint64_t)a3, (uint64_t *)&buf);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v8 != 3)
  {
LABEL_16:
    int v18 = *a3;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      xpc_object_t v19 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failure: Environment is not ready", (uint8_t *)&buf, 0xCu);
    }
    sub_10036CD68((uint64_t)&buf, a4);
    operator new();
  }
  unsigned int v9 = (std::__shared_weak_count *)operator new(0x20uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
  LOBYTE(v9[1].__vftable) = 1;
  __int16 v10 = v9 + 1;
  char v11 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v9 + 1;
  *(void *)(a1 + 80) = v9;
  if (!v11
    || (sub_10004D2C8(v11),
        __int16 v10 = *(std::__shared_weak_count **)(a1 + 72),
        (unsigned int v9 = *(std::__shared_weak_count **)(a1 + 80)) != 0))
  {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v14 = a3[3];
  unsigned int v20 = *(_DWORD *)(a1 + 36);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, (const ctu::OsLogLogger *)a3);
  sub_10036CD68((uint64_t)v22, a4);
  *(void *)&long long v23 = a1;
  *((void *)&v23 + 1) = v10;
  uint64_t v24 = v9;
  uint64_t v25 = v12 - v13;
  char v26 = 0;
  xpc_object_t v28 = 0;
  int v15 = operator new(0x58uLL);
  *(void *)int v15 = off_101A91AB8;
  ctu::OsLogLogger::OsLogLogger();
  sub_10036CD68((uint64_t)(v15 + 1), (uint64_t)v22);
  v15[3] = v23;
  int v16 = v24;
  *((void *)&v23 + 1) = 0;
  uint64_t v24 = 0;
  *((unsigned char *)v15 + 80) = v26;
  uint64_t v17 = v25;
  *((void *)v15 + 8) = v16;
  *((void *)v15 + 9) = v17;
  xpc_object_t v28 = v15;
  (*((void (**)(NSObject *, void, uint64_t, long long *))v14->isa + 3))(v14, v20, a1 + 48, &buf);
  sub_1002BF950(&buf);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  sub_10026E5BC(v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
}

void sub_10111D268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_1002BF950((uint64_t *)va1);
  sub_10036B6A4((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10111D2C4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void sub_10111D2CC(uint64_t a1, uint64_t a2, NSObject **a3, uint64_t a4)
{
}

BOOL sub_10111D2D4(uint64_t a1, uint64_t a2, unsigned char **a3)
{
  uint64_t v6 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a2 + 40);
  if (v8)
  {
    if (*(unsigned char *)(v8 + 273) && *(void *)(v8 + 88) && *(void *)(v8 + 152) && *(void *)(v8 + 168))
    {
      unint64_t v9 = a3[1] - *a3;
      if (v9 > 4)
      {
        *(unsigned char *)(a1 + 26) = 0;
        unint64_t v16 = 8;
        while (1)
        {
          uint64_t v17 = a3[4];
          unint64_t v18 = (unint64_t)a3[5];
          if (!v18)
          {
            a3[4] = ++v17;
            a3[5] = (unsigned char *)8;
            unint64_t v18 = 8;
          }
          uint64_t v19 = (uint64_t)*a3;
          if ((unint64_t)v17 >= a3[1] - *a3)
          {
            *((unsigned char *)a3 + 24) = 1;
            unint64_t v57 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            __int16 v64 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v64;
            uint64_t v13 = "[%s] Failed to read conversationID";
            goto LABEL_123;
          }
          unint64_t v20 = v16 - v18;
          if (v16 <= v18) {
            break;
          }
          unsigned int v21 = v17[v19] & ~(-1 << v18);
          a3[5] = 0;
          *(unsigned char *)(a1 + 26) |= v21 << v20;
          unint64_t v16 = v20;
          if (v20 - 9 < 0xFFFFFFFFFFFFFFF8) {
            __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
          }
        }
        a3[5] = (unsigned char *)(v18 - v16);
        if (v16 < 8) {
          char v22 = ~(-1 << v16);
        }
        else {
          char v22 = -1;
        }
        unsigned __int8 v23 = *(unsigned char *)(a1 + 26) | (v17[v19] >> (v18 - v16)) & v22;
        int v24 = v23;
        *(unsigned char *)(a1 + 26) = v23;
        uint64_t v25 = *(void *)(*(void *)(a2 + 40) + 104);
        if (v23 == v25)
        {
          int v26 = 0;
          uint64_t v27 = (uint64_t)*a3;
          unint64_t v28 = a3[1] - *a3;
          xpc_object_t v29 = a3[4];
          unint64_t v30 = (unint64_t)a3[5];
          unint64_t v31 = 2;
          if (v30) {
            goto LABEL_24;
          }
          while (1)
          {
            a3[4] = ++v29;
            a3[5] = (unsigned char *)8;
            unint64_t v30 = 8;
LABEL_24:
            if ((unint64_t)v29 >= v28)
            {
              *((unsigned char *)a3 + 24) = 1;
              unint64_t v57 = *(NSObject **)a2;
              BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
              if (!result) {
                return result;
              }
              __int16 v71 = sub_10093AA58(*(_DWORD *)(a1 + 12));
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v71;
              uint64_t v13 = "[%s] Failed to read text encoding";
              goto LABEL_123;
            }
            BOOL v32 = v30 >= v31;
            uint64_t v33 = v30 - v31;
            if (v32) {
              break;
            }
            char v34 = v29[v27];
            a3[5] = 0;
            v26 |= 2 * (v34 & 1);
            unint64_t v31 = 1;
          }
          a3[5] = (unsigned char *)v33;
          unsigned int v37 = v26 | (v29[v27] >> v33) & ~(-1 << v31);
          unsigned int v38 = (v26 | (v29[v27] >> v33) & ~(-1 << v31));
          if (v38 >= 3) {
            int v39 = 3;
          }
          else {
            int v39 = v38;
          }
          *(unsigned char *)(a1 + 30) = v39;
          if (v38 >= 3)
          {
            uint64_t v40 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            unint64_t v41 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            uint64_t v42 = off_101A91B90[v39];
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v41;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v42;
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&uint8_t buf[24] = v37;
            uint64_t v13 = "[%s] Invalid encoding: %s (Received: %hhu)";
            uint64_t v14 = v40;
            uint32_t v15 = 28;
            goto LABEL_124;
          }
          if (!v33)
          {
            uint64_t v33 = 8;
            a3[4] = ++v29;
            a3[5] = (unsigned char *)8;
          }
          if ((unint64_t)v29 >= v28)
          {
            *((unsigned char *)a3 + 24) = 1;
            unint64_t v57 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            int v89 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v89;
            uint64_t v13 = "[%s] Failed to read reservedBit";
            goto LABEL_123;
          }
          a3[5] = (unsigned char *)(v33 - 1);
          *(_WORD *)(a1 + 32) = 0;
          if ((sub_10036C2D8((uint64_t *)a3, (_WORD *)(a1 + 32), 0xDuLL) & 1) == 0)
          {
            unint64_t v57 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            uint64_t v58 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v58;
            uint64_t v13 = "[%s] Failed to read incoming sequence number";
            goto LABEL_123;
          }
          unsigned __int16 v43 = (unsigned __int16)sub_101117E48(*(void *)(a2 + 40));
          if (!v44)
          {
            unint64_t v57 = *(NSObject **)a2;
            BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            unint64_t v59 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v59;
            uint64_t v13 = "[%s] ProviderId is missing in environment";
            goto LABEL_123;
          }
          *(_WORD *)(a1 + 28) = v43;
          if (*((unsigned char *)a3 + 24))
          {
            __TUAssertTrigger();
            if (*((unsigned char *)a3 + 24)) {
              sub_10016C840();
            }
          }
          unint64_t v45 = (unint64_t)a3[5];
          if (v45) {
            uint64_t v46 = (uint64_t)a3[4];
          }
          else {
            uint64_t v46 = (uint64_t)(a3[4] + 1);
          }
          if ((v45 | 8) != 8) {
            __TUAssertTrigger();
          }
          if (v46 != 4) {
            __TUAssertTrigger();
          }
          *(_OWORD *)long long __p = 0u;
          long long v93 = 0u;
          uint64_t v47 = *(void *)(a2 + 40);
          uint64_t v49 = *(void *)(v47 + 152);
          unint64_t v48 = *(std::__shared_weak_count **)(v47 + 160);
          if (v48) {
            atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          memset(v98, 0, sizeof(v98));
          long long v50 = *a3;
          buf[0] = **a3;
          buf[1] = v50[1];
          *(_DWORD *)&buf[2] = 0;
          buf[6] = v50[2];
          buf[7] = v50[3];
          sub_1003699B0(v98, buf, 8uLL);
          sub_100BCAE0C((os_log_t *)a2, v49, (uint64_t)v98, *a3 + 4, a3[1] - *a3 - 4, buf);
          sub_10026E640((uint64_t)__p, (__n128 *)buf);
          if (buf[24] && *(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          if (*(void *)v98)
          {
            *(void *)&v98[8] = *(void *)v98;
            operator delete(*(void **)v98);
          }
          if (v48) {
            sub_10004D2C8(v48);
          }
          if (BYTE8(v93))
          {
            if (__p[0] != __p[1])
            {
              *(void **)long long buf = __p[0];
              *(void **)&uint8_t buf[8] = __p[1];
              uint64_t v51 = v93;
              __p[1] = 0;
              *(void *)&long long v93 = 0;
              __p[0] = 0;
              *(void *)&uint8_t buf[16] = v51;
              *(void *)&uint8_t buf[24] = 0;
              *(void *)&uint8_t buf[32] = 0;
              *(void *)v95 = 8;
              int v52 = *(unsigned __int8 *)(a1 + 30);
              if (v52 == 2)
              {
                unint64_t v91 = 0;
                if ((sub_10036C524((uint64_t *)buf, &v91) & 1) == 0)
                {
                  os_log_t v72 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_95;
                  }
                  __int16 v73 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v98 = 136315138;
                  *(void *)&v98[4] = v73;
                  uint64_t v68 = "[%s] Failed to read varint-128 codecId";
                  goto LABEL_130;
                }
                unint64_t v65 = v91;
                if (HIDWORD(v91))
                {
                  os_log_t v66 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_95;
                  }
                  long long v67 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v98 = 136315394;
                  *(void *)&v98[4] = v67;
                  *(_WORD *)&v98[12] = 2048;
                  *(void *)&v98[14] = v65;
                  uint64_t v68 = "[%s] CodecId must fit 32 bits (Received: %llu)";
                  xpc_object_t v69 = v66;
                  uint32_t v70 = 22;
                  goto LABEL_131;
                }
                if (!v91)
                {
                  os_log_t v86 = *(os_log_t *)a2;
                  if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_95;
                  }
                  uint64_t v87 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  *(_DWORD *)v98 = 136315394;
                  *(void *)&v98[4] = v87;
                  *(_WORD *)&v98[12] = 1024;
                  *(_DWORD *)&v98[14] = 0;
                  uint64_t v68 = "[%s] Received invalid codecId(%u) from backend";
                  xpc_object_t v69 = v86;
                  uint32_t v70 = 18;
                  goto LABEL_131;
                }
                if (!*(unsigned char *)(a1 + 40)) {
                  *(unsigned char *)(a1 + 40) = 1;
                }
                *(_DWORD *)(a1 + 36) = v65;
              }
              else if (v52 == 1)
              {
                unint64_t v53 = sub_101125A48(*(void *)(a2 + 40));
                if ((v53 & 0xFF00000000) != 0)
                {
                  *(_DWORD *)(a1 + 36) = v53;
                  *(unsigned char *)(a1 + 40) = 1;
                  goto LABEL_64;
                }
                os_log_t v72 = *(os_log_t *)a2;
                if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
                {
LABEL_95:
                  int v63 = 1;
                  goto LABEL_96;
                }
                int v88 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                *(_DWORD *)v98 = 136315138;
                *(void *)&v98[4] = v88;
                uint64_t v68 = "[%s] Don't have a valid preferred codec id";
LABEL_130:
                xpc_object_t v69 = v72;
                uint32_t v70 = 12;
LABEL_131:
                _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, v68, v98, v70);
                goto LABEL_95;
              }
LABEL_64:
              if (buf[24])
              {
                __TUAssertTrigger();
                if (buf[24]) {
                  sub_10016C840();
                }
              }
              if (*(void *)v95) {
                uint64_t v54 = *(void *)&buf[32];
              }
              else {
                uint64_t v54 = *(void *)&buf[32] + 1;
              }
              if ((*(void *)v95 | 8) != 8) {
                __TUAssertTrigger();
              }
              __int16 v55 = *(unsigned char **)&buf[8];
              uint64_t v56 = (unsigned char *)(*(void *)buf + v54);
              *(void *)v98 = a1 + 48;
              while (v56 != v55)
                sub_100240714((unint64_t **)v98, v56++);
              if (*(void *)(a1 + 48) == *(void *)(a1 + 56))
              {
                os_log_t v72 = *(os_log_t *)a2;
                if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_95;
                }
                v90 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                *(_DWORD *)v98 = 136315138;
                *(void *)&v98[4] = v90;
                uint64_t v68 = "[%s] Rejecting empty text received from backend";
                goto LABEL_130;
              }
              int v63 = 0;
LABEL_96:
              if (*(void *)buf)
              {
                *(void *)&uint8_t buf[8] = *(void *)buf;
                operator delete(*(void **)buf);
              }
LABEL_98:
              if (BYTE8(v93) && __p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
              if (!v63)
              {
                uint64_t v74 = *(NSObject **)a2;
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                {
                  int v75 = sub_10093AA58(*(_DWORD *)(a1 + 12));
                  unint64_t v76 = *(char *)(a1 + 30);
                  if (v76 > 3) {
                    unsigned int v77 = "???";
                  }
                  else {
                    unsigned int v77 = off_101A91B90[v76];
                  }
                  int v78 = *(unsigned __int8 *)(a1 + 26);
                  int v79 = *(unsigned __int8 *)(a1 + 40);
                  if (*(unsigned char *)(a1 + 40)) {
                    int v79 = *(_DWORD *)(a1 + 36);
                  }
                  int v80 = *(unsigned __int16 *)(a1 + 32);
                  uint64_t v81 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
                  if (*(unsigned char *)(a1 + 30)) {
                    v82 = "true";
                  }
                  else {
                    v82 = "false";
                  }
                  *(_DWORD *)long long buf = 136316674;
                  *(void *)&uint8_t buf[4] = v75;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v78;
                  *(_WORD *)&buf[18] = 2080;
                  *(void *)&buf[20] = v77;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v79;
                  *(_WORD *)&unsigned char buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v80;
                  *(_WORD *)v95 = 2048;
                  *(void *)&v95[2] = v81;
                  __int16 v96 = 2080;
                  unint64_t v97 = v82;
                  _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I [%s] ConversationID: %hhu, Encoding: %s[%u], sequence number: %hu, Received text size: %zu, isCompressed: %s", buf, 0x3Cu);
                }
                return 1;
              }
              return 0;
            }
            xpc_object_t v60 = *(NSObject **)a2;
            if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR))
            {
LABEL_81:
              int v63 = 1;
              goto LABEL_98;
            }
            v84 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v84;
            xpc_object_t v62 = "[%s] Decrypted message contents are empty";
          }
          else
          {
            xpc_object_t v60 = *(NSObject **)a2;
            if (!os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_ERROR)) {
              return 0;
            }
            uint64_t v61 = sub_10093AA58(*(_DWORD *)(a1 + 12));
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v61;
            xpc_object_t v62 = "[%s] Failed to decrypt incoming text message";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, v62, buf, 0xCu);
          goto LABEL_81;
        }
        uint64_t v35 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        uint64_t v36 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v36;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v25;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v24;
        uint64_t v13 = "[%s] Expected conversationID: %hhu, got: %hhu. Rejecting message";
        uint64_t v14 = v35;
        uint32_t v15 = 24;
      }
      else
      {
        uint64_t v10 = *(NSObject **)a2;
        BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        uint64_t v12 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = 4;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&uint8_t buf[24] = v9;
        uint64_t v13 = "[%s] Incomplete message: Expected size > %zu, got %zu";
        uint64_t v14 = v10;
        uint32_t v15 = 32;
      }
      goto LABEL_124;
    }
    unint64_t v57 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v83 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v83;
    uint64_t v13 = "[%s] Roadside environment is not ready";
  }
  else
  {
    unint64_t v57 = *(NSObject **)a2;
    BOOL result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    v85 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v85;
    uint64_t v13 = "[%s] Roadside environment doesn't exist";
  }
LABEL_123:
  uint64_t v14 = v57;
  uint32_t v15 = 12;
LABEL_124:
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
  return 0;
}

void sub_10111DE34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14)
  {
    if (a11) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10111DEC0(uint64_t a1, uint64_t a2, unsigned char **a3)
{
  return sub_10111D2D4(a1 - 16, a2, a3);
}

uint64_t sub_10111DEC8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10111DED4()
{
}

void sub_10111DEE8(uint64_t a1)
{
  *(void *)a1 = off_101A90E78;
  *(void *)(a1 + 16) = &unk_101A90F20;
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v2 = *(void **)(a1 + 64);
    if (v2)
    {
      *(void *)(a1 + 72) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  operator delete();
}

void sub_10111DF98(uint64_t a1)
{
  *(void *)(a1 - 16) = off_101A90E78;
  *(void *)a1 = &unk_101A90F20;
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0) {
      operator delete(*(void **)(a1 + 16));
    }
  }
}

void sub_10111E024(uint64_t a1)
{
  *(void *)(a1 - 16) = off_101A90E78;
  *(void *)a1 = &unk_101A90F20;
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 40) && *(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

uint64_t sub_10111E0D4(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10111E0E0()
{
}

void sub_10111E0F4(void *a1)
{
  *a1 = off_101A911A0;
  a1[2] = &unk_101A91248;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10111E190(void *a1)
{
  *(a1 - 2) = off_101A911A0;
  *a1 = &unk_101A91248;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
}

void sub_10111E208(void *a1)
{
  *(a1 - 2) = off_101A911A0;
  *a1 = &unk_101A91248;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }

  operator delete();
}

uint64_t sub_10111E2A4(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10111E2B0()
{
}

void sub_10111E2C8()
{
}

void sub_10111E2E0()
{
}

uint64_t sub_10111E2F8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_10111E304()
{
}

void sub_10111E318(void *a1)
{
  *a1 = off_101A917F0;
  a1[2] = &unk_101A91858;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_10111E3B4(void *a1)
{
  *(a1 - 2) = off_101A917F0;
  *a1 = &unk_101A91858;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
}

void sub_10111E42C(void *a1)
{
  *(a1 - 2) = off_101A917F0;
  *a1 = &unk_101A91858;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_10111E4C8(void *a1)
{
  *a1 = off_101A91A38;
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  sub_10026E5BC(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10111E520(void *a1)
{
  *a1 = off_101A91A38;
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  sub_10026E5BC(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_10111E598(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A91A38;
  sub_10111E920((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10111E5EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10111E600(uint64_t a1, void *a2)
{
  *a2 = off_101A91A38;
  return sub_10111E920((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10111E62C(uint64_t a1)
{
}

void sub_10111E634(void *a1)
{
  sub_10036D36C(a1 + 1);

  operator delete(a1);
}

void sub_10111E670(void *a1, uint64_t *a2, __n128 *a3)
{
  BOOL v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      unint64_t v9 = v8;
      uint64_t v10 = (unsigned char *)a1[2];
      if (v10)
      {
        unsigned char *v10 = 1;
        if ((v6 & 0xFF00000000) != 0 && a3->n128_u64[0] != a3->n128_u64[1] && v6)
        {
          unint64_t v11 = *(void *)(v7 + 40) - *(void *)(v7 + 32);
          *(_DWORD *)(v7 + 56) = v6;
          *(unsigned char *)(v7 + 60) = 1;
          unint64_t v12 = a3->n128_u64[1] - a3->n128_u64[0];
          if (v11 < v12) {
            __TUAssertTrigger();
          }
          uint64_t v13 = a1[8];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = sub_10093AA58(*(_DWORD *)(v7 + 12));
            *(_DWORD *)unsigned int v21 = 136315650;
            *(void *)&void v21[4] = v14;
            __int16 v22 = 2048;
            unint64_t v23 = v11;
            __int16 v24 = 2048;
            unint64_t v25 = v12;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Reduced size from %zu bytes -> %zu bytes", v21, 0x20u);
          }
          __n128 v15 = sub_10005C9A4(v7 + 32, a3);
          int v16 = *(_DWORD *)(v7 + 56);
          *(void *)unsigned int v21 = v11 - v12;
          *(_DWORD *)&char v21[8] = v16;
          BYTE2(v23) = 1;
          uint64_t v17 = a1[7];
          if (!v17) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *, __n128))(*(void *)v17 + 48))(v17, v21, v15);
        }
        else
        {
          unint64_t v18 = a1[8];
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v19 = sub_10093AA58(*(_DWORD *)(v7 + 12));
            *(_DWORD *)unsigned int v21 = 136315138;
            *(void *)&void v21[4] = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [%s][Compression] Going uncompressed", v21, 0xCu);
          }
          v21[0] = 0;
          BYTE2(v23) = 0;
          uint64_t v20 = a1[7];
          if (!v20) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v20 + 48))(v20, v21);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_10111E8B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10111E8D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10111E914()
{
}

uint64_t sub_10111E920(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10036D2D4(a1 + 24, a2 + 24);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 56), (const ctu::OsLogLogger *)(a2 + 56));
  return a1;
}

void sub_10111E98C(_Unwind_Exception *a1)
{
  sub_10026E5BC(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void **sub_10111E9B4(void *a1)
{
  uint64_t v3 = a1;
  v4[0] = 0;
  v4[16] = 0;
  uint64_t v1 = a1[3];
  if (!v1) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v1 + 48))(v1, v4);
  return sub_10036D3C0(&v3);
}

void sub_10111EA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void *sub_10111EA38(void *a1)
{
  *a1 = off_101A91AB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10026E5BC(a1 + 2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_10111EA98(void *a1)
{
  *a1 = off_101A91AB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10026E5BC(a1 + 2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void *sub_10111EB18(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A91AB8;
  sub_10111EFB4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10111EB6C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10111EB80(uint64_t a1, void *a2)
{
  *a2 = off_101A91AB8;
  return sub_10111EFB4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10111EBAC(uint64_t a1)
{
}

void sub_10111EBB4(uint64_t a1)
{
  sub_10036B6A4((ctu::OsLogLogger *)(a1 + 8));

  operator delete((void *)a1);
}

void sub_10111EBF0(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 56))
      {
        if (!*(unsigned char *)(v5 + 40)) {
          __TUAssertTrigger();
        }
        *(void *)(v5 + 56) = *(void *)(v5 + 48);
        unint64_t v8 = a2->n128_u64[1];
        if (a2->n128_u64[0] == v8)
        {
          unint64_t v25 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = sub_10093AA58(*(_DWORD *)(v5 + 12));
            int v28 = *(_DWORD *)(v5 + 36);
            int v29 = *(unsigned __int8 *)(v5 + 26);
            int v30 = *(unsigned __int16 *)(v5 + 32);
            *(_DWORD *)long long buf = 136315906;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v36 = 1024;
            int v37 = v28;
            __int16 v38 = 1024;
            int v39 = v29;
            __int16 v40 = 1024;
            int v41 = v30;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[%s][Decompression] Failed. codecId: %u, conversationID: %hhu, incoming sequence number: %hu", buf, 0x1Eu);
          }
          buf[0] = 0;
          BYTE2(v37) = 0;
          uint64_t v26 = *(void *)(a1 + 40);
          if (!v26) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v26 + 48))(v26, buf);
        }
        else
        {
          unint64_t v9 = v8 - a2->n128_u64[0];
          uint64_t v10 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v11 = sub_10093AA58(*(_DWORD *)(v5 + 12));
            int v12 = *(_DWORD *)(v5 + 36);
            int v13 = *(unsigned __int8 *)(v5 + 26);
            int v14 = *(unsigned __int16 *)(v5 + 32);
            uint64_t v15 = *(void *)(a1 + 72);
            *(_DWORD *)long long buf = 136316418;
            *(void *)&uint8_t buf[4] = v11;
            __int16 v36 = 1024;
            int v37 = v12;
            __int16 v38 = 1024;
            int v39 = v13;
            __int16 v40 = 1024;
            int v41 = v14;
            __int16 v42 = 2048;
            uint64_t v43 = v15;
            __int16 v44 = 2048;
            unint64_t v45 = v9;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [%s][Decompression] For codecId: %u, conversationID: %hhu, incoming sequence number: %hu, compressed text size: %zu, uncompressed text size: %zu bytes", buf, 0x32u);
          }
          sub_10005C9A4(v5 + 48, a2);
          unint64_t v16 = *(void *)(a1 + 72);
          uint64_t v17 = v9 - v16;
          if (v9 < v16)
          {
            unint64_t v18 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Backend is compressing in a way that does not yield any benefit. Please create radar.", buf, 2u);
            }
            uint64_t v17 = 0;
          }
          if (*(unsigned char *)(a1 + 80))
          {
            uint64_t v19 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v20 = *(_DWORD *)(v5 + 12);
              sub_10012CD04(buf, *(char **)(v5 + 48), *(char **)(v5 + 56), *(void *)(v5 + 56) - *(void *)(v5 + 48));
              unsigned int v21 = sub_10093AA58(v20);
              __int16 v22 = v39 >= 0 ? buf : *(unsigned char **)buf;
              int v31 = 136315394;
              BOOL v32 = v21;
              __int16 v33 = 2080;
              char v34 = v22;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [%s] Decompressed text: %s", (uint8_t *)&v31, 0x16u);
              if (SHIBYTE(v39) < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          int v23 = *(_DWORD *)(v5 + 36);
          *(void *)long long buf = v17;
          *(_DWORD *)&uint8_t buf[8] = v23;
          BYTE2(v37) = 1;
          uint64_t v24 = *(void *)(a1 + 40);
          if (!v24) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v24 + 48))(v24, buf);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10111EF4C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10111EF68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10111EFA8()
{
}

uint64_t sub_10111EFB4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)a2);
  sub_10036D2D4(v4 + 8, a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 56);
  *(void *)(a1 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(a1 + 64) = v6;
  return a1;
}

void sub_10111F01C(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

void sub_10111F030(const char *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  v6[0] = 0;
  v6[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v6);
  ctu::TextConverter::pushConversion();
  ctu::TextConverter::setSource((ctu::TextConverter *)v6, a1, a2);
  ctu::TextConverter::readChars(a3, (ctu::TextConverter *)v6, 0x7FFFFFFFuLL);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v6);
}

void sub_10111F0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10111F0C8(uint64_t a1, unsigned int a2, ctu::OsLogLogger *a3)
{
  uint64_t v5 = ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, a3);
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(void *)(v5 + 16) = 0x3FF0000000000000;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = 0;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = 0;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(void *)(v5 + 96) = 0x3FF0000000000000;
  *(void *)(v5 + 112) = 0;
  *(void *)(v5 + 120) = 0;
  *(void *)(v5 + 128) = 0;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  sub_100ABA920(&v8, a2);
  unsigned int v6 = v8;
  *(_DWORD *)(a1 + 176) = v8;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  *(_DWORD *)(a1 + 248) = v6;
  *(_DWORD *)(a1 + 252) = v6;
  *(_OWORD *)(a1 + 180) = xmmword_10147A180;
  *(_WORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = "Rsrp";
  *(void *)(a1 + 376) = "Sinr";
  *(void *)(a1 + 56) = 0x4000000000000000;
  *(void *)(a1 + 136) = 0x3FE0000000000000;
  return a1;
}

void sub_10111F1D0(_Unwind_Exception *a1)
{
  sub_10111F1F4((void *)v1 + 11);
  sub_10111F1F4(v2);
  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

void *sub_10111F1F4(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t *sub_10111F238(uint64_t a1, double a2, double a3)
{
  double v6 = *(double *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  double v7 = v6;
  double v8 = a2 - v6;
  if (a2 - v6 < 0.0 || v7 >= *(double *)(a1 + 272) || *(double *)(a1 + 88) >= *(double *)(a1 + 280))
  {
    *(unsigned char *)(a1 + 256) = 0;
    *(void *)(a1 + 168) = 0;
LABEL_8:
    double v10 = 0.0625;
    goto LABEL_9;
  }
  if (v8 + *(double *)(a1 + 168) < *(double *)(a1 + 264))
  {
    int v9 = *(unsigned __int8 *)(a1 + 256);
    *(double *)(a1 + 168) = v8;
    double v10 = 0.5;
    if (v9) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 256) = 1;
  *(double *)(a1 + 168) = v8;
  double v10 = 0.5;
LABEL_9:
  *(double *)(a1 + 96) = v10;
  sub_10111F468(v5, a2);
  sub_10111F468(a1 + 88, a3);
  double v11 = *(double *)(a1 + 8);
  double v12 = *(double *)(a1 + 288);
  *(unsigned char *)(a1 + 257) = v11 <= v12;
  int v13 = (uint64_t **)(a1 + 200);
  unsigned int v16 = 2;
  uint64_t v17 = &v16;
  if (v11 > v12)
  {
    int v14 = 8;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 8;
    unsigned int v16 = 3;
    uint64_t v17 = &v16;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 5;
    unsigned int v16 = 4;
    uint64_t v17 = &v16;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 5;
  }
  else
  {
    int v14 = 1;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 1;
    unsigned int v16 = 3;
    uint64_t v17 = &v16;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 1;
    unsigned int v16 = 4;
    uint64_t v17 = &v16;
    *((_DWORD *)sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17) + 8) = 1;
  }
  unsigned int v16 = 5;
  uint64_t v17 = &v16;
  BOOL result = sub_100ABCA70(v13, &v16, (uint64_t)&unk_10144E20E, &v17);
  *((_DWORD *)result + 8) = v14;
  return result;
}

double sub_10111F468(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    *(double *)a1 = *(double *)(a1 + 8) * a2 + (1.0 - *(double *)(a1 + 8)) * *(double *)a1;
  }
  else
  {
    *(double *)a1 = a2;
    *(unsigned char *)(a1 + 16) = 1;
    sub_1008356FC((char *)(a1 + 56), *(char **)(a1 + 24), *(void *)(a1 + 32), (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
  }
  int v3 = sub_10111F630(a1);
  uint64_t v5 = *(double **)(a1 + 24);
  double v6 = *(double **)(a1 + 56);
  double v7 = v6;
  double v8 = &v5[v3 - 1];
  if (v3 != 1)
  {
    uint64_t v9 = 8 * (v3 - 1);
    double v10 = *(double **)(a1 + 24);
    double v7 = *(double **)(a1 + 56);
    do
    {
      double v11 = *v10++;
      double result = v11 - *(double *)(a1 + 48);
      *v7++ = result;
      v9 -= 8;
    }
    while (v9);
  }
  double v12 = *(double **)(a1 + 32);
  while (v8 != v12)
  {
    double v13 = *v8++;
    double result = v13 + *(double *)(a1 + 48);
    *v7++ = result;
  }
  if (v6 != *(double **)(a1 + 64))
  {
    double result = *v5;
    double *v6 = *v5;
  }
  return result;
}

void sub_10111F548(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  sub_10111F468(a1 + 88, *(double *)(a1 + 296));
  *(void *)(a1 + 16) = 0x3FE0000000000000;
  *(void *)(a1 + 96) = 0x3FE0000000000000;
  *(_WORD *)(a1 + 256) = 0;
  if (a2)
  {
    int v4 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)(a1 + 248) = *(_DWORD *)(a1 + 252);
    *(_DWORD *)(a1 + 252) = v4;
  }
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = 0;
}

unint64_t sub_10111F5A8(uint64_t a1, int a2, unsigned int a3)
{
  double v6 = (_DWORD *)(a1 + 176);
  signed int v7 = sub_10111F630(a1 + 8);
  signed int v8 = sub_10111F630(a1 + 88);
  if (v8 >= v7) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v8;
  }
  sub_100ABA920(&v11, v9);
  return sub_100ABC838(v6, &v11, a2, a3) | ((unint64_t)*(unsigned int *)(a1 + 248) << 32);
}

uint64_t sub_10111F630(uint64_t a1)
{
  uint64_t v1 = *(double **)(a1 + 56);
  uint64_t v2 = *(double **)(a1 + 64);
  if (v2 != v1)
  {
    unint64_t v3 = v2 - v1;
    uint64_t v2 = *(double **)(a1 + 56);
    do
    {
      unint64_t v4 = v3 >> 1;
      uint64_t v5 = &v2[v3 >> 1];
      double v7 = *v5;
      double v6 = v5 + 1;
      v3 += ~(v3 >> 1);
      if (*(double *)a1 < v7) {
        unint64_t v3 = v4;
      }
      else {
        uint64_t v2 = v6;
      }
    }
    while (v3);
  }
  return ((unint64_t)((char *)v2 - (char *)v1) >> 3) + 1;
}

void sub_10111F680(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v4 = a2[2];
  *(_OWORD *)(a1 + 280) = a2[1];
  *(_OWORD *)(a1 + 296) = v4;
  *(_OWORD *)(a1 + 264) = v3;
  long long v5 = a2[3];
  long long v6 = a2[4];
  long long v7 = a2[5];
  *(void *)(a1 + 360) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 328) = v6;
  *(_OWORD *)(a1 + 344) = v7;
  *(_OWORD *)(a1 + 312) = v5;
  uint64_t v8 = a1 + 8;
  unsigned int v9 = (const void *)(a1 + 336);
  long long __p = 0;
  unsigned int v11 = 0;
  uint64_t v12 = 0;
  sub_10111F7D8(&__p, (const void *)(a1 + 304), a1 + 336, 4uLL);
  sub_10111F778(v8, (uint64_t)&__p);
  if (__p)
  {
    unsigned int v11 = __p;
    operator delete(__p);
  }
  long long __p = 0;
  unsigned int v11 = 0;
  uint64_t v12 = 0;
  sub_10111F7D8(&__p, v9, a1 + 368, 4uLL);
  sub_10111F778(a1 + 88, (uint64_t)&__p);
  if (__p)
  {
    unsigned int v11 = __p;
    operator delete(__p);
  }
}

void sub_10111F758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10111F778(uint64_t a1, uint64_t a2)
{
  long long v3 = (char *)(a1 + 24);
  if (v3 != (char *)a2) {
    sub_1008356FC(v3, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  }
  long long v4 = *(char **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);

  return sub_1008356FC((char *)(a1 + 56), v4, v5, (v5 - (uint64_t)v4) >> 3);
}

void *sub_10111F7D8(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    double result = sub_1004D669C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_10111F838(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10111F854(uint64_t a1)
{
  *(void *)a1 = off_101A91BC0;
  sub_101122320((void *)(a1 + 120));
  sub_100142A3C((const void **)(a1 + 112));
  sub_1000558F4((const void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  MISServiceInterface::~MISServiceInterface((MISServiceInterface *)a1);
}

void sub_10111F8F4(uint64_t a1)
{
  sub_10111F854(a1);

  operator delete();
}

void *sub_10111F92C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::getBasebandBootStrategy(a1) == 1) {
    operator new();
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = off_101A5DC48;
  result[3] = &off_1019A0FA0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_10111FC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_10111FDB8(uint64_t a1, dispatch_object_t *a2)
{
  long long v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10111FEBC(uint64_t a1, int a2, ServiceStage *this)
{
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10111FFD0(void *a1, char a2, char a3, char a4, uint64_t a5)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_1011200F4;
  v11[3] = &unk_101A91C18;
  char v12 = a2;
  char v13 = a3;
  char v14 = a4;
  void v11[4] = a1;
  v11[5] = a5;
  long long v6 = (std::__shared_weak_count *)a1[2];
  if (!v6 || (v7 = a1[1], (size_t v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v9 = v8;
  double v10 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1011231FC;
  block[3] = &unk_101A920A8;
  block[5] = v7;
  unsigned int v16 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v11;
  dispatch_async(v10, block);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v9);
}

void sub_1011200F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 48))
  {
    *(unsigned char *)(v2 + 80) = 0;
LABEL_3:
    *(void *)long long buf = 0;
    size_t v8 = 0;
    sub_101120208(buf, v2);
    uint64_t v3 = *(void *)buf;
    sub_101120488(*(uint64_t *)buf, *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned char *)(a1 + 50), 0, *(void *)(a1 + 40));
    if (capabilities::ct::supportsReportingTetheringStateToBaseband(v4))
    {
      sub_100083DA4((const void **)&v6, (const void **)(v3 + 88));
      sub_101120EB8(v2, &v6);
      sub_1000558F4((const void **)&v6);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
    return;
  }
  if (!*(unsigned char *)(v2 + 80)) {
    goto LABEL_3;
  }
  uint64_t v5 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MIS retries stopped", buf, 2u);
  }
}

void sub_1011201E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

std::__shared_weak_count *sub_101120208(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  long long v4 = *(std::__shared_weak_count **)(a2 + 96);
  if (!v4
    || (double result = std::__shared_weak_count::lock(v4), (a1[1] = result) == 0)
    || (uint64_t v6 = *(void *)(a2 + 88), (*a1 = v6) == 0))
  {
    operator new();
  }
  return result;
}

void sub_1011203EC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_101122440);
  __cxa_rethrow();
}

void sub_101120414(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (*(void *)(v1 + 8)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v1 + 8));
  }
  _Unwind_Resume(a1);
}

void sub_101120488(uint64_t a1, int a2, BOOL a3, char a4, BOOL a5, uint64_t a6)
{
  char v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      char v13 = "reset & ";
    }
    else {
      char v13 = "";
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a6;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&uint8_t buf[24] = asStringBool(a3);
    LOWORD(v73) = 2080;
    *(void *)((char *)&v73 + 2) = asStringBool(a5);
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Calls to %scheck MIS avalibility on %s, onlyForUnknownAuth=%s, pingOnly=%s", buf, 0x2Au);
  }
  BOOL v59 = a5;
  BOOL v60 = a3;
  char v14 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v14 || (uint64_t v15 = *(void *)(a1 + 8), (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v17 = v16;
  v69[0] = _NSConcreteStackBlock;
  v69[1] = 1174405120;
  v69[2] = sub_101122514;
  v69[3] = &unk_101A91E78;
  v69[4] = a1;
  v69[5] = v15;
  uint32_t v70 = v16;
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v18 = sub_1011215E0(a1, v69);
  uint64_t v19 = (capabilities::ct *)v70;
  if (v70) {
    sub_10004D2C8(v70);
  }
  if (!v18) {
    goto LABEL_93;
  }
  if (capabilities::ct::supportsReportingTetheringStateToBaseband(v19))
  {
    uint64_t v20 = *(void *)(a1 + 64);
    if (v20)
    {
      if (!(*(void *)(a1 + 88) ? sub_1000810B8 : 0))
      {
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        memset(buf, 0, sizeof(buf));
        if (_NETRBClientGetDynamicStoreKey(v20, (char *)buf))
        {
          CFStringRef v22 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)buf, 0x8000100u);
          int v23 = *(NSObject **)(a1 + 40);
          if (v22)
          {
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int16 v71 = 0;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I PHS key retreived successfully", v71, 2u);
            }
            uint64_t v24 = *(void *)(a1 + 88);
            *(void *)(a1 + 88) = v22;
            *(void *)__int16 v71 = v24;
            sub_1000558F4((const void **)v71);
            goto LABEL_25;
          }
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_25;
          }
          *(_WORD *)__int16 v71 = 0;
          unint64_t v25 = "_NETRBClientGetDynamicStoreKey failed to convert to CFStringRef";
        }
        else
        {
          int v23 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_25;
          }
          *(_WORD *)__int16 v71 = 0;
          unint64_t v25 = "_NETRBClientGetDynamicStoreKey failed";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v25, v71, 2u);
      }
    }
  }
LABEL_25:
  if (v60)
  {
    *(_DWORD *)__int16 v71 = 0;
    int v68 = 0;
    if ((_NETRBClientGetGlobalServiceState(*(void *)(a1 + 64), v71, &v68) & 1) == 0)
    {
      uint64_t v26 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = a6;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#E Failed to get MIS state (%s)", buf, 0xCu);
      }
    }
    int v27 = *(_DWORD *)v71;
    if ((*(_DWORD *)v71 - 1022) <= 0xFFFFFFFD)
    {
      int v28 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v27;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = a6;
        int v29 = "#I MIS state is already known: %d, bailing out (%s)";
        int v30 = v28;
        uint32_t v31 = 18;
LABEL_69:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
      }
LABEL_92:
      sub_1011217B8(a1);
      goto LABEL_93;
    }
    int v32 = v68;
    __int16 v33 = *(NSObject **)(a1 + 40);
    BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    if (v27 == 1021 && v32 == 3 && (a2 & 1) == 0)
    {
      if (!v34) {
        goto LABEL_92;
      }
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = 1021;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = 3;
      *(_WORD *)&buf[14] = 2080;
      *(void *)&uint8_t buf[16] = a6;
      int v29 = "#I NOT retrying when MIS state is: %d, the reason is: %d (%s)";
      int v30 = v33;
      goto LABEL_64;
    }
    if (v34)
    {
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v27;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v32;
      *(_WORD *)&buf[14] = 2080;
      *(void *)&uint8_t buf[16] = a6;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I retrying when MIS state is: %d, the reason is: %d (%s)", buf, 0x18u);
    }
  }
  uint64_t v35 = *(NSObject **)(a1 + 72);
  if (v35)
  {
    __int16 v36 = *(NSObject **)(a1 + 40);
    BOOL v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    if ((a4 & 1) == 0)
    {
      if (v37)
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = a6;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication already active (%s)", buf, 0xCu);
      }
      goto LABEL_93;
    }
    if (v37)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = a6;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication interrupted (%s)", buf, 0xCu);
      uint64_t v35 = *(NSObject **)(a1 + 72);
    }
    dispatch_source_cancel(v35);
    dispatch_release(*(dispatch_object_t *)(a1 + 72));
    *(void *)(a1 + 72) = 0;
    uint64_t v38 = *(void *)(a1 + 64);
    if (!v38)
    {
      __int16 v40 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_58;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v43 = "#I MIS Authentication interrupted while fClientRef not present";
      goto LABEL_57;
    }
    int v39 = _NETRBClientStopService(v38);
    __int16 v40 = *(NSObject **)(a1 + 40);
    BOOL v41 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
    if (v39)
    {
      if (v41)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I MIS Stopping", buf, 2u);
      }
      *(unsigned char *)(a1 + 80) = 1;
      if (*(unsigned char *)(a1 + 81)) {
        char v42 = 1;
      }
      else {
        char v42 = a2;
      }
      *(unsigned char *)(a1 + 81) = v42;
      goto LABEL_93;
    }
    if (v41)
    {
      *(_WORD *)long long buf = 0;
      uint64_t v43 = "#E MIS failed to stop";
LABEL_57:
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, v43, buf, 2u);
    }
  }
LABEL_58:
  if (a2) {
    sub_1011216A8(a1);
  }
  if (v59)
  {
    *(_DWORD *)__int16 v71 = 0;
    int v68 = 0;
    char GlobalServiceState = _NETRBClientGetGlobalServiceState(*(void *)(a1 + 64), v71, &v68);
    unint64_t v45 = *(NSObject **)(a1 + 40);
    BOOL v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT);
    if ((GlobalServiceState & 1) == 0)
    {
      if (v46)
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = a6;
        int v29 = "#E Failed to get MIS state (%s)";
        int v30 = v45;
        uint32_t v31 = 12;
        goto LABEL_69;
      }
      goto LABEL_92;
    }
    if (!v46) {
      goto LABEL_92;
    }
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)v71;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v68;
    *(_WORD *)&buf[14] = 2080;
    *(void *)&uint8_t buf[16] = a6;
    int v29 = "#I MIS state is: %d, the reason is: %d (%s)";
    int v30 = v45;
LABEL_64:
    uint32_t v31 = 24;
    goto LABEL_69;
  }
  *(void *)__int16 v71 = 0;
  xpc_object_t v47 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v48 = v47;
  if (v47)
  {
    *(void *)__int16 v71 = v47;
  }
  else
  {
    xpc_object_t v48 = xpc_null_create();
    *(void *)__int16 v71 = v48;
    if (!v48)
    {
      xpc_object_t v49 = xpc_null_create();
      xpc_object_t v48 = 0;
      goto LABEL_75;
    }
  }
  if (xpc_get_type(v48) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v48);
    goto LABEL_76;
  }
  xpc_object_t v49 = xpc_null_create();
LABEL_75:
  *(void *)__int16 v71 = v49;
LABEL_76:
  xpc_release(v48);
  xpc_object_t v66 = xpc_uint64_create(1uLL);
  if (!v66) {
    xpc_object_t v66 = xpc_null_create();
  }
  *(void *)long long buf = v71;
  *(char **)&uint8_t buf[8] = netrbClientDeviceType[0];
  sub_100035E70((uint64_t)buf, &v66, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v66);
  xpc_object_t v66 = 0;
  int started = _NETRBClientStartService(*(void *)(a1 + 64), 0, 201, 301, *(void **)v71);
  uint64_t v51 = *(NSObject **)(a1 + 40);
  BOOL v52 = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
  if (!started)
  {
    if (v52)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#E Failed to start MIS service.", buf, 2u);
    }
    xpc_release(*(xpc_object_t *)v71);
    goto LABEL_92;
  }
  if (v52)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Starting MIS service.", buf, 2u);
  }
  *(unsigned char *)(a1 + 80) = 0;
  dispatch_time_t v53 = dispatch_time(0, 60000000000);
  dispatch_source_t v54 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 1uLL, 0, *(dispatch_queue_t *)(a1 + 24));
  *(void *)(a1 + 72) = v54;
  __int16 v55 = *(NSObject **)(a1 + 40);
  BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
  BOOL v57 = v56;
  if (v54)
  {
    uint64_t v58 = v54;
    if (v57)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I fCleanTimer created", buf, 2u);
      uint64_t v58 = *(NSObject **)(a1 + 72);
    }
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 1174405120;
    handler[2] = sub_10112276C;
    handler[3] = &unk_101A91EA8;
    handler[4] = a1;
    handler[5] = v15;
    xpc_object_t v62 = v17;
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v63 = v60;
    char v64 = a4;
    char v65 = 0;
    dispatch_source_set_event_handler(v58, handler);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 72), v53, 0xFFFFFFFFFFFFFFFFLL, 0x12A05F200uLL);
    dispatch_activate(*(dispatch_object_t *)(a1 + 72));
    if (v62) {
      sub_10004D2C8(v62);
    }
  }
  else if (v56)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#E Failed to created Clean Timer.", buf, 2u);
  }
  xpc_release(*(xpc_object_t *)v71);
  if (!v54) {
    goto LABEL_92;
  }
LABEL_93:
  sub_10004D2C8(v17);
}

void sub_101120E34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101120EB8(uint64_t a1, void **a2)
{
  if (*a2) {
    uint64_t v2 = sub_1000810B8;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    if (!(*(void *)(a1 + 112) ? sub_100142574 : 0))
    {
      values = *a2;
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        HIDWORD(buf.info) = 0;
        buf.retain = 0;
        ctu::cf::assign();
        *(_OWORD *)long long __p = 0u;
        uint64_t v17 = 0;
        LODWORD(buf.version) = 136315138;
        *(CFIndex *)((char *)&buf.version + 4) = (CFIndex)__p;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Starting PHS DS listener for key: %s", (uint8_t *)&buf, 0xCu);
        if (SHIBYTE(v17) < 0) {
          operator delete(__p[0]);
        }
      }
      buf.version = 0;
      buf.info = (void *)a1;
      memset(&buf.retain, 0, 24);
      SCDynamicStoreRef v7 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:PHSStateListener", (SCDynamicStoreCallBack)sub_101121F14, &buf);
      size_t v8 = *(void **)(a1 + 112);
      *(void *)(a1 + 112) = v7;
      __p[0] = v8;
      sub_100142A3C((const void **)__p);
      if (*(void *)(a1 + 112)) {
        unsigned int v9 = sub_100142574;
      }
      else {
        unsigned int v9 = 0;
      }
      if (v9)
      {
        CFArrayRef v15 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        if (SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 112), v15, 0))
        {
          if (SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 112), *(dispatch_queue_t *)(a1 + 24)))
          {
            sub_100083EB8((const void **)(a1 + 104), (const void **)a2);
            double v10 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__p[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I fPhsStore created successfully", (uint8_t *)__p, 2u);
            }
            sub_101121AC4(a1);
            goto LABEL_27;
          }
          char v12 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
LABEL_26:
            char v14 = *(void **)(a1 + 112);
            *(void *)(a1 + 112) = 0;
            __p[0] = v14;
            sub_100142A3C((const void **)__p);
LABEL_27:
            sub_100044D00((const void **)&v15);
            return;
          }
          LOWORD(__p[0]) = 0;
          char v13 = "fPhsStore SCDynamicStoreSetDispatchQueue failed";
        }
        else
        {
          char v12 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          LOWORD(__p[0]) = 0;
          char v13 = "fPhsStore SCDynamicStoreSetNotificationKeys failed";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v13, (uint8_t *)__p, 2u);
        goto LABEL_26;
      }
      unsigned int v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "fPhsStore SCDynamicStore failed", (uint8_t *)__p, 2u);
      }
    }
  }
}

void sub_1011211B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011211E8(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101121300;
  v7[3] = &unk_101A91C38;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (uint64_t v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1011231FC;
  block[3] = &unk_101A920A8;
  block[5] = v3;
  unsigned int v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_101121300(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_101120208(&v5, v1);
  uint64_t v2 = v5;
  sub_101120488(v5, 0, 0, 0, 1, (uint64_t)"ping");
  if (capabilities::ct::supportsReportingTetheringStateToBaseband(v3))
  {
    sub_100083DA4((const void **)&v4, (const void **)(v2 + 88));
    sub_101120EB8(v1, &v4);
    sub_1000558F4((const void **)&v4);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_101121390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1011213B8(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1011214D0;
  v8[3] = &unk_101A91C58;
  v8[4] = a1;
  v8[5] = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  SCDynamicStoreRef v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1011231FC;
  block[3] = &unk_101A920A8;
  block[5] = v4;
  double v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_1011214D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    LODWORD(v6) = 136315138;
    *(void *)((char *)&v6 + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Calls to reset MIS avalibility on %s", (uint8_t *)&v6, 0xCu);
  }
  *(unsigned char *)(v2 + 80) = 0;
  long long v6 = 0uLL;
  sub_101120208(&v6, v2);
  uint64_t v5 = v6;
  if (sub_1011215E0(v6, 0))
  {
    sub_1011216A8(v5);
    sub_1011217B8(v5);
  }
  if (*((void *)&v6 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
  }
}

void sub_1011215C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

BOOL sub_1011215E0(uint64_t a1, const void *a2)
{
  if (*(void *)(a1 + 64)) {
    return 1;
  }
  uint64_t v4 = _NETRBClientCreate(*(NSObject **)(a1 + 24), a2, 0);
  *(void *)(a1 + 64) = v4;
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MIS Client attached.", v6, 2u);
    }
    return 1;
  }
  BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)SCDynamicStoreContext buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to attach to MIS Client.", buf, 2u);
    return 0;
  }
  return result;
}

void sub_1011216A8(uint64_t a1)
{
  int v13 = 0;
  int v12 = 0;
  if ((_NETRBClientGetGlobalServiceState(*(void *)(a1 + 64), &v13, &v12) & 1) == 0)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v11 = 0;
    long long v6 = "#E Failed to get MIS state.";
    SCDynamicStoreRef v7 = (uint8_t *)&v11;
    size_t v8 = v5;
    goto LABEL_11;
  }
  if (v13 == 1020)
  {
LABEL_6:
    *(unsigned char *)(a1 + 81) = 0;
    return;
  }
  char v2 = _NETRBClientSetGlobalServiceState(*(void *)(a1 + 64), 1020);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)unsigned int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Called to reset", v9, 2u);
    }
    goto LABEL_6;
  }
  if (v4)
  {
    *(_WORD *)SCDynamicStoreContext buf = 0;
    long long v6 = "#E Failed to reset MIS state.";
    SCDynamicStoreRef v7 = buf;
    size_t v8 = v3;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
  }
}

void sub_1011217B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    char v3 = _NETRBClientDestroy(v2);
    *(void *)(a1 + 64) = 0;
    BOOL v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)SCDynamicStoreContext buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MIS Client detached.", buf, 2u);
    }
    if ((v3 & 1) == 0)
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Failed to detach from MIS.", v6, 2u);
      }
    }
  }
}

void sub_101121878(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101121990;
  v7[3] = &unk_101A91C78;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (uint64_t v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  long long v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1011231FC;
  block[3] = &unk_101A920A8;
  block[5] = v3;
  unsigned int v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_101121990(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 80) = 1;
  return result;
}

void sub_1011219A0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101121AB8;
  v7[3] = &unk_101A91C98;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (uint64_t v3 = a1[1], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  long long v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1011231FC;
  block[3] = &unk_101A920A8;
  block[5] = v3;
  unsigned int v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_101121AB8(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 80) = 0;
  return result;
}

const void **sub_101121AC4(uint64_t a1)
{
  int valuePtr = 0;
  CFTypeRef cf = 0;
  uint64_t v29 = (uint64_t)SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 112), *(CFStringRef *)(a1 + 104));
  sub_100084068(&cf, (CFTypeRef *)&v29);
  if (cf) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2)
  {
    size_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return sub_100057D78(&cf);
    }
    LOWORD(v29) = 0;
    unsigned int v9 = "Cannot find PHS dictionary";
LABEL_13:
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v29, 2u);
    return sub_100057D78(&cf);
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 != CFDictionaryGetTypeID())
  {
    size_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return sub_100057D78(&cf);
    }
    LOWORD(v29) = 0;
    unsigned int v9 = "PHS dictionary of wrong type";
    goto LABEL_13;
  }
  CFTypeRef v31 = 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"InternalInterfaces");
  uint64_t v5 = Value;
  if (Value && (CFTypeID v6 = CFGetTypeID(Value), v6 == CFArrayGetTypeID()))
  {
    CFTypeRef v31 = v5;
    CFRetain(v5);
    CFArrayRef v7 = (const __CFArray *)v31;
  }
  else
  {
    CFArrayRef v7 = 0;
    CFTypeRef v31 = 0;
  }
  if (v7) {
    double v10 = sub_100083F10;
  }
  else {
    double v10 = 0;
  }
  if (!v10)
  {
    int v13 = *(NSObject **)(a1 + 40);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    int v15 = 0;
    if (!v14) {
      goto LABEL_42;
    }
    LOWORD(v29) = 0;
    unsigned int v16 = "#I Cannot find external interface in PHS dictionary";
    goto LABEL_26;
  }
  if (CFArrayGetCount(v7) > 0)
  {
    uint64_t v29 = a1;
    CFArrayRef v30 = (const __CFArray *)v31;
    if (v31)
    {
      CFRetain(v31);
      uint64_t v11 = v29;
      CFArrayRef v12 = v30;
    }
    else
    {
      CFArrayRef v12 = 0;
      uint64_t v11 = a1;
    }
    if ((sub_101121F80(v11, v12, kSCEntNetIPv4) & 1) == 0 && !sub_101121F80(v29, v30, kSCEntNetIPv6)) {
      goto LABEL_39;
    }
    CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Hosts");
    CFDictionaryRef v19 = v18;
    if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == CFDictionaryGetTypeID()) && CFDictionaryGetCount(v19))
    {
      CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(v19, @"Current");
      CFNumberRef v22 = v21;
      if (v21)
      {
        CFTypeID v23 = CFGetTypeID(v21);
        if (v23 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v22, kCFNumberIntType, &valuePtr);
LABEL_39:
          uint64_t v26 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)SCDynamicStoreContext buf = 67109120;
            int v35 = valuePtr;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I PHS: %d connected devices", buf, 8u);
          }
          sub_100044D00((const void **)&v30);
          int v15 = valuePtr;
          goto LABEL_42;
        }
      }
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      *(_WORD *)SCDynamicStoreContext buf = 0;
      unint64_t v25 = "#N No devices in PHS dictionary";
    }
    else
    {
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      *(_WORD *)SCDynamicStoreContext buf = 0;
      unint64_t v25 = "#N No hosts in PHS dictionary";
    }
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
    goto LABEL_39;
  }
  int v13 = *(NSObject **)(a1 + 40);
  BOOL v17 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  int v15 = 0;
  if (v17)
  {
    LOWORD(v29) = 0;
    unsigned int v16 = "#I external interface in PHS dictionary is empty";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v29, 2u);
    int v15 = 0;
  }
LABEL_42:
  if (*(_DWORD *)(a1 + 152) != v15)
  {
    *(_DWORD *)(a1 + 152) = v15;
    uint64_t v27 = *(void *)(a1 + 144);
    if (v27) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 48))(v27, a1 + 152);
    }
  }
  sub_100044D00(&v31);
  return sub_100057D78(&cf);
}

void sub_101121EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  CFTypeID v6 = va_arg(va1, const void *);
  sub_100044D00(v4);
  sub_100044D00((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_101121F14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v4 = *(NSObject **)(a3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I PHS DS changed", v6, 2u);
  }
  return sub_101121AC4(a3);
}

uint64_t sub_101121F80(uint64_t a1, CFArrayRef theArray, const __CFString *a3)
{
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
  if (ValueAtIndex)
  {
    CFStringRef v6 = ValueAtIndex;
    CFTypeID v7 = CFGetTypeID(ValueAtIndex);
    if (v7 == CFStringGetTypeID()) {
      CFStringRef v8 = v6;
    }
    else {
      CFStringRef v8 = 0;
    }
  }
  else
  {
    CFStringRef v8 = 0;
  }
  CFStringRef v19 = v8;
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, v8, a3);
  CFStringRef v18 = NetworkInterfaceEntity;
  if (NetworkInterfaceEntity) {
    double v10 = sub_1000810B8;
  }
  else {
    double v10 = 0;
  }
  if (!v10)
  {
    int v13 = *(NSObject **)(a1 + 40);
    uint64_t v12 = 0;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_21;
    }
    *(_WORD *)SCDynamicStoreContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N hasStateForNetworkType: no sharedIPKey", buf, 2u);
LABEL_20:
    uint64_t v12 = 0;
    goto LABEL_21;
  }
  *(void *)SCDynamicStoreContext buf = SCDynamicStoreCopyValue(*(SCDynamicStoreRef *)(a1 + 112), NetworkInterfaceEntity);
  if (*(void *)buf) {
    uint64_t v11 = sub_100080934;
  }
  else {
    uint64_t v11 = 0;
  }
  if (!v11)
  {
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v16[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N hasStateForNetworkType: no plistRef", (uint8_t *)v16, 2u);
    }
    sub_1000577C4((const void **)buf);
    goto LABEL_20;
  }
  sub_1000577C4((const void **)buf);
  uint64_t v12 = 1;
LABEL_21:
  sub_1000558F4((const void **)&v18);
  sub_1000558F4((const void **)&v19);
  return v12;
}

void sub_101122104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  CFStringRef v6 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_101122128(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)SCDynamicStoreContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========= MISService =========", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 80));
    if (*(void *)(a1 + 104)) {
      BOOL v4 = sub_1000810B8;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      long long v11 = 0uLL;
      uint64_t v12 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0uLL;
      uint64_t v10 = 0;
      uint64_t v5 = __p;
    }
    else
    {
      uint64_t v5 = (void **)"null";
    }
    if (*(void *)(a1 + 112)) {
      CFStringRef v6 = sub_100142574;
    }
    else {
      CFStringRef v6 = 0;
    }
    uint64_t v7 = asStringBool(v6 != 0);
    int v8 = *(_DWORD *)(a1 + 152);
    *(_DWORD *)SCDynamicStoreContext buf = 136315906;
    uint64_t v14 = v3;
    __int16 v15 = 2082;
    unsigned int v16 = v5;
    __int16 v17 = 2080;
    uint64_t v18 = v7;
    __int16 v19 = 1024;
    int v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fStopRetries: %s, fPhsKey: %{public}s, fPhsStore: %s, fPhsClientsSource = %d", buf, 0x26u);
    if (v4)
    {
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1011222E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_101122320(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1011223A8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011223E0(uint64_t a1)
{
}

uint64_t sub_1011223FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101122440(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10112246C(uint64_t a1)
{
  *(void *)a1 = off_101A91DD0;
  sub_1011217B8(a1);
  sub_1000558F4((const void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1011224DC(uint64_t a1)
{
  sub_10112246C(a1);

  operator delete();
}

uint64_t sub_101122514(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2 == 1001)
  {
    uint64_t v5 = *(NSObject **)(v3 + 72);
    if (v5)
    {
      CFStringRef v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication responseHandler. fCleanTimer canceled", (uint8_t *)&v14, 2u);
        uint64_t v5 = *(NSObject **)(v3 + 72);
      }
      dispatch_source_cancel(v5);
      dispatch_release(*(dispatch_object_t *)(v3 + 72));
      *(void *)(v3 + 72) = 0;
    }
    uint64_t uint64 = xpc_dictionary_get_uint64(xdict, netrbClientNotificationKey[0]);
    int v8 = *(NSObject **)(v3 + 40);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (uint64 == 5002)
    {
      if (v9)
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication Successfull", (uint8_t *)&v14, 2u);
      }
      uint64_t v10 = *(void *)(v3 + 64);
      if (v10) {
        _NETRBClientStopService(v10);
      }
    }
    else
    {
      if (v9)
      {
        int v14 = 134217984;
        uint64_t v15 = uint64;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MIS Authentication complete with notification: %lld", (uint8_t *)&v14, 0xCu);
      }
      if (uint64 == 5003 && *(unsigned char *)(v3 + 80)) {
        sub_1011228D0((void *)v3, *(unsigned char *)(v3 + 81), 0, 1, 0, (uint64_t)"Start failed with NETRB_FAILURE");
      }
    }
    sub_1011217B8(v3);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 67109120;
      LODWORD(v15) = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MIS responseHandler response: %d", (uint8_t *)&v14, 8u);
    }
    if (a2 == 1002 && *(unsigned char *)(v3 + 80)) {
      sub_1011228D0((void *)v3, *(unsigned char *)(v3 + 81), 0, 1, 0, (uint64_t)"deffered Stop");
    }
  }
  return 0;
}

uint64_t sub_101122740(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10112275C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10112276C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)SCDynamicStoreContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cleaning Time out triggered before misd finished querying.", buf, 2u);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(v2 + 72));
  dispatch_release(*(dispatch_object_t *)(v2 + 72));
  *(void *)(v2 + 72) = 0;
  uint64_t v4 = *(void *)(v2 + 64);
  if (v4)
  {
    int v5 = _NETRBClientStopService(v4);
    CFStringRef v6 = *(NSObject **)(v2 + 40);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        __int16 v13 = 0;
        int v8 = "#I MIS Stopping";
        BOOL v9 = (uint8_t *)&v13;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, v9, 2u);
      }
    }
    else if (v7)
    {
      *(_WORD *)uint64_t v12 = 0;
      int v8 = "#E MIS failed to stop";
      BOOL v9 = v12;
      goto LABEL_13;
    }
  }
  else if (*(unsigned char *)(v2 + 80))
  {
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I trying MIS again", v11, 2u);
    }
    sub_1011228D0((void *)v2, *(unsigned char *)(v2 + 81), *(unsigned char *)(a1 + 56), *(unsigned char *)(a1 + 57), *(unsigned char *)(a1 + 58), (uint64_t)"timed out");
  }
  sub_1011217B8(v2);
}

void sub_1011228D0(void *a1, char a2, char a3, char a4, char a5, uint64_t a6)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  uint8_t v12[2] = sub_1011229F8;
  v12[3] = &unk_101A91ED8;
  char v13 = a2;
  char v14 = a3;
  char v15 = a4;
  char v16 = a5;
  void v12[4] = a1;
  v12[5] = a6;
  BOOL v7 = (std::__shared_weak_count *)a1[2];
  if (!v7 || (uint64_t v8 = a1[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v10 = v9;
  long long v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101122A14;
  block[3] = &unk_101A91F00;
  block[5] = v8;
  uint64_t v18 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v11, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(v10);
}

uint64_t sub_1011229F8(uint64_t a1)
{
  return sub_101120488(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 50), *(unsigned __int8 *)(a1 + 51), *(void *)(a1 + 40));
}

uint64_t sub_101122A14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_101122A24(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101122A40(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101122A54(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101122A8C(uint64_t a1)
{
}

uint64_t sub_101122AA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101122AEC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101122B18(ServiceManager::Service *this)
{
  *(void *)this = off_101A91FA0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101122B74(ServiceManager::Service *this)
{
  *(void *)this = off_101A91FA0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_101122BE4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "mis");
}

unsigned char *sub_101122BF4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  BOOL result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101122C34(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 64))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_101122CBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101122CE0()
{
  return 0;
}

uint64_t sub_101122CE8()
{
  return 1;
}

uint64_t sub_101122CF0()
{
  return 0;
}

uint64_t sub_101122CFC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))();
}

uint64_t sub_101122D24(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80))();
}

uint64_t *sub_101122D4C(void *a1)
{
  uint64_t v1 = *a1;
  BOOL v7 = a1;
  uint64_t v8 = (dispatch_group_t *)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v3 = (void *)(v2 + 120);
  v11[0] = off_101A92020;
  v11[1] = v2 + 64;
  uint64_t v12 = v11;
  if (v11 != (void *)(v2 + 120))
  {
    uint64_t v4 = *(void **)(v2 + 144);
    if (v4 == v3)
    {
      v13[1] = v2 + 64;
      void v13[2] = 0;
      uint64_t v12 = 0;
      v13[0] = off_101A92020;
      (*(void (**)(uint64_t, void *))(*v3 + 24))(v2 + 120, v11);
      (*(void (**)(void))(**(void **)(v2 + 144) + 32))(*(void *)(v2 + 144));
      *(void *)(v2 + 144) = 0;
      uint64_t v12 = v11;
      (*(void (**)(void *, uint64_t))(v13[0] + 24))(v13, v2 + 120);
      (*(void (**)(void *))(v13[0] + 32))(v13);
    }
    else
    {
      *(void *)(v2 + 120) = off_101A92020;
      *(void *)(v2 + 128) = v2 + 64;
      uint64_t v12 = v4;
    }
    *(void *)(v2 + 144) = v3;
  }
  sub_101122320(v11);
  uint64_t v5 = *(void *)(v2 + 144);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, v2 + 152);
  }
  sub_10062AF08(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101122F60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101122FA4()
{
}

void *sub_101122FB8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = off_101A92020;
  result[1] = v3;
  return result;
}

uint64_t sub_101123000(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A92020;
  a2[1] = v2;
  return result;
}

void sub_10112302C(uint64_t a1, int *a2)
{
  xpc_object_t v2 = xpc_int64_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/phs_clients");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1011230DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_101123124(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101123164()
{
}

void sub_101123170(void **a1)
{
  BOOL v7 = a1;
  uint64_t v1 = *a1;
  xpc_object_t v2 = (void *)**a1;
  uint64_t v3 = (std::__shared_weak_count *)v2[12];
  v2[11] = 0;
  v2[12] = 0;
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (const void *)v2[14];
  v2[14] = 0;
  uint64_t v8 = v4;
  sub_100142A3C(&v8);
  char v5 = v1[1];
  if (v5)
  {
    dispatch_group_leave(v5);
    CFStringRef v6 = v1[1];
    if (v6) {
      dispatch_release(v6);
    }
  }
  operator delete();
}

uint64_t sub_1011231FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10112320C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101123228(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_101123238(void *a1, void *a2)
{
  sub_100058DB0(__p, "reg");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "reg", 0);
  *a1 = off_101A92158;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A920E8;
  return a1;
}

void sub_1011232E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101123300()
{
}

void sub_10112336C()
{
}

uint64_t sub_101123390@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 40));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v13);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 264))(v10, 1);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return 1;
}

void sub_1011234A0(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011234C0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v4 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      char v5 = a3;
    }
    else {
      char v5 = (uint64_t *)*a3;
    }
    int v6 = 136315138;
    unsigned int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its registration notification assertion", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10112356C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 40));
  char v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void))(*(void *)v10 + 264))(v10, 0);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_101123678(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10112369C(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1011236D8(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_101123710(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101123790(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011237CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101123804(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101123834(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1011239D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_101123B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_101123C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 24))(a15);
  }
  objc_destroyWeak(v16);
  if (v15) {
    dispatch_release(v15);
  }
  objc_destroyWeak((id *)(v17 - 40));
  _Unwind_Resume(a1);
}

void sub_101123CA0(uint64_t a1, uint64_t a2)
{
  WeakRetained = (NSObject ***)objc_loadWeakRetained((id *)(a1 + 32));
  unint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    char v5 = *WeakRetained[10];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Handling iCloud change notification", (uint8_t *)v6, 2u);
    }
    [v4 handleiCloudAccountEventSync:a2];
  }
}

void sub_101123D30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101123FE0()
{
}

void *sub_101123FF4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A927C8;
  result[1] = v3;
  return result;
}

uint64_t sub_10112403C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A927C8;
  a2[1] = v2;
  return result;
}

void sub_101124068(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/edu_mode");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_101124118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_101124160(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011241A0()
{
}

void sub_1011241AC(void *a1, void *a2, const char *a3)
{
}

void sub_101124368()
{
}

uint64_t sub_1011244C0(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  *xpc_object_t v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  return a1;
}

uint64_t sub_1011244F4(uint64_t result, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(result + 273))
  {
    uint64_t v5 = result;
    uint64_t v6 = result + 232;
    if (sub_101125018(result + 232, 0))
    {
      (*(void (**)(std::string *__return_ptr))(**(void **)(v5 + 192) + 8))(&buf);
      if (buf.__r_.__value_.__r.__words[0]) {
        unsigned int v7 = sub_100080934;
      }
      else {
        unsigned int v7 = 0;
      }
      sub_1000577C4((const void **)&buf.__r_.__value_.__l.__data_);
      if (v7)
      {
        uint64_t v8 = sub_100200FB4((id *)(v5 + 8));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Protocol version has changed. Will ensure we start with a new conversation", (uint8_t *)&buf, 2u);
        }

        (*(void (**)(void))(**(void **)(v5 + 192) + 16))(*(void *)(v5 + 192));
      }
      uint64_t v9 = sub_100200FB4((id *)(v5 + 8));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kV0";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Updated current protocol version to: %s", (uint8_t *)&buf, 0xCu);
      }

      sub_101125110(v6, 0);
    }
    *(unsigned char *)(v5 + 273) = 1;
    uint64_t v10 = sub_100200FB4((id *)(v5 + 8));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (a3) {
        char v11 = "yes";
      }
      else {
        char v11 = "no";
      }
      if (*(unsigned char *)(a2 + 8))
      {
        std::to_string(&buf, *(void *)a2);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)char v14 = 136315394;
        *(void *)&v14[4] = v11;
        *(_WORD *)&v14[12] = 2080;
        *(void *)&v14[14] = p_buf;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setting up conversation environment [Attempt Resume = %s][minimumRawConversationID=%s]", v14, 0x16u);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        *(_DWORD *)char v14 = 136315394;
        *(void *)&v14[4] = v11;
        *(_WORD *)&v14[12] = 2080;
        *(void *)&v14[14] = "<none>";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setting up conversation environment [Attempt Resume = %s][minimumRawConversationID=%s]", v14, 0x16u);
      }
    }

    *(void *)char v14 = 0;
    *(void *)&v14[8] = 0;
    sub_100076430(v14);
  }
  return result;
}

void sub_101124F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a21) {
    (*(void (**)(uint64_t))(*(void *)a21 + 32))(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101125018(uint64_t a1, char a2)
{
  if (!*(unsigned char *)(a1 + 18) || (a2 & 1) != 0)
  {
    *(unsigned char *)(a1 + 18) = 1;
    uint64_t v8 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(a1 + 8) + 8) + 8))(&v7);
    sub_1000842D0(&v8, &v7);
    sub_1000577C4(&v7);
    if (v8) {
      uint64_t v5 = sub_100081E58;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      LODWORD(v7) = 0;
      ctu::cf::assign((ctu::cf *)&v7, v8, v4);
      unsigned __int8 v3 = v7;
    }
    else
    {
      unsigned __int8 v3 = *(unsigned char *)(a1 + 16);
    }
    *(unsigned char *)(a1 + 17) = v3;
    sub_1000570E8((const void **)&v8);
  }
  else
  {
    return *(unsigned __int8 *)(a1 + 17);
  }
  return v3;
}

void sub_1011250EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101125110(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 18) = 1;
  *(unsigned char *)(a1 + 17) = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  CFNumberRef v9 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v9;
    CFNumberRef v9 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  uint64_t v6 = (***(uint64_t (****)(void, const void *))(v2 + 8))(*(void *)(v2 + 8), v5);
  sub_1000570E8((const void **)&v8);
  return v6;
}

void sub_1011251C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011251E8(CFDateRef *a1)
{
  if (*a1) {
    uint64_t v1 = sub_1001908E4;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    return 0;
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v6 = CFDateCreate(kCFAllocatorDefault, Current);
  double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(*a1, v6);
  sub_10007CA64((const void **)&v6);
  if (TimeIntervalSinceDate <= 0.0) {
    return 0;
  }
  else {
    return (uint64_t)(TimeIntervalSinceDate * 1000.0);
  }
}

void sub_101125294(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011252A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

uint64_t sub_1011252B0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 274))
  {
    uint64_t v2 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Most likely a duplicate ack for start", (uint8_t *)v6, 2u);
    }
LABEL_4:

    return 0;
  }
  if (!*(unsigned char *)(a1 + 273) || !*(void *)(a1 + 88) || !*(void *)(a1 + 152) || !*(void *)(a1 + 168))
  {
    uint64_t v2 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Start message was acked but conversation environment is not ready!", (uint8_t *)v6, 2u);
    }
    goto LABEL_4;
  }
  unint64_t v4 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 104);
    v6[0] = 67109376;
    v6[1] = v5;
    __int16 v7 = 2048;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Start message acked for ConversationID: %hhu [Raw: %llu]", (uint8_t *)v6, 0x12u);
  }

  uint64_t result = 1;
  *(unsigned char *)(a1 + 274) = 1;
  return result;
}

BOOL sub_101125440(uint64_t a1)
{
  return *(unsigned char *)(a1 + 273) && *(void *)(a1 + 88) && *(void *)(a1 + 152) && *(void *)(a1 + 168) != 0;
}

void sub_101125470(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 277))
  {
    if (*(unsigned char *)(a1 + 273) && *(void *)(a1 + 88) && *(void *)(a1 + 152) && *(void *)(a1 + 168))
    {
      uint64_t v2 = sub_100200FB4((id *)(a1 + 8));
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *(void *)(a1 + 104);
        LODWORD(v10) = 67109376;
        HIDWORD(v10) = v3;
        LOWORD(v11[0]) = 2048;
        *(void *)((char *)v11 + 2) = v3;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I First attempt for start was made for ConversationID: %hhu [Raw: %llu]. Persisting keys.", (uint8_t *)&v10, 0x12u);
      }

      uint64_t v4 = *(void *)(a1 + 104);
      *(unsigned char *)(a1 + 277) = 1;
      *(void *)(a1 + 112) = v4;
      *(unsigned char *)(a1 + 120) = 1;
      id v5 = objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v6 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 104)];
      uint64_t v7 = +[NSData dataWithBytes:**(void **)(a1 + 152) length:*(void *)(*(void *)(a1 + 152) + 8) - **(void **)(a1 + 152)];
      uint64_t v8 = +[NSData dataWithBytes:**(void **)(a1 + 168) length:*(void *)(*(void *)(a1 + 168) + 8) - **(void **)(a1 + 168)];
      [v5 setValue:v6 forKey:@"ConversationID"];
      [v5 setValue:v7 forKey:@"AppIncoming"];
      [v5 setValue:v8 forKey:@"AppOutgoing"];
      uint64_t v10 = 0;
      v11[0] = 0;
      sub_100076430(&v10);
    }
    CFNumberRef v9 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "First attempt for start was made but conversation environment is not ready!", (uint8_t *)&v10, 2u);
    }
  }
}

void sub_1011256F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 32))(a10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_101125768(uint64_t result, char a2)
{
  *(unsigned char *)(result + 275) = a2;
  return result;
}

void sub_101125770(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 264);
  *(_OWORD *)(a1 + 256) = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

AutoStartTimer *sub_101125790(uint64_t a1)
{
  uint64_t result = *(AutoStartTimer **)(a1 + 256);
  if (result) {
    return (AutoStartTimer *)(AutoStartTimer::isExpired(result) ^ 1);
  }
  return result;
}

uint64_t sub_1011257B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 275);
}

uint64_t sub_1011257BC(uint64_t a1)
{
  uint64_t v7 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 208) + 8))(&v6);
  sub_1000842D0(&v7, &v6);
  sub_1000577C4(&v6);
  if (v7) {
    uint64_t v2 = sub_100081E58;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    LOBYTE(v6) = 0;
    ctu::cf::assign((ctu::cf *)&v6, v7, v1);
    int v3 = v6;
    sub_1000570E8((const void **)&v7);
    int v4 = 1;
  }
  else
  {
    sub_1000570E8((const void **)&v7);
    int v3 = 0;
    int v4 = 0;
  }
  return v3 | (v4 << 8);
}

void sub_101125878(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10112589C(uint64_t a1)
{
  __int16 v1 = sub_1011257BC(a1);
  if (((v1 + 1) & 0x100) != 0) {
    unsigned __int8 v2 = 1;
  }
  else {
    unsigned __int8 v2 = v1 + 1;
  }
  if ((v1 & 0xFF00) == 0) {
    return 0;
  }
  return v2;
}

void sub_1011258D4(uint64_t a1)
{
  __int16 v2 = sub_1011257BC(a1);
  if ((_BYTE)v2 == 0xFF) {
    unsigned __int8 v3 = 1;
  }
  else {
    unsigned __int8 v3 = v2 + 1;
  }
  if ((v2 & 0xFF00) != 0) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  id v5 = +[NSNumber numberWithUnsignedShort:v4];
  (***(void (****)(void))(a1 + 208))();
}

void sub_101125988(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL sub_10112599C(uint64_t a1)
{
  id v5 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 224) + 8))(&v4);
  sub_1000842D0(&v5, &v4);
  sub_1000577C4(&v4);
  if (v5) {
    __int16 v1 = sub_100081E58;
  }
  else {
    __int16 v1 = 0;
  }
  BOOL v2 = v1 != 0;
  sub_1000570E8(&v5);
  return v2;
}

void sub_101125A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

unint64_t sub_101125A48(uint64_t a1)
{
  uint64_t v6 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 224) + 8))(&v5);
  sub_1000842D0(&v6, &v5);
  sub_1000577C4(&v5);
  if (v6) {
    BOOL v2 = sub_100081E58;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2 && (LODWORD(v5) = 0, ctu::cf::assign((ctu::cf *)&v5, v6, v1), uint64_t v3 = v5, v5))
  {
    sub_1000570E8((const void **)&v6);
    return v3 | (unint64_t)&_mh_execute_header;
  }
  else
  {
    sub_1000570E8((const void **)&v6);
    return 0;
  }
}

void sub_101125B00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_101125B24(uint64_t a1, uint64_t a2)
{
  id v3 = +[NSNumber numberWithUnsignedInt:a2];
  (***(void (****)(void))(a1 + 224))();
}

void sub_101125BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

const void **sub_101125BCC(const void **result)
{
  if (*((unsigned char *)result + 274))
  {
    CFNumberRef v1 = result;
    BOOL v2 = (id *)(result + 1);
    uint64_t v3 = (*((uint64_t (**)(const void **))*result + 8))(result);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v6 = CFDateCreate(kCFAllocatorDefault, Current + (double)v3);
    id v5 = sub_100200FB4(v2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      uint64_t v8 = v3;
      __int16 v9 = 2048;
      uint64_t v10 = v3 / 60;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Conversation resume eligiblity extended. Eligible until: %lld seconds (about %ld minutes) from now", buf, 0x16u);
    }

    (**(void (***)(const void *, CFDateRef))v1[24])(v1[24], v6);
    return sub_10007CA64((const void **)&v6);
  }
  return result;
}

void sub_101125D2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101125D4C(uint64_t *a1, char **a2)
{
  if (*((unsigned char *)a1 + 274))
  {
LABEL_2:
    uint64_t v2 = 0;
    uint64_t v3 = 1;
    return v2 & 0xF00000000 | v3;
  }
  if (*((unsigned char *)a1 + 277))
  {
    CFDateRef v6 = *a2;
    size_t v7 = a2[1] - *a2;
    uint64_t v8 = (const void *)a1[16];
    if (v7 == a1[17] - (void)v8 && !memcmp(v6, v8, v7))
    {
      __int16 v19 = sub_100200FB4((id *)a1 + 1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Newly generated app key is same as old key. No worries", buf, 2u);
      }

      goto LABEL_2;
    }
    __int16 v9 = sub_100200FB4((id *)a1 + 1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "We had attempted start message, but app key changed before we could receive ack. Will bump conversationID next time", buf, 2u);
    }

    uint64_t v3 = 0;
    uint64_t v2 = 0xA00000000;
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v24 = 0;
    uint64_t v10 = *a1;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v22 = 0;
    char v11 = (char *)(*(uint64_t (**)(uint64_t *))(v10 + 56))(a1);
    if (sub_100BCA7AC((os_log_t *)a1 + 1, v11, (uint64_t)a2, (uint64_t)buf, (uint64_t)__p))
    {
      unint64_t v12 = sub_100200FB4((id *)a1 + 1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v20 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Derived incoming and outgoing keys", v20, 2u);
      }

      unint64_t v13 = (char *)operator new(0x30uLL);
      *((void *)v13 + 1) = 0;
      *((void *)v13 + 2) = 0;
      *(void *)unint64_t v13 = off_1019B47B8;
      *(_OWORD *)(v13 + 24) = *(_OWORD *)buf;
      *((void *)v13 + 5) = v24;
      memset(buf, 0, sizeof(buf));
      uint64_t v24 = 0;
      char v14 = (std::__shared_weak_count *)a1[20];
      a1[19] = (uint64_t)(v13 + 24);
      a1[20] = (uint64_t)v13;
      if (v14) {
        sub_10004D2C8(v14);
      }
      char v15 = (char *)operator new(0x30uLL);
      *((void *)v15 + 1) = 0;
      *((void *)v15 + 2) = 0;
      *(void *)char v15 = off_1019B47B8;
      *(_OWORD *)(v15 + 24) = *(_OWORD *)__p;
      *((void *)v15 + 5) = v22;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v22 = 0;
      char v16 = (std::__shared_weak_count *)a1[22];
      a1[21] = (uint64_t)(v15 + 24);
      a1[22] = (uint64_t)v15;
      if (v16) {
        sub_10004D2C8(v16);
      }
      if (a1 + 16 != (uint64_t *)a2) {
        sub_10006E4A8(a1 + 16, *a2, a2[1], a2[1] - *a2);
      }
      uint64_t v2 = 0;
      uint64_t v3 = 1;
    }
    else
    {
      uint64_t v17 = sub_100200FB4((id *)a1 + 1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v20 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to derive incoming and outgoing keys", v20, 2u);
      }

      uint64_t v3 = 0;
      uint64_t v2 = 0x500000000;
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
  return v2 & 0xF00000000 | v3;
}

void sub_101126050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10112608C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104) | (*(unsigned __int8 *)(a1 + 272) << 8);
}

uint64_t sub_10112609C(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 104) + 1);
}

uint64_t sub_1011260AC(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t sub_1011260B8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 274)) {
    return 0;
  }
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 192) + 8))(&v3);
  sub_100201EE4(&v4, &v3);
  uint64_t v1 = sub_1011251E8((CFDateRef *)&v4);
  sub_10007CA64(&v4);
  sub_1000577C4(&v3);
  return v1;
}

void sub_101126150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_101126174(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 274);
}

uint64_t sub_10112617C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 160);
  *a2 = *(void *)(result + 152);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101126198@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 176);
  *a2 = *(void *)(result + 168);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011261B4(void *a1, uint64_t *a2)
{
  if (((*(uint64_t (**)(void *, void *))(*a1 + 80))(a1, a1 + 11) & 1) == 0)
  {
    uint64_t v5 = *a2;
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    CFDateRef v6 = (std::__shared_weak_count *)a1[12];
    a1[11] = v5;
    a1[12] = v4;
    if (v6)
    {
      sub_10004D2C8(v6);
    }
  }
}

uint64_t sub_101126240@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 96);
  *a2 = *(void *)(result + 88);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10112625C(uint64_t a1)
{
  int v2 = IOPSGetPercentRemaining();
  uint64_t v3 = sub_100200FB4((id *)(a1 + 8));
  uint64_t v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to get battery info", buf, 2u);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109634;
    int v7 = 0;
    __int16 v8 = 2080;
    __int16 v9 = "no";
    __int16 v10 = 2080;
    char v11 = "no";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Battery is: %d percent, charging: %s, fully charged: %s", buf, 0x1Cu);
  }

  return 0;
}

uint64_t sub_1011263D0()
{
  return 3;
}

uint64_t sub_1011263D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 276);
}

uint64_t sub_1011263E0(uint64_t result, char a2)
{
  *(unsigned char *)(result + 276) = a2;
  return result;
}

void sub_1011263E8(uint64_t a1)
{
  sub_1002B486C(a1);
  int v2 = (id *)(a1 + 8);
  uint64_t v3 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 274)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v24 = 136315138;
    unint64_t v25 = (void *)v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] Start acked: %s", (uint8_t *)&v24, 0xCu);
  }

  uint64_t v5 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFDateRef v6 = *(void **)(a1 + 104);
    int v24 = 134217984;
    unint64_t v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [d] Raw ConversationID: %llu", (uint8_t *)&v24, 0xCu);
  }

  int v7 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(unsigned __int8 *)(a1 + 104);
    int v24 = 67109120;
    LODWORD(v25) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [d] ConversationID: %hhu", (uint8_t *)&v24, 8u);
  }

  __int16 v9 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 272)) {
      __int16 v10 = "true";
    }
    else {
      __int16 v10 = "false";
    }
    int v24 = 136315138;
    unint64_t v25 = (void *)v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [d] Did resume conversation: %s", (uint8_t *)&v24, 0xCu);
  }

  char v11 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 275)) {
      unint64_t v12 = "true";
    }
    else {
      unint64_t v12 = "false";
    }
    int v24 = 136315138;
    unint64_t v25 = (void *)v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [d] Location update due: %s", (uint8_t *)&v24, 0xCu);
  }

  unint64_t v13 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v14 = sub_1011257BC(a1);
    if (v14 == 255) {
      int v15 = 1;
    }
    else {
      int v15 = v14 + 1;
    }
    if ((v14 & 0xFF00) == 0) {
      int v15 = 0;
    }
    int v24 = 67109120;
    LODWORD(v25) = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [d] Next loc seq num: %hhu", (uint8_t *)&v24, 8u);
  }

  char v16 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = off_101A929F8[sub_10112625C(a1)];
    int v24 = 136315138;
    unint64_t v25 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [d] Battery: %s", (uint8_t *)&v24, 0xCu);
  }

  uint64_t v18 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v19 = *(AutoStartTimer **)(a1 + 256);
    int v20 = "false";
    if (v19 && !AutoStartTimer::isExpired(v19)) {
      int v20 = "true";
    }
    int v24 = 136315138;
    unint64_t v25 = (void *)v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [d] Location update timer is running: %s", (uint8_t *)&v24, 0xCu);
  }

  unint64_t v21 = sub_101125A48(a1);
  int v22 = v21;
  if (HIDWORD(v21))
  {
    CFTypeID v23 = sub_100200FB4(v2);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = 67109120;
      LODWORD(v25) = v22;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I [d] Preferred Codec ID: %u", (uint8_t *)&v24, 8u);
    }
  }
}

void sub_101126808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_101126828(void *a1)
{
  *a1 = off_101A92848;
  int v2 = (CFTypeRef *)a1[8];
  uint64_t v3 = (CFTypeRef *)a1[9];
  while (v2 != v3)
    CFRelease(*v2++);
  uint64_t v4 = (std::__shared_weak_count *)a1[33];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = a1[30];
  a1[30] = 0;
  if (v5) {
    sub_10026CD9C((uint64_t)(a1 + 30), v5);
  }
  uint64_t v6 = a1[28];
  a1[28] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[26];
  a1[26] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[24];
  a1[24] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  __int16 v9 = (std::__shared_weak_count *)a1[22];
  if (v9) {
    sub_10004D2C8(v9);
  }
  __int16 v10 = (std::__shared_weak_count *)a1[20];
  if (v10) {
    sub_10004D2C8(v10);
  }
  char v11 = (void *)a1[16];
  if (v11)
  {
    a1[17] = v11;
    operator delete(v11);
  }
  unint64_t v12 = (std::__shared_weak_count *)a1[12];
  if (v12) {
    sub_10004D2C8(v12);
  }
  unint64_t v13 = (void *)a1[8];
  if (v13)
  {
    a1[9] = v13;
    operator delete(v13);
  }

  return sub_1002B4928(a1);
}

uint64_t sub_10112699C(uint64_t a1)
{
  *(unsigned char *)(a1 + 18) = 0;
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 8) + 16))();
}

uint64_t sub_1011269CC(uint64_t a1)
{
  return sub_101125018(a1, 1);
}

void sub_1011269D4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  *uint64_t v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

void PhoneNumberRegistrationManager::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101126F90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t object, dispatch_object_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
}

void sub_101127238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x101127214);
}

void sub_101127260()
{
}

const char *sub_101127268(int a1)
{
  if ((a1 - 1) > 2) {
    return "pnr.mgr.?";
  }
  else {
    return off_101A93210[a1 - 1];
  }
}

void sub_101127290(uint64_t a1)
{
  *(void *)a1 = off_101A92A28;
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 1896));
  sub_10005CD2C(a1 + 1872, *(char **)(a1 + 1880));
  sub_10019D5B8(a1 + 1848, *(void **)(a1 + 1856));
  sub_1000346F8(a1 + 1824, *(void **)(a1 + 1832));
  sub_100088048(a1 + 1800, *(void **)(a1 + 1808));
  sub_100087F94(a1 + 1776, *(void **)(a1 + 1784));
  sub_10019D614(a1 + 1752, *(void **)(a1 + 1760));
  sub_1000346F8(a1 + 1728, *(void **)(a1 + 1736));
  sub_100136194(a1 + 928);
  sub_100136194(a1 + 128);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100119D90(*(void **)(a1 + 96));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  PhoneNumberRegistrationInterface::~PhoneNumberRegistrationInterface((PhoneNumberRegistrationInterface *)a1);
}

void sub_1011273C0(uint64_t a1)
{
  sub_101127290(a1);

  operator delete();
}

void sub_1011273F8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011274F8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 1800);
  uint64_t v3 = (void *)(a1 + 1808);
  if (v2 != (void *)(a1 + 1808))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((BasicSimInfo::operator==() & 1) == 0)
      {
        int v7 = *((_DWORD *)v2 + 8);
        uint64_t v12 = a1;
        uint64_t v13 = (uint64_t)(v2 + 5);
        goto LABEL_17;
      }
LABEL_18:
      __int16 v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          int v15 = v14;
          __int16 v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          int v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    int v7 = *((_DWORD *)v2 + 8);
LABEL_16:
    uint64_t v13 = (uint64_t)(v2 + 5);
    uint64_t v12 = a1;
LABEL_17:
    sub_10112B164(v12, v7, v13);
    goto LABEL_18;
  }
}

void sub_1011275E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 1776);
  uint64_t v3 = (void *)(a1 + 1784);
  if (v2 != (void *)(a1 + 1784))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if ((rest::operator==() & 1) == 0) {
        break;
      }
LABEL_19:
      int v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v2[2];
          BOOL v17 = *v16 == (void)v2;
          uint64_t v2 = v16;
        }
        while (!v17);
      }
      uint64_t v2 = v16;
      if (v16 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_15:
    uint64_t v12 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
    sub_1011288A4(a1, v7);
    if ((*((unsigned char *)v2 + 40) - 1) <= 3u)
    {
      uint64_t v13 = *v12;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v19 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle updated :%s", buf, 0xCu);
      }
      sub_101127BE8(a1, v7);
    }
    goto LABEL_19;
  }
}

void sub_1011277B8(uint64_t a1)
{
}

void sub_1011277C4(uint64_t a1)
{
}

void sub_1011277D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)(a1 + 1752);
  uint64_t v3 = (void **)(a1 + 1760);
  if (v2 != (void **)(a1 + 1760))
  {
    uint64_t v6 = (void **)(a2 + 8);
    uint64_t v7 = (void *)(a1 + 96);
    while (v6 != sub_100046F68(a2, v2 + 4) && (rest::operator==() & 1) != 0)
    {
LABEL_42:
      uint64_t v29 = (void **)v2[1];
      if (v29)
      {
        do
        {
          CFArrayRef v30 = v29;
          uint64_t v29 = (void **)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          CFArrayRef v30 = (void **)v2[2];
          BOOL v27 = *v30 == v2;
          uint64_t v2 = v30;
        }
        while (!v27);
      }
      uint64_t v2 = v30;
      if (v30 == v3) {
        return;
      }
    }
    uint64_t v8 = *(void *)(a1 + 2048);
    int v9 = *(void **)v8;
    BOOL v10 = *(void **)(v8 + 8);
    if (*(void **)v8 == v10) {
      goto LABEL_14;
    }
    while (!sub_10001D294((unsigned __int8 *)(*v9 + 24), (unsigned __int8 *)v2 + 32))
    {
      v9 += 2;
      if (v9 == v10)
      {
        int v9 = v10;
        break;
      }
    }
    if (v9 == *(void **)(v8 + 8))
    {
LABEL_14:
      int v14 = 0;
      uint64_t v12 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v12 = *v9;
      uint64_t v11 = (std::__shared_weak_count *)v9[1];
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v12)
      {
        uint64_t v13 = *(unsigned int *)(v12 + 52);
        int v14 = 1;
LABEL_16:
        int v15 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
        if (v14)
        {
          uint64_t v16 = *v7;
          if (!*v7) {
            goto LABEL_27;
          }
          uint64_t v17 = *(unsigned int *)(v12 + 52);
          uint64_t v18 = v7;
          do
          {
            int v19 = *(_DWORD *)(v16 + 32);
            BOOL v20 = v19 < (int)v17;
            if (v19 >= (int)v17) {
              unint64_t v21 = (uint64_t *)v16;
            }
            else {
              unint64_t v21 = (uint64_t *)(v16 + 8);
            }
            if (!v20) {
              uint64_t v18 = (void *)v16;
            }
            uint64_t v16 = *v21;
          }
          while (*v21);
          if (v18 != v7 && (int)v17 >= *((_DWORD *)v18 + 8))
          {
            sub_101127BE8(a1, v17);
          }
          else
          {
LABEL_27:
            int v22 = *v15;
            if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid slot while handling phone number update", buf, 2u);
            }
          }
        }
        else
        {
          CFTypeID v23 = *v15;
          if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
          {
            int v24 = (void *)*((unsigned __int8 *)v2 + 55);
            BOOL v25 = (char)v24 < 0;
            if ((char)v24 < 0) {
              int v24 = v2[5];
            }
            if (v25) {
              uint64_t v26 = (const char *)v2[4];
            }
            else {
              uint64_t v26 = (const char *)(v2 + 4);
            }
            BOOL v27 = v24 == 0;
            int v28 = "<invalid>";
            if (!v27) {
              int v28 = v26;
            }
            *(_DWORD *)std::string buf = 136315138;
            int v32 = v28;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I handlePhoneNumberAvailable_sync, unknown persona '%s'", buf, 0xCu);
          }
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
        goto LABEL_42;
      }
      int v14 = 0;
    }
    uint64_t v13 = 0;
    goto LABEL_16;
  }
}

void sub_101127A78(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101127A98(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 1872);
  uint64_t v3 = (unsigned __int8 *)(a1 + 1880);
  if (v2 != (unsigned __int8 *)(a1 + 1880))
  {
    uint64_t v6 = (void **)(a2 + 8);
    do
    {
      uint64_t v7 = *(void *)(a1 + 2048);
      uint64_t v8 = *(void **)v7;
      int v9 = *(void **)(v7 + 8);
      if (*(void **)v7 != v9)
      {
        while (!sub_10001D294((unsigned __int8 *)(*v8 + 24), v2 + 32))
        {
          v8 += 2;
          if (v8 == v9)
          {
            uint64_t v8 = v9;
            break;
          }
        }
        if (v8 != *(void **)(v7 + 8))
        {
          uint64_t v11 = *v8;
          BOOL v10 = (std::__shared_weak_count *)v8[1];
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v11)
          {
            if (!*(unsigned char *)(v11 + 49))
            {
              unint64_t v12 = *((void *)v2 + 7);
              uint64_t v13 = sub_100046F68(a2, (void **)v2 + 4);
              if (v6 == v13 || ((v12 >> 1) & 1) != ((_BYTE)v13[7] & 2) >> 1) {
                sub_101127BE8(a1, *(unsigned int *)(v11 + 52));
              }
            }
          }
          if (v10) {
            sub_10004D2C8(v10);
          }
        }
      }
      int v14 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v14)
      {
        do
        {
          int v15 = v14;
          int v14 = *(unsigned __int8 **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          int v15 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v16 = *(void *)v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != v3);
  }
}

void sub_101127BD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101127BE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v6 = v5;
    uint64_t v8 = (uint64_t *)(a1 + 96);
    uint64_t v7 = *(void *)(a1 + 96);
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v9 = a1 + 96;
    do
    {
      int v10 = *(_DWORD *)(v7 + 32);
      BOOL v11 = v10 < (int)a2;
      if (v10 >= (int)a2) {
        unint64_t v12 = (uint64_t *)v7;
      }
      else {
        unint64_t v12 = (uint64_t *)(v7 + 8);
      }
      if (!v11) {
        uint64_t v9 = v7;
      }
      uint64_t v7 = *v12;
    }
    while (*v12);
    if ((uint64_t *)v9 == v8 || *(_DWORD *)(v9 + 32) > (int)a2)
    {
LABEL_12:
      uint64_t v13 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long __p = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid Slot while reading phone number.", __p, 2u);
      }
LABEL_14:
      uint64_t v14 = 0;
      goto LABEL_15;
    }
    PersonalityIdFromSlotId();
    int v22 = sub_100046F68(a1 + 1752, (void **)__p);
    if (v45 < 0) {
      operator delete(*(void **)__p);
    }
    if ((void **)(a1 + 1760) == v22 || !*((unsigned char *)v22 + 136))
    {
      int v28 = *v6;
      BOOL v29 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      uint64_t v14 = 0;
      if (!v29) {
        goto LABEL_15;
      }
      *(_WORD *)long long __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N Phone number hasn't been read", __p, 2u);
      goto LABEL_14;
    }
    CFTypeID v23 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Phone number has been read", __p, 2u);
    }
    uint64_t v24 = *(void *)(a1 + 2048);
    BOOL v25 = *(void **)v24;
    uint64_t v26 = *(void **)(v24 + 8);
    if (v25 != v26)
    {
      while (*(unsigned char *)(*v25 + 49) || *(_DWORD *)(*v25 + 52) != a2)
      {
        v25 += 2;
        if (v25 == v26) {
          goto LABEL_55;
        }
      }
    }
    if (v25 == v26)
    {
LABEL_55:
      CFTypeRef v31 = 0;
      goto LABEL_56;
    }
    uint64_t v30 = *v25;
    CFTypeRef v31 = (std::__shared_weak_count *)v25[1];
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v30)
    {
      int v32 = sub_100046F68(a1 + 1872, (void **)(v30 + 24));
      if ((void **)(a1 + 1880) == v32)
      {
        BOOL v34 = *v6;
        if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_56;
        }
        *(_WORD *)long long __p = 0;
        __int16 v36 = "#I PNR cannot be performed over Entitlements (not supported)";
        goto LABEL_77;
      }
      __int16 v33 = v32[7];
      BOOL v34 = *v6;
      BOOL v35 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      if ((v33 & 2) != 0)
      {
        if (!v35) {
          goto LABEL_61;
        }
        *(_WORD *)long long __p = 0;
        int v39 = "#I PNR can be performed over Entitlements";
        goto LABEL_60;
      }
      if (v35)
      {
        *(_WORD *)long long __p = 0;
        __int16 v36 = "#I PNR cannot be performed over Entitlements (not reachable)";
LABEL_77:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v36, __p, 2u);
      }
    }
LABEL_56:
    uint64_t v37 = *(void *)(v9 + 40);
    int v38 = *(unsigned __int8 *)(v37 + 1);
    if (*(unsigned char *)(v37 + 1))
    {
      BOOL v34 = *v6;
      if (*(unsigned char *)(v37 + 2))
      {
        if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
LABEL_61:
          uint64_t v14 = 1;
LABEL_73:
          if (v31) {
            sub_10004D2C8(v31);
          }
LABEL_15:
          uint64_t v15 = *v8;
          if (!*v8) {
            goto LABEL_25;
          }
          uint64_t v16 = a1 + 96;
          do
          {
            int v17 = *(_DWORD *)(v15 + 32);
            BOOL v18 = v17 < (int)a2;
            if (v17 >= (int)a2) {
              int v19 = (uint64_t *)v15;
            }
            else {
              int v19 = (uint64_t *)(v15 + 8);
            }
            if (!v18) {
              uint64_t v16 = v15;
            }
            uint64_t v15 = *v19;
          }
          while (*v19);
          if ((uint64_t *)v16 != v8 && *(_DWORD *)(v16 + 32) <= (int)a2)
          {
            BOOL v27 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 32);
            v27(a1, a2, v14);
          }
          else
          {
LABEL_25:
            BOOL v20 = *v4;
            if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long __p = 0;
              unint64_t v21 = "Invalid Slot while accessing fReadyState..";
LABEL_46:
              _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, __p, 2u);
              return;
            }
          }
          return;
        }
        *(_WORD *)long long __p = 0;
        int v39 = "#I PNR is allowed via SMS";
LABEL_60:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v39, __p, 2u);
        goto LABEL_61;
      }
    }
    else
    {
      BOOL v34 = *v6;
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v40 = "true";
      if (v38) {
        BOOL v41 = "true";
      }
      else {
        BOOL v41 = "false";
      }
      if (!*(unsigned char *)(v37 + 2)) {
        __int16 v40 = "false";
      }
      *(_DWORD *)long long __p = 136315394;
      *(void *)&__p[4] = v41;
      __int16 v43 = 2080;
      __int16 v44 = v40;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I PNR is not allowed via SMS. SMS online: %s Registration status:%s", __p, 0x16u);
      BOOL v34 = *v6;
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#N PNR is not allowed over Entitlements or SMS", __p, 2u);
    }
    uint64_t v14 = 0;
    goto LABEL_73;
  }
  BOOL v20 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long __p = 0;
    unint64_t v21 = "Invalid Slot while evaluating Registration state..";
    goto LABEL_46;
  }
}

void sub_101128158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10112817C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 1728);
  uint64_t v3 = (void *)(a1 + 1736);
  if (v2 != (void *)(a1 + 1736))
  {
    uint64_t v5 = (void *)(a2 + 8);
    uint64_t v6 = (uint64_t **)(a1 + 88);
    while (1)
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        break;
      }
      uint64_t v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < (int)v8;
        if (v10 >= (int)v8) {
          unint64_t v12 = (uint64_t *)v7;
        }
        else {
          unint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || (int)v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      int v13 = *((unsigned __int8 *)v2 + 32);
      if (*((unsigned __int8 *)v9 + 32) != v13) {
        goto LABEL_14;
      }
LABEL_19:
      int v17 = (void *)v2[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v2[2];
          BOOL v19 = *v18 == (void)v2;
          uint64_t v2 = v18;
        }
        while (!v19);
      }
      uint64_t v2 = v18;
      if (v18 == v3) {
        return;
      }
    }
    LOBYTE(v13) = *((unsigned char *)v2 + 32);
LABEL_14:
    int v20 = *((_DWORD *)v2 + 7);
    uint64_t v14 = sub_100584088(v6, v8, &v20);
    *((unsigned char *)v14[5] + 1) = v13;
    uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "true";
      if (!*((unsigned char *)v14[5] + 1)) {
        uint64_t v16 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      int v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I SMS Online changed :- %s", buf, 0xCu);
    }
    sub_101127BE8(a1, v8);
    goto LABEL_19;
  }
}

void sub_10112836C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(a2 + 24);
  BOOL v4 = v3 == 4 || v3 == 1;
  if (v4 && !*(unsigned char *)(*(void *)a3 + 49))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(*(void *)a3 + 49), *(Registry **)(a1 + 56));
    uint64_t v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v16 = v8;
    unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
    if (v12)
    {
      uint64_t v14 = v12[3];
      int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        if (!v14)
        {
LABEL_17:
          if ((v15 & 1) == 0) {
            sub_10004D2C8(v13);
          }
          return;
        }
LABEL_16:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 48))(v14, a3);
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    int v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
}

void sub_101128498(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011284B4(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011285AC(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = a2;
  sub_10112B8D8((uint64_t)v6, a3);
  void v6[4] = a1;
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101128748(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

BOOL sub_101128768(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10112C060;
  v7[3] = &unk_101A93110;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  unint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unsigned int v11 = sub_10005B608;
    unint64_t v12 = &unk_101A93150;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unsigned int v11 = sub_10005A8A4;
    unint64_t v12 = &unk_101A93130;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_1011288A4(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  int v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unsigned int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
LABEL_11:
      v16[0] = off_101A93180;
      v16[1] = a2;
      int v16[2] = a1;
      v16[3] = v16;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v12 + 184))(v12, a2, v16);
      sub_1001289E8(v16);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unsigned int v11 = 0;
  char v13 = 1;
  if (v12) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid Carrier bundle interface", (uint8_t *)&v15, 2u);
  }
LABEL_12:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_101128A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101128AC8(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10112C8C0;
  v7[3] = &unk_101A931F0;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_10005B608;
    uint64_t v12 = &unk_101A93150;
    char v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_10005A8A4;
    uint64_t v12 = &unk_101A93130;
    char v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_101128C04(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping PNR Param :", buf, 2u);
  }
  subscriber::makeSimSlotRange();
  uint64_t v3 = *(unsigned int **)buf;
  BOOL v4 = v36;
  if (*(unsigned int **)buf != v36)
  {
    int v5 = v37;
    while ((v5(*v3) & 1) == 0)
    {
      if (++v3 == v4)
      {
        uint64_t v3 = v4;
        break;
      }
    }
    __int16 v33 = v36;
    while (v3 != v33)
    {
      unsigned int v34 = 0;
      unsigned int v34 = *v3;
      int v6 = v34;
      uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v34);
      uint64_t v8 = sub_100584088((uint64_t **)(a1 + 88), v6, &v34);
      uint64_t v10 = v8[5];
      unsigned int v9 = (std::__shared_weak_count *)v8[6];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v11 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = "true";
        if (!*(unsigned char *)v10) {
          uint64_t v12 = "false";
        }
        *(_DWORD *)int v38 = 136315138;
        *(void *)&v38[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Ready state :- %s", v38, 0xCu);
        char v11 = *v7;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        char v13 = "true";
        if (!*((unsigned char *)v10 + 1)) {
          char v13 = "false";
        }
        *(_DWORD *)int v38 = 136315138;
        *(void *)&v38[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SMS online state :- %s", v38, 0xCu);
        char v11 = *v7;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = "true";
        if (!*((unsigned char *)v10 + 2)) {
          uint64_t v14 = "false";
        }
        *(_DWORD *)int v38 = 136315138;
        *(void *)&v38[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Registered state :- %s", v38, 0xCu);
        int v6 = v34;
      }
      PersonalityIdFromSlotId();
      char v15 = sub_100046F68(a1 + 1752, (void **)v38);
      if (v41 < 0) {
        operator delete(*(void **)v38);
      }
      os_log_t v16 = *v7;
      BOOL v17 = os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT);
      if ((void **)(a1 + 1760) == v15)
      {
        if (!v17) {
          goto LABEL_35;
        }
        *(_WORD *)int v38 = 0;
        int v20 = v16;
        unint64_t v21 = "#I Phone number :- none, sim :- none";
        uint32_t v22 = 2;
      }
      else
      {
        if (!v17) {
          goto LABEL_35;
        }
        BOOL v18 = v15 + 10;
        if (*((char *)v15 + 103) < 0) {
          BOOL v18 = (void *)*v18;
        }
        BOOL v19 = v15 + 7;
        if (*((char *)v15 + 79) < 0) {
          BOOL v19 = (void *)*v19;
        }
        *(_DWORD *)int v38 = 136315394;
        *(void *)&v38[4] = v18;
        __int16 v39 = 2080;
        __int16 v40 = v19;
        int v20 = v16;
        unint64_t v21 = "#I Phone number :- %s, sim :- %s";
        uint32_t v22 = 22;
      }
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, v38, v22);
LABEL_35:
      uint64_t v23 = *(void *)(a1 + 2048);
      uint64_t v24 = *(void **)v23;
      BOOL v25 = *(void **)(v23 + 8);
      if (v24 != v25)
      {
        while (*(unsigned char *)(*v24 + 49) || *(_DWORD *)(*v24 + 52) != v6)
        {
          v24 += 2;
          if (v24 == v25) {
            goto LABEL_46;
          }
        }
      }
      if (v24 == v25)
      {
LABEL_46:
        BOOL v27 = 0;
LABEL_47:
        int v29 = 0;
        goto LABEL_48;
      }
      uint64_t v26 = *v24;
      BOOL v27 = (std::__shared_weak_count *)v24[1];
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v26) {
        goto LABEL_47;
      }
      int v28 = sub_100046F68(a1 + 1872, (void **)(v26 + 24));
      if ((void **)(a1 + 1880) == v28) {
        goto LABEL_47;
      }
      int v29 = (*((unsigned __int8 *)v28 + 56) >> 1) & 1;
LABEL_48:
      uint64_t v30 = *v7;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeRef v31 = "true";
        if (!v29) {
          CFTypeRef v31 = "false";
        }
        *(_DWORD *)int v38 = 136315138;
        *(void *)&v38[4] = v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Entitlement reachability :- %s", v38, 0xCu);
      }
      if (v27) {
        sub_10004D2C8(v27);
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
      int v32 = v3 + 1;
      uint64_t v3 = v4;
      if (v32 != v4)
      {
        uint64_t v3 = v32;
        while ((v5(*v3) & 1) == 0)
        {
          if (++v3 == v4)
          {
            uint64_t v3 = v4;
            break;
          }
        }
      }
    }
  }
}

void sub_1011290BC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 - 105) < 0) {
    operator delete(*(void **)(v2 - 128));
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011290F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101129130(uint64_t a1)
{
}

uint64_t sub_10112914C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101129190(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011291BC(ServiceManager::Service *this)
{
  *(void *)this = off_101A92B90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101129218(ServiceManager::Service *this)
{
  *(void *)this = off_101A92B90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_101129288@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PhoneNumberRegistrationManager");
}

unsigned char *sub_101129298@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1011292D8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1011273F8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1011273F8(v4, 0);
}

uint64_t sub_10112935C()
{
  return 0;
}

uint64_t sub_101129364()
{
  return 1;
}

uint64_t sub_10112936C()
{
  return 0;
}

void sub_10112937C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101129494()
{
}

uint64_t sub_1011294A8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_1011294B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 112));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_101129538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_101129554(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v23 = a1;
  uint64_t v24 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  subscriber::makeSimSlotRange();
  int v5 = *(_DWORD **)buf;
  uint64_t v4 = v32;
  if (*(_DWORD **)buf != v32)
  {
    uint64_t v6 = v33;
    while ((v6(*v5) & 1) == 0)
    {
      if (++v5 == v4)
      {
        int v5 = v4;
        break;
      }
    }
    uint64_t v7 = v32;
    while (v5 != v7)
    {
      LODWORD(__p[0]) = 0;
      LODWORD(__p[0]) = *v5;
      int v8 = (int)__p[0];
      unsigned int v9 = (char *)operator new(0x50uLL);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)unsigned int v9 = off_101A92C50;
      *(_OWORD *)(v9 + 24) = 0u;
      *(_OWORD *)(v9 + 40) = 0u;
      *(_OWORD *)(v9 + 56) = 0u;
      *((void *)v9 + 9) = 0;
      uint64_t v10 = sub_100584088((uint64_t **)(v2 + 88), v8, __p);
      char v11 = (std::__shared_weak_count *)v10[6];
      v10[5] = (uint64_t *)(v9 + 24);
      void v10[6] = (uint64_t *)v9;
      if (v11) {
        sub_10004D2C8(v11);
      }
      uint64_t v12 = v5 + 1;
      int v5 = v4;
      if (v12 != v4)
      {
        int v5 = v12;
        while ((v6(*v5) & 1) == 0)
        {
          if (++v5 == v4)
          {
            int v5 = v4;
            break;
          }
        }
      }
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v25, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_100058DB0(__p, "/cc/props/reg_net_info1");
  char v13 = operator new(0x28uLL);
  *char v13 = off_101A92CA0;
  v13[1] = v2 + 128;
  void v13[2] = v2;
  void v13[3] = sub_1011277B8;
  v13[4] = 0;
  unsigned int v34 = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_net_info2");
  uint64_t v14 = operator new(0x28uLL);
  void *v14 = off_101A92D20;
  v14[1] = v2 + 928;
  v14[2] = v2;
  void v14[3] = sub_1011277C4;
  v14[4] = 0;
  unsigned int v34 = v14;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sms_online");
  char v15 = operator new(0x28uLL);
  *char v15 = off_101A92DA0;
  v15[1] = v2 + 1728;
  void v15[2] = v2;
  v15[3] = sub_10112817C;
  v15[4] = 0;
  unsigned int v34 = v15;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/personalized_phone_numbers");
  os_log_t v16 = operator new(0x28uLL);
  *os_log_t v16 = off_101A92E20;
  v16[1] = v2 + 1752;
  int v16[2] = v2;
  v16[3] = sub_1011277D0;
  void v16[4] = 0;
  unsigned int v34 = v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  BOOL v17 = operator new(0x28uLL);
  void *v17 = off_101A92EA0;
  v17[1] = v2 + 1776;
  v17[2] = v2;
  v17[3] = sub_1011275E8;
  v17[4] = 0;
  unsigned int v34 = v17;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_1002DA10C(v2 + 1824);
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  BOOL v18 = operator new(0x28uLL);
  *BOOL v18 = off_101A92F20;
  v18[1] = v2 + 1800;
  xpc_object_t v18[2] = v2;
  v18[3] = sub_1011274F8;
  void v18[4] = 0;
  unsigned int v34 = v18;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100D3EB10(v2 + 1848);
  sub_100058DB0(__p, "/cc/props/carrier_entitlements_reachability");
  BOOL v19 = operator new(0x28uLL);
  void *v19 = off_101A92FA0;
  v19[1] = v2 + 1872;
  v19[2] = v2;
  void v19[3] = sub_101127A98;
  void v19[4] = 0;
  unsigned int v34 = v19;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  int v20 = operator new(0x20uLL);
  void *v20 = off_101A93020;
  v20[1] = v2;
  v20[2] = sub_101128C04;
  v20[3] = 0;
  unsigned int v34 = v20;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v21 = operator new(0x20uLL);
  *unint64_t v21 = off_101A930A0;
  v21[1] = v2;
  v21[2] = sub_10112836C;
  v21[3] = 0;
  unsigned int v34 = v21;
  uint64_t v30 = 0;
  v27[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v27);
  sub_10010040C(__p);
  sub_100100388(buf);
  sub_100088C88(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_101129BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24)
{
}

void sub_101129C70(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A92C50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101129C90(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A92C50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101129CE4(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    operator delete(v2);
  }
}

void sub_101129D44()
{
}

__n128 sub_101129D58(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92CA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101129DAC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92CA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101129DE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101129E24()
{
}

void sub_101129E34()
{
}

__n128 sub_101129E48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92D20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101129E9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92D20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101129ED4(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(RegisteredNetworkInfo **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101129F50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101129F90()
{
}

void sub_101129FA0()
{
}

__n128 sub_101129FB4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92DA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10112A008(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92DA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112A040(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  unsigned int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10112A100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10112A118(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112A158()
{
}

void sub_10112A168()
{
}

__n128 sub_10112A17C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92E20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10112A1D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92E20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112A208(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  unsigned int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_1001A6D14((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10019D614((uint64_t)&v9, v10);
}

void sub_10112A2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10112A2E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112A320()
{
}

void sub_10112A330()
{
}

__n128 sub_10112A344(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92EA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10112A398(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92EA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112A3D0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  unsigned int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_10112A490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10112A4A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112A4E8()
{
}

void sub_10112A4F8()
{
}

__n128 sub_10112A50C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92F20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10112A560(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112A598(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_size = &v3->__r_.__value_.__l.__size_;
  size = (void *)v3->__r_.__value_.__l.__size_;
  BOOL v18 = (void **)v3->__r_.__value_.__r.__words[0];
  BOOL v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    std::string::size_type *p_size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    BOOL v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  uint64_t v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      int v8 = (void **)v6[1];
      unsigned int v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          int v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          unsigned int v9 = (void ***)v6;
        }
        while (!v10);
      }
      char v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          char v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  char v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  char v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    char v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  BOOL v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_10112A75C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10112A7A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112A7E4()
{
}

void sub_10112A7F4()
{
}

__n128 sub_10112A808(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A92FA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10112A85C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A92FA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112A894(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  unsigned int v9 = (char **)*v3;
  BOOL v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_10112A9B8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_10112A954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10112A96C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112A9AC()
{
}

void sub_10112A9B8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v12, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v11, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v13; i != v11[1] || v12 != v11[0]; uint64_t i = ++v13)
    {
      xpc_object_t v10 = 0;
      object[0] = &v12;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v10);
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v9 = 0;
        *(_OWORD *)xpc_object_t object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v10;
        if (v10) {
          xpc_retain(v10);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10112AC64((uint64_t)object, &v6);
        xpc_release(v6);
        sub_10112ADAC((uint64_t **)a1, object, (uint64_t)object);
        if (SBYTE7(v8) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v10);
    }
    xpc_release(v12);
    xpc_release(v12);
  }
  xpc_release(v3);
}

void sub_10112ABC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v21 - 48));
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void sub_10112AC64(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v7 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v7 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = &v7;
    uint64_t v5 = "first";
    sub_100048BAC((uint64_t)&v4, &object);
    read_rest_value();
    xpc_release(object);
    uint64_t v4 = &v7;
    uint64_t v5 = "second";
    sub_100048BAC((uint64_t)&v4, &object);
    sub_1003B6CB0((void *)(a1 + 24), &object);
    xpc_release(object);
    xpc_object_t v3 = v7;
  }
  xpc_release(v3);
}

void sub_10112AD58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t *sub_10112ADAC(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_10112AE38((uint64_t)a1, a3, v7);
    sub_100046C38(a1, v8, v5, v7[0]);
    return v7[0];
  }
  return result;
}

__n128 sub_10112AE38@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  xpc_object_t v7 = (char *)operator new(0x48uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t v8 = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v7 + 56) = result;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10112AED0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_10112AEF0()
{
}

__n128 sub_10112AF04(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A93020;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10112AF58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A93020;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10112AF90(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10112AFD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112B018()
{
}

void sub_10112B028()
{
}

__n128 sub_10112B03C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A930A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10112B090(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A930A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10112B0C8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  xpc_object_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_10112B118(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112B158()
{
}

void sub_10112B164(uint64_t a1, int a2, uint64_t a3)
{
  int v21 = a2;
  xpc_object_t v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    xpc_object_t v7 = sub_100584088((uint64_t **)(a1 + 88), a2, &v21);
    uint64_t v8 = v7[5];
    uint64_t v9 = (std::string *)(v8 + 1);
    uint64_t v10 = *((unsigned __int8 *)v8 + 31);
    size_t v11 = v8[2];
    if ((v10 & 0x80u) == 0) {
      uint64_t v12 = *((unsigned __int8 *)v8 + 31);
    }
    else {
      uint64_t v12 = v8[2];
    }
    uint64_t v13 = *(unsigned __int8 *)(a3 + 119);
    int v14 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(a3 + 104);
    }
    if (v12 == v13)
    {
      if (v14 >= 0) {
        char v15 = (unsigned __int8 *)(a3 + 96);
      }
      else {
        char v15 = *(unsigned __int8 **)(a3 + 96);
      }
      if ((v10 & 0x80) != 0)
      {
        if (!memcmp(v9->__r_.__value_.__l.__data_, v15, v11)) {
          return;
        }
      }
      else
      {
        if (!v10) {
          return;
        }
        for (uint64_t i = v9; i->__r_.__value_.__s.__data_[0] == *v15; uint64_t i = (std::string *)((char *)i + 1))
        {
          ++v15;
          if (!--v10) {
            return;
          }
        }
      }
    }
    std::string::operator=(v9, (const std::string *)(a3 + 96));
    BOOL v18 = *v6;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v19 = v7[5];
      std::string::size_type v20 = v19 + 1;
      if (*((char *)v19 + 31) < 0) {
        std::string::size_type v20 = (void *)*v20;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v23 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Updating IMSI :- %s", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v17 = *v6;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid slot while handling sim update", buf, 2u);
    }
  }
}

void sub_10112B350(void **a1)
{
  uint64_t v1 = (void **)**a1;
  int v3 = *((unsigned __int8 *)*a1 + 12);
  unsigned int v12 = *((_DWORD *)*a1 + 2);
  uint64_t v2 = v12;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void *, void))(*v1[6] + 16))(v1[6], v12);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v5 = sub_100584088(v1 + 11, v12, &v12);
    xpc_object_t v6 = v5[5];
    int v7 = *(unsigned __int8 *)v6;
    if (v7 != v3)
    {
      uint64_t v8 = *v4;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = "true";
        if (v7) {
          uint64_t v10 = "true";
        }
        else {
          uint64_t v10 = "false";
        }
        if (!v3) {
          uint64_t v9 = "false";
        }
        *(_DWORD *)std::string buf = 136315394;
        int v14 = v10;
        __int16 v15 = 2080;
        long long v16 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N PNR state is changing from %s to %s", buf, 0x16u);
        xpc_object_t v6 = v5[5];
      }
      *(unsigned char *)xpc_object_t v6 = v3;
      (*(void (**)(void *, uint64_t, BOOL))(*v1[9] + 320))(v1[9], v2, v3 != 0);
    }
  }
  else
  {
    size_t v11 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid slot context while sending Ready Notification", buf, 2u);
    }
  }
  operator delete();
}

void sub_10112B550()
{
}

uint64_t *sub_10112B57C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string::size_type v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  sub_100083DA4(&v22, (const void **)(v1 + 16));
  int v26 = v3;
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    int v14 = *v4;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_35;
    }
    *(_WORD *)std::string buf = 0;
    __int16 v15 = "Invalid slot context while reading Carrier Name";
LABEL_27:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    goto LABEL_35;
  }
  if (!v22)
  {
    int v14 = *v4;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_35;
    }
    *(_WORD *)std::string buf = 0;
    __int16 v15 = "Invalid Carrier bundle name";
    goto LABEL_27;
  }
  memset(&__str, 0, sizeof(__str));
  memset(buf, 0, sizeof(buf));
  uint64_t v28 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v24 = v28;
  if (v28 >= 0) {
    uint64_t v5 = (char *)__p;
  }
  else {
    uint64_t v5 = (char *)__p[0];
  }
  sub_100058DB0(&__str, v5);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v6 = sub_100584088((uint64_t **)(v2 + 88), v3, &v26);
  int v7 = v6[5];
  uint64_t v8 = (std::string *)(v7 + 4);
  uint64_t v9 = *((unsigned __int8 *)v7 + 55);
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = *((unsigned __int8 *)v7 + 55);
  }
  else {
    uint64_t v10 = v7[5];
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (v10 != size) {
    goto LABEL_29;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v9 & 0x80) != 0)
  {
    if (!memcmp(v8->__r_.__value_.__l.__data_, p_str, v7[5])) {
      goto LABEL_33;
    }
LABEL_29:
    std::string::operator=(v8, &__str);
    long long v16 = *v4;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = v6[5];
      BOOL v18 = v17 + 4;
      if (*((char *)v17 + 55) < 0) {
        BOOL v18 = (void *)*v18;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Carrier Name updated :- %s", buf, 0xCu);
    }
    goto LABEL_33;
  }
  if (*((unsigned char *)v7 + 55))
  {
    uint64_t v13 = (unsigned __int8 *)(v7 + 4);
    while (*v13 == p_str->__r_.__value_.__s.__data_[0])
    {
      ++v13;
      p_str = (std::string *)((char *)p_str + 1);
      if (!--v9) {
        goto LABEL_33;
      }
    }
    goto LABEL_29;
  }
LABEL_33:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_35:
  sub_1000558F4(&v22);
  sub_10112B888(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_10112B824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a12);
  sub_10112B888(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10112B888(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_10112B8D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_10112B970(unsigned int **a1)
{
  uint64_t v1 = *a1;
  char v41 = a1;
  char v42 = v1;
  uint64_t v2 = *((void *)v1 + 5);
  uint64_t v3 = *v1;
  sub_10112B8D8((uint64_t)v52, (uint64_t)(v1 + 2));
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  uint64_t v5 = *(void *)(v2 + 2048);
  xpc_object_t v6 = *(void **)v5;
  int v7 = *(void **)(v5 + 8);
  if (v6 != v7)
  {
    while (*(unsigned char *)(*v6 + 49) || *(_DWORD *)(*v6 + 52) != v3)
    {
      v6 += 2;
      if (v6 == v7) {
        goto LABEL_23;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_23:
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v9 = *v6;
    uint64_t v8 = (std::__shared_weak_count *)v6[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v9)
    {
      if (subscriber::isValidSimSlot())
      {
        uint64_t v10 = *(void *)(v2 + 96);
        if (v10)
        {
          uint64_t v11 = v2 + 96;
          do
          {
            int v12 = *(_DWORD *)(v10 + 32);
            BOOL v13 = v12 < (int)v3;
            if (v12 >= (int)v3) {
              int v14 = (uint64_t *)v10;
            }
            else {
              int v14 = (uint64_t *)(v10 + 8);
            }
            if (!v13) {
              uint64_t v11 = v10;
            }
            uint64_t v10 = *v14;
          }
          while (*v14);
          if (v11 != v2 + 96 && *(_DWORD *)(v11 + 32) <= (int)v3)
          {
            __int16 v15 = sub_100046F68(v2 + 1752, (void **)(v9 + 24));
            uint64_t v51 = 0;
            *(_OWORD *)xpc_object_t v49 = 0u;
            long long v50 = 0u;
            memset(__dst, 0, sizeof(__dst));
            if ((void **)(v2 + 1760) == v15)
            {
              int v16 = 0;
            }
            else
            {
              sub_100897414((char *)__dst, (long long *)(v15 + 7));
              int v16 = v51;
            }
            std::string::size_type v20 = *(unsigned __int8 **)(v11 + 40);
            int v21 = *v20;
            v46[0] = 0;
            v46[1] = 0;
            uint64_t v47 = 0;
            uint64_t v22 = *(void *)(v2 + 1856);
            if (v22)
            {
              uint64_t v23 = v2 + 1856;
              do
              {
                int v24 = *(_DWORD *)(v22 + 32);
                BOOL v25 = v24 < (int)v3;
                if (v24 >= (int)v3) {
                  int v26 = (uint64_t *)v22;
                }
                else {
                  int v26 = (uint64_t *)(v22 + 8);
                }
                if (!v25) {
                  uint64_t v23 = v22;
                }
                uint64_t v22 = *v26;
              }
              while (*v26);
              if (v23 != v2 + 1856 && *(_DWORD *)(v23 + 32) <= (int)v3)
              {
                memset(buf, 0, 64);
                MCCAndMNC::MCCAndMNC();
                MCCAndMNC::getStringValue((uint64_t *)v44, (MCCAndMNC *)buf);
                if (SHIBYTE(v47) < 0) {
                  operator delete(v46[0]);
                }
                *(_OWORD *)BOOL v46 = *(_OWORD *)v44;
                uint64_t v47 = v45;
                if ((buf[63] & 0x80000000) != 0) {
                  operator delete(*(void **)&buf[40]);
                }
                if ((buf[31] & 0x80000000) != 0) {
                  operator delete(*(void **)&buf[8]);
                }
                std::string::size_type v20 = *(unsigned __int8 **)(v11 + 40);
              }
            }
            if (v16) {
              BOOL v27 = v21 == 0;
            }
            else {
              BOOL v27 = 1;
            }
            char v28 = !v27;
            buf[0] = v28;
            if ((char)v20[31] < 0)
            {
              sub_10004FC84(&buf[8], *((void **)v20 + 1), *((void *)v20 + 2));
              std::string::size_type v20 = *(unsigned __int8 **)(v11 + 40);
            }
            else
            {
              long long v29 = *(_OWORD *)(v20 + 8);
              *(void *)&uint8_t buf[24] = *((void *)v20 + 3);
              *(_OWORD *)&uint8_t buf[8] = v29;
            }
            sub_1000292E0((uint64_t)v44);
            uint64_t v30 = v20[55];
            if ((v30 & 0x80u) == 0) {
              CFTypeRef v31 = (void *)v20[55];
            }
            else {
              CFTypeRef v31 = (void *)*((void *)v20 + 5);
            }
            int v32 = (void *)HIBYTE(v45);
            int v33 = SHIBYTE(v45);
            if (v45 < 0) {
              int v32 = v44[1];
            }
            if (v31 != v32) {
              goto LABEL_85;
            }
            unsigned int v34 = (const void **)(v20 + 32);
            if (v45 >= 0) {
              BOOL v35 = v44;
            }
            else {
              BOOL v35 = (void **)v44[0];
            }
            if ((v30 & 0x80) != 0)
            {
              if (memcmp(*v34, v35, *((void *)v20 + 5))) {
                goto LABEL_85;
              }
            }
            else if (v20[55])
            {
              while (*(unsigned __int8 *)v34 == *(unsigned __int8 *)v35)
              {
                unsigned int v34 = (const void **)((char *)v34 + 1);
                BOOL v35 = (void **)((char *)v35 + 1);
                if (!--v30) {
                  goto LABEL_81;
                }
              }
              goto LABEL_85;
            }
LABEL_81:
            __int16 v36 = (void *)HIBYTE(v47);
            char v37 = HIBYTE(v47);
            if (v47 < 0) {
              __int16 v36 = v46[1];
            }
            if (v36)
            {
              int v38 = v46;
              goto LABEL_86;
            }
LABEL_85:
            uint64_t v39 = *(void *)(v11 + 40);
            int v38 = (void **)(v39 + 32);
            char v37 = *(unsigned char *)(v39 + 55);
LABEL_86:
            if (v37 < 0)
            {
              sub_10004FC84(&buf[32], *v38, (unint64_t)v38[1]);
            }
            else
            {
              long long v40 = *(_OWORD *)v38;
              *(void *)&buf[48] = v38[2];
              *(_OWORD *)&uint8_t buf[32] = v40;
            }
            if (SHIBYTE(__dst[2]) < 0)
            {
              sub_10004FC84(&buf[56], *((void **)&__dst[1] + 1), *(unint64_t *)&__dst[2]);
            }
            else
            {
              *(_OWORD *)&buf[56] = *(_OWORD *)((char *)&__dst[1] + 8);
              *(void *)&buf[72] = *((void *)&__dst[2] + 1);
            }
            if (SBYTE7(__dst[1]) < 0)
            {
              sub_10004FC84(&buf[80], *(void **)&__dst[0], *((unint64_t *)&__dst[0] + 1));
            }
            else
            {
              *(_OWORD *)&buf[80] = __dst[0];
              *(void *)&buf[96] = *(void *)&__dst[1];
            }
            if (!v53) {
              sub_10007B600();
            }
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v53 + 48))(v53, buf);
            if ((buf[103] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[80]);
            }
            if ((buf[79] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[56]);
            }
            if ((buf[55] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[32]);
            }
            if ((buf[31] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[8]);
            }
            if (v33 < 0) {
              operator delete(v44[0]);
            }
            if (SHIBYTE(v47) < 0) {
              operator delete(v46[0]);
            }
            if (SHIBYTE(v50) < 0) {
              operator delete(v49[1]);
            }
            if (SHIBYTE(__dst[2]) < 0) {
              operator delete(*((void **)&__dst[1] + 1));
            }
            if (SBYTE7(__dst[1]) < 0)
            {
              BOOL v18 = *(void **)&__dst[0];
              goto LABEL_35;
            }
            goto LABEL_36;
          }
        }
      }
    }
  }
  uint64_t v17 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid Slot while reading PNR context", buf, 2u);
  }
  buf[0] = 0;
  memset(&buf[8], 0, 96);
  if (!v53) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v53 + 48))(v53, buf);
  if ((buf[103] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[80]);
  }
  if ((buf[79] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[56]);
  }
  if ((buf[55] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[32]);
  }
  if ((buf[31] & 0x80000000) != 0)
  {
    BOOL v18 = *(void **)&buf[8];
LABEL_35:
    operator delete(v18);
  }
LABEL_36:
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_1003BEA1C(v52);
  sub_10112C010((uint64_t *)&v42);
  return sub_100046B58((uint64_t *)&v41);
}

void sub_10112BF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,char a45)
{
  sub_10013C44C((uint64_t)&a11);
  if (a43 < 0) {
    operator delete(__p);
  }
  sub_10019693C((uint64_t)&a45);
  if (v45) {
    sub_10004D2C8(v45);
  }
  sub_1003BEA1C((void *)(v46 - 104));
  sub_10112C010(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10112C010(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1003BEA1C((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10112C060(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *v1[1];
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**((void **)*v1 + 6) + 16))(*((void *)*v1 + 6), v3);
  if (!subscriber::isValidSimSlot()) {
    goto LABEL_12;
  }
  uint64_t v5 = *((void *)v2 + 12);
  if (!v5) {
    goto LABEL_12;
  }
  xpc_object_t v6 = v2 + 24;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < (int)v3;
    if (v7 >= (int)v3) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      xpc_object_t v6 = (unsigned int *)v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == v2 + 24 || (int)v6[8] > (int)v3)
  {
LABEL_12:
    uint64_t v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int16 v55 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Slot while checking phone number credential validity.", v55, 2u);
    }
    return 0;
  }
  uint64_t v13 = *((void *)v2 + 226);
  if (!v13) {
    goto LABEL_26;
  }
  int v14 = v2 + 452;
  do
  {
    int v15 = *(_DWORD *)(v13 + 32);
    BOOL v16 = v15 < (int)v3;
    if (v15 >= (int)v3) {
      uint64_t v17 = (uint64_t *)v13;
    }
    else {
      uint64_t v17 = (uint64_t *)(v13 + 8);
    }
    if (!v16) {
      int v14 = (unsigned int *)v13;
    }
    uint64_t v13 = *v17;
  }
  while (*v17);
  if (v14 == v2 + 452 || (int)v14[8] > (int)v3)
  {
LABEL_26:
    os_log_t v18 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    *(_WORD *)__int16 v55 = 0;
    xpc_object_t v49 = "Invalid Slot for sims property";
    long long v50 = v18;
    uint32_t v51 = 2;
LABEL_76:
    _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, v49, v55, v51);
    goto LABEL_27;
  }
  if (v14[12] != 5)
  {
    os_log_t v48 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    *(_DWORD *)__int16 v55 = 136315138;
    *(void *)&v55[4] = subscriber::asString();
    xpc_object_t v49 = "Invalid Sim state :%s";
    long long v50 = v48;
    uint32_t v51 = 12;
    goto LABEL_76;
  }
  for (uint64_t i = (_DWORD *)*((void *)v14 + 7); i != *((_DWORD **)v14 + 8); ++i)
  {
    if ((*i - 4) >= 0xFFFFFFFD)
    {
      dispatch_source_t v54 = *v4;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int16 v55 = 136315138;
        *(void *)&v55[4] = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Valid Sim App present :%s", v55, 0xCu);
      }
      uint64_t v11 = subscriber::isSimUnreadable() ^ 1;
      int v20 = 1;
      goto LABEL_30;
    }
  }
LABEL_27:
  BOOL v19 = *v4;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int16 v55 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No valid sim card is present", v55, 2u);
  }
  int v20 = 0;
  uint64_t v11 = 0;
LABEL_30:
  int v21 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), v3);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *((Registry **)v2 + 7));
  int v24 = ServiceMap;
  if (v25 < 0)
  {
    int v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(ServiceMap);
  *(void *)__int16 v55 = v25;
  long long v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)v55);
  if (v29)
  {
    uint64_t v31 = v29[3];
    uint64_t v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      if (!v31) {
        goto LABEL_36;
      }
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v24);
  uint64_t v30 = 0;
  char v32 = 1;
  if (!v31)
  {
LABEL_36:
    int v33 = *v21;
    uint64_t v11 = 0;
    if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v55 = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Missing ActivationInterface", v55, 2u);
      uint64_t v11 = 0;
    }
    goto LABEL_61;
  }
LABEL_40:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 64))(v31))
  {
    uint64_t v11 = v20 & v11;
    os_log_t v34 = *v21;
    if (!os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    BOOL v35 = "false";
    if (v11) {
      BOOL v35 = "true";
    }
    *(_DWORD *)__int16 v55 = 136315138;
    *(void *)&v55[4] = v35;
    __int16 v36 = "#I UIM is required, phone calls allowed = %s";
    char v37 = v34;
    uint32_t v38 = 12;
    goto LABEL_60;
  }
  uint64_t v39 = *((void *)v2 + 229);
  if (!v39) {
    goto LABEL_55;
  }
  long long v40 = v2 + 458;
  do
  {
    int v41 = *(_DWORD *)(v39 + 28);
    BOOL v42 = v41 < (int)v3;
    if (v41 >= (int)v3) {
      __int16 v43 = (uint64_t *)v39;
    }
    else {
      __int16 v43 = (uint64_t *)(v39 + 8);
    }
    if (!v42) {
      long long v40 = (unsigned int *)v39;
    }
    uint64_t v39 = *v43;
  }
  while (*v43);
  if (v40 == v2 + 458 || (int)v40[7] > (int)v3 || *((unsigned char *)v40 + 32) != 2)
  {
LABEL_55:
    uint64_t v11 = v20 & v11;
    os_log_t v44 = *v21;
    if (!os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    uint64_t v45 = asString();
    uint64_t v46 = "false";
    if (v11) {
      uint64_t v46 = "true";
    }
    *(_DWORD *)__int16 v55 = 136315394;
    *(void *)&v55[4] = v46;
    __int16 v56 = 2080;
    uint64_t v57 = v45;
    __int16 v36 = "#I UIM is not required, not service provisioned, phone calls allowed = %s Baseband provisioned state = %s";
    goto LABEL_59;
  }
  os_log_t v44 = *v21;
  if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = asString();
    uint64_t v53 = "false";
    if (v11) {
      uint64_t v53 = "true";
    }
    *(_DWORD *)__int16 v55 = 136315394;
    *(void *)&v55[4] = v53;
    __int16 v56 = 2080;
    uint64_t v57 = v52;
    __int16 v36 = "#I UIM is not required, phone calls allowed = %s Baseband provisioned state = %s";
LABEL_59:
    char v37 = v44;
    uint32_t v38 = 22;
LABEL_60:
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v36, v55, v38);
  }
LABEL_61:
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  return v11;
}

void sub_10112C638(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10112C674()
{
}

__n128 sub_10112C688(uint64_t a1)
{
  char v2 = (char *)operator new(0x18uLL);
  *(void *)char v2 = off_101A93180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10112C6D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A93180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10112C704(uint64_t a1, const void **a2)
{
  char v2 = *a2;
  xpc_object_t v6 = v2;
  int v7 = v2;
  *a2 = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    CFRetain(v2);
    uint64_t v8 = v3;
    int v9 = v4;
    uint64_t v10 = v2;
    CFRetain(v2);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    int v9 = v4;
    uint64_t v10 = 0;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10112C874(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10112C8B4()
{
}

BOOL sub_10112C8C0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  char v2 = *v1;
  uint64_t v3 = *v1[1];
  int v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**((void **)*v1 + 6) + 16))(*((void *)*v1 + 6), v3);
  if (subscriber::isValidSimSlot())
  {
    int v7 = (unsigned int *)*((void *)v2 + 12);
    xpc_object_t v6 = v2 + 24;
    uint64_t v5 = v7;
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v8 = v6;
    int v9 = (unsigned int **)v5;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < (int)v3;
      if (v10 >= (int)v3) {
        int v12 = v9;
      }
      else {
        int v12 = v9 + 1;
      }
      if (!v11) {
        uint64_t v8 = (unsigned int *)v9;
      }
      int v9 = (unsigned int **)*v12;
    }
    while (*v12);
    if (v8 != v6 && (int)v8[8] <= (int)v3)
    {
      while (1)
      {
        while (1)
        {
          int v16 = v5[8];
          if (v16 <= (int)v3) {
            break;
          }
          uint64_t v5 = *(unsigned int **)v5;
          if (!v5) {
            goto LABEL_20;
          }
        }
        if (v16 >= (int)v3) {
          return **((unsigned char **)v5 + 5) != 0;
        }
        uint64_t v5 = (unsigned int *)*((void *)v5 + 1);
        if (!v5) {
LABEL_20:
        }
          sub_1000C14F0("map::at:  key not found");
      }
    }
    else
    {
LABEL_12:
      uint64_t v13 = *v4;
      BOOL result = os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR);
      if (result)
      {
        __int16 v17 = 0;
        int v15 = (uint8_t *)&v17;
LABEL_24:
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid Slot. Unable to get Registration state.", v15, 2u);
        return 0;
      }
    }
  }
  else
  {
    uint64_t v13 = *v4;
    BOOL result = os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)std::string buf = 0;
      int v15 = buf;
      goto LABEL_24;
    }
  }
  return result;
}

void sub_10112CA30(uint64_t a1)
{
  *(void *)a1 = off_101A93238;
  uint64_t v3 = (void **)(a1 + 24);
  sub_100465E6C(&v3);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    sub_100206334(a1 + 16, v2);
  }
  sub_100110A40((void ***)(a1 + 8), 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_10112CAB0(uint64_t a1)
{
  sub_10112CA30(a1);

  operator delete();
}

uint64_t sub_10112CAE8(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  xpc_object_t v6 = *(uint64_t **)(a1 + 24);
  int v7 = *(uint64_t **)(a1 + 32);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "pendingProfile");
  }
  if (*(unsigned char *)(a1 + 52)) {
    PB::TextFormatter::format(this, "status", *(_DWORD *)(a1 + 48));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10112CBD4(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_21:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_26:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        sub_100A0D440();
      case 3u:
        *(unsigned char *)(a1 + 52) |= 1u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 <= 0xFFFFFFFFFFFFFFF5 && v23 + 10 <= v24)
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          do
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              goto LABEL_48;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
          }
          while (!v14);
LABEL_44:
          LODWORD(v28) = 0;
          goto LABEL_48;
        }
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v28 = 0;
        if (v24 <= v23) {
          unint64_t v24 = *((void *)this + 1);
        }
        break;
      case 4u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v24 == v23)
      {
        LODWORD(v28) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_48;
      }
      unint64_t v33 = v23 + 1;
      char v34 = *(unsigned char *)(v25 + v23);
      *((void *)this + 1) = v33;
      v28 |= (unint64_t)(v34 & 0x7F) << v31;
      if ((v34 & 0x80) == 0) {
        break;
      }
      v31 += 7;
      unint64_t v23 = v33;
      BOOL v14 = v32++ > 8;
      if (v14) {
        goto LABEL_44;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v28) = 0;
    }
LABEL_48:
    *(_DWORD *)(a1 + 48) = v28;
    goto LABEL_21;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_10112CF70(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Base ***)(v3 + 24);
  xpc_object_t v6 = *(const PB::Base ***)(v3 + 32);
  while (v5 != v6)
  {
    int v7 = *v5++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 2u);
  }
  if (*(unsigned char *)(v3 + 52)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 48), 3u);
  }
  if (*(void *)(v3 + 16))
  {
    return PB::Writer::write();
  }
  return result;
}

void sub_10112D018()
{
  memset(v2, 0, sizeof(v2));
  sub_100058DB0(v2, "{\"sharedData\": { \"deviceSpecifics\": { \"deviceModel\": \"X\", \"platformVersion\": \"iOS\", \"clientVendor\": \"Apple\", \"clientVersion\": \"Apple\", \"batteryRemainingMinutes\": __battery__ } }}");
  memset(&v1, 0, sizeof(v1));
  sub_10056D028(&v0, "__battery__", 0);
}

void sub_10112D7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,std::locale a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x207]) < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a19);
  if (a70 < 0) {
    operator delete(a65);
  }
  if (a72 < 0) {
    operator delete(a71);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10112D89C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1 + 32;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v6 + 8);
  uint64_t v9 = a2 + 32;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(v9 + 8);
  BOOL v10 = v8 == v7 && v5 == v4;
  if (v5 != v4 && v8 != v7) {
    return *(void *)a1 == *(void *)a2
  }
        && *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && sub_10112DC34(v4, v7) == 0;
  return v10;
}

void sub_10112D934(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, char a5)
{
  char v5 = a5;
  uint64_t v10 = a4[6];
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
  char v13 = *(char **)a1;
  unint64_t v12 = *(char **)(a1 + 8);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v12[-*(void *)a1] >> 3);
  unint64_t v15 = v11 - v14;
  if (v11 <= v14)
  {
    uint64_t v22 = *(char **)(a1 + 8);
    if (v11 >= v14) {
      goto LABEL_24;
    }
    uint64_t v22 = &v13[8 * ((a4[1] - *a4) >> 3)];
    goto LABEL_20;
  }
  uint64_t v16 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v12) >> 3) >= v15)
  {
    uint64_t v22 = &v12[24 * v15];
    uint64_t v27 = 8 * ((a4[1] - *a4) >> 3) - 8 * ((uint64_t)&v12[-*(void *)a1] >> 3);
    do
    {
      *(void *)unint64_t v12 = 0;
      *((void *)v12 + 1) = 0;
      v12[16] = 0;
      v12 += 24;
      v27 -= 24;
    }
    while (v27);
LABEL_20:
    *(void *)(a1 + 8) = v22;
    goto LABEL_24;
  }
  if (v11 > 0xAAAAAAAAAAAAAAALL) {
    sub_10006A748();
  }
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v13) >> 3);
  unint64_t v18 = 0x5555555555555556 * ((v16 - (uint64_t)v13) >> 3);
  if (v18 <= v11) {
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
  }
  if (v17 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v18;
  }
  if (v19 > 0xAAAAAAAAAAAAAAALL) {
    sub_10006A7CC();
  }
  unint64_t v20 = (char *)operator new(24 * v19);
  int v21 = &v20[24 * v14];
  uint64_t v22 = &v20[24 * v11];
  unint64_t v23 = v21;
  uint64_t v24 = 24 * v11 - 24 * v14;
  do
  {
    *(void *)unint64_t v23 = 0;
    *((void *)v23 + 1) = 0;
    v23[16] = 0;
    v23 += 24;
    v24 -= 24;
  }
  while (v24);
  uint64_t v25 = &v20[24 * v19];
  if (v12 == v13)
  {
    char v5 = a5;
  }
  else
  {
    char v5 = a5;
    do
    {
      long long v26 = *(_OWORD *)(v12 - 24);
      *((void *)v21 - 1) = *((void *)v12 - 1);
      *(_OWORD *)(v21 - 24) = v26;
      v21 -= 24;
      v12 -= 24;
    }
    while (v12 != v13);
    unint64_t v12 = v13;
  }
  *(void *)a1 = v21;
  *(void *)(a1 + 8) = v22;
  *(void *)(a1 + 16) = v25;
  if (v12)
  {
    operator delete(v12);
    uint64_t v22 = *(char **)(a1 + 8);
  }
LABEL_24:
  uint64_t v28 = *(char **)a1;
  if (v22 != *(char **)a1)
  {
    uint64_t v29 = 0;
    unint64_t v30 = 0;
    uint64_t v32 = *a4;
    uint64_t v31 = a4[1];
    do
    {
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v31 - v32) >> 3);
      char v34 = (void *)(v32 + v29);
      if (v33 <= v30) {
        BOOL v35 = a4 + 3;
      }
      else {
        BOOL v35 = v34;
      }
      *(void *)&v28[v29] = a2 + *v35 - v10;
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v30) {
        __int16 v36 = a4 + 3;
      }
      else {
        __int16 v36 = (uint64_t *)(*a4 + v29);
      }
      *(void *)(*(void *)a1 + v29 + 8) = a2 + v36[1] - v10;
      uint64_t v32 = *a4;
      uint64_t v31 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v31 - *a4) >> 3) <= v30) {
        char v37 = a4 + 3;
      }
      else {
        char v37 = (uint64_t *)(*a4 + v29);
      }
      char v38 = *((unsigned char *)v37 + 16);
      uint64_t v28 = *(char **)a1;
      uint64_t v39 = *(void *)(a1 + 8);
      *(unsigned char *)(*(void *)a1 + v29 + 16) = v38;
      ++v30;
      v29 += 24;
    }
    while (v30 < 0xAAAAAAAAAAAAAAABLL * ((v39 - (uint64_t)v28) >> 3));
  }
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 40) = 0;
  uint64_t v40 = a2 + a4[6] - v10;
  *(void *)(a1 + 48) = v40;
  *(void *)(a1 + 56) = a2 + a4[7] - v10;
  *(unsigned char *)(a1 + 64) = *((unsigned char *)a4 + 64);
  *(void *)(a1 + 72) = a2 + a4[9] - v10;
  *(void *)(a1 + 80) = a2 + a4[10] - v10;
  *(unsigned char *)(a1 + 88) = *((unsigned char *)a4 + 88);
  if ((v5 & 1) == 0) {
    *(void *)(a1 + 104) = v40;
  }
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a4 + 96);
}

uint64_t sub_10112DC34(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    sub_10012CD04(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }
  else
  {
    long long __p = 0;
    size_t v19 = 0;
    uint64_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 16))
  {
    sub_10012CD04(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    char v5 = v15;
    size_t v4 = v16;
  }
  else
  {
    size_t v4 = 0;
    char v5 = 0;
    unsigned int v3 = 0;
    unint64_t v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
  }
  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    uint64_t v10 = (void **)&v15;
  }
  else {
    uint64_t v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_10112DD48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10112DD64(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "lazuli.tr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v16, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)&v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  v17[0] = off_101999E18;
  v17[1] = sub_10112E070;
  v17[3] = v17;
  *(void *)(a1 + 8) = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 8)) {
    operator new();
  }
  sub_10008863C(v17);
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = *a3;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 32) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 40) = *(_OWORD *)a6;
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 104) = *a4;
  uint64_t v14 = a4[1];
  *(void *)(a1 + 112) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 120) = *(_OWORD *)a5;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  return a1;
}

void sub_10112DFCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_10112E070(int a1)
{
  std::string v1 = "lazuli.tr.?";
  if (a1 == 2) {
    std::string v1 = "lazuli.tr.2";
  }
  if (a1 == 1) {
    return "lazuli.tr.1";
  }
  else {
    return v1;
  }
}

void sub_10112E09C(uint64_t a1, uint64_t *a2, const void **a3, char *a4, void *a5, uint64_t a6, const char *a7, const char *a8, uint64_t a9)
{
  xpc_object_t v63 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v63 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v63 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v19 = xpc_null_create();
LABEL_8:
    xpc_object_t v63 = v19;
    goto LABEL_9;
  }
  xpc_retain(v18);
LABEL_9:
  xpc_release(v18);
  sub_100CC8708((const void **)a6, &v61);
  char v64 = &v63;
  uint64_t v65 = ims::lazuli::kBody;
  sub_100035E70((uint64_t)&v64, &v61, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v61);
  xpc_object_t v61 = 0;
  if (a7[24])
  {
    if (a7[23] < 0) {
      a7 = *(const char **)a7;
    }
    xpc_object_t v59 = xpc_string_create(a7);
    if (!v59) {
      xpc_object_t v59 = xpc_null_create();
    }
    char v64 = &v63;
    uint64_t v65 = ims::lazuli::kContentType;
    sub_100035E70((uint64_t)&v64, &v59, &v60);
    xpc_release(v60);
    xpc_object_t v60 = 0;
    xpc_release(v59);
    xpc_object_t v59 = 0;
  }
  else
  {
    sub_100058DB0(&v64, "message/cpim");
    if (v66 >= 0) {
      uint64_t v20 = (const char *)&v64;
    }
    else {
      uint64_t v20 = (const char *)v64;
    }
    xpc_object_t v57 = xpc_string_create(v20);
    if (!v57) {
      xpc_object_t v57 = xpc_null_create();
    }
    *(void *)std::string buf = &v63;
    *(void *)&uint8_t buf[8] = ims::lazuli::kContentType;
    sub_100035E70((uint64_t)buf, &v57, &v58);
    xpc_release(v58);
    xpc_object_t v58 = 0;
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v66) < 0) {
      operator delete(v64);
    }
  }
  if (*(char *)(*a5 + 55) >= 0) {
    int v21 = (const char *)(*a5 + 32);
  }
  else {
    int v21 = *(const char **)(*a5 + 32);
  }
  xpc_object_t v55 = xpc_string_create(v21);
  if (!v55) {
    xpc_object_t v55 = xpc_null_create();
  }
  char v64 = &v63;
  uint64_t v65 = ims::lazuli::kTransactionId;
  sub_100035E70((uint64_t)&v64, &v55, &v56);
  xpc_release(v56);
  xpc_object_t v56 = 0;
  xpc_release(v55);
  xpc_object_t v55 = 0;
  uint64_t v22 = (const char **)&ims::lazuli::kImdn;
  unint64_t v23 = (const char **)&ims::lazuli::kComposing;
  int v24 = *(_DWORD *)(a6 + 32);
  if (v24 != 2) {
    unint64_t v23 = (const char **)&ims::lazuli::kMessageText;
  }
  if (v24 != 1) {
    uint64_t v22 = v23;
  }
  xpc_object_t v53 = xpc_string_create(*v22);
  if (!v53) {
    xpc_object_t v53 = xpc_null_create();
  }
  char v64 = &v63;
  uint64_t v65 = ims::lazuli::kMessageType;
  sub_100035E70((uint64_t)&v64, &v53, &v54);
  xpc_release(v54);
  xpc_object_t v54 = 0;
  xpc_release(v53);
  xpc_object_t v53 = 0;
  xpc_object_t v51 = xpc_uint64_create(*(void *)(a6 + 24));
  if (!v51) {
    xpc_object_t v51 = xpc_null_create();
  }
  char v64 = &v63;
  uint64_t v65 = ims::lazuli::kOriginalMessageSize;
  sub_100035E70((uint64_t)&v64, &v51, &v52);
  xpc_release(v52);
  xpc_object_t v52 = 0;
  xpc_release(v51);
  xpc_object_t v51 = 0;
  if (a8[24])
  {
    if (a8[23] < 0) {
      a8 = *(const char **)a8;
    }
    xpc_object_t v49 = xpc_string_create(a8);
    if (!v49) {
      xpc_object_t v49 = xpc_null_create();
    }
    char v64 = &v63;
    uint64_t v65 = ims::lazuli::kContributionId;
    sub_100035E70((uint64_t)&v64, &v49, &v50);
    xpc_release(v50);
    xpc_object_t v50 = 0;
    xpc_release(v49);
    xpc_object_t v49 = 0;
  }
  else
  {
    sub_100561E04((const void **)a4, a3, &v64);
    if (v66 >= 0) {
      uint64_t v25 = (const char *)&v64;
    }
    else {
      uint64_t v25 = (const char *)v64;
    }
    xpc_object_t v47 = xpc_string_create(v25);
    if (!v47) {
      xpc_object_t v47 = xpc_null_create();
    }
    *(void *)std::string buf = &v63;
    *(void *)&uint8_t buf[8] = ims::lazuli::kContributionId;
    sub_100035E70((uint64_t)buf, &v47, &v48);
    xpc_release(v48);
    xpc_object_t v48 = 0;
    xpc_release(v47);
    xpc_object_t v47 = 0;
    if (SHIBYTE(v66) < 0) {
      operator delete(v64);
    }
  }
  long long v26 = (const char *)a9;
  if (*(unsigned char *)(a9 + 24))
  {
    if (*(char *)(a9 + 23) < 0) {
      long long v26 = *(const char **)a9;
    }
    xpc_object_t v45 = xpc_string_create(v26);
    if (!v45) {
      xpc_object_t v45 = xpc_null_create();
    }
    char v64 = &v63;
    uint64_t v65 = ims::lazuli::kInReplyToContributionId;
    sub_100035E70((uint64_t)&v64, &v45, &v46);
    xpc_release(v46);
    xpc_object_t v46 = 0;
    xpc_release(v45);
    xpc_object_t v45 = 0;
  }
  uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = a4[23];
    uint64_t v29 = *(char **)a4;
    sub_100120074(&v63, &v64);
    unint64_t v30 = v28 >= 0 ? a4 : v29;
    uint64_t v31 = v66 >= 0 ? (void **)&v64 : v64;
    *(_DWORD *)std::string buf = 136446467;
    *(void *)&uint8_t buf[4] = v30;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v31;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Dispatching transaction: [%{public}s] with message: %{private}s ", buf, 0x16u);
    if (SHIBYTE(v66) < 0) {
      operator delete(v64);
    }
  }
  uint64_t v32 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  xpc_object_t v44 = v63;
  if (v63) {
    xpc_retain(v63);
  }
  else {
    xpc_object_t v44 = xpc_null_create();
  }
  sub_100A66638(a2, v32, &v44);
  xpc_release(v44);
  xpc_object_t v44 = 0;
  unint64_t v33 = *(void ***)(a1 + 64);
  char v34 = (void ***)(a1 + 64);
  BOOL v35 = (void ***)(a1 + 64);
  if (!v33) {
    goto LABEL_75;
  }
  char v34 = (void ***)(a1 + 64);
  while (1)
  {
    while (1)
    {
      BOOL v35 = (void ***)v33;
      __int16 v36 = v33 + 4;
      if ((sub_100046FE8(a4, v33 + 4) & 0x80) == 0) {
        break;
      }
      unint64_t v33 = *v35;
      char v34 = v35;
      if (!*v35) {
        goto LABEL_75;
      }
    }
    if ((sub_100046FE8(v36, (void **)a4) & 0x80) == 0) {
      break;
    }
    char v34 = v35 + 1;
    unint64_t v33 = v35[1];
    if (!v33) {
      goto LABEL_75;
    }
  }
  char v37 = *v34;
  if (!*v34)
  {
LABEL_75:
    uint64_t v66 = 0;
    char v38 = operator new(0x48uLL);
    char v64 = (void **)v38;
    uint64_t v65 = a1 + 64;
    LOBYTE(v66) = 0;
    uint64_t v39 = v38 + 4;
    if (a4[23] < 0)
    {
      sub_10004FC84(v39, *(void **)a4, *((void *)a4 + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v39 = *(_OWORD *)a4;
      v38[6] = *((void *)a4 + 2);
    }
    v38[7] = 0;
    v38[8] = 0;
    LOBYTE(v66) = 1;
    *char v38 = 0;
    v38[1] = 0;
    v38[2] = v35;
    *char v34 = (void **)v38;
    uint64_t v40 = **(void **)(a1 + 56);
    if (v40)
    {
      *(void *)(a1 + 56) = v40;
      char v38 = *v34;
    }
    sub_100046C90(*(uint64_t **)(a1 + 64), v38);
    ++*(void *)(a1 + 72);
    char v37 = v64;
    char v64 = 0;
    sub_1001FEBC4((uint64_t)&v64);
  }
  BOOL v42 = (void *)*a5;
  int v41 = (atomic_ullong *)a5[1];
  if (v41) {
    atomic_fetch_add_explicit(v41 + 1, 1uLL, memory_order_relaxed);
  }
  __int16 v43 = (std::__shared_weak_count *)v37[8];
  v37[7] = v42;
  v37[8] = v41;
  if (v43) {
    sub_10004D2C8(v43);
  }
  xpc_release(v63);
}

void sub_10112E7BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10112E8C0(uint64_t a1, void **a2, unsigned int a3)
{
  char v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = Lazuli::asString();
    uint64_t v8 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v8 = *a2;
    }
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Incoming message ==>> [%{public}s] with id: %{public}s", buf, 0x16u);
  }
  uint64_t v9 = *(void *)(a1 + 104);
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(buf, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)a2;
    *(void *)&uint8_t buf[16] = a2[2];
  }
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v12 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  char v13 = 1;
  (*(void (**)(uint64_t, uint64_t, void **, unint64_t))(*(void *)v9 + 8))(v9, v10, __p, a3 | (unint64_t)&_mh_execute_header);
  if (v13 && SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_10112EA6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_10112EAA8(uint64_t a1, uint64_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v19 = 0;
  uint64_t v4 = *a2;
  if (*(char *)(*a2 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v4 + 8), *(void *)(v4 + 16));
    uint64_t v4 = *a2;
    if (!*a2) {
      goto LABEL_7;
    }
  }
  else
  {
    long long v5 = *(_OWORD *)(v4 + 8);
    uint64_t v19 = *(void *)(v4 + 24);
    *(_OWORD *)long long __p = v5;
  }
  {
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    goto LABEL_12;
  }
LABEL_7:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, void **))(*(void *)v9 + 16))(v9, __p);
      }
      sub_10004D2C8(v8);
    }
  }
LABEL_12:
  v15[0] = (long long *)__p;
  uint64_t v10 = sub_10113D9D0((uint64_t **)(a1 + 80), __p, v15);
  uint64_t v12 = *a2;
  uint64_t v11 = a2[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  char v13 = (std::__shared_weak_count *)v10[8];
  v10[7] = v12;
  v10[8] = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  char v16 = 0;
  char v17 = 0;
  uint64_t v14 = a2[1];
  v15[0] = (long long *)*a2;
  v15[1] = (long long *)v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10112ECA4();
}

void sub_10112EC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_10004D2C8(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10112ECA4()
{
}

void sub_10112EED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a23)
  {
    if (a22 < 0) {
      operator delete(__p);
    }
  }
  (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  _Unwind_Resume(a1);
}

BOOL sub_10112EF50@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 24));
  unsigned int v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    long long v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v13 = v10;
  uint64_t v14 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
  }
  BOOL v11 = sub_100562BDC((uint64_t)&v13);
  if (v14) {
    sub_10004D2C8(v14);
  }
  return v11;
}

void sub_10112F03C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10112F058()
{
}

void sub_10112F250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  _Unwind_Resume(a1);
}

void sub_10112F2C0()
{
}

void sub_10112F380(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_10112F3D4(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 80);
  unsigned int v3 = (void *)(a1 + 88);
  if (v2 != (void *)(a1 + 88))
  {
    do
    {
      unint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        long long v5 = (char *)v2[7];
        if (v5)
        {
          sub_100BEBA6C(v5, __p);
          if (v17 >= 0) {
            uint64_t v6 = __p;
          }
          else {
            uint64_t v6 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          uint64_t v19 = (const char *)v6;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [Incoming] %{public}s", buf, 0xCu);
          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_DWORD *)std::string buf = 136446210;
          uint64_t v19 = "(null)";
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [Incoming] %{public}s", buf, 0xCu);
        }
      }
      unsigned int v7 = (void *)v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          unsigned int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v2[2];
          BOOL v9 = *v8 == (void)v2;
          unint64_t v2 = v8;
        }
        while (!v9);
      }
      unint64_t v2 = v8;
    }
    while (v8 != v3);
  }
  uint64_t v10 = *(void **)(a1 + 56);
  if (v10 != (void *)(a1 + 64))
  {
    do
    {
      BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = (char *)v10[7];
        if (v12)
        {
          sub_100BEBA6C(v12, __p);
          if (v17 >= 0) {
            uint64_t v13 = __p;
          }
          else {
            uint64_t v13 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136446210;
          uint64_t v19 = (const char *)v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [Outgoing] %{public}s", buf, 0xCu);
          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_DWORD *)std::string buf = 136446210;
          uint64_t v19 = "(null)";
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [Outgoing] %{public}s", buf, 0xCu);
        }
      }
      uint64_t v14 = (void *)v10[1];
      if (v14)
      {
        do
        {
          unint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          unint64_t v15 = (void *)v10[2];
          BOOL v9 = *v15 == (void)v10;
          uint64_t v10 = v15;
        }
        while (!v9);
      }
      uint64_t v10 = v15;
    }
    while (v15 != (void *)(a1 + 64));
  }
}

void sub_10112F6AC(uint64_t a1@<X0>, void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      unsigned int v7 = a2;
    }
    else {
      unsigned int v7 = (void **)*a2;
    }
    int v17 = 136446210;
    xpc_object_t v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Retrieving message: %{public}s", (uint8_t *)&v17, 0xCu);
  }
  uint64_t v8 = sub_100046F68(a1 + 80, a2);
  if ((void **)(a1 + 88) == v8)
  {
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a2 + 23) >= 0) {
        char v16 = a2;
      }
      else {
        char v16 = (void **)*a2;
      }
      int v17 = 136446210;
      xpc_object_t v18 = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Unable to find transaction: %{public}s", (uint8_t *)&v17, 0xCu);
    }
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    BOOL v9 = v8[7];
    if (v9)
    {
      uint64_t v10 = (atomic_ullong *)v8[8];
      *a3 = v9;
      a3[1] = v10;
      if (v10) {
        atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
      }
      BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) < 0) {
          a2 = (void **)*a2;
        }
        unsigned int v12 = (*(uint64_t (**)(void *))(*(void *)v9 + 16))(v9) - 1;
        if (v12 > 4) {
          uint64_t v13 = "kInvalid";
        }
        else {
          uint64_t v13 = off_101A93A88[v12];
        }
        int v17 = 136446466;
        xpc_object_t v18 = a2;
        __int16 v19 = 2080;
        uint64_t v20 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Message retrieved successfully: [%{public}s: %s]", (uint8_t *)&v17, 0x16u);
      }
    }
    else
    {
      unint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v17) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Message has disappeared", (uint8_t *)&v17, 2u);
      }
    }
  }
}

void sub_10112F9B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10112F9D4(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v4 = *(void **)(a1 + 80);
  long long v5 = (void *)(a1 + 88);
  if (v4 != (void *)(a1 + 88))
  {
    do
    {
      sub_100BEBEBC(v4[7], &__p);
      unint64_t v7 = a2[1];
      unint64_t v6 = a2[2];
      if (v7 >= v6)
      {
        unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a2) >> 3);
        unint64_t v10 = v9 + 1;
        if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_10006A748();
        }
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *a2) >> 3);
        if (2 * v11 > v10) {
          unint64_t v10 = 2 * v11;
        }
        if (v11 >= 0x555555555555555) {
          unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v12 = v10;
        }
        uint64_t v27 = a2 + 2;
        if (v12) {
          uint64_t v13 = (char *)sub_10004812C((uint64_t)(a2 + 2), v12);
        }
        else {
          uint64_t v13 = 0;
        }
        uint64_t v14 = &v13[24 * v9];
        *(void *)&long long buf = v13;
        *((void *)&buf + 1) = v14;
        long long v26 = &v13[24 * v12];
        long long v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((void *)v14 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)uint64_t v14 = v15;
        memset(&__p, 0, sizeof(__p));
        uint64_t v25 = v14 + 24;
        sub_10113D234(a2, &buf);
        uint64_t v16 = a2[1];
        sub_100048174((uint64_t)&buf);
        int v17 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        a2[1] = v16;
        if (v17 < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v8 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v7 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v7 = v8;
        a2[1] = v7 + 24;
      }
      xpc_object_t v18 = (void *)v4[1];
      if (v18)
      {
        do
        {
          __int16 v19 = v18;
          xpc_object_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          __int16 v19 = (void *)v4[2];
          BOOL v20 = *v19 == (void)v4;
          unint64_t v4 = v19;
        }
        while (!v20);
      }
      unint64_t v4 = v19;
    }
    while (v19 != v5);
  }
  int v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Retrieved a total of [%ld] message", (uint8_t *)&buf, 0xCu);
  }
}

void sub_10112FC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void sub_10112FC7C(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Acknowledging [%ld] message", buf, 0xCu);
  }
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    long long v8 = (void ***)(a1 + 80);
    unint64_t v9 = (void **)(a1 + 88);
    do
    {
      *(_OWORD *)std::string __p = 0u;
      long long v23 = 0u;
      *(_OWORD *)long long buf = 0u;
      sub_100BEC024(v6, (std::string *)buf);
      if (v9 != sub_100046F68(a1 + 80, (void **)buf))
      {
        unint64_t v10 = sub_100046F68(a1 + 80, (void **)buf);
        if (v9 != v10)
        {
          unint64_t v11 = (uint64_t *)v10;
          unint64_t v12 = (void **)v10[1];
          if (v12)
          {
            do
            {
              uint64_t v13 = v12;
              unint64_t v12 = (void **)*v12;
            }
            while (v12);
          }
          else
          {
            uint64_t v14 = v10;
            do
            {
              uint64_t v13 = (void **)v14[2];
              BOOL v15 = *v13 == v14;
              uint64_t v14 = v13;
            }
            while (!v15);
          }
          if (*v8 == v10) {
            *long long v8 = v13;
          }
          uint64_t v16 = *(uint64_t **)(a1 + 88);
          --*(void *)(a1 + 96);
          sub_10005EE6C(v16, v11);
          sub_1001FEC1C((uint64_t)(v11 + 4));
          operator delete(v11);
        }
        int v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = v6;
          if (*(char *)(v6 + 23) < 0) {
            uint64_t v18 = *(void *)v6;
          }
          *(_DWORD *)__int16 v19 = 136446210;
          uint64_t v20 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Erased: [%{public}s]", v19, 0xCu);
        }
      }
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(*(void **)buf);
      }
      v6 += 24;
    }
    while (v6 != v7);
  }
}

void sub_10112FEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1001085D8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10112FF10(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 24));
  unint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v6;
  unint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v15 = v12;
  uint64_t v16 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    uint64_t v12 = v15;
  }
  if (v12)
  {
    memset(v14, 0, sizeof(v14));
    sub_100CC85C0(v14, a2);
    sub_100CC84D0();
  }
  uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Missing carrier settings interface", (uint8_t *)&__p, 2u);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_10113054C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,std::__shared_weak_count *a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_10004D2C8(v35);
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a29) {
    sub_10004D2C8(a29);
  }
  _Unwind_Resume(a1);
}

void sub_101130664(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x10113065CLL);
}

void sub_101130674(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = (uint64_t *)*a3;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Incoming CPIM with contribution ID: %{public}s", buf, 0xCu);
  }
  uint64_t v15 = 0;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  unint64_t v11 = *(Registry **)(a1 + 24);
  uint64_t v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10055FEB8(&v11, buf);
  sub_100CC89EC(v13, (uint64_t)buf);
  if (SBYTE7(v17) < 0) {
    operator delete(*(void **)buf);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v45 = 0;
  long long v44 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  long long v39 = 0u;
  long long v38 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_100B8EBC0((uint64_t)buf);
  BOOL v9 = sub_100B8F6E4((uint64_t)buf, (Registry **)(a1 + 24), a2);
  sub_100B907E0((uint64_t)buf, 1);
  if (v9) {
    sub_100CC84D0();
  }
  unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__s = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to decode CPIM content", __s, 2u);
  }
  sub_10112F2C0();
}

void sub_101132784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39)
{
  if (SLOBYTE(STACK[0x497]) < 0) {
    operator delete((void *)STACK[0x480]);
  }
  sub_100456338((uint64_t)&STACK[0x670]);
  sub_10113D1F0((uint64_t)&STACK[0x9C0]);
  sub_10113D58C((uint64_t)&a39);
  sub_10113D608((uint64_t)&STACK[0x340]);
  sub_1000C636C((uint64_t)&STACK[0x4A0]);
  if (LOBYTE(STACK[0x5C8]) && SLOBYTE(STACK[0x5C7]) < 0) {
    operator delete((void *)STACK[0x5B0]);
  }
  if (LOBYTE(STACK[0x608]))
  {
    STACK[0x9C0] = (unint64_t)&STACK[0x5F0];
    sub_100155494((void ***)&STACK[0x9C0]);
  }
  if (LOBYTE(STACK[0x628]) && SLOBYTE(STACK[0x627]) < 0) {
    operator delete((void *)STACK[0x610]);
  }
  sub_10113D654((uint64_t)&STACK[0x7E0]);
  if (SLOBYTE(STACK[0x657]) < 0) {
    operator delete((void *)STACK[0x640]);
  }
  _Unwind_Resume(a1);
}

_OWORD *sub_101132F54(_OWORD *__dst, uint64_t a2)
{
  unint64_t v2 = __dst;
  char v3 = *(unsigned char *)(a2 + 464);
  if (v3)
  {
    for (uint64_t i = *(void *)(a2 + 440); ; i += 384)
    {
      if (i == *(void *)(a2 + 448))
      {
        char v3 = 0;
        goto LABEL_7;
      }
      if (*(_DWORD *)(i + 376) == 6) {
        break;
      }
    }
    if (*(char *)(i + 55) < 0)
    {
      long long __dst = sub_10004FC84(__dst, *(void **)(i + 32), *(void *)(i + 40));
    }
    else
    {
      long long v5 = *(_OWORD *)(i + 32);
      *((void *)__dst + 2) = *(void *)(i + 48);
      *long long __dst = v5;
    }
    char v3 = 1;
  }
  else
  {
LABEL_7:
    *(unsigned char *)long long __dst = 0;
  }
  v2[24] = v3;
  return __dst;
}

void sub_101132FD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a4 + 24))
  {
    sub_100561B00((uint64_t)__p);
    if (*(unsigned char *)(a4 + 24))
    {
      if (*(char *)(a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      *(_OWORD *)a4 = *(_OWORD *)__p;
      *(void *)(a4 + 16) = v15;
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)__p;
      *(void *)(a4 + 16) = v15;
      *(unsigned char *)(a4 + 24) = 1;
    }
  }
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_1001544B0();
}

void sub_101133650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50,uint64_t a51)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (v51) {
    sub_10004D2C8(v51);
  }
  sub_10113D72C((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void sub_1011337A4()
{
}

void sub_1011337AC(uint64_t a1, void *a2)
{
  if (a2[2])
  {
    uint64_t v15 = 0;
    long long v3 = 0uLL;
    long long v14 = 0u;
    unint64_t v4 = a2 + 1;
    long long v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1)
    {
      uint64_t v9 = 0;
    }
    else
    {
      do
      {
        if (*((char *)v5 + 55) < 0)
        {
          sub_10004FC84(v10, (void *)v5[4], v5[5]);
        }
        else
        {
          *(_OWORD *)long long v10 = *((_OWORD *)v5 + 2);
          uint64_t v11 = v5[6];
        }
        if (*((char *)v5 + 79) < 0)
        {
          sub_10004FC84(&__p, (void *)v5[7], v5[8]);
        }
        else
        {
          long long __p = *(_OWORD *)(v5 + 7);
          uint64_t v13 = v5[9];
        }
        sub_1002943D8((char **)&v14, (long long *)v10);
        if (SHIBYTE(v13) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v11) < 0) {
          operator delete(v10[0]);
        }
        long long v6 = (void *)v5[1];
        if (v6)
        {
          do
          {
            long long v7 = v6;
            long long v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            long long v7 = (void *)v5[2];
            BOOL v8 = *v7 == (void)v5;
            long long v5 = v7;
          }
          while (!v8);
        }
        long long v5 = v7;
      }
      while (v7 != v4);
      long long v3 = v14;
      uint64_t v9 = v15;
    }
    *(_OWORD *)a1 = v3;
    *(void *)(a1 + 16) = v9;
    uint64_t v15 = 0;
    long long v14 = 0uLL;
    *(unsigned char *)(a1 + 24) = 1;
    v10[0] = &v14;
    sub_100155410((void ***)v10);
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
}

void sub_101133908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  long long __p = &a18;
  sub_100155410((void ***)&__p);
  _Unwind_Resume(a1);
}

char *sub_10113394C(char *result, uint64_t a2)
{
  unint64_t v2 = result;
  char v3 = *(unsigned char *)(a2 + 464);
  if (v3)
  {
    for (uint64_t i = *(void *)(a2 + 440); ; i += 384)
    {
      if (i == *(void *)(a2 + 448))
      {
        char v3 = 0;
        goto LABEL_7;
      }
      if (*(_DWORD *)(i + 376) == 5) {
        break;
      }
    }
    *(_DWORD *)uint64_t result = *(_DWORD *)(i + 32);
    if (*(char *)(i + 63) < 0)
    {
      sub_10004FC84(result + 8, *(void **)(i + 40), *(void *)(i + 48));
    }
    else
    {
      long long v5 = *(_OWORD *)(i + 40);
      *((void *)result + 3) = *(void *)(i + 56);
      *(_OWORD *)(result + 8) = v5;
    }
    uint64_t result = v2 + 32;
    if (*(char *)(i + 87) < 0)
    {
      uint64_t result = (char *)sub_10004FC84(result, *(void **)(i + 64), *(void *)(i + 72));
    }
    else
    {
      long long v6 = *(_OWORD *)(i + 64);
      *((void *)v2 + 6) = *(void *)(i + 80);
      *(_OWORD *)uint64_t result = v6;
    }
    char v3 = 1;
  }
  else
  {
LABEL_7:
    *uint64_t result = 0;
  }
  v2[56] = v3;
  return result;
}

void sub_101133A14(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101133A30(uint64_t a1)
{
  sub_1002B24B0(a1 + 144);
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(unsigned char *)(a1 + 112))
  {
    char v3 = (void **)(a1 + 88);
    sub_100047F64(&v3);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

char *sub_101133ABC(char *result, uint64_t a2)
{
  unint64_t v2 = result;
  char v3 = *(unsigned char *)(a2 + 464);
  if (v3)
  {
    for (uint64_t i = *(void *)(a2 + 440); ; i += 384)
    {
      if (i == *(void *)(a2 + 448))
      {
        char v3 = 0;
        goto LABEL_7;
      }
      if (*(_DWORD *)(i + 376) == 4) {
        break;
      }
    }
    *(_DWORD *)uint64_t result = *(_DWORD *)(i + 32);
    if (*(char *)(i + 63) < 0)
    {
      sub_10004FC84(result + 8, *(void **)(i + 40), *(void *)(i + 48));
    }
    else
    {
      long long v5 = *(_OWORD *)(i + 40);
      *((void *)result + 3) = *(void *)(i + 56);
      *(_OWORD *)(result + 8) = v5;
    }
    uint64_t result = v2 + 32;
    if (*(char *)(i + 87) < 0)
    {
      uint64_t result = (char *)sub_10004FC84(result, *(void **)(i + 64), *(void *)(i + 72));
    }
    else
    {
      long long v6 = *(_OWORD *)(i + 64);
      *((void *)v2 + 6) = *(void *)(i + 80);
      *(_OWORD *)uint64_t result = v6;
    }
    *((void *)v2 + 7) = *(void *)(i + 88);
    char v3 = 1;
  }
  else
  {
LABEL_7:
    *uint64_t result = 0;
  }
  v2[64] = v3;
  return result;
}

void sub_101133B8C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_101133BA8(unsigned char *result, uint64_t a2)
{
  unint64_t v2 = result;
  if (*(unsigned char *)(a2 + 464))
  {
    for (uint64_t i = *(void *)(a2 + 440); i != *(void *)(a2 + 448); i += 384)
    {
      if (*(_DWORD *)(i + 376) == 2)
      {
        sub_100B920FC((uint64_t)result, (long long *)(i + 32));
        uint64_t result = sub_100B9223C(v2 + 144, i + 176);
        char v4 = 1;
        goto LABEL_7;
      }
    }
  }
  char v4 = 0;
  *uint64_t result = 0;
LABEL_7:
  v2[296] = v4;
  return result;
}

void sub_101133C1C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 127) < 0) {
    operator delete(*(void **)(v1 + 104));
  }
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*(void **)(v1 + 80));
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*(void **)(v1 + 56));
  }
  if (*(unsigned char *)(v1 + 48))
  {
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101133C70(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 320))
  {
    char v3 = (void **)(a1 + 296);
    sub_100155494(&v3);
  }
  if (*(unsigned char *)(a1 + 288) && *(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(unsigned char *)(a1 + 256) && *(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  sub_1004563E8(a1 + 48);
  if (*(unsigned char *)(a1 + 40) && *(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

uint64_t sub_101133D08(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  sub_100058DB0(__p, "message/cpim");
  BOOL v8 = sub_1010E5F80(a3, (uint64_t)__p);
  BOOL v9 = v8;
  if (SBYTE7(v57) < 0)
  {
    operator delete(__p[0]);
    if (v9) {
LABEL_3:
    }
      sub_101130674(a1, (uint64_t)a2, a4);
  }
  else if (v8)
  {
    goto LABEL_3;
  }
  sub_100058DB0(__p, "application/vnd.gsma.rcsrevoke+xml");
  BOOL v10 = sub_1010E5F80(a3, (uint64_t)__p);
  if (SBYTE7(v57) < 0) {
    operator delete(__p[0]);
  }
  if (!v10)
  {
    long long v32 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        long long v35 = (void *)a3;
      }
      else {
        long long v35 = *(void **)a3;
      }
      LODWORD(__p[0]) = 136446210;
      *(void **)((char *)__p + 4) = v35;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Unhandled content type (non CPIM): %{public}s", (uint8_t *)__p, 0xCu);
    }
    sub_10112F2C0();
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Incoming revoke XML", (uint8_t *)__p, 2u);
  }
  uint64_t v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v12 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_100A442C0((Registry **)(a1 + 24), v12, a2, (uint64_t)__p);
  if (!(_BYTE)v61)
  {
    long long v34 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Failed to decode revoke XML", buf, 2u);
    }
    return sub_100777CB4((uint64_t)__p);
  }
  *(_OWORD *)xpc_object_t v50 = 0u;
  long long v51 = 0u;
  uint64_t v13 = *(void **)(a1 + 56);
  long long v14 = (void *)(a1 + 64);
  if (v13 == (void *)(a1 + 64)) {
    goto LABEL_52;
  }
  do
  {
    uint64_t v15 = (_DWORD *)v13[7];
    if (v15[14] == 14)
    {
      if (!v16)
      {
        long long v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Invalid revoke transaction", buf, 2u);
        }
        goto LABEL_24;
      }
      long long v17 = (std::__shared_weak_count *)v13[8];
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v18 = sub_1010E5F80((uint64_t)v16 + 8, (uint64_t)(v13 + 4));
      BOOL v19 = v18;
      if (v18) {
        sub_100093B44((std::string *)v50, (const std::string *)(v13 + 4));
      }
      if (v17) {
        sub_10004D2C8(v17);
      }
      if (v19) {
        break;
      }
    }
LABEL_24:
    long long v21 = (void *)v13[1];
    if (v21)
    {
      do
      {
        long long v22 = v21;
        long long v21 = (void *)*v21;
      }
      while (v21);
    }
    else
    {
      do
      {
        long long v22 = (void *)v13[2];
        BOOL v23 = *v22 == (void)v13;
        uint64_t v13 = v22;
      }
      while (!v23);
    }
    uint64_t v13 = v22;
  }
  while (v22 != v14);
  if (BYTE8(v51))
  {
    long long v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if (!BYTE8(v51)) {
        sub_10016C840();
      }
      long long v25 = v50;
      if (SBYTE7(v51) < 0) {
        long long v25 = (void **)v50[0];
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Matched incoming revoke message to ID: %{public}s", buf, 0xCu);
    }
    if (!BYTE8(v51)) {
      sub_10016C840();
    }
    long long v26 = (void *)*v14;
    if (*v14)
    {
      uint64_t v27 = a1 + 64;
      do
      {
        char v28 = sub_100046FE8(v26 + 4, v50);
        if (v28 >= 0) {
          long long v29 = v26;
        }
        else {
          long long v29 = v26 + 1;
        }
        if (v28 >= 0) {
          uint64_t v27 = (uint64_t)v26;
        }
        long long v26 = (void *)*v29;
      }
      while (*v29);
      if ((void *)v27 != v14 && (sub_100046FE8(v50, (void **)(v27 + 32)) & 0x80) == 0)
      {
        long long v30 = *(void **)(v27 + 8);
        if (v30)
        {
          do
          {
            long long v31 = v30;
            long long v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          long long v36 = (void *)v27;
          do
          {
            long long v31 = (void *)v36[2];
            BOOL v23 = *v31 == (void)v36;
            long long v36 = v31;
          }
          while (!v23);
        }
        if (*(void *)(a1 + 56) == v27) {
          *(void *)(a1 + 56) = v31;
        }
        long long v37 = *(uint64_t **)(a1 + 64);
        --*(void *)(a1 + 72);
        sub_10005EE6C(v37, (uint64_t *)v27);
        sub_1001FEC1C(v27 + 32);
        operator delete((void *)v27);
      }
    }
    long long v38 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      if (!BYTE8(v51)) {
        sub_10016C840();
      }
      long long v39 = v50;
      if (SBYTE7(v51) < 0) {
        long long v39 = (void **)v50[0];
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v39;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Incoming revoke message ==>> with id: %{public}s", buf, 0xCu);
    }
    *(_OWORD *)long long __dst = 0u;
    long long v49 = 0u;
    if (SBYTE7(v57) < 0)
    {
      sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)__p;
      *(void *)&long long v49 = v57;
    }
    DWORD2(v49) = DWORD2(v60);
    if (!BYTE8(v51)) {
      sub_10016C840();
    }
    uint64_t v40 = *(void *)(a1 + 104);
    uint64_t v41 = *(unsigned int *)(a1 + 16);
    if (SBYTE7(v51) < 0)
    {
      sub_10004FC84(v43, v50[0], (unint64_t)v50[1]);
    }
    else
    {
      *(_OWORD *)long long v43 = *(_OWORD *)v50;
      uint64_t v44 = v51;
    }
    *(_OWORD *)uint64_t v45 = *(_OWORD *)v43;
    uint64_t v46 = v44;
    v43[1] = 0;
    uint64_t v44 = 0;
    v43[0] = 0;
    char v47 = 1;
    if (SBYTE7(v49) < 0)
    {
      sub_10004FC84(buf, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)__dst;
      uint64_t v53 = v49;
    }
    int v54 = DWORD2(v49);
    char v55 = 1;
    (*(void (**)(uint64_t, uint64_t, void **, uint8_t *))(*(void *)v40 + 64))(v40, v41, v45, buf);
    if (v55 && SHIBYTE(v53) < 0) {
      operator delete(*(void **)buf);
    }
    if (v47 && SHIBYTE(v46) < 0) {
      operator delete(v45[0]);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(v43[0]);
    }
    if (SBYTE7(v49) < 0) {
      operator delete(__dst[0]);
    }
    goto LABEL_91;
  }
LABEL_52:
  long long v33 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Failed to match incoming revoke message", buf, 2u);
  }
LABEL_91:
  if (BYTE8(v51) && SBYTE7(v51) < 0) {
    operator delete(v50[0]);
  }
  return sub_100777CB4((uint64_t)__p);
}

void sub_10113451C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,char a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a22 && a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a36)
  {
    if (a35 < 0) {
      operator delete(a30);
    }
  }
  sub_100777CB4((uint64_t)&a46);
  _Unwind_Resume(a1);
}

void sub_10113460C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  unint64_t v47 = 0;
  char v4 = *(long long **)(a1 + 56);
  long long v5 = (long long *)(a1 + 64);
  if (v4 == (long long *)(a1 + 64))
  {
    long long v6 = 0;
    long long v20 = 0;
  }
  else
  {
    long long v6 = 0;
    do
    {
      long long v7 = v4 + 2;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (char *)v45) >> 3) <= 4)
      {
        if ((unint64_t)v6 >= v47)
        {
          long long v6 = (std::string *)sub_100048008((uint64_t *)&v45, v4 + 2);
        }
        else
        {
          if (*((char *)v4 + 55) < 0)
          {
            sub_10004FC84(v6, *((void **)v4 + 4), *((void *)v4 + 5));
          }
          else
          {
            long long v8 = *v7;
            v6->__r_.__value_.__r.__words[2] = *((void *)v4 + 6);
            *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v8;
          }
          ++v6;
        }
        uint64_t v46 = v6;
      }
      uint64_t v9 = *((void *)v4 + 7);
      uint64_t v10 = *(unsigned __int8 *)(v9 + 55);
      size_t v11 = *(void *)(v9 + 40);
      if ((v10 & 0x80u) == 0) {
        uint64_t v12 = *(unsigned __int8 *)(v9 + 55);
      }
      else {
        uint64_t v12 = *(void *)(v9 + 40);
      }
      uint64_t v13 = a2[23];
      int v14 = (char)v13;
      if ((v13 & 0x80u) != 0) {
        uint64_t v13 = *((void *)a2 + 1);
      }
      if (v12 == v13)
      {
        uint64_t v15 = (const void **)(v9 + 32);
        if (v14 >= 0) {
          uint64_t v16 = a2;
        }
        else {
          uint64_t v16 = *(unsigned __int8 **)a2;
        }
        if ((v10 & 0x80) != 0)
        {
          if (!memcmp(*v15, v16, v11))
          {
LABEL_33:
            long long v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              if ((a2[23] & 0x80u) == 0) {
                long long v22 = a2;
              }
              else {
                long long v22 = *(unsigned __int8 **)a2;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = v22;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Publishing SendSuccess for: %{public}s", buf, 0xCu);
            }
            uint64_t v23 = *(void *)(a1 + 104);
            uint64_t v24 = *(unsigned int *)(a1 + 16);
            if (*((char *)v4 + 55) < 0)
            {
              sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
            }
            else
            {
              *(_OWORD *)long long buf = *v7;
              int64_t v50 = *((void *)v4 + 6);
            }
            *(_OWORD *)long long v42 = *(_OWORD *)buf;
            uint64_t v43 = v50;
            int64_t v50 = 0;
            memset(buf, 0, sizeof(buf));
            char v44 = 1;
            (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v23 + 24))(v23, v24, v42);
            if (v44 && SHIBYTE(v43) < 0) {
              operator delete(v42[0]);
            }
            if (SHIBYTE(v50) < 0) {
              operator delete(*(void **)buf);
            }
            char v40 = 0;
            char v41 = 0;
            uint64_t v34 = *((void *)v4 + 8);
            *(void *)long long buf = *((void *)v4 + 7);
            *(void *)&uint8_t buf[8] = v34;
            if (v34) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
            }
            sub_10112ECA4();
          }
        }
        else
        {
          if (!v10) {
            goto LABEL_33;
          }
          while (*(unsigned __int8 *)v15 == *v16)
          {
            uint64_t v15 = (const void **)((char *)v15 + 1);
            ++v16;
            if (!--v10) {
              goto LABEL_33;
            }
          }
        }
      }
      long long v17 = (long long *)*((void *)v4 + 1);
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          long long v17 = *(long long **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (long long *)*((void *)v4 + 2);
          BOOL v19 = *(void *)v18 == (void)v4;
          char v4 = v18;
        }
        while (!v19);
      }
      char v4 = v18;
    }
    while (v18 != v5);
    long long v20 = v45;
  }
  sub_100062B40(v20, v6, ",", 1uLL, &v38);
  long long v25 = std::string::append(&v38, " {", 2uLL);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v39.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *(void *)(a1 + 72));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  long long v29 = std::string::append(&v39, (const std::string::value_type *)p_p, size);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  long long v31 = std::string::append(&v48, "} ", 2uLL);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  int64_t v50 = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long buf = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  long long v33 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    if ((a2[23] & 0x80u) == 0) {
      std::string::size_type v35 = (std::string::size_type)a2;
    }
    else {
      std::string::size_type v35 = *(void *)a2;
    }
    long long v36 = buf;
    if (v50 < 0) {
      long long v36 = *(uint8_t **)buf;
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = v35;
    WORD2(v48.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v48.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v36;
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "SendSuccess: Failed to find transactionID: [%{public}s] current transactions: [%{public}s]", (uint8_t *)&v48, 0x16u);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(*(void **)buf);
  }
  *(void *)long long buf = &v45;
  sub_100047F64((void ***)buf);
}

void sub_101134B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,char a40,uint64_t a41)
{
  *(void *)(v41 - 112) = &a40;
  sub_100047F64((void ***)(v41 - 112));
  _Unwind_Resume(a1);
}

void sub_101134BE4(uint64_t a1, unsigned __int8 **a2, unsigned int *a3)
{
  long long v5 = *(void **)(a1 + 56);
  long long v6 = (void *)(a1 + 64);
  if (v5 != (void *)(a1 + 64))
  {
    char v8 = *((unsigned char *)a2 + 23);
    if (v8 >= 0) {
      uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    }
    else {
      uint64_t v9 = a2[1];
    }
    if (v8 >= 0) {
      uint64_t v10 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v10 = *a2;
    }
    do
    {
      uint64_t v11 = v5[7];
      uint64_t v12 = *(unsigned __int8 *)(v11 + 55);
      size_t v13 = *(void *)(v11 + 40);
      if ((v12 & 0x80u) == 0) {
        int v14 = (unsigned __int8 *)*(unsigned __int8 *)(v11 + 55);
      }
      else {
        int v14 = *(unsigned __int8 **)(v11 + 40);
      }
      if (v14 == v9)
      {
        uint64_t v15 = (const void **)(v11 + 32);
        if ((v12 & 0x80) != 0)
        {
          if (!memcmp(*v15, v10, v13))
          {
LABEL_30:
            long long v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              if (*((char *)a2 + 23) >= 0) {
                uint64_t v23 = (unsigned __int8 *)a2;
              }
              else {
                uint64_t v23 = *a2;
              }
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = v23;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Publishing SendFailure for: %{public}s", buf, 0xCu);
            }
            if (*((unsigned char *)a3 + 4))
            {
              uint64_t v24 = *(void *)(a1 + 104);
              uint64_t v25 = *(unsigned int *)(a1 + 16);
              if (*((char *)v5 + 55) < 0)
              {
                sub_10004FC84(buf, (void *)v5[4], v5[5]);
                int v26 = *((unsigned __int8 *)a3 + 4);
                *(_OWORD *)std::string __p = *(_OWORD *)buf;
                uint64_t v29 = v32;
                memset(buf, 0, sizeof(buf));
                uint64_t v32 = 0;
                char v30 = 1;
                if (!v26) {
                  sub_10016C840();
                }
              }
              else
              {
                *(_OWORD *)std::string __p = *((_OWORD *)v5 + 2);
                uint64_t v29 = v5[6];
                uint64_t v32 = 0;
                memset(buf, 0, sizeof(buf));
                char v30 = 1;
              }
              (*(void (**)(uint64_t, uint64_t, void **, unint64_t))(*(void *)v24 + 16))(v24, v25, __p, *a3 | (unint64_t)&_mh_execute_header);
              if (v30 && SHIBYTE(v29) < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v32) < 0) {
                operator delete(*(void **)buf);
              }
            }
            sub_100A4863C((int *)a3, buf);
            uint64_t v32 = 0;
            memset(buf, 0, sizeof(buf));
            uint64_t v27 = v5[8];
            if (v27) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
            }
            sub_10112ECA4();
          }
        }
        else
        {
          if (!v12) {
            goto LABEL_30;
          }
          uint64_t v16 = v10;
          while (*(unsigned __int8 *)v15 == *v16)
          {
            uint64_t v15 = (const void **)((char *)v15 + 1);
            ++v16;
            if (!--v12) {
              goto LABEL_30;
            }
          }
        }
      }
      long long v17 = (void *)v5[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v5[2];
          BOOL v19 = *v18 == (void)v5;
          long long v5 = v18;
        }
        while (!v19);
      }
      long long v5 = v18;
    }
    while (v18 != v6);
  }
  long long v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v21 = (unsigned __int8 *)a2;
    }
    else {
      long long v21 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "SendFailure: Failed to find transactionID: [%{public}s]", buf, 0xCu);
  }
}

void sub_101134F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 && a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101134FE0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 360))
  {
    char v3 = (void **)(a1 + 336);
    sub_100155410(&v3);
  }
  return sub_1002B26E8(a1);
}

void sub_101135028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0;
  memset(__dst, 0, sizeof(__dst));
  sub_100CC8650(__dst, a4);
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  char v8 = sub_10112EF50(a1, v7);
  sub_100454248((uint64_t)v9, a4 + 56);
  sub_1011353A0((uint64_t)v10, a3, (uint64_t)__dst, v8, v9);
}

void sub_1011352B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_10004D2C8(v39);
  if (*(char *)(v40 - 137) < 0) {
    operator delete(*(void **)(v40 - 160));
  }
  if (*(char *)(v40 - 89) < 0) {
    operator delete(*(void **)(v40 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_1011353A0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, long long **a5)
{
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  memset(v23, 0, sizeof(v23));
  sub_1008DD030((uint64_t)v23);
  LOBYTE(v25) = a4;
  std::string::operator=((std::string *)&v23[1], (const std::string *)a3);
  *(void *)&long long v24 = *(void *)(a3 + 24);
  DWORD2(v24) = *(_DWORD *)(a3 + 32);
  uint64_t v22 = 0;
  *(_OWORD *)long long v20 = 0u;
  long long v21 = 0u;
  sub_1008DD0E8((uint64_t)v23, v20);
  v19[0] = 0;
  v19[1] = 0;
  BOOL v18 = v19;
  if (*((unsigned char *)a5 + 24))
  {
    uint64_t v11 = *a5;
    uint64_t v10 = a5[1];
    while (v11 != v10)
    {
      if (*((char *)v11 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)v11, *((void *)v11 + 1));
      }
      else
      {
        long long v12 = *v11;
        uint64_t v17 = *((void *)v11 + 2);
        *(_OWORD *)long long __dst = v12;
      }
      if (*((char *)v11 + 47) < 0)
      {
        sub_10004FC84(&__p, *((void **)v11 + 3), *((void *)v11 + 4));
      }
      else
      {
        long long v13 = *(long long *)((char *)v11 + 24);
        __p.__r_.__value_.__r.__words[2] = *((void *)v11 + 5);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v13;
      }
      sub_1010E707C((uint64_t)&v18, __dst, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(__dst[0]);
      }
      v11 += 3;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_100B964AC((uint64_t)v14, (uint64_t)&v18);
  sub_101135BFC(a1, a2, (long long *)v20, 2, (uint64_t)v14);
}

void sub_10113558C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_10010C0E0((uint64_t)&a10, a11);
  sub_10010C0E0((uint64_t)&a26, a27);
  if (a34 < 0) {
    operator delete(__p);
  }
  sub_10113D7A8(v34 - 144);
  _Unwind_Resume(a1);
}

void sub_101135610(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v22 = 0uLL;
  uint64_t v23 = 0;
  long long v7 = *(std::__shared_weak_count **)(a1 + 32);
  long long v20 = *(Registry **)(a1 + 24);
  long long v21 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10055FEB8(&v20, &v22);
  if (v21) {
    sub_10004D2C8(v21);
  }
  memset(v19, 0, sizeof(v19));
  sub_100BEC024(a4 + 8, v19);
  std::string::size_type size = HIBYTE(v19[1].__r_.__value_.__r.__words[2]);
  if ((v19[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v19[1].__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a4 + 31) >= 0) {
        uint64_t v10 = a4 + 8;
      }
      else {
        uint64_t v10 = *(void *)(a4 + 8);
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to find contribution id from: %{public}s", buf, 0xCu);
    }
    sub_100561B00((uint64_t)buf);
    if (SHIBYTE(v19[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19[1].__r_.__value_.__l.__data_);
    }
    v19[1] = *(std::string *)buf;
  }
  uint64_t v26 = 0;
  long long v25 = 0u;
  memset(buf, 0, sizeof(buf));
  *(_DWORD *)long long buf = *(_DWORD *)a4;
  if (SHIBYTE(v19[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf[8], v19[0].__r_.__value_.__l.__data_, v19[0].__r_.__value_.__l.__size_);
  }
  else {
    *(std::string *)&uint8_t buf[8] = v19[0];
  }
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(&v25, (void *)v22, *((unint64_t *)&v22 + 1));
  }
  else
  {
    long long v25 = v22;
    uint64_t v26 = v23;
  }
  uint64_t v18 = 0;
  *(_OWORD *)uint64_t v16 = 0u;
  long long v17 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10101236C(buf, v16);
  uint64_t v15 = 0;
  *(_OWORD *)long long v13 = 0u;
  long long v14 = 0u;
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v11 = v12;
  sub_101135BFC((uint64_t)v13, a3, (long long *)v16, -1, (uint64_t)&v11);
}

void sub_101135AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  sub_10004D2C8(v57);
  if (a48 < 0) {
    operator delete(__p);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  sub_100087784(v58 - 144);
  sub_1001085D8(v58 - 240);
  if (*(char *)(v58 - 145) < 0) {
    operator delete(*(void **)(v58 - 168));
  }
  _Unwind_Resume(a1);
}

void sub_101135BFC(uint64_t a1, uint64_t a2, long long *a3, int a4, uint64_t a5)
{
  sub_10113D7F8(a4, a5, *(unsigned __int8 *)(a2 + 96));
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  sub_100B8ED00((uint64_t)v9, a2, a3, a5);
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_100B8EF9C((uint64_t)v9);
}

void sub_101135CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(char *)(v9 + 23) < 0) {
    operator delete(*(void **)v9);
  }
  sub_10113D654((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_101135D00(uint64_t a1, uint64_t a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 40);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_101135D94(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101135DA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5)
  {
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    int8x16_t v31 = *(int8x16_t *)a4;
    sub_1000593FC((uint64_t)&v32, (long long *)(a4 + 16));
    sub_1001FD3D8((uint64_t)v35, a4 + 48);
    sub_100454248((uint64_t)v36, a4 + 80);
    sub_100155178((uint64_t)&v31, &v37);
    if (v36[24])
    {
      *(void *)&long long v28 = v36;
      sub_100155410((void ***)&v28);
    }
    if (v35[24])
    {
      *(void *)&long long v28 = v35;
      sub_100155494((void ***)&v28);
    }
    if (v34 && v33 < 0) {
      operator delete(v32);
    }
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    if (SBYTE7(v38) < 0)
    {
      sub_10004FC84(&v24, (void *)v37, *((unint64_t *)&v37 + 1));
    }
    else
    {
      long long v24 = v37;
      uint64_t v25 = v38;
    }
    uint64_t v26 = *((void *)&v38 + 1);
    int v27 = v39;
    char v13 = sub_10112EF50(a1, (uint64_t *)v39);
    sub_100454248((uint64_t)v23, a4 + 80);
    sub_1011353A0((uint64_t)&v28, a3, (uint64_t)&v24, v13, v23);
  }
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  char v8 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v21 = *(void *)(a1 + 24);
  long long v22 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a3 + 55) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    long long __dst = *(_OWORD *)(a3 + 32);
    uint64_t v17 = *(void *)(a3 + 48);
  }
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long __p = *(_OWORD *)(a3 + 8);
    uint64_t v19 = *(void *)(a3 + 24);
  }
  int8x16_t v20 = vextq_s8(*(int8x16_t *)a4, *(int8x16_t *)a4, 8uLL);
  sub_100CC695C((uint64_t)&v21, (uint64_t)&__dst, &v37);
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)__dst);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  *((void *)&v24 + 1) = 0;
  uint64_t v25 = 0;
  *(void *)&long long v24 = (char *)&v24 + 8;
  if (*(unsigned char *)(a4 + 104))
  {
    uint64_t v9 = *(long long **)(a4 + 80);
    uint64_t v10 = *(long long **)(a4 + 88);
    while (v9 != v10)
    {
      if (*((char *)v9 + 23) < 0)
      {
        sub_10004FC84(&v28, *(void **)v9, *((void *)v9 + 1));
      }
      else
      {
        long long v11 = *v9;
        *(void *)&long long v29 = *((void *)v9 + 2);
        long long v28 = v11;
      }
      if (*((char *)v9 + 47) < 0)
      {
        sub_10004FC84(&v15, *((void **)v9 + 3), *((void *)v9 + 4));
      }
      else
      {
        long long v12 = *(long long *)((char *)v9 + 24);
        v15.__r_.__value_.__r.__words[2] = *((void *)v9 + 5);
        *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v12;
      }
      sub_1010E707C((uint64_t)&v24, (void **)&v28, &v15);
      if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v15.__r_.__value_.__l.__data_);
      }
      if (SBYTE7(v29) < 0) {
        operator delete((void *)v28);
      }
      v9 += 3;
    }
  }
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  sub_100B964AC((uint64_t)v14, (uint64_t)&v24);
  sub_101135BFC((uint64_t)&v28, a3, &v37, 2, (uint64_t)v14);
}

void sub_101136380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  if (a72 < 0) {
    operator delete(__p);
  }
  sub_10010C0E0((uint64_t)&a61, (void *)a62);
  if (*(char *)(v72 - 105) < 0) {
    operator delete(*(void **)(v72 - 128));
  }
  _Unwind_Resume(a1);
}

void sub_1011365D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int8x16_t v20 = &v21;
  sub_100058DB0(v14, "cpm.Payload-Type");
  if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&__dst, v14[0].__r_.__value_.__l.__data_, v14[0].__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&v14[0].__r_.__value_.__l.__data_;
    *(void *)&long long v16 = *((void *)&v14[0].__r_.__value_.__l + 2);
  }
  sub_100058DB0(&v18, "text/plain;charset=UTF-8");
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v19, v18.__r_.__value_.__l.__data_, v18.__r_.__value_.__l.__size_);
  }
  else {
    std::string v19 = v18;
  }
  sub_1010E707C((uint64_t)&v20, (void **)&__dst, &v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v16) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14[0].__r_.__value_.__l.__data_);
  }
  sub_100058DB0(v14, "NS");
  if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&__dst, v14[0].__r_.__value_.__l.__data_, v14[0].__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&v14[0].__r_.__value_.__l.__data_;
    *(void *)&long long v16 = *((void *)&v14[0].__r_.__value_.__l + 2);
  }
  sub_100058DB0(&v18, "cpm <http://www.openmobilealliance.org/cpm/>");
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v19, v18.__r_.__value_.__l.__data_, v18.__r_.__value_.__l.__size_);
  }
  else {
    std::string v19 = v18;
  }
  sub_1010E707C((uint64_t)&v20, (void **)&__dst, &v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v16) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14[0].__r_.__value_.__l.__data_);
  }
  if (*(unsigned char *)(a4 + 304))
  {
    uint64_t v7 = *(long long **)(a4 + 280);
    char v8 = *(long long **)(a4 + 288);
    while (v7 != v8)
    {
      if (*((char *)v7 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)v7, *((void *)v7 + 1));
      }
      else
      {
        long long v9 = *v7;
        *(void *)&long long v16 = *((void *)v7 + 2);
        long long __dst = v9;
      }
      if (*((char *)v7 + 47) < 0)
      {
        sub_10004FC84(v14, *((void **)v7 + 3), *((void *)v7 + 4));
      }
      else
      {
        long long v10 = *(long long *)((char *)v7 + 24);
        v14[0].__r_.__value_.__r.__words[2] = *((void *)v7 + 5);
        *(_OWORD *)&v14[0].__r_.__value_.__l.__data_ = v10;
      }
      sub_1010E707C((uint64_t)&v20, (void **)&__dst, v14);
      if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v14[0].__r_.__value_.__l.__data_);
      }
      if (SBYTE7(v16) < 0) {
        operator delete((void *)__dst);
      }
      v7 += 3;
    }
  }
  uint64_t v17 = 0;
  long long __dst = 0u;
  long long v16 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10045449C(v13, a4);
  sub_100463B30((uint64_t)v13, v14);
  long long v11 = v20;
  v12[0] = v21;
  v12[1] = v22;
  if (v22)
  {
    *(void *)(v21 + 16) = v12;
    int8x16_t v20 = &v21;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  else
  {
    long long v11 = v12;
  }
  sub_101135BFC((uint64_t)&__dst, a3, (long long *)v14, 2, (uint64_t)&v11);
}

void sub_101136AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,char a37)
{
  sub_10004D2C8(v37);
  if (*(char *)(v38 - 153) < 0) {
    operator delete(*(void **)(v38 - 176));
  }
  sub_10010C0E0(v38 - 88, *(void **)(v38 - 80));
  _Unwind_Resume(a1);
}

uint64_t sub_101136C44(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  if (*(unsigned char *)(a4 + 80))
  {
    if (*(char *)(a4 + 79) < 0)
    {
      sub_10004FC84(__str, *(void **)(a4 + 56), *(void *)(a4 + 64));
    }
    else
    {
      *(_OWORD *)std::string __str = *(_OWORD *)(a4 + 56);
      *(void *)&__str[16] = *(void *)(a4 + 72);
    }
  }
  else
  {
    sub_100058DB0(__str, "");
  }
  std::string::operator=((std::string *)&v27, (const std::string *)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (*(unsigned char *)(a4 + 48))
  {
    if (*(char *)(a4 + 47) < 0)
    {
      sub_10004FC84(__str, *(void **)(a4 + 24), *(void *)(a4 + 32));
    }
    else
    {
      *(_OWORD *)std::string __str = *(_OWORD *)(a4 + 24);
      *(void *)&__str[16] = *(void *)(a4 + 40);
    }
  }
  else
  {
    sub_100058DB0(__str, "");
  }
  std::string::operator=((std::string *)((char *)&v25 + 8), (const std::string *)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  LODWORD(v25) = *(unsigned __int8 *)(a4 + 16);
  uint64_t v8 = 120;
  if (*(unsigned char *)(a4 + 8)) {
    uint64_t v8 = *(void *)a4;
  }
  *((void *)&v28 + 1) = v8;
  uint64_t v24 = 0;
  memset(__str, 0, sizeof(__str));
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10114DA14((uint64_t)&v25, __str);
  LODWORD(v24) = 2;
  long long v9 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_101A93638;
  sub_1012D612C(&v9[1].__vftable, a3 + 32, (long long *)(a3 + 168), (long long *)a4);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(a3 + 8);
    uint64_t v22 = *(void *)(a3 + 24);
  }
  v20[0] = v9 + 1;
  v20[1] = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_100058DB0(v17, "application/im-iscomposing+xml");
  char v19 = 1;
  LOBYTE(v14) = 0;
  char v16 = 0;
  LOBYTE(__p) = 0;
  char v13 = 0;
  sub_10112E09C(a1, a2, (const void **)__dst, (char *)(a3 + 32), v20, (uint64_t)__str, (const char *)v17, (const char *)&v14, (uint64_t)&__p);
  if (v13 && v12 < 0) {
    operator delete(__p);
  }
  if (v16 && v15 < 0) {
    operator delete(v14);
  }
  if (v19 && v18 < 0) {
    operator delete(v17[0]);
  }
  sub_10004D2C8(v9);
  if (SHIBYTE(v22) < 0) {
    operator delete(__dst[0]);
  }
  sub_10004D2C8(v9);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (SBYTE7(v28) < 0) {
    operator delete((void *)v27);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(*((void **)&v25 + 1));
  }
  return 0;
}

void sub_101136F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_10004D2C8(v46);
  if (a46 < 0) {
    operator delete(__p);
  }
  sub_100087784(v47 - 128);
  _Unwind_Resume(a1);
}

void sub_101137018(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = 42;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Battery remaining in minutes: %u", buf, 8u);
  }
  uint64_t v5 = 0;
  *(_OWORD *)long long buf = 0u;
  long long v4 = 0u;
  LODWORD(v2) = 42;
  sub_10112D018();
}

void sub_1011372DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41)
{
  sub_10004D2C8(v41);
  if (*(char *)(v42 - 137) < 0) {
    operator delete(*(void **)(v42 - 160));
  }
  if (*(char *)(v42 - 89) < 0) {
    operator delete(*(void **)(v42 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_1011373B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset((char *)&v5[4] + 8, 0, 24);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long __dst = *(_OWORD *)(a3 + 8);
    *(void *)&long long v4 = *(void *)(a3 + 24);
  }
  sub_100CC85C0(v5, (uint64_t)&__dst);
  sub_100CC7D60();
}

void sub_101137704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  sub_10004D2C8(v52);
  if (*(char *)(v53 - 185) < 0) {
    operator delete(*(void **)(v53 - 208));
  }
  sub_1001085D8(v53 - 160);
  if (*(char *)(v53 - 89) < 0) {
    operator delete(*(void **)(v53 - 112));
  }
  if (*(char *)(v53 - 65) < 0) {
    operator delete(*(void **)(v53 - 88));
  }
  _Unwind_Resume(a1);
}

void sub_101137820()
{
}

void sub_101137828()
{
  if (*(char *)(v0 - 137) < 0) {
    JUMPOUT(0x101137804);
  }
  JUMPOUT(0x101137808);
}

void sub_10113783C()
{
}

void sub_101137844()
{
  if (*(char *)(v0 - 137) < 0) {
    operator delete(*(void **)(v0 - 160));
  }
  if (*(char *)(v0 - 185) < 0) {
    JUMPOUT(0x101137814);
  }
  JUMPOUT(0x101137818);
}

void sub_101137870(os_log_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int8x16_t v20 = &v21;
  sub_100058DB0(&v16, "NS");
  if (SBYTE7(v17) < 0)
  {
    sub_10004FC84(__p, (void *)v16, *((unint64_t *)&v16 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = v16;
    uint64_t v11 = v17;
  }
  sub_100058DB0(&v19, "cpm <http://www.openmobilealliance.org/cpm/>");
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(__dst, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
  }
  else {
    __dst[0] = v19;
  }
  sub_1010E707C((uint64_t)&v20, __p, __dst);
  if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v17) < 0) {
    operator delete((void *)v16);
  }
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    uint64_t v11 = *(void *)(a4 + 16);
  }
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(v12, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    *(_OWORD *)char v12 = *(_OWORD *)(a4 + 24);
    uint64_t v7 = *(uint64_t **)(a4 + 40);
    char v13 = v7;
  }
  BOOL v14 = sub_10112EF50((uint64_t)a1, v7);
  sub_1000BE3B8(a1, (uint64_t *)__p, (uint64_t)__dst);
  uint64_t v8 = v20;
  v9[0] = v21;
  v9[1] = v22;
  if (v22)
  {
    *(void *)(v21 + 16) = v9;
    int8x16_t v20 = &v21;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  else
  {
    uint64_t v8 = v9;
  }
  sub_101135BFC((uint64_t)&v16, a3, (long long *)__dst, 2, (uint64_t)&v8);
}

void sub_101137C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a25 && a24 < 0) {
    operator delete(__p);
  }
  if (a32 && a31 < 0) {
    operator delete(a26);
  }
  sub_10004D2C8(v49);
  if (*(char *)(v50 - 185) < 0) {
    operator delete(*(void **)(v50 - 208));
  }
  sub_1001085D8((uint64_t)&a38);
  sub_10004D2C8(v49);
  if (*(char *)(v50 - 137) < 0) {
    operator delete(*(void **)(v50 - 160));
  }
  sub_10010C0E0(v50 - 88, *(void **)(v50 - 80));
  _Unwind_Resume(a1);
}

void sub_101137DC8(os_log_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int8x16_t v20 = &v21;
  sub_100058DB0(&v16, "NS");
  if (SBYTE7(v17) < 0)
  {
    sub_10004FC84(__p, (void *)v16, *((unint64_t *)&v16 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = v16;
    uint64_t v11 = v17;
  }
  sub_100058DB0(&v19, "cpm <http://www.openmobilealliance.org/cpm/>");
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(__dst, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
  }
  else {
    __dst[0] = v19;
  }
  sub_1010E707C((uint64_t)&v20, __p, __dst);
  if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v17) < 0) {
    operator delete((void *)v16);
  }
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    uint64_t v11 = *(void *)(a4 + 16);
  }
  if (*(char *)(a4 + 47) < 0)
  {
    sub_10004FC84(v12, *(void **)(a4 + 24), *(void *)(a4 + 32));
  }
  else
  {
    *(_OWORD *)char v12 = *(_OWORD *)(a4 + 24);
    uint64_t v7 = *(uint64_t **)(a4 + 40);
    char v13 = v7;
  }
  BOOL v14 = sub_10112EF50((uint64_t)a1, v7);
  sub_1000BEAA0(a1, (uint64_t *)__p, (uint64_t)__dst);
  uint64_t v8 = v20;
  v9[0] = v21;
  v9[1] = v22;
  if (v22)
  {
    *(void *)(v21 + 16) = v9;
    int8x16_t v20 = &v21;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  else
  {
    uint64_t v8 = v9;
  }
  sub_101135BFC((uint64_t)&v16, a3, (long long *)__dst, 2, (uint64_t)&v8);
}

void sub_1011381A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a25 && a24 < 0) {
    operator delete(__p);
  }
  if (a32 && a31 < 0) {
    operator delete(a26);
  }
  sub_10004D2C8(v49);
  if (*(char *)(v50 - 185) < 0) {
    operator delete(*(void **)(v50 - 208));
  }
  sub_1001085D8((uint64_t)&a38);
  sub_10004D2C8(v49);
  if (*(char *)(v50 - 137) < 0) {
    operator delete(*(void **)(v50 - 160));
  }
  sub_10010C0E0(v50 - 88, *(void **)(v50 - 80));
  _Unwind_Resume(a1);
}

void sub_101138320(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  sub_100CC8650(v11, a4);
  uint64_t v10 = 0;
  *(_OWORD *)uint64_t v8 = 0u;
  long long v9 = 0u;
  sub_10112EF50(a1, v6);
  sub_100454248((uint64_t)v7, a4 + 56);
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long __dst = 0u;
  long long v15 = 0u;
  sub_100CC786C();
}

void sub_101138650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  sub_10004D2C8(v43);
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  _Unwind_Resume(a1);
}

void sub_1011387A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  long long v9 = *(std::__shared_weak_count **)(a1 + 32);
  long long v26 = *(Registry **)(a1 + 24);
  long long v27 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10055FEB8(&v26, &v28);
  if (v27) {
    sub_10004D2C8(v27);
  }
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)long long v24 = 0u;
  sub_100BEC024(a5 + 8, (std::string *)v24);
  uint64_t v10 = (void *)HIBYTE(__p[3]);
  if (SHIBYTE(__p[3]) < 0) {
    uint64_t v10 = __p[2];
  }
  if (!v10)
  {
    uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a5 + 31) >= 0) {
        uint64_t v12 = a5 + 8;
      }
      else {
        uint64_t v12 = *(void *)(a5 + 8);
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to find contribution id from: %{public}s", buf, 0xCu);
    }
    sub_100561B00((uint64_t)buf);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    *(_OWORD *)&__p[1] = *(_OWORD *)buf;
    __p[3] = (void *)v31;
  }
  uint64_t v23 = 0;
  *(_OWORD *)long long v22 = 0u;
  memset(v21, 0, sizeof(v21));
  LODWORD(v21[0]) = *(_DWORD *)a5;
  if (SHIBYTE(__p[0]) < 0)
  {
    sub_10004FC84(&v21[1], v24[0], (unint64_t)v24[1]);
  }
  else
  {
    *(_OWORD *)&v21[1] = *(_OWORD *)v24;
    v21[3] = __p[0];
  }
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(v22, (void *)v28, *((unint64_t *)&v28 + 1));
  }
  else
  {
    *(_OWORD *)long long v22 = v28;
    uint64_t v23 = v29;
  }
  uint64_t v20 = 0;
  *(_OWORD *)long long v18 = 0u;
  long long v19 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10101236C(v21, v18);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v31 = 0u;
  sub_100CC7114(v15, a4);
  sub_100CC8CB8(buf, a3 + 8, (long long *)v15, a3 + 32, a3 + 56, *(unsigned char *)(a3 + 96));
  if (SBYTE7(v16) < 0) {
    operator delete(v15[0]);
  }
  uint64_t v17 = 0;
  *(_OWORD *)long long v15 = 0u;
  long long v16 = 0u;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v13 = v14;
  sub_101135BFC((uint64_t)v15, (uint64_t)buf, (long long *)v18, -1, (uint64_t)&v13);
}

void sub_101138CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10004D2C8(v72);
  if (a36 < 0) {
    operator delete(__p);
  }
  sub_100CC8E78((uint64_t)&a72);
  if (a45 < 0) {
    operator delete(a40);
  }
  sub_100087784((uint64_t)&a49);
  sub_1001085D8((uint64_t)&a57);
  if (a71 < 0) {
    operator delete(a66);
  }
  _Unwind_Resume(a1);
}

void sub_101138E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[0] = 0;
  v20[1] = 0;
  long long v19 = v20;
  sub_100058DB0(v13, "cpm.Payload-Type");
  if (SHIBYTE(v13[0].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&__dst, v13[0].__r_.__value_.__l.__data_, v13[0].__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&v13[0].__r_.__value_.__l.__data_;
    *(void *)&long long v15 = *((void *)&v13[0].__r_.__value_.__l + 2);
  }
  sub_100058DB0(&v17, "text/plain;charset=UTF-8");
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v18, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
  }
  else {
    std::string v18 = v17;
  }
  sub_1010E707C((uint64_t)&v19, (void **)&__dst, &v18);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v15) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v13[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13[0].__r_.__value_.__l.__data_);
  }
  sub_100058DB0(v13, "NS");
  if (SHIBYTE(v13[0].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&__dst, v13[0].__r_.__value_.__l.__data_, v13[0].__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&v13[0].__r_.__value_.__l.__data_;
    *(void *)&long long v15 = *((void *)&v13[0].__r_.__value_.__l + 2);
  }
  sub_100058DB0(&v17, "cpm <http://www.openmobilealliance.org/cpm/>");
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v18, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
  }
  else {
    std::string v18 = v17;
  }
  sub_1010E707C((uint64_t)&v19, (void **)&__dst, &v18);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v15) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v13[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13[0].__r_.__value_.__l.__data_);
  }
  if (*(unsigned char *)(a4 + 304))
  {
    uint64_t v7 = *(long long **)(a4 + 280);
    uint64_t v8 = *(long long **)(a4 + 288);
    while (v7 != v8)
    {
      if (*((char *)v7 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)v7, *((void *)v7 + 1));
      }
      else
      {
        long long v9 = *v7;
        *(void *)&long long v15 = *((void *)v7 + 2);
        long long __dst = v9;
      }
      if (*((char *)v7 + 47) < 0)
      {
        sub_10004FC84(v13, *((void **)v7 + 3), *((void *)v7 + 4));
      }
      else
      {
        long long v10 = *(long long *)((char *)v7 + 24);
        v13[0].__r_.__value_.__r.__words[2] = *((void *)v7 + 5);
        *(_OWORD *)&v13[0].__r_.__value_.__l.__data_ = v10;
      }
      sub_1010E707C((uint64_t)&v19, (void **)&__dst, v13);
      if (SHIBYTE(v13[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v13[0].__r_.__value_.__l.__data_);
      }
      if (SBYTE7(v15) < 0) {
        operator delete((void *)__dst);
      }
      v7 += 3;
    }
  }
  uint64_t v16 = 0;
  long long __dst = 0u;
  long long v15 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10045449C(v12, a4);
  sub_100463B30((uint64_t)v12, v13);
  sub_100B964AC((uint64_t)v11, (uint64_t)&v19);
  sub_101139464((uint64_t)&__dst, a3, (uint64_t)v13, (uint64_t)v11);
}

void sub_1011392DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,char a37)
{
  sub_10004D2C8(v37);
  if (*(char *)(v38 - 153) < 0) {
    operator delete(*(void **)(v38 - 176));
  }
  sub_10010C0E0(v38 - 88, *(void **)(v38 - 80));
  _Unwind_Resume(a1);
}

void sub_101139464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_10113D7F8(2, a4, *(unsigned __int8 *)(a2 + 96));
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  sub_100CC786C();
}

void sub_1011395B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p)
{
  if (*(char *)(v9 + 23) < 0) {
    operator delete(*(void **)v9);
  }
  sub_10113D654((uint64_t)&__p);
  sub_100CC8E78(v10 - 240);
  _Unwind_Resume(a1);
}

void sub_101139620(uint64_t a1, uint64_t a2, uint64_t a3, int8x16_t *a4)
{
  memset(v14, 0, 40);
  long long v6 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 24);
  long long v13 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a3 + 55) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    long long __dst = *(_OWORD *)(a3 + 32);
    uint64_t v8 = *(void *)(a3 + 48);
  }
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(&v9, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v9 = *(_OWORD *)(a3 + 8);
    uint64_t v10 = *(void *)(a3 + 24);
  }
  int8x16_t v11 = vextq_s8(*a4, *a4, 8uLL);
  sub_100CC695C((uint64_t)&v12, (uint64_t)&__dst, v14);
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete((void *)__dst);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100CC786C();
}

void sub_1011399FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,void *a52,int a53,__int16 a54,char a55,char a56,char a57)
{
  sub_10004D2C8(v57);
  if (a41 < 0) {
    operator delete(__p);
  }
  sub_10010C0E0((uint64_t)&a51, a52);
  sub_100CC8E78((uint64_t)&a57);
  if (*(char *)(v58 - 121) < 0) {
    operator delete(*(void **)(v58 - 144));
  }
  _Unwind_Resume(a1);
}

void sub_101139B74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  sub_100CC8650(v21, a4);
  memset(v20, 0, sizeof(v20));
  sub_100CC8CB8(v20, a3 + 8, (long long *)(a3 + 168), a3 + 32, a3 + 56, *(unsigned char *)(a3 + 96));
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)__srCC_SHA1_CTX c = 0u;
  long long v16 = 0u;
  *(_OWORD *)long long v13 = 0u;
  long long v14 = 0u;
  sub_10045F708((void *)(a3 + 192), v13);
  uint64_t v12 = 0;
  *(_OWORD *)uint64_t v10 = 0u;
  long long v11 = 0u;
  char v8 = sub_10112EF50(a1, v7);
  sub_100454248((uint64_t)v9, a4 + 56);
  sub_1011353A0((uint64_t)v10, (uint64_t)v20, (uint64_t)v21, v8, v9);
}

void sub_101139FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10004D2C8(v72);
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v72);
  sub_1002E4140((uint64_t)&a34);
  sub_10113A1B8((uint64_t)&a44);
  if (SLOBYTE(STACK[0x207]) < 0) {
    operator delete(a72);
  }
  sub_10113A168((uint64_t)&STACK[0x220]);
  sub_100CC8E78((uint64_t)&STACK[0x290]);
  if (*(char *)(v73 - 105) < 0) {
    operator delete(*(void **)(v73 - 128));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10113A168(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10113A1B8(uint64_t a1)
{
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  sub_10010C0E0(a1 + 80, *(void **)(a1 + 88));
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10113A234(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  long long v7 = (long long *)(a3 + 8);
  memset(v53, 0, 192);
  char v8 = (long long *)(a3 + 168);
  uint64_t v9 = a3 + 32;
  sub_100CC8CB8(v53, a3 + 8, (long long *)(a3 + 168), a3 + 32, a3 + 56, *(unsigned char *)(a3 + 96));
  uint64_t v10 = operator new(0xF8uLL);
  v10[1] = 0;
  _OWORD v10[2] = 0;
  void *v10 = off_101A93958;
  sub_1012D6ADC(v10 + 3, v9, (long long **)(a3 + 192), v8, a4);
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  *(_OWORD *)__srCC_SHA1_CTX c = 0u;
  long long v49 = 0u;
  *(_OWORD *)uint64_t v46 = 0u;
  long long v47 = 0u;
  sub_10045F708((void *)(a3 + 192), v46);
  uint64_t v45 = 0;
  *(_OWORD *)uint64_t v43 = 0u;
  long long v44 = 0u;
  if (*(unsigned char *)(a3 + 96))
  {
    v22[0] = 0;
    *(_OWORD *)uint64_t v20 = 0uLL;
    long long v21 = 0uLL;
    long long v11 = *(std::__shared_weak_count **)(a1 + 32);
    uint64_t v30 = *(void *)(a1 + 24);
    long long v31 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(a3 + 55) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v9;
      uint64_t v26 = *(void *)(v9 + 16);
    }
    if (*(char *)(a3 + 31) < 0)
    {
      sub_10004FC84(&v27, *(void **)(a3 + 8), *(void *)(a3 + 16));
    }
    else
    {
      long long v27 = *v7;
      uint64_t v28 = *((void *)v7 + 2);
    }
    int8x16_t v29 = vextq_s8(*(int8x16_t *)a4, *(int8x16_t *)a4, 8uLL);
    sub_100CC695C((uint64_t)&v30, (uint64_t)__dst, v20);
    if (SHIBYTE(v28) < 0) {
      operator delete((void *)v27);
    }
    if (SHIBYTE(v26) < 0) {
      operator delete(__dst[0]);
    }
    if (v31) {
      sub_10004D2C8(v31);
    }
    uint64_t v34 = 0;
    v33[1] = 0;
    v33[0] = &v33[1];
    if (*((unsigned char *)a4 + 104))
    {
      long long v13 = (long long *)*((void *)a4 + 10);
      long long v14 = (long long *)*((void *)a4 + 11);
      while (v13 != v14)
      {
        if (*((char *)v13 + 23) < 0)
        {
          sub_10004FC84(v18, *(void **)v13, *((void *)v13 + 1));
        }
        else
        {
          long long v15 = *v13;
          *(void *)&long long v19 = *((void *)v13 + 2);
          *(_OWORD *)long long v18 = v15;
        }
        if (*((char *)v13 + 47) < 0)
        {
          sub_10004FC84(&v24, *((void **)v13 + 3), *((void *)v13 + 4));
        }
        else
        {
          long long v16 = *(long long *)((char *)v13 + 24);
          v24.__r_.__value_.__r.__words[2] = *((void *)v13 + 5);
          *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v16;
        }
        sub_1010E707C((uint64_t)v33, v18, &v24);
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v24.__r_.__value_.__l.__data_);
        }
        if (SBYTE7(v19) < 0) {
          operator delete(v18[0]);
        }
        v13 += 3;
      }
    }
    sub_100B964AC((uint64_t)v23, (uint64_t)v33);
    sub_101135BFC((uint64_t)v18, (uint64_t)v53, (long long *)v20, 2, (uint64_t)v23);
  }
  v22[0] = 0;
  *(_OWORD *)uint64_t v20 = 0uLL;
  long long v21 = 0uLL;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  int8x16_t v37 = (int8x16_t)*a4;
  sub_1000593FC((uint64_t)&__p, a4 + 1);
  sub_1001FD3D8((uint64_t)v41, (uint64_t)(a4 + 3));
  uint64_t v12 = (uint64_t)(a4 + 5);
  sub_100454248((uint64_t)v42, v12);
  sub_100155178((uint64_t)&v37, v20);
  if (v42[24])
  {
    v18[0] = v42;
    sub_100155410((void ***)v18);
  }
  if (v41[24])
  {
    v18[0] = v41;
    sub_100155494((void ***)v18);
  }
  if (v40 && v39 < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v21) < 0)
  {
    sub_10004FC84(v33, v20[0], (unint64_t)v20[1]);
  }
  else
  {
    *(_OWORD *)long long v33 = *(_OWORD *)v20;
    uint64_t v34 = v21;
  }
  uint64_t v35 = *((void *)&v21 + 1);
  int v36 = (int)v22[0];
  char v17 = sub_10112EF50(a1, (uint64_t *)LODWORD(v22[0]));
  sub_100454248((uint64_t)v32, v12);
  sub_1011353A0((uint64_t)v18, (uint64_t)v53, (uint64_t)v33, v17, v32);
}

void sub_10113A988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  sub_10113A168((uint64_t)&STACK[0x320]);
  sub_10004D2C8(v40);
  sub_100CC8E78((uint64_t)&STACK[0x390]);
  _Unwind_Resume(a1);
}

void sub_10113AC14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v33, 0, 192);
  long long v7 = (long long *)(a3 + 168);
  uint64_t v8 = a3 + 32;
  sub_100CC8CB8(v33, a3 + 8, (long long *)(a3 + 168), a3 + 32, a3 + 56, *(unsigned char *)(a3 + 96));
  uint64_t v9 = operator new(0x1C0uLL);
  v9[1] = 0;
  void v9[2] = 0;
  *uint64_t v9 = off_101A939A8;
  sub_1012D6C08(v9 + 3, v8, (long long **)(a3 + 192), v7, a4);
  uint64_t v32 = 0;
  uint64_t v31 = 0;
  uint64_t v30 = &v31;
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)__srCC_SHA1_CTX c = 0u;
  long long v26 = 0u;
  *(_OWORD *)uint64_t v23 = 0u;
  long long v24 = 0u;
  sub_10045F708((void *)(a3 + 192), v23);
  if (*(unsigned char *)(a4 + 304))
  {
    uint64_t v10 = *(long long **)(a4 + 280);
    long long v11 = *(long long **)(a4 + 288);
    while (v10 != v11)
    {
      if (*((char *)v10 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)v10, *((void *)v10 + 1));
      }
      else
      {
        long long v12 = *v10;
        *(void *)&long long v16 = *((void *)v10 + 2);
        *(_OWORD *)long long __dst = v12;
      }
      if (*((char *)v10 + 47) < 0)
      {
        sub_10004FC84(&__p, *((void **)v10 + 3), *((void *)v10 + 4));
      }
      else
      {
        long long v13 = *(long long *)((char *)v10 + 24);
        __p.__r_.__value_.__r.__words[2] = *((void *)v10 + 5);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v13;
      }
      sub_1010E707C((uint64_t)&v30, __dst, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SBYTE7(v16) < 0) {
        operator delete(__dst[0]);
      }
      v10 += 3;
    }
  }
  uint64_t v22 = 0;
  *(_OWORD *)uint64_t v20 = 0u;
  long long v21 = 0u;
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  sub_10045449C(v19, a4);
  sub_100463B30((uint64_t)v19, __dst);
  char v17 = v30;
  v18[0] = v31;
  v18[1] = v32;
  if (v32)
  {
    *(void *)(v31 + 16) = v18;
    uint64_t v30 = &v31;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
  }
  else
  {
    char v17 = v18;
  }
  sub_101135BFC((uint64_t)v20, (uint64_t)v33, (long long *)__dst, 2, (uint64_t)&v17);
}

void sub_10113B1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42)
{
  sub_10004D2C8(v42);
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_1002E4140((uint64_t)&a32);
  sub_10113A1B8((uint64_t)&a42);
  if (SLOBYTE(STACK[0x2E7]) < 0) {
    operator delete((void *)STACK[0x2D0]);
  }
  sub_10113A168((uint64_t)&STACK[0x300]);
  sub_10010C0E0((uint64_t)&STACK[0x368], (void *)STACK[0x370]);
  sub_10004D2C8(v42);
  sub_100CC8E78((uint64_t)&STACK[0x380]);
  _Unwind_Resume(a1);
}

void sub_10113B3A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, long long *a6)
{
  sub_100058DB0(__p, "message/cpim");
  BOOL v12 = sub_1010E5F80(a4, (uint64_t)__p);
  BOOL v13 = v12;
  if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
  {
    if (v12) {
      goto LABEL_3;
    }
LABEL_16:
    char v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a4 + 23) >= 0) {
        long long v24 = (void *)a4;
      }
      else {
        long long v24 = *(void **)a4;
      }
      LODWORD(__p[0]) = 136446210;
      *(void **)((char *)__p + 4) = v24;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Unhandled content type (non CPIM): %{public}s", (uint8_t *)__p, 0xCu);
    }
    sub_10112F2C0();
  }
  operator delete(__p[0]);
  if (!v13) {
    goto LABEL_16;
  }
LABEL_3:
  uint64_t v84 = 0;
  *(_OWORD *)long long v82 = 0u;
  long long v83 = 0u;
  long long v14 = *(std::__shared_weak_count **)(a1 + 32);
  long long v80 = *(Registry **)(a1 + 24);
  long long v81 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10055FEB8(&v80, __p);
  sub_100CC89EC(v82, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (v81) {
    sub_10004D2C8(v81);
  }
  uint64_t v130 = 0;
  long long v129 = 0u;
  long long v128 = 0u;
  memset(v127, 0, sizeof(v127));
  long long v126 = 0u;
  long long v125 = 0u;
  long long v124 = 0u;
  long long v123 = 0u;
  long long v122 = 0u;
  long long v121 = 0u;
  long long v120 = 0u;
  long long v119 = 0u;
  long long v118 = 0u;
  long long v117 = 0u;
  memset(__p, 0, sizeof(__p));
  sub_100B8EBC0((uint64_t)__p);
  BOOL v15 = sub_100B8F6E4((uint64_t)__p, (Registry **)(a1 + 24), a3);
  sub_100B907E0((uint64_t)__p, 1);
  if (!v15)
  {
    long long v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to decode CPIM content", buf, 2u);
    }
    sub_10112F2C0();
  }
  int v16 = sub_101012EBC((void *)v127 + 1);
  *(_OWORD *)__srCC_SHA1_CTX c = 0u;
  long long v79 = 0u;
  sub_101013080((void *)v127 + 1, (uint64_t)__src);
  if (!BYTE8(v79))
  {
    sub_100561B00((uint64_t)buf);
    if (BYTE8(v79))
    {
      if (SBYTE7(v79) < 0) {
        operator delete(__src[0]);
      }
      *(_OWORD *)__srCC_SHA1_CTX c = *(_OWORD *)buf;
      *(void *)&long long v79 = *(void *)&buf[16];
    }
    else
    {
      *(_OWORD *)__srCC_SHA1_CTX c = *(_OWORD *)buf;
      *(void *)&long long v79 = *(void *)&buf[16];
      BYTE8(v79) = 1;
    }
    long long v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      if (!BYTE8(v79)) {
        sub_10016C840();
      }
      uint64_t v29 = __src;
      if (SBYTE7(v79) < 0) {
        uint64_t v29 = (void **)__src[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing incoming message ID - created a new one: %s", buf, 0xCu);
    }
  }
  if (!*(unsigned char *)(a2 + 168))
  {
    uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Bailing out. Missing Focus", buf, 2u);
    }
    sub_100058DB0(buf, "bad input");
    uint8_t buf[24] = 1;
    sub_10112F058();
  }
  long long v76 = 0uLL;
  uint64_t v77 = 0;
  sub_100CC7114(&v76, a2 + 120);
  if (SHIBYTE(__p[3]) < 0)
  {
    sub_10004FC84(buf, __p[1], (unint64_t)__p[2]);
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)&__p[1];
    *(void **)&uint8_t buf[16] = __p[3];
  }
  sub_100B90DB8((uint64_t)__p);
  char v74 = 0;
  char v75 = 0;
  sub_10112FF10(a1, (uint64_t)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  *(_OWORD *)uint64_t v72 = 0u;
  long long v73 = 0u;
  sub_101132F54(v72, (uint64_t)__p);
  if (BYTE8(v73)) {
    sub_100562588();
  }
  long long v70 = 0u;
  long long v71 = 0u;
  *(_OWORD *)int v68 = 0u;
  long long v69 = 0u;
  sub_10113394C((char *)v68, (uint64_t)__p);
  if (BYTE8(v71))
  {
    memset(v105, 0, 56);
    sub_1010122A4((int *)v68, (uint64_t)v105);
    long long v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = Lazuli::asString();
      uint64_t v23 = &v105[8];
      if ((v105[31] & 0x80u) != 0) {
        uint64_t v23 = *(uint8_t **)&v105[8];
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v23;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Incoming IMDN message ==>> [%{public}s] for id: %{public}s", buf, 0x16u);
    }
    LOBYTE(v63[0]) = 0;
    BYTE8(v64) = 0;
    sub_10112F058();
  }
  uint64_t v67 = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  *(_OWORD *)xpc_object_t v63 = 0u;
  long long v64 = 0u;
  sub_101133ABC((char *)v63, (uint64_t)__p);
  if ((_BYTE)v67)
  {
    *(_OWORD *)uint64_t v61 = 0u;
    long long v62 = 0u;
    memset(__dst, 0, sizeof(__dst));
    sub_10114D958((uint64_t)v63, (uint64_t)__dst);
    long long v25 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)__dst) {
        long long v26 = "kActive";
      }
      else {
        long long v26 = "kIdle";
      }
      long long v27 = &__dst[8];
      if ((__dst[31] & 0x80u) != 0) {
        long long v27 = *(uint8_t **)&__dst[8];
      }
      long long v28 = v61;
      if (SBYTE7(v62) < 0) {
        long long v28 = (void **)v61[0];
      }
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = v26;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(void *)&buf[14] = *((void *)&v62 + 1);
      *(_WORD *)&unsigned char buf[22] = 2082;
      *(void *)&uint8_t buf[24] = v27;
      LOWORD(v86) = 2082;
      *(void *)((char *)&v86 + 2) = v28;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Incoming group-composing message ==>> [%{public}s] refresh: %{public}lu lastactive: %{public}s contenttype: %{public}s", buf, 0x2Au);
    }
    memset(&v105[8], 0, 80);
    *(void *)v105 = *((void *)&v62 + 1);
    v105[8] = 1;
    v105[16] = *(_DWORD *)__dst == 1;
    if ((char)__dst[31] < 0)
    {
      sub_10004FC84(&v105[24], *(void **)&__dst[8], *(unint64_t *)&__dst[16]);
    }
    else
    {
      *(_OWORD *)&v105[24] = *(_OWORD *)&__dst[8];
      *(void *)&v105[40] = *(void *)&__dst[24];
    }
    v105[48] = 1;
    if (SBYTE7(v62) < 0)
    {
      sub_10004FC84(&v105[56], v61[0], (unint64_t)v61[1]);
    }
    else
    {
      *(_OWORD *)&v105[56] = *(_OWORD *)v61;
      *(void *)&v105[72] = v62;
    }
    v105[80] = 1;
    LOBYTE(v58[0]) = 0;
    char v59 = 0;
    sub_10112F058();
  }
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  *(_OWORD *)uint64_t v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  *(_OWORD *)char v40 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  sub_101133BA8(v38, (uint64_t)__p);
  if (BYTE8(v56))
  {
    uint64_t v115 = 0;
    long long v114 = 0u;
    long long v113 = 0u;
    long long v112 = 0u;
    long long v111 = 0u;
    long long v110 = 0u;
    long long v109 = 0u;
    long long v108 = 0u;
    long long v107 = 0u;
    long long v106 = 0u;
    memset(v105, 0, sizeof(v105));
    sub_1004637B0((uint64_t)v38, (uint64_t)v105);
    v57[0] = 0;
    v57[1] = 0;
    if (BYTE8(v79))
    {
      if (SBYTE7(v79) < 0)
      {
        sub_10004FC84(__dst, __src[0], (unint64_t)__src[1]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)__src;
        *(void *)&__dst[16] = v79;
      }
      sub_10045449C(buf, (uint64_t)v105);
      BYTE8(v99) = 0;
      LOBYTE(v101[0]) = 0;
      sub_1011337AC((uint64_t)v101 + 8, (void *)v127 + 1);
      sub_10113EC38(v57, (uint64_t)__dst, &v76, (long long *)&__p[1], (uint64_t)buf, a5, a6);
      sub_100454840((uint64_t)buf);
      if ((char)__dst[23] < 0) {
        operator delete(*(void **)__dst);
      }
      *(void **)long long __dst = v57[0];
      *(void **)&__dst[8] = v57[1];
      if (v57[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v57[1] + 1, 1uLL, memory_order_relaxed);
      }
      sub_10112EAA8(a1, (uint64_t *)__dst);
    }
    sub_10016C840();
  }
  if ((_BYTE)v130)
  {
    for (uint64_t i = *((void *)&v128 + 1); i != (void)v129; i += 384)
    {
      if (!*(_DWORD *)(i + 376))
      {
        long long v35 = *(_OWORD *)(i + 32);
        memset(v105, 0, 48);
        *(_OWORD *)&v105[48] = v35;
        long long v104 = 0u;
        long long v103 = 0u;
        long long v102 = 0u;
        memset(v101, 0, sizeof(v101));
        long long v100 = 0u;
        long long v99 = 0u;
        long long v98 = 0u;
        long long v97 = 0u;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v92 = 0u;
        long long v93 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_1002B2188((uint64_t)buf, a2);
        *(void *)&long long v102 = *(void *)&v105[56];
        *((void *)&v102 + 1) = *(void *)&v105[48];
        LOBYTE(v103) = 0;
        BYTE8(v104) = 0;
        v57[0] = 0;
        v57[1] = 0;
        if (BYTE8(v79))
        {
          if (SBYTE7(v79) < 0)
          {
            sub_10004FC84(__dst, __src[0], (unint64_t)__src[1]);
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)__src;
            *(void *)&__dst[16] = v79;
          }
          sub_10113ED88((uint64_t *)v57, (uint64_t)__dst, &v76, (long long *)&__p[1], (uint64_t)buf, v16, a5, a6);
          if ((char)__dst[23] < 0) {
            operator delete(*(void **)__dst);
          }
          v58[0] = (uint64_t)v57[0];
          v58[1] = (uint64_t)v57[1];
          if (v57[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)v57[1] + 1, 1uLL, memory_order_relaxed);
          }
          sub_10112EAA8(a1, v58);
        }
        sub_10016C840();
      }
    }
  }
  *(void *)&long long v86 = 0;
  memset(buf, 0, sizeof(buf));
  sub_10113CF48(buf, (uint64_t)__p);
  if (!(_BYTE)v86)
  {
    uint64_t v34 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      int8x16_t v37 = (char *)&v123 + 8;
      if (v124 < 0) {
        int8x16_t v37 = (char *)*((void *)&v123 + 1);
      }
      *(_DWORD *)v105 = 136446210;
      *(void *)&v105[4] = v37;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Unhandled content type for group message: [%{public}s]", v105, 0xCu);
    }
    sub_100058DB0(v105, "bad input");
    v105[24] = 1;
    sub_10112F058();
  }
  memset(v105, 0, 32);
  sub_100720334((std::string *)buf, (uint64_t)v105);
  uint64_t v31 = *(std::__shared_weak_count **)(a1 + 48);
  if (v31)
  {
    uint64_t v32 = std::__shared_weak_count::lock(v31);
    if (v32)
    {
      long long v33 = *(void (****)(void, void, uint8_t *, void))(a1 + 40);
      if (v33)
      {
        (**v33)(v33, *(unsigned int *)(a1 + 16), v105, v105[24]);
        goto LABEL_104;
      }
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  int v36 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    if (!v32) {
      goto LABEL_105;
    }
    goto LABEL_104;
  }
  *(_WORD *)long long __dst = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "No delegate set when updating chatbot identity...", __dst, 2u);
  if (v32) {
LABEL_104:
  }
    sub_10004D2C8(v32);
LABEL_105:
  if ((char)v105[23] < 0) {
    operator delete(*(void **)v105);
  }
  if ((_BYTE)v86 && (buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  sub_10113D58C((uint64_t)v38);
  sub_10113D608((uint64_t)v63);
  sub_1000C636C((uint64_t)v68);
  if (BYTE8(v73) && SBYTE7(v73) < 0) {
    operator delete(v72[0]);
  }
  if (SHIBYTE(v77) < 0) {
    operator delete((void *)v76);
  }
  if (BYTE8(v79) && SBYTE7(v79) < 0) {
    operator delete(__src[0]);
  }
  sub_10113D654((uint64_t)__p);
  if (SBYTE7(v83) < 0) {
    operator delete(v82[0]);
  }
}

void sub_10113C9A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_101134FE0((uint64_t)&STACK[0x370]);
  sub_1001085D8((uint64_t)&STACK[0x4E0]);
  sub_10113D58C((uint64_t)&a9);
  sub_10113D608((uint64_t)&STACK[0x220]);
  sub_1000C636C((uint64_t)&STACK[0x270]);
  if (LOBYTE(STACK[0x2C8]) && SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  if (SLOBYTE(STACK[0x30F]) < 0) {
    operator delete((void *)STACK[0x2F8]);
  }
  if (LOBYTE(STACK[0x328]) && SLOBYTE(STACK[0x327]) < 0) {
    operator delete((void *)STACK[0x310]);
  }
  sub_10113D654((uint64_t)&STACK[0x5E0]);
  if (SLOBYTE(STACK[0x357]) < 0) {
    operator delete((void *)STACK[0x340]);
  }
  _Unwind_Resume(a1);
}

_OWORD *sub_10113CF48(_OWORD *__dst, uint64_t a2)
{
  long long v2 = __dst;
  char v3 = *(unsigned char *)(a2 + 464);
  if (v3)
  {
    for (uint64_t i = *(void *)(a2 + 440); ; i += 384)
    {
      if (i == *(void *)(a2 + 448))
      {
        char v3 = 0;
        goto LABEL_7;
      }
      if (*(_DWORD *)(i + 376) == 1) {
        break;
      }
    }
    if (*(char *)(i + 55) < 0)
    {
      long long __dst = sub_10004FC84(__dst, *(void **)(i + 32), *(void *)(i + 40));
    }
    else
    {
      long long v5 = *(_OWORD *)(i + 32);
      *((void *)__dst + 2) = *(void *)(i + 48);
      *long long __dst = v5;
    }
    v2[3] = *(void *)(i + 56);
    char v3 = 1;
  }
  else
  {
LABEL_7:
    *(unsigned char *)long long __dst = 0;
  }
  *((unsigned char *)v2 + 32) = v3;
  return __dst;
}

void sub_10113CFD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v16, 0, 40);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a3;
    __p[0] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(&__p[1], *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)&__p[1] = *(_OWORD *)a4;
    __p[3] = *(void **)(a4 + 16);
  }
  sub_100720734((uint64_t)__dst, (uint64_t)v16);
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(__dst[0]);
  }
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  *(_OWORD *)long long __dst = 0u;
  memset(__p, 0, sizeof(__p));
  sub_100CC786C();
}

void sub_10113D164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10113D1F0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 384))
  {
    sub_100B93514(a1 + 32);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10113D234(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10113D2AC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10113D2AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  void v12[2] = &v14;
  v12[3] = 1;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v14 + 1) = v9;
  }
  sub_10113D348((uint64_t)v12);
  return a6;
}

uint64_t sub_10113D348(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000D8858(a1);
  }
  return a1;
}

uint64_t sub_10113D380(uint64_t result, uint64_t a2)
{
  *(_DWORD *)uint64_t result = *(_DWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(result + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(result + 32) = v3;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  long long v4 = *(_OWORD *)(a2 + 56);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(result + 56) = v4;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  char v5 = *(unsigned char *)(a2 + 80);
  *(unsigned char *)(result + 88) = 0;
  *(unsigned char *)(result + 80) = v5;
  *(unsigned char *)(result + 112) = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    *(void *)(result + 88) = 0;
    *(void *)(result + 96) = 0;
    *(void *)(result + 104) = 0;
    *(_OWORD *)(result + 88) = *(_OWORD *)(a2 + 88);
    *(void *)(result + 104) = *(void *)(a2 + 104);
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    *(unsigned char *)(result + 112) = 1;
  }
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(result + 120) = v6;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  *(unsigned char *)(result + 144) = 0;
  *(unsigned char *)(result + 216) = 0;
  if (*(unsigned char *)(a2 + 216))
  {
    long long v7 = *(_OWORD *)(a2 + 144);
    *(void *)(result + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(result + 144) = v7;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    long long v8 = *(_OWORD *)(a2 + 168);
    *(void *)(result + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(result + 168) = v8;
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 168) = 0;
    long long v9 = *(_OWORD *)(a2 + 192);
    *(void *)(result + 208) = *(void *)(a2 + 208);
    *(_OWORD *)(result + 192) = v9;
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 208) = 0;
    *(void *)(a2 + 192) = 0;
    *(unsigned char *)(result + 216) = 1;
  }
  *(unsigned char *)(result + 224) = 1;
  return result;
}

uint64_t sub_10113D49C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 224))
  {
    sub_1002B24B0(a1 + 144);
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(unsigned char *)(a1 + 112))
    {
      long long v3 = (void **)(a1 + 88);
      sub_100047F64(&v3);
    }
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

uint64_t sub_10113D530(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
  return a1;
}

uint64_t sub_10113D58C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 296))
  {
    sub_100B9164C(a1 + 144);
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*(void **)(a1 + 80));
    }
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
  return a1;
}

uint64_t sub_10113D608(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_10113D654(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 464)) {
    sub_100B9630C(a1 + 296);
  }
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  if (*(unsigned char *)(a1 + 264) && *(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  sub_10010C0E0(a1 + 200, *(void **)(a1 + 208));
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

uint64_t sub_10113D72C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(unsigned char *)(a1 + 104))
    {
      long long v3 = (void **)(a1 + 80);
      sub_100155410(&v3);
    }
    if (*(unsigned char *)(a1 + 72))
    {
      long long v3 = (void **)(a1 + 48);
      sub_100155494(&v3);
    }
    if (*(unsigned char *)(a1 + 40) && *(char *)(a1 + 39) < 0) {
      operator delete(*(void **)(a1 + 16));
    }
  }
  return a1;
}

void sub_10113D7A8(uint64_t a1)
{
  sub_10010C0E0(a1 + 56, *(void **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

void sub_10113D7F8(int a1, uint64_t a2, int a3)
{
  memset(v14, 0, 7);
  if (a1 == -1)
  {
    long long v6 = 0;
    unsigned int v7 = 0;
    char v5 = 0;
  }
  else
  {
    if (a3) {
      int v4 = 11;
    }
    else {
      int v4 = 15;
    }
    LODWORD(v10[0]) = v4;
    sub_101012938((int *)v10, (uint64_t)__dst);
    char v5 = __dst[0];
    long long v6 = __dst[1];
    v14[0] = v13;
    *(_DWORD *)((char *)v14 + 3) = *(_DWORD *)((char *)&v13 + 3);
    unsigned int v7 = HIBYTE(v13);
  }
  if ((v7 & 0x80u) == 0) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = (unint64_t)v6;
  }
  if (!v8) {
    goto LABEL_22;
  }
  sub_100058DB0(v10, "imdn.Disposition-Notification");
  if (SHIBYTE(v11) < 0)
  {
    sub_10004FC84(__dst, v10[0], (unint64_t)v10[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v10;
    uint64_t v13 = v11;
  }
  if ((v7 & 0x80) != 0)
  {
    sub_10004FC84(&__p, v5, (unint64_t)v6);
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)v6;
    LODWORD(__p.__r_.__value_.__r.__words[2]) = v14[0];
    *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v14 + 3);
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v7;
  }
  sub_1010E707C(a2, __dst, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__dst[0]);
  }
  if ((SHIBYTE(v11) & 0x80000000) == 0)
  {
LABEL_22:
    if ((v7 & 0x80) == 0) {
      return;
    }
    goto LABEL_23;
  }
  operator delete(v10[0]);
  if ((v7 & 0x80) != 0) {
LABEL_23:
  }
    operator delete(v5);
}

void sub_10113D950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_10113D9B4()
{
}

uint64_t sub_10113D9C8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t *sub_10113D9D0(uint64_t **a1, void **a2, long long **a3)
{
  long long v6 = a1 + 1;
  char v5 = a1[1];
  unsigned int v7 = a1 + 1;
  unint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  unsigned int v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      unint64_t v8 = (uint64_t **)v5;
      long long v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      char v5 = *v8;
      unsigned int v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    unsigned int v7 = v8 + 1;
    char v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    long long v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (uint64_t *)operator new(0x48uLL);
    v18[0] = v13;
    v18[1] = v6;
    long long v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      v13[6] = *((void *)v12 + 2);
      *(_OWORD *)long long v14 = v15;
    }
    v13[7] = 0;
    v13[8] = 0;
    LOBYTE(v19) = 1;
    *uint64_t v13 = 0;
    v13[1] = 0;
    std::string v13[2] = (uint64_t)v8;
    *unsigned int v7 = v13;
    int v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_1001FEBC4((uint64_t)v18);
  }
  return v11;
}

void sub_10113DB1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10113DB30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A932C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113DB50(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A932C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113DBA4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113DBCC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93318;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113DBEC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93318;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113DC40(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113DC68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93368;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113DC88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93368;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113DCDC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10113DD04(void *a1, uint64_t a2, long long *a3, uint64_t a4, long long *a5)
{
  long long v10 = operator new(0x1C0uLL);
  v10[1] = 0;
  _OWORD v10[2] = 0;
  void *v10 = off_101A933B8;
  uint64_t result = sub_1012D56E0(v10 + 3, a2, a3, a4, a5);
  *a1 = result;
  a1[1] = v10;
  return result;
}

void sub_10113DD88(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10113DDA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A933B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113DDC0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A933B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113DE14(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10113DE3C(uint64_t *a1, uint64_t a2, long long *a3, long long *a4, long long *a5)
{
  long long v10 = operator new(0x118uLL);
  v10[1] = 0;
  _OWORD v10[2] = 0;
  void *v10 = off_101A93408;
  uint64_t result = sub_1012D5B34((uint64_t)(v10 + 3), a2, a3, a4, a5);
  *a1 = result;
  a1[1] = (uint64_t)v10;
  return result;
}

void sub_10113DEC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10113DED8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93408;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113DEF8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93408;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113DF4C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10113DF74(void *a1, uint64_t a2, long long *a3, _OWORD *a4, long long *a5)
{
  long long v10 = operator new(0x1F0uLL);
  v10[1] = 0;
  _OWORD v10[2] = 0;
  void *v10 = off_101A93458;
  uint64_t result = sub_1012D5A08(v10 + 3, a2, a3, a4, a5);
  *a1 = result;
  a1[1] = v10;
  return result;
}

void sub_10113DFF8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10113E010(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93458;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E030(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93458;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E084(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E0AC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A934A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E0CC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A934A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E120(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E148(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A934F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E168(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A934F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E1BC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E1E4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93548;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E204(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93548;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E258(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10113E280(void *a1, uint64_t a2, long long *a3, _OWORD *a4)
{
  unint64_t v8 = operator new(0xE0uLL);
  v8[1] = 0;
  v8[2] = 0;
  *unint64_t v8 = off_101A93598;
  uint64_t result = sub_1012D55B8(v8 + 3, a2, a3, a4);
  *a1 = result;
  a1[1] = v8;
  return result;
}

void sub_10113E2FC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10113E314(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E334(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93598;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E388(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E3B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A935E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E3D0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A935E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E424(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E44C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93638;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E46C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93638;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E4C0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E4E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93688;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E508(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93688;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E55C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E584(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A936D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E5A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A936D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E5F8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E620(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E640(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93728;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E694(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E6BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E6DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93778;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E730(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E758(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A937C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E778(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A937C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E7CC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E7F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E814(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E868(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E890(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E8B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93868;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E904(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E92C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A938B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E94C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A938B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113E9A0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113E9C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113E9E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93908;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113EA3C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113EA64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93958;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113EA84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93958;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113EAD8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113EB00(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A939A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113EB20(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A939A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113EB74(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10113EB9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A939F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113EBBC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A939F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113EC10(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10113EC38(void *a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5, long long *a6, long long *a7)
{
  long long v14 = operator new(0x1F0uLL);
  v14[1] = 0;
  _DWORD v14[2] = 0;
  void *v14 = off_101A93A48;
  uint64_t result = sub_1012D67B4(v14 + 3, a2, a3, a4, a5, a6, a7);
  *a1 = result;
  a1[1] = v14;
  return result;
}

void sub_10113ECD4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10113ECEC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A93A48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10113ED0C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A93A48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10113ED60(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10113ED88(uint64_t *a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5, int a6, long long *a7, long long *a8)
{
  int v16 = operator new(0x230uLL);
  v16[1] = 0;
  int v16[2] = 0;
  *int v16 = off_101A934A8;
  uint64_t result = sub_1012D652C((uint64_t)(v16 + 3), a2, a3, a4, a5, a6, a7, a8);
  *a1 = result;
  a1[1] = (uint64_t)v16;
  return result;
}

void sub_10113EE34(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

const char *sub_10113EE4C(PersonalitySpecificImpl *a1)
{
  if (PersonalitySpecificImpl::simSlot(a1) == 1) {
    return "DATA.ursp.1";
  }
  if (PersonalitySpecificImpl::simSlot(a1) == 2) {
    return "DATA.ursp.2";
  }
  return "DATA.ursp.?";
}

void *sub_10113EEA4(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  char v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_10113EF0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10113EF30(uint64_t a1, void *a2, void *a3, uint64_t a4, NSObject **a5)
{
  *(void *)(a1 + 192) = off_101A93D60;
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  *(void *)a1 = off_101A93AF0;
  *(void *)(a1 + 192) = off_101A93BB0;
  long long v9 = sub_10113EE4C((PersonalitySpecificImpl *)a1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, v9);
  sub_10113EEA4((void *)(a1 + 24), a5, &v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)a1 = off_101A93AF0;
  *(void *)(a1 + 192) = off_101A93BB0;
  *(void *)(a1 + 64) = *a3;
  uint64_t v10 = a3[1];
  *(void *)(a1 + 72) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 184) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10113F090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  PersonalitySpecificImpl::~PersonalitySpecificImpl(v9);
  PersonalitySpecific::~PersonalitySpecific(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10113F0CC(uint64_t a1)
{
  *(void *)a1 = off_101A93AF0;
  long long v2 = (PersonalitySpecific *)(a1 + 192);
  *(void *)(a1 + 192) = off_101A93BB0;
  long long v3 = *(std::__shared_weak_count **)(a1 + 184);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(void **)(a1 + 152);
  if (v4)
  {
    *(void *)(a1 + 160) = v4;
    operator delete(v4);
  }
  unsigned int v7 = (void **)(a1 + 128);
  sub_1008BE774(&v7);
  sub_10114D568(*(char **)(a1 + 112));
  unsigned int v7 = (void **)(a1 + 80);
  sub_101146B4C(&v7);
  char v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));
  sub_100087E88((void *)(a1 + 24));
  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)a1);
  PersonalitySpecific::~PersonalitySpecific(v2);
  return a1;
}

uint64_t sub_10113F1B8(void *a1)
{
  return sub_10113F0CC((uint64_t)a1 + *(void *)(*a1 - 24));
}

void sub_10113F1D4(uint64_t a1)
{
  sub_10113F0CC(a1);

  operator delete();
}

void sub_10113F20C(void *a1)
{
  sub_10113F0CC((uint64_t)a1 + *(void *)(*a1 - 24));

  operator delete();
}

void sub_10113F25C(uint64_t a1, int *a2, void *a3, unsigned int a4)
{
  int v7 = a2[2];
  int v8 = *a2;
  long long v9 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a4;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I processUrsp_sync numOfPlmn=%u", buf, 8u);
  }
  if (a4)
  {
    uint64_t v10 = 0;
    unsigned int v126 = (unsigned __int16)(v7 - v8);
    uint64_t v125 = a4;
    long long v129 = (uint64_t **)(a1 + 112);
    long long v123 = (void **)(a1 + 104);
    while (1)
    {
      uint64_t v11 = *(unsigned int *)(*a3 + 4 * v10);
      if (v11 >= v126) {
        break;
      }
      uint64_t v130 = v10;
      unint64_t v12 = (v11 + 9);
      uint64_t v13 = *(void *)a2;
      if (*((void *)a2 + 1) - *(void *)a2 > v12)
      {
        int v141 = *(unsigned __int8 *)(v13 + v11);
        int v14 = *(unsigned __int8 *)(v11 + v13 + 1);
        uint64_t v139 = *(unsigned __int8 *)(v11 + v13 + 3);
        uint64_t v136 = *(unsigned __int8 *)(v11 + v13 + 2);
        int v15 = *(unsigned __int8 *)(v11 + v13 + 7);
        int v16 = *(unsigned __int8 *)(v11 + v13 + 6);
        int v132 = *(unsigned __int8 *)(v11 + v13 + 5);
        int v134 = *(unsigned __int8 *)(v11 + v13 + 4);
        int v17 = *(unsigned __int8 *)(v11 + v13 + 8) | (*(unsigned __int8 *)(v13 + v12) << 8);
        long long v18 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v11;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v17;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I processUePolicySectionManagementSublist startIndex %u, upsmSublistLength %u", buf, 0xEu);
        }
        unsigned int v138 = v17 + v12;
        if (v17 + (int)v12 < (v11 + 10)) {
          goto LABEL_162;
        }
        unsigned int v19 = v11 + 10;
        int v20 = (v15 << 24) | (v16 << 16) | (v132 << 8) | v134;
        int v21 = (v14 << 8) | v141;
        unint64_t v128 = ((v139 << 24) | (unint64_t)(v136 << 16)) >> 16;
        int v133 = (v139 << 24) | (v136 << 16);
        BOOL v131 = v20 != 0;
        uint64_t v22 = *(void *)a2;
        uint64_t v23 = *((void *)a2 + 1);
        int v124 = v21;
        while (1)
        {
          uint64_t v142 = v19;
          unint64_t v24 = v19 + 3;
          if (v23 - v22 <= v24)
          {
            long long v33 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v19;
              _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "processUePolicyInstruction incorrect startIndex %u", buf, 8u);
            }
          }
          else
          {
            unsigned int v140 = v19;
            long long v25 = (unsigned __int16 *)(v22 + v19);
            unsigned int v26 = __rev16(*v25);
            int v27 = *(unsigned __int8 *)(v22 + v24) | (*((unsigned __int8 *)v25 + 2) << 8);
            uint64_t v145 = (unsigned __int16)v21;
            WORD1(v145) = HIWORD(v133);
            BYTE4(v145) = v131;
            int v137 = v27;
            HIWORD(v145) = v27;
            long long v28 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109888;
              *(_DWORD *)&uint8_t buf[4] = v21;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v128;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v137;
              *(_WORD *)&buf[20] = 1024;
              *(_DWORD *)&unsigned char buf[22] = v26;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I processUePolicyInstruction upsi: mcc=%u, mnc=%u,upsc=0x%x, instruction length=0x%x", buf, 0x1Au);
            }
            if (v26 != 2)
            {
              if (!v26)
              {
                uint64_t v29 = *(NSObject **)(a1 + 56);
                unsigned int v19 = v140;
                if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_151;
                }
                *(_DWORD *)long long buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v140;
                uint64_t v30 = v29;
                uint64_t v31 = "#E processUePolicyInstruction empty content %u";
                uint32_t v32 = 8;
                goto LABEL_37;
              }
              int64x2_t v143 = 0uLL;
              uint64_t v144 = 0;
              unsigned int v44 = v140 + 4;
              unsigned int v45 = v140 + 1 + v26;
              int64x2_t v148 = 0uLL;
              unint64_t v149 = 0;
              long long v46 = *(NSObject **)(a1 + 56);
              if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v140 + 4;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v140 + 1 + v26;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I processUePolicySectionContents startIdx=%u, stopIdx=%u", buf, 0xEu);
              }
              if (v44 >= v45)
              {
                unint64_t v92 = 0;
                int64x2_t v91 = 0uLL;
LABEL_107:
                int64x2_t v143 = v91;
                uint64_t v144 = v92;
                long long v90 = &v148;
              }
              else
              {
                unsigned int v135 = v140 + 1 + v26;
                while (1)
                {
                  unint64_t v47 = v44 + 2;
                  uint64_t v48 = *(void *)a2;
                  if (*((void *)a2 + 1) - *(void *)a2 <= v47) {
                    break;
                  }
                  unsigned int v49 = __rev16(*(unsigned __int16 *)(v48 + v44));
                  int v50 = *(unsigned char *)(v48 + v47) & 0xF;
                  long long v51 = *(NSObject **)(a1 + 56);
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 67109376;
                    *(_DWORD *)&uint8_t buf[4] = v49;
                    *(_WORD *)&uint8_t buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v50;
                    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I processUePolicySectionContents, policyPartContentsLen=0x%x, type=0x%x", buf, 0xEu);
                  }
                  if (v50 == 1)
                  {
                    int64x2_t v146 = 0uLL;
                    unint64_t v147 = 0;
                    unsigned int v52 = v44 + 3;
                    unsigned int v53 = v44 + 1 + v49;
                    int64x2_t v150 = 0uLL;
                    unint64_t v151 = 0;
                    long long v54 = *(NSObject **)(a1 + 56);
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 67109376;
                      *(_DWORD *)&uint8_t buf[4] = v44 + 3;
                      *(_WORD *)&uint8_t buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v44 + 1 + v49;
                      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I processUePolicyPartContentsUrspList startIdx=%u, stopIdx=%u", buf, 0xEu);
                    }
                    if (v52 <= v53)
                    {
                      while (1)
                      {
                        unint64_t v57 = v52 + 1;
                        if (*((void *)a2 + 1) - *(void *)a2 <= v57) {
                          break;
                        }
                        int v58 = *(unsigned __int8 *)(*(void *)a2 + v57) | (*(unsigned __int8 *)(*(void *)a2 + v52) << 8);
                        char v59 = *(NSObject **)(a1 + 56);
                        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)long long buf = 67109120;
                          *(_DWORD *)&uint8_t buf[4] = v58;
                          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I urspRuleLength=0x%x", buf, 8u);
                        }
                        long long v168 = 0u;
                        long long v169 = 0u;
                        long long v166 = 0u;
                        long long v167 = 0u;
                        long long v164 = 0u;
                        long long v165 = 0u;
                        long long v162 = 0u;
                        long long v163 = 0u;
                        long long v160 = 0u;
                        long long v161 = 0u;
                        long long v158 = 0u;
                        long long v159 = 0u;
                        long long v157 = 0u;
                        memset(buf, 0, sizeof(buf));
                        sub_10114028C((uint64_t)buf, (NSObject **)a1, (uint64_t *)a2, v52);
                        int v60 = BYTE8(v169);
                        uint64_t v61 = *(NSObject **)(a1 + 56);
                        BOOL v62 = os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT);
                        if (v60)
                        {
                          if (v62)
                          {
                            *(_WORD *)v152 = 0;
                            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I processUePolicyPartContentsUrspList adding ursp Rule", v152, 2u);
                            if (!BYTE8(v169)) {
                              sub_10016C840();
                            }
                          }
                          uint64_t v63 = v150.i64[1];
                          if (v150.i64[1] >= v151)
                          {
                            uint64_t v65 = 0x34F72C234F72C235 * ((v150.i64[1] - v150.i64[0]) >> 3);
                            unint64_t v66 = v65 + 1;
                            if ((unint64_t)(v65 + 1) > 0x11A7B9611A7B961) {
                              sub_10006A748();
                            }
                            if (0x69EE58469EE5846ALL * ((uint64_t)(v151 - v150.i64[0]) >> 3) > v66) {
                              unint64_t v66 = 0x69EE58469EE5846ALL * ((uint64_t)(v151 - v150.i64[0]) >> 3);
                            }
                            if ((unint64_t)(0x34F72C234F72C235 * ((uint64_t)(v151 - v150.i64[0]) >> 3)) >= 0x8D3DCB08D3DCB0) {
                              unint64_t v67 = 0x11A7B9611A7B961;
                            }
                            else {
                              unint64_t v67 = v66;
                            }
                            v155 = &v151;
                            if (v67) {
                              unint64_t v67 = (unint64_t)sub_101146DC8(v67);
                            }
                            else {
                              uint64_t v68 = 0;
                            }
                            *(void *)v152 = v67;
                            v153.i64[0] = v67 + 232 * v65;
                            v153.i64[1] = v153.i64[0];
                            unint64_t v154 = v67 + 232 * v68;
                            sub_101146E88(v153.i64[0], (uint64_t)buf);
                            uint64_t v69 = v153.i64[0];
                            uint64_t v64 = v153.i64[1] + 232;
                            v153.i64[1] += 232;
                            uint64_t v70 = v150.i64[1];
                            uint64_t v71 = v150.i64[0];
                            if (v150.i64[1] == v150.i64[0])
                            {
                              int64x2_t v72 = vdupq_n_s64(v150.u64[1]);
                            }
                            else
                            {
                              do
                              {
                                v70 -= 232;
                                sub_101146C0C(v69 - 232, v70);
                              }
                              while (v70 != v71);
                              int64x2_t v72 = v150;
                              uint64_t v64 = v153.i64[1];
                            }
                            v150.i64[0] = v69;
                            v150.i64[1] = v64;
                            int64x2_t v153 = v72;
                            unint64_t v73 = v151;
                            unint64_t v151 = v154;
                            unint64_t v154 = v73;
                            *(void *)v152 = v72.i64[0];
                            sub_101146E14((uint64_t)v152);
                          }
                          else
                          {
                            sub_101146E88(v150.i64[1], (uint64_t)buf);
                            uint64_t v64 = v63 + 232;
                          }
                          v150.i64[1] = v64;
                        }
                        else if (v62)
                        {
                          *(_WORD *)v152 = 0;
                          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I processUePolicyPartContentsUrspList skip invalid ursp Rule", v152, 2u);
                        }
                        v52 += v58 + 2;
                        sub_101147828((uint64_t)buf);
                        if (v52 > v53)
                        {
                          int64x2_t v56 = v150;
                          unint64_t v55 = v151;
                          goto LABEL_77;
                        }
                      }
                      char v75 = *(NSObject **)(a1 + 56);
                      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 67109120;
                        *(_DWORD *)&uint8_t buf[4] = v52;
                        _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "processUePolicyPartContentsUrspList incorrect index %u", buf, 8u);
                      }
                      char v74 = &v146;
                    }
                    else
                    {
                      unint64_t v55 = 0;
                      int64x2_t v56 = 0uLL;
LABEL_77:
                      int64x2_t v146 = v56;
                      unint64_t v147 = v55;
                      char v74 = &v150;
                    }
                    v74->i64[0] = 0;
                    v74->i64[1] = 0;
                    v74[1].i64[0] = 0;
                    *(void *)long long buf = &v150;
                    sub_101146B4C((void ***)buf);
                    uint64_t v76 = v146.i64[1];
                    uint64_t v77 = v146.i64[0];
                    if (v146.i64[0] != v146.i64[1])
                    {
                      unint64_t v78 = v148.u64[1];
                      do
                      {
                        if (v78 >= v149)
                        {
                          uint64_t v79 = 0x34F72C234F72C235 * ((uint64_t)(v78 - v148.i64[0]) >> 3);
                          unint64_t v80 = v79 + 1;
                          if ((unint64_t)(v79 + 1) > 0x11A7B9611A7B961) {
                            sub_10006A748();
                          }
                          if (0x69EE58469EE5846ALL * ((uint64_t)(v149 - v148.i64[0]) >> 3) > v80) {
                            unint64_t v80 = 0x69EE58469EE5846ALL * ((uint64_t)(v149 - v148.i64[0]) >> 3);
                          }
                          if ((unint64_t)(0x34F72C234F72C235 * ((uint64_t)(v149 - v148.i64[0]) >> 3)) >= 0x8D3DCB08D3DCB0) {
                            unint64_t v81 = 0x11A7B9611A7B961;
                          }
                          else {
                            unint64_t v81 = v80;
                          }
                          *(void *)&long long v157 = &v149;
                          if (v81) {
                            unint64_t v81 = (unint64_t)sub_101146DC8(v81);
                          }
                          else {
                            uint64_t v82 = 0;
                          }
                          uint64_t v83 = v81 + 232 * v79;
                          *(void *)long long buf = v81;
                          *(void *)&uint8_t buf[8] = v83;
                          *(void *)&uint8_t buf[24] = v81 + 232 * v82;
                          sub_101146C0C(v83, v77);
                          unint64_t v78 = v83 + 232;
                          *(void *)&uint8_t buf[16] = v83 + 232;
                          uint64_t v84 = v148.i64[1];
                          uint64_t v85 = v148.i64[0];
                          uint64_t v86 = *(void *)&buf[8];
                          if (v148.i64[1] == v148.i64[0])
                          {
                            int64x2_t v87 = vdupq_n_s64(v148.u64[1]);
                          }
                          else
                          {
                            do
                            {
                              v84 -= 232;
                              sub_101146C0C(v86 - 232, v84);
                            }
                            while (v84 != v85);
                            int64x2_t v87 = v148;
                            unint64_t v78 = *(void *)&buf[16];
                          }
                          v148.i64[0] = v86;
                          v148.i64[1] = v78;
                          *(int64x2_t *)&uint8_t buf[8] = v87;
                          unint64_t v88 = v149;
                          unint64_t v149 = *(void *)&buf[24];
                          *(void *)&uint8_t buf[24] = v88;
                          *(void *)long long buf = v87.i64[0];
                          sub_101146E14((uint64_t)buf);
                        }
                        else
                        {
                          sub_101146C0C(v78, v77);
                          v78 += 232;
                        }
                        v148.i64[1] = v78;
                        v77 += 232;
                      }
                      while (v77 != v76);
                    }
                    *(void *)long long buf = &v146;
                    sub_101146B4C((void ***)buf);
                    unsigned int v45 = v135;
                  }
                  unsigned int v44 = v49 + v47;
                  if (v49 + v47 >= v45)
                  {
                    int64x2_t v91 = v148;
                    unint64_t v92 = v149;
                    int v21 = v124;
                    goto LABEL_107;
                  }
                }
                long long v89 = *(NSObject **)(a1 + 56);
                if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v44;
                  _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "processUePolicyInstruction incorrect index %u", buf, 8u);
                }
                long long v90 = &v143;
                int v21 = v124;
              }
              v90->i64[0] = 0;
              v90->i64[1] = 0;
              v90[1].i64[0] = 0;
              *(void *)long long buf = &v148;
              sub_101146B4C((void ***)buf);
              uint64_t v93 = v143.i64[1];
              uint64_t v94 = v143.i64[0];
              if (v143.i64[0] != v143.i64[1])
              {
                long long v95 = (unsigned __int16 *)(a1 + 112);
                long long v96 = *v129;
                if (!*v129) {
                  goto LABEL_118;
                }
                long long v97 = (uint64_t *)(a1 + 112);
                do
                {
                  BOOL v98 = sub_10114D5CC((unsigned __int16 *)v96 + 16, (unsigned __int16 *)&v145);
                  long long v99 = (uint64_t **)(v96 + 1);
                  if (!v98)
                  {
                    long long v99 = (uint64_t **)v96;
                    long long v97 = v96;
                  }
                  long long v96 = *v99;
                }
                while (*v99);
                long long v95 = (unsigned __int16 *)(a1 + 112);
                if (v97 == (uint64_t *)v129)
                {
LABEL_118:
                  *(void *)long long buf = 0;
                  *(void *)v152 = 0;
                  goto LABEL_119;
                }
                if (sub_10114D5CC((unsigned __int16 *)&v145, (unsigned __int16 *)v97 + 16))
                {
                  *(void *)long long buf = 0;
                  *(void *)v152 = 0;
                  if (sub_10114D5CC((unsigned __int16 *)&v145, (unsigned __int16 *)v97 + 16))
                  {
                    long long v95 = (unsigned __int16 *)v97;
LABEL_119:
                    long long v100 = *(uint64_t **)v95;
                    v101 = v95;
                    if (*v123 == v95) {
                      goto LABEL_125;
                    }
                    long long v102 = *(uint64_t **)v95;
                    long long v103 = v95;
                    if (v100)
                    {
                      do
                      {
                        v101 = (unsigned __int16 *)v102;
                        long long v102 = (uint64_t *)v102[1];
                      }
                      while (v102);
                    }
                    else
                    {
                      do
                      {
                        v101 = (unsigned __int16 *)*((void *)v103 + 2);
                        BOOL v42 = *(void *)v101 == (void)v103;
                        long long v103 = v101;
                      }
                      while (v42);
                    }
                    if (sub_10114D5CC(v101 + 16, (unsigned __int16 *)&v145))
                    {
LABEL_125:
                      if (v100)
                      {
                        *(void *)long long buf = v101;
                        long long v95 = v101 + 4;
                        goto LABEL_141;
                      }
LABEL_140:
                      *(void *)long long buf = v95;
                      goto LABEL_141;
                    }
LABEL_142:
                    long long v112 = (void **)(a1 + 104);
                    long long v95 = (unsigned __int16 *)sub_10114D644((uint64_t)v123, buf, (unsigned __int16 *)&v145);
                    goto LABEL_143;
                  }
                  if (sub_10114D5CC((unsigned __int16 *)v97 + 16, (unsigned __int16 *)&v145))
                  {
                    long long v109 = (unsigned __int16 *)v97[1];
                    long long v110 = v109;
                    long long v111 = (unsigned __int16 *)v97;
                    if (v109)
                    {
                      do
                      {
                        long long v95 = v110;
                        long long v110 = *(unsigned __int16 **)v110;
                      }
                      while (v110);
                    }
                    else
                    {
                      do
                      {
                        long long v95 = (unsigned __int16 *)*((void *)v111 + 2);
                        BOOL v42 = *(void *)v95 == (void)v111;
                        long long v111 = v95;
                      }
                      while (!v42);
                    }
                    if (v95 != (unsigned __int16 *)v129 && !sub_10114D5CC((unsigned __int16 *)&v145, v95 + 16)) {
                      goto LABEL_142;
                    }
                    if (v109) {
                      goto LABEL_140;
                    }
                    *(void *)long long buf = v97;
                    long long v95 = (unsigned __int16 *)(v97 + 1);
LABEL_141:
                    long long v112 = (void **)(a1 + 104);
LABEL_143:
                    if (!*(void *)v95)
                    {
LABEL_144:
                      long long v113 = (uint64_t *)operator new(0x40uLL);
                      v113[4] = v145;
                      v113[5] = v94;
                      uint64_t v114 = v144;
                      v113[6] = v93;
                      v113[7] = v114;
                      uint64_t v144 = 0;
                      int64x2_t v143 = 0uLL;
                      uint64_t v115 = *(void *)buf;
                      *long long v113 = 0;
                      v113[1] = 0;
                      v113[2] = v115;
                      *(void *)long long v95 = v113;
                      v116 = (void *)**v112;
                      if (v116)
                      {
                        *long long v112 = v116;
                        long long v113 = *(uint64_t **)v95;
                      }
                      sub_100046C90(*(uint64_t **)(a1 + 112), v113);
                      ++*(void *)(a1 + 120);
                    }
                  }
                  else
                  {
                    *(void *)long long buf = v97;
                    *(void *)v152 = v97;
                    long long v95 = (unsigned __int16 *)v152;
                    long long v112 = (void **)(a1 + 104);
                    if (!v97) {
                      goto LABEL_144;
                    }
                  }
                  long long v117 = *(NSObject **)(a1 + 56);
                  int v21 = v124;
                  if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 67109632;
                    *(_DWORD *)&uint8_t buf[4] = v124;
                    *(_WORD *)&uint8_t buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v128;
                    *(_WORD *)&buf[14] = 1024;
                    *(_DWORD *)&uint8_t buf[16] = v137;
                    long long v107 = v117;
                    long long v108 = "#I processUePolicyInstruction inserted upsi: plmn[%u, %u] upsc 0x%x";
LABEL_149:
                    _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, v108, buf, 0x14u);
                  }
                }
                else
                {
                  v105 = (void **)(v97 + 5);
                  uint64_t v104 = v97[5];
                  if (v104)
                  {
                    sub_101146BA0((uint64_t)(v97 + 5), v104);
                    operator delete(*v105);
                    *v105 = 0;
                    v97[6] = 0;
                    v97[7] = 0;
                    uint64_t v93 = v143.i64[1];
                    uint64_t v94 = v143.i64[0];
                  }
                  v97[5] = v94;
                  v97[6] = v93;
                  v97[7] = v144;
                  uint64_t v144 = 0;
                  int64x2_t v143 = 0uLL;
                  long long v106 = *(NSObject **)(a1 + 56);
                  int v21 = v124;
                  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 67109632;
                    *(_DWORD *)&uint8_t buf[4] = v124;
                    *(_WORD *)&uint8_t buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v128;
                    *(_WORD *)&buf[14] = 1024;
                    *(_DWORD *)&uint8_t buf[16] = v137;
                    long long v107 = v106;
                    long long v108 = "#I processUePolicyInstruction replaced upsi: plmn[%u, %u] upsc 0x%x";
                    goto LABEL_149;
                  }
                }
              }
              *(void *)long long buf = &v143;
              sub_101146B4C((void ***)buf);
              unsigned int v19 = v140;
              goto LABEL_151;
            }
            uint64_t v34 = (uint64_t *)(a1 + 112);
            long long v35 = *v129;
            unsigned int v19 = v140;
            if (*v129)
            {
              int v36 = *v129;
              do
              {
                BOOL v37 = sub_10114D5CC((unsigned __int16 *)v36 + 16, (unsigned __int16 *)&v145);
                uint64_t v38 = (uint64_t **)(v36 + 1);
                if (!v37)
                {
                  uint64_t v38 = (uint64_t **)v36;
                  uint64_t v34 = v36;
                }
                int v36 = *v38;
              }
              while (*v38);
              if (v34 != (uint64_t *)v129 && !sub_10114D5CC((unsigned __int16 *)&v145, (unsigned __int16 *)v34 + 16))
              {
                long long v39 = (uint64_t *)v34[1];
                char v40 = v34;
                if (v39)
                {
                  do
                  {
                    long long v41 = v39;
                    long long v39 = (uint64_t *)*v39;
                  }
                  while (v39);
                }
                else
                {
                  do
                  {
                    long long v41 = (uint64_t *)v40[2];
                    BOOL v42 = *v41 == (void)v40;
                    char v40 = v41;
                  }
                  while (!v42);
                }
                if (*v123 == v34) {
                  *long long v123 = v41;
                }
                --*(void *)(a1 + 120);
                sub_10005EE6C(v35, v34);
                *(void *)long long buf = v34 + 5;
                sub_101146B4C((void ***)buf);
                operator delete(v34);
              }
            }
            long long v43 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = v21;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v128;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v137;
              uint64_t v30 = v43;
              uint64_t v31 = "#I processUePolicyInstruction removed upsi: plmn[%u, %u] upsc 0x%x";
              uint32_t v32 = 20;
LABEL_37:
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, buf, v32);
            }
          }
LABEL_151:
          uint64_t v22 = *(void *)a2;
          uint64_t v23 = *((void *)a2 + 1);
          if (v23 - *(void *)a2 <= (unint64_t)(v142 + 1))
          {
            long long v121 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v19;
              long long v119 = v121;
              long long v120 = "processUePolicySectionManagementSublistContent incorrect index %u";
LABEL_161:
              _os_log_error_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, v120, buf, 8u);
            }
            goto LABEL_162;
          }
          v19 += (*(unsigned __int8 *)(v22 + v142 + 1) | (*(unsigned __int8 *)(v22 + v19) << 8)) + 2;
          if (v19 > v138) {
            goto LABEL_162;
          }
        }
      }
      long long v118 = *(NSObject **)(a1 + 56);
      if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v11;
        long long v119 = v118;
        long long v120 = "processUePolicySectionManagementSublist incorrect startIndex %u";
        goto LABEL_161;
      }
LABEL_162:
      uint64_t v10 = v130 + 1;
      if (v130 + 1 == v125) {
        return;
      }
    }
    long long v122 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "incorrect upsmBufferPlmnSublistOffset!", buf, 2u);
    }
  }
}

void sub_1011401EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void **a47)
{
  a47 = (void **)&a35;
  sub_101146B4C(&a47);
  _Unwind_Resume(a1);
}

void sub_101140270(void *a1, int *a2, void *a3, unsigned int a4)
{
}

uint64_t sub_10114028C(uint64_t a1, NSObject **a2, uint64_t *a3, int a4)
{
  int v4 = (PersonalitySpecificImpl *)a2;
  uint64_t v409 = 0;
  long long v408 = 0u;
  unint64_t v5 = (a4 + 4);
  memset(v407, 0, sizeof(v407));
  memset(v406, 0, sizeof(v406));
  *(_OWORD *)v404 = 0u;
  memset(v405, 0, sizeof(v405));
  long long v402 = 0u;
  memset(v403, 0, sizeof(v403));
  uint64_t v6 = *a3;
  if (a3[1] - *a3 > v5)
  {
    int v8 = *(unsigned __int8 *)(v6 + (a4 + 2));
    LOBYTE(v402) = *(unsigned char *)(v6 + (a4 + 2));
    int v9 = *(unsigned __int8 *)(v6 + v5) | (*(unsigned __int8 *)(v6 + (a4 + 3)) << 8);
    uint64_t v10 = a2[7];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v8;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I URSP rule precedenceValue = %u, trafficDescriptorLength = 0x%x", buf, 0xEu);
    }
    int64x2_t v11 = 0uLL;
    *(_OWORD *)v420 = 0u;
    long long v421 = 0u;
    memset(v419, 0, sizeof(v419));
    long long v418 = 0u;
    *(_OWORD *)v416 = 0u;
    memset(__src, 0, sizeof(__src));
    memset(v415, 0, sizeof(v415));
    *(_OWORD *)v413 = 0u;
    *(_OWORD *)std::string __str = 0u;
    *(_OWORD *)long long buf = 0u;
    unsigned int v12 = a4 + 5;
    int v391 = v9;
    unsigned int v13 = v9 + v5;
    v430 = 0;
    *(_OWORD *)v429 = 0u;
    *(_OWORD *)v427 = 0u;
    memset(v428, 0, sizeof(v428));
    memset(v426, 0, sizeof(v426));
    long long v424 = 0u;
    memset(v425, 0, sizeof(v425));
    *(_OWORD *)v422 = 0u;
    long long v423 = 0u;
    v399 = v4;
    if (a4 + 5 > (v9 + v5))
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint8_t v16 = 0;
      int64x2_t v17 = 0uLL;
      int64x2_t v18 = 0uLL;
      int64x2_t v19 = 0uLL;
      int64x2_t v20 = 0uLL;
      int64x2_t v21 = 0uLL;
LABEL_6:
      buf[0] = v16;
      *(void *)&uint8_t buf[8] = v15;
      *(void *)v413 = v14;
      *(void *)&v413[2] = *((void *)&v423 + 1);
      long long v423 = 0uLL;
      *(void *)&v422[8] = 0;
      *(int64x2_t *)std::string __str = v11;
      long long v424 = 0uLL;
      *(int64x2_t *)((char *)v415 + 8) = v17;
      *(void *)&v415[0] = *(void *)&v425[0];
      *((void *)&v415[1] + 1) = *((void *)&v425[1] + 1);
      memset(v425, 0, sizeof(v425));
      *(int64x2_t *)v416 = v18;
      memset(v426, 0, sizeof(v426));
      *(int64x2_t *)&__src[1] = v19;
      __src[0] = v426[2];
      __src[3] = v426[5];
      long long v418 = *(_OWORD *)v427;
      v427[0] = 0;
      v427[1] = 0;
      *(int64x2_t *)&v419[1] = v20;
      v419[0] = *(std::string **)&v428[0];
      v419[3] = *((std::string **)&v428[1] + 1);
      memset(v428, 0, sizeof(v428));
      *(int64x2_t *)v420 = v21;
      *(void *)&long long v421 = v430;
      v430 = 0;
      v429[1] = 0;
      v429[0] = 0;
      BYTE8(v421) = 1;
      goto LABEL_330;
    }
    unsigned int v389 = v13 + 1;
    unsigned int v397 = v9 + v5;
    while (1)
    {
      uint64_t v24 = *a3;
      long long v25 = (unsigned __int8 *)(*a3 + v12);
      unsigned int v26 = *v25;
      if (v26 > 0x7F)
      {
        switch(*v25)
        {
          case 0x80u:
            v12 += 4;
            goto LABEL_319;
          case 0x81u:
            v12 += 7;
            goto LABEL_319;
          case 0x82u:
          case 0x89u:
          case 0x8Au:
          case 0x8Bu:
          case 0x8Cu:
          case 0x8Du:
          case 0x8Eu:
          case 0x8Fu:
            goto LABEL_605;
          case 0x83u:
          case 0x84u:
          case 0x87u:
            goto LABEL_199;
          case 0x85u:
          case 0x86u:
            goto LABEL_215;
          case 0x88u:
            unint64_t v71 = v12 + 2;
            if (a3[1] - v24 <= v71)
            {
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeDnn wrong index %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            int v72 = *(unsigned __int8 *)(v24 + v12 + 1);
            unsigned int v73 = v12 + 1 + v72;
            if (v73 > v13)
            {
              v383 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v383, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v72;
              v380 = "#E processUrspTrafficDescriptor incorrect dnnLength=%u";
              v381 = v383;
              uint32_t v382 = 8;
              goto LABEL_637;
            }
            memset(&v438, 0, sizeof(v438));
            memset(&v433, 0, sizeof(v433));
            if (v71 > v73) {
              goto LABEL_228;
            }
            unsigned int v74 = v12 + 2;
            do
            {
              unsigned int v75 = v74 + *(unsigned __int8 *)(*a3 + v74);
              sub_101143CD0((std::string *)__p, (uint64_t)v4, a3, v74 + 1, v75);
              if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v433.__r_.__value_.__l.__data_);
              }
              std::string v433 = *(std::string *)__p;
              sub_1002055B4((const void **)&v438.__r_.__value_.__l.__data_, (const void **)&v433.__r_.__value_.__l.__data_, __p);
              uint64_t v76 = std::string::append((std::string *)__p, ".", 1uLL);
              std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
              v432.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v432.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
              char v78 = HIBYTE(v76->__r_.__value_.__r.__words[2]);
              v76->__r_.__value_.__l.__size_ = 0;
              v76->__r_.__value_.__r.__words[2] = 0;
              v76->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v438.__r_.__value_.__l.__data_);
              }
              v438.__r_.__value_.__r.__words[0] = v77;
              v438.__r_.__value_.__l.__size_ = v432.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)&v438.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v432.__r_.__value_.__r.__words + 7);
              *((unsigned char *)&v438.__r_.__value_.__s + 23) = v78;
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
              unsigned int v74 = v75 + 1;
            }
            while (v75 + 1 <= v73);
            if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0)
            {
              if (!v438.__r_.__value_.__l.__size_) {
                goto LABEL_228;
              }
              uint64_t v79 = v438.__r_.__value_.__l.__size_ - 1;
              unint64_t v80 = (std::string *)v438.__r_.__value_.__r.__words[0];
              --v438.__r_.__value_.__l.__size_;
            }
            else
            {
              if (!*((unsigned char *)&v438.__r_.__value_.__s + 23)) {
                goto LABEL_228;
              }
              uint64_t v79 = HIBYTE(v438.__r_.__value_.__r.__words[2]) - 1;
              --*((unsigned char *)&v438.__r_.__value_.__s + 23);
              unint64_t v80 = &v438;
            }
            v80->__r_.__value_.__s.__data_[v79] = 0;
LABEL_228:
            long long v169 = *((void *)v4 + 7);
            if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
            {
              v170 = &v438;
              if ((v438.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                v170 = (std::string *)v438.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)std::string __p = 136315138;
              *(void *)&__p[4] = v170;
              _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "#I processUrspTrafficDescriptor Td Dnn=%s", __p, 0xCu);
            }
            v171 = (_OWORD *)v423;
            if ((unint64_t)v423 >= *((void *)&v423 + 1))
            {
              unint64_t v174 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v423 - *(void *)&v422[8]) >> 3);
              unint64_t v175 = v174 + 1;
              if (v174 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              if (0x5555555555555556 * ((uint64_t)(*((void *)&v423 + 1) - *(void *)&v422[8]) >> 3) > v175) {
                unint64_t v175 = 0x5555555555555556 * ((uint64_t)(*((void *)&v423 + 1) - *(void *)&v422[8]) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v423 + 1) - *(void *)&v422[8]) >> 3) >= 0x555555555555555) {
                unint64_t v176 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v176 = v175;
              }
              *(void *)&long long v435 = (char *)&v423 + 8;
              if (v176) {
                v177 = (char *)sub_10004812C((uint64_t)&v423 + 8, v176);
              }
              else {
                v177 = 0;
              }
              v178 = &v177[24 * v174];
              *(void *)std::string __p = v177;
              *(void *)&__p[8] = v178;
              *(void *)&unsigned char __p[24] = &v177[24 * v176];
              long long v179 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
              *((void *)v178 + 2) = *((void *)&v438.__r_.__value_.__l + 2);
              *(_OWORD *)v178 = v179;
              memset(&v438, 0, sizeof(v438));
              *(void *)&__p[16] = v178 + 24;
              sub_100048204((uint64_t *)&v422[8], __p);
              v173 = (char *)v423;
              sub_100048174((uint64_t)__p);
            }
            else
            {
              long long v172 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
              *(void *)(v423 + 16) = *((void *)&v438.__r_.__value_.__l + 2);
              _OWORD *v171 = v172;
              memset(&v438, 0, sizeof(v438));
              v173 = (char *)v171 + 24;
            }
            *(void *)&long long v423 = v173;
            if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v433.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v438.__r_.__value_.__l.__data_);
            }
            unsigned int v12 = v71 + v72;
            goto LABEL_319;
          case 0x90u:
            unint64_t v49 = v12 + 1;
            unint64_t v50 = a3[1] - v24;
            if (v50 <= v49)
            {
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeConnectionCapabilities wrong index %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            uint64_t v51 = *(unsigned __int8 *)(v24 + v49);
            if (v50 <= (v49 + v51))
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeConnectionCapabilities wrong conn cap length %u";
              goto LABEL_654;
            }
            unsigned int v52 = v12 + 2;
            if (v51)
            {
              uint64_t v388 = v12 + 1;
              for (uint64_t i = 0; i != v51; ++i)
              {
                long long v54 = *((void *)v4 + 7);
                BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
                uint64_t v56 = *a3;
                uint64_t v57 = v52 + i;
                if (v55)
                {
                  int v58 = *(unsigned __int8 *)(v56 + v57);
                  *(_DWORD *)std::string __p = 67109120;
                  *(_DWORD *)&__p[4] = v58;
                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I UrspTdTypeConnectionCapabilities conn cap=%u", __p, 8u);
                  uint64_t v56 = *a3;
                }
                char v59 = (char *)v429[1];
                if (v429[1] >= v430)
                {
                  unint64_t v61 = (unint64_t)v429[0];
                  int64_t v62 = (char *)v429[1] - (char *)v429[0];
                  int64_t v63 = (char *)v429[1] - (char *)v429[0] + 1;
                  if (v63 < 0) {
                    sub_10006A748();
                  }
                  unint64_t v64 = v430 - (char *)v429[0];
                  if (2 * (v430 - (char *)v429[0]) > (unint64_t)v63) {
                    int64_t v63 = 2 * v64;
                  }
                  if (v64 >= 0x3FFFFFFFFFFFFFFFLL) {
                    size_t v65 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    size_t v65 = v63;
                  }
                  if (v65) {
                    unint64_t v66 = (char *)operator new(v65);
                  }
                  else {
                    unint64_t v66 = 0;
                  }
                  unint64_t v67 = &v66[v62];
                  v66[v62] = *(unsigned char *)(v56 + v57);
                  int v60 = &v66[v62 + 1];
                  if (v59 == (char *)v61)
                  {
                    int v4 = v399;
                    unsigned int v13 = v397;
                  }
                  else
                  {
                    uint64_t v68 = &v59[~v61];
                    int v4 = v399;
                    unsigned int v13 = v397;
                    do
                    {
                      char v69 = *--v59;
                      (v68--)[(void)v66] = v69;
                    }
                    while (v59 != (char *)v61);
                    char v59 = (char *)v429[0];
                    unint64_t v67 = v66;
                  }
                  v429[0] = v67;
                  v429[1] = v60;
                  v430 = &v66[v65];
                  if (v59) {
                    operator delete(v59);
                  }
                }
                else
                {
                  *(unsigned char *)v429[1] = *(unsigned char *)(v56 + v57);
                  int v60 = v59 + 1;
                  int v4 = v399;
                }
                v429[1] = v60;
              }
              int v70 = *(unsigned __int8 *)(*a3 + v388);
            }
            else
            {
              int v70 = 0;
            }
            unsigned int v12 = v52 + v70;
            goto LABEL_319;
          case 0x91u:
            unint64_t v38 = v12 + 1;
            if (a3[1] - v24 <= v38)
            {
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeDestinationFQDN wrong index %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            int v39 = *(unsigned __int8 *)(v24 + v38);
            memset(__p, 0, 24);
            unsigned int v40 = v38 + v39;
            memset(&v438, 0, sizeof(v438));
            if (v12 + 2 <= (int)v38 + v39)
            {
              unsigned int v41 = v12 + 2;
              do
              {
                if (a3[1] - *a3 <= (unint64_t)v41)
                {
                  unsigned int v140 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v433.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v433.__r_.__value_.__r.__words[0]) = v41;
                    _os_log_error_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_ERROR, "UrspTdTypeDestinationFQDN wrong fqdnLabelStartIndex %u", (uint8_t *)&v433, 8u);
                  }
                  char v141 = 0;
                  buf[0] = 0;
                  BYTE8(v421) = 0;
                  goto LABEL_263;
                }
                int v42 = *(unsigned __int8 *)(*a3 + v41);
                int v43 = v41 + v42;
                sub_101143CD0(&v433, (uint64_t)v4, a3, v41 + 1, v41 + v42);
                if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v438.__r_.__value_.__l.__data_);
                }
                std::string v438 = v433;
                sub_1002055B4((const void **)__p, (const void **)&v438.__r_.__value_.__l.__data_, &v433);
                unsigned int v44 = std::string::append(&v433, ".", 1uLL);
                std::string::size_type v45 = v44->__r_.__value_.__r.__words[0];
                v432.__r_.__value_.__r.__words[0] = v44->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v432.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v44->__r_.__value_.__r.__words[1] + 7);
                char v46 = HIBYTE(v44->__r_.__value_.__r.__words[2]);
                v44->__r_.__value_.__l.__size_ = 0;
                v44->__r_.__value_.__r.__words[2] = 0;
                v44->__r_.__value_.__r.__words[0] = 0;
                if ((__p[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__p);
                }
                *(void *)std::string __p = v45;
                *(void *)&__p[8] = v432.__r_.__value_.__r.__words[0];
                *(void *)&__p[15] = *(std::string::size_type *)((char *)v432.__r_.__value_.__r.__words + 7);
                __p[23] = v46;
                if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v433.__r_.__value_.__l.__data_);
                }
                unsigned int v41 = v43 + 1;
                unsigned int v13 = v397;
              }
              while (v43 + 1 <= v40);
              if ((__p[23] & 0x80000000) != 0)
              {
                if (!*(void *)&__p[8]) {
                  goto LABEL_252;
                }
                uint64_t v47 = *(void *)&__p[8] - 1;
                uint64_t v48 = *(unsigned char **)__p;
                --*(void *)&__p[8];
              }
              else
              {
                if (!__p[23]) {
                  goto LABEL_252;
                }
                uint64_t v47 = --__p[23];
                uint64_t v48 = __p;
              }
              v48[v47] = 0;
            }
LABEL_252:
            v180 = *((void *)v4 + 7);
            if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
            {
              v181 = __p;
              if (__p[23] < 0) {
                v181 = *(unsigned char **)__p;
              }
              LODWORD(v433.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v433.__r_.__value_.__r.__words + 4) = (std::string::size_type)v181;
              _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEFAULT, "#I processUrspTrafficDescriptor Fqdn=%s", (uint8_t *)&v433, 0xCu);
            }
            v182 = *(_OWORD **)&v428[1];
            if (*(void *)&v428[1] >= *((void *)&v428[1] + 1))
            {
              uint64_t v184 = sub_1000D8CE8((uint64_t *)v428 + 1, (long long *)__p);
            }
            else
            {
              if ((__p[23] & 0x80000000) != 0)
              {
                sub_10004FC84(*(unsigned char **)&v428[1], *(void **)__p, *(unint64_t *)&__p[8]);
              }
              else
              {
                long long v183 = *(_OWORD *)__p;
                *(void *)(*(void *)&v428[1] + 16) = *(void *)&__p[16];
                _OWORD *v182 = v183;
              }
              uint64_t v184 = (uint64_t)v182 + 24;
            }
            *(void *)&v428[1] = v184;
            v12 += 2 + v39;
            char v141 = 1;
LABEL_263:
            if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v438.__r_.__value_.__l.__data_);
            }
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            if ((v141 & 1) == 0) {
              goto LABEL_330;
            }
            break;
          case 0x92u:
            unint64_t v81 = v12 + 1;
            if (a3[1] - v24 <= v81)
            {
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeRegularExpression wrong index %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            v12 += *(unsigned __int8 *)(v24 + v81) + 2;
            goto LABEL_319;
          default:
            if (v26 == 160)
            {
              unint64_t v108 = v12 + 1;
              if (a3[1] - v24 <= v108)
              {
                v377 = *((void *)v4 + 7);
                if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_329;
                }
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeOsAppId wrong index %u";
                goto LABEL_654;
              }
              int v109 = *(unsigned __int8 *)(v24 + v108);
              sub_101143CD0(&v438, (uint64_t)v4, a3, v12 + 2, v108 + v109);
              long long v110 = (_OWORD *)*((void *)&v424 + 1);
              if (*((void *)&v424 + 1) >= *(void *)&v425[0])
              {
                unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v424 + 1) - v424) >> 3);
                unint64_t v129 = v128 + 1;
                if (v128 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  sub_1000D8578();
                }
                if (0x5555555555555556 * ((uint64_t)(*(void *)&v425[0] - v424) >> 3) > v129) {
                  unint64_t v129 = 0x5555555555555556 * ((uint64_t)(*(void *)&v425[0] - v424) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v425[0] - v424) >> 3) >= 0x555555555555555) {
                  unint64_t v130 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v130 = v129;
                }
                *(void *)&long long v435 = v425;
                if (v130) {
                  BOOL v131 = (char *)sub_10004812C((uint64_t)v425, v130);
                }
                else {
                  BOOL v131 = 0;
                }
                long long v163 = &v131[24 * v128];
                *(void *)std::string __p = v131;
                *(void *)&__p[8] = v163;
                *(void *)&unsigned char __p[24] = &v131[24 * v130];
                long long v164 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
                *((void *)v163 + 2) = *((void *)&v438.__r_.__value_.__l + 2);
                *(_OWORD *)long long v163 = v164;
                memset(&v438, 0, sizeof(v438));
                *(void *)&__p[16] = v163 + 24;
                sub_100048204((uint64_t *)&v424, __p);
                uint64_t v165 = *((void *)&v424 + 1);
                sub_100048174((uint64_t)__p);
                *((void *)&v424 + 1) = v165;
                if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v438.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                long long v111 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
                *(void *)(*((void *)&v424 + 1) + 16) = *((void *)&v438.__r_.__value_.__l + 2);
                *long long v110 = v111;
                *((void *)&v424 + 1) = (char *)v110 + 24;
              }
              v12 += 2 + v109;
            }
            else
            {
              if (v26 != 161) {
                goto LABEL_605;
              }
              v12 += 13;
            }
            goto LABEL_319;
        }
        goto LABEL_319;
      }
      if (*v25 <= 0x4Fu)
      {
        if (*v25 <= 0xFu)
        {
          if (v26 == 1)
          {
            if (v12 != v13)
            {
              v379 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v379, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_329;
              }
              *(_WORD *)std::string __p = 0;
              v380 = "#E Error: Match-All traffic descriptor has to be the only traffic descriptor in the URSP rule";
              v381 = v379;
              uint32_t v382 = 2;
LABEL_637:
              _os_log_impl((void *)&_mh_execute_header, v381, OS_LOG_TYPE_DEFAULT, v380, __p, v382);
              goto LABEL_329;
            }
            v422[0] = 1;
            unsigned int v12 = v389;
          }
          else
          {
            if (v26 != 8)
            {
LABEL_605:
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v26;
                v378 = "Unrecognized URSP traffic descriptor %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            if (a3[1] - v24 <= (unint64_t)(v12 + 17))
            {
              v377 = *((void *)v4 + 7);
              if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string __p = 67109120;
                *(_DWORD *)&__p[4] = v12;
                v378 = "UrspTdTypeOsIdAndOsAppId wrong index %u";
                goto LABEL_654;
              }
              goto LABEL_329;
            }
            *(_OWORD *)&v433.__r_.__value_.__l.__data_ = 0uLL;
            *(_OWORD *)&v433.__r_.__value_.__l.__data_ = *(_OWORD *)(v25 + 1);
            uint64_t v30 = (std::__shared_weak_count *)*((void *)v4 + 9);
            if (v30)
            {
              uint64_t v31 = std::__shared_weak_count::lock(v30);
              if (v31)
              {
                uint64_t v32 = *((void *)v4 + 8);
                if (v32)
                {
                  uint64_t v33 = PersonalitySpecificImpl::simSlot(v4);
                  if (((*(uint64_t (**)(uint64_t, uint64_t, std::string *))(*(void *)v32 + 48))(v32, v33, &v433) & 1) == 0)
                  {
                    v386 = *((void *)v4 + 7);
                    if (os_log_type_enabled(v386, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string __p = 0;
                      _os_log_impl((void *)&_mh_execute_header, v386, OS_LOG_TYPE_DEFAULT, "#I Skip traffic descriptor as it is NOT for iOS", __p, 2u);
                    }
                    buf[0] = 0;
                    BYTE8(v421) = 0;
                    sub_10004D2C8(v31);
                    goto LABEL_330;
                  }
                }
              }
            }
            else
            {
              uint64_t v31 = 0;
            }
            uint64_t v132 = v12 + 17;
            int v133 = *(unsigned __int8 *)(*a3 + v132);
            sub_101143CD0(&v438, (uint64_t)v4, a3, v12 + 18, v132 + v133);
            int v134 = (_OWORD *)*((void *)&v424 + 1);
            if (*((void *)&v424 + 1) >= *(void *)&v425[0])
            {
              unint64_t v136 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v424 + 1) - v424) >> 3);
              unint64_t v137 = v136 + 1;
              if (v136 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              if (0x5555555555555556 * ((uint64_t)(*(void *)&v425[0] - v424) >> 3) > v137) {
                unint64_t v137 = 0x5555555555555556 * ((uint64_t)(*(void *)&v425[0] - v424) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v425[0] - v424) >> 3) >= 0x555555555555555) {
                unint64_t v138 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v138 = v137;
              }
              *(void *)&long long v435 = v425;
              if (v138) {
                uint64_t v139 = (char *)sub_10004812C((uint64_t)v425, v138);
              }
              else {
                uint64_t v139 = 0;
              }
              long long v166 = &v139[24 * v136];
              *(void *)std::string __p = v139;
              *(void *)&__p[8] = v166;
              *(void *)&unsigned char __p[24] = &v139[24 * v138];
              long long v167 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
              *((void *)v166 + 2) = *((void *)&v438.__r_.__value_.__l + 2);
              *(_OWORD *)long long v166 = v167;
              memset(&v438, 0, sizeof(v438));
              *(void *)&__p[16] = v166 + 24;
              sub_100048204((uint64_t *)&v424, __p);
              uint64_t v168 = *((void *)&v424 + 1);
              sub_100048174((uint64_t)__p);
              *((void *)&v424 + 1) = v168;
              if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v438.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              long long v135 = *(_OWORD *)&v438.__r_.__value_.__l.__data_;
              *(void *)(*((void *)&v424 + 1) + 16) = *((void *)&v438.__r_.__value_.__l + 2);
              *int v134 = v135;
              *((void *)&v424 + 1) = (char *)v134 + 24;
            }
            v12 += v133 + 18;
            if (v31) {
              sub_10004D2C8(v31);
            }
          }
          goto LABEL_319;
        }
        if (v26 == 16)
        {
          unint64_t v89 = v12 + 8;
          if (a3[1] - v24 <= v89)
          {
            v377 = *((void *)v4 + 7);
            if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
              goto LABEL_329;
            }
            *(_DWORD *)std::string __p = 67109120;
            *(_DWORD *)&__p[4] = v12;
            v378 = "UrspTdTypeIpv4RemoteAddress wrong index %u";
            goto LABEL_654;
          }
          memset(__p, 0, 24);
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)__p);
          memset(&v438, 0, sizeof(v438));
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v438);
          int v90 = *(unsigned __int8 *)(*a3 + v12 + 5);
          int v91 = *(unsigned __int8 *)(*a3 + v12 + 6);
          int v92 = *(unsigned __int8 *)(*a3 + v12 + 7);
          int v93 = *(unsigned __int8 *)(*a3 + v89);
          CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)__p, (*(unsigned __int8 *)(*a3 + v12 + 1) << 24) | (*(unsigned __int8 *)(*a3 + v12 + 2) << 16) | (*(unsigned __int8 *)(*a3 + v12 + 3) << 8) | *(unsigned __int8 *)(*a3 + v12 + 4));
          CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v438, (v90 << 24) | (v91 << 16) | (v92 << 8) | v93);
          unsigned __int8 v94 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v438);
          CSIPacketAddress::setPrefixLen((CSIPacketAddress *)__p, v94);
          uint64_t v95 = *(void *)&v425[1];
          if (*(void *)&v425[1] >= *((void *)&v425[1] + 1))
          {
            uint64_t v96 = sub_101149DDC((uint64_t)v425 + 8, (const CSIPacketAddress *)__p);
          }
          else
          {
            CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)&v425[1], (const CSIPacketAddress *)__p);
            uint64_t v96 = v95 + 24;
          }
          *(void *)&v425[1] = v96;
          v12 += 9;
          goto LABEL_319;
        }
        if (v26 == 33)
        {
          unint64_t v86 = v12 + 17;
          if (a3[1] - v24 <= v86)
          {
            v377 = *((void *)v4 + 7);
            if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIPv6remoteAddressAndPrefixLength wrong index %u";
              goto LABEL_654;
            }
            goto LABEL_329;
          }
          memset(__p, 0, 24);
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)__p);
          CSIPacketAddress::setIPv6Address((CSIPacketAddress *)__p, (const unsigned __int8 *)(*a3 + v12 + 1), 0x10uLL);
          CSIPacketAddress::setPrefixLen((CSIPacketAddress *)__p, *(unsigned char *)(*a3 + v86));
          uint64_t v87 = *(void *)&v425[1];
          if (*(void *)&v425[1] >= *((void *)&v425[1] + 1))
          {
            uint64_t v88 = sub_101149DDC((uint64_t)v425 + 8, (const CSIPacketAddress *)__p);
          }
          else
          {
            CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)&v425[1], (const CSIPacketAddress *)__p);
            uint64_t v88 = v87 + 24;
          }
          *(void *)&v425[1] = v88;
          v12 += 18;
          goto LABEL_319;
        }
        if (v26 != 48) {
          goto LABEL_605;
        }
        unint64_t v27 = v12 + 1;
        if (a3[1] - v24 > v27)
        {
          long long v28 = (char *)v426[1];
          if (v426[1] >= v426[2])
          {
            unint64_t v122 = (unint64_t)v426[0];
            int64_t v123 = (char *)v426[1] - (char *)v426[0];
            int64_t v124 = (char *)v426[1] - (char *)v426[0] + 1;
            if (v124 < 0) {
              sub_10006A748();
            }
            unint64_t v125 = (char *)v426[2] - (char *)v426[0];
            if (2 * ((char *)v426[2] - (char *)v426[0]) > (unint64_t)v124) {
              int64_t v124 = 2 * v125;
            }
            if (v125 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v126 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v126 = v124;
            }
            if (v126) {
              v127 = (char *)operator new(v126);
            }
            else {
              v127 = 0;
            }
            long long v160 = &v127[v123];
            v127[v123] = *(unsigned char *)(v24 + v27);
            uint64_t v29 = &v127[v123 + 1];
            if (v28 != (char *)v122)
            {
              long long v161 = &v28[~v122];
              do
              {
                char v162 = *--v28;
                (v161--)[(void)v127] = v162;
              }
              while (v28 != (char *)v122);
              long long v28 = (char *)v426[0];
              long long v160 = v127;
            }
            v426[0] = v160;
            v426[1] = &v127[v123 + 1];
            v426[2] = &v127[v126];
            if (v28) {
              operator delete(v28);
            }
          }
          else
          {
            *(unsigned char *)v426[1] = *(unsigned char *)(v24 + v27);
            uint64_t v29 = v28 + 1;
          }
          v426[1] = v29;
LABEL_215:
          v12 += 2;
          goto LABEL_319;
        }
        v377 = *((void *)v4 + 7);
        if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string __p = 67109120;
          *(_DWORD *)&__p[4] = v12;
          v378 = "UrspTdTypeProtocolIdOrNextHeader wrong index %u";
          goto LABEL_654;
        }
LABEL_329:
        buf[0] = 0;
        BYTE8(v421) = 0;
LABEL_330:
        sub_101149F54((uint64_t)v422);
        v213 = *((void *)v4 + 7);
        if (!BYTE8(v421))
        {
          if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v422 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_ERROR, "processUrspRule invalid traffic descriptor", v422, 2u);
          }
          *(unsigned char *)a1 = 0;
          *(unsigned char *)(a1 + 232) = 0;
          goto LABEL_602;
        }
        if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v422 = 0;
          _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "#I processUrspRule adding td", v422, 2u);
          if (!BYTE8(v421)) {
            sub_10016C840();
          }
        }
        BYTE8(v402) = buf[0];
        sub_10005CA3C((uint64_t)v403, *(std::string **)&buf[8], *(long long **)v413, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v413 - *(void *)&buf[8]) >> 3));
        sub_10005CA3C((uint64_t)&v403[1] + 8, __str[0], (long long *)__str[1], 0xAAAAAAAAAAAAAAABLL * (((char *)__str[1] - (char *)__str[0]) >> 3));
        uint64_t v214 = *((void *)&v415[0] + 1);
        uint64_t v215 = *(void *)&v415[1];
        unint64_t v216 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v415[1] - *((void *)&v415[0] + 1)) >> 3);
        uint64_t v217 = *(void *)&v405[0];
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v405[0] - (unint64_t)v404[0]) >> 3) < v216)
        {
          if (v404[0])
          {
            v404[1] = v404[0];
            operator delete(v404[0]);
            uint64_t v217 = 0;
            v404[0] = 0;
            v404[1] = 0;
            *(void *)&v405[0] = 0;
          }
          if (v216 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A748();
          }
          unint64_t v218 = 0xAAAAAAAAAAAAAAABLL * (v217 >> 3);
          uint64_t v219 = 2 * v218;
          if (2 * v218 <= v216) {
            uint64_t v219 = v216;
          }
          if (v218 >= 0x555555555555555) {
            unint64_t v220 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v220 = v219;
          }
          sub_100157704(v404, v220);
          v221 = (char *)v404[1];
          if (v214 != v215)
          {
            uint64_t v222 = 0;
            do
            {
              CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v221[v222], (const CSIPacketAddress *)(v214 + v222));
              v222 += 24;
            }
            while (v214 + v222 != v215);
            goto LABEL_353;
          }
          goto LABEL_354;
        }
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v404[1] - (char *)v404[0]) >> 3) >= v216)
        {
          v404[1] = (void *)sub_101147874(*((uint64_t *)&v415[0] + 1), *(uint64_t *)&v415[1], (uint64_t)v404[0]);
        }
        else
        {
          uint64_t v223 = *((void *)&v415[0] + 1) + 8 * (((char *)v404[1] - (char *)v404[0]) >> 3);
          sub_101147874(*((uint64_t *)&v415[0] + 1), v223, (uint64_t)v404[0]);
          v221 = (char *)v404[1];
          if (v223 != v215)
          {
            uint64_t v222 = 0;
            do
            {
              CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v221[v222], (const CSIPacketAddress *)(v223 + v222));
              v222 += 24;
            }
            while (v223 + v222 != v215);
LABEL_353:
            v221 += v222;
          }
LABEL_354:
          v404[1] = v221;
        }
        sub_10006E4A8((void *)v405 + 1, (char *)v416[0], (char *)v416[1], (char *)v416[1] - (char *)v416[0]);
        sub_1003BA328((char *)v406, (char *)__src[1], (uint64_t)__src[2], ((char *)__src[2] - (char *)__src[1]) >> 1);
        v224 = (int *)*((void *)&v418 + 1);
        v225 = (int *)v418;
        uint64_t v226 = *((void *)&v418 + 1) - v418;
        unint64_t v227 = (uint64_t)(*((void *)&v418 + 1) - v418) >> 2;
        uint64_t v228 = *((void *)&v406[2] + 1);
        v229 = (char *)*((void *)&v406[1] + 1);
        if (v227 <= (uint64_t)(*((void *)&v406[2] + 1) - *((void *)&v406[1] + 1)) >> 2)
        {
          v232 = *(char **)&v406[2];
          unint64_t v236 = (uint64_t)(*(void *)&v406[2] - *((void *)&v406[1] + 1)) >> 2;
          if (v236 >= v227)
          {
            uint64_t v242 = *((void *)&v406[1] + 1);
            if ((void)v418 != *((void *)&v418 + 1))
            {
              v243 = (_DWORD *)*((void *)&v406[1] + 1);
              do
              {
                int v244 = *v225++;
                *v243++ = v244;
                v242 += 4;
              }
              while (v225 != v224);
            }
            v235 = (char *)(v242 - (void)v229);
            v232 = v229;
          }
          else
          {
            v237 = (int *)(v418 + 4 * v236);
            if (*(void *)&v406[2] != *((void *)&v406[1] + 1))
            {
              do
              {
                int v238 = *v225++;
                *(_DWORD *)v229 = v238;
                v229 += 4;
              }
              while (v225 != v237);
            }
            v239 = v232;
            if (v237 != v224)
            {
              v240 = v232;
              do
              {
                int v241 = *v237++;
                *(_DWORD *)v240 = v241;
                v240 += 4;
                v239 += 4;
              }
              while (v237 != v224);
            }
            v235 = (char *)(v239 - v232);
          }
        }
        else
        {
          if (*((void *)&v406[1] + 1))
          {
            *(void *)&v406[2] = *((void *)&v406[1] + 1);
            operator delete(*((void **)&v406[1] + 1));
            uint64_t v228 = 0;
            memset((char *)&v406[1] + 8, 0, 24);
          }
          if (v226 < 0) {
            sub_10006A748();
          }
          uint64_t v230 = v228 >> 1;
          if (v228 >> 1 <= v227) {
            uint64_t v230 = v227;
          }
          if ((unint64_t)v228 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v231 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v231 = v230;
          }
          sub_10005CCE8((void *)&v406[1] + 1, v231);
          v232 = *(char **)&v406[2];
          v233 = *(char **)&v406[2];
          if (v225 != v224)
          {
            v233 = *(char **)&v406[2];
            do
            {
              int v234 = *v225++;
              *(_DWORD *)v233 = v234;
              v233 += 4;
            }
            while (v225 != v224);
          }
          v235 = (char *)(v233 - v232);
        }
        *(void *)&v406[2] = &v235[(void)v232];
        sub_10005CA3C((uint64_t)v407, v419[1], (long long *)v419[2], 0xAAAAAAAAAAAAAAABLL * (((char *)v419[2] - (char *)v419[1]) >> 3));
        sub_10006E4A8((void *)&v407[1] + 1, (char *)v420[0], (char *)v420[1], (char *)v420[1] - (char *)v420[0]);
        unint64_t v245 = (a4 + v391 + 6);
        if (a3[1] - *a3 <= v245)
        {
          v355 = *((void *)v4 + 7);
          if (os_log_type_enabled(v355, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v422 = 67109120;
            *(_DWORD *)&v422[4] = v391;
            _os_log_error_impl((void *)&_mh_execute_header, v355, OS_LOG_TYPE_ERROR, "processUrspRule incorrect tdlength=0x%x", v422, 8u);
          }
          *(unsigned char *)a1 = 0;
          *(unsigned char *)(a1 + 232) = 0;
          goto LABEL_602;
        }
        int v246 = *(unsigned __int8 *)(*a3 + v245) | (*(unsigned __int8 *)(*a3 + (v391 + a4 + 5)) << 8);
        v247 = *((void *)v4 + 7);
        if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v422 = 67109120;
          *(_DWORD *)&v422[4] = v246;
          _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_DEFAULT, "#I processUrspRule length of rsd list=0x%x", v422, 8u);
        }
        unint64_t v248 = 0;
        unint64_t v401 = 0;
        int64x2_t v249 = 0uLL;
        int64x2_t v400 = 0u;
        unsigned int v250 = a4 + v391 + 7;
        unsigned int v251 = v246 + v245;
        unint64_t v411 = 0;
        int64x2_t v410 = 0u;
        if (v250 > v246 + (int)v245) {
          goto LABEL_574;
        }
        unsigned int v395 = v246 + v245;
        while (1)
        {
          unint64_t v252 = v250 + 1;
          uint64_t v253 = *a3;
          unint64_t v254 = a3[1] - *a3;
          if (v254 <= v252)
          {
            v356 = *((void *)v4 + 7);
            if (os_log_type_enabled(v356, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v422 = 67109120;
              *(_DWORD *)&v422[4] = v250;
              _os_log_impl((void *)&_mh_execute_header, v356, OS_LOG_TYPE_DEFAULT, "#E processUrspRouteSelectionDescriptorList wrong startIndex %u", v422, 8u);
            }
            v357 = &v400;
LABEL_575:
            v357->i64[0] = 0;
            v357->i64[1] = 0;
            v357[1].i64[0] = 0;
            *(void *)v422 = &v410;
            sub_1011477A4((void ***)v422);
            v359 = (__int16 *)v400.i64[1];
            v358 = (unsigned __int8 *)v400.i64[0];
            v360 = *((void *)v4 + 7);
            if (v400.i64[0] == v400.i64[1])
            {
              if (os_log_type_enabled(v360, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v422 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v360, OS_LOG_TYPE_ERROR, "processUrspRule invalid route selection descriptor list", v422, 2u);
              }
              char v369 = 0;
              uint64_t v370 = a1;
              *(unsigned char *)a1 = 0;
              goto LABEL_601;
            }
            if (os_log_type_enabled(v360, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v422 = 0;
              _os_log_impl((void *)&_mh_execute_header, v360, OS_LOG_TYPE_DEFAULT, "#I processUrspRule adding rsdList", v422, 2u);
              v359 = (__int16 *)v400.i64[1];
              v358 = (unsigned __int8 *)v400.i64[0];
            }
            unint64_t v361 = 126 - 2 * __clz(0xEEEEEEEEEEEEEEEFLL * (((char *)v359 - (char *)v358) >> 3));
            if (v359 == (__int16 *)v358) {
              uint64_t v362 = 0;
            }
            else {
              uint64_t v362 = v361;
            }
            sub_1011478CC(v358, v359, v362, 1);
            int64x2_t v363 = v400;
            unint64_t v364 = 0xEEEEEEEEEEEEEEEFLL * ((v400.i64[1] - v400.i64[0]) >> 3);
            if (0xEEEEEEEEEEEEEEEFLL * ((v409 - (uint64_t)v408) >> 3) >= v364)
            {
              if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)&v408 + 1) - v408) >> 3) >= v364)
              {
                uint64_t v372 = sub_101149A20((__int16 *)v400.i64[0], (__int16 *)v400.i64[1], v408);
                for (uint64_t j = *((void *)&v408 + 1); j != v372; sub_10114774C(j))
                  j -= 120;
                *((void *)&v408 + 1) = v372;
                goto LABEL_600;
              }
              v371 = (__int16 *)(v400.i64[0] + 8 * ((uint64_t)(*((void *)&v408 + 1) - v408) >> 3));
              sub_101149A20((__int16 *)v400.i64[0], v371, v408);
              uint64_t v368 = sub_1011471EC((uint64_t)v371, v363.i64[1], *((uint64_t *)&v408 + 1));
            }
            else
            {
              sub_1011499B8((void **)&v408);
              if (v364 > 0x222222222222222) {
                goto LABEL_666;
              }
              unint64_t v365 = 0xDDDDDDDDDDDDDDDELL * ((v409 - (uint64_t)v408) >> 3);
              if (v365 <= v364) {
                unint64_t v365 = v364;
              }
              unint64_t v366 = 0xEEEEEEEEEEEEEEEFLL * ((v409 - (uint64_t)v408) >> 3) >= 0x111111111111111
                   ? 0x222222222222222
                   : v365;
              if (v366 > 0x222222222222222) {
LABEL_666:
              }
                sub_10006A748();
              *(void *)&long long v408 = sub_100448470(v366);
              *((void *)&v408 + 1) = v408;
              uint64_t v409 = v408 + 120 * v367;
              uint64_t v368 = sub_1011471EC(v363.i64[0], v363.i64[1], v408);
            }
            *((void *)&v408 + 1) = v368;
LABEL_600:
            uint64_t v370 = a1;
            *(unsigned char *)a1 = v402;
            *(unsigned char *)(a1 + 8) = BYTE8(v402);
            *(_OWORD *)(a1 + 16) = v403[0];
            *(void *)(a1 + 32) = *(void *)&v403[1];
            memset(v403, 0, 24);
            *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)&v403[1] + 8);
            *(void *)(a1 + 56) = *((void *)&v403[2] + 1);
            memset((char *)&v403[1] + 8, 0, 24);
            *(_OWORD *)(a1 + 64) = *(_OWORD *)v404;
            *(void *)(a1 + 80) = *(void *)&v405[0];
            v404[0] = 0;
            v404[1] = 0;
            *(void *)&v405[0] = 0;
            *(_OWORD *)(a1 + 88) = *(_OWORD *)((char *)v405 + 8);
            *(void *)(a1 + 104) = *((void *)&v405[1] + 1);
            memset((char *)v405 + 8, 0, 24);
            *(_OWORD *)(a1 + 112) = v406[0];
            uint64_t v374 = *((void *)&v406[2] + 1);
            *(void *)(a1 + 128) = *(void *)&v406[1];
            memset(v406, 0, 24);
            *(_OWORD *)(a1 + 136) = *(_OWORD *)((char *)&v406[1] + 8);
            *(void *)(a1 + 152) = v374;
            memset((char *)&v406[1] + 8, 0, 24);
            *(_OWORD *)(a1 + 160) = v407[0];
            uint64_t v375 = *((void *)&v407[2] + 1);
            *(void *)(a1 + 176) = *(void *)&v407[1];
            memset(v407, 0, 24);
            *(_OWORD *)(a1 + 184) = *(_OWORD *)((char *)&v407[1] + 8);
            *(void *)(a1 + 200) = v375;
            memset((char *)&v407[1] + 8, 0, 24);
            *(_OWORD *)(a1 + 208) = v408;
            *(void *)(a1 + 224) = v409;
            long long v408 = 0uLL;
            char v369 = 1;
            uint64_t v409 = 0;
LABEL_601:
            *(unsigned char *)(v370 + 232) = v369;
            *(void *)v422 = &v400;
            sub_1011477A4((void ***)v422);
LABEL_602:
            if (BYTE8(v421)) {
              sub_101149F54((uint64_t)buf);
            }
            goto LABEL_604;
          }
          int v255 = *(unsigned __int8 *)(v253 + v252) | (*(unsigned __int8 *)(v253 + v250) << 8);
          v256 = *((void *)v4 + 7);
          int v398 = v255;
          if (os_log_type_enabled(v256, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v422 = 67109120;
            *(_DWORD *)&v422[4] = v255;
            _os_log_impl((void *)&_mh_execute_header, v256, OS_LOG_TYPE_DEFAULT, "#I processUrspRouteSelectionDescriptorList rsdLength=0x%x", v422, 8u);
            uint64_t v253 = *a3;
            unint64_t v254 = a3[1] - *a3;
          }
          memset(v426, 0, sizeof(v426));
          long long v424 = 0u;
          memset(v425, 0, sizeof(v425));
          *(_OWORD *)v422 = 0u;
          long long v423 = 0u;
          unint64_t v257 = v250 + 4;
          memset(v437, 0, 56);
          long long v436 = 0u;
          long long v435 = 0u;
          memset(__p, 0, sizeof(__p));
          if (v254 <= v257)
          {
            v319 = *((void *)v4 + 7);
            if (os_log_type_enabled(v319, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(v438.__r_.__value_.__r.__words[0]) = v250;
              _os_log_error_impl((void *)&_mh_execute_header, v319, OS_LOG_TYPE_ERROR, "processRouteSelectionDescriptor wrong index %u", (uint8_t *)&v438, 8u);
            }
LABEL_510:
            char v265 = 0;
            v422[0] = 0;
            goto LABEL_516;
          }
          __p[0] = *(unsigned char *)(v253 + v250 + 2);
          int v258 = *(unsigned __int8 *)(v253 + v257) | (*(unsigned __int8 *)(v253 + v250 + 3) << 8);
          v259 = *((void *)v4 + 7);
          if (os_log_type_enabled(v259, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
            HIDWORD(v438.__r_.__value_.__r.__words[0]) = v258;
            _os_log_impl((void *)&_mh_execute_header, v259, OS_LOG_TYPE_DEFAULT, "#I processRouteSelectionDescriptor rsdContentsLength=0x%x", (uint8_t *)&v438, 8u);
          }
          unsigned int v260 = v398 + v252;
          unsigned int v261 = v250 + 5;
          if (v258 + v257 != v260)
          {
            v320 = *((void *)v4 + 7);
            if (!os_log_type_enabled(v320, OS_LOG_TYPE_ERROR)) {
              goto LABEL_512;
            }
            LODWORD(v438.__r_.__value_.__l.__data_) = 67109632;
            HIDWORD(v438.__r_.__value_.__r.__words[0]) = v250 + 5;
            LOWORD(v438.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&v438.__r_.__value_.__r.__words[1] + 2) = v258;
            HIWORD(v438.__r_.__value_.__r.__words[1]) = 1024;
            LODWORD(v438.__r_.__value_.__r.__words[2]) = v260;
            v342 = v320;
            v343 = "incorrect rsd contents legnth %u, %u, %u";
            uint32_t v344 = 20;
            goto LABEL_546;
          }
          if (v261 <= v260) {
            break;
          }
LABEL_393:
          uint64_t v262 = *(void *)&__p[16];
          if (__p[2] || *(void *)&__p[8] != *(void *)&__p[16])
          {
            uint64_t v264 = *((void *)&v437[0] + 1);
            uint64_t v263 = *(void *)&v437[0];
            unsigned int v251 = v395;
          }
          else
          {
            uint64_t v264 = *((void *)&v437[0] + 1);
            uint64_t v263 = *(void *)&v437[0];
            unsigned int v251 = v395;
            if ((void)v435 != *((void *)&v435 + 1)
              || BYTE9(v436)
              || *(_WORD *)((char *)&v436 + 11)
              || BYTE13(v436)
              || *(void *)&v437[0] != *((void *)&v437[0] + 1)
              || BYTE8(v437[2])
              || LOBYTE(v437[3])
              || BYTE2(v437[3]))
            {
              uint64_t v262 = *(void *)&__p[8];
            }
            else
            {
              uint64_t v262 = *(void *)&__p[8];
              if (!BYTE4(v437[3]))
              {
                char v265 = 0;
                v422[0] = 0;
                goto LABEL_516;
              }
            }
          }
          *(_WORD *)v422 = *(_WORD *)__p;
          v422[2] = __p[2];
          *(void *)&v422[8] = *(void *)&__p[8];
          *(void *)&long long v423 = v262;
          uint64_t v321 = *(void *)&__p[24];
          memset(&__p[8], 0, 24);
          *((void *)&v423 + 1) = v321;
          long long v424 = v435;
          *(void *)&v425[0] = v436;
          *(void *)&long long v436 = 0;
          long long v435 = 0uLL;
          WORD6(v425[0]) = WORD6(v436);
          DWORD2(v425[0]) = DWORD2(v436);
          *(void *)&v425[1] = v263;
          *((void *)&v425[1] + 1) = v264;
          v426[0] = *(void **)&v437[1];
          memset(v437, 0, 24);
          *(_OWORD *)((char *)&v426[2] + 5) = *(_OWORD *)((char *)&v437[2] + 5);
          char v265 = 1;
          *(_OWORD *)&v426[1] = *(_OWORD *)((char *)&v437[1] + 8);
LABEL_516:
          LOBYTE(v426[5]) = v265;
          v438.__r_.__value_.__r.__words[0] = (std::string::size_type)v437;
          sub_1011476C8((void ***)&v438);
          v438.__r_.__value_.__r.__words[0] = (std::string::size_type)&v435;
          sub_100047F64((void ***)&v438);
          if (*(void *)&__p[8])
          {
            *(void *)&__p[16] = *(void *)&__p[8];
            operator delete(*(void **)&__p[8]);
          }
          int v322 = LOBYTE(v426[5]);
          v323 = *((void *)v4 + 7);
          BOOL v324 = os_log_type_enabled(v323, OS_LOG_TYPE_DEFAULT);
          if (v322)
          {
            if (v324)
            {
              *(_WORD *)std::string __p = 0;
              _os_log_impl((void *)&_mh_execute_header, v323, OS_LOG_TYPE_DEFAULT, "#I processUrspRouteSelectionDescriptorList adding rsd", __p, 2u);
              if (!LOBYTE(v426[5])) {
                sub_10016C840();
              }
            }
            uint64_t v325 = v410.i64[1];
            if (v410.i64[1] >= v411)
            {
              unint64_t v328 = 0xEEEEEEEEEEEEEEEFLL * ((v410.i64[1] - v410.i64[0]) >> 3);
              unint64_t v329 = v328 + 1;
              if (v328 + 1 > 0x222222222222222) {
                sub_10006A748();
              }
              if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v411 - v410.i64[0]) >> 3) > v329) {
                unint64_t v329 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v411 - v410.i64[0]) >> 3);
              }
              if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v411 - v410.i64[0]) >> 3) >= 0x111111111111111) {
                unint64_t v330 = 0x222222222222222;
              }
              else {
                unint64_t v330 = v329;
              }
              *(void *)&long long v435 = &v411;
              if (v330) {
                unint64_t v330 = (unint64_t)sub_100448470(v330);
              }
              else {
                uint64_t v331 = 0;
              }
              int v327 = v398;
              *(void *)std::string __p = v330;
              *(void *)&__p[8] = v330 + 120 * v328;
              *(void *)&__p[16] = *(void *)&__p[8];
              *(void *)&unsigned char __p[24] = v330 + 120 * v331;
              sub_101147270(*(uint64_t *)&__p[8], (__int16 *)v422);
              uint64_t v332 = *(void *)&__p[8];
              uint64_t v326 = *(void *)&__p[16] + 120;
              *(void *)&__p[16] += 120;
              uint64_t v333 = v410.i64[1];
              uint64_t v334 = v410.i64[0];
              if (v410.i64[1] == v410.i64[0])
              {
                int64x2_t v339 = vdupq_n_s64(v410.u64[1]);
              }
              else
              {
                do
                {
                  __int16 v335 = *(_WORD *)(v333 - 120);
                  v333 -= 120;
                  char v336 = *(unsigned char *)(v333 + 2);
                  *(_WORD *)(v332 - 120) = v335;
                  v332 -= 120;
                  *(unsigned char *)(v332 + 2) = v336;
                  *(void *)(v332 + 16) = 0;
                  *(void *)(v332 + 24) = 0;
                  *(void *)(v332 + 8) = 0;
                  *(_OWORD *)(v332 + 8) = *(_OWORD *)(v333 + 8);
                  *(void *)(v332 + 24) = *(void *)(v333 + 24);
                  *(void *)(v333 + 8) = 0;
                  *(void *)(v333 + 16) = 0;
                  *(void *)(v333 + 24) = 0;
                  *(void *)(v332 + 32) = 0;
                  *(void *)(v332 + 40) = 0;
                  *(void *)(v332 + 48) = 0;
                  *(_OWORD *)(v332 + 32) = *(_OWORD *)(v333 + 32);
                  *(void *)(v332 + 48) = *(void *)(v333 + 48);
                  *(void *)(v333 + 32) = 0;
                  *(void *)(v333 + 40) = 0;
                  *(void *)(v333 + 48) = 0;
                  int v337 = *(_DWORD *)(v333 + 56);
                  *(_WORD *)(v332 + 60) = *(_WORD *)(v333 + 60);
                  *(void *)(v332 + 72) = 0;
                  *(void *)(v332 + 80) = 0;
                  *(void *)(v332 + 64) = 0;
                  *(_DWORD *)(v332 + 56) = v337;
                  *(_OWORD *)(v332 + 64) = *(_OWORD *)(v333 + 64);
                  *(void *)(v332 + 80) = *(void *)(v333 + 80);
                  *(void *)(v333 + 64) = 0;
                  *(void *)(v333 + 72) = 0;
                  *(void *)(v333 + 80) = 0;
                  long long v338 = *(_OWORD *)(v333 + 88);
                  *(_OWORD *)(v332 + 101) = *(_OWORD *)(v333 + 101);
                  *(_OWORD *)(v332 + 88) = v338;
                }
                while (v333 != v334);
                int64x2_t v339 = v410;
                uint64_t v326 = *(void *)&__p[16];
              }
              v410.i64[0] = v332;
              v410.i64[1] = v326;
              *(int64x2_t *)&__p[8] = v339;
              unint64_t v340 = v411;
              unint64_t v411 = *(void *)&__p[24];
              *(void *)&unsigned char __p[24] = v340;
              *(void *)std::string __p = v339.i64[0];
              sub_10114A000((uint64_t)__p);
            }
            else
            {
              sub_101147270(v410.i64[1], (__int16 *)v422);
              uint64_t v326 = v325 + 120;
              int v327 = v398;
            }
            v410.i64[1] = v326;
          }
          else
          {
            int v327 = v398;
            if (v324)
            {
              *(_WORD *)std::string __p = 0;
              _os_log_impl((void *)&_mh_execute_header, v323, OS_LOG_TYPE_DEFAULT, "#I processUrspRouteSelectionDescriptorList skip invalid rsd", __p, 2u);
            }
          }
          v250 += v327 + 2;
          sub_10114A050((uint64_t)v422);
          if (v250 > v251)
          {
            int64x2_t v249 = v410;
            unint64_t v248 = v411;
LABEL_574:
            int64x2_t v400 = v249;
            unint64_t v401 = v248;
            v357 = &v410;
            goto LABEL_575;
          }
        }
        while (2)
        {
          uint64_t v266 = *a3;
          unint64_t v267 = a3[1] - *a3;
          if (v267 <= v261)
          {
            v341 = *((void *)v4 + 7);
            if (os_log_type_enabled(v341, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
              v342 = v341;
              v343 = "rsd wrong index %u";
              goto LABEL_544;
            }
            goto LABEL_512;
          }
          unsigned int v268 = *(unsigned __int8 *)(v266 + v261);
          if (v268 > 0x1F)
          {
            switch(*(unsigned char *)(v266 + v261))
            {
              case 0x80:
                v271 = *((void *)v4 + 7);
                if (os_log_type_enabled(v271, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v438.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v271, OS_LOG_TYPE_DEFAULT, "#I UrspRsdTypeTimeWindow skip", (uint8_t *)&v438, 2u);
                }
                v261 += 17;
                goto LABEL_458;
              case 0x81:
                LOBYTE(v437[3]) = 1;
                goto LABEL_452;
              case 0x82:
                unint64_t v290 = v261 + 1;
                if (v267 <= v290)
                {
                  v351 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v351, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v351;
                    v343 = "UrspRsdTypePduSessionPairId wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                *(_WORD *)((char *)&v437[3] + 1) = *(unsigned __int8 *)(v266 + v290) | 0x100;
                break;
              case 0x83:
                unint64_t v291 = v261 + 1;
                if (v267 <= v291)
                {
                  v350 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v350;
                    v343 = "UrspRsdTypeRsn wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                *(_WORD *)((char *)&v437[3] + 3) = *(unsigned __int8 *)(v266 + v291) | 0x100;
                break;
              default:
                if (v268 == 32)
                {
                  BYTE13(v436) = 1;
                  goto LABEL_452;
                }
                if (v268 != 64) {
                  goto LABEL_547;
                }
                int v272 = *(unsigned __int8 *)(v266 + v261 + 1);
                v273 = *((void *)v4 + 7);
                if (os_log_type_enabled(v273, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v438.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v273, OS_LOG_TYPE_DEFAULT, "#I UrspRsdTypeLocationCriteria skip", (uint8_t *)&v438, 2u);
                }
                v261 += v272 + 2;
                goto LABEL_458;
            }
          }
          else
          {
            switch(*(unsigned char *)(v266 + v261))
            {
              case 1:
                unint64_t v269 = v261 + 1;
                if (v267 <= v269)
                {
                  v346 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v346, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v346;
                    v343 = "UrspRsdTypeSscMode wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                char v270 = *(unsigned char *)(v266 + v269);
                if (!__p[2]) {
                  __p[2] = 1;
                }
                __p[1] = v270 & 7;
                break;
              case 2:
                unint64_t v285 = v261 + 5;
                if (v267 <= v285)
                {
                  v347 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v347, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v347;
                    v343 = "UrspRsdTypeSnssai wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                int v286 = *(unsigned __int8 *)(v266 + v261 + 1);
                if (v286 == 1)
                {
                  char v390 = 0;
                  int v287 = 0;
                  int v288 = 0;
                  int v289 = 3;
                }
                else
                {
                  if (v286 != 4)
                  {
                    v354 = *((void *)v4 + 7);
                    if (!os_log_type_enabled(v354, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_512;
                    }
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v286;
                    v342 = v354;
                    v343 = "wrong UrspRsdTypeSnssai length %u";
LABEL_544:
                    uint32_t v344 = 8;
LABEL_546:
                    _os_log_error_impl((void *)&_mh_execute_header, v342, OS_LOG_TYPE_ERROR, v343, (uint8_t *)&v438, v344);
                    goto LABEL_512;
                  }
                  int v286 = 0;
                  int v287 = *(unsigned __int8 *)(v266 + v261 + 4) | (*(unsigned __int8 *)(v266 + v261 + 3) << 8);
                  int v288 = *(unsigned __int8 *)(v266 + v285);
                  char v390 = 1;
                  int v289 = 6;
                }
                int v393 = v289;
                int v294 = *(unsigned __int8 *)(v266 + v261 + 2);
                v295 = *((void *)v399 + 7);
                if (os_log_type_enabled(v295, OS_LOG_TYPE_DEFAULT))
                {
                  int v296 = v288 | (v287 << 8);
                  LODWORD(v438.__r_.__value_.__l.__data_) = 67109376;
                  HIDWORD(v438.__r_.__value_.__r.__words[0]) = v294;
                  if (v286) {
                    int v296 = 0xFFFFFF;
                  }
                  LOWORD(v438.__r_.__value_.__r.__words[1]) = 1024;
                  *(_DWORD *)((char *)&v438.__r_.__value_.__r.__words[1] + 2) = v296;
                  _os_log_impl((void *)&_mh_execute_header, v295, OS_LOG_TYPE_DEFAULT, "#I UrspRsdTypeSnssai add [sst:%d, sd:%d]", (uint8_t *)&v438, 0xEu);
                }
                uint64_t v297 = *(void *)&__p[16];
                if (*(void *)&__p[16] >= *(void *)&__p[24])
                {
                  unint64_t v299 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__p[16] - *(void *)&__p[8]) >> 3);
                  unint64_t v300 = v299 + 1;
                  if (v299 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    sub_10006A748();
                  }
                  if (0x5555555555555556 * ((uint64_t)(*(void *)&__p[24] - *(void *)&__p[8]) >> 3) > v300) {
                    unint64_t v300 = 0x5555555555555556 * ((uint64_t)(*(void *)&__p[24] - *(void *)&__p[8]) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__p[24] - *(void *)&__p[8]) >> 3) >= 0x555555555555555) {
                    unint64_t v301 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v301 = v300;
                  }
                  if (v301) {
                    unint64_t v301 = (unint64_t)sub_100601864(v301);
                  }
                  else {
                    uint64_t v302 = 0;
                  }
                  unint64_t v303 = v301 + 24 * v299;
                  *(unsigned char *)unint64_t v303 = v294;
                  *(_WORD *)(v303 + 1) = 0;
                  *(unsigned char *)(v303 + 3) = 0;
                  *(_DWORD *)(v303 + 4) = v288 | (v287 << 8);
                  *(unsigned char *)(v303 + 8) = v390;
                  *(void *)(v303 + 9) = 0;
                  *(void *)(v303 + 16) = 0;
                  v304 = *(char **)&__p[16];
                  v305 = *(char **)&__p[8];
                  unint64_t v306 = v303;
                  if (*(void *)&__p[16] == *(void *)&__p[8])
                  {
                    int v4 = v399;
                  }
                  else
                  {
                    int v4 = v399;
                    do
                    {
                      long long v307 = *(_OWORD *)(v304 - 24);
                      *(void *)(v306 - 8) = *((void *)v304 - 1);
                      *(_OWORD *)(v306 - 24) = v307;
                      v306 -= 24;
                      v304 -= 24;
                    }
                    while (v304 != v305);
                    v304 = *(char **)&__p[8];
                  }
                  unint64_t v298 = v303 + 24;
                  *(void *)&__p[8] = v306;
                  *(void *)&__p[16] = v303 + 24;
                  *(void *)&unsigned char __p[24] = v301 + 24 * v302;
                  if (v304) {
                    operator delete(v304);
                  }
                }
                else
                {
                  **(unsigned char **)&__p[16] = v294;
                  *(_WORD *)(v297 + 1) = 0;
                  *(unsigned char *)(v297 + 3) = 0;
                  *(_DWORD *)(v297 + 4) = v288 | (v287 << 8);
                  *(unsigned char *)(v297 + 8) = v390;
                  unint64_t v298 = v297 + 24;
                  *(void *)(v297 + 9) = 0;
                  *(void *)(v297 + 16) = 0;
                  int v4 = v399;
                }
                v261 += v393;
                *(void *)&__p[16] = v298;
                goto LABEL_458;
              case 3:
              case 5:
              case 6:
              case 7:
                goto LABEL_547;
              case 4:
                unint64_t v276 = v261 + 2;
                if (v267 <= v276)
                {
                  v348 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v348, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v348;
                    v343 = "UrspRsdTypeDnn wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                int v392 = *(unsigned __int8 *)(v266 + v261 + 1);
                unsigned int v277 = v261 + 1 + v392;
                if (v277 > v260)
                {
                  v353 = *((void *)v4 + 7);
                  unsigned int v251 = v395;
                  if (os_log_type_enabled(v353, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v392;
                    _os_log_impl((void *)&_mh_execute_header, v353, OS_LOG_TYPE_DEFAULT, "#E processUrspTrafficDescriptor incorrect dnnLength=%u", (uint8_t *)&v438, 8u);
                  }
                  goto LABEL_510;
                }
                memset(&v433, 0, sizeof(v433));
                memset(&v432, 0, sizeof(v432));
                if (v276 > v277) {
                  goto LABEL_487;
                }
                unsigned int v278 = v261 + 2;
                do
                {
                  unsigned int v279 = v278 + *(unsigned __int8 *)(*a3 + v278);
                  sub_101143CD0(&v438, (uint64_t)v4, a3, v278 + 1, v279);
                  if (SHIBYTE(v432.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v432.__r_.__value_.__l.__data_);
                  }
                  std::string v432 = v438;
                  sub_1002055B4((const void **)&v433.__r_.__value_.__l.__data_, (const void **)&v432.__r_.__value_.__l.__data_, &v438);
                  v280 = std::string::append(&v438, ".", 1uLL);
                  std::string::size_type v281 = v280->__r_.__value_.__r.__words[0];
                  v431[0] = v280->__r_.__value_.__l.__size_;
                  *(void *)((char *)v431 + 7) = *(std::string::size_type *)((char *)&v280->__r_.__value_.__r.__words[1]
                                                                            + 7);
                  char v282 = HIBYTE(v280->__r_.__value_.__r.__words[2]);
                  v280->__r_.__value_.__l.__size_ = 0;
                  v280->__r_.__value_.__r.__words[2] = 0;
                  v280->__r_.__value_.__r.__words[0] = 0;
                  if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v433.__r_.__value_.__l.__data_);
                  }
                  v433.__r_.__value_.__r.__words[0] = v281;
                  v433.__r_.__value_.__l.__size_ = v431[0];
                  *(std::string::size_type *)((char *)&v433.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v431 + 7);
                  *((unsigned char *)&v433.__r_.__value_.__s + 23) = v282;
                  if (SHIBYTE(v438.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v438.__r_.__value_.__l.__data_);
                  }
                  unsigned int v278 = v279 + 1;
                  int v4 = v399;
                }
                while (v279 + 1 <= v277);
                if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0)
                {
                  if (!v433.__r_.__value_.__l.__size_) {
                    goto LABEL_487;
                  }
                  uint64_t v283 = v433.__r_.__value_.__l.__size_ - 1;
                  v284 = (std::string *)v433.__r_.__value_.__r.__words[0];
                  --v433.__r_.__value_.__l.__size_;
                }
                else
                {
                  if (!*((unsigned char *)&v433.__r_.__value_.__s + 23)) {
                    goto LABEL_487;
                  }
                  uint64_t v283 = HIBYTE(v433.__r_.__value_.__r.__words[2]) - 1;
                  --*((unsigned char *)&v433.__r_.__value_.__s + 23);
                  v284 = &v433;
                }
                v284->__r_.__value_.__s.__data_[v283] = 0;
LABEL_487:
                v308 = *((void *)v4 + 7);
                if (os_log_type_enabled(v308, OS_LOG_TYPE_DEFAULT))
                {
                  v309 = &v433;
                  if ((v433.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    v309 = (std::string *)v433.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(v438.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)v438.__r_.__value_.__r.__words + 4) = (std::string::size_type)v309;
                  _os_log_impl((void *)&_mh_execute_header, v308, OS_LOG_TYPE_DEFAULT, "#I UrspRsdTypeDnn Dnn=%s", (uint8_t *)&v438, 0xCu);
                }
                v310 = (_OWORD *)*((void *)&v435 + 1);
                if (*((void *)&v435 + 1) >= (unint64_t)v436)
                {
                  unint64_t v313 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v435 + 1) - v435) >> 3);
                  unint64_t v314 = v313 + 1;
                  if (v313 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    sub_1000D8578();
                  }
                  if (0x5555555555555556 * ((uint64_t)(v436 - v435) >> 3) > v314) {
                    unint64_t v314 = 0x5555555555555556 * ((uint64_t)(v436 - v435) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v436 - v435) >> 3) >= 0x555555555555555) {
                    unint64_t v315 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v315 = v314;
                  }
                  v440 = &v436;
                  if (v315) {
                    v316 = (char *)sub_10004812C((uint64_t)&v436, v315);
                  }
                  else {
                    v316 = 0;
                  }
                  std::string::size_type v317 = (std::string::size_type)&v316[24 * v313];
                  v438.__r_.__value_.__r.__words[0] = (std::string::size_type)v316;
                  v438.__r_.__value_.__l.__size_ = v317;
                  v439 = &v316[24 * v315];
                  long long v318 = *(_OWORD *)&v433.__r_.__value_.__l.__data_;
                  *(void *)(v317 + 16) = *((void *)&v433.__r_.__value_.__l + 2);
                  *(_OWORD *)std::string::size_type v317 = v318;
                  memset(&v433, 0, sizeof(v433));
                  v438.__r_.__value_.__r.__words[2] = v317 + 24;
                  sub_100048204((uint64_t *)&v435, &v438);
                  v312 = (char *)*((void *)&v435 + 1);
                  sub_100048174((uint64_t)&v438);
                }
                else
                {
                  long long v311 = *(_OWORD *)&v433.__r_.__value_.__l.__data_;
                  *(void *)(*((void *)&v435 + 1) + 16) = *((void *)&v433.__r_.__value_.__l + 2);
                  _OWORD *v310 = v311;
                  memset(&v433, 0, sizeof(v433));
                  v312 = (char *)v310 + 24;
                }
                *((void *)&v435 + 1) = v312;
                if (SHIBYTE(v432.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v432.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v433.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v433.__r_.__value_.__l.__data_);
                }
                unsigned int v261 = v276 + v392;
                goto LABEL_458;
              case 8:
                unint64_t v274 = v261 + 1;
                if (v267 <= v274)
                {
                  v349 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v349, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v349;
                    v343 = "UrspRsdTypePduSessionType wrong index %u";
                    goto LABEL_544;
                  }
                  goto LABEL_512;
                }
                char v275 = *(unsigned char *)(v266 + v274);
                if (!BYTE9(v436)) {
                  BYTE9(v436) = 1;
                }
                BYTE8(v436) = v275 & 7;
                break;
              default:
                if (v268 != 16)
                {
                  if (v268 != 17)
                  {
LABEL_547:
                    v345 = *((void *)v4 + 7);
                    if (os_log_type_enabled(v345, OS_LOG_TYPE_ERROR))
                    {
                      LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                      HIDWORD(v438.__r_.__value_.__r.__words[0]) = v268;
                      v342 = v345;
                      v343 = "unknown route selection desc: %u";
                      goto LABEL_544;
                    }
                    goto LABEL_512;
                  }
                  BYTE12(v436) = 1;
LABEL_452:
                  ++v261;
                  goto LABEL_458;
                }
                unint64_t v292 = v261 + 1;
                if (v267 <= v292)
                {
                  v352 = *((void *)v4 + 7);
                  if (os_log_type_enabled(v352, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v438.__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(v438.__r_.__value_.__r.__words[0]) = v261;
                    v342 = v352;
                    v343 = "UrspRsdTypePreferredAccessType wrong index %u";
                    goto LABEL_544;
                  }
LABEL_512:
                  char v265 = 0;
                  v422[0] = 0;
                  unsigned int v251 = v395;
                  goto LABEL_516;
                }
                char v293 = *(unsigned char *)(v266 + v292);
                if (!BYTE11(v436)) {
                  BYTE11(v436) = 1;
                }
                BYTE10(v436) = v293 & 3;
                break;
            }
          }
          v261 += 2;
LABEL_458:
          if (v261 > v260) {
            goto LABEL_393;
          }
          continue;
        }
      }
      if (*v25 <= 0x51u) {
        break;
      }
      switch(v26)
      {
        case 'R':
          unint64_t v97 = v12 + 1;
          unint64_t v98 = a3[1] - v24;
          if (v98 <= v97)
          {
            v377 = *((void *)v4 + 7);
            if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
              goto LABEL_329;
            }
            *(_DWORD *)std::string __p = 67109120;
            *(_DWORD *)&__p[4] = v12;
            v378 = "UrspTdTypeIP3Tuple wrong index %u";
            goto LABEL_654;
          }
          int v99 = *(unsigned __int8 *)(v24 + v97);
          if (v99)
          {
            unint64_t v100 = v12 + 9;
            if (v98 <= v100)
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIP3Tuple Ipv4 wrong index %u";
LABEL_654:
              v384 = v377;
              uint32_t v385 = 8;
              goto LABEL_655;
            }
            memset(__p, 0, 24);
            CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)__p);
            memset(&v438, 0, sizeof(v438));
            CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v438);
            int v101 = *(unsigned __int8 *)(*a3 + v12 + 6);
            int v102 = *(unsigned __int8 *)(*a3 + v12 + 7);
            int v103 = *(unsigned __int8 *)(*a3 + v12 + 8);
            int v104 = *(unsigned __int8 *)(*a3 + v100);
            CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)__p, (*(unsigned __int8 *)(*a3 + v12 + 2) << 24) | (*(unsigned __int8 *)(*a3 + v12 + 3) << 16) | (*(unsigned __int8 *)(*a3 + v12 + 4) << 8) | *(unsigned __int8 *)(*a3 + v12 + 5));
            CSIPacketAddress::setIPv4AddressLE((CSIPacketAddress *)&v438, (v101 << 24) | (v102 << 16) | (v103 << 8) | v104);
            unsigned __int8 v105 = CSIPacketAddress::maskToPrefix((CSIPacketAddress *)&v438);
            CSIPacketAddress::setPrefixLen((CSIPacketAddress *)__p, v105);
            uint64_t v106 = *(void *)&v425[1];
            if (*(void *)&v425[1] >= *((void *)&v425[1] + 1))
            {
              uint64_t v107 = sub_101149DDC((uint64_t)v425 + 8, (const CSIPacketAddress *)__p);
            }
            else
            {
              CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)&v425[1], (const CSIPacketAddress *)__p);
              uint64_t v107 = v106 + 24;
            }
            *(void *)&v425[1] = v107;
            v12 += 10;
          }
          if ((v99 & 2) != 0)
          {
            unint64_t v142 = v12 + 18;
            if (a3[1] - *a3 <= v142)
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIP3Tuple Ipv6 wrong index %u";
              goto LABEL_654;
            }
            memset(__p, 0, 24);
            CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)__p);
            CSIPacketAddress::setIPv6Address((CSIPacketAddress *)__p, (const unsigned __int8 *)(*a3 + v12 + 2), 0x10uLL);
            CSIPacketAddress::setPrefixLen((CSIPacketAddress *)__p, *(unsigned char *)(*a3 + v142));
            uint64_t v143 = *(void *)&v425[1];
            if (*(void *)&v425[1] >= *((void *)&v425[1] + 1))
            {
              uint64_t v144 = sub_101149DDC((uint64_t)v425 + 8, (const CSIPacketAddress *)__p);
            }
            else
            {
              CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)&v425[1], (const CSIPacketAddress *)__p);
              uint64_t v144 = v143 + 24;
            }
            *(void *)&v425[1] = v144;
            v12 += 19;
          }
          if ((v99 & 4) != 0)
          {
            uint64_t v145 = *a3;
            if (a3[1] - *a3 <= (unint64_t)v12)
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIP3Tuple protocol id wrong index %u";
              goto LABEL_654;
            }
            int64x2_t v146 = (char *)v426[1];
            if (v426[1] >= v426[2])
            {
              unint64_t v148 = (unint64_t)v426[0];
              int64_t v149 = (char *)v426[1] - (char *)v426[0];
              int64_t v150 = (char *)v426[1] - (char *)v426[0] + 1;
              if (v150 < 0) {
                sub_10006A748();
              }
              unint64_t v151 = (char *)v426[2] - (char *)v426[0];
              if (2 * ((char *)v426[2] - (char *)v426[0]) > (unint64_t)v150) {
                int64_t v150 = 2 * v151;
              }
              if (v151 >= 0x3FFFFFFFFFFFFFFFLL) {
                size_t v152 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                size_t v152 = v150;
              }
              if (v152) {
                int64x2_t v153 = (char *)operator new(v152);
              }
              else {
                int64x2_t v153 = 0;
              }
              v185 = &v153[v149];
              v153[v149] = *(unsigned char *)(v145 + v12);
              unint64_t v147 = &v153[v149 + 1];
              if (v146 == (char *)v148)
              {
                unsigned int v13 = v397;
              }
              else
              {
                v186 = &v146[~v148];
                unsigned int v13 = v397;
                do
                {
                  char v187 = *--v146;
                  (v186--)[(void)v153] = v187;
                }
                while (v146 != (char *)v148);
                int64x2_t v146 = (char *)v426[0];
                v185 = v153;
              }
              v426[0] = v185;
              v426[1] = v147;
              v426[2] = &v153[v152];
              if (v146) {
                operator delete(v146);
              }
            }
            else
            {
              *(unsigned char *)v426[1] = *(unsigned char *)(v145 + v12);
              unint64_t v147 = v146 + 1;
            }
            v426[1] = v147;
            ++v12;
          }
          if ((v99 & 8) != 0)
          {
            unint64_t v188 = v12 + 1;
            if (a3[1] - *a3 <= v188)
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIP3Tuple remote port wrong index %u";
              goto LABEL_654;
            }
            __int16 v189 = *(unsigned __int8 *)(*a3 + v188) | (*(unsigned __int8 *)(*a3 + v12) << 8);
            v190 = (char *)v426[4];
            if (v426[4] >= v426[5])
            {
              v192 = (char *)v426[3];
              int64_t v193 = (char *)v426[4] - (char *)v426[3];
              if ((char *)v426[4] - (char *)v426[3] <= -3) {
                sub_10006A748();
              }
              uint64_t v194 = v193 >> 1;
              if ((void *)((char *)v426[5] - (char *)v426[3]) <= (void *)((v193 >> 1) + 1)) {
                int64_t v195 = v194 + 1;
              }
              else {
                int64_t v195 = (char *)v426[5] - (char *)v426[3];
              }
              if ((void *)((char *)v426[5] - (char *)v426[3]) >= (void *)0x7FFFFFFFFFFFFFFELL) {
                uint64_t v196 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v196 = v195;
              }
              if (v196)
              {
                v197 = (char *)sub_10006E5B8((uint64_t)&v426[5], v196);
                v190 = (char *)v426[4];
                v192 = (char *)v426[3];
              }
              else
              {
                v197 = 0;
              }
              v198 = &v197[2 * v194];
              *(_WORD *)v198 = v189;
              v191 = v198 + 2;
              while (v190 != v192)
              {
                __int16 v199 = *((_WORD *)v190 - 1);
                v190 -= 2;
                *((_WORD *)v198 - 1) = v199;
                v198 -= 2;
              }
              v426[3] = v198;
              v426[4] = v191;
              v426[5] = &v197[2 * v196];
              if (v192) {
                operator delete(v192);
              }
            }
            else
            {
              *(_WORD *)v426[4] = v189;
              v191 = v190 + 2;
            }
            v426[4] = v191;
            v12 += 2;
          }
          if ((v99 & 0x10) != 0)
          {
            unint64_t v200 = v12 + 3;
            if (a3[1] - *a3 <= v200)
            {
              v377 = *((void *)v4 + 7);
              if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
                goto LABEL_329;
              }
              *(_DWORD *)std::string __p = 67109120;
              *(_DWORD *)&__p[4] = v12;
              v378 = "UrspTdTypeIP3Tuple port range wrong index %u";
              goto LABEL_654;
            }
            int v201 = *(unsigned __int8 *)(*a3 + v12 + 1) | (*(unsigned __int8 *)(*a3 + v12) << 8) | (*(unsigned __int8 *)(*a3 + v12 + 2) << 24) | (*(unsigned __int8 *)(*a3 + v200) << 16);
            v202 = (char *)v427[1];
            if (v427[1] >= (void *)*(void *)&v428[0])
            {
              int64_t v204 = ((char *)v427[1] - (char *)v427[0]) >> 2;
              if ((unint64_t)(v204 + 1) >> 62) {
                sub_10006A748();
              }
              unint64_t v205 = (uint64_t)(*(void *)&v428[0] - (unint64_t)v427[0]) >> 1;
              if (v205 <= v204 + 1) {
                unint64_t v205 = v204 + 1;
              }
              if (*(void *)&v428[0] - (unint64_t)v427[0] >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v206 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v206 = v205;
              }
              if (v206) {
                v207 = (char *)sub_10005ECD8((uint64_t)v428, v206);
              }
              else {
                v207 = 0;
              }
              v208 = (int *)&v207[4 * v204];
              int *v208 = v201;
              v203 = v208 + 1;
              v209 = (char *)v427[1];
              v210 = (char *)v427[0];
              if (v427[1] != v427[0])
              {
                do
                {
                  int v211 = *((_DWORD *)v209 - 1);
                  v209 -= 4;
                  *--v208 = v211;
                }
                while (v209 != v210);
                v209 = (char *)v427[0];
              }
              v427[0] = v208;
              v427[1] = v203;
              *(void *)&v428[0] = &v207[4 * v206];
              if (v209) {
                operator delete(v209);
              }
            }
            else
            {
              *(_DWORD *)v427[1] = v201;
              v203 = v202 + 4;
            }
            v427[1] = v203;
            v12 += 4;
          }
          if ((~v99 & 3) == 0)
          {
            v212 = *((void *)v4 + 7);
            if (!os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
              goto LABEL_329;
            }
            *(_WORD *)std::string __p = 0;
            v378 = "UrspTdTypeIP3Tuple error: contains both IPv4 and IPv6 addresses";
LABEL_643:
            v384 = v212;
            uint32_t v385 = 2;
LABEL_655:
            _os_log_error_impl((void *)&_mh_execute_header, v384, OS_LOG_TYPE_ERROR, v378, __p, v385);
            goto LABEL_329;
          }
          if ((~v99 & 0x18) == 0)
          {
            v212 = *((void *)v4 + 7);
            if (!os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
              goto LABEL_329;
            }
            *(_WORD *)std::string __p = 0;
            v378 = "UrspTdTypeIP3Tuple error: contains both single remote and remote port range";
            goto LABEL_643;
          }
          break;
          v12 += 5;
          break;
        case 'p':
LABEL_199:
          v12 += 3;
          break;
        default:
          goto LABEL_605;
      }
LABEL_319:
      if (v12 > v13)
      {
        uint8_t v16 = v422[0];
        uint64_t v15 = *(void *)&v422[8];
        uint64_t v14 = v423;
        if (!v422[0])
        {
          int64x2_t v17 = *(int64x2_t *)((char *)v425 + 8);
          int64x2_t v11 = (int64x2_t)v424;
          int64x2_t v18 = *(int64x2_t *)v426;
          int64x2_t v19 = *(int64x2_t *)&v426[3];
          int64x2_t v20 = *(int64x2_t *)((char *)v428 + 8);
          int64x2_t v21 = *(int64x2_t *)v429;
          goto LABEL_6;
        }
        if (*(void *)&v422[8] == (void)v423
          && (void)v424 == *((void *)&v424 + 1)
          && *((void *)&v425[0] + 1) == *(void *)&v425[1]
          && v426[0] == v426[1]
          && v426[3] == v426[4]
          && *((void *)&v428[0] + 1) == *(void *)&v428[1]
          && v429[0] == v429[1])
        {
          int64x2_t v11 = vdupq_n_s64(v424);
          int64x2_t v17 = vdupq_n_s64(*((unint64_t *)&v425[0] + 1));
          int64x2_t v18 = vdupq_n_s64((unint64_t)v426[0]);
          int64x2_t v19 = vdupq_n_s64((unint64_t)v426[3]);
          int64x2_t v20 = vdupq_n_s64(*((unint64_t *)&v428[0] + 1));
          uint8_t v16 = 1;
          uint64_t v14 = *(void *)&v422[8];
          int64x2_t v21 = vdupq_n_s64((unint64_t)v429[0]);
          goto LABEL_6;
        }
        v212 = *((void *)v4 + 7);
        if (!os_log_type_enabled(v212, OS_LOG_TYPE_ERROR)) {
          goto LABEL_329;
        }
        *(_WORD *)std::string __p = 0;
        v378 = "UrspTdTypeOsAppId error: matchAll TD coexist with other TDs";
        goto LABEL_643;
      }
    }
    if (v26 != 80)
    {
      unint64_t v34 = v12 + 4;
      if (a3[1] - v24 <= v34)
      {
        v377 = *((void *)v4 + 7);
        if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
          goto LABEL_329;
        }
        *(_DWORD *)std::string __p = 67109120;
        *(_DWORD *)&__p[4] = v12;
        v378 = "UrspTdTypeRemotePortRange wrong index %u";
        goto LABEL_654;
      }
      int v35 = *(unsigned __int8 *)(v24 + v12 + 2) | (*(unsigned __int8 *)(v24 + v12 + 1) << 8) | (*(unsigned __int8 *)(v24 + v12 + 3) << 24) | (*(unsigned __int8 *)(v24 + v34) << 16);
      int v36 = (char *)v427[1];
      if (v427[1] >= (void *)*(void *)&v428[0])
      {
        int64_t v118 = ((char *)v427[1] - (char *)v427[0]) >> 2;
        if ((unint64_t)(v118 + 1) >> 62) {
          sub_10006A748();
        }
        unint64_t v119 = (uint64_t)(*(void *)&v428[0] - (unint64_t)v427[0]) >> 1;
        if (v119 <= v118 + 1) {
          unint64_t v119 = v118 + 1;
        }
        if (*(void *)&v428[0] - (unint64_t)v427[0] >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v120 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v120 = v119;
        }
        if (v120) {
          long long v121 = (char *)sub_10005ECD8((uint64_t)v428, v120);
        }
        else {
          long long v121 = 0;
        }
        v156 = (int *)&v121[4 * v118];
        int *v156 = v35;
        BOOL v37 = v156 + 1;
        long long v157 = (char *)v427[1];
        long long v158 = (char *)v427[0];
        if (v427[1] != v427[0])
        {
          do
          {
            int v159 = *((_DWORD *)v157 - 1);
            v157 -= 4;
            *--v156 = v159;
          }
          while (v157 != v158);
          long long v157 = (char *)v427[0];
        }
        v427[0] = v156;
        v427[1] = v37;
        *(void *)&v428[0] = &v121[4 * v120];
        if (v157) {
          operator delete(v157);
        }
      }
      else
      {
        *(_DWORD *)v427[1] = v35;
        BOOL v37 = v36 + 4;
      }
      v427[1] = v37;
      unsigned int v12 = 5;
      goto LABEL_319;
    }
    unint64_t v82 = v12 + 2;
    if (a3[1] - v24 <= v82)
    {
      v377 = *((void *)v4 + 7);
      if (!os_log_type_enabled(v377, OS_LOG_TYPE_ERROR)) {
        goto LABEL_329;
      }
      *(_DWORD *)std::string __p = 67109120;
      *(_DWORD *)&__p[4] = v12;
      v378 = "UrspTdTypeSingleRemotePort wrong index %u";
      goto LABEL_654;
    }
    __int16 v83 = *(unsigned __int8 *)(v24 + v82) | (*(unsigned __int8 *)(v24 + v12 + 1) << 8);
    uint64_t v84 = (char *)v426[4];
    if (v426[4] >= v426[5])
    {
      long long v112 = (char *)v426[3];
      int64_t v113 = (char *)v426[4] - (char *)v426[3];
      if ((char *)v426[4] - (char *)v426[3] <= -3) {
        sub_10006A748();
      }
      uint64_t v114 = v113 >> 1;
      if ((void *)((char *)v426[5] - (char *)v426[3]) <= (void *)((v113 >> 1) + 1)) {
        int64_t v115 = v114 + 1;
      }
      else {
        int64_t v115 = (char *)v426[5] - (char *)v426[3];
      }
      if ((void *)((char *)v426[5] - (char *)v426[3]) >= (void *)0x7FFFFFFFFFFFFFFELL) {
        uint64_t v116 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v116 = v115;
      }
      if (v116)
      {
        long long v117 = (char *)sub_10006E5B8((uint64_t)&v426[5], v116);
        uint64_t v84 = (char *)v426[4];
        long long v112 = (char *)v426[3];
      }
      else
      {
        long long v117 = 0;
      }
      unint64_t v154 = &v117[2 * v114];
      *(_WORD *)unint64_t v154 = v83;
      uint64_t v85 = v154 + 2;
      while (v84 != v112)
      {
        __int16 v155 = *((_WORD *)v84 - 1);
        v84 -= 2;
        *((_WORD *)v154 - 1) = v155;
        v154 -= 2;
      }
      v426[3] = v154;
      v426[4] = v85;
      v426[5] = &v117[2 * v116];
      if (v112) {
        operator delete(v112);
      }
    }
    else
    {
      *(_WORD *)v426[4] = v83;
      uint64_t v85 = v84 + 2;
    }
    v426[4] = v85;
    goto LABEL_199;
  }
  uint64_t v23 = a2[7];
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a4;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E processUePolicyInstruction wrong startIndex %u", buf, 8u);
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 232) = 0;
LABEL_604:
  *(void *)long long buf = &v408;
  sub_1011477A4((void ***)buf);
  return sub_101149F54((uint64_t)&v402 + 8);
}

void sub_101143978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  STACK[0x208] = v47;
  STACK[0x310] = (unint64_t)&a43;
  sub_1011477A4((void ***)&STACK[0x310]);
  if (LOBYTE(STACK[0x308])) {
    sub_101149F54((uint64_t)&STACK[0x240]);
  }
  sub_101143C8C((uint64_t)&a47);
  _Unwind_Resume(a1);
}

uint64_t sub_101143C8C(uint64_t a1)
{
  long long v3 = (void **)(a1 + 208);
  sub_1011477A4(&v3);
  sub_101149F54(a1 + 8);
  return a1;
}

void sub_101143CD0(std::string *this, uint64_t a2, void *a3, unsigned int a4, unsigned int a5)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a3[1] - *a3 <= (unint64_t)a5)
  {
    int v9 = *(NSObject **)(a2 + 56);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10[0] = 67109120;
      v10[1] = a5;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "convertUrspByteStreamToString wrong index %u", (uint8_t *)v10, 8u);
    }
  }
  else
  {
    for (unsigned int i = a4; i <= a5; ++i)
      std::string::push_back(this, *(unsigned char *)(*a3 + i));
  }
}

void sub_101143DC4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101143DE0(uint64_t a1)
{
  int v4 = (void **)(a1 + 64);
  sub_1011476C8(&v4);
  int v4 = (void **)(a1 + 32);
  sub_100047F64(&v4);
  long long v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void *sub_101143E3C(void *a1)
{
  long long v2 = a1[7];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (a1[17] == a1[16]) {
      long long v3 = "empty";
    }
    else {
      long long v3 = "non-empty";
    }
    int v5 = 136315138;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I sliceTrafficDescriptors_sync return %s list", (uint8_t *)&v5, 0xCu);
  }
  return a1 + 16;
}

void *sub_101143EF8(void *a1)
{
  return sub_101143E3C((void *)((char *)a1 + *(void *)(*a1 - 88)));
}

void sub_101143F14(uint64_t *a1)
{
  long long v2 = a1 + 14;
  sub_10114D568((char *)a1[14]);
  uint64_t v3 = a1[10];
  a1[13] = (uint64_t)v2;
  *long long v2 = 0;
  a1[15] = 0;
  sub_101146BA0((uint64_t)(a1 + 10), v3);
  uint64_t v5 = a1[16];
  for (uint64_t i = a1[17]; i != v5; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(i - 304)))
    ;
  a1[17] = v5;
}

void sub_101143F80(void *a1)
{
}

void sub_101143F9C(PersonalitySpecificImpl *a1, uint64_t a2, uint64_t a3)
{
  int v4 = (std::__shared_weak_count *)*((void *)a1 + 9);
  if (!v4 || !std::__shared_weak_count::lock(v4) || (uint64_t v6 = *((void *)a1 + 8)) == 0)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    sub_10012CA20((uint64_t)&buf.__r_.__value_.__l.__size_, a3);
    uint64_t v85 = (std::__shared_weak_count *)*((void *)a1 + 4);
    if (v85 && std::__shared_weak_count::lock(v85)) {
      operator new();
    }
    sub_100088B9C();
  }
  uint64_t v7 = PersonalitySpecificImpl::simSlot(a1);
  int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 56))(v6, v7);
  memset(&v123, 0, sizeof(v123));
  sub_100058DB0(&v123, "");
  unint64_t v120 = 0;
  long long v121 = 0;
  uint64_t v122 = 0;
  memset(&__p, 0, sizeof(__p));
  sub_100058DB0(&__p, "");
  uint64_t v111 = a3;
  int v9 = *((void *)a1 + 7);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I enter selectDnnForTd_sync", (uint8_t *)&buf, 2u);
  }
  uint64_t v10 = (unsigned __int8 *)*((void *)a1 + 10);
  uint64_t v114 = (unsigned __int8 *)*((void *)a1 + 11);
  if (v10 == v114)
  {
LABEL_145:
    std::string::size_type size = HIBYTE(v123.__r_.__value_.__r.__words[2]);
    if ((v123.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v123.__r_.__value_.__l.__size_;
    }
    if (!size && v120 != v121)
    {
      int v86 = *(unsigned __int8 *)(a2 + 264);
      uint64_t v87 = *((void *)a1 + 7);
      BOOL v88 = os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT);
      if (v86)
      {
        if (v88)
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I rsd has no DNN. Use the same DNN from application td", (uint8_t *)&buf, 2u);
          if (!*(unsigned char *)(a2 + 264)) {
            sub_10016C840();
          }
        }
        std::string::operator=(&v123, (const std::string *)(a2 + 240));
      }
      else if (v88)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I Both rsd and application td has no DNN", (uint8_t *)&buf, 2u);
      }
    }
    memset(&v118, 0, sizeof(v118));
    sub_100058DB0(&v118, "");
    unint64_t v81 = v120;
    if (v120 == v121)
    {
      std::to_string(&v117, 255);
      unint64_t v89 = std::string::append(&v117, ":", 1uLL);
      long long v90 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
      buf.__r_.__value_.__r.__words[2] = v89->__r_.__value_.__r.__words[2];
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v90;
      v89->__r_.__value_.__l.__size_ = 0;
      v89->__r_.__value_.__r.__words[2] = 0;
      v89->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v116, 0xFFFFFF);
      if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v91 = &v116;
      }
      else {
        int v91 = (std::string *)v116.__r_.__value_.__r.__words[0];
      }
      if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v92 = HIBYTE(v116.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v92 = v116.__r_.__value_.__l.__size_;
      }
      int v93 = std::string::append(&buf, (const std::string::value_type *)v91, v92);
      std::string::size_type v94 = v93->__r_.__value_.__r.__words[0];
      v126[0] = v93->__r_.__value_.__l.__size_;
      *(void *)((char *)v126 + 7) = *(std::string::size_type *)((char *)&v93->__r_.__value_.__r.__words[1] + 7);
      char v95 = HIBYTE(v93->__r_.__value_.__r.__words[2]);
      v93->__r_.__value_.__l.__size_ = 0;
      v93->__r_.__value_.__r.__words[2] = 0;
      v93->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v118.__r_.__value_.__l.__data_);
      }
      v118.__r_.__value_.__r.__words[0] = v94;
      v118.__r_.__value_.__l.__size_ = v126[0];
      *(std::string::size_type *)((char *)&v118.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v126 + 7);
      *((unsigned char *)&v118.__r_.__value_.__s + 23) = v95;
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v116.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      std::to_string(&buf, *(unsigned __int8 *)v120);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v83 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v83 = buf.__r_.__value_.__l.__size_;
      }
      std::string::append(&v118, (const std::string::value_type *)p_buf, v83);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (*((unsigned char *)v81 + 8)) {
        unsigned int v84 = v81[1];
      }
      else {
        unsigned int v84 = 0xFFFFFF;
      }
      std::to_string(&v117, v84);
      uint64_t v96 = std::string::insert(&v117, 0, ":", 1uLL);
      long long v97 = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
      buf.__r_.__value_.__r.__words[2] = v96->__r_.__value_.__r.__words[2];
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v97;
      v96->__r_.__value_.__l.__size_ = 0;
      v96->__r_.__value_.__r.__words[2] = 0;
      v96->__r_.__value_.__r.__words[0] = 0;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v98 = &buf;
      }
      else {
        unint64_t v98 = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v99 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v99 = buf.__r_.__value_.__l.__size_;
      }
      std::string::append(&v118, (const std::string::value_type *)v98, v99);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v117.__r_.__value_.__l.__data_);
    }
    if ((v123.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v100 = HIBYTE(v123.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t v100 = v123.__r_.__value_.__l.__size_;
    }
    if (v100)
    {
      memset(&v117, 0, sizeof(v117));
      sub_1000C140C((uint64_t)&v117, v100 + 1);
      if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v101 = &v117;
      }
      else {
        int v101 = (std::string *)v117.__r_.__value_.__r.__words[0];
      }
      if ((v123.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v102 = &v123;
      }
      else {
        int v102 = (std::string *)v123.__r_.__value_.__r.__words[0];
      }
      memmove(v101, v102, v100);
      *(_WORD *)((char *)&v101->__r_.__value_.__l.__data_ + v100) = 64;
      if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v103 = &v118;
      }
      else {
        int v103 = (std::string *)v118.__r_.__value_.__r.__words[0];
      }
      if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v104 = HIBYTE(v118.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v104 = v118.__r_.__value_.__l.__size_;
      }
      unsigned __int8 v105 = std::string::append(&v117, (const std::string::value_type *)v103, v104);
      long long v106 = *(_OWORD *)&v105->__r_.__value_.__l.__data_;
      buf.__r_.__value_.__r.__words[2] = v105->__r_.__value_.__r.__words[2];
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v106;
      v105->__r_.__value_.__l.__size_ = 0;
      v105->__r_.__value_.__r.__words[2] = 0;
      v105->__r_.__value_.__r.__words[0] = 0;
    }
    else
    {
      sub_100058DB0(&buf, "");
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = buf;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v100 && SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v117.__r_.__value_.__l.__data_);
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    sub_10012CA20((uint64_t)&buf.__r_.__value_.__l.__size_, v111);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v125, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v125 = __p;
    }
    uint64_t v107 = (std::__shared_weak_count *)*((void *)a1 + 4);
    if (v107)
    {
      if (std::__shared_weak_count::lock(v107)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  int64_t v113 = (unsigned __int8 *)(a2 + 240);
  long long v112 = (unsigned __int8 *)(a2 + 48);
  long long v110 = (unsigned __int8 *)(a2 + 152);
  while (1)
  {
    if (v10[8])
    {
      int64x2_t v11 = *((void *)a1 + 7);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I isTrafficDescriptorMatched matchAll", (uint8_t *)&buf, 2u);
      }
      goto LABEL_11;
    }
    uint64_t v30 = (unsigned __int8 *)*((void *)v10 + 2);
    uint64_t v29 = (unsigned __int8 *)*((void *)v10 + 3);
    if (v30 != v29)
    {
      int v31 = *(unsigned __int8 *)(a2 + 264);
      uint64_t v32 = *(unsigned __int8 *)(a2 + 263);
      uint64_t v33 = *(const void **)(a2 + 240);
      size_t v34 = *(void *)(a2 + 248);
      if ((v32 & 0x80u) == 0) {
        uint64_t v35 = *(unsigned __int8 *)(a2 + 263);
      }
      else {
        uint64_t v35 = *(void *)(a2 + 248);
      }
      do
      {
        if (v31)
        {
          uint64_t v36 = v30[23];
          int v37 = (char)v36;
          if ((v36 & 0x80u) != 0) {
            uint64_t v36 = *((void *)v30 + 1);
          }
          if (v35 == v36)
          {
            if (v37 >= 0) {
              unint64_t v38 = v30;
            }
            else {
              unint64_t v38 = *(unsigned __int8 **)v30;
            }
            if ((v32 & 0x80) != 0)
            {
              uint64_t v41 = a2;
              int v42 = v33;
              int v43 = memcmp(v33, v38, v34);
              uint64_t v33 = v42;
              a2 = v41;
              if (!v43) {
                goto LABEL_71;
              }
            }
            else
            {
              if (!v32) {
                goto LABEL_71;
              }
              int v39 = v113;
              uint64_t v40 = v32;
              while (*v39 == *v38)
              {
                ++v39;
                ++v38;
                if (!--v40) {
                  goto LABEL_71;
                }
              }
            }
          }
        }
        v30 += 24;
      }
      while (v30 != v29);
      goto LABEL_144;
    }
LABEL_71:
    std::string::size_type v45 = (unsigned __int8 *)*((void *)v10 + 5);
    unsigned int v44 = (unsigned __int8 *)*((void *)v10 + 6);
    if (v45 != v44) {
      break;
    }
LABEL_91:
    uint64_t v56 = *((void *)v10 + 8);
    uint64_t v57 = *((void *)v10 + 9);
    if (v56 != v57)
    {
      while (!*(unsigned char *)(a2 + 208) || (CSIPacketAddress::operator==() & 1) == 0)
      {
        v56 += 24;
        if (v56 == v57) {
          goto LABEL_144;
        }
      }
    }
    int v58 = (unsigned __int8 *)*((void *)v10 + 11);
    char v59 = (unsigned __int8 *)*((void *)v10 + 12);
    if (v58 != v59)
    {
      while (!*(unsigned char *)(a2 + 224) || *(_WORD *)(a2 + 222) != *v58)
      {
        if (++v58 == v59) {
          goto LABEL_144;
        }
      }
    }
    int v60 = (unsigned __int16 *)*((void *)v10 + 14);
    unint64_t v61 = (unsigned __int16 *)*((void *)v10 + 15);
    if (v60 != v61)
    {
      while (!*(unsigned char *)(a2 + 214) || *(unsigned __int16 *)(a2 + 212) != *v60)
      {
        if (++v60 == v61) {
          goto LABEL_144;
        }
      }
    }
    int64_t v63 = (unsigned __int16 *)*((void *)v10 + 17);
    int64_t v62 = (unsigned __int16 *)*((void *)v10 + 18);
    if (v63 != v62)
    {
      unint64_t v64 = (unsigned __int16 *)*((void *)v10 + 17);
      while (1)
      {
        if (*(unsigned char *)(a2 + 220))
        {
          if (*(unsigned __int16 *)(a2 + 216) == *v64 && *(unsigned __int16 *)(a2 + 218) == v64[1]) {
            break;
          }
        }
        v64 += 2;
        if (v64 == v62) {
          goto LABEL_144;
        }
      }
    }
    unint64_t v67 = (unsigned __int8 *)*((void *)v10 + 20);
    unint64_t v66 = (unsigned __int8 *)*((void *)v10 + 21);
    if (v67 == v66)
    {
LABEL_135:
      if (v63 != v62)
      {
        unsigned int v79 = *(unsigned __int16 *)(a2 + 212);
        while ((!*(unsigned char *)(a2 + 214) || v79 < *v63 || v79 > v63[1])
             && (!*(unsigned char *)(a2 + 220)
              || *(unsigned __int16 *)(a2 + 216) < *v63
              || *(unsigned __int16 *)(a2 + 218) > v63[1]))
        {
          v63 += 2;
          if (v63 == v62) {
            goto LABEL_144;
          }
        }
      }
LABEL_11:
      unsigned int v12 = *((void *)a1 + 7);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *v10;
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Found matching trafficDescriptor, precedence=%u", (uint8_t *)&buf, 8u);
      }
      uint64_t v15 = *((void *)v10 + 26);
      uint64_t v14 = *((void *)v10 + 27);
      if (v15 != v14)
      {
        while (v8 == 16 || v8 == 14)
        {
          if (*(unsigned char *)(v15 + 2) && (*(unsigned char *)(v15 + 1) & 0xFE) == 2)
          {
            uint8_t v16 = *((void *)a1 + 7);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              int64x2_t v17 = v16;
              int64x2_t v18 = "#I skip rsd in EPS with sscMode";
LABEL_35:
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&buf, 2u);
            }
          }
          else if (*(void *)(v15 + 8) == *(void *)(v15 + 16))
          {
            if (*(unsigned char *)(v15 + 112))
            {
              int64x2_t v20 = *((void *)a1 + 7);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                int64x2_t v17 = v20;
                int64x2_t v18 = "#I skip rsd in EPS with proSeL3RelayOffloadIndicationPresent";
                goto LABEL_35;
              }
            }
            else if (*(unsigned char *)(v15 + 60))
            {
              int64x2_t v21 = *((void *)a1 + 7);
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                int64x2_t v17 = v21;
                int64x2_t v18 = "#I skip rsd in EPS with multiAccessPreferencePresent";
                goto LABEL_35;
              }
            }
            else if (*(unsigned char *)(v15 + 104))
            {
              uint64_t v22 = *((void *)a1 + 7);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                int64x2_t v17 = v22;
                int64x2_t v18 = "#I skip rsd in EPS with timeWindow";
                goto LABEL_35;
              }
            }
            else
            {
              if (*(void *)(v15 + 64) == *(void *)(v15 + 72)) {
                break;
              }
              uint64_t v23 = *((void *)a1 + 7);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                int64x2_t v17 = v23;
                int64x2_t v18 = "#I skip rsd in EPS with locationCriteria";
                goto LABEL_35;
              }
            }
          }
          else
          {
            int64x2_t v19 = *((void *)a1 + 7);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              int64x2_t v17 = v19;
              int64x2_t v18 = "#I skip rsd in EPS with snssaiList";
              goto LABEL_35;
            }
          }
LABEL_44:
          v15 += 120;
          if (v15 == v14) {
            goto LABEL_45;
          }
        }
        uint64_t v24 = *(const std::string **)(v15 + 32);
        if (v24 != *(const std::string **)(v15 + 40)) {
          std::string::operator=(&v123, v24);
        }
        long long v25 = *(char **)(v15 + 8);
        uint64_t v26 = *(void *)(v15 + 16);
        if (v25 != (char *)v26) {
          sub_10114A0B4((char *)&v120, v25, v26, 0xAAAAAAAAAAAAAAABLL * ((v26 - (uint64_t)v25) >> 3));
        }
        std::string::size_type v27 = HIBYTE(v123.__r_.__value_.__r.__words[2]);
        if ((v123.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v27 = v123.__r_.__value_.__l.__size_;
        }
        if (v27 || v120 != v121) {
          goto LABEL_45;
        }
        goto LABEL_44;
      }
LABEL_45:
      std::string::size_type v28 = HIBYTE(v123.__r_.__value_.__r.__words[2]);
      if ((v123.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v28 = v123.__r_.__value_.__l.__size_;
      }
      if (v28) {
        goto LABEL_145;
      }
      if (v120 != v121) {
        goto LABEL_145;
      }
      v10 += 232;
      if (v10 == v114) {
        goto LABEL_145;
      }
    }
    else
    {
      int v68 = *(unsigned __int8 *)(a2 + 176);
      uint64_t v69 = *(unsigned __int8 *)(a2 + 175);
      int v70 = *(const void **)(a2 + 152);
      size_t v71 = *(void *)(a2 + 160);
      if ((v69 & 0x80u) == 0) {
        uint64_t v72 = *(unsigned __int8 *)(a2 + 175);
      }
      else {
        uint64_t v72 = *(void *)(a2 + 160);
      }
      do
      {
        if (v68)
        {
          uint64_t v73 = v67[23];
          int v74 = (char)v73;
          if ((v73 & 0x80u) != 0) {
            uint64_t v73 = *((void *)v67 + 1);
          }
          if (v72 == v73)
          {
            if (v74 >= 0) {
              unsigned int v75 = v67;
            }
            else {
              unsigned int v75 = *(unsigned __int8 **)v67;
            }
            if ((v69 & 0x80) != 0)
            {
              unint64_t v108 = v70;
              uint64_t v109 = v69;
              int v78 = memcmp(v70, v75, v71);
              int v70 = v108;
              uint64_t v69 = v109;
              if (!v78) {
                goto LABEL_135;
              }
            }
            else
            {
              if (!v69) {
                goto LABEL_135;
              }
              uint64_t v76 = v110;
              uint64_t v77 = v69;
              while (*v76 == *v75)
              {
                ++v76;
                ++v75;
                if (!--v77) {
                  goto LABEL_135;
                }
              }
            }
          }
        }
        v67 += 24;
      }
      while (v67 != v66);
LABEL_144:
      v10 += 232;
      if (v10 == v114) {
        goto LABEL_145;
      }
    }
  }
  int v46 = *(unsigned __int8 *)(a2 + 72);
  uint64_t v47 = *(unsigned __int8 *)(a2 + 71);
  unint64_t v49 = *(const void **)(a2 + 48);
  size_t v48 = *(void *)(a2 + 56);
  if ((v47 & 0x80u) == 0) {
    uint64_t v50 = *(unsigned __int8 *)(a2 + 71);
  }
  else {
    uint64_t v50 = *(void *)(a2 + 56);
  }
  do
  {
    if (v46)
    {
      uint64_t v51 = v45[23];
      int v52 = (char)v51;
      if ((v51 & 0x80u) != 0) {
        uint64_t v51 = *((void *)v45 + 1);
      }
      if (v50 == v51)
      {
        if (v52 >= 0) {
          unsigned int v53 = v45;
        }
        else {
          unsigned int v53 = *(unsigned __int8 **)v45;
        }
        if ((v47 & 0x80) != 0)
        {
          if (!memcmp(v49, v53, v48)) {
            goto LABEL_91;
          }
        }
        else
        {
          if (!v47) {
            goto LABEL_91;
          }
          long long v54 = v112;
          uint64_t v55 = v47;
          while (*v54 == *v53)
          {
            ++v54;
            ++v53;
            if (!--v55) {
              goto LABEL_91;
            }
          }
        }
      }
    }
    v45 += 24;
  }
  while (v45 != v44);
  goto LABEL_144;
}

void sub_101144D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  if (a47) {
    operator delete(a47);
  }
  if (*(char *)(v47 - 193) < 0) {
    operator delete(*(void **)(v47 - 216));
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_101144EAC(void *a1, uint64_t a2, uint64_t a3)
{
}

void sub_101144EE0(uint64_t a1, char a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 64);
      if (!v6)
      {
LABEL_284:
        sub_10004D2C8(v5);
        return;
      }
      char v154 = a2;
      __int16 v155 = v5;
      long long v196 = 0u;
      long long v197 = 0u;
      long long v194 = 0u;
      long long v195 = 0u;
      uint64_t v7 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 104))(&v194, v6, v7);
      uint64_t v153 = v6;
      sub_101146BA0(a1 + 80, *(void *)(a1 + 80));
      int v8 = *(void **)(a1 + 104);
      long long v158 = (uint64_t *)(a1 + 80);
      int v9 = (void *)(a1 + 112);
      if (v8 != (void *)(a1 + 112))
      {
        long long v160 = (unint64_t *)(a1 + 96);
        do
        {
          long long v207 = 0u;
          long long v208 = 0u;
          long long v205 = 0u;
          long long v206 = 0u;
          long long v157 = v8;
          MCCAndMNC::MCCAndMNC((MCCAndMNC *)&v205, *((_WORD *)v8 + 16), *((_WORD *)v8 + 17));
          if (MCCAndMNC::operator==())
          {
            xpc_object_t v190 = 0;
            v191 = 0;
            v192 = 0;
            uint64_t v10 = v157[5];
            uint64_t v11 = v157[6];
            char v187 = &v190;
            if (v11 != v10)
            {
              unint64_t v12 = 0x34F72C234F72C235 * ((v11 - v10) >> 3);
              unint64_t v188 = 0;
              if (v12 > 0x11A7B9611A7B961) {
                sub_10006A748();
              }
              xpc_object_t v190 = sub_101146DC8(v12);
              v191 = v190;
              v192 = (char *)v190 + 232 * v13;
              v185[0] = (uint64_t)v190;
              *(void *)v198 = v190;
              *(void *)&long long buf = &v192;
              *((void *)&buf + 1) = v198;
              v225 = v185;
              uint64_t v226 = 0;
              xpc_object_t v14 = v190;
              do
              {
                sub_101146E88((uint64_t)v14, v10);
                v10 += 232;
                xpc_object_t v14 = (xpc_object_t)(v185[0] + 232);
                v185[0] += 232;
              }
              while (v10 != v11);
              LOBYTE(v226) = 1;
              sub_10114A1EC((uint64_t)&buf);
              v191 = v14;
              uint64_t v15 = v190;
              char v162 = v14;
              if (v190 != v14)
              {
                while (1)
                {
                  uint64_t v16 = v15[26];
                  uint64_t v17 = v15[27];
                  long long v164 = v15;
                  while (v16 != v17)
                  {
                    int64x2_t v18 = *(unsigned __int8 **)(v16 + 8);
                    int64x2_t v19 = *(unsigned __int8 **)(v16 + 16);
                    while (v18 != v19)
                    {
                      int v20 = *v18;
                      int v21 = *((_DWORD *)v18 + 1);
                      uint64_t v22 = *(unsigned __int8 **)(a1 + 152);
                      uint64_t v23 = *(unsigned __int8 **)(a1 + 160);
                      if (v22 == v23)
                      {
LABEL_24:
                        uint64_t v24 = *(NSObject **)(a1 + 56);
                        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                        {
                          if (v18[8]) {
                            int v25 = v21;
                          }
                          else {
                            int v25 = 0xFFFFFF;
                          }
                          LODWORD(buf) = 67109376;
                          DWORD1(buf) = v20;
                          WORD4(buf) = 1024;
                          *(_DWORD *)((char *)&buf + 10) = v25;
                          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I updateHomePlmnUrspList_sync remove [sst:%d, sd:%d] as it is not allowed", (uint8_t *)&buf, 0xEu);
                          int64x2_t v19 = *(unsigned __int8 **)(v16 + 16);
                        }
                        int64_t v26 = v19 - (v18 + 24);
                        if (v19 != v18 + 24) {
                          memmove(v18, v18 + 24, v19 - (v18 + 24));
                        }
                        v19 -= 24;
                        *(void *)(v16 + 16) = &v18[v26];
                      }
                      else
                      {
                        while (1)
                        {
                          if (v20 != *v22) {
                            goto LABEL_23;
                          }
                          if (v18[8]) {
                            break;
                          }
                          if (!v22[8]) {
                            goto LABEL_32;
                          }
LABEL_23:
                          v22 += 24;
                          if (v22 == v23) {
                            goto LABEL_24;
                          }
                        }
                        if (v22[8] && v21 != *((_DWORD *)v22 + 1)) {
                          goto LABEL_23;
                        }
LABEL_32:
                        v18 += 24;
                      }
                    }
                    v16 += 120;
                  }
                  uint64_t v15 = v164 + 29;
                  if (v164 + 29 == v162)
                  {
                    std::string::size_type v27 = (char *)v190;
                    std::string::size_type v28 = (char *)v191;
                    if (v190 != v191)
                    {
                      unint64_t v29 = *(void *)(a1 + 88);
                      do
                      {
                        if (v29 >= *v160)
                        {
                          uint64_t v30 = 0x34F72C234F72C235 * ((uint64_t)(v29 - *v158) >> 3);
                          unint64_t v31 = v30 + 1;
                          if ((unint64_t)(v30 + 1) > 0x11A7B9611A7B961) {
                            sub_10006A748();
                          }
                          if (0x69EE58469EE5846ALL * ((uint64_t)(*v160 - *v158) >> 3) > v31) {
                            unint64_t v31 = 0x69EE58469EE5846ALL * ((uint64_t)(*v160 - *v158) >> 3);
                          }
                          if ((unint64_t)(0x34F72C234F72C235 * ((uint64_t)(*v160 - *v158) >> 3)) >= 0x8D3DCB08D3DCB0) {
                            unint64_t v32 = 0x11A7B9611A7B961;
                          }
                          else {
                            unint64_t v32 = v31;
                          }
                          unint64_t v227 = (char **)(a1 + 96);
                          if (v32) {
                            unint64_t v32 = (unint64_t)sub_101146DC8(v32);
                          }
                          else {
                            uint64_t v33 = 0;
                          }
                          *(void *)&long long buf = v32;
                          *((void *)&buf + 1) = v32 + 232 * v30;
                          v225 = (uint64_t *)*((void *)&buf + 1);
                          uint64_t v226 = (char *)(v32 + 232 * v33);
                          sub_10114A264(*((uint64_t *)&buf + 1), (uint64_t)v27);
                          v225 += 29;
                          sub_101146D40(v158, &buf);
                          unint64_t v29 = *(void *)(a1 + 88);
                          sub_101146E14((uint64_t)&buf);
                        }
                        else
                        {
                          sub_10114A264(v29, (uint64_t)v27);
                          v29 += 232;
                          *(void *)(a1 + 88) = v29;
                        }
                        *(void *)(a1 + 88) = v29;
                        v27 += 232;
                      }
                      while (v27 != v28);
                    }
                    break;
                  }
                }
              }
            }
            *(void *)&long long buf = &v190;
            sub_101146B4C((void ***)&buf);
            int v9 = (void *)(a1 + 112);
          }
          else
          {
            size_t v34 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)&v194);
              int IntValue = MCC::getIntValue((MCC *)&buf);
              MCCAndMNC::getMnc((uint64_t *)&v190, (MCCAndMNC *)&v194);
              int v36 = MCC::getIntValue((MCC *)&v190);
              MCCAndMNC::getMcc((uint64_t *)&v187, (MCCAndMNC *)&v205);
              int v37 = MCC::getIntValue((MCC *)&v187);
              MCCAndMNC::getMnc(v185, (MCCAndMNC *)&v205);
              int v38 = MCC::getIntValue((MCC *)v185);
              *(_DWORD *)v198 = 67109888;
              *(_DWORD *)&v198[4] = IntValue;
              __int16 v199 = 1024;
              int v200 = v36;
              __int16 v201 = 1024;
              int v202 = v37;
              __int16 v203 = 1024;
              int v204 = v38;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I fUrspRuleMap skip non-hplmn, hplmn[%u,%u], upsiPlmn[%u,%u]", v198, 0x1Au);
              if (v186 < 0) {
                operator delete((void *)v185[1]);
              }
              if (v189 < 0) {
                operator delete(v188);
              }
              if (v193 < 0) {
                operator delete(v191);
              }
              if (SHIBYTE(v226) < 0) {
                operator delete(*((void **)&buf + 1));
              }
            }
          }
          if (SHIBYTE(v208) < 0) {
            operator delete(*((void **)&v207 + 1));
          }
          if (SHIBYTE(v206) < 0) {
            operator delete(*((void **)&v205 + 1));
          }
          int v39 = v157;
          uint64_t v40 = (void *)v157[1];
          if (v40)
          {
            do
            {
              uint64_t v41 = v40;
              uint64_t v40 = (void *)*v40;
            }
            while (v40);
          }
          else
          {
            do
            {
              uint64_t v41 = (void *)v39[2];
              BOOL v42 = *v41 == (void)v39;
              int v39 = v41;
            }
            while (!v42);
          }
          int v8 = v41;
        }
        while (v41 != v9);
      }
      uint64_t v43 = *(void *)(a1 + 80);
      unsigned int v44 = *(unsigned __int8 **)(a1 + 88);
      unint64_t v45 = 126 - 2 * __clz(0x34F72C234F72C235 * ((uint64_t)&v44[-v43] >> 3));
      if (v44 == (unsigned __int8 *)v43) {
        uint64_t v46 = 0;
      }
      else {
        uint64_t v46 = v45;
      }
      sub_10114A2E4(v43, v44, v46, 1);
      uint64_t v47 = *(void **)(a1 + 80);
      uint64_t v165 = *(void **)(a1 + 88);
      if (v47 != v165)
      {
        int v48 = 1;
        do
        {
          unint64_t v49 = *(NSObject **)(a1 + 56);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            int v50 = *(unsigned __int8 *)v47;
            UrspTrafficDescriptor::toString((uint64_t *)&buf, (UrspTrafficDescriptor *)(v47 + 1));
            p_long long buf = &buf;
            if (SHIBYTE(v225) < 0) {
              p_long long buf = (long long *)buf;
            }
            LODWORD(v205) = 67109634;
            DWORD1(v205) = v48;
            WORD4(v205) = 1024;
            *(_DWORD *)((char *)&v205 + 10) = v50;
            HIWORD(v205) = 2080;
            *(void *)&long long v206 = p_buf;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I fHplmnUrsp Rule#%u, prec=%u, td=%s", (uint8_t *)&v205, 0x18u);
            if (SHIBYTE(v225) < 0) {
              operator delete((void *)buf);
            }
          }
          int v52 = (RouteSelectionDescriptor *)v47[26];
          unsigned int v53 = (RouteSelectionDescriptor *)v47[27];
          while (v52 != v53)
          {
            long long v54 = *(NSObject **)(a1 + 56);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              RouteSelectionDescriptor::toString((uint64_t *)&v205, v52);
              uint64_t v55 = (SBYTE7(v206) & 0x80u) == 0 ? &v205 : (long long *)v205;
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v55;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I                            rsd=%s", (uint8_t *)&buf, 0xCu);
              if (SBYTE7(v206) < 0) {
                operator delete((void *)v205);
              }
            }
            int v52 = (RouteSelectionDescriptor *)((char *)v52 + 120);
          }
          ++v48;
          v47 += 29;
        }
        while (v47 != v165);
      }
      uint64_t v56 = *(std::__shared_weak_count **)(a1 + 72);
      if (v56)
      {
        uint64_t v57 = std::__shared_weak_count::lock(v56);
        if (v57)
        {
          size_t v152 = v57;
          uint64_t v161 = *(void *)(a1 + 64);
          if (v161)
          {
            uint64_t v58 = *(void *)(a1 + 128);
            long long v163 = (uint64_t *)(a1 + 128);
            for (uint64_t i = *(void *)(a1 + 136); i != v58; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(i - 304)))
              ;
            *(void *)(a1 + 136) = v58;
            uint64_t v61 = *(void *)(a1 + 80);
            uint64_t v60 = *(void *)(a1 + 88);
            if (v61 != v60)
            {
              uint64_t v156 = *(void *)(a1 + 88);
              do
              {
                if (*(unsigned char *)(v61 + 8))
                {
                  int64_t v62 = *(NSObject **)(a1 + 56);
                  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v205) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I No need to report matchAll td", (uint8_t *)&v205, 2u);
                  }
                }
                else
                {
                  xpc_object_t v190 = 0;
                  v191 = 0;
                  v192 = 0;
                  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205);
                  int64_t v63 = (char *)v191;
                  if (v191 >= v192)
                  {
                    unint64_t v65 = 0x86BCA1AF286BCA1BLL * (((unsigned char *)v191 - (unsigned char *)v190) >> 4);
                    unint64_t v66 = v65 + 1;
                    if (v65 + 1 > 0xD79435E50D7943) {
                      sub_10006A748();
                    }
                    if (0xD79435E50D79436 * ((v192 - (unsigned char *)v190) >> 4) > v66) {
                      unint64_t v66 = 0xD79435E50D79436 * ((v192 - (unsigned char *)v190) >> 4);
                    }
                    if (0x86BCA1AF286BCA1BLL * ((v192 - (unsigned char *)v190) >> 4) >= 0x6BCA1AF286BCA1) {
                      unint64_t v67 = 0xD79435E50D7943;
                    }
                    else {
                      unint64_t v67 = v66;
                    }
                    unint64_t v227 = &v192;
                    if (v67) {
                      int v68 = (char *)sub_100B05D04((uint64_t)&v192, v67);
                    }
                    else {
                      int v68 = 0;
                    }
                    *(void *)&long long buf = v68;
                    *((void *)&buf + 1) = &v68[304 * v65];
                    v225 = (uint64_t *)*((void *)&buf + 1);
                    uint64_t v226 = &v68[304 * v67];
                    TrafficDescriptor::TrafficDescriptor();
                    v225 += 38;
                    sub_100B05C8C((uint64_t *)&v190, &buf);
                    unint64_t v64 = v191;
                    sub_100B05DE4((uint64_t)&buf);
                  }
                  else
                  {
                    TrafficDescriptor::TrafficDescriptor();
                    unint64_t v64 = v63 + 304;
                  }
                  v191 = v64;
                  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                  uint64_t v69 = *(const std::string **)(v61 + 40);
                  long long v166 = *(const std::string **)(v61 + 48);
                  uint64_t v159 = v61;
                  if (v69 != v166)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      int v70 = (const TrafficDescriptor *)v190;
                      size_t v71 = (const TrafficDescriptor *)v191;
                      while (v70 != v71)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v70);
                        sub_100093B44((std::string *)&v208, v69);
                        uint64_t v72 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v73 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v73 = v72 + 304;
                        }
                        *((void *)&buf + 1) = v73;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        int v70 = (const TrafficDescriptor *)((char *)v70 + 304);
                      }
                      ++v69;
                    }
                    while (v69 != v166);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  int v74 = *(const std::string **)(v61 + 160);
                  long long v167 = *(const std::string **)(v61 + 168);
                  if (v74 != v167)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      unsigned int v75 = (const TrafficDescriptor *)v190;
                      uint64_t v76 = (const TrafficDescriptor *)v191;
                      while (v75 != v76)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v75);
                        sub_100093B44((std::string *)((char *)&v214 + 8), v74);
                        uint64_t v77 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v78 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v78 = v77 + 304;
                        }
                        *((void *)&buf + 1) = v78;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        unsigned int v75 = (const TrafficDescriptor *)((char *)v75 + 304);
                      }
                      ++v74;
                    }
                    while (v74 != v167);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  unsigned int v79 = *(const CSIPacketAddress **)(v61 + 64);
                  uint64_t v168 = *(const CSIPacketAddress **)(v61 + 72);
                  if (v79 != v168)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      unint64_t v80 = (const TrafficDescriptor *)v190;
                      unint64_t v81 = (const TrafficDescriptor *)v191;
                      while (v80 != v81)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v80);
                        if ((_BYTE)v218)
                        {
                          CSIPacketAddress::operator=();
                        }
                        else
                        {
                          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v216 + 8), v79);
                          LOBYTE(v218) = 1;
                        }
                        uint64_t v82 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v83 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v83 = v82 + 304;
                        }
                        *((void *)&buf + 1) = v83;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        unint64_t v80 = (const TrafficDescriptor *)((char *)v80 + 304);
                      }
                      unsigned int v79 = (const CSIPacketAddress *)((char *)v79 + 24);
                    }
                    while (v79 != v168);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  unsigned int v84 = *(_WORD **)(v61 + 112);
                  long long v169 = *(_WORD **)(v61 + 120);
                  if (v84 != v169)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      uint64_t v85 = (const TrafficDescriptor *)v190;
                      int v86 = (const TrafficDescriptor *)v191;
                      while (v85 != v86)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v85);
                        WORD2(v218) = *v84;
                        BYTE6(v218) = 1;
                        uint64_t v87 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v88 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v88 = v87 + 304;
                        }
                        *((void *)&buf + 1) = v88;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        uint64_t v85 = (const TrafficDescriptor *)((char *)v85 + 304);
                      }
                      ++v84;
                    }
                    while (v84 != v169);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  unint64_t v89 = *(_DWORD **)(v61 + 136);
                  v170 = *(_DWORD **)(v61 + 144);
                  if (v89 != v170)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      long long v90 = (const TrafficDescriptor *)v190;
                      int v91 = (const TrafficDescriptor *)v191;
                      while (v90 != v91)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v90);
                        DWORD2(v218) = *v89;
                        if (!BYTE12(v218)) {
                          BYTE12(v218) = 1;
                        }
                        uint64_t v92 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v93 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v93 = v92 + 304;
                        }
                        *((void *)&buf + 1) = v93;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        long long v90 = (const TrafficDescriptor *)((char *)v90 + 304);
                      }
                      ++v89;
                    }
                    while (v89 != v170);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  std::string::size_type v94 = *(unsigned __int8 **)(v61 + 88);
                  v171 = *(unsigned __int8 **)(v61 + 96);
                  if (v94 != v171)
                  {
                    long long buf = 0uLL;
                    v225 = 0;
                    do
                    {
                      char v95 = (const TrafficDescriptor *)v190;
                      uint64_t v96 = (const TrafficDescriptor *)v191;
                      while (v95 != v96)
                      {
                        long long v222 = 0u;
                        long long v223 = 0u;
                        long long v220 = 0u;
                        long long v221 = 0u;
                        long long v218 = 0u;
                        long long v219 = 0u;
                        long long v216 = 0u;
                        long long v217 = 0u;
                        long long v214 = 0u;
                        long long v215 = 0u;
                        long long v212 = 0u;
                        long long v213 = 0u;
                        long long v210 = 0u;
                        long long v211 = 0u;
                        long long v208 = 0u;
                        long long v209 = 0u;
                        long long v206 = 0u;
                        long long v207 = 0u;
                        long long v205 = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v95);
                        __int16 v97 = *v94;
                        if (!(_BYTE)v219) {
                          LOBYTE(v219) = 1;
                        }
                        HIWORD(v218) = v97;
                        uint64_t v98 = *((void *)&buf + 1);
                        if (*((void *)&buf + 1) >= (unint64_t)v225)
                        {
                          uint64_t v99 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                        }
                        else
                        {
                          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                          uint64_t v99 = v98 + 304;
                        }
                        *((void *)&buf + 1) = v99;
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                        char v95 = (const TrafficDescriptor *)((char *)v95 + 304);
                      }
                      ++v94;
                    }
                    while (v94 != v171);
                    sub_100B06144((uint64_t)&v190, buf, *((uint64_t *)&buf + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  size_t v100 = *(const std::string **)(v61 + 24);
                  if (*(const std::string **)(v61 + 16) != v100)
                  {
                    v225 = 0;
                    long long buf = 0uLL;
                    int v101 = *(const std::string **)(v61 + 16);
                    long long v172 = v100;
                    if (v101 == v100)
                    {
                      uint64_t v107 = 0;
                      uint64_t v106 = 0;
                    }
                    else
                    {
                      do
                      {
                        int v102 = (const TrafficDescriptor *)v190;
                        int v103 = (const TrafficDescriptor *)v191;
                        while (v102 != v103)
                        {
                          long long v222 = 0u;
                          long long v223 = 0u;
                          long long v220 = 0u;
                          long long v221 = 0u;
                          long long v218 = 0u;
                          long long v219 = 0u;
                          long long v216 = 0u;
                          long long v217 = 0u;
                          long long v214 = 0u;
                          long long v215 = 0u;
                          long long v212 = 0u;
                          long long v213 = 0u;
                          long long v210 = 0u;
                          long long v211 = 0u;
                          long long v208 = 0u;
                          long long v209 = 0u;
                          long long v206 = 0u;
                          long long v207 = 0u;
                          long long v205 = 0u;
                          TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v205, v102);
                          sub_100093B44((std::string *)&v220, v101);
                          uint64_t v104 = *((void *)&buf + 1);
                          if (*((void *)&buf + 1) >= (unint64_t)v225)
                          {
                            uint64_t v105 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)&v205);
                          }
                          else
                          {
                            TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), (const TrafficDescriptor *)&v205);
                            uint64_t v105 = v104 + 304;
                          }
                          *((void *)&buf + 1) = v105;
                          TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v205);
                          int v102 = (const TrafficDescriptor *)((char *)v102 + 304);
                        }
                        ++v101;
                      }
                      while (v101 != v172);
                      uint64_t v107 = *((void *)&buf + 1);
                      uint64_t v106 = buf;
                    }
                    sub_100B06144((uint64_t)&v190, v106, v107, 0x86BCA1AF286BCA1BLL * ((v107 - v106) >> 4));
                    *(void *)&long long v205 = &buf;
                    sub_1008BE774((void ***)&v205);
                    uint64_t v61 = v159;
                  }
                  v173 = (char *)v191;
                  if (v190 != v191)
                  {
                    unint64_t v108 = (char *)v190 + 240;
                    do
                    {
                      if ((TrafficDescriptor::empty((TrafficDescriptor *)(v108 - 240)) & 1) == 0)
                      {
                        if (!v108[24]) {
                          goto LABEL_198;
                        }
                        uint64_t v109 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
                        if (!v108[24]) {
                          sub_10016C840();
                        }
                        if (((*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)v161 + 64))(v161, v109, v108) & 1) == 0)
                        {
                          unint64_t v120 = *(NSObject **)(a1 + 56);
                          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                          {
                            if (!v108[24]) {
                              sub_10016C840();
                            }
                            long long v121 = v108;
                            if (v108[23] < 0) {
                              long long v121 = *(char **)v108;
                            }
                            LODWORD(v205) = 136446210;
                            *(void *)((char *)&v205 + 4) = v121;
                            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I fHplmnTrafficDescriptors: skip invalid DNN %{public}s", (uint8_t *)&v205, 0xCu);
                          }
                        }
                        else
                        {
LABEL_198:
                          long long v110 = *(NSObject **)(a1 + 56);
                          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                          {
                            TrafficDescriptor::toString((uint64_t *)&v205, (TrafficDescriptor *)(v108 - 240));
                            uint64_t v111 = &v205;
                            if (SBYTE7(v206) < 0) {
                              uint64_t v111 = (long long *)v205;
                            }
                            LODWORD(buf) = 136446210;
                            *(void *)((char *)&buf + 4) = v111;
                            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I fHplmnTrafficDescriptors: add td %{public}s", (uint8_t *)&buf, 0xCu);
                            if (SBYTE7(v206) < 0) {
                              operator delete((void *)v205);
                            }
                          }
                          unint64_t v113 = *(void *)(a1 + 136);
                          unint64_t v112 = *(void *)(a1 + 144);
                          if (v113 >= v112)
                          {
                            unint64_t v115 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v113 - *v163) >> 4);
                            unint64_t v116 = v115 + 1;
                            if (v115 + 1 > 0xD79435E50D7943) {
                              sub_10006A748();
                            }
                            unint64_t v117 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v112 - *v163) >> 4);
                            if (2 * v117 > v116) {
                              unint64_t v116 = 2 * v117;
                            }
                            if (v117 >= 0x6BCA1AF286BCA1) {
                              unint64_t v118 = 0xD79435E50D7943;
                            }
                            else {
                              unint64_t v118 = v116;
                            }
                            *(void *)&long long v207 = a1 + 144;
                            if (v118) {
                              unint64_t v119 = (char *)sub_100B05D04(a1 + 144, v118);
                            }
                            else {
                              unint64_t v119 = 0;
                            }
                            *(void *)&long long v205 = v119;
                            *((void *)&v205 + 1) = &v119[304 * v115];
                            *(void *)&long long v206 = *((void *)&v205 + 1);
                            *((void *)&v206 + 1) = &v119[304 * v118];
                            TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&v205 + 1), (const TrafficDescriptor *)(v108 - 240));
                            *(void *)&long long v206 = v206 + 304;
                            sub_100B05C8C(v163, &v205);
                            unint64_t v114 = *(void *)(a1 + 136);
                            sub_100B05DE4((uint64_t)&v205);
                          }
                          else
                          {
                            TrafficDescriptor::TrafficDescriptor(*(TrafficDescriptor **)(a1 + 136), (const TrafficDescriptor *)(v108 - 240));
                            unint64_t v114 = v113 + 304;
                            *(void *)(a1 + 136) = v114;
                          }
                          *(void *)(a1 + 136) = v114;
                        }
                      }
                      uint64_t v122 = v108 + 64;
                      v108 += 304;
                    }
                    while (v122 != v173);
                  }
                  *(void *)&long long v205 = &v190;
                  sub_1008BE774((void ***)&v205);
                  uint64_t v60 = v156;
                }
                v61 += 232;
              }
              while (v61 != v60);
            }
          }
          sub_10004D2C8(v152);
        }
      }
      uint64_t v123 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v153 + 80))(v153, v123, 1, 0);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v124, *(Registry **)(a1 + 176));
      size_t v126 = ServiceMap;
      if (v127 < 0)
      {
        unint64_t v128 = (unsigned __int8 *)(v127 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v129 = 5381;
        do
        {
          uint64_t v127 = v129;
          unsigned int v130 = *v128++;
          uint64_t v129 = (33 * v129) ^ v130;
        }
        while (v130);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long v205 = v127;
      BOOL v131 = sub_10004D37C(&v126[1].__m_.__sig, (unint64_t *)&v205);
      if (v131)
      {
        uint64_t v132 = v131[3];
        int v133 = (std::__shared_weak_count *)v131[4];
        if (v133)
        {
          atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v126);
          atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v133);
          char v134 = 0;
          if (!v132) {
            goto LABEL_277;
          }
LABEL_234:
          if (v154)
          {
            xpc_object_t v190 = 0;
            xpc_object_t v135 = xpc_dictionary_create(0, 0, 0);
            xpc_object_t v136 = v135;
            if (v135)
            {
              xpc_object_t v190 = v135;
            }
            else
            {
              xpc_object_t v136 = xpc_null_create();
              xpc_object_t v190 = v136;
              if (!v136)
              {
                xpc_object_t v137 = xpc_null_create();
                xpc_object_t v136 = 0;
                goto LABEL_242;
              }
            }
            if (xpc_get_type(v136) == (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_retain(v136);
              goto LABEL_243;
            }
            xpc_object_t v137 = xpc_null_create();
LABEL_242:
            xpc_object_t v190 = v137;
LABEL_243:
            xpc_release(v136);
            if (*(void *)(a1 + 120))
            {
              xpc_object_t v179 = xpc_BOOL_create(1);
              if (!v179) {
                xpc_object_t v179 = xpc_null_create();
              }
              *(void *)&long long v205 = &v190;
              *((void *)&v205 + 1) = "result";
              sub_100035E70((uint64_t)&v205, &v179, &object);
              xpc_release(object);
              xpc_object_t object = 0;
              xpc_release(v179);
              xpc_object_t v179 = 0;
            }
            else
            {
              xpc_object_t v183 = xpc_BOOL_create(0);
              if (!v183) {
                xpc_object_t v183 = xpc_null_create();
              }
              *(void *)&long long v205 = &v190;
              *((void *)&v205 + 1) = "result";
              sub_100035E70((uint64_t)&v205, &v183, &v184);
              xpc_release(v184);
              xpc_object_t v184 = 0;
              xpc_release(v183);
              xpc_object_t v183 = 0;
              xpc_object_t v181 = xpc_string_create("URSP_CONFIG_DECODING_FAIL");
              if (!v181) {
                xpc_object_t v181 = xpc_null_create();
              }
              *(void *)&long long v205 = &v190;
              *((void *)&v205 + 1) = "fail_reason";
              sub_100035E70((uint64_t)&v205, &v181, &v182);
              xpc_release(v182);
              xpc_object_t v182 = 0;
              xpc_release(v181);
              xpc_object_t v181 = 0;
            }
            MCCAndMNC::getStringValue((uint64_t *)&v205, (MCCAndMNC *)&v194);
            if ((SBYTE7(v206) & 0x80u) == 0) {
              unint64_t v138 = (const char *)&v205;
            }
            else {
              unint64_t v138 = (const char *)v205;
            }
            xpc_object_t v177 = xpc_string_create(v138);
            if (!v177) {
              xpc_object_t v177 = xpc_null_create();
            }
            *(void *)&long long buf = &v190;
            *((void *)&buf + 1) = "plmn";
            sub_100035E70((uint64_t)&buf, &v177, &v178);
            xpc_release(v178);
            xpc_object_t v178 = 0;
            xpc_release(v177);
            xpc_object_t v177 = 0;
            uint64_t v139 = (uint64_t *)SBYTE7(v206);
            if ((v139 & 0x80000000) != 0) {
              operator delete((void *)v205);
            }
            unsigned int v140 = (std::mutex *)Registry::getServiceMap(v139, *(Registry **)(a1 + 176));
            char v141 = v140;
            if (v142 < 0)
            {
              uint64_t v143 = (unsigned __int8 *)(v142 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v144 = 5381;
              do
              {
                uint64_t v142 = v144;
                unsigned int v145 = *v143++;
                uint64_t v144 = (33 * v144) ^ v145;
              }
              while (v145);
            }
            std::mutex::lock(v140);
            *(void *)&long long v205 = v142;
            int64x2_t v146 = sub_10004D37C(&v141[1].__m_.__sig, (unint64_t *)&v205);
            if (v146)
            {
              uint64_t v148 = v146[3];
              unint64_t v147 = (std::__shared_weak_count *)v146[4];
              if (v147)
              {
                atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v141);
                atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v147);
                char v149 = 0;
                if (!v148) {
                  goto LABEL_265;
                }
                goto LABEL_269;
              }
            }
            else
            {
              uint64_t v148 = 0;
            }
            std::mutex::unlock(v141);
            unint64_t v147 = 0;
            char v149 = 1;
            if (!v148)
            {
LABEL_265:
              BOOL v150 = 0;
              if (v149) {
                goto LABEL_271;
              }
              goto LABEL_270;
            }
LABEL_269:
            int v151 = (*(uint64_t (**)(uint64_t))(*(void *)v148 + 760))(v148);
            BOOL v150 = v151 == PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
            if (v149)
            {
LABEL_271:
              xpc_object_t v175 = xpc_BOOL_create(v150);
              if (!v175) {
                xpc_object_t v175 = xpc_null_create();
              }
              *(void *)&long long v205 = &v190;
              *((void *)&v205 + 1) = "is_data_preferred";
              sub_100035E70((uint64_t)&v205, &v175, &v176);
              xpc_release(v176);
              xpc_object_t v176 = 0;
              xpc_release(v175);
              xpc_object_t v174 = v190;
              xpc_object_t v175 = 0;
              if (v190) {
                xpc_retain(v190);
              }
              else {
                xpc_object_t v174 = xpc_null_create();
              }
              (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v132 + 16))(v132, "metricUrspConfigUpdate", &v174);
              xpc_release(v174);
              xpc_object_t v174 = 0;
              xpc_release(v190);
              goto LABEL_277;
            }
LABEL_270:
            sub_10004D2C8(v147);
            goto LABEL_271;
          }
LABEL_277:
          if ((v134 & 1) == 0) {
            sub_10004D2C8(v133);
          }
          if (SHIBYTE(v197) < 0) {
            operator delete(*((void **)&v196 + 1));
          }
          if (SHIBYTE(v195) < 0) {
            operator delete(*((void **)&v194 + 1));
          }
          uint64_t v5 = v155;
          goto LABEL_284;
        }
      }
      else
      {
        uint64_t v132 = 0;
      }
      std::mutex::unlock(v126);
      int v133 = 0;
      char v134 = 1;
      if (!v132) {
        goto LABEL_277;
      }
      goto LABEL_234;
    }
  }
}

void sub_10114669C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011469BC(void *a1, char a2)
{
}

uint64_t sub_1011469D8(char *a1, uint64_t a2)
{
  uint64_t v3 = a1 + 152;
  if (v3 != (char *)a2) {
    sub_10114A0B4(v3, *(char **)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
  int v4 = (unsigned __int8 *)*((void *)a1 + 19);
  for (uint64_t i = (unsigned __int8 *)*((void *)a1 + 20); v4 != i; v4 += 24)
  {
    uint64_t v6 = *((void *)a1 + 7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (v4[8]) {
        int v7 = *((_DWORD *)v4 + 1);
      }
      else {
        int v7 = 0xFFFFFF;
      }
      int v8 = *v4;
      *(_DWORD *)long long buf = 67109376;
      int v11 = v8;
      __int16 v12 = 1024;
      int v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I updateAllowedNssaiList_sync [sst:%u|sd:%u]", buf, 0xEu);
    }
  }
  return (*(uint64_t (**)(char *, void))(*(void *)a1 + 48))(a1, 0);
}

uint64_t sub_101146B30(char *a1, uint64_t a2)
{
  return sub_1011469D8(&a1[*(void *)(*(void *)a1 - 80)], a2);
}

void sub_101146B4C(void ***a1)
{
  long long v2 = (uint64_t *)*a1;
  if (*v2)
  {
    sub_101146BA0((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t sub_101146BA0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 232)
  {
    uint64_t v5 = (void **)(i - 24);
    sub_1011477A4(&v5);
    uint64_t result = sub_101149F54(i - 224);
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

__n128 sub_101146C0C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  *(void *)(a2 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  __n128 result = *(__n128 *)(a2 + 208);
  *(__n128 *)(a1 + 208) = result;
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;
  *(void *)(a2 + 224) = 0;
  return result;
}

void sub_101146D40(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v4 -= 232;
    sub_101146C0C(v6 - 232, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_101146DC8(unint64_t a1)
{
  if (a1 >= 0x11A7B9611A7B962) {
    sub_10006A7CC();
  }
  return operator new(232 * a1);
}

uint64_t sub_101146E14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 232;
    uint64_t v5 = (void **)(i - 24);
    sub_1011477A4(&v5);
    sub_101149F54(i - 224);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_101146E88(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  sub_101146F08(a1 + 8, a2 + 8);
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  sub_101147118((void *)(a1 + 208), *(void *)(a2 + 208), *(void *)(a2 + 216), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a2 + 216) - *(void *)(a2 + 208)) >> 3));
  return a1;
}

void sub_101146EF4(_Unwind_Exception *a1)
{
  sub_101149F54(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101146F08(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1000302C0((char *)(a1 + 8), *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000302C0((char *)(a1 + 32), *(long long **)(a2 + 32), *(long long **)(a2 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1007CC088((void *)(a1 + 56), *(void *)(a2 + 56), *(void *)(a2 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3));
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  sub_10005C928((void *)(a1 + 80), *(const void **)(a2 + 80), *(void *)(a2 + 88), *(void *)(a2 + 88) - *(void *)(a2 + 80));
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  sub_1003A10E0((void *)(a1 + 104), *(const void **)(a2 + 104), *(void *)(a2 + 112), (uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 1);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  sub_1003A2684((char *)(a1 + 128), *(int **)(a2 + 128), *(int **)(a2 + 136), (uint64_t)(*(void *)(a2 + 136) - *(void *)(a2 + 128)) >> 2);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  sub_1000302C0((char *)(a1 + 152), *(long long **)(a2 + 152), *(long long **)(a2 + 160), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 160) - *(void *)(a2 + 152)) >> 3));
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  sub_10005C928((void *)(a1 + 176), *(const void **)(a2 + 176), *(void *)(a2 + 184), *(void *)(a2 + 184) - *(void *)(a2 + 176));
  return a1;
}

void sub_101147078(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  uint64_t v8 = *v6;
  if (*v6)
  {
    v2[17] = v8;
    operator delete(v8);
  }
  uint64_t v9 = *v5;
  if (*v5)
  {
    v2[14] = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v4;
  if (*v4)
  {
    v2[11] = v10;
    operator delete(v10);
  }
  int v11 = *v3;
  if (*v3)
  {
    v2[8] = v11;
    operator delete(v11);
  }
  sub_100047F64((void ***)va);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_101147110()
{
}

void *sub_101147118(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10114719C(result, a4);
    __n128 result = (void *)sub_1011471EC(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10114717C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1011477A4(&a9);
  _Unwind_Resume(a1);
}

char *sub_10114719C(void *a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    sub_10006A748();
  }
  __n128 result = (char *)sub_100448470(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[120 * v4];
  return result;
}

uint64_t sub_1011471EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_101147270(a3 + v6, (__int16 *)(a1 + v6));
      v6 += 120;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_10114724C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 120;
    do
    {
      sub_10114774C(v4 + v2);
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101147270(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(unsigned char *)(a1 + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)a1 = v4;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v6 = (unsigned char *)*((void *)a2 + 1);
  uint64_t v5 = (unsigned char *)*((void *)a2 + 2);
  int64_t v7 = v5 - v6;
  if (v5 != v6)
  {
    sub_1011473E8((void *)(a1 + 8), 0xAAAAAAAAAAAAAAABLL * (v7 >> 3));
    uint64_t v8 = *(char **)(a1 + 16);
    memmove(v8, v6, v7);
    *(void *)(a1 + 16) = &v8[8 * (v7 >> 3)];
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000302C0((char *)(a1 + 32), *((long long **)a2 + 4), *((long long **)a2 + 5), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 5) - *((void *)a2 + 4)) >> 3));
  int v9 = *((_DWORD *)a2 + 14);
  __int16 v10 = a2[30];
  *(void *)(a1 + 64) = 0;
  *(_WORD *)(a1 + 60) = v10;
  *(_DWORD *)(a1 + 56) = v9;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v11 = *((void *)a2 + 8);
  uint64_t v12 = *((void *)a2 + 9);
  if (v12 != v11)
  {
    sub_101147438((void *)(a1 + 64), (v12 - v11) >> 7);
    *(void *)(a1 + 72) = sub_10114747C(v11, v12, *(void *)(a1 + 72));
  }
  long long v13 = *(_OWORD *)(a2 + 44);
  *(_OWORD *)(a1 + 101) = *(_OWORD *)((char *)a2 + 101);
  *(_OWORD *)(a1 + 88) = v13;
  return a1;
}

void sub_1011473A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 72) = v11;
  sub_1011476C8(&a9);
  sub_100047F64(&a9);
  long long v13 = *v10;
  if (*v10)
  {
    *(void *)(v9 + 16) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

char *sub_1011473E8(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_10006A748();
  }
  __n128 result = (char *)sub_100601864(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

char *sub_101147438(void *a1, unint64_t a2)
{
  if (a2 >> 57) {
    sub_10006A748();
  }
  __n128 result = (char *)operator new(a2 << 7);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[128 * a2];
  return result;
}

uint64_t sub_10114747C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = sub_1011475B0(a3 + v6, a1 + v6);
      sub_1011475B0(v7 + 32, a1 + v6 + 32);
      sub_1011475B0(a3 + v6 + 64, a1 + v6 + 64);
      sub_1011475B0(a3 + v6 + 96, a1 + v6 + 96);
      v6 += 128;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_101147514(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + v2 + 88))
  {
    uint64_t v4 = *(void **)(v1 + v2 + 64);
    if (v4)
    {
      *(void *)(v1 + v2 + 72) = v4;
      operator delete(v4);
    }
  }
  if (*(unsigned char *)(v1 + v2 + 56))
  {
    uint64_t v5 = *(void **)(v1 + v2 + 32);
    if (v5)
    {
      *(void *)(v1 + v2 + 40) = v5;
      operator delete(v5);
    }
  }
  if (*(unsigned char *)(v1 + v2 + 24))
  {
    uint64_t v6 = *(void **)(v1 + v2);
    if (v6)
    {
      *(void *)(v1 + v2 + 8) = v6;
      operator delete(v6);
    }
  }
  if (v2)
  {
    uint64_t v7 = v1 - 128;
    do
    {
      sub_101147630(v7 + v2);
      v2 -= 128;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011475B0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_10010556C((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_10114760C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_101147630(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 96);
    if (v2)
    {
      *(void *)(a1 + 104) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = *(void **)(a1 + 64);
    if (v3)
    {
      *(void *)(a1 + 72) = v3;
      operator delete(v3);
    }
  }
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v4 = *(void **)(a1 + 32);
    if (v4)
    {
      *(void *)(a1 + 40) = v4;
      operator delete(v4);
    }
  }
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v5;
      operator delete(v5);
    }
  }
}

void sub_1011476C8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 128;
        sub_101147630(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10114774C(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 64);
  sub_1011476C8(&v3);
  uint64_t v3 = (void **)(a1 + 32);
  sub_100047F64(&v3);
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1011477A4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 120;
        sub_10114774C(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_101147828(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 232))
  {
    uint64_t v3 = (void **)(a1 + 208);
    sub_1011477A4(&v3);
    sub_101149F54(a1 + 8);
  }
  return a1;
}

uint64_t sub_101147874(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      CSIPacketAddress::operator=();
      v5 += 24;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_1011478CC(unsigned __int8 *a1, __int16 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v8 = a2;
    BOOL v150 = a2 - 60;
    uint64_t v9 = (__n128 *)a1;
    while (1)
    {
      while (1)
      {
        a1 = (unsigned __int8 *)v9;
        uint64_t v10 = (char *)v8 - (char *)v9;
        unint64_t v11 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v8 - (char *)v9) >> 3);
        if (v5 || !v4)
        {
          switch(v11)
          {
            case 0uLL:
            case 1uLL:
              return;
            case 2uLL:
              unsigned int v52 = *((unsigned __int8 *)a2 - 120);
              char v162 = a2 - 60;
              if (v52 < *a1)
              {
                sub_101149570((__int16 *)a1, v162);
              }
              break;
            case 3uLL:
              sub_1011490CC((__int16 *)a1, (__int16 *)a1 + 60, v150);
              break;
            case 4uLL:
              sub_10114983C((__int16 *)a1, (__int16 *)a1 + 60, (__int16 *)a1 + 120, v150);
              break;
            case 5uLL:
              sub_1011498E4((__int16 *)a1, (__int16 *)a1 + 60, (__int16 *)a1 + 120, (__int16 *)a1 + 180, v150);
              break;
            default:
              JUMPOUT(0);
          }
          return;
        }
        if (v10 <= 2879)
        {
          if (a4)
          {
            if (a1 != (unsigned __int8 *)v8)
            {
              unsigned int v53 = a1 + 120;
              if (a1 + 120 != (unsigned __int8 *)a2)
              {
                uint64_t v54 = 0;
                uint64_t v55 = a1;
                do
                {
                  uint64_t v56 = v53;
                  uint64_t v57 = a2;
                  if (v55[120] < *v55)
                  {
                    memset((char *)&v165[1] + 3, 0, 101);
                    *(_OWORD *)((char *)v165 + 3) = 0u;
                    __int16 v58 = *(_WORD *)v53;
                    BYTE2(v165[0]) = v56[2];
                    LOWORD(v165[0]) = v58;
                    *(_OWORD *)((char *)v165 + 8) = *((_OWORD *)v55 + 8);
                    *((void *)&v165[1] + 1) = *((void *)v55 + 18);
                    *((void *)v55 + 16) = 0;
                    *((void *)v55 + 17) = 0;
                    v165[2] = *(_OWORD *)(v55 + 152);
                    *(void *)&v165[3] = *((void *)v55 + 21);
                    *((void *)v55 + 18) = 0;
                    *((void *)v55 + 19) = 0;
                    *((void *)v55 + 20) = 0;
                    *((void *)v55 + 21) = 0;
                    int v59 = *((_DWORD *)v55 + 44);
                    WORD6(v165[3]) = *((_WORD *)v55 + 90);
                    DWORD2(v165[3]) = v59;
                    v165[4] = *(_OWORD *)(v55 + 184);
                    *(void *)&v165[5] = *((void *)v55 + 25);
                    *((void *)v55 + 23) = 0;
                    *((void *)v55 + 24) = 0;
                    *((void *)v55 + 25) = 0;
                    long long v60 = *((_OWORD *)v55 + 13);
                    *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)(v55 + 221);
                    uint64_t v61 = v54;
                    *(_OWORD *)((char *)&v165[5] + 8) = v60;
                    while (1)
                    {
                      int64_t v62 = &a1[v61];
                      *((_WORD *)v62 + 60) = *(_WORD *)&a1[v61];
                      v62[122] = a1[v61 + 2];
                      sub_10005C9A4((uint64_t)&a1[v61 + 128], (__n128 *)&a1[v61 + 8]);
                      sub_10005CBB4((uint64_t *)&a1[v61 + 152]);
                      *(_OWORD *)(v62 + 152) = *((_OWORD *)v62 + 2);
                      *((void *)v62 + 21) = *((void *)v62 + 6);
                      *((void *)v62 + 5) = 0;
                      *((void *)v62 + 6) = 0;
                      *((void *)v62 + 4) = 0;
                      *((_DWORD *)v62 + 44) = *((_DWORD *)v62 + 14);
                      *((_WORD *)v62 + 90) = *((_WORD *)v62 + 30);
                      sub_1011497D4((void **)&a1[v61 + 184]);
                      *(_OWORD *)(v62 + 184) = *((_OWORD *)v62 + 4);
                      *((void *)v62 + 25) = *((void *)v62 + 10);
                      *((void *)v62 + 9) = 0;
                      *((void *)v62 + 10) = 0;
                      *((void *)v62 + 8) = 0;
                      *((_OWORD *)v62 + 13) = *(_OWORD *)(v62 + 88);
                      *(_OWORD *)(v62 + 221) = *(_OWORD *)(v62 + 101);
                      if (!v61) {
                        break;
                      }
                      v61 -= 120;
                      if (LOBYTE(v165[0]) >= *(v62 - 120))
                      {
                        uint64_t v63 = (uint64_t)&a1[v61 + 120];
                        goto LABEL_85;
                      }
                    }
                    uint64_t v63 = (uint64_t)a1;
LABEL_85:
                    __int16 v64 = v165[0];
                    *(unsigned char *)(v63 + 2) = BYTE2(v165[0]);
                    *(_WORD *)uint64_t v63 = v64;
                    unint64_t v67 = (void *)*((void *)v62 + 1);
                    unint64_t v66 = v62 + 8;
                    unint64_t v65 = v67;
                    if (v67)
                    {
                      *(void *)(v63 + 16) = v65;
                      operator delete(v65);
                      *(void *)unint64_t v66 = 0;
                      *((void *)v66 + 1) = 0;
                      *((void *)v66 + 2) = 0;
                    }
                    *(void *)unint64_t v66 = *((void *)&v165[0] + 1);
                    *(_OWORD *)(v63 + 16) = v165[1];
                    memset((char *)v165 + 8, 0, 24);
                    sub_10005CBB4((uint64_t *)v66 + 3);
                    *((void *)v66 + 3) = *(void *)&v165[2];
                    *(void *)(v63 + 40) = *((void *)&v165[2] + 1);
                    *(void *)(v63 + 48) = *(void *)&v165[3];
                    memset(&v165[2], 0, 24);
                    int v68 = DWORD2(v165[3]);
                    *((_WORD *)v66 + 26) = WORD6(v165[3]);
                    *((_DWORD *)v66 + 12) = v68;
                    sub_1011497D4((void **)v66 + 7);
                    *((void *)v66 + 7) = *(void *)&v165[4];
                    *(void *)(v63 + 72) = *((void *)&v165[4] + 1);
                    *(void *)(v63 + 80) = *(void *)&v165[5];
                    memset(&v165[4], 0, 24);
                    long long v69 = *(_OWORD *)((char *)&v165[5] + 8);
                    *(_OWORD *)(v66 + 93) = *(_OWORD *)((char *)&v165[6] + 5);
                    *((_OWORD *)v66 + 5) = v69;
                    *(void *)long long v163 = &v165[4];
                    sub_1011476C8((void ***)v163);
                    *(void *)long long v163 = &v165[2];
                    sub_100047F64((void ***)v163);
                    if (*((void *)&v165[0] + 1))
                    {
                      *(void *)&v165[1] = *((void *)&v165[0] + 1);
                      operator delete(*((void **)&v165[0] + 1));
                    }
                    uint64_t v57 = a2;
                  }
                  unsigned int v53 = v56 + 120;
                  v54 += 120;
                  uint64_t v55 = v56;
                }
                while (v56 + 120 != (unsigned __int8 *)v57);
              }
            }
          }
          else if (a1 != (unsigned __int8 *)v8)
          {
            xpc_object_t v137 = a1 + 120;
            if (a1 + 120 != (unsigned __int8 *)a2)
            {
              unint64_t v138 = a1 + 208;
              do
              {
                uint64_t v139 = v137;
                if (a1[120] < *a1)
                {
                  memset((char *)&v165[1] + 3, 0, 101);
                  *(_OWORD *)((char *)v165 + 3) = 0u;
                  __int16 v140 = *(_WORD *)v137;
                  BYTE2(v165[0]) = v139[2];
                  LOWORD(v165[0]) = v140;
                  *(_OWORD *)((char *)v165 + 8) = *((_OWORD *)a1 + 8);
                  *((void *)&v165[1] + 1) = *((void *)a1 + 18);
                  *((void *)a1 + 16) = 0;
                  *((void *)a1 + 17) = 0;
                  v165[2] = *(_OWORD *)(a1 + 152);
                  *(void *)&v165[3] = *((void *)a1 + 21);
                  *((void *)a1 + 18) = 0;
                  *((void *)a1 + 19) = 0;
                  *((void *)a1 + 20) = 0;
                  *((void *)a1 + 21) = 0;
                  int v141 = *((_DWORD *)a1 + 44);
                  WORD6(v165[3]) = *((_WORD *)a1 + 90);
                  DWORD2(v165[3]) = v141;
                  v165[4] = *(_OWORD *)(a1 + 184);
                  *(void *)&v165[5] = *((void *)a1 + 25);
                  *((void *)a1 + 23) = 0;
                  *((void *)a1 + 24) = 0;
                  *((void *)a1 + 25) = 0;
                  long long v142 = *((_OWORD *)a1 + 13);
                  *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)(a1 + 221);
                  uint64_t v143 = v138;
                  *(_OWORD *)((char *)&v165[5] + 8) = v142;
                  do
                  {
                    *((_WORD *)v143 - 44) = *((_WORD *)v143 - 104);
                    *(v143 - 86) = *(v143 - 206);
                    sub_10005C9A4((uint64_t)(v143 - 80), (__n128 *)(v143 - 200));
                    sub_10005CBB4((uint64_t *)v143 - 7);
                    *(_OWORD *)(v143 - 56) = *((_OWORD *)v143 - 11);
                    *((void *)v143 - 5) = *((void *)v143 - 20);
                    *((void *)v143 - 21) = 0;
                    *((void *)v143 - 20) = 0;
                    *((void *)v143 - 22) = 0;
                    *((_DWORD *)v143 - 8) = *((_DWORD *)v143 - 38);
                    *((_WORD *)v143 - 14) = *((_WORD *)v143 - 74);
                    sub_1011497D4((void **)v143 - 3);
                    *(_OWORD *)(v143 - 24) = *((_OWORD *)v143 - 9);
                    *((void *)v143 - 1) = *((void *)v143 - 16);
                    *((void *)v143 - 17) = 0;
                    *((void *)v143 - 16) = 0;
                    *((void *)v143 - 18) = 0;
                    *(_OWORD *)uint64_t v143 = *(_OWORD *)(v143 - 120);
                    *(_OWORD *)(v143 + 13) = *(_OWORD *)(v143 - 107);
                    uint64_t v144 = v143 - 328;
                    v143 -= 120;
                  }
                  while (LOBYTE(v165[0]) < *v144);
                  __int16 v145 = v165[0];
                  int64x2_t v146 = (void *)*((void *)v143 - 10);
                  *(v143 - 86) = BYTE2(v165[0]);
                  *((_WORD *)v143 - 44) = v145;
                  if (v146)
                  {
                    *((void *)v143 - 9) = v146;
                    operator delete(v146);
                    *((void *)v143 - 10) = 0;
                    *((void *)v143 - 9) = 0;
                    *((void *)v143 - 8) = 0;
                  }
                  *((_OWORD *)v143 - 5) = *(_OWORD *)((char *)v165 + 8);
                  *((void *)v143 - 8) = *((void *)&v165[1] + 1);
                  memset((char *)v165 + 8, 0, 24);
                  sub_10005CBB4((uint64_t *)v143 - 7);
                  *(_OWORD *)(v143 - 56) = v165[2];
                  *((void *)v143 - 5) = *(void *)&v165[3];
                  memset(&v165[2], 0, 24);
                  int v147 = DWORD2(v165[3]);
                  *((_WORD *)v143 - 14) = WORD6(v165[3]);
                  *((_DWORD *)v143 - 8) = v147;
                  sub_1011497D4((void **)v143 - 3);
                  *(_OWORD *)(v143 - 24) = v165[4];
                  *((void *)v143 - 1) = *(void *)&v165[5];
                  memset(&v165[4], 0, 24);
                  long long v148 = *(_OWORD *)((char *)&v165[5] + 8);
                  *(_OWORD *)(v143 + 13) = *(_OWORD *)((char *)&v165[6] + 5);
                  *(_OWORD *)uint64_t v143 = v148;
                  *(void *)long long v163 = &v165[4];
                  sub_1011476C8((void ***)v163);
                  *(void *)long long v163 = &v165[2];
                  sub_100047F64((void ***)v163);
                  if (*((void *)&v165[0] + 1))
                  {
                    *(void *)&v165[1] = *((void *)&v165[0] + 1);
                    operator delete(*((void **)&v165[0] + 1));
                  }
                }
                xpc_object_t v137 = v139 + 120;
                v138 += 120;
                a1 = v139;
              }
              while (v139 + 120 != (unsigned __int8 *)a2);
            }
          }
          return;
        }
        if (!a3)
        {
          if (a1 != (unsigned __int8 *)v8)
          {
            int64_t v160 = (v11 - 2) >> 1;
            int64_t v70 = v160;
            uint64_t v156 = v10;
            do
            {
              int64_t v71 = v70;
              if (v160 >= v70)
              {
                uint64_t v72 = (2 * v70) | 1;
                uint64_t v73 = &a1[120 * v72];
                if (2 * v71 + 2 < (uint64_t)v11)
                {
                  unsigned int v76 = *v73;
                  unsigned int v74 = v73[120];
                  BOOL v75 = v76 >= v74;
                  if (v76 <= v74) {
                    unsigned int v76 = v73[120];
                  }
                  if (!v75)
                  {
                    v73 += 120;
                    uint64_t v72 = 2 * v71 + 2;
                  }
                }
                else
                {
                  unsigned int v76 = *v73;
                }
                uint64_t v77 = &a1[120 * v71];
                if (v76 >= *v77)
                {
                  memset((char *)&v165[1] + 3, 0, 101);
                  *(_OWORD *)((char *)v165 + 3) = 0u;
                  __int16 v78 = *(_WORD *)v77;
                  BYTE2(v165[0]) = v77[2];
                  LOWORD(v165[0]) = v78;
                  int64_t v159 = v71;
                  unsigned int v79 = &a1[120 * v71];
                  *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(v79 + 8);
                  *((void *)&v165[1] + 1) = *((void *)v79 + 3);
                  *((void *)v79 + 1) = 0;
                  *((void *)v79 + 2) = 0;
                  *((void *)v79 + 3) = 0;
                  v165[2] = *((_OWORD *)v79 + 2);
                  *(void *)&v165[3] = *((void *)v79 + 6);
                  *((void *)v79 + 4) = 0;
                  *((void *)v79 + 5) = 0;
                  *((void *)v79 + 6) = 0;
                  int v80 = *((_DWORD *)v79 + 14);
                  WORD6(v165[3]) = *((_WORD *)v79 + 30);
                  DWORD2(v165[3]) = v80;
                  v165[4] = *((_OWORD *)v79 + 4);
                  *(void *)&v165[5] = *((void *)v79 + 10);
                  *((void *)v79 + 9) = 0;
                  *((void *)v79 + 10) = 0;
                  *((void *)v79 + 8) = 0;
                  long long v81 = *(_OWORD *)(v79 + 88);
                  *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)(v79 + 101);
                  *(_OWORD *)((char *)&v165[5] + 8) = v81;
                  unsigned int v82 = LOBYTE(v165[0]);
                  do
                  {
                    uint64_t v83 = v73;
                    __int16 v84 = *(_WORD *)v73;
                    v77[2] = v83[2];
                    *(_WORD *)uint64_t v77 = v84;
                    sub_10005C9A4((uint64_t)(v77 + 8), (__n128 *)(v83 + 8));
                    sub_10005CBB4((uint64_t *)v77 + 4);
                    *((_OWORD *)v77 + 2) = *((_OWORD *)v83 + 2);
                    *((void *)v77 + 6) = *((void *)v83 + 6);
                    *((void *)v83 + 4) = 0;
                    *((void *)v83 + 5) = 0;
                    *((void *)v83 + 6) = 0;
                    int v85 = *((_DWORD *)v83 + 14);
                    *((_WORD *)v77 + 30) = *((_WORD *)v83 + 30);
                    *((_DWORD *)v77 + 14) = v85;
                    sub_1011497D4((void **)v77 + 8);
                    *((_OWORD *)v77 + 4) = *((_OWORD *)v83 + 4);
                    *((void *)v77 + 10) = *((void *)v83 + 10);
                    *((void *)v83 + 8) = 0;
                    *((void *)v83 + 9) = 0;
                    *((void *)v83 + 10) = 0;
                    long long v86 = *(_OWORD *)(v83 + 88);
                    *(_OWORD *)(v77 + 101) = *(_OWORD *)(v83 + 101);
                    *(_OWORD *)(v77 + 88) = v86;
                    if (v160 < v72) {
                      break;
                    }
                    uint64_t v73 = &a1[120 * ((2 * v72) | 1)];
                    if (2 * v72 + 2 < (uint64_t)v11)
                    {
                      unsigned int v89 = *v73;
                      unsigned int v87 = v73[120];
                      BOOL v88 = v89 >= v87;
                      if (v89 <= v87) {
                        unsigned int v89 = v73[120];
                      }
                      if (v88)
                      {
                        uint64_t v72 = (2 * v72) | 1;
                      }
                      else
                      {
                        v73 += 120;
                        uint64_t v72 = 2 * v72 + 2;
                      }
                    }
                    else
                    {
                      unsigned int v89 = *v73;
                      uint64_t v72 = (2 * v72) | 1;
                    }
                    uint64_t v77 = v83;
                  }
                  while (v89 >= v82);
                  __int16 v90 = v165[0];
                  v83[2] = BYTE2(v165[0]);
                  *(_WORD *)uint64_t v83 = v90;
                  int v91 = (void *)*((void *)v83 + 1);
                  if (v91)
                  {
                    *((void *)v83 + 2) = v91;
                    operator delete(v91);
                    *((void *)v83 + 1) = 0;
                    *((void *)v83 + 2) = 0;
                    *((void *)v83 + 3) = 0;
                  }
                  *(_OWORD *)(v83 + 8) = *(_OWORD *)((char *)v165 + 8);
                  *((void *)v83 + 3) = *((void *)&v165[1] + 1);
                  memset((char *)v165 + 8, 0, 24);
                  sub_10005CBB4((uint64_t *)v83 + 4);
                  *((_OWORD *)v83 + 2) = v165[2];
                  *((void *)v83 + 6) = *(void *)&v165[3];
                  memset(&v165[2], 0, 24);
                  __int16 v92 = WORD6(v165[3]);
                  *((_DWORD *)v83 + 14) = DWORD2(v165[3]);
                  *((_WORD *)v83 + 30) = v92;
                  sub_1011497D4((void **)v83 + 8);
                  *((_OWORD *)v83 + 4) = v165[4];
                  *((void *)v83 + 10) = *(void *)&v165[5];
                  memset(&v165[4], 0, 24);
                  long long v93 = *(_OWORD *)((char *)&v165[6] + 5);
                  *(_OWORD *)(v83 + 88) = *(_OWORD *)((char *)&v165[5] + 8);
                  *(_OWORD *)(v83 + 101) = v93;
                  *(void *)long long v163 = &v165[4];
                  sub_1011476C8((void ***)v163);
                  *(void *)long long v163 = &v165[2];
                  sub_100047F64((void ***)v163);
                  if (*((void *)&v165[0] + 1))
                  {
                    *(void *)&v165[1] = *((void *)&v165[0] + 1);
                    operator delete(*((void **)&v165[0] + 1));
                  }
                  uint64_t v10 = v156;
                  int64_t v71 = v159;
                }
              }
              int64_t v70 = v71 - 1;
            }
            while (v71);
            int64_t v94 = v10 / 0x78uLL;
            do
            {
              if (v94 >= 2)
              {
                uint64_t v95 = 0;
                memset(&v163[19], 0, 101);
                *(_OWORD *)&v163[3] = 0u;
                __int16 v96 = *(_WORD *)a1;
                v163[2] = a1[2];
                *(_WORD *)long long v163 = v96;
                uint64_t v154 = *((void *)a1 + 2);
                uint64_t v157 = *((void *)a1 + 1);
                *(void *)&v163[8] = v157;
                *(void *)&v163[16] = v154;
                uint64_t v151 = *((void *)a1 + 3);
                *(void *)&v163[24] = v151;
                *((void *)a1 + 2) = 0;
                *((void *)a1 + 3) = 0;
                *((void *)a1 + 1) = 0;
                *(_OWORD *)&v163[32] = *((_OWORD *)a1 + 2);
                *(void *)&v163[48] = *((void *)a1 + 6);
                *((void *)a1 + 4) = 0;
                *((void *)a1 + 5) = 0;
                *((void *)a1 + 6) = 0;
                int v97 = *((_DWORD *)a1 + 14);
                *(_WORD *)&v163[60] = *((_WORD *)a1 + 30);
                *(_DWORD *)&v163[56] = v97;
                *(_OWORD *)&v163[64] = *((_OWORD *)a1 + 4);
                *(void *)&v163[80] = *((void *)a1 + 10);
                *((void *)a1 + 8) = 0;
                *((void *)a1 + 9) = 0;
                *((void *)a1 + 10) = 0;
                long long v98 = *(_OWORD *)(a1 + 88);
                *(_OWORD *)&v163[101] = *(_OWORD *)(a1 + 101);
                uint64_t v99 = (__int16 *)a1;
                *(_OWORD *)&v163[88] = v98;
                do
                {
                  size_t v100 = &v99[60 * v95 + 60];
                  uint64_t v101 = (2 * v95) | 1;
                  uint64_t v102 = 2 * v95 + 2;
                  if (v102 < v94 && *(unsigned __int8 *)v100 < *((unsigned __int8 *)v100 + 120))
                  {
                    v100 += 60;
                    uint64_t v101 = v102;
                  }
                  __int16 v103 = *v100;
                  *((unsigned char *)v99 + 2) = *((unsigned char *)v100 + 2);
                  *uint64_t v99 = v103;
                  uint64_t v104 = v100 + 4;
                  sub_10005C9A4((uint64_t)(v99 + 4), (__n128 *)(v100 + 4));
                  sub_10005CBB4((uint64_t *)v99 + 4);
                  *((_OWORD *)v99 + 2) = *((_OWORD *)v100 + 2);
                  *((void *)v99 + 6) = *((void *)v100 + 6);
                  *((void *)v100 + 4) = 0;
                  *((void *)v100 + 5) = 0;
                  *((void *)v100 + 6) = 0;
                  uint64_t v106 = (int *)(v100 + 28);
                  int v105 = *((_DWORD *)v100 + 14);
                  v99[30] = v100[30];
                  *((_DWORD *)v99 + 14) = v105;
                  sub_1011497D4((void **)v99 + 8);
                  *((_OWORD *)v99 + 4) = *((_OWORD *)v100 + 4);
                  *((void *)v99 + 10) = *((void *)v100 + 10);
                  *((void *)v100 + 8) = 0;
                  *((void *)v100 + 9) = 0;
                  *((void *)v100 + 10) = 0;
                  long long v107 = *(_OWORD *)(v100 + 44);
                  *(_OWORD *)((char *)v99 + 101) = *(_OWORD *)((char *)v100 + 101);
                  *(_OWORD *)(v99 + 44) = v107;
                  uint64_t v99 = v100;
                  uint64_t v95 = v101;
                }
                while (v101 <= (uint64_t)((unint64_t)(v94 - 2) >> 1));
                unint64_t v108 = a2 - 60;
                if (v100 == a2 - 60)
                {
                  __int16 v132 = *(_WORD *)v163;
                  *((unsigned char *)v100 + 2) = v163[2];
                  *size_t v100 = v132;
                  int v133 = (void *)*((void *)v100 + 1);
                  if (v133)
                  {
                    *((void *)v100 + 2) = v133;
                    operator delete(v133);
                    *uint64_t v104 = 0;
                    *((void *)v100 + 2) = 0;
                    *((void *)v100 + 3) = 0;
                  }
                  *(_OWORD *)(v100 + 4) = *(_OWORD *)&v163[8];
                  *((void *)v100 + 3) = *(void *)&v163[24];
                  memset(&v163[8], 0, 24);
                  sub_10005CBB4((uint64_t *)v100 + 4);
                  *((_OWORD *)v100 + 2) = *(_OWORD *)&v163[32];
                  *((void *)v100 + 6) = *(void *)&v163[48];
                  memset(&v163[32], 0, 24);
                  int v134 = *(_DWORD *)&v163[56];
                  v100[30] = *(_WORD *)&v163[60];
                  *uint64_t v106 = v134;
                  sub_1011497D4((void **)v100 + 8);
                  *((_OWORD *)v100 + 4) = *(_OWORD *)&v163[64];
                  *((void *)v100 + 10) = *(void *)&v163[80];
                  memset(&v163[64], 0, 24);
                  long long v135 = *(_OWORD *)&v163[88];
                  *(_OWORD *)((char *)v100 + 101) = *(_OWORD *)&v163[101];
                  *(_OWORD *)(v100 + 44) = v135;
                }
                else
                {
                  __int16 v109 = *v108;
                  *((unsigned char *)v100 + 2) = *((unsigned char *)a2 - 118);
                  *size_t v100 = v109;
                  sub_10005C9A4((uint64_t)(v100 + 4), (__n128 *)a2 - 7);
                  sub_10005CBB4((uint64_t *)v100 + 4);
                  *((_OWORD *)v100 + 2) = *(_OWORD *)(a2 - 44);
                  *((void *)v100 + 6) = *((void *)a2 - 9);
                  *((void *)a2 - 11) = 0;
                  *((void *)a2 - 10) = 0;
                  *((void *)a2 - 9) = 0;
                  int v110 = *((_DWORD *)a2 - 16);
                  v100[30] = *(a2 - 30);
                  *uint64_t v106 = v110;
                  sub_1011497D4((void **)v100 + 8);
                  uint64_t v111 = a2 - 28;
                  *((_OWORD *)v100 + 4) = *(_OWORD *)(a2 - 28);
                  *((void *)v100 + 10) = *((void *)a2 - 5);
                  *(void *)uint64_t v111 = 0;
                  *((void *)v111 + 1) = 0;
                  *((void *)v111 + 2) = 0;
                  long long v112 = *((_OWORD *)a2 - 2);
                  *(_OWORD *)((char *)v100 + 101) = *(_OWORD *)((char *)a2 - 19);
                  *(_OWORD *)(v100 + 44) = v112;
                  __int16 v113 = *(_WORD *)v163;
                  *((unsigned char *)a2 - 118) = v163[2];
                  *unint64_t v108 = v113;
                  unint64_t v114 = (void *)*((void *)a2 - 14);
                  if (v114)
                  {
                    *((void *)a2 - 13) = v114;
                    operator delete(v114);
                  }
                  char v149 = a2 - 16;
                  *((void *)a2 - 14) = v157;
                  *((void *)a2 - 13) = v154;
                  *((void *)a2 - 12) = v151;
                  memset(&v163[8], 0, 24);
                  sub_10005CBB4((uint64_t *)a2 - 11);
                  *(_OWORD *)(a2 - 44) = *(_OWORD *)&v163[32];
                  *((void *)a2 - 9) = *(void *)&v163[48];
                  memset(&v163[32], 0, 24);
                  int v115 = *(_DWORD *)&v163[56];
                  *(a2 - 30) = *(_WORD *)&v163[60];
                  *((_DWORD *)a2 - 16) = v115;
                  sub_1011497D4((void **)a2 - 7);
                  *(_OWORD *)(a2 - 28) = *(_OWORD *)&v163[64];
                  *((void *)a2 - 5) = *(void *)&v163[80];
                  memset(&v163[64], 0, 24);
                  long long v116 = *(_OWORD *)&v163[88];
                  *(_OWORD *)((char *)v149 + 13) = *(_OWORD *)&v163[101];
                  *(_OWORD *)char v149 = v116;
                  uint64_t v117 = (char *)(v100 + 60) - (char *)a1;
                  if (v117 >= 121)
                  {
                    unint64_t v118 = (v117 / 0x78uLL - 2) >> 1;
                    unint64_t v119 = &a1[120 * v118];
                    if (*v119 < *(unsigned __int8 *)v100)
                    {
                      memset((char *)&v165[1] + 3, 0, 101);
                      *(_OWORD *)((char *)v165 + 3) = 0u;
                      __int16 v120 = *v100;
                      BYTE2(v165[0]) = *((unsigned char *)v100 + 2);
                      LOWORD(v165[0]) = v120;
                      uint64_t v158 = *((void *)v100 + 1);
                      *((void *)&v165[0] + 1) = v158;
                      uint64_t v155 = *((void *)v100 + 2);
                      *(void *)&v165[1] = v155;
                      uint64_t v152 = *((void *)v100 + 3);
                      *((void *)&v165[1] + 1) = v152;
                      *uint64_t v104 = 0;
                      *((void *)v100 + 2) = 0;
                      *((void *)v100 + 3) = 0;
                      v165[2] = *((_OWORD *)v100 + 2);
                      *(void *)&v165[3] = *((void *)v100 + 6);
                      *((void *)v100 + 4) = 0;
                      *((void *)v100 + 5) = 0;
                      *((void *)v100 + 6) = 0;
                      int v121 = *v106;
                      WORD6(v165[3]) = v100[30];
                      DWORD2(v165[3]) = v121;
                      v165[4] = *((_OWORD *)v100 + 4);
                      *(void *)&v165[5] = *((void *)v100 + 10);
                      *((void *)v100 + 9) = 0;
                      *((void *)v100 + 10) = 0;
                      *((void *)v100 + 8) = 0;
                      long long v122 = *(_OWORD *)(v100 + 44);
                      *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)((char *)v100 + 101);
                      *(_OWORD *)((char *)&v165[5] + 8) = v122;
                      unsigned int v123 = LOBYTE(v165[0]);
                      do
                      {
                        int64_t v124 = v119;
                        __int16 v125 = *(_WORD *)v119;
                        *((unsigned char *)v100 + 2) = v124[2];
                        *size_t v100 = v125;
                        sub_10005C9A4((uint64_t)(v100 + 4), (__n128 *)(v124 + 8));
                        sub_10005CBB4((uint64_t *)v100 + 4);
                        *((_OWORD *)v100 + 2) = *((_OWORD *)v124 + 2);
                        *((void *)v100 + 6) = *((void *)v124 + 6);
                        *((void *)v124 + 4) = 0;
                        *((void *)v124 + 5) = 0;
                        *((void *)v124 + 6) = 0;
                        int v126 = *((_DWORD *)v124 + 14);
                        v100[30] = *((_WORD *)v124 + 30);
                        *((_DWORD *)v100 + 14) = v126;
                        sub_1011497D4((void **)v100 + 8);
                        *((_OWORD *)v100 + 4) = *((_OWORD *)v124 + 4);
                        *((void *)v100 + 10) = *((void *)v124 + 10);
                        *((void *)v124 + 8) = 0;
                        *((void *)v124 + 9) = 0;
                        *((void *)v124 + 10) = 0;
                        long long v127 = *(_OWORD *)(v124 + 88);
                        *(_OWORD *)((char *)v100 + 101) = *(_OWORD *)(v124 + 101);
                        *(_OWORD *)(v100 + 44) = v127;
                        if (!v118) {
                          break;
                        }
                        unint64_t v118 = (v118 - 1) >> 1;
                        unint64_t v119 = &a1[120 * v118];
                        size_t v100 = (__int16 *)v124;
                      }
                      while (*v119 < v123);
                      __int16 v128 = v165[0];
                      v124[2] = BYTE2(v165[0]);
                      *(_WORD *)int64_t v124 = v128;
                      uint64_t v129 = (void *)*((void *)v124 + 1);
                      if (v129)
                      {
                        *((void *)v124 + 2) = v129;
                        operator delete(v129);
                      }
                      *((void *)v124 + 1) = v158;
                      *((void *)v124 + 2) = v155;
                      *((void *)v124 + 3) = v152;
                      memset((char *)v165 + 8, 0, 24);
                      sub_10005CBB4((uint64_t *)v124 + 4);
                      *((_OWORD *)v124 + 2) = v165[2];
                      *((void *)v124 + 6) = *(void *)&v165[3];
                      memset(&v165[2], 0, 24);
                      __int16 v130 = WORD6(v165[3]);
                      *((_DWORD *)v124 + 14) = DWORD2(v165[3]);
                      *((_WORD *)v124 + 30) = v130;
                      sub_1011497D4((void **)v124 + 8);
                      *((_OWORD *)v124 + 4) = v165[4];
                      *((void *)v124 + 10) = *(void *)&v165[5];
                      memset(&v165[4], 0, 24);
                      long long v131 = *(_OWORD *)((char *)&v165[6] + 5);
                      *(_OWORD *)(v124 + 88) = *(_OWORD *)((char *)&v165[5] + 8);
                      *(_OWORD *)(v124 + 101) = v131;
                      long long v164 = (void **)&v165[4];
                      sub_1011476C8(&v164);
                      long long v164 = (void **)&v165[2];
                      sub_100047F64(&v164);
                      if (*((void *)&v165[0] + 1))
                      {
                        *(void *)&v165[1] = *((void *)&v165[0] + 1);
                        operator delete(*((void **)&v165[0] + 1));
                      }
                    }
                  }
                }
                *(void *)&v165[0] = &v163[64];
                sub_1011476C8((void ***)v165);
                *(void *)&v165[0] = &v163[32];
                sub_100047F64((void ***)v165);
                if (*(void *)&v163[8])
                {
                  *(void *)&v163[16] = *(void *)&v163[8];
                  operator delete(*(void **)&v163[8]);
                }
              }
              a2 -= 60;
            }
            while ((unint64_t)v94-- > 2);
          }
          return;
        }
        if ((unint64_t)v10 >= 0x3C01)
        {
          sub_1011490CC((__int16 *)a1, (__int16 *)&a1[120 * (v11 >> 1)], v150);
          uint64_t v12 = 120 * (v11 >> 1);
          sub_1011490CC((__int16 *)a1 + 60, (__int16 *)&a1[v12 - 120], a2 - 120);
          sub_1011490CC((__int16 *)a1 + 120, (__int16 *)&a1[v12 + 120], a2 - 180);
          sub_1011490CC((__int16 *)&a1[v12 - 120], (__int16 *)&a1[v12], (__int16 *)&a1[v12 + 120]);
          sub_101149570((__int16 *)a1, (__int16 *)&a1[v12]);
        }
        else
        {
          sub_1011490CC((__int16 *)&a1[120 * (v11 >> 1)], (__int16 *)a1, v150);
        }
        --a3;
        if ((a4 & 1) != 0 || *(a1 - 120) < *a1) {
          break;
        }
        memset((char *)&v165[1] + 3, 0, 101);
        *(_OWORD *)((char *)v165 + 3) = 0u;
        __int16 v34 = *(_WORD *)a1;
        BYTE2(v165[0]) = a1[2];
        LOWORD(v165[0]) = v34;
        *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(a1 + 8);
        *((void *)&v165[1] + 1) = *((void *)a1 + 3);
        *((void *)a1 + 1) = 0;
        *((void *)a1 + 2) = 0;
        *((void *)a1 + 3) = 0;
        v165[2] = *((_OWORD *)a1 + 2);
        *(void *)&v165[3] = *((void *)a1 + 6);
        *((void *)a1 + 4) = 0;
        *((void *)a1 + 5) = 0;
        *((void *)a1 + 6) = 0;
        int v35 = *((_DWORD *)a1 + 14);
        WORD6(v165[3]) = *((_WORD *)a1 + 30);
        DWORD2(v165[3]) = v35;
        v165[4] = *((_OWORD *)a1 + 4);
        *(void *)&v165[5] = *((void *)a1 + 10);
        *((void *)a1 + 8) = 0;
        *((void *)a1 + 9) = 0;
        *((void *)a1 + 10) = 0;
        long long v36 = *(_OWORD *)(a1 + 88);
        *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)(a1 + 101);
        *(_OWORD *)((char *)&v165[5] + 8) = v36;
        unsigned int v37 = LOBYTE(v165[0]);
        if (LOBYTE(v165[0]) < *(unsigned __int8 *)v150)
        {
          uint64_t v9 = (__n128 *)a1;
          do
          {
            unsigned int v38 = v9[7].n128_u8[8];
            uint64_t v9 = (__n128 *)((char *)v9 + 120);
          }
          while (LOBYTE(v165[0]) >= v38);
        }
        else
        {
          int v39 = a1 + 120;
          do
          {
            uint64_t v9 = (__n128 *)v39;
            if (v39 >= (unsigned __int8 *)v8) {
              break;
            }
            v39 += 120;
          }
          while (LOBYTE(v165[0]) >= v9->n128_u8[0]);
        }
        uint64_t v40 = v8;
        if (v9 < (__n128 *)v8)
        {
          uint64_t v40 = v8;
          do
          {
            unsigned int v41 = *((unsigned __int8 *)v40 - 120);
            v40 -= 60;
          }
          while (LOBYTE(v165[0]) < v41);
        }
        while (v9 < (__n128 *)v40)
        {
          sub_101149570((__int16 *)v9, v40);
          do
          {
            unsigned int v42 = v9[7].n128_u8[8];
            uint64_t v9 = (__n128 *)((char *)v9 + 120);
          }
          while (v37 >= v42);
          do
          {
            unsigned int v43 = *((unsigned __int8 *)v40 - 120);
            v40 -= 60;
          }
          while (v37 < v43);
        }
        unsigned int v44 = &v9[-8].n128_u8[8];
        if (&v9[-8].n128_i8[8] != (__int8 *)a1)
        {
          __int16 v45 = *(_WORD *)v44;
          a1[2] = v9[-8].n128_u8[10];
          *(_WORD *)a1 = v45;
          sub_10005C9A4((uint64_t)(a1 + 8), v9 - 7);
          sub_10005CBB4((uint64_t *)a1 + 4);
          *((__n128 *)a1 + 2) = *(__n128 *)((char *)v9 - 88);
          *((void *)a1 + 6) = v9[-5].n128_u64[1];
          v9[-6].n128_u64[1] = 0;
          v9[-5].n128_u64[0] = 0;
          v9[-5].n128_u64[1] = 0;
          unsigned __int32 v46 = v9[-4].n128_u32[0];
          *((_WORD *)a1 + 30) = v9[-4].n128_u16[2];
          *((_DWORD *)a1 + 14) = v46;
          sub_1011497D4((void **)a1 + 8);
          *((__n128 *)a1 + 4) = *(__n128 *)((char *)v9 - 56);
          *((void *)a1 + 10) = v9[-3].n128_u64[1];
          v9[-4].n128_u64[1] = 0;
          v9[-3].n128_u64[0] = 0;
          v9[-3].n128_u64[1] = 0;
          __n128 v47 = v9[-2];
          *(__n128 *)(a1 + 101) = *(__n128 *)((char *)v9 - 19);
          *(__n128 *)(a1 + 88) = v47;
        }
        __int16 v48 = v165[0];
        v9[-8].n128_u8[10] = BYTE2(v165[0]);
        *(_WORD *)unsigned int v44 = v48;
        unint64_t v49 = (void *)v9[-7].n128_u64[0];
        if (v49)
        {
          v9[-7].n128_u64[1] = (unint64_t)v49;
          operator delete(v49);
          v9[-7].n128_u64[0] = 0;
          v9[-7].n128_u64[1] = 0;
          v9[-6].n128_u64[0] = 0;
        }
        v9[-7] = *(__n128 *)((char *)v165 + 8);
        v9[-6].n128_u64[0] = *((void *)&v165[1] + 1);
        memset((char *)v165 + 8, 0, 24);
        sub_10005CBB4(&v9[-6].n128_i64[1]);
        *(_OWORD *)((char *)v9 - 88) = v165[2];
        v9[-5].n128_u64[1] = *(void *)&v165[3];
        memset(&v165[2], 0, 24);
        unsigned __int32 v50 = DWORD2(v165[3]);
        v9[-4].n128_u16[2] = WORD6(v165[3]);
        v9[-4].n128_u32[0] = v50;
        sub_1011497D4((void **)&v9[-4].n128_u64[1]);
        *(_OWORD *)((char *)v9 - 56) = v165[4];
        v9[-3].n128_u64[1] = *(void *)&v165[5];
        memset(&v165[4], 0, 24);
        __n128 v51 = *(__n128 *)((char *)&v165[5] + 8);
        *(__n128 *)((char *)v9 - 19) = *(__n128 *)((char *)&v165[6] + 5);
        v9[-2] = v51;
        *(void *)long long v163 = &v165[4];
        sub_1011476C8((void ***)v163);
        *(void *)long long v163 = &v165[2];
        sub_100047F64((void ***)v163);
        if (*((void *)&v165[0] + 1))
        {
          *(void *)&v165[1] = *((void *)&v165[0] + 1);
          operator delete(*((void **)&v165[0] + 1));
        }
LABEL_37:
        a4 = 0;
      }
      uint64_t v13 = 0;
      memset((char *)&v165[1] + 3, 0, 101);
      *(_OWORD *)((char *)v165 + 3) = 0u;
      __int16 v14 = *(_WORD *)a1;
      BYTE2(v165[0]) = a1[2];
      LOWORD(v165[0]) = v14;
      *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(a1 + 8);
      *((void *)&v165[1] + 1) = *((void *)a1 + 3);
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
      *((void *)a1 + 3) = 0;
      v165[2] = *((_OWORD *)a1 + 2);
      *(void *)&v165[3] = *((void *)a1 + 6);
      *((void *)a1 + 4) = 0;
      *((void *)a1 + 5) = 0;
      *((void *)a1 + 6) = 0;
      int v15 = *((_DWORD *)a1 + 14);
      WORD6(v165[3]) = *((_WORD *)a1 + 30);
      DWORD2(v165[3]) = v15;
      v165[4] = *((_OWORD *)a1 + 4);
      *(void *)&v165[5] = *((void *)a1 + 10);
      *((void *)a1 + 8) = 0;
      *((void *)a1 + 9) = 0;
      *((void *)a1 + 10) = 0;
      long long v16 = *(_OWORD *)(a1 + 88);
      *(_OWORD *)((char *)&v165[6] + 5) = *(_OWORD *)(a1 + 101);
      *(_OWORD *)((char *)&v165[5] + 8) = v16;
      unsigned int v17 = LOBYTE(v165[0]);
      do
      {
        unsigned int v18 = a1[v13 + 120];
        v13 += 120;
      }
      while (v18 < LOBYTE(v165[0]));
      int64x2_t v19 = &a1[v13];
      if (v13 == 120)
      {
        uint64_t v8 = a2;
        do
        {
          if (v19 >= (unsigned __int8 *)v8) {
            break;
          }
          unsigned int v21 = *((unsigned __int8 *)v8 - 120);
          v8 -= 60;
        }
        while (v21 >= LOBYTE(v165[0]));
      }
      else
      {
        do
        {
          unsigned int v20 = *((unsigned __int8 *)v8 - 120);
          v8 -= 60;
        }
        while (v20 >= LOBYTE(v165[0]));
      }
      if (v19 < (unsigned __int8 *)v8)
      {
        uint64_t v22 = v8;
        uint64_t v9 = (__n128 *)&a1[v13];
        do
        {
          sub_101149570((__int16 *)v9, v22);
          do
          {
            unsigned int v23 = v9[7].n128_u8[8];
            uint64_t v9 = (__n128 *)((char *)v9 + 120);
          }
          while (v23 < v17);
          do
          {
            unsigned int v24 = *((unsigned __int8 *)v22 - 120);
            v22 -= 60;
          }
          while (v24 >= v17);
        }
        while (v9 < (__n128 *)v22);
      }
      else
      {
        uint64_t v9 = (__n128 *)&a1[v13];
      }
      int v25 = &v9[-8].n128_u8[8];
      if (&v9[-8].n128_i8[8] != (__int8 *)a1)
      {
        __int16 v26 = *(_WORD *)v25;
        a1[2] = v9[-8].n128_u8[10];
        *(_WORD *)a1 = v26;
        sub_10005C9A4((uint64_t)(a1 + 8), v9 - 7);
        sub_10005CBB4((uint64_t *)a1 + 4);
        *((__n128 *)a1 + 2) = *(__n128 *)((char *)v9 - 88);
        *((void *)a1 + 6) = v9[-5].n128_u64[1];
        v9[-6].n128_u64[1] = 0;
        v9[-5].n128_u64[0] = 0;
        v9[-5].n128_u64[1] = 0;
        unsigned __int32 v27 = v9[-4].n128_u32[0];
        *((_WORD *)a1 + 30) = v9[-4].n128_u16[2];
        *((_DWORD *)a1 + 14) = v27;
        sub_1011497D4((void **)a1 + 8);
        *((__n128 *)a1 + 4) = *(__n128 *)((char *)v9 - 56);
        *((void *)a1 + 10) = v9[-3].n128_u64[1];
        v9[-4].n128_u64[1] = 0;
        v9[-3].n128_u64[0] = 0;
        v9[-3].n128_u64[1] = 0;
        __n128 v28 = v9[-2];
        *(__n128 *)(a1 + 101) = *(__n128 *)((char *)v9 - 19);
        *(__n128 *)(a1 + 88) = v28;
      }
      __int16 v29 = v165[0];
      v9[-8].n128_u8[10] = BYTE2(v165[0]);
      *(_WORD *)int v25 = v29;
      uint64_t v30 = (void *)v9[-7].n128_u64[0];
      if (v30)
      {
        v9[-7].n128_u64[1] = (unint64_t)v30;
        operator delete(v30);
        v9[-7].n128_u64[0] = 0;
        v9[-7].n128_u64[1] = 0;
        v9[-6].n128_u64[0] = 0;
      }
      v9[-7] = *(__n128 *)((char *)v165 + 8);
      v9[-6].n128_u64[0] = *((void *)&v165[1] + 1);
      memset((char *)v165 + 8, 0, 24);
      sub_10005CBB4(&v9[-6].n128_i64[1]);
      *(_OWORD *)((char *)v9 - 88) = v165[2];
      v9[-5].n128_u64[1] = *(void *)&v165[3];
      memset(&v165[2], 0, 24);
      unsigned __int32 v31 = DWORD2(v165[3]);
      v9[-4].n128_u16[2] = WORD6(v165[3]);
      v9[-4].n128_u32[0] = v31;
      sub_1011497D4((void **)&v9[-4].n128_u64[1]);
      *(_OWORD *)((char *)v9 - 56) = v165[4];
      v9[-3].n128_u64[1] = *(void *)&v165[5];
      memset(&v165[4], 0, 24);
      __n128 v32 = *(__n128 *)((char *)&v165[5] + 8);
      *(__n128 *)((char *)v9 - 19) = *(__n128 *)((char *)&v165[6] + 5);
      v9[-2] = v32;
      *(void *)long long v163 = &v165[4];
      sub_1011476C8((void ***)v163);
      *(void *)long long v163 = &v165[2];
      sub_100047F64((void ***)v163);
      if (*((void *)&v165[0] + 1))
      {
        *(void *)&v165[1] = *((void *)&v165[0] + 1);
        operator delete(*((void **)&v165[0] + 1));
      }
      BOOL v4 = v19 >= (unsigned __int8 *)v8;
      uint64_t v8 = a2;
      if (!v4)
      {
LABEL_36:
        sub_1011478CC(a1, &v9[-8].n128_i8[8], a3, a4 & 1);
        goto LABEL_37;
      }
      BOOL v33 = sub_10114918C((__int16 *)a1, &v9[-8].n128_i16[4]);
      if (sub_10114918C((__int16 *)v9, a2)) {
        break;
      }
      if (!v33) {
        goto LABEL_36;
      }
    }
    a2 = &v9[-8].n128_i16[4];
    if (!v33) {
      continue;
    }
    break;
  }
}

void sub_1011490CC(__int16 *a1, __int16 *a2, __int16 *a3)
{
  char v5 = a1;
  unsigned int v6 = *(unsigned __int8 *)a2;
  unsigned int v7 = *(unsigned __int8 *)a3;
  if (v6 >= *(unsigned __int8 *)a1)
  {
    if (v7 >= v6) {
      return;
    }
    sub_101149570(a2, a3);
    if (*(unsigned __int8 *)a2 >= *(unsigned __int8 *)v5) {
      return;
    }
    a1 = v5;
    uint64_t v8 = a2;
  }
  else
  {
    if (v7 >= v6)
    {
      sub_101149570(a1, a2);
      if (*(unsigned __int8 *)a3 >= *(unsigned __int8 *)a2) {
        return;
      }
      a1 = a2;
    }
    uint64_t v8 = a3;
  }

  sub_101149570(a1, v8);
}

BOOL sub_10114918C(__int16 *a1, __int16 *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(0xEEEEEEEEEEEEEEEFLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*((unsigned __int8 *)a2 - 120) < *(unsigned __int8 *)a1)
      {
        sub_101149570(a1, a2 - 60);
        return 1;
      }
      return result;
    case 3uLL:
      sub_1011490CC(a1, a1 + 60, a2 - 60);
      return 1;
    case 4uLL:
      sub_10114983C(a1, a1 + 60, a1 + 120, a2 - 60);
      return 1;
    case 5uLL:
      sub_1011498E4(a1, a1 + 60, a1 + 120, a1 + 180, a2 - 60);
      return 1;
    default:
      unsigned int v6 = (unsigned __int8 *)(a1 + 120);
      sub_1011490CC(a1, a1 + 60, a1 + 120);
      unsigned int v7 = (unsigned __int8 *)(a1 + 180);
      if (a1 + 180 == v2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      uint64_t v22 = (unsigned __int8 *)v2;
      break;
  }
  while (1)
  {
    if (*v7 < *v6)
    {
      int v23 = v9;
      memset(&v25[17], 0, 101);
      __int16 v24 = *(_WORD *)v7;
      *(void *)int v25 = v7[2];
      *(_OWORD *)&v25[6] = *(_OWORD *)(v7 + 8);
      *(void *)&v25[22] = *((void *)v7 + 3);
      *((void *)v7 + 1) = 0;
      *((void *)v7 + 2) = 0;
      *(_OWORD *)&v25[30] = *((_OWORD *)v7 + 2);
      *(void *)&v25[46] = *((void *)v7 + 6);
      *((void *)v7 + 3) = 0;
      *((void *)v7 + 4) = 0;
      *((void *)v7 + 5) = 0;
      *((void *)v7 + 6) = 0;
      int v10 = *((_DWORD *)v7 + 14);
      *(_WORD *)&v25[58] = *((_WORD *)v7 + 30);
      *(_DWORD *)&v25[54] = v10;
      *(_OWORD *)&v25[62] = *((_OWORD *)v7 + 4);
      *(void *)&v25[78] = *((void *)v7 + 10);
      *((void *)v7 + 8) = 0;
      *((void *)v7 + 9) = 0;
      *((void *)v7 + 10) = 0;
      long long v11 = *(_OWORD *)(v7 + 88);
      *(_OWORD *)&v25[99] = *(_OWORD *)(v7 + 101);
      uint64_t v12 = v8;
      *(_OWORD *)&v25[86] = v11;
      while (1)
      {
        uint64_t v13 = (char *)a1 + v12;
        *((_WORD *)v13 + 180) = *(__int16 *)((char *)a1 + v12 + 240);
        v13[362] = *((unsigned char *)a1 + v12 + 242);
        sub_10005C9A4((uint64_t)a1 + v12 + 368, (__n128 *)((char *)a1 + v12 + 248));
        sub_10005CBB4((uint64_t *)((char *)a1 + v12 + 392));
        *(_OWORD *)(v13 + 392) = *((_OWORD *)v13 + 17);
        *((void *)v13 + 51) = *((void *)v13 + 36);
        *((void *)v13 + 35) = 0;
        *((void *)v13 + 36) = 0;
        *((void *)v13 + 34) = 0;
        *((_DWORD *)v13 + 104) = *((_DWORD *)v13 + 74);
        *((_WORD *)v13 + 210) = *((_WORD *)v13 + 150);
        sub_1011497D4((void **)((char *)a1 + v12 + 424));
        *(_OWORD *)(v13 + 424) = *((_OWORD *)v13 + 19);
        *((void *)v13 + 55) = *((void *)v13 + 40);
        *((void *)v13 + 39) = 0;
        *((void *)v13 + 40) = 0;
        *((void *)v13 + 38) = 0;
        *((_OWORD *)v13 + 28) = *(_OWORD *)(v13 + 328);
        *(_OWORD *)(v13 + 461) = *(_OWORD *)(v13 + 341);
        if (v12 == -240) {
          break;
        }
        v12 -= 120;
        if (v24 >= v13[120])
        {
          uint64_t v14 = (uint64_t)a1 + v12 + 360;
          goto LABEL_12;
        }
      }
      uint64_t v14 = (uint64_t)a1;
LABEL_12:
      *(_WORD *)uint64_t v14 = v24;
      *(unsigned char *)(v14 + 2) = v25[0];
      unsigned int v17 = (void *)*((void *)v13 + 31);
      long long v16 = v13 + 248;
      int v15 = v17;
      if (v17)
      {
        *(void *)(v14 + 16) = v15;
        operator delete(v15);
        *(void *)long long v16 = 0;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = 0;
      }
      *(void *)long long v16 = *(void *)&v25[6];
      *(void *)(v14 + 16) = *(void *)&v25[14];
      *(void *)(v14 + 24) = *(void *)&v25[22];
      sub_10005CBB4((uint64_t *)v16 + 3);
      uint64_t v18 = *(void *)&v25[38];
      *((void *)v16 + 3) = *(void *)&v25[30];
      uint64_t v19 = *(void *)&v25[46];
      *(void *)(v14 + 40) = v18;
      *(void *)(v14 + 48) = v19;
      memset(&v25[30], 0, 24);
      *((_DWORD *)v16 + 12) = *(_DWORD *)&v25[54];
      *((_WORD *)v16 + 26) = *(_WORD *)&v25[58];
      sub_1011497D4((void **)v16 + 7);
      uint64_t v20 = *(void *)&v25[70];
      *((void *)v16 + 7) = *(void *)&v25[62];
      uint64_t v21 = *(void *)&v25[78];
      *(void *)(v14 + 72) = v20;
      *(void *)(v14 + 80) = v21;
      memset(&v25[62], 0, 24);
      *((_OWORD *)v16 + 5) = *(_OWORD *)&v25[86];
      *(_OWORD *)(v16 + 93) = *(_OWORD *)&v25[99];
      v26[0] = (void **)&v25[62];
      sub_1011476C8(v26);
      v26[0] = (void **)&v25[30];
      sub_100047F64(v26);
      int v9 = v23 + 1;
      uint64_t v2 = (__int16 *)v22;
      if (v23 == 7) {
        return v7 + 120 == v22;
      }
    }
    unsigned int v6 = v7;
    v8 += 120;
    v7 += 120;
    if (v7 == (unsigned __int8 *)v2) {
      return 1;
    }
  }
}

void sub_101149570(__int16 *a1, __int16 *a2)
{
  memset(v25, 0, sizeof(v25));
  __int16 v23 = *a1;
  char v24 = *((unsigned char *)a1 + 2);
  uint64_t v5 = *((void *)a1 + 1);
  uint64_t v4 = a1 + 4;
  uint64_t v6 = *((void *)a1 + 3);
  uint64_t v21 = *((void *)a1 + 2);
  uint64_t v22 = v5;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  *uint64_t v4 = 0;
  uint64_t v19 = *((void *)a1 + 4);
  uint64_t v20 = v6;
  *(void *)&v25[13] = v19;
  uint64_t v17 = *((void *)a1 + 6);
  uint64_t v18 = *((void *)a1 + 5);
  *(void *)&v25[21] = v18;
  *(void *)&v25[29] = v17;
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 6) = 0;
  int v7 = *((_DWORD *)a1 + 14);
  *(_WORD *)&v25[41] = a1[30];
  *(_DWORD *)&v25[37] = v7;
  uint64_t v8 = *((void *)a1 + 10);
  uint64_t v15 = *((void *)a1 + 9);
  uint64_t v16 = *((void *)a1 + 8);
  *(void *)&v25[45] = v16;
  *(void *)&v25[53] = v15;
  uint64_t v14 = v8;
  *(void *)&v25[61] = v8;
  *((void *)a1 + 8) = 0;
  *((void *)a1 + 9) = 0;
  *((void *)a1 + 10) = 0;
  long long v9 = *(_OWORD *)(a1 + 44);
  *(_OWORD *)&v25[82] = *(_OWORD *)((char *)a1 + 101);
  *(_OWORD *)&v25[69] = v9;
  __int16 v10 = *a2;
  *((unsigned char *)a1 + 2) = *((unsigned char *)a2 + 2);
  *a1 = v10;
  sub_10005C9A4((uint64_t)v4, (__n128 *)(a2 + 4));
  sub_10005CBB4((uint64_t *)a1 + 4);
  *((_OWORD *)a1 + 2) = *((_OWORD *)a2 + 2);
  *((void *)a1 + 6) = *((void *)a2 + 6);
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  int v11 = *((_DWORD *)a2 + 14);
  a1[30] = a2[30];
  *((_DWORD *)a1 + 14) = v11;
  sub_1011497D4((void **)a1 + 8);
  *((_OWORD *)a1 + 4) = *((_OWORD *)a2 + 4);
  *((void *)a1 + 10) = *((void *)a2 + 10);
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  long long v12 = *(_OWORD *)(a2 + 44);
  *(_OWORD *)((char *)a1 + 101) = *(_OWORD *)((char *)a2 + 101);
  *(_OWORD *)(a1 + 44) = v12;
  *a2 = v23;
  *((unsigned char *)a2 + 2) = v24;
  uint64_t v13 = (void *)*((void *)a2 + 1);
  if (v13)
  {
    *((void *)a2 + 2) = v13;
    operator delete(v13);
  }
  *((void *)a2 + 1) = v22;
  *((void *)a2 + 2) = v21;
  *((void *)a2 + 3) = v20;
  sub_10005CBB4((uint64_t *)a2 + 4);
  *((void *)a2 + 4) = v19;
  *((void *)a2 + 5) = v18;
  *((void *)a2 + 6) = v17;
  memset(&v25[13], 0, 24);
  *((_DWORD *)a2 + 14) = *(_DWORD *)&v25[37];
  a2[30] = *(_WORD *)&v25[41];
  sub_1011497D4((void **)a2 + 8);
  *((void *)a2 + 8) = v16;
  *((void *)a2 + 9) = v15;
  *((void *)a2 + 10) = v14;
  memset(&v25[45], 0, 24);
  *(_OWORD *)(a2 + 44) = *(_OWORD *)&v25[69];
  *(_OWORD *)((char *)a2 + 101) = *(_OWORD *)&v25[82];
  v26[0] = (void **)&v25[45];
  sub_1011476C8(v26);
  v26[0] = (void **)&v25[13];
  sub_100047F64(v26);
}

void sub_1011497D4(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 128;
        sub_101147630(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_10114983C(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4)
{
  sub_1011490CC(a1, a2, a3);
  if (*(unsigned __int8 *)a4 < *(unsigned __int8 *)a3)
  {
    sub_101149570(a3, a4);
    if (*(unsigned __int8 *)a3 < *(unsigned __int8 *)a2)
    {
      sub_101149570(a2, a3);
      if (*(unsigned __int8 *)a2 < *(unsigned __int8 *)a1)
      {
        sub_101149570(a1, a2);
      }
    }
  }
}

void sub_1011498E4(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5)
{
  sub_10114983C(a1, a2, a3, a4);
  if (*(unsigned __int8 *)a5 < *(unsigned __int8 *)a4)
  {
    sub_101149570(a4, a5);
    if (*(unsigned __int8 *)a4 < *(unsigned __int8 *)a3)
    {
      sub_101149570(a3, a4);
      if (*(unsigned __int8 *)a3 < *(unsigned __int8 *)a2)
      {
        sub_101149570(a2, a3);
        if (*(unsigned __int8 *)a2 < *(unsigned __int8 *)a1)
        {
          sub_101149570(a1, a2);
        }
      }
    }
  }
}

void sub_1011499B8(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 120;
        sub_10114774C(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_101149A20(__int16 *a1, __int16 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    for (uint64_t i = a1; i != a2; i += 60)
    {
      __int16 v6 = *i;
      *(unsigned char *)(a3 + 2) = *((unsigned char *)i + 2);
      *(_WORD *)a3 = v6;
      if ((__int16 *)a3 != i)
      {
        sub_10114A0B4((char *)(a3 + 8), *((char **)i + 1), *((void *)i + 2), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)i + 2) - *((void *)i + 1)) >> 3));
        sub_10005CA3C(a3 + 32, *((std::string **)i + 4), *((long long **)i + 5), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)i + 5) - *((void *)i + 4)) >> 3));
        int v7 = *((_DWORD *)i + 14);
        uint64_t v8 = *(char ***)(a3 + 64);
        *(_WORD *)(a3 + 60) = i[30];
        *(_DWORD *)(a3 + 56) = v7;
        uint64_t v10 = *((void *)i + 8);
        uint64_t v9 = *((void *)i + 9);
        unint64_t v11 = (v9 - v10) >> 7;
        if (v11 <= (uint64_t)(*(void *)(a3 + 80) - (void)v8) >> 7)
        {
          unint64_t v16 = (uint64_t)(*(void *)(a3 + 72) - (void)v8) >> 7;
          if (v16 >= v11)
          {
            uint64_t v18 = sub_101149BF4(*((const void ***)i + 8), *((const void ***)i + 9), v8);
            for (uint64_t j = *(void *)(a3 + 72); (char **)j != v18; sub_101147630(j))
              j -= 128;
            *(void *)(a3 + 72) = v18;
            goto LABEL_18;
          }
          uint64_t v17 = (const void **)(v10 + (v16 << 7));
          sub_101149BF4(*((const void ***)i + 8), v17, v8);
          uint64_t v15 = sub_10114747C((uint64_t)v17, v9, *(void *)(a3 + 72));
        }
        else
        {
          sub_1011497D4((void **)(a3 + 64));
          if (v9 - v10 < 0) {
            sub_10006A748();
          }
          uint64_t v12 = *(void *)(a3 + 80) - *(void *)(a3 + 64);
          uint64_t v13 = v12 >> 6;
          if (v12 >> 6 <= v11) {
            uint64_t v13 = (v9 - v10) >> 7;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFF80) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v13;
          }
          sub_101147438((void *)(a3 + 64), v14);
          uint64_t v15 = sub_10114747C(v10, v9, *(void *)(a3 + 72));
        }
        *(void *)(a3 + 72) = v15;
      }
LABEL_18:
      long long v20 = *(_OWORD *)(i + 44);
      *(_OWORD *)(a3 + 101) = *(_OWORD *)((char *)i + 101);
      *(_OWORD *)(a3 + 88) = v20;
      a3 += 120;
    }
  }
  return a3;
}

void sub_101149BE4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  _Unwind_Resume(a1);
}

void sub_101149BEC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  _Unwind_Resume(a1);
}

char **sub_101149BF4(const void **a1, const void **a2, char **a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_101149C70(a3, v5);
      sub_101149C70(a3 + 4, v5 + 4);
      sub_101149C70(a3 + 8, v5 + 8);
      sub_101149C70(a3 + 12, v5 + 12);
      a3 += 16;
      v5 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_101149C70(char **a1, const void **a2)
{
  if (*((unsigned __int8 *)a1 + 24) == *((unsigned __int8 *)a2 + 24))
  {
    if (a1 != (char **)a2 && *((unsigned char *)a1 + 24))
    {
      uint64_t v3 = (char *)*a2;
      uint64_t v4 = (char *)a2[1];
      int64_t v5 = v4 - (unsigned char *)*a2;
      unint64_t v6 = v5 >> 3;
      uint64_t v7 = (uint64_t)a1[2];
      uint64_t v8 = *a1;
      if (v5 >> 3 <= (unint64_t)((v7 - (uint64_t)*a1) >> 3))
      {
        unint64_t v11 = (void **)(a1 + 1);
        unint64_t v14 = a1[1];
        unint64_t v15 = (v14 - v8) >> 3;
        if (v15 < v6)
        {
          unint64_t v16 = &v3[8 * v15];
          if (v14 != v8)
          {
            memmove(v8, *a2, v14 - v8);
            uint64_t v8 = (char *)*v11;
          }
          int64_t v5 = v4 - v16;
          if (v4 == v16) {
            goto LABEL_27;
          }
          uint64_t v17 = v8;
          uint64_t v18 = v16;
          goto LABEL_26;
        }
      }
      else
      {
        if (v8)
        {
          a1[1] = v8;
          operator delete(v8);
          uint64_t v7 = 0;
          *a1 = 0;
          a1[1] = 0;
          a1[2] = 0;
        }
        if (v5 < 0) {
          sub_10010562C();
        }
        uint64_t v9 = v7 >> 2;
        if (v7 >> 2 <= v6) {
          uint64_t v9 = v5 >> 3;
        }
        if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v9;
        }
        sub_1001055E8(a1, v10);
        uint64_t v12 = a1[1];
        unint64_t v11 = (void **)(a1 + 1);
        uint64_t v8 = v12;
      }
      if (v4 == v3)
      {
LABEL_27:
        void *v11 = &v8[v5];
        return;
      }
      uint64_t v17 = v8;
      uint64_t v18 = v3;
LABEL_26:
      memmove(v17, v18, v5);
      goto LABEL_27;
    }
  }
  else if (*((unsigned char *)a1 + 24))
  {
    uint64_t v13 = *a1;
    if (*a1)
    {
      a1[1] = v13;
      operator delete(v13);
    }
    *((unsigned char *)a1 + 24) = 0;
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    sub_10010556C(a1, *a2, (uint64_t)a2[1], ((unsigned char *)a2[1] - (unsigned char *)*a2) >> 3);
    *((unsigned char *)a1 + 24) = 1;
  }
}

uint64_t sub_101149DDC(uint64_t a1, const CSIPacketAddress *a2)
{
  uint64_t v3 = *(const CSIPacketAddress **)a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_10006A748();
  }
  uint64_t v7 = a1 + 16;
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 16;
  if (v9) {
    unint64_t v10 = (char *)sub_10004812C(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  std::string __p = v10;
  unint64_t v14 = (CSIPacketAddress *)&v10[24 * v4];
  unint64_t v16 = &v10[24 * v9];
  CSIPacketAddress::CSIPacketAddress(v14, a2);
  unint64_t v15 = (CSIPacketAddress *)((char *)v14 + 24);
  sub_10028DB34((const CSIPacketAddress **)a1, &__p);
  uint64_t v11 = *(void *)(a1 + 8);
  if (v15 != v14) {
    unint64_t v15 = (CSIPacketAddress *)((char *)v14 + (v15 - v14 - 24) % 0x18uLL);
  }
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

void sub_101149F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101149F54(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 176);
  if (v2)
  {
    *(void *)(a1 + 184) = v2;
    operator delete(v2);
  }
  unint64_t v8 = (void **)(a1 + 152);
  sub_100047F64(&v8);
  uint64_t v3 = *(void **)(a1 + 128);
  if (v3)
  {
    *(void *)(a1 + 136) = v3;
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(a1 + 104);
  if (v4)
  {
    *(void *)(a1 + 112) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(a1 + 80);
  if (v5)
  {
    *(void *)(a1 + 88) = v5;
    operator delete(v5);
  }
  unint64_t v6 = *(void **)(a1 + 56);
  if (v6)
  {
    *(void *)(a1 + 64) = v6;
    operator delete(v6);
  }
  unint64_t v8 = (void **)(a1 + 32);
  sub_100047F64(&v8);
  unint64_t v8 = (void **)(a1 + 8);
  sub_100047F64(&v8);
  return a1;
}

uint64_t sub_10114A000(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    sub_10114774C(i - 120);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10114A050(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120))
  {
    unint64_t v4 = (void **)(a1 + 64);
    sub_1011476C8(&v4);
    unint64_t v4 = (void **)(a1 + 32);
    sub_100047F64(&v4);
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      *(void *)(a1 + 16) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

char *sub_10114A0B4(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    BOOL result = sub_1011473E8(v7, v12);
    unint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    unint64_t v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v13 = (void **)(result + 8);
  unint64_t v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v15 - v9);
    unint64_t v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v13 = &v9[v17];
  return result;
}

uint64_t sub_10114A1EC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(uint64_t **)(a1 + 8);
    uint64_t v2 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = *v2;
    for (uint64_t i = *v3; v4 != i; v4 -= 232)
    {
      uint64_t v7 = (void **)(v4 - 24);
      sub_1011477A4(&v7);
      sub_101149F54(v4 - 224);
    }
  }
  return a1;
}

uint64_t sub_10114A264(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  sub_101146F08(a1 + 8, a2 + 8);
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  sub_101147118((void *)(a1 + 208), *(void *)(a2 + 208), *(void *)(a2 + 216), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a2 + 216) - *(void *)(a2 + 208)) >> 3));
  return a1;
}

void sub_10114A2D0(_Unwind_Exception *a1)
{
  sub_101149F54(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10114A2E4(uint64_t result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  v180 = (unsigned __int8 *)result;
  while (2)
  {
    uint64_t v7 = a2;
    uint64_t v8 = v180;
    uint64_t v161 = (char *)(a2 - 232);
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v7 - v8;
          unint64_t v190 = 0x34F72C234F72C235 * ((v7 - v8) >> 3);
          v180 = v8;
          if (v5 || !v4)
          {
            switch(0x34F72C234F72C235 * ((v7 - v8) >> 3))
            {
              case 0:
              case 1:
                return result;
              case 2:
                unsigned int v68 = *(a2 - 232);
                xpc_object_t v179 = (char *)(a2 - 232);
                if (v68 < *v8)
                {
                  BOOL result = sub_10114CFB0((char *)v8, v179);
                }
                break;
              case 3:
                BOOL result = (uint64_t)sub_10114C924((char *)v8, (char *)v8 + 232, v161);
                break;
              case 4:
                BOOL result = sub_10114D3EC((char *)v8, (char *)v8 + 232, (char *)v8 + 464, v161);
                break;
              case 5:
                BOOL result = sub_10114D494((char *)v8, (char *)v8 + 232, (char *)v8 + 464, (char *)v8 + 696, v161);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v9 <= 5567)
          {
            if (a4)
            {
              if (v8 != v7)
              {
                long long v69 = v8 + 232;
                if (v8 + 232 != a2)
                {
                  uint64_t v70 = 0;
                  int64_t v71 = v8;
                  do
                  {
                    uint64_t v72 = v69;
                    unsigned int v73 = v71[232];
                    if (v73 < *v71)
                    {
                      uint64_t v217 = 0;
                      unint64_t v216 = v73;
                      LOBYTE(v217) = v71[240];
                      *(_OWORD *)long long v218 = *(_OWORD *)(v71 + 248);
                      uint64_t v74 = *((void *)v71 + 33);
                      *((void *)v71 + 31) = 0;
                      *((void *)v71 + 32) = 0;
                      __n128 v219 = *((__n128 *)v71 + 17);
                      unint64_t v75 = *((void *)v71 + 36);
                      *(void *)&v218[16] = v74;
                      unint64_t v220 = v75;
                      *((void *)v71 + 33) = 0;
                      *((void *)v71 + 34) = 0;
                      *((void *)v71 + 35) = 0;
                      *((void *)v71 + 36) = 0;
                      __n128 v221 = *(__n128 *)(v71 + 296);
                      unint64_t v222 = *((void *)v71 + 39);
                      *((void *)v71 + 37) = 0;
                      *((void *)v71 + 38) = 0;
                      *((void *)v71 + 39) = 0;
                      __n128 v223 = *((__n128 *)v71 + 20);
                      unint64_t v224 = *((void *)v71 + 42);
                      *((void *)v71 + 40) = 0;
                      *((void *)v71 + 41) = 0;
                      *((void *)v71 + 42) = 0;
                      __n128 v225 = *(__n128 *)(v71 + 344);
                      unint64_t v226 = *((void *)v71 + 45);
                      *((void *)v71 + 43) = 0;
                      *((void *)v71 + 44) = 0;
                      *((void *)v71 + 45) = 0;
                      __n128 v227 = *((__n128 *)v71 + 23);
                      unint64_t v228 = *((void *)v71 + 48);
                      *((void *)v71 + 46) = 0;
                      *((void *)v71 + 47) = 0;
                      *((void *)v71 + 48) = 0;
                      __n128 v229 = *(__n128 *)(v71 + 392);
                      unint64_t v230 = *((void *)v71 + 51);
                      *((void *)v71 + 49) = 0;
                      *((void *)v71 + 50) = 0;
                      *((void *)v71 + 51) = 0;
                      __n128 v231 = *((__n128 *)v71 + 26);
                      unint64_t v232 = *((void *)v71 + 54);
                      *((void *)v71 + 52) = 0;
                      *((void *)v71 + 53) = 0;
                      *((void *)v71 + 54) = 0;
                      __n128 v233 = *(__n128 *)(v71 + 440);
                      unint64_t v234 = *((void *)v71 + 57);
                      *((void *)v71 + 55) = 0;
                      *((void *)v71 + 56) = 0;
                      *((void *)v71 + 57) = 0;
                      uint64_t v76 = v70;
                      LOBYTE(v77) = *v71;
                      while (1)
                      {
                        __int16 v78 = &v180[v76];
                        v78[232] = v77;
                        v78[240] = v180[v76 + 8];
                        sub_10005CBB4((uint64_t *)&v180[v76 + 248]);
                        *(_OWORD *)(v78 + 248) = *((_OWORD *)v78 + 1);
                        *((void *)v78 + 33) = *((void *)v78 + 4);
                        *((void *)v78 + 3) = 0;
                        *((void *)v78 + 4) = 0;
                        *((void *)v78 + 2) = 0;
                        sub_10005CBB4((uint64_t *)&v180[v76 + 272]);
                        *((_OWORD *)v78 + 17) = *(_OWORD *)(v78 + 40);
                        *((void *)v78 + 36) = *((void *)v78 + 7);
                        *((void *)v78 + 6) = 0;
                        *((void *)v78 + 7) = 0;
                        *((void *)v78 + 5) = 0;
                        sub_10005C9A4((uint64_t)(v78 + 296), (__n128 *)v78 + 4);
                        sub_10005C9A4((uint64_t)(v78 + 320), (__n128 *)(v78 + 88));
                        sub_10005C9A4((uint64_t)(v78 + 344), (__n128 *)v78 + 7);
                        sub_10005C9A4((uint64_t)(v78 + 368), (__n128 *)(v78 + 136));
                        sub_10005CBB4((uint64_t *)&v180[v76 + 392]);
                        *(_OWORD *)(v78 + 392) = *((_OWORD *)v78 + 10);
                        *((void *)v78 + 51) = *((void *)v78 + 22);
                        *((void *)v78 + 21) = 0;
                        *((void *)v78 + 22) = 0;
                        *((void *)v78 + 20) = 0;
                        sub_10005C9A4((uint64_t)(v78 + 416), (__n128 *)(v78 + 184));
                        sub_1011499B8((void **)&v180[v76 + 440]);
                        *(_OWORD *)(v78 + 440) = *((_OWORD *)v78 + 13);
                        *((void *)v78 + 57) = *((void *)v78 + 28);
                        *((void *)v78 + 26) = 0;
                        *((void *)v78 + 27) = 0;
                        *((void *)v78 + 28) = 0;
                        if (!v76) {
                          break;
                        }
                        unsigned int v77 = *(v78 - 232);
                        v76 -= 232;
                        if (v216 >= v77)
                        {
                          uint64_t v79 = (uint64_t)&v180[v76 + 232];
                          goto LABEL_98;
                        }
                      }
                      uint64_t v79 = (uint64_t)v180;
LABEL_98:
                      *(unsigned char *)uint64_t v79 = v216;
                      *(unsigned char *)(v79 + 8) = v217;
                      sub_10005CBB4((uint64_t *)v78 + 2);
                      *((void *)v78 + 2) = *(void *)v218;
                      *(void *)(v79 + 24) = *(void *)&v218[8];
                      *(void *)(v79 + 32) = *(void *)&v218[16];
                      memset(v218, 0, sizeof(v218));
                      sub_10005CBB4((uint64_t *)v78 + 5);
                      *((void *)v78 + 5) = v219.n128_u64[0];
                      *(void *)(v79 + 48) = v219.n128_u64[1];
                      *(void *)(v79 + 56) = v220;
                      __n128 v219 = 0uLL;
                      unint64_t v220 = 0;
                      unsigned int v82 = (void *)*((void *)v78 + 8);
                      long long v81 = v78 + 64;
                      int v80 = v82;
                      if (v82)
                      {
                        *(void *)(v79 + 72) = v80;
                        operator delete(v80);
                        *(void *)long long v81 = 0;
                        *((void *)v81 + 1) = 0;
                        *((void *)v81 + 2) = 0;
                      }
                      uint64_t v83 = v81 + 24;
                      *(void *)long long v81 = v221.n128_u64[0];
                      *(void *)(v79 + 72) = v221.n128_u64[1];
                      *(void *)(v79 + 80) = v222;
                      __n128 v221 = 0uLL;
                      unint64_t v222 = 0;
                      __int16 v84 = (void *)*((void *)v81 + 3);
                      if (v84)
                      {
                        *(void *)(v79 + 96) = v84;
                        operator delete(v84);
                        void *v83 = 0;
                        *((void *)v81 + 4) = 0;
                        *((void *)v81 + 5) = 0;
                      }
                      int v85 = v81 + 48;
                      void *v83 = v223.n128_u64[0];
                      *(void *)(v79 + 96) = v223.n128_u64[1];
                      *(void *)(v79 + 104) = v224;
                      __n128 v223 = 0uLL;
                      unint64_t v224 = 0;
                      long long v86 = (void *)*((void *)v81 + 6);
                      if (v86)
                      {
                        *(void *)(v79 + 120) = v86;
                        operator delete(v86);
                        void *v85 = 0;
                        *((void *)v81 + 7) = 0;
                        *((void *)v81 + 8) = 0;
                      }
                      unsigned int v87 = v81 + 72;
                      void *v85 = v225.n128_u64[0];
                      *(void *)(v79 + 120) = v225.n128_u64[1];
                      *(void *)(v79 + 128) = v226;
                      __n128 v225 = 0uLL;
                      unint64_t v226 = 0;
                      BOOL v88 = (void *)*((void *)v81 + 9);
                      if (v88)
                      {
                        *(void *)(v79 + 144) = v88;
                        operator delete(v88);
                        *unsigned int v87 = 0;
                        *((void *)v81 + 10) = 0;
                        *((void *)v81 + 11) = 0;
                      }
                      unsigned int v89 = v81 + 120;
                      *unsigned int v87 = v227.n128_u64[0];
                      *(void *)(v79 + 144) = v227.n128_u64[1];
                      *(void *)(v79 + 152) = v228;
                      __n128 v227 = 0uLL;
                      unint64_t v228 = 0;
                      sub_10005CBB4((uint64_t *)v81 + 12);
                      *((void *)v81 + 12) = v229.n128_u64[0];
                      *(void *)(v79 + 168) = v229.n128_u64[1];
                      *(void *)(v79 + 176) = v230;
                      __n128 v229 = 0uLL;
                      unint64_t v230 = 0;
                      __int16 v90 = (void *)*((void *)v81 + 15);
                      if (v90)
                      {
                        *(void *)(v79 + 192) = v90;
                        operator delete(v90);
                        *unsigned int v89 = 0;
                        *((void *)v81 + 16) = 0;
                        *((void *)v81 + 17) = 0;
                      }
                      *unsigned int v89 = v231.n128_u64[0];
                      *(void *)(v79 + 192) = v231.n128_u64[1];
                      *(void *)(v79 + 200) = v232;
                      __n128 v231 = 0uLL;
                      unint64_t v232 = 0;
                      sub_1011499B8((void **)v81 + 18);
                      *((void *)v81 + 18) = v233.n128_u64[0];
                      *(void *)(v79 + 216) = v233.n128_u64[1];
                      *(void *)(v79 + 224) = v234;
                      __n128 v233 = 0uLL;
                      unint64_t v234 = 0;
                      long long v195 = &v233;
                      sub_1011477A4((void ***)&v195);
                      BOOL result = sub_101149F54((uint64_t)&v217);
                    }
                    long long v69 = v72 + 232;
                    v70 += 232;
                    int64_t v71 = v72;
                  }
                  while (v72 + 232 != a2);
                }
              }
            }
            else if (v8 != v7)
            {
              __int16 v145 = v8 + 232;
              if (v8 + 232 != a2)
              {
                int64x2_t v146 = v8 + 456;
                do
                {
                  int v147 = v145;
                  unsigned int v148 = v180[232];
                  if (v148 < *v180)
                  {
                    uint64_t v217 = 0;
                    unint64_t v216 = v148;
                    LOBYTE(v217) = v180[240];
                    *(_OWORD *)long long v218 = *(_OWORD *)(v180 + 248);
                    uint64_t v149 = *((void *)v180 + 33);
                    *((void *)v180 + 31) = 0;
                    *((void *)v180 + 32) = 0;
                    __n128 v219 = *((__n128 *)v180 + 17);
                    unint64_t v150 = *((void *)v180 + 36);
                    *(void *)&v218[16] = v149;
                    unint64_t v220 = v150;
                    *((void *)v180 + 33) = 0;
                    *((void *)v180 + 34) = 0;
                    *((void *)v180 + 35) = 0;
                    *((void *)v180 + 36) = 0;
                    __n128 v221 = *(__n128 *)(v180 + 296);
                    unint64_t v222 = *((void *)v180 + 39);
                    *((void *)v180 + 37) = 0;
                    *((void *)v180 + 38) = 0;
                    *((void *)v180 + 39) = 0;
                    __n128 v223 = *((__n128 *)v180 + 20);
                    unint64_t v224 = *((void *)v180 + 42);
                    *((void *)v180 + 40) = 0;
                    *((void *)v180 + 41) = 0;
                    *((void *)v180 + 42) = 0;
                    __n128 v225 = *(__n128 *)(v180 + 344);
                    unint64_t v226 = *((void *)v180 + 45);
                    *((void *)v180 + 43) = 0;
                    *((void *)v180 + 44) = 0;
                    *((void *)v180 + 45) = 0;
                    __n128 v227 = *((__n128 *)v180 + 23);
                    unint64_t v228 = *((void *)v180 + 48);
                    *((void *)v180 + 46) = 0;
                    *((void *)v180 + 47) = 0;
                    *((void *)v180 + 48) = 0;
                    __n128 v229 = *(__n128 *)(v180 + 392);
                    unint64_t v230 = *((void *)v180 + 51);
                    *((void *)v180 + 49) = 0;
                    *((void *)v180 + 50) = 0;
                    *((void *)v180 + 51) = 0;
                    __n128 v231 = *((__n128 *)v180 + 26);
                    unint64_t v232 = *((void *)v180 + 54);
                    *((void *)v180 + 52) = 0;
                    *((void *)v180 + 53) = 0;
                    *((void *)v180 + 54) = 0;
                    __n128 v233 = *(__n128 *)(v180 + 440);
                    unint64_t v234 = *((void *)v180 + 57);
                    *((void *)v180 + 55) = 0;
                    *((void *)v180 + 56) = 0;
                    *((void *)v180 + 57) = 0;
                    uint64_t v151 = (__n128 *)v146;
                    LOBYTE(v152) = *v180;
                    do
                    {
                      uint64_t v153 = v151;
                      v151[-14].n128_u8[0] = v152;
                      v151[-14].n128_u8[8] = v151[-28].n128_u8[0];
                      sub_10005CBB4((uint64_t *)&v151[-13]);
                      v151[-13] = *(__n128 *)((char *)v151 - 440);
                      v151[-12].n128_u64[0] = v151[-27].n128_u64[1];
                      v151[-27].n128_u64[1] = 0;
                      v151[-27].n128_u64[0] = 0;
                      v151[-28].n128_u64[1] = 0;
                      sub_10005CBB4(&v151[-12].n128_i64[1]);
                      *(__n128 *)((char *)v151 - 184) = v151[-26];
                      v151[-11].n128_u64[1] = v151[-25].n128_u64[0];
                      v151[-25].n128_u64[0] = 0;
                      v151[-26].n128_u64[1] = 0;
                      v151[-26].n128_u64[0] = 0;
                      sub_10005C9A4((uint64_t)&v151[-10], (__n128 *)((char *)v151 - 392));
                      sub_10005C9A4((uint64_t)&v151[-9].n128_i64[1], v151 - 23);
                      sub_10005C9A4((uint64_t)&v151[-7], (__n128 *)((char *)v151 - 344));
                      sub_10005C9A4((uint64_t)&v151[-6].n128_i64[1], v151 - 20);
                      sub_10005CBB4((uint64_t *)&v151[-4]);
                      v151[-4] = *(__n128 *)((char *)v151 - 296);
                      v151[-3].n128_u64[0] = v151[-18].n128_u64[1];
                      v151[-18].n128_u64[1] = 0;
                      v151[-18].n128_u64[0] = 0;
                      v151[-19].n128_u64[1] = 0;
                      sub_10005C9A4((uint64_t)&v151[-3].n128_i64[1], v151 - 17);
                      sub_1011499B8((void **)&v151[-1]);
                      v151[-1] = *(__n128 *)((char *)v151 - 248);
                      unint64_t v154 = v151[-15].n128_u64[1];
                      uint64_t v151 = (__n128 *)((char *)v151 - 232);
                      v153->n128_u64[0] = v154;
                      v153[-16].n128_u64[1] = 0;
                      v153[-15].n128_u64[0] = 0;
                      v151->n128_u64[0] = 0;
                      unsigned int v152 = v153[-43].n128_u8[0];
                    }
                    while (v216 < v152);
                    v151[-14].n128_u8[0] = v216;
                    v151[-14].n128_u8[8] = v217;
                    sub_10005CBB4((uint64_t *)&v151[-13]);
                    v151[-13] = *(__n128 *)v218;
                    v151[-12].n128_u64[0] = *(void *)&v218[16];
                    memset(v218, 0, sizeof(v218));
                    sub_10005CBB4(&v151[-12].n128_i64[1]);
                    *(__n128 *)((char *)v151 - 184) = v219;
                    v151[-11].n128_u64[1] = v220;
                    __n128 v219 = 0uLL;
                    unint64_t v220 = 0;
                    uint64_t v155 = (void *)v151[-10].n128_u64[0];
                    if (v155)
                    {
                      v151[-10].n128_u64[1] = (unint64_t)v155;
                      operator delete(v155);
                      v151[-10].n128_u64[0] = 0;
                      v151[-10].n128_u64[1] = 0;
                      v151[-9].n128_u64[0] = 0;
                    }
                    v151[-10] = v221;
                    v151[-9].n128_u64[0] = v222;
                    __n128 v221 = 0uLL;
                    unint64_t v222 = 0;
                    uint64_t v156 = (void *)v151[-9].n128_u64[1];
                    if (v156)
                    {
                      v151[-8].n128_u64[0] = (unint64_t)v156;
                      operator delete(v156);
                      v151[-9].n128_u64[1] = 0;
                      v151[-8].n128_u64[0] = 0;
                      v151[-8].n128_u64[1] = 0;
                    }
                    *(__n128 *)((char *)v151 - 136) = v223;
                    v151[-8].n128_u64[1] = v224;
                    __n128 v223 = 0uLL;
                    unint64_t v224 = 0;
                    uint64_t v157 = (void *)v151[-7].n128_u64[0];
                    if (v157)
                    {
                      v151[-7].n128_u64[1] = (unint64_t)v157;
                      operator delete(v157);
                      v151[-7].n128_u64[0] = 0;
                      v151[-7].n128_u64[1] = 0;
                      v151[-6].n128_u64[0] = 0;
                    }
                    v151[-7] = v225;
                    v151[-6].n128_u64[0] = v226;
                    __n128 v225 = 0uLL;
                    unint64_t v226 = 0;
                    uint64_t v158 = (void *)v151[-6].n128_u64[1];
                    if (v158)
                    {
                      v151[-5].n128_u64[0] = (unint64_t)v158;
                      operator delete(v158);
                      v151[-6].n128_u64[1] = 0;
                      v151[-5].n128_u64[0] = 0;
                      v151[-5].n128_u64[1] = 0;
                    }
                    *(__n128 *)((char *)v151 - 88) = v227;
                    v151[-5].n128_u64[1] = v228;
                    __n128 v227 = 0uLL;
                    unint64_t v228 = 0;
                    sub_10005CBB4((uint64_t *)&v151[-4]);
                    v151[-4] = v229;
                    v151[-3].n128_u64[0] = v230;
                    __n128 v229 = 0uLL;
                    unint64_t v230 = 0;
                    int64_t v159 = (void *)v151[-3].n128_u64[1];
                    if (v159)
                    {
                      v151[-2].n128_u64[0] = (unint64_t)v159;
                      operator delete(v159);
                      v151[-3].n128_u64[1] = 0;
                      v151[-2].n128_u64[0] = 0;
                      v151[-2].n128_u64[1] = 0;
                    }
                    *(__n128 *)((char *)v151 - 40) = v231;
                    v151[-2].n128_u64[1] = v232;
                    __n128 v231 = 0uLL;
                    unint64_t v232 = 0;
                    sub_1011499B8((void **)&v151[-1]);
                    v151[-1] = v233;
                    v151->n128_u64[0] = v234;
                    __n128 v233 = 0uLL;
                    unint64_t v234 = 0;
                    long long v195 = &v233;
                    sub_1011477A4((void ***)&v195);
                    BOOL result = sub_101149F54((uint64_t)&v217);
                  }
                  __int16 v145 = v147 + 232;
                  v146 += 232;
                  v180 = v147;
                }
                while (v147 + 232 != a2);
              }
            }
            return result;
          }
          if (!a3)
          {
            if (v8 != v7)
            {
              unint64_t v160 = v7 - v8;
              int64_t v183 = (v190 - 2) >> 1;
              int64_t v91 = v183;
              do
              {
                int64_t v92 = v91;
                if (v183 >= v91)
                {
                  uint64_t v93 = (2 * v91) | 1;
                  int64_t v94 = &v180[232 * v93];
                  if (2 * v92 + 2 >= (uint64_t)v190)
                  {
                    unsigned int v95 = *v94;
                  }
                  else
                  {
                    unsigned int v95 = *v94;
                    unsigned int v96 = v94[232];
                    BOOL v97 = v95 >= v96;
                    if (v95 <= v96) {
                      unsigned int v95 = v94[232];
                    }
                    if (!v97)
                    {
                      v94 += 232;
                      uint64_t v93 = 2 * v92 + 2;
                    }
                  }
                  long long v98 = &v180[232 * v92];
                  unsigned int v99 = *v98;
                  if (v95 >= v99)
                  {
                    int64_t v188 = v93;
                    uint64_t v217 = 0;
                    unint64_t v216 = v99;
                    int64_t v173 = v92;
                    size_t v100 = &v180[232 * v92];
                    LOBYTE(v217) = v100[8];
                    *(_OWORD *)long long v218 = *((_OWORD *)v100 + 1);
                    *(void *)&v218[16] = *((void *)v100 + 4);
                    *((void *)v100 + 2) = 0;
                    *((void *)v100 + 3) = 0;
                    *((void *)v100 + 4) = 0;
                    __n128 v219 = *(__n128 *)(v100 + 40);
                    unint64_t v220 = *((void *)v100 + 7);
                    *((void *)v100 + 5) = 0;
                    *((void *)v100 + 6) = 0;
                    *((void *)v100 + 7) = 0;
                    __n128 v221 = *((__n128 *)v100 + 4);
                    unint64_t v222 = *((void *)v100 + 10);
                    *((void *)v100 + 8) = 0;
                    *((void *)v100 + 9) = 0;
                    *((void *)v100 + 10) = 0;
                    __n128 v223 = *(__n128 *)(v100 + 88);
                    unint64_t v224 = *((void *)v100 + 13);
                    *((void *)v100 + 11) = 0;
                    *((void *)v100 + 12) = 0;
                    *((void *)v100 + 13) = 0;
                    __n128 v225 = *((__n128 *)v100 + 7);
                    unint64_t v226 = *((void *)v100 + 16);
                    *((void *)v100 + 14) = 0;
                    *((void *)v100 + 15) = 0;
                    *((void *)v100 + 16) = 0;
                    __n128 v227 = *(__n128 *)(v100 + 136);
                    unint64_t v228 = *((void *)v100 + 19);
                    *((void *)v100 + 17) = 0;
                    *((void *)v100 + 18) = 0;
                    *((void *)v100 + 19) = 0;
                    __n128 v229 = *((__n128 *)v100 + 10);
                    unint64_t v230 = *((void *)v100 + 22);
                    *((void *)v100 + 20) = 0;
                    *((void *)v100 + 21) = 0;
                    *((void *)v100 + 22) = 0;
                    __n128 v231 = *(__n128 *)(v100 + 184);
                    unint64_t v232 = *((void *)v100 + 25);
                    *((void *)v100 + 23) = 0;
                    *((void *)v100 + 24) = 0;
                    *((void *)v100 + 25) = 0;
                    __n128 v233 = *((__n128 *)v100 + 13);
                    unint64_t v234 = *((void *)v100 + 28);
                    *((void *)v100 + 26) = 0;
                    *((void *)v100 + 27) = 0;
                    *((void *)v100 + 28) = 0;
                    LOBYTE(v100) = *v94;
                    while (1)
                    {
                      uint64_t v101 = v94;
                      *long long v98 = v100;
                      v98[8] = v94[8];
                      sub_10005CBB4((uint64_t *)v98 + 2);
                      *((_OWORD *)v98 + 1) = *((_OWORD *)v101 + 1);
                      *((void *)v98 + 4) = *((void *)v101 + 4);
                      *((void *)v101 + 2) = 0;
                      *((void *)v101 + 3) = 0;
                      *((void *)v101 + 4) = 0;
                      sub_10005CBB4((uint64_t *)v98 + 5);
                      *(_OWORD *)(v98 + 40) = *(_OWORD *)(v101 + 40);
                      *((void *)v98 + 7) = *((void *)v101 + 7);
                      *((void *)v101 + 5) = 0;
                      *((void *)v101 + 6) = 0;
                      *((void *)v101 + 7) = 0;
                      sub_10005C9A4((uint64_t)(v98 + 64), (__n128 *)v101 + 4);
                      sub_10005C9A4((uint64_t)(v98 + 88), (__n128 *)(v101 + 88));
                      sub_10005C9A4((uint64_t)(v98 + 112), (__n128 *)v101 + 7);
                      sub_10005C9A4((uint64_t)(v98 + 136), (__n128 *)(v101 + 136));
                      sub_10005CBB4((uint64_t *)v98 + 20);
                      *((_OWORD *)v98 + 10) = *((_OWORD *)v101 + 10);
                      *((void *)v98 + 22) = *((void *)v101 + 22);
                      *((void *)v101 + 20) = 0;
                      *((void *)v101 + 21) = 0;
                      *((void *)v101 + 22) = 0;
                      sub_10005C9A4((uint64_t)(v98 + 184), (__n128 *)(v101 + 184));
                      sub_1011499B8((void **)v98 + 26);
                      *((_OWORD *)v98 + 13) = *((_OWORD *)v101 + 13);
                      *((void *)v98 + 28) = *((void *)v101 + 28);
                      *((void *)v101 + 26) = 0;
                      *((void *)v101 + 27) = 0;
                      *((void *)v101 + 28) = 0;
                      if (v183 < v188) {
                        break;
                      }
                      uint64_t v102 = (2 * v188) | 1;
                      int64_t v94 = &v180[232 * v102];
                      if (2 * v188 + 2 >= (uint64_t)v190)
                      {
                        LODWORD(v100) = *v94;
                      }
                      else
                      {
                        LODWORD(v100) = *v94;
                        unsigned int v103 = v94[232];
                        BOOL v104 = v100 >= v103;
                        if (v100 <= v103) {
                          LODWORD(v100) = v94[232];
                        }
                        if (!v104)
                        {
                          v94 += 232;
                          uint64_t v102 = 2 * v188 + 2;
                        }
                      }
                      int64_t v188 = v102;
                      unsigned __int8 v105 = v216;
                      long long v98 = v101;
                      if (v100 < v216) {
                        goto LABEL_134;
                      }
                    }
                    unsigned __int8 v105 = v216;
LABEL_134:
                    unsigned __int8 *v101 = v105;
                    v101[8] = v217;
                    sub_10005CBB4((uint64_t *)v101 + 2);
                    *((_OWORD *)v101 + 1) = *(_OWORD *)v218;
                    *((void *)v101 + 4) = *(void *)&v218[16];
                    memset(v218, 0, sizeof(v218));
                    sub_10005CBB4((uint64_t *)v101 + 5);
                    *(__n128 *)(v101 + 40) = v219;
                    *((void *)v101 + 7) = v220;
                    __n128 v219 = 0uLL;
                    unint64_t v220 = 0;
                    uint64_t v106 = (void *)*((void *)v101 + 8);
                    if (v106)
                    {
                      *((void *)v101 + 9) = v106;
                      operator delete(v106);
                      *((void *)v101 + 8) = 0;
                      *((void *)v101 + 9) = 0;
                      *((void *)v101 + 10) = 0;
                    }
                    *((__n128 *)v101 + 4) = v221;
                    *((void *)v101 + 10) = v222;
                    __n128 v221 = 0uLL;
                    unint64_t v222 = 0;
                    long long v107 = (void *)*((void *)v101 + 11);
                    if (v107)
                    {
                      *((void *)v101 + 12) = v107;
                      operator delete(v107);
                      *((void *)v101 + 11) = 0;
                      *((void *)v101 + 12) = 0;
                      *((void *)v101 + 13) = 0;
                    }
                    *(__n128 *)(v101 + 88) = v223;
                    *((void *)v101 + 13) = v224;
                    __n128 v223 = 0uLL;
                    unint64_t v224 = 0;
                    unint64_t v108 = (void *)*((void *)v101 + 14);
                    if (v108)
                    {
                      *((void *)v101 + 15) = v108;
                      operator delete(v108);
                      *((void *)v101 + 14) = 0;
                      *((void *)v101 + 15) = 0;
                      *((void *)v101 + 16) = 0;
                    }
                    *((__n128 *)v101 + 7) = v225;
                    *((void *)v101 + 16) = v226;
                    __n128 v225 = 0uLL;
                    unint64_t v226 = 0;
                    __int16 v109 = (void *)*((void *)v101 + 17);
                    if (v109)
                    {
                      *((void *)v101 + 18) = v109;
                      operator delete(v109);
                      *((void *)v101 + 17) = 0;
                      *((void *)v101 + 18) = 0;
                      *((void *)v101 + 19) = 0;
                    }
                    *(__n128 *)(v101 + 136) = v227;
                    *((void *)v101 + 19) = v228;
                    __n128 v227 = 0uLL;
                    unint64_t v228 = 0;
                    sub_10005CBB4((uint64_t *)v101 + 20);
                    *((__n128 *)v101 + 10) = v229;
                    *((void *)v101 + 22) = v230;
                    __n128 v229 = 0uLL;
                    unint64_t v230 = 0;
                    int v110 = (void *)*((void *)v101 + 23);
                    if (v110)
                    {
                      *((void *)v101 + 24) = v110;
                      operator delete(v110);
                      *((void *)v101 + 23) = 0;
                      *((void *)v101 + 24) = 0;
                      *((void *)v101 + 25) = 0;
                    }
                    *(__n128 *)(v101 + 184) = v231;
                    *((void *)v101 + 25) = v232;
                    __n128 v231 = 0uLL;
                    unint64_t v232 = 0;
                    sub_1011499B8((void **)v101 + 26);
                    *((__n128 *)v101 + 13) = v233;
                    *((void *)v101 + 28) = v234;
                    __n128 v233 = 0uLL;
                    unint64_t v234 = 0;
                    long long v195 = &v233;
                    sub_1011477A4((void ***)&v195);
                    BOOL result = sub_101149F54((uint64_t)&v217);
                    int64_t v92 = v173;
                  }
                }
                int64_t v91 = v92 - 1;
              }
              while (v92);
              int64_t v111 = v160 / 0xE8;
              do
              {
                if (v111 >= 2)
                {
                  int64_t v112 = 0;
                  long long v195 = 0;
                  uint64_t v196 = 0;
                  __int16 v113 = v180;
                  LOBYTE(v195) = *v180;
                  LOBYTE(v196) = v180[8];
                  long long v197 = *((_OWORD *)v180 + 1);
                  uint64_t v198 = *((void *)v180 + 4);
                  *((void *)v180 + 3) = 0;
                  *((void *)v180 + 4) = 0;
                  *((void *)v180 + 2) = 0;
                  long long v199 = *(_OWORD *)(v180 + 40);
                  uint64_t v200 = *((void *)v180 + 7);
                  *((void *)v180 + 6) = 0;
                  *((void *)v180 + 7) = 0;
                  *((void *)v180 + 5) = 0;
                  long long v201 = *((_OWORD *)v180 + 4);
                  uint64_t v202 = *((void *)v180 + 10);
                  *((void *)v180 + 8) = 0;
                  *((void *)v180 + 9) = 0;
                  *((void *)v180 + 10) = 0;
                  long long v203 = *(_OWORD *)(v180 + 88);
                  uint64_t v204 = *((void *)v180 + 13);
                  *((void *)v180 + 11) = 0;
                  *((void *)v180 + 12) = 0;
                  *((void *)v180 + 13) = 0;
                  long long v205 = *((_OWORD *)v180 + 7);
                  uint64_t v206 = *((void *)v180 + 16);
                  *((void *)v180 + 14) = 0;
                  *((void *)v180 + 15) = 0;
                  *((void *)v180 + 16) = 0;
                  long long v207 = *(_OWORD *)(v180 + 136);
                  uint64_t v208 = *((void *)v180 + 19);
                  *((void *)v180 + 17) = 0;
                  *((void *)v180 + 18) = 0;
                  *((void *)v180 + 19) = 0;
                  long long v209 = *((_OWORD *)v180 + 10);
                  uint64_t v210 = *((void *)v180 + 22);
                  *((void *)v180 + 20) = 0;
                  *((void *)v180 + 21) = 0;
                  *((void *)v180 + 22) = 0;
                  long long v211 = *(_OWORD *)(v180 + 184);
                  uint64_t v212 = *((void *)v180 + 25);
                  *((void *)v180 + 23) = 0;
                  *((void *)v180 + 24) = 0;
                  *((void *)v180 + 25) = 0;
                  long long v213 = *((_OWORD *)v180 + 13);
                  uint64_t v214 = *((void *)v180 + 28);
                  *((void *)v180 + 26) = 0;
                  *((void *)v180 + 27) = 0;
                  int64_t v184 = (unint64_t)(v111 - 2) >> 1;
                  int64_t v189 = v111;
                  *((void *)v180 + 28) = 0;
                  do
                  {
                    unint64_t v114 = &v113[232 * v112 + 232];
                    uint64_t v115 = (2 * v112) | 1;
                    uint64_t v116 = 2 * v112 + 2;
                    if (v116 >= v111)
                    {
                      LOBYTE(v117) = *v114;
                    }
                    else
                    {
                      unsigned int v117 = *v114;
                      unsigned int v118 = v113[232 * v112 + 464];
                      BOOL v119 = v117 >= v118;
                      if (v117 <= v118) {
                        LOBYTE(v117) = v118;
                      }
                      if (!v119)
                      {
                        v114 += 232;
                        uint64_t v115 = v116;
                      }
                    }
                    int64_t v193 = v115;
                    *__int16 v113 = v117;
                    v113[8] = v114[8];
                    sub_10005CBB4((uint64_t *)v113 + 2);
                    *((_OWORD *)v113 + 1) = *((_OWORD *)v114 + 1);
                    *((void *)v113 + 4) = *((void *)v114 + 4);
                    *((void *)v114 + 2) = 0;
                    *((void *)v114 + 3) = 0;
                    *((void *)v114 + 4) = 0;
                    sub_10005CBB4((uint64_t *)v113 + 5);
                    *(_OWORD *)(v113 + 40) = *(_OWORD *)(v114 + 40);
                    *((void *)v113 + 7) = *((void *)v114 + 7);
                    *((void *)v114 + 5) = 0;
                    *((void *)v114 + 6) = 0;
                    *((void *)v114 + 7) = 0;
                    sub_10005C9A4((uint64_t)(v113 + 64), (__n128 *)v114 + 4);
                    __int16 v120 = v114 + 88;
                    sub_10005C9A4((uint64_t)(v113 + 88), (__n128 *)(v114 + 88));
                    sub_10005C9A4((uint64_t)(v113 + 112), (__n128 *)v114 + 7);
                    sub_10005C9A4((uint64_t)(v113 + 136), (__n128 *)(v114 + 136));
                    sub_10005CBB4((uint64_t *)v113 + 20);
                    *((_OWORD *)v113 + 10) = *((_OWORD *)v114 + 10);
                    *((void *)v113 + 22) = *((void *)v114 + 22);
                    *((void *)v114 + 20) = 0;
                    *((void *)v114 + 21) = 0;
                    *((void *)v114 + 22) = 0;
                    sub_10005C9A4((uint64_t)(v113 + 184), (__n128 *)(v114 + 184));
                    sub_1011499B8((void **)v113 + 26);
                    *((_OWORD *)v113 + 13) = *((_OWORD *)v114 + 13);
                    *((void *)v113 + 28) = *((void *)v114 + 28);
                    *((void *)v114 + 26) = 0;
                    *((void *)v114 + 27) = 0;
                    *((void *)v114 + 28) = 0;
                    __int16 v113 = v114;
                    int64_t v111 = v189;
                    int64_t v112 = v193;
                  }
                  while (v193 <= v184);
                  v170 = v114 + 64;
                  xpc_object_t v174 = v114 + 112;
                  v185 = (uint64_t *)(v114 + 160);
                  xpc_object_t v177 = v114 + 136;
                  long long v194 = v114 + 184;
                  long long v167 = (void **)(v114 + 208);
                  if (v114 == a2 - 232)
                  {
                    *unint64_t v114 = v195;
                    v114[8] = v196;
                    sub_10005CBB4((uint64_t *)v114 + 2);
                    *((_OWORD *)v114 + 1) = v197;
                    *((void *)v114 + 4) = v198;
                    long long v197 = 0uLL;
                    uint64_t v198 = 0;
                    sub_10005CBB4((uint64_t *)v114 + 5);
                    *(_OWORD *)(v114 + 40) = v199;
                    *((void *)v114 + 7) = v200;
                    long long v199 = 0uLL;
                    uint64_t v200 = 0;
                    uint64_t v139 = (void *)*((void *)v114 + 8);
                    if (v139)
                    {
                      *((void *)v114 + 9) = v139;
                      operator delete(v139);
                      void *v170 = 0;
                      *((void *)v114 + 9) = 0;
                      *((void *)v114 + 10) = 0;
                    }
                    *((_OWORD *)v114 + 4) = v201;
                    *((void *)v114 + 10) = v202;
                    long long v201 = 0uLL;
                    uint64_t v202 = 0;
                    __int16 v140 = (void *)*((void *)v114 + 11);
                    if (v140)
                    {
                      *((void *)v114 + 12) = v140;
                      operator delete(v140);
                      *__int16 v120 = 0;
                      *((void *)v114 + 12) = 0;
                      *((void *)v114 + 13) = 0;
                    }
                    *(_OWORD *)(v114 + 88) = v203;
                    *((void *)v114 + 13) = v204;
                    long long v203 = 0uLL;
                    uint64_t v204 = 0;
                    int v141 = (void *)*((void *)v114 + 14);
                    if (v141)
                    {
                      *((void *)v114 + 15) = v141;
                      operator delete(v141);
                      *xpc_object_t v174 = 0;
                      *((void *)v114 + 15) = 0;
                      *((void *)v114 + 16) = 0;
                    }
                    *((_OWORD *)v114 + 7) = v205;
                    *((void *)v114 + 16) = v206;
                    long long v205 = 0uLL;
                    uint64_t v206 = 0;
                    long long v142 = (void *)*((void *)v114 + 17);
                    if (v142)
                    {
                      *((void *)v114 + 18) = v142;
                      operator delete(v142);
                      void *v177 = 0;
                      *((void *)v114 + 18) = 0;
                      *((void *)v114 + 19) = 0;
                    }
                    *(_OWORD *)(v114 + 136) = v207;
                    *((void *)v114 + 19) = v208;
                    long long v207 = 0uLL;
                    uint64_t v208 = 0;
                    sub_10005CBB4(v185);
                    *((_OWORD *)v114 + 10) = v209;
                    *((void *)v114 + 22) = v210;
                    long long v209 = 0uLL;
                    uint64_t v210 = 0;
                    uint64_t v143 = (void *)*((void *)v114 + 23);
                    if (v143)
                    {
                      *((void *)v114 + 24) = v143;
                      operator delete(v143);
                      *long long v194 = 0;
                      *((void *)v114 + 24) = 0;
                      *((void *)v114 + 25) = 0;
                    }
                    *(_OWORD *)(v114 + 184) = v211;
                    *((void *)v114 + 25) = v212;
                    long long v211 = 0uLL;
                    uint64_t v212 = 0;
                    sub_1011499B8(v167);
                    *((_OWORD *)v114 + 13) = v213;
                    *((void *)v114 + 28) = v214;
                    long long v213 = 0uLL;
                    uint64_t v214 = 0;
                  }
                  else
                  {
                    *unint64_t v114 = *(a2 - 232);
                    v114[8] = *(a2 - 224);
                    sub_10005CBB4((uint64_t *)v114 + 2);
                    *((_OWORD *)v114 + 1) = *(_OWORD *)(a2 - 216);
                    *((void *)v114 + 4) = *((void *)a2 - 25);
                    *((void *)a2 - 27) = 0;
                    *((void *)a2 - 26) = 0;
                    *((void *)a2 - 25) = 0;
                    sub_10005CBB4((uint64_t *)v114 + 5);
                    *(_OWORD *)(v114 + 40) = *((_OWORD *)a2 - 12);
                    *((void *)v114 + 7) = *((void *)a2 - 22);
                    *((void *)a2 - 24) = 0;
                    *((void *)a2 - 23) = 0;
                    *((void *)a2 - 22) = 0;
                    sub_10005C9A4((uint64_t)v170, (__n128 *)(a2 - 168));
                    sub_10005C9A4((uint64_t)(v114 + 88), (__n128 *)a2 - 9);
                    sub_10005C9A4((uint64_t)v174, (__n128 *)(a2 - 120));
                    sub_10005C9A4((uint64_t)v177, (__n128 *)a2 - 6);
                    sub_10005CBB4(v185);
                    *((_OWORD *)v114 + 10) = *(_OWORD *)(a2 - 72);
                    *((void *)v114 + 22) = *((void *)a2 - 7);
                    *((void *)a2 - 9) = 0;
                    *((void *)a2 - 8) = 0;
                    *((void *)a2 - 7) = 0;
                    sub_10005C9A4((uint64_t)v194, (__n128 *)a2 - 3);
                    sub_1011499B8((void **)v114 + 26);
                    int v121 = a2 - 24;
                    *((_OWORD *)v114 + 13) = *(_OWORD *)(a2 - 24);
                    *((void *)v114 + 28) = *((void *)a2 - 1);
                    *(void *)int v121 = 0;
                    *((void *)v121 + 1) = 0;
                    *((void *)v121 + 2) = 0;
                    *(a2 - 232) = v195;
                    *(a2 - 224) = v196;
                    sub_10005CBB4((uint64_t *)a2 - 27);
                    *(_OWORD *)(a2 - 216) = v197;
                    *((void *)a2 - 25) = v198;
                    long long v197 = 0uLL;
                    uint64_t v198 = 0;
                    sub_10005CBB4((uint64_t *)a2 - 24);
                    *((_OWORD *)a2 - 12) = v199;
                    *((void *)a2 - 22) = v200;
                    long long v199 = 0uLL;
                    uint64_t v200 = 0;
                    long long v122 = (void *)*((void *)a2 - 21);
                    if (v122)
                    {
                      *((void *)a2 - 20) = v122;
                      operator delete(v122);
                    }
                    *(_OWORD *)(a2 - 168) = v201;
                    *((void *)a2 - 19) = v202;
                    long long v201 = 0uLL;
                    uint64_t v202 = 0;
                    unsigned int v123 = (void *)*((void *)a2 - 18);
                    if (v123)
                    {
                      *((void *)a2 - 17) = v123;
                      operator delete(v123);
                    }
                    *((_OWORD *)a2 - 9) = v203;
                    *((void *)a2 - 16) = v204;
                    long long v203 = 0uLL;
                    uint64_t v204 = 0;
                    int64_t v124 = (void *)*((void *)a2 - 15);
                    if (v124)
                    {
                      *((void *)a2 - 14) = v124;
                      operator delete(v124);
                    }
                    *(_OWORD *)(a2 - 120) = v205;
                    *((void *)a2 - 13) = v206;
                    long long v205 = 0uLL;
                    uint64_t v206 = 0;
                    __int16 v125 = (void *)*((void *)a2 - 12);
                    if (v125)
                    {
                      *((void *)a2 - 11) = v125;
                      operator delete(v125);
                    }
                    *((_OWORD *)a2 - 6) = v207;
                    *((void *)a2 - 10) = v208;
                    long long v207 = 0uLL;
                    uint64_t v208 = 0;
                    sub_10005CBB4((uint64_t *)a2 - 9);
                    *(_OWORD *)(a2 - 72) = v209;
                    *((void *)a2 - 7) = v210;
                    long long v209 = 0uLL;
                    uint64_t v210 = 0;
                    int v126 = (void *)*((void *)a2 - 6);
                    if (v126)
                    {
                      *((void *)a2 - 5) = v126;
                      operator delete(v126);
                    }
                    *((_OWORD *)a2 - 3) = v211;
                    *((void *)a2 - 4) = v212;
                    long long v211 = 0uLL;
                    uint64_t v212 = 0;
                    sub_1011499B8((void **)a2 - 3);
                    *(_OWORD *)(a2 - 24) = v213;
                    *((void *)a2 - 1) = v214;
                    long long v213 = 0uLL;
                    uint64_t v214 = 0;
                    uint64_t v127 = v114 + 232 - v180;
                    if (v127 >= 233)
                    {
                      unint64_t v128 = (v127 / 0xE8uLL - 2) >> 1;
                      uint64_t v129 = &v180[232 * v128];
                      unsigned int v130 = *v114;
                      if (*v129 < v130)
                      {
                        uint64_t v217 = 0;
                        unint64_t v216 = v130;
                        LOBYTE(v217) = v114[8];
                        *(_OWORD *)long long v218 = *((_OWORD *)v114 + 1);
                        *(void *)&v218[16] = *((void *)v114 + 4);
                        *((void *)v114 + 2) = 0;
                        *((void *)v114 + 3) = 0;
                        *((void *)v114 + 4) = 0;
                        __n128 v219 = *(__n128 *)(v114 + 40);
                        unint64_t v220 = *((void *)v114 + 7);
                        *((void *)v114 + 5) = 0;
                        *((void *)v114 + 6) = 0;
                        *((void *)v114 + 7) = 0;
                        __n128 v221 = *((__n128 *)v114 + 4);
                        unint64_t v222 = *((void *)v114 + 10);
                        void *v170 = 0;
                        *((void *)v114 + 9) = 0;
                        *((void *)v114 + 10) = 0;
                        __n128 v223 = *(__n128 *)(v114 + 88);
                        unint64_t v224 = *((void *)v114 + 13);
                        *__int16 v120 = 0;
                        *((void *)v114 + 12) = 0;
                        *((void *)v114 + 13) = 0;
                        __n128 v225 = *((__n128 *)v114 + 7);
                        unint64_t v226 = *((void *)v114 + 16);
                        *xpc_object_t v174 = 0;
                        *((void *)v114 + 15) = 0;
                        *((void *)v114 + 16) = 0;
                        __n128 v227 = *(__n128 *)(v114 + 136);
                        unint64_t v228 = *((void *)v114 + 19);
                        void *v177 = 0;
                        *((void *)v114 + 18) = 0;
                        *((void *)v114 + 19) = 0;
                        __n128 v229 = *((__n128 *)v114 + 10);
                        unint64_t v230 = *((void *)v114 + 22);
                        uint64_t *v185 = 0;
                        *((void *)v114 + 21) = 0;
                        *((void *)v114 + 22) = 0;
                        __n128 v231 = *(__n128 *)(v114 + 184);
                        unint64_t v232 = *((void *)v114 + 25);
                        *long long v194 = 0;
                        *((void *)v114 + 24) = 0;
                        *((void *)v114 + 25) = 0;
                        unint64_t v131 = v128;
                        __n128 v233 = *((__n128 *)v114 + 13);
                        unint64_t v234 = *((void *)v114 + 28);
                        *long long v167 = 0;
                        *((void *)v114 + 27) = 0;
                        *((void *)v114 + 28) = 0;
                        LOBYTE(v132) = *v129;
                        do
                        {
                          int v133 = v129;
                          *unint64_t v114 = v132;
                          v114[8] = v129[8];
                          sub_10005CBB4((uint64_t *)v114 + 2);
                          *((_OWORD *)v114 + 1) = *((_OWORD *)v133 + 1);
                          *((void *)v114 + 4) = *((void *)v133 + 4);
                          *((void *)v133 + 2) = 0;
                          *((void *)v133 + 3) = 0;
                          *((void *)v133 + 4) = 0;
                          sub_10005CBB4((uint64_t *)v114 + 5);
                          *(_OWORD *)(v114 + 40) = *(_OWORD *)(v133 + 40);
                          *((void *)v114 + 7) = *((void *)v133 + 7);
                          *((void *)v133 + 5) = 0;
                          *((void *)v133 + 6) = 0;
                          *((void *)v133 + 7) = 0;
                          sub_10005C9A4((uint64_t)(v114 + 64), (__n128 *)v133 + 4);
                          sub_10005C9A4((uint64_t)(v114 + 88), (__n128 *)(v133 + 88));
                          sub_10005C9A4((uint64_t)(v114 + 112), (__n128 *)v133 + 7);
                          sub_10005C9A4((uint64_t)(v114 + 136), (__n128 *)(v133 + 136));
                          sub_10005CBB4((uint64_t *)v114 + 20);
                          *((_OWORD *)v114 + 10) = *((_OWORD *)v133 + 10);
                          *((void *)v114 + 22) = *((void *)v133 + 22);
                          *((void *)v133 + 20) = 0;
                          *((void *)v133 + 21) = 0;
                          *((void *)v133 + 22) = 0;
                          sub_10005C9A4((uint64_t)(v114 + 184), (__n128 *)(v133 + 184));
                          sub_1011499B8((void **)v114 + 26);
                          *((_OWORD *)v114 + 13) = *((_OWORD *)v133 + 13);
                          *((void *)v114 + 28) = *((void *)v133 + 28);
                          *((void *)v133 + 26) = 0;
                          *((void *)v133 + 27) = 0;
                          *((void *)v133 + 28) = 0;
                          if (!v131) {
                            break;
                          }
                          unint64_t v131 = (v131 - 1) >> 1;
                          uint64_t v129 = &v180[232 * v131];
                          unsigned int v132 = *v129;
                          unint64_t v114 = v133;
                        }
                        while (v132 < v216);
                        *int v133 = v216;
                        v133[8] = v217;
                        sub_10005CBB4((uint64_t *)v133 + 2);
                        *((_OWORD *)v133 + 1) = *(_OWORD *)v218;
                        *((void *)v133 + 4) = *(void *)&v218[16];
                        memset(v218, 0, sizeof(v218));
                        sub_10005CBB4((uint64_t *)v133 + 5);
                        *(__n128 *)(v133 + 40) = v219;
                        *((void *)v133 + 7) = v220;
                        __n128 v219 = 0uLL;
                        unint64_t v220 = 0;
                        int v134 = (void *)*((void *)v133 + 8);
                        if (v134)
                        {
                          *((void *)v133 + 9) = v134;
                          operator delete(v134);
                        }
                        *((__n128 *)v133 + 4) = v221;
                        *((void *)v133 + 10) = v222;
                        __n128 v221 = 0uLL;
                        unint64_t v222 = 0;
                        long long v135 = (void *)*((void *)v133 + 11);
                        if (v135)
                        {
                          *((void *)v133 + 12) = v135;
                          operator delete(v135);
                        }
                        *(__n128 *)(v133 + 88) = v223;
                        *((void *)v133 + 13) = v224;
                        __n128 v223 = 0uLL;
                        unint64_t v224 = 0;
                        xpc_object_t v136 = (void *)*((void *)v133 + 14);
                        if (v136)
                        {
                          *((void *)v133 + 15) = v136;
                          operator delete(v136);
                        }
                        *((__n128 *)v133 + 7) = v225;
                        *((void *)v133 + 16) = v226;
                        __n128 v225 = 0uLL;
                        unint64_t v226 = 0;
                        xpc_object_t v137 = (void *)*((void *)v133 + 17);
                        if (v137)
                        {
                          *((void *)v133 + 18) = v137;
                          operator delete(v137);
                        }
                        *(__n128 *)(v133 + 136) = v227;
                        *((void *)v133 + 19) = v228;
                        __n128 v227 = 0uLL;
                        unint64_t v228 = 0;
                        sub_10005CBB4((uint64_t *)v133 + 20);
                        *((__n128 *)v133 + 10) = v229;
                        *((void *)v133 + 22) = v230;
                        __n128 v229 = 0uLL;
                        unint64_t v230 = 0;
                        unint64_t v138 = (void *)*((void *)v133 + 23);
                        if (v138)
                        {
                          *((void *)v133 + 24) = v138;
                          operator delete(v138);
                        }
                        *(__n128 *)(v133 + 184) = v231;
                        *((void *)v133 + 25) = v232;
                        __n128 v231 = 0uLL;
                        unint64_t v232 = 0;
                        sub_1011499B8((void **)v133 + 26);
                        *((__n128 *)v133 + 13) = v233;
                        *((void *)v133 + 28) = v234;
                        __n128 v233 = 0uLL;
                        unint64_t v234 = 0;
                        long long v215 = &v233;
                        sub_1011477A4((void ***)&v215);
                        sub_101149F54((uint64_t)&v217);
                      }
                    }
                  }
                  unint64_t v216 = (unint64_t)&v213;
                  sub_1011477A4((void ***)&v216);
                  BOOL result = sub_101149F54((uint64_t)&v196);
                  int64_t v111 = v189;
                }
                a2 -= 232;
              }
              while ((unint64_t)v111-- > 2);
            }
            return result;
          }
          unint64_t v10 = v190 >> 1;
          uint64_t v11 = (char *)&v8[232 * (v190 >> 1)];
          if ((unint64_t)v9 < 0x7401)
          {
            sub_10114C924((char *)&v8[232 * (v190 >> 1)], (char *)v8, v161);
          }
          else
          {
            sub_10114C924((char *)v8, (char *)&v8[232 * (v190 >> 1)], v161);
            sub_10114C924((char *)v8 + 232, (char *)&v8[232 * v10 - 232], (char *)a2 - 464);
            sub_10114C924((char *)v8 + 464, (char *)&v8[232 * v10 + 232], (char *)a2 - 696);
            sub_10114C924((char *)&v8[232 * v10 - 232], v11, (char *)&v8[232 * v10 + 232]);
            sub_10114CFB0((char *)v8, v11);
          }
          --a3;
          if ((a4 & 1) != 0 || *(v8 - 232) < *v8) {
            break;
          }
          uint64_t v217 = 0;
          unint64_t v216 = 0;
          LOBYTE(v216) = *v8;
          unsigned int v39 = v216;
          unsigned __int8 v40 = v8[8];
          LOBYTE(v217) = v40;
          unsigned int v42 = (uint64_t *)(v8 + 16);
          uint64_t v41 = *((void *)v8 + 2);
          *(void *)long long v218 = v41;
          long long v43 = *(_OWORD *)(v8 + 24);
          *(_OWORD *)&v218[8] = v43;
          *((void *)v8 + 2) = 0;
          unsigned int v44 = (uint64_t *)(v8 + 40);
          __n128 v45 = *(__n128 *)(v8 + 40);
          *((void *)v8 + 3) = 0;
          *((void *)v8 + 4) = 0;
          __n128 v219 = v45;
          unint64_t v220 = *((void *)v8 + 7);
          *((void *)v8 + 5) = 0;
          *((void *)v8 + 6) = 0;
          *((void *)v8 + 7) = 0;
          unsigned __int32 v46 = v8 + 64;
          __n128 v221 = *((__n128 *)v8 + 4);
          unint64_t v222 = *((void *)v8 + 10);
          *((void *)v8 + 8) = 0;
          __n128 v47 = v8 + 88;
          __n128 v48 = *(__n128 *)(v8 + 88);
          *((void *)v8 + 9) = 0;
          *((void *)v8 + 10) = 0;
          __n128 v223 = v48;
          unint64_t v224 = *((void *)v8 + 13);
          *((void *)v8 + 11) = 0;
          *((void *)v8 + 12) = 0;
          *((void *)v8 + 13) = 0;
          unint64_t v49 = v8 + 112;
          __n128 v225 = *((__n128 *)v8 + 7);
          unint64_t v226 = *((void *)v8 + 16);
          *((void *)v8 + 14) = 0;
          unsigned __int32 v50 = v8 + 136;
          __n128 v51 = *(__n128 *)(v8 + 136);
          *((void *)v8 + 15) = 0;
          *((void *)v8 + 16) = 0;
          __n128 v227 = v51;
          unint64_t v228 = *((void *)v8 + 19);
          *((void *)v8 + 17) = 0;
          *((void *)v8 + 18) = 0;
          *((void *)v8 + 19) = 0;
          unsigned int v52 = (uint64_t *)(v8 + 160);
          __n128 v229 = *((__n128 *)v8 + 10);
          unint64_t v230 = *((void *)v8 + 22);
          *((void *)v8 + 20) = 0;
          unsigned int v53 = v8 + 184;
          __n128 v54 = *(__n128 *)(v8 + 184);
          *((void *)v8 + 21) = 0;
          *((void *)v8 + 22) = 0;
          __n128 v231 = v54;
          unint64_t v232 = *((void *)v8 + 25);
          *((void *)v8 + 23) = 0;
          *((void *)v8 + 24) = 0;
          *((void *)v8 + 25) = 0;
          uint64_t v55 = (void **)(v8 + 208);
          __n128 v233 = *((__n128 *)v8 + 13);
          unint64_t v234 = *((void *)v8 + 28);
          *((void *)v8 + 26) = 0;
          *((void *)v8 + 27) = 0;
          *((void *)v8 + 28) = 0;
          if (v39 >= *v161)
          {
            uint64_t v57 = v8 + 232;
            do
            {
              uint64_t v8 = v57;
              if (v57 >= v7) {
                break;
              }
              v57 += 232;
            }
            while (v39 >= *v8);
          }
          else
          {
            do
            {
              unsigned int v56 = v8[232];
              v8 += 232;
            }
            while (v39 >= v56);
          }
          __int16 v58 = (char *)v7;
          if (v8 < v7)
          {
            __int16 v58 = (char *)v7;
            do
            {
              unsigned int v59 = *(v58 - 232);
              v58 -= 232;
            }
            while (v39 < v59);
          }
          uint64_t v192 = v43;
          unsigned __int8 v187 = v40;
          uint64_t v176 = (uint64_t)v47;
          uint64_t v182 = v41;
          uint64_t v169 = (uint64_t)v53;
          uint64_t v172 = (uint64_t)v49;
          uint64_t v166 = (uint64_t)v50;
          uint64_t v60 = (uint64_t)v46;
          while (v8 < (unsigned __int8 *)v58)
          {
            sub_10114CFB0((char *)v8, v58);
            do
            {
              unsigned int v61 = v8[232];
              v8 += 232;
            }
            while (v39 >= v61);
            do
            {
              unsigned int v62 = *(v58 - 232);
              v58 -= 232;
            }
            while (v39 < v62);
          }
          if (v8 - 232 != v180)
          {
            unsigned __int8 *v180 = *(v8 - 232);
            v180[8] = *(v8 - 224);
            sub_10005CBB4(v42);
            *((_OWORD *)v180 + 1) = *(_OWORD *)(v8 - 216);
            *((void *)v180 + 4) = *((void *)v8 - 25);
            *((void *)v8 - 27) = 0;
            *((void *)v8 - 26) = 0;
            *((void *)v8 - 25) = 0;
            sub_10005CBB4(v44);
            *(_OWORD *)(v180 + 40) = *((_OWORD *)v8 - 12);
            *((void *)v180 + 7) = *((void *)v8 - 22);
            *((void *)v8 - 24) = 0;
            *((void *)v8 - 23) = 0;
            *((void *)v8 - 22) = 0;
            sub_10005C9A4(v60, (__n128 *)(v8 - 168));
            sub_10005C9A4(v176, (__n128 *)v8 - 9);
            sub_10005C9A4(v172, (__n128 *)(v8 - 120));
            sub_10005C9A4(v166, (__n128 *)v8 - 6);
            sub_10005CBB4(v52);
            *((_OWORD *)v180 + 10) = *(_OWORD *)(v8 - 72);
            *((void *)v180 + 22) = *((void *)v8 - 7);
            *((void *)v8 - 9) = 0;
            *((void *)v8 - 8) = 0;
            *((void *)v8 - 7) = 0;
            sub_10005C9A4(v169, (__n128 *)v8 - 3);
            sub_1011499B8(v55);
            *((_OWORD *)v180 + 13) = *(_OWORD *)(v8 - 24);
            *((void *)v180 + 28) = *((void *)v8 - 1);
            *((void *)v8 - 3) = 0;
            *((void *)v8 - 2) = 0;
            *((void *)v8 - 1) = 0;
          }
          *(v8 - 232) = v39;
          *(v8 - 224) = v187;
          sub_10005CBB4((uint64_t *)v8 - 27);
          *((void *)v8 - 27) = v182;
          *((void *)v8 - 26) = v192;
          *((void *)v8 - 25) = *(void *)&v218[16];
          memset(v218, 0, sizeof(v218));
          sub_10005CBB4((uint64_t *)v8 - 24);
          *((__n128 *)v8 - 12) = v219;
          *((void *)v8 - 22) = v220;
          __n128 v219 = 0uLL;
          unint64_t v220 = 0;
          uint64_t v63 = (void *)*((void *)v8 - 21);
          if (v63)
          {
            *((void *)v8 - 20) = v63;
            operator delete(v63);
            *((void *)v8 - 21) = 0;
            *((void *)v8 - 20) = 0;
            *((void *)v8 - 19) = 0;
          }
          *(__n128 *)(v8 - 168) = v221;
          *((void *)v8 - 19) = v222;
          __n128 v221 = 0uLL;
          unint64_t v222 = 0;
          __int16 v64 = (void *)*((void *)v8 - 18);
          if (v64)
          {
            *((void *)v8 - 17) = v64;
            operator delete(v64);
            *((void *)v8 - 18) = 0;
            *((void *)v8 - 17) = 0;
            *((void *)v8 - 16) = 0;
          }
          *((__n128 *)v8 - 9) = v223;
          *((void *)v8 - 16) = v224;
          __n128 v223 = 0uLL;
          unint64_t v224 = 0;
          unint64_t v65 = (void *)*((void *)v8 - 15);
          if (v65)
          {
            *((void *)v8 - 14) = v65;
            operator delete(v65);
            *((void *)v8 - 15) = 0;
            *((void *)v8 - 14) = 0;
            *((void *)v8 - 13) = 0;
          }
          *(__n128 *)(v8 - 120) = v225;
          *((void *)v8 - 13) = v226;
          __n128 v225 = 0uLL;
          unint64_t v226 = 0;
          unint64_t v66 = (void *)*((void *)v8 - 12);
          if (v66)
          {
            *((void *)v8 - 11) = v66;
            operator delete(v66);
            *((void *)v8 - 12) = 0;
            *((void *)v8 - 11) = 0;
            *((void *)v8 - 10) = 0;
          }
          *((__n128 *)v8 - 6) = v227;
          *((void *)v8 - 10) = v228;
          __n128 v227 = 0uLL;
          unint64_t v228 = 0;
          sub_10005CBB4((uint64_t *)v8 - 9);
          *(__n128 *)(v8 - 72) = v229;
          *((void *)v8 - 7) = v230;
          __n128 v229 = 0uLL;
          unint64_t v230 = 0;
          unint64_t v67 = (void *)*((void *)v8 - 6);
          if (v67)
          {
            *((void *)v8 - 5) = v67;
            operator delete(v67);
            *((void *)v8 - 6) = 0;
            *((void *)v8 - 5) = 0;
            *((void *)v8 - 4) = 0;
          }
          *((__n128 *)v8 - 3) = v231;
          *((void *)v8 - 4) = v232;
          __n128 v231 = 0uLL;
          unint64_t v232 = 0;
          sub_1011499B8((void **)v8 - 3);
          *(__n128 *)(v8 - 24) = v233;
          *((void *)v8 - 1) = v234;
          __n128 v233 = 0uLL;
          unint64_t v234 = 0;
          long long v195 = &v233;
          sub_1011477A4((void ***)&v195);
          BOOL result = sub_101149F54((uint64_t)&v217);
          a4 = 0;
        }
        uint64_t v191 = a3;
        uint64_t v12 = 0;
        uint64_t v217 = 0;
        unint64_t v216 = 0;
        unsigned int v13 = *v8;
        unsigned __int8 v14 = v8[8];
        uint64_t v181 = *((void *)v8 + 2);
        *(void *)long long v218 = v181;
        long long v171 = *(_OWORD *)(v8 + 24);
        *(_OWORD *)&v218[8] = v171;
        long long v163 = (uint64_t *)(v8 + 16);
        *((void *)v8 + 2) = 0;
        __n128 v15 = *(__n128 *)(v8 + 40);
        *((void *)v8 + 3) = 0;
        *((void *)v8 + 4) = 0;
        __n128 v219 = v15;
        unint64_t v220 = *((void *)v8 + 7);
        uint64_t v165 = (uint64_t *)(v8 + 40);
        *((void *)v8 + 5) = 0;
        *((void *)v8 + 6) = 0;
        *((void *)v8 + 7) = 0;
        __n128 v221 = *((__n128 *)v8 + 4);
        unint64_t v222 = *((void *)v8 + 10);
        uint64_t v168 = (uint64_t)(v8 + 64);
        *((void *)v8 + 8) = 0;
        __n128 v16 = *(__n128 *)(v8 + 88);
        *((void *)v8 + 9) = 0;
        *((void *)v8 + 10) = 0;
        __n128 v223 = v16;
        unint64_t v224 = *((void *)v8 + 13);
        uint64_t v164 = (uint64_t)(v8 + 88);
        *((void *)v8 + 11) = 0;
        *((void *)v8 + 12) = 0;
        *((void *)v8 + 13) = 0;
        uint64_t v17 = (uint64_t)(v8 + 112);
        __n128 v225 = *((__n128 *)v8 + 7);
        unint64_t v226 = *((void *)v8 + 16);
        *((void *)v8 + 14) = 0;
        uint64_t v18 = (uint64_t)(v8 + 136);
        __n128 v19 = *(__n128 *)(v8 + 136);
        *((void *)v8 + 15) = 0;
        *((void *)v8 + 16) = 0;
        __n128 v227 = v19;
        unint64_t v228 = *((void *)v8 + 19);
        *((void *)v8 + 17) = 0;
        *((void *)v8 + 18) = 0;
        *((void *)v8 + 19) = 0;
        long long v20 = (uint64_t *)(v8 + 160);
        __n128 v229 = *((__n128 *)v8 + 10);
        unint64_t v230 = *((void *)v8 + 22);
        *((void *)v8 + 20) = 0;
        uint64_t v21 = (uint64_t)(v8 + 184);
        __n128 v22 = *(__n128 *)(v8 + 184);
        *((void *)v8 + 21) = 0;
        *((void *)v8 + 22) = 0;
        __n128 v231 = v22;
        unint64_t v232 = *((void *)v8 + 25);
        *((void *)v8 + 23) = 0;
        *((void *)v8 + 24) = 0;
        *((void *)v8 + 25) = 0;
        __int16 v23 = (void **)(v8 + 208);
        __n128 v24 = *((__n128 *)v8 + 13);
        unint64_t v234 = *((void *)v8 + 28);
        LOBYTE(v216) = v13;
        unsigned __int8 v175 = v14;
        LOBYTE(v217) = v14;
        __n128 v233 = v24;
        *((void *)v8 + 26) = 0;
        *((void *)v8 + 27) = 0;
        *((void *)v8 + 28) = 0;
        do
        {
          unsigned int v25 = v8[v12 + 232];
          v12 += 232;
        }
        while (v25 < v13);
        __int16 v26 = &v8[v12];
        unsigned __int32 v27 = a2;
        if (v12 == 232)
        {
          unsigned __int32 v27 = a2;
          do
          {
            if (v26 >= v27) {
              break;
            }
            unsigned int v29 = *(v27 - 232);
            v27 -= 232;
          }
          while (v29 >= v13);
        }
        else
        {
          do
          {
            unsigned int v28 = *(v27 - 232);
            v27 -= 232;
          }
          while (v28 >= v13);
        }
        if (v26 >= v27)
        {
          v8 += v12;
        }
        else
        {
          uint64_t v30 = (char *)v27;
          v8 += v12;
          do
          {
            sub_10114CFB0((char *)v8, v30);
            do
            {
              unsigned int v31 = v8[232];
              v8 += 232;
            }
            while (v31 < v13);
            do
            {
              unsigned int v32 = *(v30 - 232);
              v30 -= 232;
            }
            while (v32 >= v13);
          }
          while (v8 < (unsigned __int8 *)v30);
        }
        char v186 = v8 - 232;
        if (v8 - 232 != v180)
        {
          unsigned __int8 *v180 = *(v8 - 232);
          v180[8] = *(v8 - 224);
          sub_10005CBB4(v163);
          *((_OWORD *)v180 + 1) = *(_OWORD *)(v8 - 216);
          *((void *)v180 + 4) = *((void *)v8 - 25);
          *((void *)v8 - 27) = 0;
          *((void *)v8 - 26) = 0;
          *((void *)v8 - 25) = 0;
          sub_10005CBB4(v165);
          *(_OWORD *)(v180 + 40) = *((_OWORD *)v8 - 12);
          *((void *)v180 + 7) = *((void *)v8 - 22);
          *((void *)v8 - 24) = 0;
          *((void *)v8 - 23) = 0;
          *((void *)v8 - 22) = 0;
          sub_10005C9A4(v168, (__n128 *)(v8 - 168));
          sub_10005C9A4(v164, (__n128 *)v8 - 9);
          sub_10005C9A4(v17, (__n128 *)(v8 - 120));
          sub_10005C9A4(v18, (__n128 *)v8 - 6);
          sub_10005CBB4(v20);
          *((_OWORD *)v180 + 10) = *(_OWORD *)(v8 - 72);
          *((void *)v180 + 22) = *((void *)v8 - 7);
          *((void *)v8 - 9) = 0;
          *((void *)v8 - 8) = 0;
          *((void *)v8 - 7) = 0;
          sub_10005C9A4(v21, (__n128 *)v8 - 3);
          sub_1011499B8(v23);
          *((_OWORD *)v180 + 13) = *(_OWORD *)(v8 - 24);
          *((void *)v180 + 28) = *((void *)v8 - 1);
          *((void *)v8 - 3) = 0;
          *((void *)v8 - 2) = 0;
          *((void *)v8 - 1) = 0;
        }
        *(v8 - 232) = v13;
        *(v8 - 224) = v175;
        sub_10005CBB4((uint64_t *)v8 - 27);
        *((void *)v8 - 27) = v181;
        *((void *)v8 - 26) = v171;
        *((void *)v8 - 25) = *(void *)&v218[16];
        memset(v218, 0, sizeof(v218));
        sub_10005CBB4((uint64_t *)v8 - 24);
        *((__n128 *)v8 - 12) = v219;
        *((void *)v8 - 22) = v220;
        __n128 v219 = 0uLL;
        unint64_t v220 = 0;
        BOOL v33 = (void *)*((void *)v8 - 21);
        if (v33)
        {
          *((void *)v8 - 20) = v33;
          operator delete(v33);
          *((void *)v8 - 21) = 0;
          *((void *)v8 - 20) = 0;
          *((void *)v8 - 19) = 0;
        }
        *(__n128 *)(v8 - 168) = v221;
        *((void *)v8 - 19) = v222;
        __n128 v221 = 0uLL;
        unint64_t v222 = 0;
        __int16 v34 = (void *)*((void *)v8 - 18);
        if (v34)
        {
          *((void *)v8 - 17) = v34;
          operator delete(v34);
          *((void *)v8 - 18) = 0;
          *((void *)v8 - 17) = 0;
          *((void *)v8 - 16) = 0;
        }
        *((__n128 *)v8 - 9) = v223;
        *((void *)v8 - 16) = v224;
        __n128 v223 = 0uLL;
        unint64_t v224 = 0;
        int v35 = (void *)*((void *)v8 - 15);
        if (v35)
        {
          *((void *)v8 - 14) = v35;
          operator delete(v35);
          *((void *)v8 - 15) = 0;
          *((void *)v8 - 14) = 0;
          *((void *)v8 - 13) = 0;
        }
        *(__n128 *)(v8 - 120) = v225;
        *((void *)v8 - 13) = v226;
        __n128 v225 = 0uLL;
        unint64_t v226 = 0;
        long long v36 = (void *)*((void *)v8 - 12);
        if (v36)
        {
          *((void *)v8 - 11) = v36;
          operator delete(v36);
          *((void *)v8 - 12) = 0;
          *((void *)v8 - 11) = 0;
          *((void *)v8 - 10) = 0;
        }
        *((__n128 *)v8 - 6) = v227;
        *((void *)v8 - 10) = v228;
        __n128 v227 = 0uLL;
        unint64_t v228 = 0;
        sub_10005CBB4((uint64_t *)v8 - 9);
        *(__n128 *)(v8 - 72) = v229;
        *((void *)v8 - 7) = v230;
        __n128 v229 = 0uLL;
        unint64_t v230 = 0;
        unsigned int v37 = (void *)*((void *)v8 - 6);
        if (v37)
        {
          *((void *)v8 - 5) = v37;
          operator delete(v37);
          *((void *)v8 - 6) = 0;
          *((void *)v8 - 5) = 0;
          *((void *)v8 - 4) = 0;
        }
        *((__n128 *)v8 - 3) = v231;
        *((void *)v8 - 4) = v232;
        __n128 v231 = 0uLL;
        unint64_t v232 = 0;
        sub_1011499B8((void **)v8 - 3);
        *(__n128 *)(v8 - 24) = v233;
        *((void *)v8 - 1) = v234;
        __n128 v233 = 0uLL;
        unint64_t v234 = 0;
        long long v195 = &v233;
        sub_1011477A4((void ***)&v195);
        sub_101149F54((uint64_t)&v217);
        BOOL v4 = v26 >= v27;
        uint64_t v7 = a2;
        a3 = v191;
        if (v4) {
          break;
        }
LABEL_44:
        BOOL result = sub_10114A2E4(v180, v186, v191, a4 & 1);
        a4 = 0;
      }
      BOOL v38 = sub_10114C9E4((char *)v180, v186);
      BOOL result = sub_10114C9E4((char *)v8, a2);
      if (result) {
        break;
      }
      if (!v38) {
        goto LABEL_44;
      }
    }
    a2 = v8 - 232;
    if (!v38) {
      continue;
    }
    return result;
  }
}

char *sub_10114C924(char *result, char *a2, char *a3)
{
  char v5 = result;
  unsigned int v6 = *a2;
  unsigned int v7 = *a3;
  if (v6 >= *result)
  {
    if (v7 >= v6) {
      return result;
    }
    BOOL result = (char *)sub_10114CFB0(a2, a3);
    if (*a2 >= *v5) {
      return result;
    }
    BOOL result = v5;
    uint64_t v8 = a2;
  }
  else
  {
    if (v7 >= v6)
    {
      BOOL result = (char *)sub_10114CFB0(result, a2);
      if (*a3 >= *a2) {
        return result;
      }
      BOOL result = a2;
    }
    uint64_t v8 = a3;
  }

  return (char *)sub_10114CFB0(result, v8);
}

BOOL sub_10114C9E4(char *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  uint64_t v4 = (a2 - (unsigned __int8 *)a1) >> 3;
  BOOL result = 1;
  switch(0x34F72C234F72C235 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 232) < *v3)
      {
        sub_10114CFB0(v3, (char *)a2 - 232);
        return 1;
      }
      return result;
    case 3:
      sub_10114C924(v3, v3 + 232, (char *)a2 - 232);
      return 1;
    case 4:
      sub_10114D3EC(v3, v3 + 232, v3 + 464, (char *)a2 - 232);
      return 1;
    case 5:
      sub_10114D494(v3, v3 + 232, v3 + 464, v3 + 696, (char *)a2 - 232);
      return 1;
    default:
      unsigned int v6 = (unsigned __int8 *)(v3 + 464);
      sub_10114C924(v3, v3 + 232, v3 + 464);
      unsigned int v7 = (unsigned __int8 *)(v3 + 696);
      if (v3 + 696 == (char *)v2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      __n128 v47 = v2;
      break;
  }
  while (1)
  {
    unsigned int v10 = *v7;
    if (v10 < *v6)
    {
      int v48 = v9;
      uint64_t v52 = 0;
      unsigned __int8 v51 = v10;
      LOBYTE(v52) = v7[8];
      long long v53 = *((_OWORD *)v7 + 1);
      uint64_t v54 = *((void *)v7 + 4);
      *((void *)v7 + 2) = 0;
      *((void *)v7 + 3) = 0;
      long long v55 = *(_OWORD *)(v7 + 40);
      uint64_t v56 = *((void *)v7 + 7);
      *((void *)v7 + 4) = 0;
      *((void *)v7 + 5) = 0;
      *((void *)v7 + 6) = 0;
      *((void *)v7 + 7) = 0;
      long long v57 = *((_OWORD *)v7 + 4);
      uint64_t v58 = *((void *)v7 + 10);
      *((void *)v7 + 8) = 0;
      *((void *)v7 + 9) = 0;
      long long v59 = *(_OWORD *)(v7 + 88);
      uint64_t v60 = *((void *)v7 + 13);
      *((void *)v7 + 10) = 0;
      *((void *)v7 + 11) = 0;
      *((void *)v7 + 12) = 0;
      *((void *)v7 + 13) = 0;
      long long v61 = *((_OWORD *)v7 + 7);
      uint64_t v11 = *((void *)v7 + 16);
      *((void *)v7 + 14) = 0;
      *((void *)v7 + 15) = 0;
      long long v63 = *(_OWORD *)(v7 + 136);
      uint64_t v12 = *((void *)v7 + 19);
      uint64_t v62 = v11;
      uint64_t v64 = v12;
      *((void *)v7 + 16) = 0;
      *((void *)v7 + 17) = 0;
      *((void *)v7 + 18) = 0;
      *((void *)v7 + 19) = 0;
      long long v65 = *((_OWORD *)v7 + 10);
      uint64_t v13 = *((void *)v7 + 22);
      *((void *)v7 + 20) = 0;
      *((void *)v7 + 21) = 0;
      long long v67 = *(_OWORD *)(v7 + 184);
      uint64_t v15 = *((void *)v7 + 25);
      uint64_t v66 = v13;
      uint64_t v68 = v15;
      *((void *)v7 + 22) = 0;
      *((void *)v7 + 23) = 0;
      *((void *)v7 + 24) = 0;
      *((void *)v7 + 25) = 0;
      long long v69 = *((_OWORD *)v7 + 13);
      uint64_t v70 = *((void *)v7 + 28);
      *((void *)v7 + 26) = 0;
      *((void *)v7 + 27) = 0;
      uint64_t v49 = v8;
      unsigned __int32 v50 = v7;
      *((void *)v7 + 28) = 0;
      uint64_t v14 = v8;
      LOBYTE(v15) = *v6;
      while (1)
      {
        __n128 v16 = v3;
        uint64_t v17 = (unsigned __int8 *)&v3[v14];
        v17[696] = v15;
        v17[704] = v3[v14 + 472];
        sub_10005CBB4((uint64_t *)&v3[v14 + 712]);
        *(_OWORD *)&v3[v14 + 712] = *(_OWORD *)&v3[v14 + 480];
        *((void *)v17 + 91) = *((void *)v17 + 62);
        *((void *)v17 + 62) = 0;
        *((_OWORD *)v17 + 30) = 0u;
        uint64_t v18 = (unsigned __int8 *)&v3[v14 + 504];
        sub_10005CBB4((uint64_t *)&v3[v14 + 736]);
        *((_OWORD *)v17 + 46) = *(_OWORD *)v18;
        *((void *)v17 + 94) = *((void *)v17 + 65);
        *((void *)v17 + 65) = 0;
        *(_OWORD *)uint64_t v18 = 0u;
        __n128 v19 = (unsigned __int8 *)&v3[v14 + 528];
        sub_10005C9A4((uint64_t)(v17 + 760), (__n128 *)v17 + 33);
        long long v20 = (void **)&v3[v14 + 552];
        sub_10005C9A4((uint64_t)(v17 + 784), (__n128 *)(v17 + 552));
        uint64_t v21 = (void **)&v3[v14 + 576];
        sub_10005C9A4((uint64_t)(v17 + 808), (__n128 *)v17 + 36);
        __n128 v22 = (void **)&v3[v14 + 600];
        sub_10005C9A4((uint64_t)(v17 + 832), (__n128 *)(v17 + 600));
        sub_10005CBB4((uint64_t *)&v3[v14 + 856]);
        *(_OWORD *)(v17 + 856) = *((_OWORD *)v17 + 39);
        *((void *)v17 + 109) = *((void *)v17 + 80);
        *((void *)v17 + 80) = 0;
        *((_OWORD *)v17 + 39) = 0u;
        __int16 v23 = (void **)&v3[v14 + 648];
        sub_10005C9A4((uint64_t)(v17 + 880), (__n128 *)(v17 + 648));
        sub_1011499B8((void **)&v3[v14 + 904]);
        *(_OWORD *)(v17 + 904) = *((_OWORD *)v17 + 42);
        *((void *)v17 + 115) = *((void *)v17 + 86);
        *((void *)v17 + 86) = 0;
        *((_OWORD *)v17 + 42) = 0u;
        if (v14 == -464) {
          break;
        }
        LODWORD(v15) = v17[232];
        v14 -= 232;
        if (v51 >= v15)
        {
          v3 += v14 + 696;
          break;
        }
      }
      uint64_t v2 = v47;
      *uint64_t v3 = v51;
      v3[8] = v52;
      sub_10005CBB4((uint64_t *)v17 + 60);
      uint64_t v24 = *((void *)&v53 + 1);
      *((void *)v17 + 60) = v53;
      uint64_t v25 = v54;
      *((void *)v3 + 3) = v24;
      *((void *)v3 + 4) = v25;
      uint64_t v54 = 0;
      long long v53 = 0uLL;
      sub_10005CBB4((uint64_t *)v17 + 63);
      uint64_t v26 = *((void *)&v55 + 1);
      *((void *)v17 + 63) = v55;
      uint64_t v27 = v56;
      *((void *)v3 + 6) = v26;
      *((void *)v3 + 7) = v27;
      uint64_t v56 = 0;
      long long v55 = 0uLL;
      unsigned int v28 = (void *)*((void *)v17 + 66);
      if (v28)
      {
        *((void *)v3 + 9) = v28;
        operator delete(v28);
        *(void *)__n128 v19 = 0;
        *((void *)v17 + 67) = 0;
        *((void *)v17 + 68) = 0;
      }
      uint64_t v29 = *((void *)&v57 + 1);
      *(void *)__n128 v19 = v57;
      uint64_t v30 = v58;
      *((void *)v3 + 9) = v29;
      *((void *)v3 + 10) = v30;
      uint64_t v58 = 0;
      long long v57 = 0uLL;
      unsigned int v31 = *v20;
      if (*v20)
      {
        *((void *)v3 + 12) = v31;
        operator delete(v31);
        uint64_t *v20 = 0;
        *((void *)v17 + 70) = 0;
        *((void *)v17 + 71) = 0;
      }
      uint64_t v32 = *((void *)&v59 + 1);
      uint64_t *v20 = (void *)v59;
      uint64_t v33 = v60;
      *((void *)v3 + 12) = v32;
      *((void *)v3 + 13) = v33;
      uint64_t v60 = 0;
      long long v59 = 0uLL;
      __int16 v34 = *v21;
      if (*v21)
      {
        *((void *)v3 + 15) = v34;
        operator delete(v34);
        *uint64_t v21 = 0;
        *((void *)v17 + 73) = 0;
        *((void *)v17 + 74) = 0;
      }
      uint64_t v35 = *((void *)&v61 + 1);
      *uint64_t v21 = (void *)v61;
      uint64_t v36 = v62;
      *((void *)v3 + 15) = v35;
      *((void *)v3 + 16) = v36;
      uint64_t v62 = 0;
      long long v61 = 0uLL;
      unsigned int v37 = *v22;
      if (*v22)
      {
        *((void *)v3 + 18) = v37;
        operator delete(v37);
        *__n128 v22 = 0;
        *((void *)v17 + 76) = 0;
        *((void *)v17 + 77) = 0;
      }
      uint64_t v38 = *((void *)&v63 + 1);
      *__n128 v22 = (void *)v63;
      uint64_t v39 = v64;
      *((void *)v3 + 18) = v38;
      *((void *)v3 + 19) = v39;
      uint64_t v64 = 0;
      long long v63 = 0uLL;
      sub_10005CBB4((uint64_t *)v17 + 78);
      uint64_t v40 = *((void *)&v65 + 1);
      *((void *)v17 + 78) = v65;
      uint64_t v41 = v66;
      *((void *)v3 + 21) = v40;
      *((void *)v3 + 22) = v41;
      uint64_t v66 = 0;
      long long v65 = 0uLL;
      unsigned int v42 = *v23;
      if (*v23)
      {
        *((void *)v3 + 24) = v42;
        operator delete(v42);
        *__int16 v23 = 0;
        *((void *)v17 + 82) = 0;
        *((void *)v17 + 83) = 0;
      }
      uint64_t v43 = *((void *)&v67 + 1);
      *__int16 v23 = (void *)v67;
      uint64_t v44 = v68;
      *((void *)v3 + 24) = v43;
      *((void *)v3 + 25) = v44;
      uint64_t v68 = 0;
      long long v67 = 0uLL;
      sub_1011499B8((void **)v17 + 84);
      uint64_t v45 = *((void *)&v69 + 1);
      *((void *)v17 + 84) = v69;
      uint64_t v46 = v70;
      *((void *)v3 + 27) = v45;
      *((void *)v3 + 28) = v46;
      uint64_t v70 = 0;
      long long v69 = 0uLL;
      int v9 = v48 + 1;
      int64_t v71 = (void **)&v69;
      sub_1011477A4(&v71);
      sub_101149F54((uint64_t)&v52);
      uint64_t v3 = v16;
      uint64_t v8 = v49;
      unsigned int v7 = v50;
      if (v48 == 7) {
        return v50 + 232 == v47;
      }
    }
    unsigned int v6 = v7;
    v8 += 232;
    v7 += 232;
    if (v7 == v2) {
      return 1;
    }
  }
}

uint64_t sub_10114CFB0(char *a1, char *a2)
{
  uint64_t v43 = 0;
  char v35 = *a1;
  LOBYTE(v43) = a1[8];
  char v34 = v43;
  uint64_t v4 = a1 + 16;
  uint64_t v44 = *((void *)a1 + 2);
  uint64_t v36 = v44;
  uint64_t v27 = (__n128 *)(a2 + 64);
  unsigned int v28 = (__n128 *)(a2 + 88);
  uint64_t v29 = (__n128 *)(a2 + 112);
  uint64_t v30 = (__n128 *)(a2 + 136);
  long long v32 = *(_OWORD *)(a1 + 24);
  uint64_t v45 = *((void *)a1 + 3);
  *((void *)a1 + 2) = 0;
  char v5 = (uint64_t *)(a1 + 40);
  uint64_t v33 = *((void *)a1 + 5);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = 0;
  uint64_t v47 = v33;
  long long v31 = *((_OWORD *)a1 + 3);
  uint64_t v48 = *((void *)a1 + 6);
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 7) = 0;
  uint64_t v26 = (uint64_t)(a1 + 64);
  long long v50 = *((_OWORD *)a1 + 4);
  uint64_t v51 = *((void *)a1 + 10);
  *((void *)a1 + 8) = 0;
  long long v6 = *(_OWORD *)(a1 + 88);
  uint64_t v25 = (uint64_t)(a1 + 88);
  *((void *)a1 + 9) = 0;
  *((void *)a1 + 10) = 0;
  long long v52 = v6;
  uint64_t v53 = *((void *)a1 + 13);
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 13) = 0;
  uint64_t v7 = (uint64_t)(a1 + 112);
  long long v54 = *((_OWORD *)a1 + 7);
  uint64_t v8 = *((void *)a1 + 16);
  *((void *)a1 + 14) = 0;
  *((void *)a1 + 15) = 0;
  *((void *)a1 + 16) = 0;
  uint64_t v9 = (uint64_t)(a1 + 136);
  long long v56 = *(_OWORD *)(a1 + 136);
  uint64_t v10 = *((void *)a1 + 19);
  uint64_t v55 = v8;
  uint64_t v57 = v10;
  *((void *)a1 + 17) = 0;
  *((void *)a1 + 18) = 0;
  *((void *)a1 + 19) = 0;
  uint64_t v11 = (uint64_t *)(a1 + 160);
  long long v58 = *((_OWORD *)a1 + 10);
  uint64_t v12 = *((void *)a1 + 22);
  *((void *)a1 + 20) = 0;
  *((void *)a1 + 21) = 0;
  *((void *)a1 + 22) = 0;
  uint64_t v14 = (uint64_t)(a1 + 184);
  uint64_t v13 = *((void *)a1 + 23);
  uint64_t v59 = v12;
  uint64_t v60 = v13;
  uint64_t v41 = v13;
  uint64_t v15 = *((void *)a1 + 25);
  uint64_t v39 = *((void *)a1 + 24);
  uint64_t v61 = v39;
  uint64_t v62 = v15;
  uint64_t v37 = v15;
  *((void *)a1 + 23) = 0;
  *((void *)a1 + 24) = 0;
  *((void *)a1 + 25) = 0;
  __n128 v16 = (void **)(a1 + 208);
  uint64_t v17 = *((void *)a1 + 27);
  uint64_t v18 = *((void *)a1 + 28);
  uint64_t v42 = *((void *)a1 + 26);
  uint64_t v63 = v42;
  uint64_t v64 = v17;
  uint64_t v40 = v17;
  uint64_t v38 = v18;
  uint64_t v65 = v18;
  *((void *)a1 + 26) = 0;
  *((void *)a1 + 27) = 0;
  *((void *)a1 + 28) = 0;
  *a1 = *a2;
  a1[8] = a2[8];
  sub_10005CBB4((uint64_t *)a1 + 2);
  *uint64_t v4 = *((_OWORD *)a2 + 1);
  *((void *)a1 + 4) = *((void *)a2 + 4);
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  sub_10005CBB4(v5);
  *(_OWORD *)char v5 = *(_OWORD *)(a2 + 40);
  *((void *)a1 + 7) = *((void *)a2 + 7);
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  sub_10005C9A4(v26, v27);
  sub_10005C9A4(v25, v28);
  sub_10005C9A4(v7, v29);
  sub_10005C9A4(v9, v30);
  sub_10005CBB4(v11);
  *(_OWORD *)uint64_t v11 = *((_OWORD *)a2 + 10);
  *((void *)a1 + 22) = *((void *)a2 + 22);
  *((void *)a2 + 20) = 0;
  *((void *)a2 + 21) = 0;
  *((void *)a2 + 22) = 0;
  sub_10005C9A4(v14, (__n128 *)(a2 + 184));
  sub_1011499B8(v16);
  *(_OWORD *)__n128 v16 = *((_OWORD *)a2 + 13);
  *((void *)a1 + 28) = *((void *)a2 + 28);
  *((void *)a2 + 26) = 0;
  *((void *)a2 + 27) = 0;
  *((void *)a2 + 28) = 0;
  *a2 = v35;
  a2[8] = v34;
  sub_10005CBB4((uint64_t *)a2 + 2);
  *((void *)a2 + 2) = v36;
  *(_OWORD *)(a2 + 24) = v32;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v44 = 0;
  sub_10005CBB4((uint64_t *)a2 + 5);
  *((void *)a2 + 5) = v33;
  *((_OWORD *)a2 + 3) = v31;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  __n128 v19 = (void *)*((void *)a2 + 8);
  if (v19)
  {
    *((void *)a2 + 9) = v19;
    operator delete(v19);
  }
  *((_OWORD *)a2 + 4) = v50;
  *((void *)a2 + 10) = v51;
  uint64_t v51 = 0;
  long long v50 = 0uLL;
  long long v20 = (void *)*((void *)a2 + 11);
  if (v20)
  {
    *((void *)a2 + 12) = v20;
    operator delete(v20);
  }
  *(_OWORD *)(a2 + 88) = v52;
  *((void *)a2 + 13) = v53;
  uint64_t v53 = 0;
  long long v52 = 0uLL;
  uint64_t v21 = (void *)*((void *)a2 + 14);
  if (v21)
  {
    *((void *)a2 + 15) = v21;
    operator delete(v21);
  }
  *((_OWORD *)a2 + 7) = v54;
  *((void *)a2 + 16) = v55;
  uint64_t v55 = 0;
  long long v54 = 0uLL;
  __n128 v22 = (void *)*((void *)a2 + 17);
  if (v22)
  {
    *((void *)a2 + 18) = v22;
    operator delete(v22);
  }
  *(_OWORD *)(a2 + 136) = v56;
  *((void *)a2 + 19) = v57;
  uint64_t v57 = 0;
  long long v56 = 0uLL;
  sub_10005CBB4((uint64_t *)a2 + 20);
  *((_OWORD *)a2 + 10) = v58;
  *((void *)a2 + 22) = v59;
  uint64_t v59 = 0;
  long long v58 = 0uLL;
  __int16 v23 = (void *)*((void *)a2 + 23);
  if (v23)
  {
    *((void *)a2 + 24) = v23;
    operator delete(v23);
  }
  *((void *)a2 + 23) = v41;
  *((void *)a2 + 24) = v39;
  *((void *)a2 + 25) = v37;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v60 = 0;
  sub_1011499B8((void **)a2 + 26);
  *((void *)a2 + 26) = v42;
  *((void *)a2 + 27) = v40;
  *((void *)a2 + 28) = v38;
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  uint64_t v63 = 0;
  uint64_t v66 = (void **)&v63;
  sub_1011477A4(&v66);
  return sub_101149F54((uint64_t)&v43);
}

uint64_t sub_10114D3EC(char *a1, char *a2, char *a3, char *a4)
{
  uint64_t result = (uint64_t)sub_10114C924(a1, a2, a3);
  if (*a4 < *a3)
  {
    uint64_t result = sub_10114CFB0(a3, a4);
    if (*a3 < *a2)
    {
      uint64_t result = sub_10114CFB0(a2, a3);
      if (*a2 < *a1)
      {
        return sub_10114CFB0(a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_10114D494(char *a1, char *a2, char *a3, char *a4, char *a5)
{
  uint64_t result = sub_10114D3EC(a1, a2, a3, a4);
  if (*a5 < *a4)
  {
    uint64_t result = sub_10114CFB0(a4, a5);
    if (*a4 < *a3)
    {
      uint64_t result = sub_10114CFB0(a3, a4);
      if (*a3 < *a2)
      {
        uint64_t result = sub_10114CFB0(a2, a3);
        if (*a2 < *a1)
        {
          return sub_10114CFB0(a1, a2);
        }
      }
    }
  }
  return result;
}

void sub_10114D568(char *a1)
{
  if (a1)
  {
    sub_10114D568(*(void *)a1);
    sub_10114D568(*((void *)a1 + 1));
    uint64_t v2 = (void **)(a1 + 40);
    sub_101146B4C(&v2);
    operator delete(a1);
  }
}

BOOL sub_10114D5CC(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  if (v2 < v3) {
    return 1;
  }
  if (v2 != v3) {
    return 0;
  }
  unsigned int v5 = a1[1];
  unsigned int v6 = a2[1];
  if (v5 < v6 || v5 == v2 && !*((unsigned char *)a1 + 4) && *((unsigned char *)a2 + 4)) {
    return 1;
  }
  return v5 == v6 && *((unsigned __int8 *)a1 + 4) == *((unsigned __int8 *)a2 + 4) && a1[3] < a2[3];
}

void *sub_10114D644(uint64_t a1, void *a2, unsigned __int16 *a3)
{
  unsigned int v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void *)v4;
        uint64_t v8 = (unsigned __int16 *)(v4 + 32);
        if (!sub_10114D5CC(a3, (unsigned __int16 *)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v7;
        unsigned int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_10114D5CC(v8, a3)) {
        break;
      }
      unsigned int v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t *sub_10114D6D8(void **a1)
{
  uint64_t v1 = *a1;
  unsigned int v5 = a1;
  unsigned int v6 = v1;
  unsigned int v2 = *(NSObject **)(*v1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#E selectDnnForTd_sync invalid observer", buf, 2u);
  }
  sub_100058DB0(buf, "");
  uint64_t v3 = v1[4];
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v3 + 48))(v3, buf);
  if (v8 < 0) {
    operator delete(*(void **)buf);
  }
  sub_100B0B7C4((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10114D7AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t *sub_10114D7E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v6 = a1;
  uint64_t v7 = v1;
  unsigned int v2 = *(NSObject **)(*(void *)v1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)(v1 + 40);
    if (*(char *)(v1 + 63) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I selectDnnForTd_sync %s", buf, 0xCu);
  }
  uint64_t v4 = *(void *)(v1 + 32);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v1 + 40);
  sub_10114D8F8(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10114D8DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10114D8F8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    sub_10012C330((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

unsigned char *sub_10114D958@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = (*(_DWORD *)a1 & 0xFFFFFFFD) == 0;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a2 + 8), *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
    *(void *)(a2 + 24) = *(void *)(a1 + 24);
  }
  uint64_t result = (unsigned char *)(a2 + 32);
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)(a1 + 32);
    *(void *)(a2 + 48) = *(void *)(a1 + 48);
  }
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  return result;
}

void sub_10114D9F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10114DA14@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v22 = 0u;
  sub_10004BD84((uint64_t)&v22);
  sub_100058DB0(__p, "<?xml version=\"1.0\" encoding=\"utf-8\" ?>");
  sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "<isComposing xmlns=\"urn:ietf:params:xml:ns:im-iscomposing\">");
  sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  if (*(_DWORD *)a1 != 1)
  {
    sub_100058DB0(__p, " <state>idle</state>");
    sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
    if ((SHIBYTE(v21) & 0x80000000) == 0) {
      goto LABEL_18;
    }
    uint64_t v9 = __p[0];
    goto LABEL_17;
  }
  sub_100058DB0(__p, " <state>active</state>");
  sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v4 = *(void *)(a1 + 56);
  if (v4)
  {
    std::to_string(&v18, v4);
    unsigned int v5 = std::string::insert(&v18, 0, " <refresh>", 0xAuLL);
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v19.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    uint64_t v7 = std::string::append(&v19, "</refresh>", 0xAuLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    std::string::size_type v21 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v9 = (void *)v18.__r_.__value_.__r.__words[0];
LABEL_17:
      operator delete(v9);
    }
  }
LABEL_18:
  uint64_t v10 = *(unsigned __int8 *)(a1 + 31);
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a1 + 16);
  }
  if (v10)
  {
    std::operator+<char>();
    uint64_t v11 = std::string::append(&v19, "</lastactive>", 0xDuLL);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v21 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v13 = *(unsigned __int8 *)(a1 + 55);
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = *(void *)(a1 + 40);
  }
  if (v13)
  {
    std::operator+<char>();
    uint64_t v14 = std::string::append(&v19, "</contenttype>", 0xEuLL);
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    std::string::size_type v21 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
  }
  sub_10004B96C(v23, (uint64_t)"</isComposing>", 14);
  __p[0] = 0;
  __p[1] = 0;
  std::string::size_type v21 = 0;
  sub_10004BC98((uint64_t)v23 + 8, __p);
  sub_10004BC98((uint64_t)v23 + 8, &v19);
  sub_100CC8650(a2, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v23[-1]
  *(void *)&v23[0] = v16;
  if (SHIBYTE(v25) < 0) {
    operator delete(*((void **)&v24 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10114DE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  sub_10008248C((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_10114DF5C(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  if (CFEqual(a1, @"pre-paid")) {
    return 1;
  }
  if (CFStringCompare(a1, @"post-paid", 0)) {
    return 0;
  }
  return 2;
}

uint64_t sub_10114DFC0(const __CFString *a1)
{
  if (CFEqual(a1, @"subscribed")) {
    return 1;
  }
  if (CFEqual(a1, @"not-subscribed")) {
    return 2;
  }
  if (CFStringCompare(a1, @"depleted", 0)) {
    return 8 * (CFEqual(a1, @"throttled"));
  }
  return 4;
}

CFComparisonResult sub_10114E05C(uint64_t a1)
{
  CFStringRef v2 = *(const __CFString **)(a1 + 16);
  if (v2) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFComparisonResult result = CFStringCompare(v2, @"cambio", 0);
    if (result == kCFCompareEqualTo) {
      return result;
    }
    CFStringRef v2 = *(const __CFString **)(a1 + 16);
  }
  if (v2) {
    unsigned int v5 = sub_1000810B8;
  }
  else {
    unsigned int v5 = 0;
  }
  if (!v5) {
    return 2;
  }
  if (CFStringCompare(v2, @"not-cambio", 0)) {
    return 2;
  }
  return 1;
}

uint64_t sub_10114E0F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v6 = sub_100083DA4((const void **)a1, (const void **)a2);
  sub_100083DA4(v6 + 1, (const void **)(a2 + 8));
  sub_100083DA4((const void **)(a1 + 16), (const void **)(a2 + 16));
  sub_100083DA4((const void **)(a1 + 24), (const void **)(a2 + 24));
  long long v7 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  sub_1001A2284(a1 + 72, a3);
  sub_1001A23FC((uint64_t *)(a1 + 96), a3 + 24);
  sub_1001A2574((uint64_t *)(a1 + 120), a3 + 48);
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a3 + 72);
  return a1;
}

void sub_10114E194(_Unwind_Exception *a1)
{
  sub_1000346F8(v3, *(void **)(v1 + 104));
  sub_1000346F8(v2, *(void **)(v1 + 80));
  sub_1001A2238((const void **)v1);
  _Unwind_Resume(a1);
}

__n128 sub_10114E1D0@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2 == (void *)(a1 + 128))
  {
LABEL_9:
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    result.n128_u64[0] = 0x100000001;
    a2->n128_u64[0] = 0x100000001;
  }
  else
  {
    while (!*((unsigned char *)v2 + 48))
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          unint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          unint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
      if (v4 == (void *)(a1 + 128)) {
        goto LABEL_9;
      }
    }
    __n128 result = *(__n128 *)(v2 + 5);
    a2[1].n128_u64[0] = v2[7];
    *a2 = result;
  }
  return result;
}

void sub_10114E244(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10114E52C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void *sub_10114E668(void *a1)
{
  *a1 = off_101A93E80;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_10114E6D8(void *a1)
{
  sub_10114E668(a1);

  operator delete();
}

void sub_10114E710(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10114E810(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = printers::asString((printers *)(a1 + 64), v3);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Demo Device: %s", (uint8_t *)&v4, 0xCu);
  }
}

BOOL sub_10114E8B4(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10114F28C;
  v5[3] = &unk_101A94120;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  long long v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005B644;
    uint64_t v10 = &unk_101A94160;
    uint64_t v11 = &v13;
    long long v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005A8E0;
    uint64_t v10 = &unk_101A94140;
    uint64_t v11 = &v13;
    long long v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_10114E9E8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10114EA20(uint64_t a1)
{
}

uint64_t sub_10114EA3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10114EA80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10114EAAC(ServiceManager::Service *this)
{
  *(void *)this = off_101A93FB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10114EB08(ServiceManager::Service *this)
{
  *(void *)this = off_101A93FB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10114EB78@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "MobileStoreDemo");
}

unsigned char *sub_10114EB88@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10114EBC8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10114E710(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10114E710(v4, 0);
}

uint64_t sub_10114EC4C()
{
  return 0;
}

uint64_t sub_10114EC54()
{
  return 1;
}

uint64_t sub_10114EC5C()
{
  return 0;
}

void sub_10114EC6C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_10114ED80(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 72));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10114EDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10114EDE4(void **a1)
{
  uint64_t v1 = *a1;
  long long v6 = a1;
  long long v7 = v1;
  uint64_t v2 = *v1;
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_101A94030;
  v3[1] = v2;
  void v3[2] = sub_10114E810;
  uint64_t v3[3] = 0;
  long long v12 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/is_postponement_ticket_available");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A940B0;
  v4[1] = v2 + 88;
  void v4[2] = v2;
  void v4[3] = sub_100BDE3E8;
  void v4[4] = 0;
  long long v12 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100088C88((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10114EF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10114EFCC()
{
}

__n128 sub_10114EFE0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A94030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10114F034(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A94030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10114F06C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10114F0B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10114F0F4()
{
}

void sub_10114F104()
{
}

__n128 sub_10114F118(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A940B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10114F16C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A940B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10114F1A4(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10114F240(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10114F280()
{
}

uint64_t sub_10114F28C(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 64);
}

const char *sub_10114F2AC(int a1)
{
  if ((a1 - 1) > 2) {
    return "DATA.ServiceController.?";
  }
  else {
    return off_101A99088[a1 - 1];
  }
}

void *sub_10114F2D4(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_101187854((void *)a1);
}

void *sub_10114F314(void *a1)
{
  sub_10003B34C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void *sub_10114F358(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_1011878D8((void *)a1);
}

void *sub_10114F398(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_10118795C((void *)a1);
}

void *sub_10114F3D8(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_1011879E0((void *)a1);
}

void *sub_10114F418(uint64_t a1)
{
  sub_100B7E174(a1 + 32, *(void **)(a1 + 40));

  return sub_101187A64((void *)a1);
}

void *sub_10114F458(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_101187B6C((void *)a1);
}

void *sub_10114F498(uint64_t a1)
{
  sub_10005D144(*(void **)(a1 + 40));

  return sub_101187BF0((void *)a1);
}

void *sub_10114F4D4(uint64_t a1)
{
  sub_1000886C0(a1 + 32, *(char **)(a1 + 40));

  return sub_101187C74((void *)a1);
}

void *sub_10114F514(uint64_t a1)
{
  sub_10024D10C(a1 + 32, *(void **)(a1 + 40));

  return sub_101187CF8((void *)a1);
}

void *sub_10114F554(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_101187D7C((void *)a1);
}

void *sub_10114F594(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_101187E00((void *)a1);
}

void DataServiceController::create(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  long long v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v7 = dispatch_queue_create("DATA.ServiceController", v6);
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *a2 = 0;
  if (v7) {
    dispatch_retain(v7);
  }
  DataServiceController::create(a3);
}

void sub_10114F6E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    dispatch_release(v10);
  }
  if (a10)
  {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
    if (!v11)
    {
LABEL_5:
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if (!v11)
  {
    goto LABEL_5;
  }
  sub_10004D2C8(v11);
  if (!v10) {
LABEL_7:
  }
    _Unwind_Resume(exception_object);
LABEL_6:
  dispatch_release(v10);
  goto LABEL_7;
}

void DataServiceController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10115091C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,EmergencyMode *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,PersonalitiesTracker *a39,uint64_t a40,DataSliceManagerInterface *a41,DataServiceInterface *a42,ctu::OsLogLogger *a43,_Unwind_Exception *exception_object,uint64_t a45,TetheringControllerInterface *a46)
{
  sub_10008863C((void *)(v46 - 128));
  operator delete();
}

void sub_10115139C(uint64_t a1, NSObject **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "notifyServiceBootstrap";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController: bootstrap 1...", buf, 0xCu);
  }
  int v5 = *a2;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_10003E168(buf, (void *)(a1 + 8));
  operator new();
}

void sub_10115150C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10115151C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "notifyServiceStart";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController: start 1...", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_10003E168(buf, (void *)(a1 + 8));
  operator new();
}

void sub_10115166C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10115167C(uint64_t a1, int a2, ServiceStage *this)
{
  dispatch_object_t object = 0;
  ServiceStage::holdOffStage((uint64_t *)&object, this);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 1174405120;
  void v5[2] = sub_10117E480;
  v5[3] = &unk_101A95BE8;
  void v5[4] = a1;
  dispatch_group_t group = object;
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(group);
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
}

void sub_1011517E4(uint64_t a1, void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v5 = a2[517];
  if (a4 < (unint64_t)((a2[518] - v5) >> 4))
  {
    long long v6 = (uint64_t *)(v5 + 16 * a4);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
  }
  uint64_t v9 = a2[14];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = a2[3];
  if (v10) {
    dispatch_retain(v10);
  }
  operator new();
}

void sub_1011519E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_101151A94()
{
  if (!v0) {
    JUMPOUT(0x101151A4CLL);
  }
  JUMPOUT(0x101151A44);
}

void *sub_101151AA0@<X0>(void *a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  __n128 result = (void *)sub_10003B004(a1[18], a2);
  if (*(void **)(a1[18] + 16) == result)
  {
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    uint64_t v8 = result[7];
    uint64_t v9 = result[8];
    unint64_t v10 = (v9 - v8) >> 4;
    if (v10 < a3)
    {
      uint64_t v11 = result[53];
      uint64_t v14 = result[52];
      uint64_t v15 = v11;
      if (v11)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
        uint64_t v8 = result[7];
        uint64_t v9 = result[8];
      }
      sub_1011517E4((uint64_t)&v16, a1, (uint64_t)&v14, (unint64_t)(v9 - v8) >> 4);
    }
    if (v10 == a3)
    {
      uint64_t v12 = result[53];
      uint64_t v14 = result[52];
      uint64_t v15 = v12;
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      sub_1011517E4((uint64_t)&v16, a1, (uint64_t)&v14, a3);
    }
    long long v13 = *(_OWORD *)(v8 + 16 * a3);
    *(_OWORD *)a4 = v13;
    if (*((void *)&v13 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v13 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

void sub_101151D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1006C59A4((void **)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  _Unwind_Resume(a1);
}

void *sub_101151DA4@<X0>(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  return sub_101151AA0((void *)(a1 - 72), a2, a3, a4);
}

void sub_101151DAC(void *a1, int a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v7 = (void *)sub_10003B004(a1[18], a2);
  if (*(void **)(a1[18] + 16) != v7)
  {
    uint64_t v8 = v7[7];
    uint64_t v9 = v7[8];
    if (a3 >= (unint64_t)((v9 - v8) >> 4))
    {
      uint64_t v10 = v7[53];
      v15[0] = v7[52];
      v15[1] = v10;
      if (v10)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        uint64_t v8 = v7[7];
        uint64_t v9 = v7[8];
      }
      sub_1011517E4((uint64_t)&v16, a1, (uint64_t)v15, (unint64_t)(v9 - v8) >> 4);
    }
    uint64_t v11 = (void *)(v8 + 16 * a3);
    uint64_t v13 = *a4;
    uint64_t v12 = a4[1];
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = (std::__shared_weak_count *)v11[1];
    void *v11 = v13;
    v11[1] = v12;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
}

void sub_101151F5C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1006C59A4((void **)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

void sub_101151F9C(uint64_t a1, int a2, unsigned int a3, uint64_t *a4)
{
}

void sub_101151FA4(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v7)
  {
    uint64_t v8 = *(uint64_t **)v7;
    uint64_t v9 = *(uint64_t **)(v7 + 8);
    if (*(uint64_t **)v7 != v9)
    {
      do
      {
        uint64_t v10 = *v8;
        uint64_t v11 = (std::__shared_weak_count *)v8[1];
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v10) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 536))(v10, a3, a4);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
        v8 += 2;
      }
      while (v8 != v9);
    }
  }
}

void sub_101152064(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115207C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
}

void sub_101152084(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  uint64_t v2 = *(uint64_t ***)(v1 + 8);
  for (uint64_t i = *(uint64_t ***)(v1 + 16); v2 != i; v2 += 54)
  {
    uint64_t v4 = *v2;
    uint64_t v5 = v2[1];
    while (v4 != v5)
    {
      uint64_t v6 = *v4;
      uint64_t v7 = (std::__shared_weak_count *)v4[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 624))(v6);
      }
      if (v7) {
        sub_10004D2C8(v7);
      }
      v4 += 2;
    }
  }
}

void sub_101152130(_Unwind_Exception *a1)
{
  if (v1)
  {
    uint64_t v2 = a1;
    sub_10004D2C8(v1);
    a1 = v2;
  }
  _Unwind_Resume(a1);
}

void sub_101152148(uint64_t a1)
{
}

void sub_101152150(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(uint64_t ***)(v2 + 8);
  for (uint64_t i = *(uint64_t ***)(v2 + 16); v3 != i; v3 += 54)
  {
    uint64_t v6 = *v3;
    uint64_t v7 = v3[1];
    while (v6 != v7)
    {
      uint64_t v8 = *v6;
      uint64_t v9 = (std::__shared_weak_count *)v6[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v8) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 632))(v8, a2);
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
      v6 += 2;
    }
  }
}

void sub_10115220C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101152224(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10115222C(uint64_t a1, int a2, uint64_t a3)
{
  int v8 = a2;
  v7[0] = 1;
  v7[1] = a1 + 3072;
  if (*(unsigned char *)(a3 + 8))
  {
    uint64_t v3 = *(uint64_t **)a3;
    uint64_t v4 = sub_1011888B4((uint64_t **)(a1 + 3104), a2, &v8);
    void v4[5] = v3;
    *((unsigned char *)v4 + 48) = 1;
  }
  else
  {
    uint64_t v5 = sub_1011888B4((uint64_t **)(a1 + 3104), a2, &v8);
    if (*((unsigned char *)v5 + 48)) {
      *((unsigned char *)v5 + 48) = 0;
    }
  }
  return sub_101188850((uint64_t)v7);
}

void sub_1011522A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101188850((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011522C0(uint64_t a1, int a2, uint64_t a3)
{
  return sub_10115222C(a1 - 72, a2, a3);
}

void sub_1011522C8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I bootstrapping...", (uint8_t *)&buf, 2u);
  }
  uint32_t v3 = notify_register_check("com.apple.CoreTelephony.Slicing.LLPHS.State", (int *)(a1 + 4888));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "com.apple.CoreTelephony.Slicing.LLPHS.State";
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to create notify register check for notification '%s'", (uint8_t *)&buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 4888);
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I bootstrapping: slicingLLPHSStateNotifyToken: %d", (uint8_t *)&buf, 8u);
  }
  uint32_t v6 = notify_register_check("com.apple.CoreTelephony.Slicing.Interfaces.Active.State", (int *)(a1 + 4892));
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (v6)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "com.apple.CoreTelephony.Slicing.Interfaces.Active.State";
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create notify register check for notification '%s'", (uint8_t *)&buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 4892);
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I bootstrapping: slicingInterfacesActiveStateNotifyToken: %d", (uint8_t *)&buf, 8u);
  }
  uint32_t v9 = notify_register_check("com.apple.CoreTelephony.UL.Health.Emergency.Bottleneck", (int *)(a1 + 5152));
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (v9)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "com.apple.CoreTelephony.UL.Health.Emergency.Bottleneck";
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to create notify register check for notification '%s'", (uint8_t *)&buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(_DWORD *)(a1 + 5152);
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I bootstrapping: fUlHealthEmergencyBottleneckStateNotifyToken: %d", (uint8_t *)&buf, 8u);
  }
  DataServiceController::setSliceEventsListeners_sync((DataServiceController *)a1, 0, 0, 0);
  uint64_t v12 = *(void *)(a1 + 224);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I bootstrapping: command driver done.", (uint8_t *)&buf, 2u);
  }
  uint64_t v14 = *(void *)(a1 + 144);
  uint64_t v15 = *(void *)(v14 + 8);
  for (uint64_t i = *(void *)(v14 + 16); v15 != i; v15 += 432)
  {
    uint64_t v17 = *(void *)(v15 + 24);
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 304))(v17);
    }
    std::string v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DataServiceController bootstrapping: BBDriver done.", (uint8_t *)&buf, 2u);
    }
    uint64_t v19 = *(void *)(v15 + 40);
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 296))(v19);
    }
    long long v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DataServiceController bootstrapping: TechDriver done.", (uint8_t *)&buf, 2u);
    }
  }
  std::string::size_type v21 = *(NSObject **)(a1 + 40);
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (v22)
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I bootstrapping: drivers done.", (uint8_t *)&buf, 2u);
  }
  unint64_t v23 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v22);
  if (v23 >> 31) {
    __assert_rtn("bootstrapDataServiceController_sync", "DataServiceController.cpp", 542, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<int>::max()");
  }
  uint64_t v24 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v23);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1552))(a1, v24);
  Registry::createRestModuleOneTimeUseConnection(&v126, *(Registry **)(a1 + 104));
  uint64_t v25 = a1 + 120;
  ctu::RestModule::connect();
  if (v127) {
    sub_10004D2C8(v127);
  }
  sub_100058DB0(&aBlock, "/cc/props/airplane_mode");
  long long v26 = operator new(0x28uLL);
  void *v26 = off_101A963B8;
  v26[1] = a1 + 832;
  v26[2] = a1;
  v26[3] = sub_101156F7C;
  v26[4] = 0;
  *((void *)&v149 + 1) = v26;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v143) < 0) {
    operator delete(aBlock);
  }
  sub_100058DB0(&aBlock, "/cc/props/radio_state");
  long long v27 = operator new(0x28uLL);
  *long long v27 = off_101A96438;
  v27[1] = a1 + 836;
  v27[2] = a1;
  v27[3] = DataServiceController::handleRadioState_sync;
  v27[4] = 0;
  *((void *)&v149 + 1) = v27;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v143) < 0) {
    operator delete(aBlock);
  }
  uint64_t v28 = a1 + 2848;
  *(void *)&long long buf = off_101A964B8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 2848))
  {
    uint64_t v29 = *(void *)(a1 + 2872);
    if (v29 == v28)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A964B8;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v28 + 24))(a1 + 2848, &buf);
      (*(void (**)(void))(**(void **)(a1 + 2872) + 32))(*(void *)(a1 + 2872));
      *(void *)(a1 + 2872) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 2848);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 2848) = off_101A964B8;
      *(void *)(a1 + 2856) = v25;
      *((void *)&v149 + 1) = v29;
    }
    *(void *)(a1 + 2872) = v28;
  }
  sub_101187E00(&buf);
  uint64_t v30 = *(void *)(a1 + 2872);
  if (v30) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 48))(v30, a1 + 2880);
  }
  uint64_t v31 = a1 + 2904;
  *(void *)&long long buf = off_101A96548;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 2904))
  {
    uint64_t v32 = *(void *)(a1 + 2928);
    if (v32 == v31)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96548;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v31 + 24))(a1 + 2904, &buf);
      (*(void (**)(void))(**(void **)(a1 + 2928) + 32))(*(void *)(a1 + 2928));
      *(void *)(a1 + 2928) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 2904);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 2904) = off_101A96548;
      *(void *)(a1 + 2912) = v25;
      *((void *)&v149 + 1) = v32;
    }
    *(void *)(a1 + 2928) = v31;
  }
  sub_101187D7C(&buf);
  uint64_t v33 = *(void *)(a1 + 2928);
  if (v33) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v33 + 48))(v33, a1 + 2936);
  }
  uint64_t v34 = a1 + 2960;
  *(void *)&long long buf = off_101A965D8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 2960))
  {
    uint64_t v35 = *(void *)(a1 + 2984);
    if (v35 == v34)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A965D8;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v34 + 24))(a1 + 2960, &buf);
      (*(void (**)(void))(**(void **)(a1 + 2984) + 32))(*(void *)(a1 + 2984));
      *(void *)(a1 + 2984) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 2960);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 2960) = off_101A965D8;
      *(void *)(a1 + 2968) = v25;
      *((void *)&v149 + 1) = v35;
    }
    *(void *)(a1 + 2984) = v34;
  }
  sub_101187CF8(&buf);
  uint64_t v36 = *(void *)(a1 + 2984);
  if (v36) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v36 + 48))(v36, a1 + 2992);
  }
  uint64_t v37 = a1 + 3016;
  *(void *)&long long buf = off_101A96668;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3016))
  {
    uint64_t v38 = *(void *)(a1 + 3040);
    if (v38 == v37)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96668;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v37 + 24))(a1 + 3016, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3040) + 32))(*(void *)(a1 + 3040));
      *(void *)(a1 + 3040) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3016);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3016) = off_101A96668;
      *(void *)(a1 + 3024) = v25;
      *((void *)&v149 + 1) = v38;
    }
    *(void *)(a1 + 3040) = v37;
  }
  sub_101187C74(&buf);
  uint64_t v39 = *(void *)(a1 + 3040);
  if (v39) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 48))(v39, a1 + 3048);
  }
  uint64_t v40 = a1 + 3072;
  *(void *)&long long buf = off_101A966F8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3072))
  {
    uint64_t v41 = *(void *)(a1 + 3096);
    if (v41 == v40)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A966F8;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v40 + 24))(a1 + 3072, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3096) + 32))(*(void *)(a1 + 3096));
      *(void *)(a1 + 3096) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3072);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3072) = off_101A966F8;
      *(void *)(a1 + 3080) = v25;
      *((void *)&v149 + 1) = v41;
    }
    *(void *)(a1 + 3096) = v40;
  }
  sub_101187BF0(&buf);
  uint64_t v42 = *(void *)(a1 + 3096);
  if (v42) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v42 + 48))(v42, a1 + 3104);
  }
  *(void *)&long long buf = off_101A96788;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_10008C3B4(&buf, (void *)(a1 + 3128));
  sub_1000882E8(&buf);
  uint64_t v43 = *(void *)(a1 + 3152);
  if (v43) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v43 + 48))(v43, a1 + 3160);
  }
  *(void *)&long long buf = off_101A96808;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100A92018(&buf, (void *)(a1 + 3184));
  sub_100A8DBC4(&buf);
  uint64_t v44 = *(void *)(a1 + 3208);
  if (v44) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v44 + 48))(v44, a1 + 3216);
  }
  *(void *)&long long buf = off_101A96888;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100A92018(&buf, (void *)(a1 + 3240));
  sub_100A8DBC4(&buf);
  uint64_t v45 = *(void *)(a1 + 3264);
  if (v45) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v45 + 48))(v45, a1 + 3272);
  }
  uint64_t v46 = a1 + 3352;
  *(void *)&long long buf = off_101A96908;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3352))
  {
    uint64_t v47 = *(void *)(a1 + 3376);
    if (v47 == v46)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96908;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v46 + 24))(a1 + 3352, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3376) + 32))(*(void *)(a1 + 3376));
      *(void *)(a1 + 3376) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3352);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3352) = off_101A96908;
      *(void *)(a1 + 3360) = v25;
      *((void *)&v149 + 1) = v47;
    }
    *(void *)(a1 + 3376) = v46;
  }
  sub_101187B6C(&buf);
  uint64_t v48 = *(void *)(a1 + 3376);
  if (v48) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v48 + 48))(v48, a1 + 3384);
  }
  sub_100058DB0(&aBlock, "/cc/props/airplane_mode_user_preference");
  uint64_t v49 = operator new(0x28uLL);
  void *v49 = off_101A96998;
  v49[1] = a1 + 1144;
  v49[2] = a1;
  void v49[3] = sub_1011574A0;
  v49[4] = 0;
  *((void *)&v149 + 1) = v49;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v143) < 0) {
    operator delete(aBlock);
  }
  *(void *)&long long buf = off_101A96A18;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100609368(&buf, (void *)(a1 + 3488));
  sub_100600F40(&buf);
  uint64_t v50 = *(void *)(a1 + 3512);
  if (v50) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v50 + 48))(v50, a1 + 3520);
  }
  uint64_t v51 = a1 + 3528;
  *(void *)&long long buf = off_101A96A98;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3528))
  {
    uint64_t v52 = *(void *)(a1 + 3552);
    if (v52 == v51)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96A98;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v51 + 24))(a1 + 3528, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3552) + 32))(*(void *)(a1 + 3552));
      *(void *)(a1 + 3552) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3528);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3528) = off_101A96A98;
      *(void *)(a1 + 3536) = v25;
      *((void *)&v149 + 1) = v52;
    }
    *(void *)(a1 + 3552) = v51;
  }
  sub_101187AE8(&buf);
  uint64_t v53 = *(void *)(a1 + 3552);
  if (v53) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v53 + 48))(v53, a1 + 3560);
  }
  uint64_t v54 = a1 + 3568;
  *(void *)&long long buf = off_101A96B28;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3568))
  {
    uint64_t v55 = *(void *)(a1 + 3592);
    if (v55 == v54)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96B28;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v54 + 24))(a1 + 3568, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3592) + 32))(*(void *)(a1 + 3592));
      *(void *)(a1 + 3592) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3568);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3568) = off_101A96B28;
      *(void *)(a1 + 3576) = v25;
      *((void *)&v149 + 1) = v55;
    }
    *(void *)(a1 + 3592) = v54;
  }
  sub_101187A64(&buf);
  uint64_t v56 = *(void *)(a1 + 3592);
  if (v56) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v56 + 48))(v56, a1 + 3600);
  }
  uint64_t v57 = a1 + 3624;
  *(void *)&long long buf = off_101A96BB8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3624))
  {
    uint64_t v58 = *(void *)(a1 + 3648);
    if (v58 == v57)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96BB8;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v57 + 24))(a1 + 3624, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3648) + 32))(*(void *)(a1 + 3648));
      *(void *)(a1 + 3648) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3624);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3624) = off_101A96BB8;
      *(void *)(a1 + 3632) = v25;
      *((void *)&v149 + 1) = v58;
    }
    *(void *)(a1 + 3648) = v57;
  }
  sub_1011879E0(&buf);
  uint64_t v59 = *(void *)(a1 + 3648);
  if (v59) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v59 + 48))(v59, a1 + 3656);
  }
  *(void *)&long long buf = off_101A96C48;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100A92018(&buf, (void *)(a1 + 3680));
  sub_100A8DBC4(&buf);
  uint64_t v60 = *(void *)(a1 + 3704);
  if (v60) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v60 + 48))(v60, a1 + 3712);
  }
  uint64_t v61 = a1 + 3736;
  *(void *)&long long buf = off_101A96CC8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  if (&buf != (long long *)(a1 + 3736))
  {
    uint64_t v62 = *(void *)(a1 + 3760);
    if (v62 == v61)
    {
      uint64_t v142 = a1 + 120;
      uint64_t v143 = 0;
      aBlock = off_101A96CC8;
      *((void *)&v149 + 1) = 0;
      (*(void (**)(uint64_t, long long *))(*(void *)v61 + 24))(a1 + 3736, &buf);
      (*(void (**)(void))(**(void **)(a1 + 3760) + 32))(*(void *)(a1 + 3760));
      *(void *)(a1 + 3760) = 0;
      *((void *)&v149 + 1) = &buf;
      ((void (*)(uint64_t (***)(), uint64_t))aBlock[3])(&aBlock, a1 + 3736);
      ((void (*)(uint64_t (***)()))aBlock[4])(&aBlock);
    }
    else
    {
      *(void *)(a1 + 3736) = off_101A96CC8;
      *(void *)(a1 + 3744) = v25;
      *((void *)&v149 + 1) = v62;
    }
    *(void *)(a1 + 3760) = v61;
  }
  sub_10118795C(&buf);
  uint64_t v63 = *(void *)(a1 + 3760);
  if (v63) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v63 + 48))(v63, a1 + 3768);
  }
  *(void *)&long long buf = off_101A96D58;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_10098310C(&buf, (void *)(a1 + 3792));
  sub_10097E974(&buf);
  uint64_t v64 = *(void *)(a1 + 3816);
  if (v64) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v64 + 48))(v64, a1 + 3824);
  }
  *(void *)&long long buf = off_101A96DD8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100318874(&buf, (void *)(a1 + 3848));
  sub_10030AB98(&buf);
  uint64_t v65 = *(void *)(a1 + 3872);
  if (v65) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v65 + 48))(v65, a1 + 3880);
  }
  *(void *)&long long buf = off_101A96E58;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_10041CA0C(&buf, (void *)(a1 + 3296));
  sub_10041A760(&buf);
  uint64_t v66 = *(void *)(a1 + 3320);
  if (v66) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v66 + 48))(v66, a1 + 3328);
  }
  *(void *)&long long buf = off_101A96ED8;
  *((void *)&buf + 1) = a1 + 120;
  *((void *)&v149 + 1) = &buf;
  sub_100318874(&buf, (void *)(a1 + 3888));
  sub_10030AB98(&buf);
  uint64_t v67 = *(void *)(a1 + 3912);
  if (v67) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v67 + 48))(v67, a1 + 3920);
  }
  uint64_t v68 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 2192))(a1);
  if (v68)
  {
    sub_100058DB0(&aBlock, "/cc/events/app_state_changed");
    long long v69 = operator new(0x20uLL);
    *long long v69 = off_101A96F58;
    v69[1] = a1;
    v69[2] = DataServiceController::handleAppRunState_sync;
    v69[3] = 0;
    *((void *)&v149 + 1) = v69;
    ctu::RestModule::observeEvent();
    uint64_t v68 = (capabilities::ct *)sub_10003F600(&buf);
    if (SHIBYTE(v143) < 0) {
      operator delete(aBlock);
    }
  }
  uint64_t v70 = capabilities::ct::supportsGemini(v68);
  if ((v70 & 1) == 0)
  {
    *(_DWORD *)(a1 + 3520) = 1;
    uint64_t v71 = *(void *)(a1 + 3512);
    if (v71) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v71 + 48))(v71, a1 + 3520);
    }
    *(_DWORD *)(a1 + 3560) = 1;
    uint64_t v70 = *(void *)(a1 + 3552);
    if (v70) {
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v70 + 48))(v70, a1 + 3560);
    }
    *(_DWORD *)(a1 + 4188) = 1;
  }
  uint64_t v72 = (capabilities::ct *)capabilities::ct::supportsDataSubscriptionController((capabilities::ct *)v70);
  if (v72)
  {
    uint64_t v72 = (capabilities::ct *)capabilities::ct::supportsGemini(v72);
    if (v72)
    {
      sub_100058DB0(&aBlock, "/cc/props/baseband_data_slot");
      unsigned int v73 = operator new(0x28uLL);
      void *v73 = off_101A96FD8;
      v73[1] = a1 + 1072;
      v73[2] = a1;
      v73[3] = DataServiceController::handleBasebandDataSlotUpdated_sync;
      v73[4] = 0;
      *((void *)&v149 + 1) = v73;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      goto LABEL_154;
    }
  }
  uint64_t v74 = (capabilities::ct *)capabilities::ct::supportsGemini(v72);
  if (v74)
  {
    sub_100630174((void *)(a1 + 3448), a1 + 120);
    sub_100630234((void *)(a1 + 3408), a1 + 120);
    goto LABEL_154;
  }
  unint64_t v75 = (capabilities::ct *)capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v74);
  if (v75)
  {
    sub_100630174((void *)(a1 + 3448), a1 + 120);
    sub_100630234((void *)(a1 + 3408), a1 + 120);
    *(_DWORD *)(a1 + 3440) = 1;
    uint64_t v76 = *(void *)(a1 + 3432);
    if (!v76) {
      goto LABEL_154;
    }
  }
  else
  {
    if (capabilities::ct::supportsDynamicSID(v75)) {
      goto LABEL_154;
    }
    sub_100630174((void *)(a1 + 3448), a1 + 120);
    sub_100630234((void *)(a1 + 3408), a1 + 120);
    *(_DWORD *)(a1 + 3480) = 1;
    uint64_t v77 = *(void *)(a1 + 3472);
    if (v77) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v77 + 48))(v77, a1 + 3480);
    }
    *(_DWORD *)(a1 + 3440) = 1;
    uint64_t v76 = *(void *)(a1 + 3432);
    if (!v76)
    {
LABEL_154:
      sub_100058DB0(&aBlock, "/cc/events/recalculate_connection_availability");
      *(void *)&long long buf = off_101A97058;
      *((void *)&buf + 1) = a1;
      *((void *)&v149 + 1) = &buf;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/rat");
      __int16 v78 = operator new(0x28uLL);
      void *v78 = off_101A970D8;
      v78[1] = a1 + 1024;
      v78[2] = a1;
      v78[3] = sub_1011574BC;
      uint8_t v78[4] = 0;
      *((void *)&v149 + 1) = v78;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/reg_data_modes");
      uint64_t v79 = operator new(0x28uLL);
      *uint64_t v79 = off_101A97158;
      v79[1] = a1 + 648;
      v79[2] = a1;
      v79[3] = sub_1011576E4;
      v79[4] = 0;
      *((void *)&v149 + 1) = v79;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/reg_ps_attached");
      int v80 = operator new(0x28uLL);
      *int v80 = off_101A971D8;
      v80[1] = a1 + 624;
      v80[2] = a1;
      v80[3] = sub_101157E48;
      v80[4] = 0;
      *((void *)&v149 + 1) = v80;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/registration_status");
      long long v81 = operator new(0x28uLL);
      void *v81 = off_101A97258;
      v81[1] = a1 + 672;
      v81[2] = a1;
      v81[3] = sub_101158094;
      v81[4] = 0;
      *((void *)&v149 + 1) = v81;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/reg_serving_network");
      unsigned int v82 = operator new(0x28uLL);
      void *v82 = off_101A972D8;
      v82[1] = a1 + 696;
      v82[2] = a1;
      v82[3] = sub_101158454;
      v82[4] = 0;
      *((void *)&v149 + 1) = v82;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/subscriber_data_id_states");
      uint64_t v83 = operator new(0x28uLL);
      void *v83 = off_101A97358;
      v83[1] = a1 + 376;
      v83[2] = a1;
      v83[3] = sub_1011588A0;
      v83[4] = 0;
      *((void *)&v149 + 1) = v83;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/vowifi_provisioning_state");
      __int16 v84 = operator new(0x28uLL);
      void *v84 = off_101A973D8;
      v84[1] = a1 + 568;
      v84[2] = a1;
      v84[3] = sub_101158E0C;
      v84[4] = 0;
      *((void *)&v149 + 1) = v84;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/ims_feature_state");
      int v85 = operator new(0x28uLL);
      void *v85 = off_101A97458;
      v85[1] = a1 + 592;
      v85[2] = a1;
      v85[3] = sub_101159650;
      v85[4] = 0;
      *((void *)&v149 + 1) = v85;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/cellular_data_setting");
      long long v86 = operator new(0x28uLL);
      void *v86 = off_101A974D8;
      v86[1] = a1 + 617;
      v86[2] = a1;
      v86[3] = sub_101159F44;
      v86[4] = 0;
      *((void *)&v149 + 1) = v86;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/cellular_data_setting_internal");
      unsigned int v87 = operator new(0x28uLL);
      *unsigned int v87 = off_101A97558;
      v87[1] = a1 + 618;
      v87[2] = a1;
      v87[3] = sub_10115A0A4;
      v87[4] = 0;
      *((void *)&v149 + 1) = v87;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/call_state");
      BOOL v88 = operator new(0x28uLL);
      *BOOL v88 = off_101A975D8;
      v88[1] = a1 + 848;
      v88[2] = a1;
      v88[3] = sub_10115A21C;
      v88[4] = 0;
      *((void *)&v149 + 1) = v88;
      ctu::RestModule::observeProperty();
      unsigned int v89 = (capabilities::ct *)sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      if (capabilities::ct::supportsGemini(v89))
      {
        sub_100058DB0(&aBlock, "/cc/events/recommended_data_sim");
        __int16 v90 = operator new(0x20uLL);
        void *v90 = off_101A97658;
        v90[1] = a1;
        v90[2] = DataServiceController::handleRecommendedDataSIMChange_sync;
        v90[3] = 0;
        *((void *)&v149 + 1) = v90;
        ctu::RestModule::observeEvent();
        sub_10003F600(&buf);
        if (SHIBYTE(v143) < 0) {
          operator delete(aBlock);
        }
      }
      sub_100058DB0(&aBlock, "/cc/props/iwlan_policies");
      int64_t v91 = operator new(0x28uLL);
      void *v91 = off_101A976D8;
      v91[1] = a1 + 896;
      v91[2] = a1;
      v91[3] = sub_10115AA54;
      v91[4] = 0;
      *((void *)&v149 + 1) = v91;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/provisioning_pco_switch");
      int64_t v92 = operator new(0x28uLL);
      void *v92 = off_101A97758;
      v92[1] = a1 + 840;
      v92[2] = a1;
      v92[3] = sub_10115ADC0;
      v92[4] = 0;
      *((void *)&v149 + 1) = v92;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/sims_in_use");
      uint64_t v93 = operator new(0x28uLL);
      *uint64_t v93 = off_101A977D8;
      v93[1] = a1 + 344;
      v93[2] = a1;
      v93[3] = sub_10115AEBC;
      v93[4] = 0;
      *((void *)&v149 + 1) = v93;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/carrier_bundle_event");
      int64_t v94 = operator new(0x20uLL);
      void *v94 = off_101A97858;
      v94[1] = a1;
      v94[2] = sub_10115B2AC;
      v94[3] = 0;
      *((void *)&v149 + 1) = v94;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/operator_bundle_event");
      unsigned int v95 = operator new(0x20uLL);
      *unsigned int v95 = off_101A978D8;
      v95[1] = a1;
      v95[2] = sub_10115B668;
      v95[3] = 0;
      *((void *)&v149 + 1) = v95;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/irat_change");
      unsigned int v96 = operator new(0x20uLL);
      *unsigned int v96 = off_101A97958;
      v96[1] = a1;
      v96[2] = sub_10115B89C;
      v96[3] = 0;
      *((void *)&v149 + 1) = v96;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/callkit_call_change");
      BOOL v97 = operator new(0x20uLL);
      *BOOL v97 = off_101A979D8;
      v97[1] = a1;
      v97[2] = DataServiceController::callKitCallChanged_sync;
      v97[3] = 0;
      *((void *)&v149 + 1) = v97;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/data_attach_apn_params");
      long long v98 = operator new(0x20uLL);
      *long long v98 = off_101A97A58;
      v98[1] = a1;
      v98[2] = sub_10115BB88;
      v98[3] = 0;
      *((void *)&v149 + 1) = v98;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/in_home_countries_definite");
      unsigned int v99 = operator new(0x28uLL);
      *unsigned int v99 = off_101A97AD8;
      v99[1] = a1 + 720;
      v99[2] = a1;
      v99[3] = sub_10115BCA4;
      v99[4] = 0;
      *((void *)&v149 + 1) = v99;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/baseband_firmware_dead");
      size_t v100 = operator new(0x28uLL);
      *size_t v100 = off_101A97B58;
      v100[1] = a1 + 921;
      v100[2] = a1;
      v100[3] = sub_10115BDA4;
      v100[4] = 0;
      *((void *)&v149 + 1) = v100;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "cc/props/ims_preference_states");
      uint64_t v101 = operator new(0x28uLL);
      void *v101 = off_101A97BD8;
      v101[1] = a1 + 744;
      v101[2] = a1;
      _OWORD v101[3] = sub_10115BE98;
      v101[4] = 0;
      *((void *)&v149 + 1) = v101;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/events/drop_ims_packets");
      uint64_t v102 = operator new(0x20uLL);
      *uint64_t v102 = off_101A97C58;
      v102[1] = a1;
      v102[2] = sub_10115C0E0;
      v102[3] = 0;
      *((void *)&v149 + 1) = v102;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/ne_configuration_started");
      unsigned int v103 = operator new(0x28uLL);
      *unsigned int v103 = off_101A97CD8;
      v103[1] = a1 + 801;
      v103[2] = a1;
      v103[3] = sub_10115C248;
      v103[4] = 0;
      *((void *)&v149 + 1) = v103;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100F2914C(a1 + 802);
      sub_100058DB0(&aBlock, "/cc/props/cdma_aux_info_ready");
      BOOL v104 = operator new(0x28uLL);
      *BOOL v104 = off_101A97D58;
      v104[1] = a1 + 928;
      v104[2] = a1;
      v104[3] = sub_10115C3C8;
      v104[4] = 0;
      *((void *)&v149 + 1) = v104;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/critical_activity_on_sim_personality");
      unsigned __int8 v105 = operator new(0x28uLL);
      *unsigned __int8 v105 = off_101A97DD8;
      v105[1] = a1 + 808;
      v105[2] = a1;
      v105[3] = DataServiceController::handleCriticalActivityOnSim_sync;
      v105[4] = 0;
      *((void *)&v149 + 1) = v105;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/phs_clients");
      uint64_t v106 = operator new(0x28uLL);
      *uint64_t v106 = off_101A97E58;
      v106[1] = a1 + 1076;
      v106[2] = a1;
      v106[3] = DataServiceController::handlePhsClients_sync;
      v106[4] = 0;
      *((void *)&v149 + 1) = v106;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/reg_net_info1");
      long long v107 = operator new(0x28uLL);
      *long long v107 = off_101A97ED8;
      v107[1] = a1 + 1176;
      v107[2] = a1;
      v107[3] = sub_100005070;
      v107[4] = 0;
      *((void *)&v149 + 1) = v107;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/reg_net_info2");
      unint64_t v108 = operator new(0x28uLL);
      *unint64_t v108 = off_101A97F58;
      v108[1] = a1 + 1976;
      v108[2] = a1;
      v108[3] = sub_10115C808;
      v108[4] = 0;
      *((void *)&v149 + 1) = v108;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/baseband_service_provisioned_states");
      __int16 v109 = operator new(0x28uLL);
      *__int16 v109 = off_101A97FD8;
      v109[1] = a1 + 776;
      v109[2] = a1;
      v109[3] = sub_10115C9F8;
      v109[4] = 0;
      *((void *)&v149 + 1) = v109;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/baseband_activated");
      int v110 = operator new(0x28uLL);
      *int v110 = off_101A98058;
      v110[1] = a1 + 800;
      v110[2] = a1;
      v110[3] = sub_10115CAE4;
      v110[4] = 0;
      *((void *)&v149 + 1) = v110;
      ctu::RestModule::observeProperty();
      int64_t v111 = (capabilities::ct *)sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      if (capabilities::ct::getDeviceEvoType(v111))
      {
        sub_100058DB0(&aBlock, "/cc/props/reg_type_of_evo");
        int64_t v112 = operator new(0x28uLL);
        *int64_t v112 = off_101A980D8;
        v112[1] = a1 + 952;
        v112[2] = a1;
        v112[3] = sub_10115CB94;
        v112[4] = 0;
        *((void *)&v149 + 1) = v112;
        ctu::RestModule::observeProperty();
        sub_10003F600(&buf);
        if (SHIBYTE(v143) < 0) {
          operator delete(aBlock);
        }
      }
      sub_100058DB0(&aBlock, "/cc/props/effective_data_roaming_setting");
      __int16 v113 = operator new(0x28uLL);
      *__int16 v113 = off_101A98158;
      v113[1] = a1 + 976;
      v113[2] = a1;
      v113[3] = sub_10115CDF4;
      v113[4] = 0;
      *((void *)&v149 + 1) = v113;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      unint64_t v114 = operator new(0x20uLL);
      uint64_t v115 = (NSObject **)(a1 + 24);
      *unint64_t v114 = off_101A981D8;
      v114[1] = a1;
      v114[2] = sub_10115D0EC;
      v114[3] = 0;
      *((void *)&v149 + 1) = v114;
      uint64_t v144 = 0;
      v140[2] = 0;
      PersonalitiesTracker::bind();
      sub_100100490(&v139);
      sub_10010040C(&aBlock);
      sub_100100388(&buf);
      sub_100058DB0(&aBlock, "/cc/props/save_data_mode_user_preference");
      uint64_t v116 = operator new(0x28uLL);
      void *v116 = off_101A98258;
      v116[1] = a1 + 1000;
      v116[2] = a1;
      v116[3] = sub_10115DFC4;
      v116[4] = 0;
      *((void *)&v149 + 1) = v116;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/emergency_mode");
      unsigned int v117 = operator new(0x28uLL);
      *unsigned int v117 = off_101A982D8;
      v117[1] = a1 + 876;
      v117[2] = a1;
      v117[3] = sub_10115E27C;
      v117[4] = 0;
      *((void *)&v149 + 1) = v117;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/frontmostapps");
      unsigned int v118 = operator new(0x28uLL);
      *unsigned int v118 = off_101A98358;
      v118[1] = a1 + 1088;
      v118[2] = a1;
      v118[3] = DataServiceController::handleFrontmostAppsChanged_sync;
      v118[4] = 0;
      *((void *)&v149 + 1) = v118;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      sub_100058DB0(&aBlock, "/cc/props/user_visible_apps_changed");
      BOOL v119 = operator new(0x20uLL);
      *BOOL v119 = off_101A983D8;
      v119[1] = a1;
      v119[2] = DataServiceController::appDbUpdateCallback_sync;
      v119[3] = 0;
      *((void *)&v149 + 1) = v119;
      ctu::RestModule::observeEvent();
      __int16 v120 = (capabilities::ct *)sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      if (capabilities::ct::supports5GSlicing(v120))
      {
        sub_100058DB0(&aBlock, "/cc/props/network_slicing_state");
        int v121 = operator new(0x28uLL);
        *int v121 = off_101A98458;
        v121[1] = a1 + 1120;
        v121[2] = a1;
        v121[3] = DataServiceController::handleNetworkSlicingSupportChanged_sync;
        v121[4] = 0;
        *((void *)&v149 + 1) = v121;
        ctu::RestModule::observeProperty();
        sub_10003F600(&buf);
        if (SHIBYTE(v143) < 0) {
          operator delete(aBlock);
        }
        sub_100D3EB10(a1 + 1152);
      }
      sub_100058DB0(&aBlock, "/cc/props/carrier_entitlements_info");
      long long v122 = operator new(0x28uLL);
      *long long v122 = off_101A984D8;
      v122[1] = a1 + 1048;
      v122[2] = a1;
      v122[3] = sub_10115EB70;
      v122[4] = 0;
      *((void *)&v149 + 1) = v122;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v143) < 0) {
        operator delete(aBlock);
      }
      aBlock = (uint64_t (**)())_NSConcreteStackBlock;
      uint64_t v142 = 0x40000000;
      uint64_t v143 = sub_101192920;
      uint64_t v144 = &unk_101A98548;
      uint64_t v145 = a1 + 8;
      int64x2_t v146 = sub_10115EBE4;
      uint64_t v147 = 0;
      unsigned int v123 = _Block_copy(&aBlock);
      sub_10003E168(&v128, (void *)(a1 + 8));
      int64_t v124 = *v115;
      unsigned int v130 = *v115;
      if (v123) {
        __int16 v125 = _Block_copy(v123);
      }
      else {
        __int16 v125 = 0;
      }
      unint64_t v131 = v125;
      dispatch_retain(v124);
      long long buf = 0u;
      long long v149 = 0u;
      sub_10119296C(v132, v124, v125);
      sub_10119296C(v133, v132[0], v132[1]);
      sub_10119296C((NSObject **)v134, v133[0], v133[1]);
      uint64_t v139 = 0;
      sub_10119296C((NSObject **)v135, v134[0], v134[1]);
      sub_10119296C(v136, v135[0], v135[1]);
      sub_10119296C(v137, v136[0], v136[1]);
      sub_10119296C((NSObject **)v138, v137[0], v137[1]);
      sub_10119296C(v140, v138[0], v138[1]);
      sub_101193218((uint64_t)v138);
      sub_101193218((uint64_t)v137);
      sub_101193218((uint64_t)v136);
      uint64_t v139 = &off_101A98568;
      sub_101193218((uint64_t)v135);
      sub_101193218((uint64_t)v134);
      sub_100FB0478((uint64_t *)&v139, (uint64_t *)&v149 + 1);
      sub_100FB0B08((uint64_t *)&v139);
      sub_101193218((uint64_t)v133);
      sub_101193218((uint64_t)v132);
      if (v129) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v129 + 16), 1uLL, memory_order_relaxed);
      }
      operator new();
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v76 + 48))(v76, a1 + 3440);
  goto LABEL_154;
}

void sub_101156918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,dispatch_group_t group,dispatch_group_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101156F7C(uint64_t a1, BOOL a2)
{
  uint64_t v4 = a1 + 4176;
  int v5 = *(unsigned __int8 *)(a1 + 832);
  atomic_store(v5, (unsigned __int8 *)(a1 + 4176));
  int v6 = *(unsigned __int8 *)(a1 + 4377);
  uint64_t v7 = *(void *)(a1 + 4384);
  *(void *)(a1 + 4384) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (v5)
  {
    *(unsigned char *)(v4 + 201) = 1;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    Registry::getTimerService(&v35, *(Registry **)(a1 + 104));
    if (v35)
    {
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v9 = *(void *)buf;
      int v8 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v8);
      }
      uint64_t v10 = v35;
      sub_100058DB0(__p, "fIsRadioOffTimer");
      int v11 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v11;
      if (v11) {
        dispatch_retain(v11);
      }
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 1174405120;
      void v29[2] = sub_101168DEC;
      v29[3] = &unk_101A95608;
      v29[4] = a1;
      v29[5] = v9;
      uint64_t v30 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      aBlock = _Block_copy(v29);
      sub_100118A44(v10, (uint64_t)__p, 0, 90000000, &object, &aBlock);
      uint64_t v12 = *(void *)buf;
      *(void *)long long buf = 0;
      uint64_t v13 = *(void *)(a1 + 4384);
      *(void *)(a1 + 4384) = v12;
      if (v13)
      {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        uint64_t v14 = *(void *)buf;
        *(void *)long long buf = 0;
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v34 < 0) {
        operator delete(__p[0]);
      }
      if (v30) {
        std::__shared_weak_count::__release_weak(v30);
      }
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v36) {
      sub_10004D2C8(v36);
    }
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = asStringBool(*(unsigned char *)(a1 + 316));
      uint64_t v17 = asStringBool(*(unsigned char *)(a1 + 315));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I (restore state) fCellularDataIsEnabled changed: %s ==>> %s", buf, 0x16u);
    }
    unsigned __int8 v18 = *(unsigned char *)(a1 + 315);
    *(unsigned char *)(a1 + 316) = v18;
    *(void *)long long buf = 1;
    *(void *)&uint8_t buf[8] = a1 + 3888;
    *(void *)&uint8_t buf[16] = v18;
    sub_1011956A0((uint64_t)buf);
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = asStringBool(a2);
    uint64_t v21 = asStringBool(v5 != 0);
    uint64_t v22 = asStringBool(v6 != 0);
    uint64_t v23 = asStringBool(*(unsigned char *)(v4 + 201));
    *(_DWORD *)long long buf = 136316162;
    *(void *)&uint8_t buf[4] = "handleAirplaneModeChange_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v20;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v38 = v21;
    __int16 v39 = 2080;
    uint64_t v40 = v22;
    __int16 v41 = 2080;
    uint64_t v42 = v23;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: airplane mode %s->%s, radio off %s->%s", buf, 0x34u);
  }
  if (*(unsigned char *)(v4 + 1)) {
    sub_101167730(a1, (uint64_t)"airplane mode");
  }
  else {
    *(unsigned char *)(v4 + 1) = 1;
  }
  uint64_t v24 = *(void *)(a1 + 144);
  uint64_t v25 = *(void *)(v24 + 8);
  uint64_t v26 = *(void *)(v24 + 16);
  while (v25 != v26)
  {
    long long v27 = *(char **)(v25 + 24);
    if (v27) {
      (*(void (**)(char *, BOOL))(*(void *)&v27[*(void *)(*(void *)v27 - 320)] + 264))(&v27[*(void *)(*(void *)v27 - 320)], v5 != 0);
    }
    uint64_t v28 = *(char **)(v25 + 40);
    if (v28) {
      (*(void (**)(char *, BOOL))(*(void *)&v28[*(void *)(*(void *)v28 - 320)] + 264))(&v28[*(void *)(*(void *)v28 - 320)], v5 != 0);
    }
    v25 += 432;
  }
}

void sub_101157418(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011574A0(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 1144) != a2) {
    sub_101167730(a1, (uint64_t)"airplane mode user preference");
  }
}

void *sub_1011574BC(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), a2, a1 + 1024);
  int v5 = *(void **)(a1 + 1024);
  if (v5 != (void *)(a1 + 1032))
  {
    int v6 = (uint64_t *)(a2 + 8);
    while (1)
    {
      uint64_t v7 = *v6;
      int v8 = *((_DWORD *)v5 + 7);
      if (!*v6) {
        break;
      }
      uint64_t v9 = a2 + 8;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          uint64_t v9 = v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if ((uint64_t *)v9 == v6 || v8 < *(_DWORD *)(v9 + 28)) {
        break;
      }
      uint64_t v13 = *((unsigned int *)v5 + 8);
      if (*(_DWORD *)(v9 + 32) != v13) {
        goto LABEL_14;
      }
LABEL_20:
      uint64_t v16 = (void *)v5[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v5[2];
          BOOL v18 = *v17 == (void)v5;
          int v5 = v17;
        }
        while (!v18);
      }
      int v5 = v17;
      if (v17 == (void *)(a1 + 1032)) {
        return result;
      }
    }
    uint64_t v13 = *((unsigned int *)v5 + 8);
LABEL_14:
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v5 + 7));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v20 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I WirelessTechnology: %s", buf, 0xCu);
    }
    __n128 result = (void *)sub_10003B004(*(void *)(a1 + 144), v8);
    if (*(void **)(*(void *)(a1 + 144) + 16) != result)
    {
      __n128 result = (void *)result[3];
      if (result) {
        __n128 result = (void *)(*(uint64_t (**)(void *, uint64_t))(*result + 760))(result, v13);
      }
    }
    goto LABEL_20;
  }
  return result;
}

const void **sub_1011576E4(const void **result)
{
  uint64_t v1 = (const void **)result[81];
  uint64_t v2 = result + 82;
  if (v1 == result + 82) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  uint64_t v44 = (uint64_t)result;
  uint64_t v43 = result + 82;
  while (1)
  {
    uint64_t v48 = sub_10003B004(*(void *)(v3 + 144), *((_DWORD *)v1 + 7));
    __n128 result = *(const void ***)(v3 + 144);
    if (result[2] != (const void *)v48) {
      break;
    }
LABEL_65:
    __int16 v39 = (const void **)v1[1];
    if (v39)
    {
      do
      {
        uint64_t v40 = v39;
        __int16 v39 = (const void **)*v39;
      }
      while (v39);
    }
    else
    {
      do
      {
        uint64_t v40 = (const void **)v1[2];
        BOOL v41 = *v40 == v1;
        uint64_t v1 = v40;
      }
      while (!v41);
    }
    uint64_t v1 = v40;
    if (v40 == v2) {
      return result;
    }
  }
  int v4 = *(_DWORD *)(v48 + 128);
  unsigned int v46 = *((_DWORD *)v1 + 9);
  unsigned int v47 = *((_DWORD *)v1 + 8);
  if (*(void *)(sub_100AEFE40((uint64_t)result, *((_DWORD *)v1 + 7)) + 24))
  {
    uint64_t v5 = sub_100AEFE40(*(void *)(v3 + 144), *((_DWORD *)v1 + 7));
    uint64_t v6 = *(void *)(v5 + 24) + *(void *)(**(void **)(v5 + 24) - 320);
    if ((*(int (**)(uint64_t))(*(void *)v6 + 192))(v6) >= 1)
    {
      uint64_t v7 = sub_100AEFE40(*(void *)(v3 + 144), *((_DWORD *)v1 + 7));
      uint64_t v8 = *(void *)(v7 + 24) + *(void *)(**(void **)(v7 + 24) - 320);
      int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 192))(v8);
    }
  }
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 7));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asString();
    uint64_t v11 = asString();
    uint64_t v12 = asString();
    uint64_t v13 = asString();
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v11;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v57 = v12;
    __int16 v58 = 2080;
    uint64_t v59 = v13;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I dataModeChanged: (change states): old raw = %s, adjusted=%s, actual=%s, oldDataMode = %s", buf, 0x2Au);
  }
  int v14 = *(_DWORD *)(v48 + 128);
  unsigned int v15 = v47;
  if (v14 != v47)
  {
    if (DataUtils::lteishDataMode())
    {
      if (v4 >= 1 && v4 != v47)
      {
        uint64_t v16 = sub_10003B004(*(void *)(v44 + 144), *((_DWORD *)v1 + 7));
        if (*(void *)(*(void *)(v44 + 144) + 16) != v16)
        {
          uint64_t v17 = &dword_1015C55B0;
          do
          {
            BOOL v18 = *(uint64_t **)(v16 + 56);
            uint64_t v19 = *(uint64_t **)(v16 + 64);
            if (v18 != v19)
            {
              uint64_t v20 = *v17;
              do
              {
                uint64_t v21 = *v18;
                uint64_t v22 = (std::__shared_weak_count *)v18[1];
                if (v22) {
                  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v21) {
                  (*(void (**)(uint64_t, uint64_t, const char *, void, uint64_t))(*(void *)v21 + 424))(v21, v20, "Data mode changed and the new data mode may mean different activation blockers", 0, 1);
                }
                if (v22) {
                  sub_10004D2C8(v22);
                }
                v18 += 2;
              }
              while (v18 != v19);
            }
            ++v17;
          }
          while (v17 != dword_1015C55B8);
        }
      }
    }
    *(_DWORD *)(v48 + 128) = v47;
    uint64_t v3 = v44;
    DataServiceController::resetSlicePoliciesOnDataModeChange_sync(v44, *((unsigned int *)v1 + 7));
    uint64_t v2 = v43;
    unsigned int v15 = v47;
  }
  v45 &= 0xFFFFFFFFFFFF0000;
  sub_10116F6BC(v3, *((unsigned int *)v1 + 7), v45, 0, v14 != v15);
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(v3 + 104));
  uint64_t v25 = ServiceMap;
  if (v26 < 0)
  {
    long long v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v26;
  uint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
  if (v30)
  {
    uint64_t v32 = v30[3];
    uint64_t v31 = (std::__shared_weak_count *)v30[4];
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v31);
      char v33 = 0;
      goto LABEL_34;
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  std::mutex::unlock(v25);
  uint64_t v31 = 0;
  char v33 = 1;
LABEL_34:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v32 + 96))(&cf, v32, *((unsigned int *)v1 + 7), 1, @"AllowedDataModesForServices", 0, 0);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  if (cf) {
    char v34 = sub_100080934;
  }
  else {
    char v34 = 0;
  }
  if (!v34) {
    goto LABEL_62;
  }
  CFTypeRef v51 = cf;
  uint64_t v52 = 0;
  if (cf)
  {
    CFRetain(cf);
    CFTypeRef v55 = v51;
    if (v51) {
      CFRetain(v51);
    }
  }
  else
  {
    CFTypeRef v55 = 0;
  }
  uint64_t v54 = 0;
  *(void *)long long buf = 0;
  sub_100044D6C(buf, &v55);
  if (*(void *)buf) {
    uint64_t v35 = sub_100083F10;
  }
  else {
    uint64_t v35 = 0;
  }
  if (v35) {
    sub_100449580(&v54, (const void **)buf);
  }
  sub_100044D00((const void **)buf);
  uint64_t v52 = v54;
  uint64_t v54 = 0;
  sub_100044D00(&v54);
  sub_1000577C4(&v55);
  sub_1000577C4(&v51);
  if (v52) {
    uint64_t v36 = sub_100083F10;
  }
  else {
    uint64_t v36 = 0;
  }
  if (!v36)
  {
LABEL_61:
    sub_100044D00(&v52);
LABEL_62:
    uint64_t v38 = *(void *)(v48 + 24);
    if (v38) {
      (*(void (**)(uint64_t, void, void))(*(void *)v38 + 744))(v38, v47, v46);
    }
    __n128 result = sub_1000577C4(&cf);
    goto LABEL_65;
  }
  if (*(unsigned char *)(v3 + 312))
  {
    int v37 = *((_DWORD *)v1 + 7);
    sub_100058DB0(__p, "Data Mode changed");
    *(_DWORD *)long long buf = v37;
    uint8_t buf[4] = 0;
    if (SHIBYTE(v50) < 0)
    {
      sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
      uint64_t v57 = v50;
    }
    sub_10011AE40();
    if (SHIBYTE(v57) < 0) {
      operator delete(*(void **)&buf[8]);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_61;
  }
  uint64_t v42 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "handleDataModeChanged_sync";
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
  }
  sub_100044D00(&v52);
  return sub_1000577C4(&cf);
}

void sub_101157D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,int a26,const void *a27,const void *a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_100044D00(&a27);
  sub_1000577C4(&a28);
  _Unwind_Resume(a1);
}

uint64_t *sub_101157E48(uint64_t *result)
{
  uint64_t v1 = (uint64_t *)result[78];
  uint64_t v2 = result + 79;
  if (v1 != result + 79)
  {
    uint64_t v3 = result;
    do
    {
      __n128 result = (uint64_t *)sub_10003B004(v3[18], *((_DWORD *)v1 + 7));
      int v4 = (uint64_t **)result;
      if (*(uint64_t **)(v3[18] + 16) != result)
      {
        uint64_t v5 = *(NSObject **)(*(uint64_t (**)(uint64_t, void))(*(void *)v3[6] + 16))(v3[6], *((unsigned int *)v1 + 7));
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = asStringBool(*((unsigned char *)v1 + 32));
          *(_DWORD *)long long buf = 136315138;
          uint64_t v16 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I handleDataAttachRawStatusChanged: %s", buf, 0xCu);
        }
        uint64_t v7 = *v4;
        uint64_t v8 = v4[1];
        while (v7 != v8)
        {
          uint64_t v9 = *v7;
          uint64_t v10 = (std::__shared_weak_count *)v7[1];
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v9) {
            (*(void (**)(uint64_t, void))(*(void *)v9 + 240))(v9, *((unsigned __int8 *)v1 + 32));
          }
          if (v10) {
            sub_10004D2C8(v10);
          }
          v7 += 2;
        }
        __n128 result = v4[3];
        if (result)
        {
          uint64_t v11 = *result;
          if (*((unsigned char *)v1 + 32)) {
            __n128 result = (uint64_t *)(*(uint64_t (**)(void))(v11 + 768))();
          }
          else {
            __n128 result = (uint64_t *)(*(uint64_t (**)(void))(v11 + 776))();
          }
        }
      }
      uint64_t v12 = (uint64_t *)v1[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (uint64_t *)v1[2];
          BOOL v14 = *v13 == (void)v1;
          uint64_t v1 = v13;
        }
        while (!v14);
      }
      uint64_t v1 = v13;
    }
    while (v13 != v2);
  }
  return result;
}

void sub_101158074(_Unwind_Exception *exception_object)
{
}

void sub_101158094(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v3 = *(void **)(a1 + 672);
    int v4 = (void *)(a1 + 680);
    if (v3 != (void *)(a1 + 680))
    {
      uint64_t v5 = (void *)(a2 + 8);
      while (1)
      {
        uint64_t v6 = sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)v3 + 7));
        uint64_t v7 = v6;
        if (*(void *)(*(void *)(a1 + 144) + 16) != v6)
        {
          if (*(void *)(v6 + 24)) {
            break;
          }
        }
LABEL_42:
        uint64_t v32 = (void *)v3[1];
        if (v32)
        {
          do
          {
            char v33 = v32;
            uint64_t v32 = (void *)*v32;
          }
          while (v32);
        }
        else
        {
          do
          {
            char v33 = (void *)v3[2];
            BOOL v34 = *v33 == (void)v3;
            uint64_t v3 = v33;
          }
          while (!v34);
        }
        uint64_t v3 = v33;
        if (v33 == v4) {
          return;
        }
      }
      uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v3 + 7));
      uint64_t v9 = v8;
      uint64_t v10 = *v5;
      if (!*v5) {
        goto LABEL_17;
      }
      int v11 = *((_DWORD *)v3 + 7);
      uint64_t v12 = v5;
      do
      {
        int v13 = *(_DWORD *)(v10 + 28);
        BOOL v14 = v13 < v11;
        if (v13 >= v11) {
          unsigned int v15 = (uint64_t *)v10;
        }
        else {
          unsigned int v15 = (uint64_t *)(v10 + 8);
        }
        if (!v14) {
          uint64_t v12 = (void *)v10;
        }
        uint64_t v10 = *v15;
      }
      while (*v15);
      if (v12 != v5 && v11 >= *((_DWORD *)v12 + 7)) {
        int v16 = *((_DWORD *)v12 + 8);
      }
      else {
LABEL_17:
      }
        int v16 = 0;
      uint64_t v17 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = asString();
        uint64_t v19 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I registrationStatus %s => %s", buf, 0x16u);
      }
      uint64_t v20 = *(void *)(a1 + 152);
      uint64_t v21 = *(std::__shared_weak_count **)(v7 + 424);
      *(void *)long long buf = *(void *)(v7 + 416);
      *(void *)&uint8_t buf[8] = v21;
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v22 = sub_10003AEB0(v20, (uint64_t)buf);
        sub_10004D2C8(v21);
        uint64_t v23 = *((unsigned int *)v3 + 8);
        if (!v22)
        {
LABEL_33:
          (*(void (**)(void, uint64_t))(**(void **)(v7 + 24) + 784))(*(void *)(v7 + 24), v23);
          uint64_t v28 = *(uint64_t **)v7;
          unsigned int v29 = *(uint64_t **)(v7 + 8);
          while (v28 != v29)
          {
            uint64_t v30 = *v28;
            uint64_t v31 = (std::__shared_weak_count *)v28[1];
            if (v31) {
              atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v30) {
              (*(void (**)(uint64_t, void))(*(void *)v30 + 248))(v30, *((unsigned int *)v3 + 8));
            }
            if (v31) {
              sub_10004D2C8(v31);
            }
            v28 += 2;
          }
          goto LABEL_42;
        }
      }
      else
      {
        BOOL v24 = sub_10003AEB0(v20, (uint64_t)buf);
        uint64_t v23 = *((unsigned int *)v3 + 8);
        if (!v24) {
          goto LABEL_33;
        }
      }
      if (v16 == 5 && v23 == 4 || v23 == 5 && v16 == 4)
      {
        uint64_t v25 = *v9;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Domestic roaming transition between networks", buf, 2u);
        }
        uint64_t v26 = *((unsigned int *)v3 + 7);
        long long v27 = operator new(8uLL);
        std::string __p = v27;
        *long long v27 = &_mh_execute_header;
        uint64_t v36 = v27 + 1;
        int v37 = v27 + 1;
        (*(void (**)(uint64_t, uint64_t, const char *, void, uint64_t, void **))(*(void *)a1 + 176))(a1, v26, "Domestic roaming", 0, 36, &__p);
        if (__p)
        {
          uint64_t v36 = __p;
          operator delete(__p);
        }
        uint64_t v23 = *((unsigned int *)v3 + 8);
      }
      goto LABEL_33;
    }
  }
}

void sub_10115841C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101158454(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 696);
  uint64_t v2 = (void *)(result + 704);
  if (v1 != (void *)(result + 704))
  {
    uint64_t v3 = result;
    do
    {
      __n128 result = sub_10003B004(*(void *)(v3 + 144), *((_DWORD *)v1 + 8));
      uint64_t v4 = result;
      if (*(void *)(*(void *)(v3 + 144) + 16) != result)
      {
        uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 8));
        uint64_t v6 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          MCCAndMNC::getStringValue((uint64_t *)&__p, (MCCAndMNC *)(v1 + 5));
          p_p = &__p;
          if (v24 < 0) {
            p_p = (long long *)__p;
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v26 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I NewServingNetwork: %s", buf, 0xCu);
          if (SHIBYTE(v24) < 0) {
            operator delete((void *)__p);
          }
        }
        __n128 result = rest::operator==();
        if ((result & 1) == 0)
        {
          if (MCCAndMNC::operator==())
          {
            if (*((_DWORD *)v1 + 26) == *(_DWORD *)(v4 + 384))
            {
              if (*((unsigned __int8 *)v1 + 108) == *(unsigned __int8 *)(v4 + 388)) {
                uint64_t v8 = 19;
              }
              else {
                uint64_t v8 = 25;
              }
            }
            else
            {
              uint64_t v8 = 23;
            }
          }
          else
          {
            uint64_t v8 = 19;
          }
          uint64_t v9 = *v5;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = asStringConnectionStateChangeReason();
            LODWORD(__p) = 136315138;
            *(void *)((char *)&__p + 4) = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I NewServingNetwork: %s", (uint8_t *)&__p, 0xCu);
          }
          MCC::operator=();
          MCC::operator=();
          int v11 = *((_DWORD *)v1 + 26);
          *(_WORD *)(v4 + 388) = *((_WORD *)v1 + 54);
          *(_DWORD *)(v4 + 384) = v11;
          uint64_t v12 = *((unsigned int *)v1 + 8);
          int v13 = operator new(8uLL);
          uint64_t v20 = v13;
          *int v13 = &_mh_execute_header;
          uint64_t v21 = v13 + 1;
          BOOL v22 = v13 + 1;
          (*(void (**)(uint64_t, uint64_t, const char *, void, uint64_t, void **))(*(void *)v3 + 176))(v3, v12, "NewServingNetwork", 0, 36, &v20);
          if (v20)
          {
            uint64_t v21 = v20;
            operator delete(v20);
          }
          sub_1011706F8(v3, *((_DWORD *)v1 + 8), v8, 0);
          uint64_t v14 = *((unsigned int *)v1 + 8);
          sub_100058DB0(&__p, "newServingNetwork");
          (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, uint64_t))(*(void *)v3 + 2072))(v3, v14, 1, &__p, v8);
          if (SHIBYTE(v24) < 0) {
            operator delete((void *)__p);
          }
          DataServiceController::reactivateAsserted_sync(v3, *((unsigned int *)v1 + 8), v8, 1);
          int v15 = *((_DWORD *)v1 + 8);
          if (v15 == (*(unsigned int (**)(uint64_t))(*(void *)v3 + 1088))(v3))
          {
            sub_100CC9534((uint64_t)&__p, 147);
            int v16 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
            sub_100A01420(v16, (uint64_t)&__p);
            if (*((void *)&__p + 1))
            {
              uint64_t v24 = *((void *)&__p + 1);
              operator delete(*((void **)&__p + 1));
            }
          }
          __n128 result = (*(uint64_t (**)(void, void))(**(void **)(v3 + 4240) + 64))(*(void *)(v3 + 4240), *((unsigned int *)v1 + 8));
        }
      }
      uint64_t v17 = (void *)v1[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v1[2];
          BOOL v19 = *v18 == (void)v1;
          uint64_t v1 = v18;
        }
        while (!v19);
      }
      uint64_t v1 = v18;
    }
    while (v18 != v2);
  }
  return result;
}

void sub_101158854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011588A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 312))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 312), *(Registry **)(a1 + 104));
    uint64_t v3 = ServiceMap;
    uint64_t v4 = "16IPCU_CellProfile";
    if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
    {
      uint64_t v5 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        uint64_t v4 = (const char *)v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v4;
    uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&buf);
    if (v8)
    {
      uint64_t v9 = v8[3];
      uint64_t v10 = (std::__shared_weak_count *)v8[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        if (!v9)
        {
LABEL_14:
          if ((v12 & 1) == 0) {
            sub_10004D2C8(v10);
          }
          uint64_t v14 = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 104));
          int v15 = v14;
          if (v16 < 0)
          {
            uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v18 = 5381;
            do
            {
              uint64_t v16 = v18;
              unsigned int v19 = *v17++;
              uint64_t v18 = (33 * v18) ^ v19;
            }
            while (v19);
          }
          std::mutex::lock(v14);
          *(void *)&long long buf = v16;
          uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&buf);
          if (v20)
          {
            uint64_t v21 = v20[3];
            BOOL v22 = (std::__shared_weak_count *)v20[4];
            if (v22)
            {
              atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v15);
              atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v22);
              char v23 = 0;
              if (!v21)
              {
LABEL_65:
                if ((v23 & 1) == 0) {
                  sub_10004D2C8(v22);
                }
                return;
              }
LABEL_25:
              char v40 = v23;
              uint64_t v24 = *(atomic_ullong **)(a1 + 112);
              __p[0] = *(void **)(a1 + 104);
              __p[1] = v24;
              if (v24) {
                atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
              }
              __int16 v39 = v22;
              subscriber::makeSimSlotRange();
              if (__p[1]) {
                sub_10004D2C8((std::__shared_weak_count *)__p[1]);
              }
              uint64_t v26 = (unsigned int *)*((void *)&buf + 1);
              uint64_t v25 = (unsigned int *)buf;
              if ((void)buf != *((void *)&buf + 1))
              {
                long long v27 = v46;
                while ((v27(*v25) & 1) == 0)
                {
                  if (++v25 == v26)
                  {
                    uint64_t v25 = v26;
                    break;
                  }
                }
                uint64_t v28 = (unsigned int *)*((void *)&buf + 1);
                if (v25 != *((unsigned int **)&buf + 1))
                {
                  unsigned int v29 = (uint64_t *)(a1 + 384);
                  do
                  {
                    uint64_t v30 = *v25;
                    uint64_t v31 = *v29;
                    if (!*v29) {
                      goto LABEL_46;
                    }
                    uint64_t v32 = a1 + 384;
                    do
                    {
                      int v33 = *(_DWORD *)(v31 + 32);
                      BOOL v34 = v33 < (int)v30;
                      if (v33 >= (int)v30) {
                        uint64_t v35 = (uint64_t *)v31;
                      }
                      else {
                        uint64_t v35 = (uint64_t *)(v31 + 8);
                      }
                      if (!v34) {
                        uint64_t v32 = v31;
                      }
                      uint64_t v31 = *v35;
                    }
                    while (*v35);
                    if ((uint64_t *)v32 != v29 && (int)v30 >= *(_DWORD *)(v32 + 32))
                    {
                      __p[0] = 0;
                      __p[1] = 0;
                      uint64_t v42 = 0;
                      if (*(char *)(v32 + 95) < 0)
                      {
                        sub_10004FC84(__p, *(void **)(v32 + 72), *(void *)(v32 + 80));
                      }
                      else
                      {
                        *(_OWORD *)long long __p = *(_OWORD *)(v32 + 72);
                        uint64_t v42 = *(void *)(v32 + 88);
                      }
                    }
                    else
                    {
LABEL_46:
                      __p[0] = 0;
                      __p[1] = 0;
                      uint64_t v42 = 0;
                      sub_100058DB0(__p, "");
                    }
                    if ((*(unsigned int (**)(uint64_t, uint64_t, void **))(*(void *)v21 + 32))(v21, v30, __p))
                    {
                      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 16))(v21, v30, 0);
                      uint64_t v36 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)uint64_t v43 = 136315138;
                        uint64_t v44 = "handleTrackerStateChange_sync";
                        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn", v43, 0xCu);
                      }
                      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 840))(a1, v30, 17, 0xFFFFFFFFLL, 0);
                      int v37 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)uint64_t v43 = 136315138;
                        uint64_t v44 = "handleTrackerStateChange_sync";
                        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn", v43, 0xCu);
                      }
                    }
                    if (SHIBYTE(v42) < 0) {
                      operator delete(__p[0]);
                    }
                    uint64_t v38 = v25 + 1;
                    uint64_t v25 = v26;
                    if (v38 != v26)
                    {
                      uint64_t v25 = v38;
                      while ((v27(*v25) & 1) == 0)
                      {
                        if (++v25 == v26)
                        {
                          uint64_t v25 = v26;
                          break;
                        }
                      }
                    }
                  }
                  while (v25 != v28);
                }
              }
              BOOL v22 = v39;
              char v23 = v40;
              goto LABEL_65;
            }
          }
          else
          {
            uint64_t v21 = 0;
          }
          std::mutex::unlock(v15);
          BOOL v22 = 0;
          char v23 = 1;
          if (!v21) {
            goto LABEL_65;
          }
          goto LABEL_25;
        }
LABEL_13:
        (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    std::mutex::unlock(v3);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v9) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  int v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "handleTrackerStateChange_sync";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&buf, 0xCu);
  }
}

void sub_101158D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, char a11, uint64_t a12, uint64_t a13, void *__p, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_101158E0C(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)a1;
  if (!*(unsigned char *)(a1 + 312))
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "handleVoWiFiProvChanged_sync";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&buf, 0xCu);
    }
    return;
  }
  if (sub_100E996C4(a2, a1 + 568)) {
    return;
  }
  *((void *)&buf + 1) = 0;
  uint64_t v73 = 0;
  *(void *)&long long buf = (char *)&buf + 8;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)&buf + 1, (Registry *)v2[13]);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v71 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v71);
  if (!v10)
  {
    uint64_t v11 = 0;
    goto LABEL_12;
  }
  uint64_t v11 = v10[3];
  char v12 = (std::__shared_weak_count *)v10[4];
  if (!v12)
  {
LABEL_12:
    std::mutex::unlock(v5);
    char v12 = 0;
    char v13 = 1;
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v13 = 0;
LABEL_13:
  uint64_t v66 = v2;
  if (v11)
  {
    char v64 = v13;
    uint64_t v63 = v12;
    int v65 = (*(uint64_t (**)(void *))(*v2 + 1088))(v2);
    int v15 = (void *)v2[71];
    uint64_t v16 = v2 + 72;
    if (v15 != v2 + 72)
    {
      do
      {
        uint64_t v17 = sub_100046F68((uint64_t)a2, (void **)v15 + 4);
        if (a2 + 1 == v17
          || *((_DWORD *)v17 + 14) != *((_DWORD *)v15 + 14)
          || *((unsigned __int8 *)v17 + 60) != *((unsigned __int8 *)v15 + 60)
          || (sub_1005A0BB8((unsigned __int8 *)v17 + 64, (unsigned __int8 *)v15 + 64) & 1) == 0)
        {
          uint64_t v18 = *((unsigned __int8 *)v15 + 55);
          if ((v18 & 0x80u) != 0) {
            uint64_t v18 = v15[5];
          }
          if (v18)
          {
            uint64_t v19 = v66[18];
            uint64_t v20 = *(void *)(v19 + 8);
            uint64_t v21 = *(void *)(v19 + 16);
            while (v20 != v21)
            {
              uint64_t v23 = *(void *)(v20 + 416);
              BOOL v22 = *(std::__shared_weak_count **)(v20 + 424);
              if (v22)
              {
                atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v22);
              }
              if (sub_10001D294((unsigned __int8 *)(v23 + 24), (unsigned __int8 *)v15 + 32))
              {
                uint64_t v24 = v66[18];
                uint64_t v25 = *(void *)(v24 + 8);
                uint64_t v26 = *(void *)(v24 + 16);
                while (1)
                {
                  if (v25 == v26) {
                    __assert_rtn("at", "PerPersonalityDataContainer.h", 85, "0");
                  }
                  uint64_t v28 = *(void *)(v25 + 416);
                  long long v27 = *(std::__shared_weak_count **)(v25 + 424);
                  if (v27)
                  {
                    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v27);
                  }
                  if (sub_10001D294((unsigned __int8 *)(v28 + 24), (unsigned __int8 *)v15 + 32)) {
                    break;
                  }
                  v25 += 432;
                }
                int v70 = 0;
                uint64_t v30 = *(void *)(v25 + 416);
                unsigned int v29 = *(std::__shared_weak_count **)(v25 + 424);
                if (v29)
                {
                  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
                  int v31 = *(_DWORD *)(v30 + 52);
                  sub_10004D2C8(v29);
                }
                else
                {
                  int v31 = *(_DWORD *)(v30 + 52);
                }
                int v70 = v31;
                uint64_t v32 = v66[14];
                *(void *)&long long v71 = v66[13];
                *((void *)&v71 + 1) = v32;
                if (v32) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
                }
                char isValidSimSlot = subscriber::isValidSimSlot();
                if (*((void *)&v71 + 1)) {
                  sub_10004D2C8(*((std::__shared_weak_count **)&v71 + 1));
                }
                if ((isValidSimSlot & 1) == 0) {
                  int v70 = v65;
                }
                LOBYTE(v71) = *((_DWORD *)v15 + 14) != 0;
                sub_1004191E8((uint64_t)&buf, &v70, &v71);
                break;
              }
              v20 += 432;
            }
          }
        }
        BOOL v34 = (void *)v15[1];
        if (v34)
        {
          do
          {
            uint64_t v35 = v34;
            BOOL v34 = (void *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v35 = (void *)v15[2];
            BOOL v36 = *v35 == (void)v15;
            int v15 = v35;
          }
          while (!v36);
        }
        int v15 = v35;
        uint64_t v2 = v66;
      }
      while (v35 != v16);
    }
    int v37 = (_OWORD *)buf;
    char v12 = v63;
    char v13 = v64;
    if ((long long *)buf != (long long *)((char *)&buf + 8))
    {
      do
      {
        (*(void (**)(uint64_t, void, void))(*(void *)v11 + 16))(v11, *((unsigned int *)v37 + 7), 0);
        uint64_t v38 = (void *)*((void *)v37 + 1);
        if (v38)
        {
          do
          {
            __int16 v39 = v38;
            uint64_t v38 = (void *)*v38;
          }
          while (v38);
        }
        else
        {
          do
          {
            __int16 v39 = (_OWORD *)*((void *)v37 + 2);
            BOOL v36 = *(void *)v39 == (void)v37;
            int v37 = v39;
          }
          while (!v36);
        }
        int v37 = v39;
      }
      while (v39 != (long long *)((char *)&buf + 8));
    }
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  char v40 = v2[5];
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v71) = 136315138;
    *(void *)((char *)&v71 + 4) = "handleVoWiFiProvChanged_sync";
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn", (uint8_t *)&v71, 0xCu);
  }
  uint64_t v41 = v2[18];
  uint64_t v42 = *(void *)(v41 + 8);
  for (uint64_t i = *(void *)(v41 + 16); v42 != i; v42 += 432)
  {
    uint64_t v45 = *(void *)(v42 + 416);
    uint64_t v44 = *(std::__shared_weak_count **)(v42 + 424);
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v46 = *(unsigned int *)(v45 + 52);
      sub_10004D2C8(v44);
    }
    else
    {
      uint64_t v46 = *(unsigned int *)(v45 + 52);
    }
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, void))(*v2 + 840))(v2, v46, 18, 0xFFFFFFFFLL, 0);
  }
  unsigned int v47 = v2[5];
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v71) = 136315138;
    *(void *)((char *)&v71 + 4) = "handleVoWiFiProvChanged_sync";
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn", (uint8_t *)&v71, 0xCu);
  }
  uint64_t v48 = (_OWORD *)buf;
  if ((long long *)buf != (long long *)((char *)&buf + 8))
  {
    do
    {
      uint64_t v49 = (void *)sub_100AEFE40(v2[18], *((_DWORD *)v48 + 7));
      CFTypeRef v51 = (uint64_t *)v49[7];
      uint64_t v50 = (uint64_t *)v49[8];
      while (v51 != v50)
      {
        uint64_t v53 = *v51;
        uint64_t v52 = (std::__shared_weak_count *)v51[1];
        if (v52) {
          atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        for (uint64_t j = 0; j != 2; ++j)
        {
          if (v53)
          {
            uint64_t v55 = dword_1015C55B0[j];
            if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v53 + 56))(v53, v55)) {
              (*(void (**)(uint64_t, uint64_t, const char *, void, void))(*(void *)v53 + 424))(v53, v55, "VoWiFi updated", 0, 0);
            }
          }
        }
        if (v52) {
          sub_10004D2C8(v52);
        }
        v51 += 2;
      }
      uint64_t v56 = *((unsigned int *)v48 + 7);
      uint64_t v68 = 0;
      long long v69 = 0;
      long long __p = 0;
      uint64_t v57 = operator new(8uLL);
      long long __p = v57;
      void *v57 = &_mh_execute_header;
      uint64_t v68 = v57 + 1;
      long long v69 = v57 + 1;
      uint64_t v2 = v66;
      (*(void (**)(void *, uint64_t, const char *, uint64_t, uint64_t, void **))(*v66 + 176))(v66, v56, "VoWiFiProvChanged", 1, 36, &__p);
      if (__p)
      {
        uint64_t v68 = __p;
        operator delete(__p);
      }
      uint64_t v58 = v49[3];
      if (v58)
      {
        uint64_t v59 = v66[5];
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          int v60 = *((unsigned __int8 *)v48 + 32);
          LODWORD(v71) = 67109120;
          DWORD1(v71) = v60;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I updateVoWiFiProvInfo_sync %d", (uint8_t *)&v71, 8u);
          uint64_t v58 = v49[3];
        }
        (*(void (**)(uint64_t, void))(*(void *)v58 + 896))(v58, *((unsigned __int8 *)v48 + 32));
      }
      uint64_t v61 = (void *)*((void *)v48 + 1);
      if (v61)
      {
        do
        {
          uint64_t v62 = v61;
          uint64_t v61 = (void *)*v61;
        }
        while (v61);
      }
      else
      {
        do
        {
          uint64_t v62 = (_OWORD *)*((void *)v48 + 2);
          BOOL v36 = *(void *)v62 == (void)v48;
          uint64_t v48 = v62;
        }
        while (!v36);
      }
      uint64_t v48 = v62;
    }
    while (v62 != (long long *)((char *)&buf + 8));
  }
  sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
}

void sub_1011595B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23)
{
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  sub_1000346F8((uint64_t)&a22, a23);
  _Unwind_Resume(a1);
}

void sub_101159650(uint64_t a1, uint64_t a2)
{
  void (***v16)(uint64_t *__return_ptr, void, uint64_t);
  char v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  void *v27;
  void *v28;
  BOOL v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  void **v32;
  NSObject *v33;
  void **v34;
  void **v35;
  int v36;
  char v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t *v47;
  void *__p[2];
  uint64_t v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unsigned char buf[24];
  uint64_t v57;

  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v3 = *(void ***)(a1 + 592);
    uint64_t v4 = (void **)(a1 + 600);
    if (v3 != (void **)(a1 + 600))
    {
      uint64_t v45 = a1 + 592;
      unsigned int v47 = (uint64_t *)(a2 + 8);
      do
      {
        uint64_t v6 = sub_100046F68(a2, v3 + 4);
        unsigned int v7 = v47;
        if (v47 != (uint64_t *)v6)
        {
          unsigned int v7 = (uint64_t *)*((unsigned int *)v6 + 14);
          if (v7 == *((_DWORD *)v3 + 14))
          {
            unsigned int v7 = (uint64_t *)*((unsigned int *)v6 + 15);
            if (v7 == *((_DWORD *)v3 + 15))
            {
              unsigned int v7 = (uint64_t *)*((unsigned __int8 *)v6 + 64);
              if (v7 == *((unsigned __int8 *)v3 + 64)) {
                goto LABEL_60;
              }
            }
          }
        }
        uint64_t v50 = 0;
        CFTypeRef v51 = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 104));
        unsigned int v9 = ServiceMap;
        if (v10 < 0)
        {
          uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v12 = 5381;
          do
          {
            uint64_t v10 = v12;
            unsigned int v13 = *v11++;
            uint64_t v12 = (33 * v12) ^ v13;
          }
          while (v13);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v10;
        uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
        if (v14)
        {
          uint64_t v16 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v14[3];
          int v15 = (std::__shared_weak_count *)v14[4];
          if (v15)
          {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v9);
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v15);
            uint64_t v17 = 0;
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        std::mutex::unlock(v9);
        int v15 = 0;
        uint64_t v17 = 1;
LABEL_17:
        (**v16)(&v50, v16, (uint64_t)(v3 + 4));
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        if (!v50
          || (*(unsigned char *)(v50 + 49) ? (uint64_t v18 = 1) : (uint64_t v18 = *(unsigned int *)(v50 + 52)),
              !sub_100AF2240(*(void *)(a1 + 144), v18)))
        {
          uint64_t v19 = 3;
          goto LABEL_56;
        }
        if (*(unsigned char *)(v50 + 49))
        {
          if (*(unsigned char *)(v50 + 49) != 1)
          {
            uint64_t v21 = 0;
            goto LABEL_52;
          }
          DataServiceController::getConnection_sync(a1, v18, 26, (uint64_t *)buf);
        }
        else
        {
          DataServiceController::getConnection_sync(a1, v18, 17, (uint64_t *)buf);
        }
        uint64_t v20 = *(void *)buf;
        uint64_t v21 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)buf)
        {
          uint64_t v46 = *(std::__shared_weak_count **)&buf[8];
          BOOL v22 = (*(uint64_t (**)(void, void, BOOL))(**(void **)buf + 376))(*(void *)buf, 0, *((_DWORD *)v3 + 14) != 0);
          uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v20 + 376))(v20, 1, *((_DWORD *)v3 + 15) != 0);
          uint64_t v24 = (*(uint64_t (**)(uint64_t, BOOL))(*(void *)v20 + 384))(v20, (v3[7] & 3) == 2);
          uint64_t v25 = sub_10003B004(*(void *)(a1 + 144), v18);
          if (*(void *)(*(void *)(a1 + 144) + 16) == v25)
          {
            BOOL v36 = 0;
          }
          else
          {
            uint64_t v54 = 0;
            uint64_t v55 = 0;
            (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 1784))(&v54, a1, v18);
            if (v54)
            {
              uint64_t v43 = v22;
              uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 160))(v54);
              long long v27 = *(void **)v25;
              uint64_t v28 = *(void **)(v25 + 8);
              unsigned int v29 = *(void *)v25 == (void)v28;
              if (v26)
              {
                if (*(void **)v25 == v28)
                {
                  LOBYTE(v44) = 0;
                }
                else
                {
                  LOBYTE(v44) = 0;
                  do
                  {
                    if (*v27)
                    {
                      uint64_t v30 = *(std::__shared_weak_count **)(a1 + 112);
                      uint64_t v52 = *(void *)(a1 + 104);
                      uint64_t v53 = v30;
                      if (v30) {
                        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      PersonalityIdFromSlotIdEx();
                      if (v53) {
                        sub_10004D2C8(v53);
                      }
                      int v31 = buf[23];
                      if (buf[23] < 0) {
                        int v31 = *(void *)&buf[8];
                      }
                      if (v31)
                      {
                        uint64_t v32 = sub_100046F68(v45, (void **)buf);
                        if (v4 != v32
                          && (*(unsigned int (**)(void))(*(void *)*v27 + 472))(*v27) != 17
                          && (*(unsigned int (**)(void))(*(void *)*v27 + 472))(*v27) != 26)
                        {
                          uint64_t v44 = v44 & 1 | (*(uint64_t (**)(void, uint64_t, BOOL))(*(void *)*v27 + 376))(*v27, 1, *((_DWORD *)v32 + 15) != 0);
                        }
                      }
                      if ((buf[23] & 0x80000000) != 0) {
                        operator delete(*(void **)buf);
                      }
                    }
                    v27 += 2;
                  }
                  while (v27 != v28);
                }
                BOOL v36 = v44 & 1;
              }
              else
              {
                int v37 = 0;
                if (!v29)
                {
                  do
                  {
                    if (*v27
                      && (*(unsigned int (**)(void))(*(void *)*v27 + 472))(*v27) != 17
                      && (*(unsigned int (**)(void))(*(void *)*v27 + 472))(*v27) != 26)
                    {
                      int v37 = v37 & 1 | (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v27 + 376))(*v27, 1, 1);
                    }
                    v27 += 2;
                  }
                  while (v27 != v28);
                }
                BOOL v36 = v37 & 1;
              }
              BOOL v22 = v43;
            }
            else
            {
              BOOL v36 = 0;
            }
            if (v55) {
              sub_10004D2C8(v55);
            }
          }
          uint64_t v38 = v22 | v23 | v24 | v36;
          __int16 v39 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v18);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            char v40 = sd::asString();
            uint64_t v41 = sd::asString();
            uint64_t v42 = asStringBool(v38);
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v40;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v41;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v57 = v42;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I handle IMS feature state: cell=%s, wifi=%s, changed=%s", buf, 0x20u);
          }
          if (v38)
          {
            uint64_t v21 = v46;
            sub_100058DB0(__p, "Connection Context Preference Changed.");
            *(_DWORD *)long long buf = v18;
            uint8_t buf[4] = 0;
            if (SHIBYTE(v49) < 0)
            {
              sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
            }
            else
            {
              *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
              uint64_t v57 = v49;
            }
            sub_10011AE40();
            if (SHIBYTE(v57) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            if (SHIBYTE(v49) < 0) {
              operator delete(__p[0]);
            }
            uint64_t v19 = 0;
            if (v46) {
              goto LABEL_55;
            }
          }
          else
          {
            uint64_t v19 = 0;
            uint64_t v21 = v46;
            if (v46) {
              goto LABEL_55;
            }
          }
          goto LABEL_56;
        }
LABEL_52:
        int v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "handleImsFeatureState_sync";
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#E %s: Reached here too early. Connections vector not initialized!", buf, 0xCu);
        }
        uint64_t v19 = 1;
        if (v21) {
LABEL_55:
        }
          sub_10004D2C8(v21);
LABEL_56:
        if (v51) {
          sub_10004D2C8(v51);
        }
        if (v19 != 3 && v19) {
          return;
        }
LABEL_60:
        BOOL v34 = (void **)v3[1];
        if (v34)
        {
          do
          {
            uint64_t v35 = v34;
            BOOL v34 = (void **)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v35 = (void **)v3[2];
            unsigned int v29 = *v35 == v3;
            uint64_t v3 = v35;
          }
          while (!v29);
        }
        uint64_t v3 = v35;
      }
      while (v35 != v4);
    }
  }
}

void sub_101159E64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a27) {
    sub_10004D2C8(a27);
  }
  _Unwind_Resume(exception_object);
}

void sub_101159F44(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v3 = (BOOL *)(a1 + 4096);
    if (!*(unsigned char *)(a1 + 4096) || *(unsigned __int8 *)(a1 + 617) != a2)
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asStringBool(*(unsigned char *)(a1 + 617));
        uint64_t v6 = asStringBool(*v3);
        int v12 = 136315394;
        uint64_t v13 = v5;
        __int16 v14 = 2080;
        uint64_t v15 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fCellularDataSetting=%s, fCellularDataSettingInitialized=%s", (uint8_t *)&v12, 0x16u);
      }
      uint64_t v7 = *(void *)(a1 + 144);
      uint64_t v8 = *(void *)(v7 + 8);
      uint64_t v9 = *(void *)(v7 + 16);
      while (v8 != v9)
      {
        uint64_t v10 = *(void *)(v8 + 24);
        if (v10) {
          (*(void (**)(uint64_t, void))(*(void *)v10 + 888))(v10, *(unsigned __int8 *)(a1 + 617));
        }
        v8 += 432;
      }
      if (*v3)
      {
        sub_101167730(a1, (uint64_t)"cellular data settings");
      }
      else
      {
        uint64_t v11 = 1;
        *uint64_t v3 = 1;
      }
      DataServiceController::pingTethering((Registry **)a1, (uint64_t *)v11);
    }
  }
}

void sub_10115A0A4(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v3 = (BOOL *)(a1 + 4097);
    if (!*(unsigned char *)(a1 + 4097) || *(unsigned __int8 *)(a1 + 618) != a2)
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asStringBool(*(unsigned char *)(a1 + 618));
        uint64_t v6 = asStringBool(*v3);
        int v13 = 136315394;
        uint64_t v14 = v5;
        __int16 v15 = 2080;
        uint64_t v16 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fCellularDataSettingInternal=%s, fCellularDataSettingInternalInitialized=%s", (uint8_t *)&v13, 0x16u);
      }
      uint64_t v7 = *(void *)(a1 + 152);
      char v8 = *(unsigned char *)(a1 + 618);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
      *(unsigned char *)(v7 + 84) = v8;
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 24));
      if (*v3)
      {
        uint64_t v9 = *(void *)(a1 + 144);
        uint64_t v10 = *(void *)(v9 + 8);
        uint64_t v11 = *(void *)(v9 + 16);
        while (v10 != v11)
        {
          uint64_t v12 = *(void *)(v10 + 24);
          if (v12) {
            (*(void (**)(uint64_t, void))(*(void *)v12 + 880))(v12, *(unsigned __int8 *)(a1 + 618));
          }
          v10 += 432;
        }
      }
      else
      {
        *uint64_t v3 = 1;
      }
    }
  }
}

void sub_10115A21C(uint64_t a1, uint64_t a2)
{
  void (***v18)(uint64_t *__return_ptr, void, uint64_t);
  char v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  char *v38;
  char *v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  void *v44;
  void *v45;
  BOOL v46;
  std::__shared_weak_count *v47;
  unsigned int *v48;
  unsigned int *v49;
  uint64_t (*v50)(void);
  unsigned int *v51;
  unsigned int *v52;
  NSObject *log;
  void **v56;
  void *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  const mach_header_64 *v62;
  uint8_t *v63;
  uint8_t buf[24];
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;

  uint64_t v2 = a1;
  uint64_t v3 = *(void **)(a1 + 848);
  uint64_t v57 = (void *)(a1 + 856);
  if (v3 != (void *)(a1 + 856))
  {
    uint64_t v4 = a2;
    BOOL v5 = 0;
    uint64_t v56 = (void **)(a2 + 8);
    while (1)
    {
      uint64_t v6 = (BOOL *)(v3 + 7);
      char v7 = *((unsigned char *)v3 + 56) | v5;
      BOOL v5 = v7 != 0;
      uint64_t v62 = &_mh_execute_header;
      char v8 = sub_100046F68(v4, (void **)v3 + 4);
      if (v56 != v8) {
        uint64_t v62 = (const mach_header_64 *)v8[7];
      }
      if (operator==()) {
        goto LABEL_71;
      }
      int v60 = 0;
      uint64_t v61 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(v2 + 104));
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
      if (!v16) {
        break;
      }
      uint64_t v18 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (!v17) {
        goto LABEL_13;
      }
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      uint64_t v19 = 0;
LABEL_14:
      (**v18)(&v60, v18, (uint64_t)(v3 + 4));
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
      if (v60)
      {
        uint64_t v20 = *(unsigned char *)(v60 + 49) ? 1 : *(unsigned int *)(v60 + 52);
        uint64_t v21 = sub_10003B004(*(void *)(v2 + 144), v20);
        if (*(void *)(*(void *)(v2 + 144) + 16) != v21)
        {
          BOOL v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v20);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            log = v22;
            uint64_t v23 = asStringBool(*v6);
            uint64_t v24 = *((unsigned __int8 *)v3 + 55);
            uint64_t v25 = (v24 & 0x80u) != 0;
            if ((v24 & 0x80u) != 0) {
              uint64_t v24 = v3[5];
            }
            if (v25) {
              uint64_t v26 = (const char *)v3[4];
            }
            else {
              uint64_t v26 = (const char *)(v3 + 4);
            }
            if (v24) {
              long long v27 = v26;
            }
            else {
              long long v27 = "<invalid>";
            }
            uint64_t v28 = asStringBool(*((unsigned char *)v3 + 58));
            unsigned int v29 = asStringBool(*((unsigned char *)v3 + 57));
            uint64_t v30 = asString();
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = v23;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v27;
            *(_WORD *)&unsigned char buf[22] = 2080;
            int v65 = v28;
            uint64_t v66 = 2080;
            uint64_t v67 = v29;
            uint64_t v68 = 2080;
            long long v69 = v30;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I Voice Call state change: active=%s. Personality: %s, CS: %s, VoIP: %s, Type: %s", buf, 0x34u);
            uint64_t v2 = a1;
          }
          if (*v6)
          {
            if (!BYTE1(v62) && *((unsigned char *)v3 + 57))
            {
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v2 + 1528))(buf, v2);
              if (*(void *)buf) {
                (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)buf + 48))(*(void *)buf, v20, 1, 1);
              }
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
            }
            int v31 = *(char **)(v21 + 24);
            if (v31) {
              (*(void (**)(char *, void *))(*(void *)&v31[*(void *)(*(void *)v31 - 320)] + 112))(&v31[*(void *)(*(void *)v31 - 320)], v3 + 7);
            }
            uint64_t v32 = *(char **)(v21 + 40);
            if (v32) {
              (*(void (**)(char *, void *))(*(void *)&v32[*(void *)(*(void *)v32 - 320)] + 112))(&v32[*(void *)(*(void *)v32 - 320)], v3 + 7);
            }
          }
          else if ((_BYTE)v62)
          {
            uint64_t v58 = 0;
            uint64_t v59 = 0;
            (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v2 + 1528))(&v58, v2);
            if (v58) {
              (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v58 + 48))(v58, v20, 1, 0);
            }
            int v33 = *(void *)(v2 + 144);
            BOOL v34 = *(void *)(v33 + 8);
            uint64_t v35 = *(void *)(v33 + 16);
            while (v34 != v35)
            {
              memset(buf, 0, sizeof(buf));
              sub_100611D7C(buf, *(void **)(v34 + 56), *(void **)(v34 + 64), (uint64_t)(*(void *)(v34 + 64) - *(void *)(v34 + 56)) >> 4);
              BOOL v36 = *(void **)buf;
              int v37 = *(void **)&buf[8];
              while (v36 != v37)
              {
                if (*v36) {
                  (*(void (**)(void, uint64_t))(*(void *)*v36 + 1024))(*v36, v20);
                }
                v36 += 2;
              }
              uint64_t v63 = buf;
              sub_10005CBF0((void ***)&v63);
              v34 += 432;
            }
            uint64_t v38 = *(char **)(v21 + 24);
            uint64_t v2 = a1;
            if (v38) {
              (*(void (**)(char *))(*(void *)&v38[*(void *)(*(void *)v38 - 320)] + 120))(&v38[*(void *)(*(void *)v38 - 320)]);
            }
            __int16 v39 = *(char **)(v21 + 40);
            if (v39) {
              (*(void (**)(char *))(*(void *)&v39[*(void *)(*(void *)v39 - 320)] + 120))(&v39[*(void *)(*(void *)v39 - 320)]);
            }
            if (v59) {
              sub_10004D2C8(v59);
            }
          }
          char v40 = *(uint64_t **)v21;
          uint64_t v41 = *(uint64_t **)(v21 + 8);
          while (v40 != v41)
          {
            uint64_t v42 = *v40;
            uint64_t v43 = (std::__shared_weak_count *)v40[1];
            if (v43) {
              atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v42) {
              (*(void (**)(uint64_t, void *, const mach_header_64 **))(*(void *)v42 + 424))(v42, v3 + 7, &v62);
            }
            if (v43) {
              sub_10004D2C8(v43);
            }
            v40 += 2;
          }
        }
      }
      if (v61) {
        sub_10004D2C8(v61);
      }
      uint64_t v4 = a2;
LABEL_71:
      uint64_t v44 = (void *)v3[1];
      if (v44)
      {
        do
        {
          uint64_t v45 = v44;
          uint64_t v44 = (void *)*v44;
        }
        while (v44);
      }
      else
      {
        do
        {
          uint64_t v45 = (void *)v3[2];
          uint64_t v46 = *v45 == (void)v3;
          uint64_t v3 = v45;
        }
        while (!v46);
      }
      uint64_t v3 = v45;
      if (v45 == v57)
      {
        *(unsigned char *)(v2 + 292) = v7;
        if (!v7) {
          goto LABEL_80;
        }
        return;
      }
    }
    uint64_t v18 = 0;
LABEL_13:
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    uint64_t v19 = 1;
    goto LABEL_14;
  }
  *(unsigned char *)(a1 + 292) = 0;
LABEL_80:
  unsigned int v47 = *(std::__shared_weak_count **)(v2 + 112);
  int v60 = *(void *)(v2 + 104);
  uint64_t v61 = v47;
  if (v47) {
    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v61) {
    sub_10004D2C8(v61);
  }
  uint64_t v49 = *(unsigned int **)buf;
  uint64_t v48 = *(unsigned int **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8])
  {
    uint64_t v50 = *(uint64_t (**)(void))&buf[16];
    while ((v50(*v49) & 1) == 0)
    {
      if (++v49 == v48)
      {
        uint64_t v49 = v48;
        break;
      }
    }
    CFTypeRef v51 = *(unsigned int **)&buf[8];
LABEL_90:
    while (v49 != v51)
    {
      (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v2 + 216))(v2, *v49, 32, 0);
      uint64_t v52 = v49 + 1;
      uint64_t v49 = v48;
      if (v52 != v48)
      {
        uint64_t v49 = v52;
        while ((v50(*v49) & 1) == 0)
        {
          if (++v49 == v48)
          {
            uint64_t v49 = v48;
            goto LABEL_90;
          }
        }
      }
    }
  }
}

void sub_10115A9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115AA54(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 912))
  {
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    BOOL v5 = *(void **)(a1 + 896);
    uint64_t v6 = v5;
    while (1)
    {
      BOOL v7 = *((_DWORD *)v4 + 8) == *((_DWORD *)v6 + 8) && v4[5] == v6[5];
      if (!v7) {
        break;
      }
      char v8 = (void *)v4[1];
      uint64_t v9 = v4;
      if (v8)
      {
        do
        {
          uint64_t v4 = v8;
          char v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v9[2];
          BOOL v7 = *v4 == (void)v9;
          uint64_t v9 = v4;
        }
        while (!v7);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v6[2];
          BOOL v7 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v7);
      }
      uint64_t v6 = v11;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    BOOL v5 = *(void **)(a1 + 896);
  }
  uint64_t v12 = (void *)(a1 + 904);
  if (v5 != (void *)(a1 + 904))
  {
    do
    {
      int v13 = (unsigned int *)(v5 + 4);
      uint64_t v14 = sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)v5 + 8));
      if (*(void *)(*(void *)(a1 + 144) + 16) != v14)
      {
        unsigned int v15 = (uint64_t *)a2[1];
        if (v15)
        {
          int v16 = *v13;
          do
          {
            int v17 = *((_DWORD *)v15 + 8);
            if (v16 >= v17)
            {
              if (v17 >= v16)
              {
                uint64_t v18 = *sub_1000FD774((uint64_t)a2, (int *)v5 + 8);
                goto LABEL_32;
              }
              ++v15;
            }
            unsigned int v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        uint64_t v18 = 0;
LABEL_32:
        if (v18 != v5[5])
        {
          uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *v13);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = v5[5];
            *(_DWORD *)long long buf = 134218496;
            *(void *)long long __p = v18;
            *(_WORD *)&__p[8] = 2048;
            *(void *)&__p[10] = v20;
            *(_WORD *)&__p[18] = 2048;
            uint64_t v29 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Allowed policy typeMask changed 0x%02llx -> 0x%02llx(%lld)", buf, 0x20u);
          }
          uint64_t v21 = *(void *)(v14 + 40);
          if (v21) {
            (*(void (**)(uint64_t, void))(*(void *)v21 + 464))(v21, v5[5]);
          }
          int v22 = *v13;
          sub_100058DB0(v25, "Tech Policy Changed");
          *(_DWORD *)long long buf = v22;
          __p[0] = 0;
          if (SHIBYTE(v26) < 0)
          {
            sub_10004FC84(&__p[4], v25[0], (unint64_t)v25[1]);
          }
          else
          {
            *(_OWORD *)&__p[4] = *(_OWORD *)v25;
            uint64_t v29 = v26;
          }
          sub_10011AE40();
          if (SHIBYTE(v29) < 0) {
            operator delete(*(void **)&__p[4]);
          }
          if (SHIBYTE(v26) < 0) {
            operator delete(v25[0]);
          }
        }
      }
      uint64_t v23 = (void *)v5[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v5[2];
          BOOL v7 = *v24 == (void)v5;
          BOOL v5 = v24;
        }
        while (!v7);
      }
      BOOL v5 = v24;
    }
    while (v24 != v12);
  }
}

void sub_10115AD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115ADC0(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), v2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v3)
  {
    uint64_t v4 = *(uint64_t **)v3;
    BOOL v5 = *(uint64_t **)(v3 + 8);
    if (*(uint64_t **)v3 != v5)
    {
      do
      {
        uint64_t v6 = *v4;
        BOOL v7 = (std::__shared_weak_count *)v4[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v6) {
          (*(void (**)(uint64_t, void))(*(void *)v6 + 544))(v6, *(unsigned __int8 *)(a1 + 840));
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
        v4 += 2;
      }
      while (v4 != v5);
    }
  }
}

void sub_10115AEA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115AEBC(void *a1, void *a2)
{
  uint64_t v3 = (unsigned int *)a1[43];
  uint64_t v4 = (unsigned int *)a1[44];
  if (v3 == v4)
  {
    uint64_t v21 = a1[5];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v30 = "handleSimsChanged_sync";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s: sim state changed: empty sim info.", buf, 0xCu);
    }
  }
  else
  {
    char v6 = 0;
    char v7 = 0;
    do
    {
      uint64_t v8 = *v3;
      uint64_t v9 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(*(void *)a1[6] + 16))(a1[6], v8);
      sub_100AE3FBC((os_unfair_lock_s *)a1[19], v8);
      if (subscriber::isSimUnreadable())
      {
        uint64_t v10 = *v9;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v30 = (const char *)v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I sim state changed: new state %s (unreadable), immediately bringing down data on that SIM", buf, 0xCu);
        }
        sub_1011673E4((uint64_t)a1, v8, 17, 1);
        char v6 = 1;
      }
      else
      {
        char v7 = 1;
      }
      v3 += 42;
    }
    while (v3 != v4);
    if (!(v7 & 1 | ((v6 & 1) == 0)))
    {
      uint64_t v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I sim state changed: making all interfaces not available", buf, 2u);
      }
      (*(void (**)(void *, void, void))(*a1 + 584))(a1, 0, 0);
    }
    int v13 = (int *)a1[43];
    uint64_t v14 = (int *)a1[44];
    if (v13 == v14)
    {
      uint64_t v20 = a1[43];
    }
    else
    {
      do
      {
        uint64_t v15 = *v13;
        int v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(*(void *)a1[6] + 16))(a1[6], v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v30 = (const char *)v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I sim state changed: new state %s", buf, 0xCu);
        }
        uint64_t v18 = operator new(8uLL);
        long long __p = v18;
        *uint64_t v18 = &_mh_execute_header;
        long long v27 = v18 + 1;
        uint64_t v28 = v18 + 1;
        (*(void (**)(void *, uint64_t, const char *, void, uint64_t, void **))(*a1 + 176))(a1, v15, "SimChanged", 0, 36, &__p);
        uint64_t v19 = (capabilities::ct *)__p;
        if (__p)
        {
          long long v27 = __p;
          operator delete(__p);
        }
        if (capabilities::ct::supports5GSlicing(v19)) {
          DataServiceController::resetAllUrspRules_sync((uint64_t)a1, *v13, v13[2]);
        }
        v13 += 42;
      }
      while (v13 != v14);
      int v13 = (int *)a1[43];
      uint64_t v20 = a1[44];
    }
    uint64_t v24 = a2;
    uint64_t v22 = *a2;
    uint64_t v23 = v24[1];
    if (v23 - v22 == v20 - (void)v13)
    {
      while (v22 != v23)
      {
        if (!BasicSimInfo::operator==()) {
          goto LABEL_29;
        }
        v22 += 168;
        v13 += 42;
      }
    }
    else
    {
LABEL_29:
      sub_101167730((uint64_t)a1, (uint64_t)"sim changed");
    }
    for (uint64_t i = 0; i != 2; ++i)
      DataServiceController::updateTetheringStatus_sync((uint64_t)a1, dword_10155B0D0[i]);
  }
}

void sub_10115B288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115B2AC(Registry **a1, unsigned __int8 *a2)
{
  if (!*((unsigned char *)a1 + 288))
  {
    uint64_t v3 = *((unsigned int *)a2 + 14);
    int v4 = *a2;
    int v5 = a2[1];
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v15 = 0;
    if ((char)a2[31] < 0)
    {
      sub_10004FC84(__p, *((void **)a2 + 1), *((void *)a2 + 2));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a2 + 8);
      uint64_t v15 = *((void *)a2 + 3);
    }
    char v6 = *(NSObject **)(*(uint64_t (**)(Registry *, uint64_t))(*(void *)a1[6] + 16))(a1[6], v3);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      uint64_t v8 = asString();
      uint64_t v9 = __p;
      if (v15 < 0) {
        uint64_t v9 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v7;
      __int16 v17 = 2080;
      uint64_t v18 = v8;
      __int16 v19 = 2080;
      uint64_t v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I carrier bundle change: %s : %s : %s", buf, 0x20u);
    }
    unint64_t v10 = (v4 - 1);
    if (v10 <= 0xFD)
    {
      sub_100058DB0(buf, "carrier bundle change");
      (*((void (**)(Registry **, uint64_t, unsigned char *, void))*a1 + 291))(a1, v3, buf, 0);
      unint64_t v10 = SHIBYTE(v19);
      if ((v10 & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    DataServiceController::updateIpcConfiguration_sync(a1, (uint64_t *)v10);
    if (v4 != 255 || v5)
    {
      if (!v4)
      {
LABEL_23:
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[0]);
        }
        return;
      }
    }
    else
    {
      uint64_t v11 = (void *)HIBYTE(v15);
      if (v15 < 0) {
        uint64_t v11 = __p[1];
      }
      if (!v11) {
        goto LABEL_23;
      }
    }
    sub_100AE3FBC((os_unfair_lock_s *)a1[19], v3);
    sub_101165780((uint64_t)a1, v3);
    (*((void (**)(Registry **, uint64_t, void))*a1 + 67))(a1, v3, 0);
    uint64_t v12 = a1[5];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asStringBool(v4 != 5);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I carrier bundle change: validCB = %s", buf, 0xCu);
    }
    sub_10117CA6C((uint64_t)a1, v4 != 5, 8);
    (*((void (**)(Registry **, uint64_t, uint64_t, uint64_t, void))*a1 + 104))(a1, v3, 1, 0xFFFFFFFFLL, 0);
    (*((void (**)(Registry **, uint64_t, uint64_t, void))*a1 + 43))(a1, v3, 14, 0);
    if ((v4 - 1) <= 2u)
    {
      sub_1011633E8((uint64_t)a1, v3);
      sub_101163938((uint64_t)a1, v3);
    }
    goto LABEL_23;
  }
}

void sub_10115B620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115B668(void **a1, unsigned __int8 *a2)
{
  uint64_t v3 = *((unsigned int *)a2 + 14);
  int v4 = *a2;
  int v5 = a2[1];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v12 = 0;
  if ((char)a2[31] < 0)
  {
    sub_10004FC84(__p, *((void **)a2 + 1), *((void *)a2 + 2));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a2 + 8);
    uint64_t v12 = *((void *)a2 + 3);
  }
  char v6 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], v3);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asString();
    uint64_t v8 = asString();
    uint64_t v9 = __p;
    if (v12 < 0) {
      uint64_t v9 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v14 = v7;
    __int16 v15 = 2080;
    uint64_t v16 = v8;
    __int16 v17 = 2080;
    uint64_t v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I operator bundle change: %s : %s : %s", buf, 0x20u);
  }
  if (v4 != 255 || v5)
  {
    if (!v4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  unint64_t v10 = (void *)HIBYTE(v12);
  if (v12 < 0) {
    unint64_t v10 = __p[1];
  }
  if (v10)
  {
LABEL_15:
    ((void (*)(void **, uint64_t, void))(*a1)[67])(a1, v3, 0);
    ((void (*)(void **, uint64_t, uint64_t, uint64_t, void))(*a1)[104])(a1, v3, 5, 0xFFFFFFFFLL, 0);
  }
LABEL_16:
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10115B874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10115B89C(uint64_t a1, int *a2)
{
  int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = a2[1];
    uint64_t v6 = asString();
    unsigned int v7 = a2[4];
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)long long __p = v5;
    *(_WORD *)&__p[4] = 2080;
    *(void *)&__p[6] = v6;
    *(_WORD *)&__p[14] = 1024;
    *(_DWORD *)&__p[16] = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Got iRat Change event with appType %d and dataContextType %s with reasonCode %d", buf, 0x18u);
  }
  int v8 = *a2;
  uint64_t v9 = sub_10003B004(*(void *)(a1 + 144), *a2);
  uint64_t v10 = v9;
  if (*(void *)(*(void *)(a1 + 144) + 16) != v9)
  {
    if (a2[2]
      || (uint64_t v12 = *(void *)(v9 + 24)) == 0
      || (*(unsigned int (**)(uint64_t))(*(void *)v12 + 408))(v12)
      && !(*(unsigned int (**)(void))(**(void **)(v10 + 24) + 376))(*(void *)(v10 + 24)))
    {
      uint64_t v11 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
      sub_100D812CC(v11, (uint64_t *)(v10 + 56), a2[1], a2[2], a2[4]);
      sub_100058DB0(v15, "iRat Changed");
      *(_DWORD *)long long buf = v8;
      __p[0] = 0;
      if (SHIBYTE(v16) < 0)
      {
        sub_10004FC84(&__p[4], v15[0], (unint64_t)v15[1]);
      }
      else
      {
        *(_OWORD *)&__p[4] = *(_OWORD *)v15;
        uint64_t v19 = v16;
      }
      sub_10011AE40();
      if (SHIBYTE(v19) < 0) {
        operator delete(*(void **)&__p[4]);
      }
      if (SHIBYTE(v16) < 0) {
        operator delete(v15[0]);
      }
    }
    else
    {
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)long long __p = "iRatChanged_sync";
        *(_WORD *)&__p[8] = 2080;
        *(void *)&__p[10] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Baseband is not even online, ignore the iRatChanged to %s event.", buf, 0x16u);
      }
    }
  }
}

void sub_10115BB4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10115BB88(uint64_t a1, unsigned int *a2)
{
  int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Got AttachAPNInfo Change event", v8, 2u);
  }
  uint64_t result = sub_10003B004(*(void *)(a1 + 144), *a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != result)
  {
    uint64_t v6 = result;
    *(_DWORD *)(result + 152) = *a2;
    std::string::operator=((std::string *)(result + 160), (const std::string *)(a2 + 2));
    unsigned int v7 = a2[10];
    *(void *)(v6 + 184) = *((void *)a2 + 4);
    *(_DWORD *)(v6 + 192) = v7;
    CSIPacketAddress::operator=();
    CSIPacketAddress::operator=();
    CSIPacketAddress::operator=();
    CSIPacketAddress::operator=();
    return CSIPacketAddress::operator=();
  }
  return result;
}

void sub_10115BCA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 720);
  int v4 = (void *)(a1 + 728);
  if (v3 != (void *)(a1 + 728))
  {
    uint64_t v6 = (void *)(a2 + 8);
    do
    {
      if (sub_100AF2240(*(void *)(a1 + 144), *((_DWORD *)v3 + 7)))
      {
        uint64_t v7 = *v6;
        uint64_t v8 = *((unsigned int *)v3 + 7);
        if (!*v6) {
          goto LABEL_15;
        }
        uint64_t v9 = v6;
        do
        {
          int v10 = *(_DWORD *)(v7 + 28);
          BOOL v11 = v10 < (int)v8;
          if (v10 >= (int)v8) {
            uint64_t v12 = (uint64_t *)v7;
          }
          else {
            uint64_t v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            uint64_t v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 == v6 || (int)v8 < *((_DWORD *)v9 + 7) || *((unsigned __int8 *)v9 + 32) != *((unsigned __int8 *)v3 + 32))
        {
LABEL_15:
          unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | *((unsigned __int8 *)v3 + 32) | 0x100;
          sub_10116F6BC(a1, v8, v2, 1, 0);
        }
      }
      uint64_t v13 = (void *)v3[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v3[2];
          BOOL v15 = *v14 == (void)v3;
          uint64_t v3 = v14;
        }
        while (!v15);
      }
      uint64_t v3 = v14;
    }
    while (v14 != v4);
  }
}

void sub_10115BDA4(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 921) != a2)
  {
    BOOL v2 = a2;
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = asStringBool(v2);
      uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 921));
      int v7 = 136315650;
      uint64_t v8 = "handleBasebandFirmwareDead_sync";
      __int16 v9 = 2080;
      uint64_t v10 = v5;
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Firmware dead: %s -> %s", (uint8_t *)&v7, 0x20u);
    }
    sub_101167730(a1, (uint64_t)"dead firmware");
  }
}

void sub_10115BE98(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 744);
  BOOL v2 = (void *)(a1 + 752);
  if (v1 != (void *)(a1 + 752))
  {
    do
    {
      int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v1 + 8));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = sd::asString();
        uint64_t v6 = (uint64_t)(v1[6] - v1[5]) >> 2;
        *(_DWORD *)long long buf = 136315394;
        uint64_t v18 = v5;
        __int16 v19 = 2048;
        uint64_t v20 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I new imsPref = [%s] (data modes: %lu)", buf, 0x16u);
      }
      uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)v1 + 8));
      if (*(void *)(*(void *)(a1 + 144) + 16) != v7)
      {
        uint64_t v9 = *(void *)(v7 + 24);
        uint64_t v8 = *(std::__shared_weak_count **)(v7 + 32);
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v9)
        {
          long long __p = 0;
          BOOL v15 = 0;
          uint64_t v16 = 0;
          sub_1003FB56C(&__p, (const void *)v1[5], v1[6], (uint64_t)(v1[6] - v1[5]) >> 2);
          unsigned int v10 = sd::imsServiceMaskToUint();
          (*(void (**)(uint64_t, void **, void))(*(void *)v9 + 792))(v9, &__p, v10);
          if (__p)
          {
            BOOL v15 = __p;
            operator delete(__p);
          }
        }
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      __int16 v11 = (void *)v1[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          __int16 v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v1[2];
          BOOL v13 = *v12 == (void)v1;
          uint64_t v1 = v12;
        }
        while (!v13);
      }
      uint64_t v1 = v12;
    }
    while (v12 != v2);
  }
}

void sub_10115C0A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115C0E0(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "handleCallDropIMSPackets_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_10003E168(buf, (void *)(a1 + 8));
  operator new();
}

void sub_10115C238(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10115C248(uint64_t a1, BOOL a2)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = asStringBool(a2);
      uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 801));
      *(_DWORD *)long long buf = 136315394;
      *(void *)long long __p = v5;
      *(_WORD *)&__p[8] = 2080;
      *(void *)&__p[10] = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I (change states) NEConfigurationStarted: %s ==>> %s", buf, 0x16u);
    }
    sub_100058DB0(v7, "NESession started");
    *(_DWORD *)long long buf = 3;
    __p[0] = 0;
    if (SHIBYTE(v8) < 0)
    {
      sub_10004FC84(&__p[4], v7[0], (unint64_t)v7[1]);
    }
    else
    {
      *(_OWORD *)&__p[4] = *(_OWORD *)v7;
      uint64_t v11 = v8;
    }
    sub_10011AE40();
    if (SHIBYTE(v11) < 0) {
      operator delete(*(void **)&__p[4]);
    }
    if (SHIBYTE(v8) < 0) {
      operator delete(v7[0]);
    }
  }
}

void sub_10115C38C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115C3C8(uint64_t a1, void *a2)
{
  int v4 = *(void **)(a1 + 928);
  uint64_t v5 = (void *)(a1 + 936);
  if (v4 != (void *)(a1 + 936))
  {
    do
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 7));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = asStringBool(*((unsigned char *)v4 + 32));
        *(_DWORD *)long long buf = 136315138;
        uint64_t v37 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I CDMA Aux Info readyness is %s (1)", buf, 0xCu);
      }
      uint64_t v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v4[2];
          BOOL v13 = *v9 == (void)v4;
          int v4 = v9;
        }
        while (!v13);
      }
      int v4 = v9;
    }
    while (v9 != v5);
  }
  if (a2[2] == *(void *)(a1 + 944))
  {
    unsigned int v10 = (void *)*a2;
    if ((void *)*a2 == a2 + 1)
    {
LABEL_29:
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I No change in CDMA Aux Info readiness", buf, 2u);
      }
      return;
    }
    uint64_t v11 = *(void **)(a1 + 928);
    uint64_t v12 = v11;
    while (1)
    {
      BOOL v13 = *((_DWORD *)v10 + 7) == *((_DWORD *)v12 + 7)
         && *((unsigned __int8 *)v10 + 32) == *((unsigned __int8 *)v12 + 32);
      if (!v13) {
        break;
      }
      uint64_t v14 = (void *)v10[1];
      BOOL v15 = v10;
      if (v14)
      {
        do
        {
          unsigned int v10 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          unsigned int v10 = (void *)v15[2];
          BOOL v13 = *v10 == (void)v15;
          BOOL v15 = v10;
        }
        while (!v13);
      }
      uint64_t v16 = (void *)v12[1];
      if (v16)
      {
        do
        {
          __int16 v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          __int16 v17 = (void *)v12[2];
          BOOL v13 = *v17 == (void)v12;
          uint64_t v12 = v17;
        }
        while (!v13);
      }
      uint64_t v12 = v17;
      if (v10 == a2 + 1) {
        goto LABEL_29;
      }
    }
  }
  else
  {
    uint64_t v11 = *(void **)(a1 + 928);
  }
  if (v11 != v5)
  {
    __int16 v19 = a2 + 1;
    while (1)
    {
      uint64_t v20 = *v19;
      uint64_t v21 = *((unsigned int *)v11 + 7);
      if (!*v19) {
        break;
      }
      uint64_t v22 = a2 + 1;
      do
      {
        int v23 = *(_DWORD *)(v20 + 28);
        BOOL v24 = v23 < (int)v21;
        if (v23 >= (int)v21) {
          uint64_t v25 = (uint64_t *)v20;
        }
        else {
          uint64_t v25 = (uint64_t *)(v20 + 8);
        }
        if (!v24) {
          uint64_t v22 = (uint64_t *)v20;
        }
        uint64_t v20 = *v25;
      }
      while (*v25);
      if (v22 == v19 || (int)v21 < *((_DWORD *)v22 + 7)) {
        break;
      }
      int v26 = *((unsigned __int8 *)v11 + 32);
      if (*((unsigned __int8 *)v22 + 32) != v26) {
        goto LABEL_45;
      }
LABEL_57:
      BOOL v34 = (void *)v11[1];
      if (v34)
      {
        do
        {
          uint64_t v35 = v34;
          BOOL v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v35 = (void *)v11[2];
          BOOL v13 = *v35 == (void)v11;
          uint64_t v11 = v35;
        }
        while (!v13);
      }
      uint64_t v11 = v35;
      if (v35 == v5) {
        return;
      }
    }
    int v26 = *((unsigned __int8 *)v11 + 32);
LABEL_45:
    uint64_t v27 = sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)v11 + 7));
    if (*(void *)(*(void *)(a1 + 144) + 16) != v27)
    {
      uint64_t v28 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v21);
      uint64_t v29 = *v28;
      if (os_log_type_enabled(*v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = asStringBool(v26 != 0);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v37 = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I CDMA Aux Info readiness is %s (2)", buf, 0xCu);
      }
      uint64_t v31 = *(void *)(v27 + 24);
      uint64_t v32 = *(std::__shared_weak_count **)(v27 + 32);
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v31)
      {
        (*(void (**)(uint64_t, BOOL))(*(void *)v31 + 832))(v31, v26 != 0);
      }
      else
      {
        int v33 = *v28;
        if (os_log_type_enabled(*v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#E BB driver is empty when CDMA Aux Info is ready", buf, 2u);
        }
      }
      if (v32) {
        sub_10004D2C8(v32);
      }
    }
    goto LABEL_57;
  }
}

void sub_10115C7E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115C808(uint64_t a1, const RegisteredNetworkInfo *a2)
{
  BOOL v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  RegisteredNetworkInfo::compare((uint64_t *)&v15, (RegisteredNetworkInfo *)(a1 + 1976), a2);
  uint64_t v3 = v15;
  if (v15 != v16)
  {
    while (*v3 != 10)
    {
      if (++v3 == v16)
      {
        uint64_t v3 = v16;
        break;
      }
    }
  }
  if (v3 != v16)
  {
    uint64_t v4 = sub_10003B004(*(void *)(a1 + 144), 2);
    if (*(void *)(*(void *)(a1 + 144) + 16) != v4)
    {
      uint64_t v5 = *(uint64_t **)v4;
      uint64_t v6 = *(uint64_t **)(v4 + 8);
      if (*(uint64_t **)v4 != v6)
      {
        do
        {
          uint64_t v7 = *v5;
          uint64_t v8 = (std::__shared_weak_count *)v5[1];
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v7) {
            (*(void (**)(uint64_t, void))(*(void *)v7 + 264))(v7, *(unsigned __int8 *)(a1 + 2772));
          }
          if (v8) {
            sub_10004D2C8(v8);
          }
          v5 += 2;
        }
        while (v5 != v6);
      }
      sub_100058DB0(v9, "Satellite system changed for slot 2");
      int v11 = 2;
      char v12 = 1;
      if (SHIBYTE(v10) < 0)
      {
        sub_10004FC84(&__p, v9[0], (unint64_t)v9[1]);
      }
      else
      {
        long long __p = *(_OWORD *)v9;
        uint64_t v14 = v10;
      }
      sub_10011AE40();
      if (SHIBYTE(v14) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v10) < 0) {
        operator delete(v9[0]);
      }
    }
  }
  if (v15)
  {
    uint64_t v16 = v15;
    operator delete(v15);
  }
}

void sub_10115C994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115C9F8(capabilities::ct *a1, uint64_t a2)
{
  BOOL v2 = (void *)*((void *)a1 + 97);
  uint64_t v3 = (void *)((char *)a1 + 784);
  if (v2 != (void *)((char *)a1 + 784))
  {
    uint64_t v4 = (uint64_t)a1;
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      a1 = (capabilities::ct *)capabilities::ct::supportsGemini(a1);
      if (a1)
      {
        uint64_t v6 = (char *)(v2 + 4);
        char v17 = 0;
        uint64_t v7 = *v5;
        int v8 = *((_DWORD *)v2 + 7);
        if (!*v5) {
          goto LABEL_15;
        }
        uint64_t v9 = v5;
        do
        {
          int v10 = *(_DWORD *)(v7 + 28);
          BOOL v11 = v10 < v8;
          if (v10 >= v8) {
            char v12 = (uint64_t *)v7;
          }
          else {
            char v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            uint64_t v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 == v5
          || v8 < *((_DWORD *)v9 + 7)
          || (int v13 = *((unsigned __int8 *)v9 + 32), v17 = v13, v13 != *v6))
        {
LABEL_15:
          sub_101167D40(v4, v8, &v17, v6);
        }
      }
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          BOOL v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          BOOL v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          BOOL v2 = v15;
        }
        while (!v16);
      }
      BOOL v2 = v15;
    }
    while (v15 != v3);
  }
}

void sub_10115CAE4(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 800);
  if (v2 != a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asStringBool(v2 != 0);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband activation status: %s", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_10115CB94(void *a1, void *a2)
{
  uint64_t v3 = (void *)a1[119];
  if (a1[121] == a2[2])
  {
    if (v3 == a1 + 120) {
      return;
    }
    int v4 = (void *)*a2;
    uint64_t v5 = (void *)a1[119];
    while (1)
    {
      BOOL v6 = *((_DWORD *)v5 + 7) == *((_DWORD *)v4 + 7) && *((unsigned __int8 *)v5 + 32) == *((unsigned __int8 *)v4 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v5[1];
      int v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v6 = *v5 == (void)v8;
          int v8 = v5;
        }
        while (!v6);
      }
      uint64_t v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v4[2];
          BOOL v6 = *v10 == (void)v4;
          int v4 = v10;
        }
        while (!v6);
      }
      int v4 = v10;
      if (v5 == a1 + 120) {
        return;
      }
    }
  }
  BOOL v11 = a1 + 120;
  if (v3 != a1 + 120)
  {
    char v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      int v14 = *((_DWORD *)v3 + 7);
      if (!*v12) {
        goto LABEL_33;
      }
      BOOL v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < v14;
        if (v16 >= v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          BOOL v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 != v12 && v14 >= *((_DWORD *)v15 + 7))
      {
        if (*((unsigned __int8 *)v15 + 32) == *((unsigned __int8 *)v3 + 32)) {
          goto LABEL_36;
        }
        __int16 v19 = a1[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
LABEL_34:
          uint64_t v20 = asString();
          uint64_t v21 = subscriber::asString();
          *(_DWORD *)long long buf = 136315394;
          uint64_t v25 = v20;
          __int16 v26 = 2080;
          uint64_t v27 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Type of EVO changed to %s for slot %s", buf, 0x16u);
        }
      }
      else
      {
LABEL_33:
        __int16 v19 = a1[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
      }
      sub_101168D34(a1[18], v14);
LABEL_36:
      uint64_t v22 = (void *)v3[1];
      if (v22)
      {
        do
        {
          int v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          int v23 = (void *)v3[2];
          BOOL v6 = *v23 == (void)v3;
          uint64_t v3 = v23;
        }
        while (!v6);
      }
      uint64_t v3 = v23;
    }
    while (v23 != v11);
  }
}

void sub_10115CDF4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 976);
  if (*(void *)(a1 + 992) == a2[2])
  {
    if (v3 == (void *)(a1 + 984)) {
      return;
    }
    int v4 = (void *)*a2;
    uint64_t v5 = *(void **)(a1 + 976);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v5 + 7) == *((_DWORD *)v4 + 7) && *((unsigned __int8 *)v5 + 32) == *((unsigned __int8 *)v4 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v5[1];
      int v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v6 = *v5 == (void)v8;
          int v8 = v5;
        }
        while (!v6);
      }
      uint64_t v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v4[2];
          BOOL v6 = *v10 == (void)v4;
          int v4 = v10;
        }
        while (!v6);
      }
      int v4 = v10;
      if (v5 == (void *)(a1 + 984)) {
        return;
      }
    }
  }
  BOOL v11 = (void *)(a1 + 984);
  if (v3 != (void *)(a1 + 984))
  {
    char v12 = a2 + 1;
    while (1)
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v3 + 7);
      if (!*v12) {
        break;
      }
      BOOL v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          BOOL v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12 || (int)v14 < *((_DWORD *)v15 + 7)) {
        break;
      }
      int v19 = *((unsigned __int8 *)v3 + 32);
      if (*((unsigned __int8 *)v15 + 32) != v19) {
        goto LABEL_34;
      }
LABEL_39:
      uint64_t v22 = (void *)v3[1];
      if (v22)
      {
        do
        {
          int v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          int v23 = (void *)v3[2];
          BOOL v6 = *v23 == (void)v3;
          uint64_t v3 = v23;
        }
        while (!v6);
      }
      uint64_t v3 = v23;
      if (v23 == v11) {
        return;
      }
    }
    int v19 = *((unsigned __int8 *)v3 + 32);
LABEL_34:
    uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v3 + 7));
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = asStringBool(v19 != 0);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I EffectiveDataRoamingSetting changed to %s ", buf, 0xCu);
    }
    sub_1011792A4((void *)a1, v14, (uint64_t)"due to _InternationalDataSettingsChanged", 1, 0);
    sub_100058DB0(buf, "recheckDataRoaming");
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 2072))(a1, v14, 1, buf, 25);
    if (v25 < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_39;
  }
}

void sub_10115D0C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115D0EC(uint64_t a1, uint64_t a2, long long **a3)
{
  switch(*(unsigned char *)(a2 + 24))
  {
    case 0:
      uint64_t v27 = *a3;
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (!*a3)
      {
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          goto LABEL_142;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v43 = "Personality empty";
        goto LABEL_64;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = (const char *)*((void *)v27 + 3);
        uint64_t v29 = (char *)v27 + 24;
        uint64_t v28 = v30;
        uint64_t v31 = v29[23];
        int v32 = (char)v31;
        if ((v31 & 0x80u) != 0) {
          uint64_t v31 = *((void *)v29 + 1);
        }
        if (v32 >= 0) {
          uint64_t v28 = v29;
        }
        if (!v31) {
          uint64_t v28 = "<invalid>";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v28;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Personality added: %s", buf, 0xCu);
        uint64_t v27 = *a3;
      }
      if (*((unsigned char *)v27 + 49) == 1)
      {
        int v33 = *(NSObject **)(a1 + 40);
        BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
        if (v34)
        {
          uint64_t v35 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Personality of type: %s (add)", buf, 0xCu);
        }
        if (capabilities::ct::supportsMultipleThumpers((capabilities::ct *)v34))
        {
          BOOL v36 = *(uint64_t **)(a1 + 144);
          uint64_t v37 = v36[1];
          uint64_t v38 = v36[2];
          if (v37 == v38)
          {
LABEL_52:
            DataModel::DataModel((uint64_t)buf, a3);
            unint64_t v41 = v36[2];
            if (v41 >= v36[3])
            {
              uint64_t v42 = sub_100611840(v36 + 1, (uint64_t)buf);
            }
            else
            {
              sub_100611960(v36[2], (uint64_t)buf);
              uint64_t v42 = v41 + 432;
              v36[2] = v41 + 432;
            }
            v36[2] = v42;
            DataModel::~DataModel((DataModel *)buf);
            uint64_t v66 = v36[2] - 432;
          }
          else
          {
            while (1)
            {
              *(void *)long long buf = *(void *)(v37 + 416);
              uint64_t v39 = *(void *)(v37 + 424);
              *(void *)&uint8_t buf[8] = v39;
              if (v39) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
              }
              char matched = DataUtils::matchPersonality();
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              if (matched) {
                break;
              }
              v37 += 432;
              if (v37 == v38) {
                goto LABEL_52;
              }
            }
            uint64_t v66 = v36[1];
            uint64_t v78 = v36[2];
            if (v66 == v78) {
LABEL_152:
            }
              __assert_rtn("at", "PerPersonalityDataContainer.h", 103, "0");
            while (1)
            {
              *(void *)long long buf = *(void *)(v66 + 416);
              uint64_t v79 = *(void *)(v66 + 424);
              *(void *)&uint8_t buf[8] = v79;
              if (v79) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v79 + 8), 1uLL, memory_order_relaxed);
              }
              char v80 = DataUtils::matchPersonality();
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              if (v80) {
                break;
              }
              v66 += 432;
              if (v66 == v78) {
                goto LABEL_152;
              }
            }
          }
          for (int i = 0; i != 36; ++i)
          {
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            uint64_t v68 = *(atomic_ullong **)(a1 + 112);
            __p[0] = *(void **)(a1 + 104);
            __p[1] = v68;
            if (v68) {
              atomic_fetch_add_explicit(v68 + 1, 1uLL, memory_order_relaxed);
            }
            uint64_t v69 = *(void *)(v66 + 424);
            *(void *)&long long v84 = *(void *)(v66 + 416);
            *((void *)&v84 + 1) = v69;
            if (v69) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v69 + 8), 1uLL, memory_order_relaxed);
            }
            int v70 = *(NSObject **)(a1 + 24);
            dispatch_object_t object = v70;
            if (v70) {
              dispatch_retain(v70);
            }
            sub_1011B0024((uint64_t)__p, a1 + 64, &object, i, (uint64_t *)buf);
            if (object) {
              dispatch_release(object);
            }
            if (*((void *)&v84 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v84 + 1));
            }
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
            if (!*(void *)buf)
            {
              long long v71 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v72 = asString();
                LODWORD(v84) = 136315138;
                *(void *)((char *)&v84 + 4) = v72;
                _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#N Connection empty: %s", (uint8_t *)&v84, 0xCu);
              }
            }
            sub_100CE9234((char **)v66, (long long *)buf);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          uint64_t v73 = *(void *)(a1 + 136);
          uint64_t v74 = *(NSObject **)(a1 + 24);
          *(void *)&long long v84 = v74;
          if (v74) {
            dispatch_retain(v74);
          }
          (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, long long **, long long *))(*(void *)v73 + 80))(buf, v73, a1 + 72, a3, &v84);
          long long v75 = *(_OWORD *)buf;
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t v76 = *(std::__shared_weak_count **)(v66 + 48);
          *(_OWORD *)(v66 + 40) = v75;
          if (v76)
          {
            sub_10004D2C8(v76);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          if ((void)v84) {
            dispatch_release((dispatch_object_t)v84);
          }
          (*(void (**)(void))(**(void **)(v66 + 40) + 296))(*(void *)(v66 + 40));
          (*(void (**)(void))(**(void **)(v66 + 40) + 304))(*(void *)(v66 + 40));
        }
        else
        {
          sub_10116557C(a1);
        }
        sub_100058DB0(__p, "Personality added");
        *(_DWORD *)long long buf = 3;
        uint8_t buf[4] = 1;
        if ((SHIBYTE(v82) & 0x80000000) == 0)
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
          uint64_t v86 = v82;
          goto LABEL_138;
        }
        goto LABEL_137;
      }
      uint64_t v53 = *(void *)(a1 + 112);
      *(void *)long long buf = *(void *)(a1 + 104);
      *(void *)&uint8_t buf[8] = v53;
      if (v53) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
      }
      char isValidSimSlot = subscriber::isValidSimSlot();
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (isValidSimSlot)
      {
        if (sub_100AF2240(*(void *)(a1 + 144), *((_DWORD *)*a3 + 13)))
        {
          if (*((unsigned char *)*a3 + 49)) {
            goto LABEL_142;
          }
          uint64_t v55 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)*a3 + 13));
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v56 = subscriber::asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v56;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I SIM Personality updating for: %s (add)", buf, 0xCu);
          }
          sub_1011588A0(a1);
          uint64_t v57 = (std::string *)sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)*a3 + 13));
          uint64_t v58 = v57;
          if (*(std::string **)(*(void *)(a1 + 144) + 16) != v57)
          {
            DataModel::update(v57, (const std::string **)a3);
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 136) + 72))(buf);
            if (*(void *)buf) {
              (*(void (**)(std::string::size_type, unsigned char *))(*(void *)v58[1].__r_.__value_.__r.__words[2]
            }
                                                                      + 320))(v58[1].__r_.__value_.__r.__words[2], buf);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          int v59 = *((_DWORD *)*a3 + 13);
          sub_100058DB0(__p, "Personality added");
          *(_DWORD *)long long buf = v59;
          uint8_t buf[4] = 1;
          if ((SHIBYTE(v82) & 0x80000000) == 0)
          {
            *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
            uint64_t v86 = v82;
LABEL_138:
            sub_10011AE40();
            if (SHIBYTE(v86) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            if (SHIBYTE(v82) < 0) {
              operator delete(__p[0]);
            }
            goto LABEL_142;
          }
LABEL_137:
          sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
          goto LABEL_138;
        }
        int v60 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_142;
        }
        uint64_t v65 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v65;
        uint64_t v62 = "#E Non-existing Personality SIM: %s (add)";
      }
      else
      {
        int v60 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_142;
        }
        uint64_t v63 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v63;
        uint64_t v62 = "#E Invalid Personality SIM: %s";
      }
      goto LABEL_105;
    case 1:
      if (!*((unsigned char *)*a3 + 49)) {
        sub_101165780(a1, *((_DWORD *)*a3 + 13));
      }
      goto LABEL_142;
    case 4:
      int v16 = *a3;
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (!*a3)
      {
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          goto LABEL_142;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v43 = "Personality empty";
LABEL_64:
        uint64_t v46 = v6;
        uint32_t v47 = 2;
LABEL_65:
        _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v43, buf, v47);
        goto LABEL_142;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = (const char *)*((void *)v16 + 3);
        uint64_t v18 = (char *)v16 + 24;
        BOOL v17 = v19;
        uint64_t v20 = v18[23];
        int v21 = (char)v20;
        if ((v20 & 0x80u) != 0) {
          uint64_t v20 = *((void *)v18 + 1);
        }
        if (v21 >= 0) {
          BOOL v17 = v18;
        }
        if (!v20) {
          BOOL v17 = "<invalid>";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v17;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Personality updated: %s", buf, 0xCu);
        int v16 = *a3;
      }
      if (*((unsigned char *)v16 + 49) == 1)
      {
        uint64_t v22 = *(NSObject **)(a1 + 40);
        BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
        if (v23)
        {
          uint64_t v24 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Personality of type: %s (update)", buf, 0xCu);
        }
        if (!capabilities::ct::supportsMultipleThumpers((capabilities::ct *)v23))
        {
          sub_10116557C(a1);
          goto LABEL_142;
        }
        char v25 = (std::string *)sub_101165864(*(void *)(*(void *)(a1 + 144) + 8), *(void *)(*(void *)(a1 + 144) + 16), (uint64_t)*a3 + 24);
        __int16 v26 = v25;
        if (*(std::string **)(*(void *)(a1 + 144) + 16) == v25) {
          goto LABEL_142;
        }
        DataModel::update(v25, (const std::string **)a3);
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 136) + 72))(buf);
        if (!*(void *)buf) {
          goto LABEL_77;
        }
LABEL_76:
        (*(void (**)(std::string::size_type, unsigned char *))(*(void *)v26[1].__r_.__value_.__r.__words[2] + 320))(v26[1].__r_.__value_.__r.__words[2], buf);
LABEL_77:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_142;
      }
      uint64_t v48 = *(void *)(a1 + 112);
      *(void *)long long buf = *(void *)(a1 + 104);
      *(void *)&uint8_t buf[8] = v48;
      if (v48) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
      }
      char v49 = subscriber::isValidSimSlot();
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if ((v49 & 1) == 0)
      {
        int v60 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_142;
        }
        uint64_t v61 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v61;
        uint64_t v62 = "#E Invalid Personality SIM: %s (update)";
LABEL_105:
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, v62, buf, 0xCu);
        goto LABEL_142;
      }
      if (!sub_100AF2240(*(void *)(a1 + 144), *((_DWORD *)*a3 + 13)))
      {
        int v60 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_142;
        }
        uint64_t v64 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v64;
        uint64_t v62 = "#E Non-existing Personality SIM: %s (update)";
        goto LABEL_105;
      }
      uint64_t v50 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)*a3 + 13));
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v51 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v51;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I SIM Personality updating for: %s (update)", buf, 0xCu);
      }
      uint64_t v52 = (std::string *)sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)*a3 + 13));
      __int16 v26 = v52;
      if (*(std::string **)(*(void *)(a1 + 144) + 16) != v52)
      {
        DataModel::update(v52, (const std::string **)a3);
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 136) + 72))(buf);
        if (!*(void *)buf) {
          goto LABEL_77;
        }
        goto LABEL_76;
      }
LABEL_142:
      uint64_t v77 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I tethering: on personality update", buf, 2u);
      }
      DataServiceController::updateTetheringInternalState_sync((Registry **)a1);
      return;
    case 6:
    case 7:
      uint64_t v5 = *a3;
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (!*a3)
      {
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          goto LABEL_142;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v43 = "Personality empty";
        goto LABEL_64;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = (const char *)*((void *)v5 + 3);
        int v8 = (char *)v5 + 24;
        uint64_t v7 = v9;
        uint64_t v10 = v8[23];
        int v11 = (char)v10;
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *((void *)v8 + 1);
        }
        if (v11 >= 0) {
          uint64_t v7 = v8;
        }
        if (!v10) {
          uint64_t v7 = "<invalid>";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Personality removed: %s", buf, 0xCu);
        uint64_t v5 = *a3;
      }
      uint64_t v12 = sub_10003B004(*(void *)(a1 + 144), *((_DWORD *)v5 + 13));
      uint64_t v13 = v12;
      if (*(void *)(*(void *)(a1 + 144) + 16) != v12)
      {
        uint64_t v14 = *(char **)(v12 + 40);
        if (v14) {
          (*(void (**)(char *, uint64_t))(*(void *)&v14[*(void *)(*(void *)v14 - 320)] + 72))(&v14[*(void *)(*(void *)v14 - 320)], 21);
        }
        BOOL v15 = *(char **)(v13 + 24);
        if (v15) {
          (*(void (**)(char *, uint64_t))(*(void *)&v15[*(void *)(*(void *)v15 - 320)] + 72))(&v15[*(void *)(*(void *)v15 - 320)], 21);
        }
        goto LABEL_142;
      }
      uint64_t v44 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_142;
      }
      uint64_t v45 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v45;
      uint64_t v43 = "%s model not found";
      uint64_t v46 = v44;
      uint32_t v47 = 12;
      goto LABEL_65;
    default:
      goto LABEL_142;
  }
}

void sub_10115DED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17, dispatch_object_t object, uint64_t a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115DFC4(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 1016))
  {
    int v4 = a2 + 1;
    uint64_t v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    BOOL v6 = *(void **)(a1 + 1000);
    while (*((_DWORD *)v5 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v5[1];
      int v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          int v8 = v5;
        }
        while (!v9);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          BOOL v6 = v11;
        }
        while (!v9);
      }
      BOOL v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  uint64_t v12 = *(void **)(a1 + 1000);
  if (v12 != (void *)(a1 + 1008))
  {
    int v13 = *(_DWORD *)(a1 + 3520);
    uint64_t v14 = a2 + 1;
    do
    {
      uint64_t v15 = *v14;
      int v16 = *((_DWORD *)v12 + 7);
      if (!*v14) {
        goto LABEL_30;
      }
      BOOL v17 = v14;
      do
      {
        int v18 = *(_DWORD *)(v15 + 28);
        BOOL v19 = v18 < v16;
        if (v18 >= v16) {
          uint64_t v20 = (uint64_t *)v15;
        }
        else {
          uint64_t v20 = (uint64_t *)(v15 + 8);
        }
        if (!v19) {
          BOOL v17 = (void *)v15;
        }
        uint64_t v15 = *v20;
      }
      while (*v20);
      if (v17 != v14 && v16 >= *((_DWORD *)v17 + 7))
      {
        if ((rest::operator==() & 1) == 0 && v13 == *((_DWORD *)v12 + 7))
        {
          uint64_t v24 = 0;
          char v25 = 0;
          DataServiceController::getConnection_sync(a1, v13, 0, &v24);
          uint64_t v21 = v24;
          if (v24 && ((*(uint64_t (**)(uint64_t))(*(void *)v24 + 168))(v24) & 1) == 0) {
LABEL_33:
          }
            (*(void (**)(uint64_t))(*(void *)v21 + 72))(v21);
LABEL_34:
          if (v25) {
            sub_10004D2C8(v25);
          }
        }
      }
      else
      {
LABEL_30:
        if (v13 == v16)
        {
          uint64_t v24 = 0;
          char v25 = 0;
          DataServiceController::getConnection_sync(a1, v13, 0, &v24);
          uint64_t v21 = v24;
          if (v24 && ((*(uint64_t (**)(uint64_t))(*(void *)v24 + 168))(v24) & 1) == 0) {
            goto LABEL_33;
          }
          goto LABEL_34;
        }
      }
      uint64_t v22 = (void *)v12[1];
      if (v22)
      {
        do
        {
          BOOL v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          BOOL v23 = (void *)v12[2];
          BOOL v9 = *v23 == (void)v12;
          uint64_t v12 = v23;
        }
        while (!v9);
      }
      uint64_t v12 = v23;
    }
    while (v23 != (void *)(a1 + 1008));
  }
}

void sub_10115E260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115E27C(uint64_t a1, _DWORD *a2)
{
  if ((capabilities::ct::supportsVegaInEmergencyMode((capabilities::ct *)a1) & 1) == 0)
  {
    int v5 = a2[2] != 5 && *a2 != 0;
    if (isActive()) {
      int v6 = *(_DWORD *)(a1 + 876) != 0;
    }
    else {
      int v6 = 0;
    }
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = "";
      if (v5) {
        BOOL v9 = "";
      }
      else {
        BOOL v9 = "not ";
      }
      uint64_t v10 = asString();
      uint64_t v11 = EmCallTypeAsString();
      if (!v6) {
        int v8 = "not ";
      }
      *(_DWORD *)long long buf = 136316418;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v66 = v11;
      __int16 v67 = 2080;
      uint64_t v68 = v8;
      __int16 v69 = 2080;
      uint64_t v70 = asString();
      __int16 v71 = 2080;
      uint64_t v72 = EmCallTypeAsString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency Mode changed: %sactive (%s, %s) -> %sactive (%s, %s)", buf, 0x3Eu);
    }
    int v12 = *(_DWORD *)(a1 + 880);
    uint64_t v13 = *(void *)(a1 + 112);
    *(void *)long long buf = *(void *)(a1 + 104);
    *(void *)&uint8_t buf[8] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    char isValidSimSlot = subscriber::isValidSimSlot();
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (isValidSimSlot)
    {
      uint64_t v15 = sub_10003B004(*(void *)(a1 + 144), v12);
      uint64_t v16 = v15;
      if (*(void *)(*(void *)(a1 + 144) + 16) == v15 || (uint64_t v17 = *(void *)(v15 + 40)) == 0)
      {
        uint64_t v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          uint64_t v51 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v51;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to get model for : %s", buf, 0xCu);
        }
      }
      else
      {
        int v18 = *(_DWORD *)(a1 + 884);
        int v19 = a2[2];
        if (v18 == 2 && v19 == 5)
        {
          uint64_t v20 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Attempting Cellular preferred upon Emergency Intent", buf, 2u);
            uint64_t v17 = *(void *)(v16 + 40);
          }
          (*(void (**)(uint64_t))(*(void *)v17 + 560))(v17);
        }
        else if (v18 == 5 && v19 == 2)
        {
          uint64_t v50 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Resetting Emergency Intent", buf, 2u);
            uint64_t v17 = *(void *)(v16 + 40);
          }
          (*(void (**)(uint64_t))(*(void *)v17 + 568))(v17);
        }
      }
    }
    if (v5 != v6)
    {
      uint64_t v22 = *(void *)(a1 + 144);
      uint64_t v24 = *(void **)(v22 + 8);
      BOOL v23 = *(void **)(v22 + 16);
      uint64_t v52 = v23;
      if (v6)
      {
        if (v24 != v23)
        {
          do
          {
            int v25 = *(_DWORD *)(a1 + 880);
            if (v25)
            {
              uint64_t v27 = v24[52];
              __int16 v26 = (std::__shared_weak_count *)v24[53];
              if (v26)
              {
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                int v28 = *(_DWORD *)(v27 + 52);
                sub_10004D2C8(v26);
                int v25 = *(_DWORD *)(a1 + 880);
              }
              else
              {
                int v28 = *(_DWORD *)(v27 + 52);
              }
              if (v28 != v25)
              {
                uint64_t v29 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v30 = (std::__shared_weak_count *)v24[53];
                  if (v30)
                  {
                    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v30);
                  }
                  uint64_t v31 = subscriber::asString();
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v31;
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Deactivating all settings for iWLAN transport on %s", buf, 0xCu);
                }
                int v32 = (uint64_t *)v24[7];
                int v33 = (uint64_t *)v24[8];
                while (v32 != v33)
                {
                  uint64_t v35 = *v32;
                  BOOL v34 = (std::__shared_weak_count *)v32[1];
                  if (v34) {
                    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (v35)
                  {
                    BOOL v36 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                    {
                      (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v35 + 240))(buf, v35, 1);
                      uint64_t v37 = buf;
                      if (buf[23] < 0) {
                        uint64_t v37 = *(unsigned char **)buf;
                      }
                      *(_DWORD *)uint64_t v64 = 136315138;
                      *(void *)&v64[4] = v37;
                      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Disabling: %s", v64, 0xCu);
                      if ((buf[23] & 0x80000000) != 0) {
                        operator delete(*(void **)buf);
                      }
                    }
                    (*(void (**)(uint64_t, uint64_t, uint64_t, const char *, const char *))(*(void *)v35
                                                                                                  + 728))(v35, 1, 26, "unknown", "CommCenter");
                    long long __p = 0;
                    uint64_t v56 = 0;
                    uint64_t v57 = 0;
                    sub_100058DB0(buf, "");
                    int v63 = 1;
                    char v62 = 0;
                    *(void *)uint64_t v64 = 0;
                    int v61 = 0;
                    char v60 = 0;
                    sub_100DA199C(&v63, (uint64_t)&__p, (long long *)buf, &v62, (uint64_t *)v64, &v61, &v60, &v58);
                    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v35 + 440))(v35, 1, &v58);
                    if (v59) {
                      sub_10004D2C8(v59);
                    }
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                    if (__p)
                    {
                      uint64_t v56 = __p;
                      operator delete(__p);
                    }
                  }
                  if (v34) {
                    sub_10004D2C8(v34);
                  }
                  v32 += 2;
                }
              }
            }
            v24 += 54;
          }
          while (v24 != v52);
        }
      }
      else if (v24 != v23)
      {
        do
        {
          uint64_t v39 = v24[52];
          uint64_t v38 = (std::__shared_weak_count *)v24[53];
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            int v40 = *(_DWORD *)(v39 + 52);
            sub_10004D2C8(v38);
          }
          else
          {
            int v40 = *(_DWORD *)(v39 + 52);
          }
          if (v40 != *(_DWORD *)(a1 + 880))
          {
            unint64_t v41 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v42 = (std::__shared_weak_count *)v24[53];
              if (v42)
              {
                atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v42);
              }
              uint64_t v43 = subscriber::asString();
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v43;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Resetting activation blockers for iWLAN transport on %s", buf, 0xCu);
            }
            uint64_t v44 = (uint64_t *)v24[7];
            uint64_t v45 = (uint64_t *)v24[8];
            while (v44 != v45)
            {
              uint64_t v47 = *v44;
              uint64_t v46 = (std::__shared_weak_count *)v44[1];
              if (v46) {
                atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (v47)
              {
                uint64_t v48 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                {
                  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v47 + 240))(buf, v47, 1);
                  char v49 = buf;
                  if (buf[23] < 0) {
                    char v49 = *(unsigned char **)buf;
                  }
                  *(_DWORD *)uint64_t v64 = 136315138;
                  *(void *)&v64[4] = v49;
                  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Re-enabling: %s", v64, 0xCu);
                  if ((buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                }
                (*(void (**)(uint64_t, uint64_t, const char *, void, void))(*(void *)v47 + 424))(v47, 1, "Emergency Mode exit", 0, 0);
              }
              if (v46) {
                sub_10004D2C8(v46);
              }
              v44 += 2;
            }
            sub_100058DB0(v53, "Emergency Mode exit");
            *(_DWORD *)long long buf = 3;
            uint8_t buf[4] = 1;
            if (SHIBYTE(v54) < 0)
            {
              sub_10004FC84(&buf[8], v53[0], (unint64_t)v53[1]);
            }
            else
            {
              *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v53;
              uint64_t v66 = v54;
            }
            sub_10011AE40();
            if (SHIBYTE(v66) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            if (SHIBYTE(v54) < 0) {
              operator delete(v53[0]);
            }
          }
          v24 += 54;
        }
        while (v24 != v52);
      }
    }
  }
}

void sub_10115EAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,int a34,__int16 a35,char a36,char a37,int a38,__int16 a39,char a40,char a41)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115EB70(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I tethering: on entitlements update", v3, 2u);
  }
  DataServiceController::updateTetheringInternalState_sync((Registry **)a1);
  DataServiceController::updateSlicingStateOnEntitlementsChange_sync((DataServiceController *)a1);
}

void sub_10115EBE4(uint64_t a1, uint64_t a2, BOOL a3)
{
  if ((capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0 && sub_100AF2240(*(void *)(a1 + 144), a2))
  {
    uint64_t v6 = *(void *)(a1 + 152);
    uint64_t v7 = sub_100AEFE40(*(void *)(a1 + 144), a2);
    int v8 = *(std::__shared_weak_count **)(v7 + 424);
    *(void *)long long buf = *(void *)(v7 + 416);
    *(void *)&uint8_t buf[8] = v8;
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      int v9 = sub_100AE5180(v6, (uint64_t)buf);
      sub_10004D2C8(v8);
    }
    else
    {
      int v9 = sub_100AE5180(v6, (uint64_t)buf);
    }
    char v14 = v9;
    if ((v9 == 2) != a3)
    {
      uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = asStringBool(v9 == 2);
        uint64_t v12 = asStringBool(a3);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I (change states) legacy provisioned status: from %s to %s", buf, 0x16u);
      }
    }
    if (a3) {
      char v13 = 2;
    }
    else {
      char v13 = 1;
    }
    buf[0] = v13;
    sub_101167D40(a1, a2, &v14, buf);
  }
}

uint64_t **sub_10115ED8C(uint64_t a1, int a2)
{
  int v6 = a2;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband refresh start received", v5, 2u);
  }
  uint64_t v7 = &v6;
  uint64_t result = sub_10005CE78((uint64_t **)(a1 + 5104), &v6, (uint64_t)&unk_10144E20E, &v7);
  *((unsigned char *)result + 32) = 1;
  return result;
}

void sub_10115EE4C(uint64_t a1, int a2)
{
  int v27 = a2;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband refresh complete received", buf, 2u);
  }
  *(void *)long long buf = &v27;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 5104), &v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 0;
  sub_10003E168(buf, (void *)(a1 + 8));
  uint64_t v5 = *(void *)buf;
  int v4 = v29;
  if (v29)
  {
    atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
  }
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 104));
  uint64_t v6 = *(void *)buf;
  sub_100058DB0(__p, "PostBasebandRefreshTimer");
  uint64_t v7 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_101185EB0;
  aBlock[3] = &unk_101A95D98;
  aBlock[4] = a1;
  aBlock[5] = v5;
  uint64_t v20 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v21 = v27;
  uint64_t v22 = _Block_copy(aBlock);
  sub_100118A44(v6, (uint64_t)__p, 0, 5000000, &object, &v22);
  int v8 = v27;
  int v9 = *(uint64_t **)(a1 + 5136);
  if (v9)
  {
    do
    {
      while (1)
      {
        uint64_t v10 = (uint64_t **)v9;
        int v11 = *((_DWORD *)v9 + 8);
        if (v11 <= v27) {
          break;
        }
        int v9 = *v10;
        uint64_t v12 = v10;
        if (!*v10) {
          goto LABEL_18;
        }
      }
      if (v11 >= v27)
      {
        uint64_t v15 = v10;
        goto LABEL_21;
      }
      int v9 = v10[1];
    }
    while (v9);
    uint64_t v12 = v10 + 1;
  }
  else
  {
    uint64_t v12 = (uint64_t **)(a1 + 5136);
    uint64_t v10 = (uint64_t **)(a1 + 5136);
  }
LABEL_18:
  uint64_t v15 = operator new(0x38uLL);
  v15[8] = v8;
  *((void *)v15 + 5) = 0;
  *((void *)v15 + 6) = 0;
  *(void *)uint64_t v15 = 0;
  *((void *)v15 + 1) = 0;
  *((void *)v15 + 2) = v10;
  void *v12 = (uint64_t *)v15;
  uint64_t v13 = **(void **)(a1 + 5128);
  char v14 = (uint64_t *)v15;
  if (v13)
  {
    *(void *)(a1 + 5128) = v13;
    char v14 = *v12;
  }
  sub_100046C90(*(uint64_t **)(a1 + 5136), v14);
  ++*(void *)(a1 + 5144);
LABEL_21:
  sub_1004DC2E0((void *)v15 + 5, &v26);
  uint64_t v16 = v26;
  uint64_t v26 = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  if (v22) {
    _Block_release(v22);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v17 = sub_10003B004(*(void *)(a1 + 144), v27);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v17)
  {
    uint64_t v18 = *(void *)(v17 + 24);
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 848))(v18);
    }
  }
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10115F180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  int v28 = *(std::__shared_weak_count **)(v26 - 56);
  if (v28) {
    sub_10004D2C8(v28);
  }
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115F23C(Registry **a1)
{
  int v2 = (std::__shared_weak_count *)a1[14];
  uint64_t v6 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v4 = v7;
  if (v7 != v8)
  {
    while ((v9(*v4) & 1) == 0)
    {
      if (++v4 == v8)
      {
        int v4 = v8;
        break;
      }
    }
LABEL_9:
    while (v4 != v8)
    {
      uint64_t v5 = v4 + 1;
      sub_1011646C8(a1, *v4, 22, 1, 1);
      int v4 = v8;
      if (v5 != v8)
      {
        int v4 = v5;
        while ((v9(*v4) & 1) == 0)
        {
          if (++v4 == v8)
          {
            int v4 = v8;
            goto LABEL_9;
          }
        }
      }
    }
  }
  DataServiceController::updateIpcConfiguration_sync(a1, v3);
}

void sub_10115F334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10115F34C(uint64_t a1, uint64_t *a2)
{
  int v4 = (void *)(a1 + 2776);
  if ((operator==() & 1) == 0)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 47) >= 0) {
        uint64_t v6 = a2 + 3;
      }
      else {
        uint64_t v6 = (uint64_t *)a2[3];
      }
      uint64_t v7 = (uint64_t *)*a2;
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      int v8 = (void *)(a1 + 2800);
      if (*(char *)(a1 + 2823) < 0) {
        int v8 = (void *)*v8;
      }
      if (*(char *)(a1 + 2799) < 0) {
        int v4 = (void *)*v4;
      }
      int v13 = 136315906;
      char v14 = v6;
      __int16 v15 = 2080;
      uint64_t v16 = v7;
      __int16 v17 = 2080;
      uint64_t v18 = v8;
      __int16 v19 = 2080;
      uint64_t v20 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I WiFi AP has changed from '%s' (%s) to '%s' (%s)", (uint8_t *)&v13, 0x2Au);
    }
    uint64_t v9 = *(void *)(a1 + 144);
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v11 = *(void *)(v9 + 16);
    while (v10 != v11)
    {
      uint64_t v12 = *(void *)(v10 + 40);
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 576))(v12);
      }
      v10 += 432;
    }
  }
}

void sub_10115F4B0(DataServiceController *this)
{
  if (*((unsigned char *)this + 288)) {
    return;
  }
  uint64_t v1 = this;
  if (!*((unsigned char *)this + 312))
  {
    uint64_t v73 = *((void *)this + 5);
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "handleDumpState_sync";
    uint64_t v74 = "#E %s: !!! too early start";
    long long v75 = v73;
    uint32_t v76 = 12;
    goto LABEL_302;
  }
  DataServiceController::dumpTetheringStatus(this);
  int v2 = *((void *)v1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========================== Begin Dump Data Service ==========================", buf, 2u);
    int v2 = *((void *)v1 + 5);
  }
  int64x2_t v249 = v1;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*((unsigned char *)v1 + 312));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataModuleInitialized=%s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asStringBool(*((unsigned char *)v1 + 313));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataBlocked=%s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asStringBool(*((unsigned char *)v1 + 292));
    uint64_t v6 = asStringBool(*((unsigned char *)v1 + 293));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fIsInCall = %s, fIsInCallHandoverBlocked=%s", buf, 0x16u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asStringBool(*((unsigned char *)v1 + 832));
    unsigned __int8 v8 = atomic_load((unsigned __int8 *)v1 + 4176);
    uint64_t v9 = asStringBool(v8 & 1);
    uint64_t v10 = asStringBool(*((unsigned char *)v1 + 4177));
    uint64_t v11 = asStringBool(*((unsigned char *)v1 + 4584));
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v10;
    *(_WORD *)&uint8_t buf[32] = 2080;
    *(void *)&unsigned char buf[34] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: Airplane mode: %s : %s (initialized %s), fWifiAvailable: %s", buf, 0x2Au);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool(*((unsigned char *)v1 + 4377));
    uint64_t v13 = asStringBool(*((void *)v1 + 548) != 0);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: Radio off: %s, timer : %s", buf, 0x16u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asStringBool(*((unsigned char *)v1 + 617));
    uint64_t v15 = asStringBool(*((unsigned char *)v1 + 4096));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: Cellular settings: %s, (initialized: %s)", buf, 0x16u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(*((unsigned char *)v1 + 618));
    uint64_t v17 = asStringBool(*((unsigned char *)v1 + 4097));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: Cellular settings internal: %s, (initialized: %s)", buf, 0x16u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v18 = (*(uint64_t (**)(DataServiceController *))(*(void *)v1 + 1760))(v1);
    uint64_t v19 = asStringBool(v18);
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: NEConfigurationStarted: %s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v20 = (*(uint64_t (**)(DataServiceController *))(*(void *)v1 + 1768))(v1);
    uint64_t v21 = asStringBool(v20);
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fTicketAvailableSink: %s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = asStringBool(*((unsigned char *)v1 + 289));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fTetheringAssertion = %s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v23 = atomic_load((unsigned int *)v1 + 1045);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fPendingActivations = %u", buf, 8u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asStringBool(*((unsigned char *)v1 + 314));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fActivationEnabled = %s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = asStringBool(*((unsigned char *)v1 + 800));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fBasebandActivatedSink = %s", buf, 0xCu);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = *((_DWORD *)v1 + 1288);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v26;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fUlHealthEmergencyBottleneckStateNotifyToken: %d", buf, 8u);
    int v2 = *((void *)v1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = *((_DWORD *)v1 + 286);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: Airplane Mode User Preference %u", buf, 8u);
  }
  int v28 = (void *)*((void *)v1 + 560);
  uint64_t v29 = (void *)((char *)v1 + 4488);
  if (v28 != (void *)((char *)v1 + 4488))
  {
    do
    {
      uint64_t v30 = *((void *)v1 + 5);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = subscriber::asString();
        asStringUiMask((uint64_t *)buf, *((_DWORD *)v28 + 8));
        if (buf[23] >= 0) {
          int v32 = buf;
        }
        else {
          int v32 = *(unsigned char **)buf;
        }
        *(_DWORD *)unint64_t v290 = 136315394;
        *(void *)&v290[4] = v31;
        *(_WORD *)&v290[12] = 2082;
        *(void *)&v290[14] = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataUiModifier[%s]=%{public}s", v290, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v1 = v249;
      }
      int v33 = (void *)v28[1];
      if (v33)
      {
        do
        {
          BOOL v34 = v33;
          int v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          BOOL v34 = (void *)v28[2];
          BOOL v35 = *v34 == (void)v28;
          int v28 = v34;
        }
        while (!v35);
      }
      int v28 = v34;
    }
    while (v34 != v29);
  }
  uint64_t v36 = *((void *)v1 + 18);
  uint64_t v38 = *(void *)(v36 + 8);
  for (uint64_t i = *(void *)(v36 + 16); v38 != i; v38 += 432)
  {
    uint64_t v39 = *((void *)v249 + 5);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = *(void *)(v38 + 416);
      int v40 = *(std::__shared_weak_count **)(v38 + 424);
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        int v42 = *(_DWORD *)(v41 + 52);
        sub_10004D2C8(v40);
      }
      else
      {
        int v42 = *(_DWORD *)(v41 + 52);
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v42;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------------------- Data Connections <SIM %d> --------------------------", buf, 8u);
    }
    uint64_t v43 = *(void **)v38;
    uint64_t v44 = *(void **)(v38 + 8);
    while (v43 != v44)
    {
      if (*v43) {
        (*(void (**)(void))(*(void *)*v43 + 416))(*v43);
      }
      v43 += 2;
    }
    uint64_t v45 = *(char **)(v38 + 24);
    if (v45)
    {
      (*(void (**)(char *))(*(void *)&v45[*(void *)(*(void *)v45 - 320)] + 240))(&v45[*(void *)(*(void *)v45 - 320)]);
    }
    else
    {
      uint64_t v46 = *((void *)v249 + 5);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I DATA:: **No BBDataDriver**", buf, 2u);
      }
    }
    uint64_t v47 = *(char **)(v38 + 40);
    if (v47)
    {
      (*(void (**)(char *))(*(void *)&v47[*(void *)(*(void *)v47 - 320)] + 240))(&v47[*(void *)(*(void *)v47 - 320)]);
    }
    else
    {
      uint64_t v48 = *((void *)v249 + 5);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I DATA:: **No TechDataDriver**", buf, 2u);
      }
    }
    char v49 = *((void *)v249 + 5);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- BB DataSettings (DS) --------------", buf, 2u);
    }
    uint64_t v51 = *(uint64_t **)(v38 + 56);
    uint64_t v50 = *(uint64_t **)(v38 + 64);
    while (v51 != v50)
    {
      uint64_t v52 = *v51;
      uint64_t v53 = (std::__shared_weak_count *)v51[1];
      if (v53) {
        atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v52)
      {
        (*(void (**)(uint64_t))(*(void *)v52 + 664))(v52);
      }
      else
      {
        uint64_t v54 = *((void *)v249 + 5);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I DATA:: ---------------- **Null DataSetting** (DS) -------------------", buf, 2u);
        }
      }
      if (v53) {
        sub_10004D2C8(v53);
      }
      uint64_t v50 = *(uint64_t **)(v38 + 64);
      v51 += 2;
    }
  }
  uint64_t v55 = *((void *)v249 + 5);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------------------- Data PDP Activators --------------------------", buf, 2u);
  }
  uint64_t v56 = *((void *)v249 + 517);
  uint64_t v57 = *((void *)v249 + 518);
  while (v56 != v57)
  {
    (*(void (**)(void))(**(void **)v56 + 184))();
    v56 += 16;
  }
  uint64_t v58 = v249;
  int v59 = *((void *)v249 + 5);
  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------------------- Other Objects --------------------------", buf, 2u);
  }
  uint64_t v61 = *((void *)v249 + 32);
  if (v61)
  {
    (*(void (**)(uint64_t))(*(void *)v61 + 64))(v61);
    uint64_t v58 = v249;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v60, *((Registry **)v58 + 13));
  int v63 = ServiceMap;
  if (v64 < 0)
  {
    uint64_t v65 = (unsigned __int8 *)(v64 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v66 = 5381;
    do
    {
      uint64_t v64 = v66;
      unsigned int v67 = *v65++;
      uint64_t v66 = (33 * v66) ^ v67;
    }
    while (v67);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v64;
  uint64_t v68 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)buf);
  if (!v68)
  {
    uint64_t v70 = 0;
LABEL_101:
    uint64_t v72 = v249;
    std::mutex::unlock(v63);
    __int16 v69 = 0;
    char v71 = 1;
    if (!v70) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  uint64_t v70 = v68[3];
  __int16 v69 = (std::__shared_weak_count *)v68[4];
  if (!v69) {
    goto LABEL_101;
  }
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v63);
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v69);
  char v71 = 0;
  uint64_t v72 = v249;
  if (v70) {
LABEL_102:
  }
    (*(void (**)(uint64_t))(*(void *)v70 + 144))(v70);
LABEL_103:
  if ((v71 & 1) == 0) {
    sub_10004D2C8(v69);
  }
  uint64_t v77 = *((void *)v72 + 5);
  if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========================== State Cache ==========================", buf, 2u);
  }
  uint64_t v78 = *((void *)v72 + 18);
  uint64_t v245 = *(void *)(v78 + 8);
  uint64_t v243 = *(void *)(v78 + 16);
  if (v245 != v243)
  {
    int v244 = (void *)((char *)v72 + 328);
    do
    {
      uint64_t v79 = *((void *)v72 + 5);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        char v80 = *(std::__shared_weak_count **)(v245 + 424);
        if (v80)
        {
          atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v80);
        }
        uint64_t v81 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v81;
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I DATA:: SIM = %s", buf, 0xCu);
        uint64_t v72 = v249;
        uint64_t v79 = *((void *)v249 + 5);
      }
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v82 = *((void *)v72 + 19);
        uint64_t v83 = *(std::__shared_weak_count **)(v245 + 424);
        *(void *)long long buf = *(void *)(v245 + 416);
        *(void *)&uint8_t buf[8] = v83;
        if (v83) {
          atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v84 = sub_100AE4330(v82, (uint64_t)buf);
        uint64_t v85 = asStringBool(v84);
        *(_DWORD *)unint64_t v290 = 136315138;
        *(void *)&v290[4] = v85;
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I DATA:: suspendInternetOnBBCall = %s", v290, 0xCu);
        if (v83) {
          sub_10004D2C8(v83);
        }
      }
      memset(v290, 0, 24);
      uint64_t v86 = *((void *)v72 + 19);
      uint64_t v88 = *(void *)(v245 + 416);
      unsigned int v87 = *(std::__shared_weak_count **)(v245 + 424);
      if (v87)
      {
        atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
        int v89 = *(_DWORD *)(v88 + 52);
        sub_10004D2C8(v87);
      }
      else
      {
        int v89 = *(_DWORD *)(v88 + 52);
      }
      sub_100AE4634(v86, v89, v290);
      __int16 v90 = *((void *)v72 + 5);
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v92 = *(void *)(v245 + 416);
        int64_t v91 = *(std::__shared_weak_count **)(v245 + 424);
        if (v91)
        {
          atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
          int v93 = *(_DWORD *)(v92 + 52);
          sub_10004D2C8(v91);
        }
        else
        {
          int v93 = *(_DWORD *)(v92 + 52);
        }
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v93;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========================== Connections availability (%d) ==========================", buf, 8u);
      }
      uint64_t v94 = *(void *)v290;
      uint64_t v95 = *(void *)&v290[8];
      if (*(void *)&v290[8] != *(void *)v290)
      {
        unint64_t v96 = 0;
        unsigned int v247 = 0;
        do
        {
          BOOL v97 = *((void *)v72 + 5);
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v98 = asString();
            if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3) <= v96) {
              sub_10015B728();
            }
            int v99 = *(_DWORD *)(*(void *)v290 + 56 * v96);
            *(_DWORD *)long long buf = 136315650;
            size_t v100 = "false";
            if (!v99) {
              size_t v100 = "true";
            }
            *(void *)&uint8_t buf[4] = v98;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v100;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v99;
            _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I DATA:: %-43s: %s (%d)", buf, 0x1Cu);
            BOOL v97 = *((void *)v72 + 5);
            uint64_t v94 = *(void *)v290;
            uint64_t v95 = *(void *)&v290[8];
          }
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v101 = 0x6DB6DB6DB6DB6DB7 * ((v95 - v94) >> 3);
            if (v101 <= v96) {
              goto LABEL_304;
            }
            int v102 = *(_DWORD *)(v94 + 56 * v96);
            unsigned int v103 = v102 ? "f" : "t";
            if (v102)
            {
              BOOL v104 = (const char *)asString();
              uint64_t v94 = *(void *)v290;
              unint64_t v101 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3);
            }
            else
            {
              BOOL v104 = "OK";
            }
            if (v101 <= v96) {
              goto LABEL_304;
            }
            uint64_t v105 = v94 + 56 * v96;
            uint64_t v107 = *(void *)(v105 + 8);
            uint64_t v106 = *(void *)(v105 + 16);
            uint64_t v108 = asStringBool(*(unsigned char *)(v105 + 24));
            if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3) <= v96
              || (uint64_t v109 = v108,
                  uint64_t v110 = asStringBool(*(unsigned char *)(*(void *)v290 + 56 * v96 + 25)),
                  0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3) <= v96)
              || (uint64_t v111 = v110,
                  uint64_t v112 = asStringBool(*(unsigned char *)(*(void *)v290 + 56 * v96 + 26)),
                  0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3) <= v96))
            {
LABEL_304:
              sub_10015B728();
            }
            uint64_t v113 = v112;
            uint64_t v114 = asStringBool(*(unsigned char *)(*(void *)v290 + 56 * v96 + 27));
            *(_DWORD *)long long buf = 136316930;
            *(void *)&uint8_t buf[4] = v103;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v104;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v107;
            *(_WORD *)&uint8_t buf[32] = 2080;
            *(void *)&unsigned char buf[34] = v106;
            *(_WORD *)&buf[42] = 2080;
            *(void *)&buf[44] = v109;
            *(_WORD *)&buf[52] = 2080;
            *(void *)&buf[54] = v111;
            *(_WORD *)&buf[62] = 2080;
            *(void *)&buf[64] = v113;
            __int16 v276 = 2080;
            uint64_t v277 = v114;
            _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x52u);
            uint64_t v94 = *(void *)v290;
            uint64_t v95 = *(void *)&v290[8];
            uint64_t v72 = v249;
          }
          if (0x6DB6DB6DB6DB6DB7 * ((v95 - v94) >> 3) <= v96) {
            sub_10015B728();
          }
          uint64_t v115 = v94 + 56 * v96;
          uint64_t v116 = *(void *)(v115 + 40);
          unsigned int v117 = *(std::__shared_weak_count **)(v115 + 48);
          if (v117) {
            atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v116)
          {
            do
            {
              unsigned int v118 = *((void *)v72 + 5);
              if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
              {
                if (*(_DWORD *)v116) {
                  BOOL v119 = "f";
                }
                else {
                  BOOL v119 = "t";
                }
                if (*(_DWORD *)v116) {
                  __int16 v120 = (const char *)asString();
                }
                else {
                  __int16 v120 = "OK";
                }
                uint64_t v122 = *(void *)(v116 + 8);
                uint64_t v121 = *(void *)(v116 + 16);
                uint64_t v123 = asStringBool(*(unsigned char *)(v116 + 24));
                uint64_t v124 = asStringBool(*(unsigned char *)(v116 + 25));
                uint64_t v125 = asStringBool(*(unsigned char *)(v116 + 26));
                uint64_t v126 = asStringBool(*(unsigned char *)(v116 + 27));
                *(_DWORD *)long long buf = 136316930;
                *(void *)&uint8_t buf[4] = v119;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v120;
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)&unsigned char buf[24] = v122;
                *(_WORD *)&uint8_t buf[32] = 2080;
                *(void *)&unsigned char buf[34] = v121;
                *(_WORD *)&buf[42] = 2080;
                *(void *)&buf[44] = v123;
                *(_WORD *)&buf[52] = 2080;
                *(void *)&buf[54] = v124;
                *(_WORD *)&buf[62] = 2080;
                *(void *)&buf[64] = v125;
                __int16 v276 = 2080;
                uint64_t v277 = v126;
                _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I DATA::  chained: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x52u);
                uint64_t v72 = v249;
              }
              uint64_t v127 = *(void *)(v116 + 40);
              uint64_t v128 = *(std::__shared_weak_count **)(v116 + 48);
              if (v128) {
                atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (v117) {
                sub_10004D2C8(v117);
              }
              unsigned int v117 = v128;
              uint64_t v116 = v127;
            }
            while (v127);
          }
          else
          {
            uint64_t v128 = v117;
          }
          if (!v247)
          {
            uint64_t v130 = *(void *)(v245 + 416);
            uint64_t v129 = *(std::__shared_weak_count **)(v245 + 424);
            if (v129)
            {
              atomic_fetch_add_explicit(&v129->__shared_owners_, 1uLL, memory_order_relaxed);
              int v131 = *(_DWORD *)(v130 + 52);
              sub_10004D2C8(v129);
            }
            else
            {
              int v131 = *(_DWORD *)(v130 + 52);
            }
            uint64_t v132 = *v244;
            if (!*v244) {
              goto LABEL_183;
            }
            int v133 = v244;
            do
            {
              int v134 = *(_DWORD *)(v132 + 32);
              BOOL v135 = v134 < v131;
              if (v134 >= v131) {
                xpc_object_t v136 = (uint64_t *)v132;
              }
              else {
                xpc_object_t v136 = (uint64_t *)(v132 + 8);
              }
              if (!v135) {
                int v133 = (void *)v132;
              }
              uint64_t v132 = *v136;
            }
            while (*v136);
            if (v133 != v244 && v131 >= *((_DWORD *)v133 + 8))
            {
              unint64_t v138 = *((void *)v72 + 5);
              if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "#I DATA:: Internet availability for any SIM:", buf, 2u);
                unint64_t v138 = *((void *)v72 + 5);
              }
              if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
              {
                int v139 = *((_DWORD *)v133 + 10);
                if (v139) {
                  __int16 v140 = "f";
                }
                else {
                  __int16 v140 = "t";
                }
                if (v139) {
                  int v141 = (const char *)asString();
                }
                else {
                  int v141 = "OK";
                }
                uint64_t v143 = v133[6];
                uint64_t v142 = v133[7];
                uint64_t v144 = asStringBool(*((unsigned char *)v133 + 64));
                uint64_t v145 = asStringBool(*((unsigned char *)v133 + 65));
                uint64_t v146 = asStringBool(*((unsigned char *)v133 + 66));
                uint64_t v147 = asStringBool(*((unsigned char *)v133 + 67));
                *(_DWORD *)long long buf = 136316930;
                *(void *)&uint8_t buf[4] = v140;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v141;
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)&unsigned char buf[24] = v143;
                *(_WORD *)&uint8_t buf[32] = 2080;
                *(void *)&unsigned char buf[34] = v142;
                *(_WORD *)&buf[42] = 2080;
                *(void *)&buf[44] = v144;
                *(_WORD *)&buf[52] = 2080;
                *(void *)&buf[54] = v145;
                *(_WORD *)&buf[62] = 2080;
                *(void *)&buf[64] = v146;
                __int16 v276 = 2080;
                uint64_t v277 = v147;
                _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x52u);
                uint64_t v72 = v249;
              }
            }
            else
            {
LABEL_183:
              xpc_object_t v137 = *((void *)v72 + 5);
              if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, "#I DATA:: no Internet availability for any SIM", buf, 2u);
              }
            }
          }
          if (v128) {
            sub_10004D2C8(v128);
          }
          uint64_t v94 = *(void *)v290;
          uint64_t v95 = *(void *)&v290[8];
          unint64_t v96 = ++v247;
        }
        while (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3) > (unint64_t)v247);
      }
      *(void *)long long buf = v290;
      sub_1002AC5A8((void ***)buf);
      v245 += 432;
    }
    while (v245 != v243);
  }
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)buf);
  int v148 = buf[28];
  if (*(void *)&buf[48]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[48]);
  }
  long long v149 = *((void *)v72 + 5);
  BOOL v150 = os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT);
  if (v148)
  {
    if (!v150) {
      goto LABEL_250;
    }
    sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v290);
    if (*(_DWORD *)v290) {
      uint64_t v151 = "f";
    }
    else {
      uint64_t v151 = "t";
    }
    sub_100AE44D0(*((void *)v72 + 19), (uint64_t)&v271);
    int v152 = v271;
    if (v271)
    {
      sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v269);
      uint64_t v153 = (const char *)asString();
    }
    else
    {
      uint64_t v153 = "OK";
    }
    sub_100AE44D0(*((void *)v72 + 19), (uint64_t)&v265);
    uint64_t v157 = v266;
    sub_100AE44D0(*((void *)v72 + 19), (uint64_t)__p);
    uint64_t v158 = v72;
    uint64_t v159 = v263;
    sub_100AE44D0(*((void *)v158 + 19), (uint64_t)v258);
    uint64_t v160 = asStringBool(v260);
    sub_100AE44D0(*((void *)v158 + 19), (uint64_t)v254);
    uint64_t v161 = asStringBool(v256);
    sub_100AE44D0(*((void *)v158 + 19), (uint64_t)v252);
    uint64_t v162 = asStringBool(v252[26]);
    sub_100AE44D0(*((void *)v158 + 19), (uint64_t)v250);
    uint64_t v163 = asStringBool(v250[27]);
    *(_DWORD *)long long buf = 136317186;
    *(void *)&uint8_t buf[4] = "lastInternetActivationError";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v151;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v153;
    *(_WORD *)&uint8_t buf[32] = 2080;
    *(void *)&unsigned char buf[34] = v157;
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v159;
    *(_WORD *)&buf[52] = 2080;
    *(void *)&buf[54] = v160;
    *(_WORD *)&buf[62] = 2080;
    *(void *)&buf[64] = v161;
    __int16 v276 = 2080;
    uint64_t v277 = v162;
    __int16 v278 = 2080;
    uint64_t v279 = v163;
    _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x5Cu);
    if (v251) {
      sub_10004D2C8(v251);
    }
    uint64_t v72 = v249;
    if (v253) {
      sub_10004D2C8(v253);
    }
    if (v257) {
      sub_10004D2C8(v257);
    }
    if (v261) {
      sub_10004D2C8(v261);
    }
    if (v264) {
      sub_10004D2C8(v264);
    }
    if (v268) {
      sub_10004D2C8(v268);
    }
    if (!v152) {
      goto LABEL_246;
    }
    goto LABEL_244;
  }
  if (!v150) {
    goto LABEL_250;
  }
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v290);
  if (*(_DWORD *)v290) {
    unint64_t v154 = "f";
  }
  else {
    unint64_t v154 = "t";
  }
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)&v271);
  int v155 = v271;
  if (v271)
  {
    sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v269);
    uint64_t v156 = (const char *)asString();
  }
  else
  {
    uint64_t v156 = "OK";
  }
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)&v265);
  if (v266 && *v266) {
    uint64_t v164 = "{";
  }
  else {
    uint64_t v164 = "";
  }
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)__p);
  uint64_t v165 = __p[1];
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v258);
  uint64_t v166 = v259;
  sub_100AE44D0(*((void *)v72 + 19), (uint64_t)v254);
  if (v255 && *v255) {
    long long v167 = "}";
  }
  else {
    long long v167 = "";
  }
  *(_DWORD *)long long buf = 136316674;
  *(void *)&uint8_t buf[4] = "lastInternetActivationError";
  *(_WORD *)&unsigned char buf[12] = 2080;
  *(void *)&buf[14] = v154;
  *(_WORD *)&unsigned char buf[22] = 2080;
  *(void *)&unsigned char buf[24] = v156;
  *(_WORD *)&uint8_t buf[32] = 2080;
  *(void *)&unsigned char buf[34] = v164;
  *(_WORD *)&buf[42] = 2080;
  *(void *)&buf[44] = v165;
  *(_WORD *)&buf[52] = 2080;
  *(void *)&buf[54] = v166;
  *(_WORD *)&buf[62] = 2080;
  *(void *)&buf[64] = v167;
  _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s: %s(%s%s%s %s%s)", buf, 0x48u);
  if (v257) {
    sub_10004D2C8(v257);
  }
  if (v261) {
    sub_10004D2C8(v261);
  }
  if (v264) {
    sub_10004D2C8(v264);
  }
  if (v268) {
    sub_10004D2C8(v268);
  }
  if (v155)
  {
LABEL_244:
    if (v270) {
      sub_10004D2C8(v270);
    }
  }
LABEL_246:
  if (v274) {
    sub_10004D2C8(v274);
  }
  if (v291) {
    sub_10004D2C8(v291);
  }
LABEL_250:
  uint64_t v168 = *((void *)v72 + 5);
  if (os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v170 = *((void *)v72 + 19);
    uint64_t v169 = (os_unfair_lock_s **)((char *)v72 + 152);
    os_unfair_lock_lock((os_unfair_lock_t)(v170 + 24));
    char v171 = *(unsigned char *)(v170 + 86);
    os_unfair_lock_unlock((os_unfair_lock_t)(v170 + 24));
    uint64_t v172 = asStringBool(v171);
    int64_t v173 = *v169;
    xpc_object_t v174 = *v169 + 6;
    os_unfair_lock_lock(v174);
    LOBYTE(v173) = v173[21]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v174);
    uint64_t v175 = asStringBool((BOOL)v173);
    uint64_t v176 = *v169;
    xpc_object_t v177 = *v169 + 6;
    os_unfair_lock_lock(v177);
    char v178 = BYTE1(v176[21]._os_unfair_lock_opaque);
    os_unfair_lock_unlock(v177);
    uint64_t v179 = asStringBool(v178);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v172;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v175;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v179;
    _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "#I DATA:: CellularCapable: %s, dataAllowed = %s, dataAllowedByUser = %s", buf, 0x20u);
    uint64_t v72 = v249;
  }
  uint64_t v180 = *((void *)v72 + 18);
  uint64_t v181 = *(void *)(v180 + 8);
  uint64_t v242 = *(void *)(v180 + 16);
  if (v181 != v242)
  {
    int v241 = (void *)((char *)v72 + 5112);
    v240 = (void *)((char *)v72 + 5136);
    do
    {
      uint64_t v248 = v181;
      v258[0] = 0;
      memset(v290, 0, 24);
      uint64_t v272 = 0;
      uint64_t v271 = 0;
      uint64_t v273 = 0;
      uint64_t v265 = 0;
      uint64_t v266 = 0;
      uint64_t v267 = 0;
      uint64_t v182 = *((void *)v72 + 19);
      int64_t v183 = *(std::__shared_weak_count **)(v181 + 424);
      *(void *)long long buf = *(void *)(v181 + 416);
      *(void *)&uint8_t buf[8] = v183;
      if (v183)
      {
        atomic_fetch_add_explicit(&v183->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100AE4090(v182, (uint64_t)buf, v258, (char *)v290, (uint64_t)&v271, &v265);
        sub_10004D2C8(v183);
      }
      else
      {
        sub_100AE4090(v182, (uint64_t)buf, v258, (char *)v290, (uint64_t)&v271, &v265);
      }
      uint64_t v184 = *(void *)v290;
      if (*(void *)&v290[8] != *(void *)v290)
      {
        unint64_t v185 = 0;
        uint64_t v186 = 144;
        do
        {
          unsigned __int8 v187 = *((void *)v72 + 5);
          if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT))
          {
            int64_t v188 = *(std::__shared_weak_count **)(v248 + 424);
            if (v188)
            {
              atomic_fetch_add_explicit(&v188->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v188);
            }
            uint64_t v189 = subscriber::asString();
            uint64_t v190 = asString();
            int v191 = *(_DWORD *)(v184 + v186 - 144);
            uint64_t v192 = asString();
            int v193 = *(_DWORD *)(v184 + v186 - 140);
            uint64_t v194 = asStringBool(*(unsigned char *)(v184 + v186 - 136));
            *(_DWORD *)long long buf = 134219522;
            *(void *)&uint8_t buf[4] = v185;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v189;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v190;
            *(_WORD *)&uint8_t buf[32] = 1024;
            *(_DWORD *)&unsigned char buf[34] = v191;
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&unsigned char buf[40] = v192;
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = v193;
            *(_WORD *)&buf[54] = 2080;
            *(void *)&buf[56] = v194;
            _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, "#I DATA:: Context %lu.%s: familyActive=%s(%d), familyAvailable=%s(%d), active=%s", buf, 0x40u);
            uint64_t v72 = v249;
            unsigned __int8 v187 = *((void *)v249 + 5);
          }
          if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT))
          {
            long long v195 = (_DWORD *)(v184 + v186);
            uint64_t v197 = *(void *)(v184 + v186 - 128);
            uint64_t v196 = *(void *)(v184 + v186 - 120);
            uint64_t v199 = *(void *)(v184 + v186 - 112);
            uint64_t v198 = *(void *)(v184 + v186 - 104);
            uint64_t v200 = *((void *)v195 - 12);
            asStringMask((uint64_t *)__p, *((void *)v195 - 11));
            long long v201 = __p;
            if (v263 < 0) {
              long long v201 = (void **)__p[0];
            }
            uint64_t v202 = *((void *)v195 - 11);
            uint64_t v203 = *((void *)v195 - 10);
            uint64_t v204 = *((void *)v195 - 9);
            uint64_t v205 = *((void *)v195 - 8);
            uint64_t v206 = *((void *)v195 - 7);
            uint64_t v207 = *((void *)v195 - 6);
            uint64_t v208 = *((void *)v195 - 5);
            int v209 = *v195;
            *(_DWORD *)long long buf = 134221314;
            *(void *)&uint8_t buf[4] = v197;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v196;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)&unsigned char buf[24] = v199;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&unsigned char buf[34] = v198;
            *(_WORD *)&buf[42] = 2048;
            *(void *)&buf[44] = v200;
            *(_WORD *)&buf[52] = 2080;
            *(void *)&buf[54] = v201;
            *(_WORD *)&buf[62] = 2048;
            *(void *)&buf[64] = v202;
            __int16 v276 = 2048;
            uint64_t v277 = v203;
            __int16 v278 = 2048;
            uint64_t v279 = v204;
            __int16 v280 = 2048;
            uint64_t v281 = v205;
            __int16 v282 = 2048;
            uint64_t v283 = v206;
            __int16 v284 = 2048;
            uint64_t v285 = v207;
            __int16 v286 = 2048;
            uint64_t v287 = v208;
            __int16 v288 = 1024;
            int v289 = v209;
            _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, "#I DATA::     pdp=%lld state=%lld dataAtt=%lld ind=%lld roam=%lld mask=%s(0x%llx) tech=%lld IPf=%lld overrideDP=%lld p9=%lld overrideInd=%lld simSlot = %lld (num=%d)", buf, 0x8Au);
            if (SHIBYTE(v263) < 0) {
              operator delete(__p[0]);
            }
          }
          ++v185;
          uint64_t v184 = *(void *)v290;
          v186 += 152;
        }
        while (v185 < 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)&v290[8] - *(void *)v290) >> 3));
      }
      uint64_t v210 = v271;
      unint64_t v211 = 0xCCCCCCCCCCCCCCCDLL * ((v272 - v271) >> 4);
      if ((int)v211 >= 1)
      {
        uint64_t v212 = 0;
        unint64_t v213 = 0;
        do
        {
          if (v211 <= v213) {
            sub_10015B728();
          }
          uint64_t v214 = *((void *)v72 + 5);
          if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v246 = asString();
            long long v215 = *(std::__shared_weak_count **)(v248 + 424);
            if (v215)
            {
              atomic_fetch_add_explicit(&v215->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v215);
            }
            uint64_t v216 = subscriber::asString();
            int v217 = *(_DWORD *)(v210 + v212);
            uint64_t v218 = asStringBool(*(unsigned char *)(v210 + v212 + 4));
            uint64_t v219 = asStringBool(*(unsigned char *)(v210 + v212 + 5));
            uint64_t v220 = asStringBool(*(unsigned char *)(v210 + v212 + 16));
            uint64_t v221 = asStringBool(*(unsigned char *)(v210 + v212 + 17));
            *(_DWORD *)long long buf = 136316674;
            *(void *)&uint8_t buf[4] = v246;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v216;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v217;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = v218;
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&unsigned char buf[40] = v219;
            *(_WORD *)&buf[48] = 2080;
            *(void *)&buf[50] = v220;
            *(_WORD *)&buf[58] = 2080;
            *(void *)&buf[60] = v221;
            _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s.%s: idByMask=%d, configuredByMask[BB]=%s, configuredByMask[iW]=%s, activeByMask=%s, networkActive=%s", buf, 0x44u);
            uint64_t v214 = *((void *)v249 + 5);
          }
          if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v222 = v210 + v212;
            int v223 = *(_DWORD *)(v222 + 8);
            uint64_t v224 = asStringBool(*(unsigned char *)(v222 + 12));
            uint64_t v225 = asString();
            *(_DWORD *)long long buf = 67109634;
            *(_DWORD *)&uint8_t buf[4] = v223;
            *(_WORD *)&uint8_t buf[8] = 2080;
            *(void *)&buf[10] = v224;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v225;
            _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "#I DATA::     activeAndIdByConnection:  id=%d, active=%s, transportType=%s", buf, 0x1Cu);
          }
          ++v213;
          uint64_t v210 = v271;
          unint64_t v211 = 0xCCCCCCCCCCCCCCCDLL * ((v272 - v271) >> 4);
          v212 += 80;
          uint64_t v72 = v249;
        }
        while ((uint64_t)v213 < (int)v211);
      }
      unint64_t v226 = (void *)*((void *)v72 + 638);
      if (v226 != v241)
      {
        do
        {
          uint64_t v227 = *(void *)((char *)v226 + 28);
          unint64_t v228 = *((void *)v72 + 5);
          if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v229 = subscriber::asString();
            uint64_t v230 = asStringBool((v227 & 0xFF00000000) != 0);
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v229;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v230;
            _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_DEFAULT, "#I DATA:: fBasebandRefreshState[%s] = %s", buf, 0x16u);
          }
          __n128 v231 = (void *)v226[1];
          if (v231)
          {
            do
            {
              unint64_t v232 = v231;
              __n128 v231 = (void *)*v231;
            }
            while (v231);
          }
          else
          {
            do
            {
              unint64_t v232 = (void *)v226[2];
              BOOL v35 = *v232 == (void)v226;
              unint64_t v226 = v232;
            }
            while (!v35);
          }
          unint64_t v226 = v232;
        }
        while (v232 != v241);
      }
      __n128 v233 = (void *)*((void *)v72 + 641);
      if (v233 != v240)
      {
        do
        {
          unint64_t v234 = *((void *)v72 + 5);
          if (os_log_type_enabled(v234, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v235 = subscriber::asString();
            uint64_t v236 = asStringBool(v233[5] != 0);
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v235;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v236;
            _os_log_impl((void *)&_mh_execute_header, v234, OS_LOG_TYPE_DEFAULT, "#I DATA:: fPostBasebandRefreshTimer[%s] = %s", buf, 0x16u);
          }
          v237 = (void *)v233[1];
          if (v237)
          {
            do
            {
              int v238 = v237;
              v237 = (void *)*v237;
            }
            while (v237);
          }
          else
          {
            do
            {
              int v238 = (void *)v233[2];
              BOOL v35 = *v238 == (void)v233;
              __n128 v233 = v238;
            }
            while (!v35);
          }
          __n128 v233 = v238;
        }
        while (v238 != v240);
      }
      *(void *)long long buf = &v265;
      sub_1002AC5A8((void ***)buf);
      *(void *)long long buf = &v271;
      sub_100AE5BF0((void ***)buf);
      if (*(void *)v290)
      {
        *(void *)&v290[8] = *(void *)v290;
        operator delete(*(void **)v290);
      }
      uint64_t v181 = v248 + 432;
    }
    while (v248 + 432 != v242);
  }
  DataServiceController::dumpMsimData_sync(v72);
  DataServiceController::dumpSliceData_sync(v249);
  v239 = *((void *)v249 + 5);
  if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v74 = "#I DATA:: ========================== Dump Data Service End ==========================";
    long long v75 = v239;
    uint32_t v76 = 2;
LABEL_302:
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, v74, buf, v76);
  }
}

void sub_101161570(_Unwind_Exception *a1)
{
  if (STACK[0x220]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x220]);
  }
  if (STACK[0x258]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x258]);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 - 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_1011616F0(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_101194C18;
  aBlock[3] = &unk_101A98B18;
  aBlock[4] = a2;
  aBlock[5] = a4;
  void aBlock[6] = a5;
  uint64_t v10 = _Block_copy(aBlock);
  sub_10003E168(&v8, (void *)a2);
  sub_101194980(a1, a3, &v8, *(dispatch_object_t *)(a2 + 16), &v10);
}

uint64_t sub_1011617CC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 40))();
}

uint64_t sub_1011617F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 48))();
}

uint64_t sub_10116181C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 56))();
}

uint64_t sub_101161844(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 64))();
}

void sub_10116186C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 312))
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "handlePostponementStatusChanged_sync";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 312), *(Registry **)(a1 + 104));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (v10) {
LABEL_13:
  }
    *(unsigned char *)(a1 + 314) = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 80))(v10);
LABEL_14:
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    uint64_t v15 = asString();
    uint64_t v16 = asStringBool(*(unsigned char *)(a1 + 314));
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "handlePostponementStatusChanged_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v20 = v15;
    __int16 v21 = 2080;
    uint64_t v22 = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: Postponement: Current: %s, New %s; fActivationEnabled = %s",
      buf,
      0x2Au);
  }
  sub_100058DB0(__p, "Postponement status change");
  *(_DWORD *)long long buf = 3;
  uint8_t buf[4] = 0;
  if (SHIBYTE(v18) < 0)
  {
    sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
    uint64_t v20 = v18;
  }
  sub_10011AE40();
  if (SHIBYTE(v20) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (SHIBYTE(v18) < 0)
  {
    operator delete(__p[0]);
    if (v11) {
      return;
    }
  }
  else if (v11)
  {
    return;
  }
  sub_10004D2C8(v9);
}

void sub_101161B1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_101161B7C(void *a1)
{
  int v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = "handleRadioDisabled_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Radio disabled", buf, 0xCu);
  }
  uint64_t v3 = a1[18];
  uint64_t v4 = *(void *)(v3 + 8);
  for (uint64_t i = *(void *)(v3 + 16); v4 != i; v4 += 432)
  {
    uint64_t v7 = *(void *)(v4 + 416);
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 424);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v8 = *(unsigned int *)(v7 + 52);
      sub_10004D2C8(v6);
    }
    else
    {
      uint64_t v8 = *(unsigned int *)(v7 + 52);
    }
    uint64_t v9 = operator new(4uLL);
    long long __p = v9;
    *uint64_t v9 = 0;
    char v11 = v9 + 1;
    uint64_t v12 = v9 + 1;
    (*(void (**)(void *, uint64_t, const char *, uint64_t, uint64_t, void **))(*a1 + 176))(a1, v8, "RadioDisabled", 1, 36, &__p);
    if (__p)
    {
      char v11 = __p;
      operator delete(__p);
    }
  }
}

void sub_101161CD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101161CFC(void **a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v10 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SIM refresh for card %s", buf, 0xCu);
  }
  uint64_t v5 = operator new(8uLL);
  long long __p = v5;
  *uint64_t v5 = &_mh_execute_header;
  uint64_t v8 = v5 + 1;
  uint64_t v7 = v5 + 1;
  ((void (*)(void **, uint64_t, const char *, void, uint64_t, void **))(*a1)[22])(a1, a2, "SimRefresh", 0, 36, &__p);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_101161E48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101161E6C(void *a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = a1[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v15 = "handleWiFiOffInAirplaneMode_sync";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: WiFiOffInAirplaneMode", buf, 0xCu);
    }
    uint64_t v4 = a1[18];
    uint64_t v5 = *(void *)(v4 + 8);
    for (uint64_t i = *(void *)(v4 + 16); v5 != i; v5 += 432)
    {
      uint64_t v8 = *(void *)(v5 + 416);
      uint64_t v7 = *(std::__shared_weak_count **)(v5 + 424);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v9 = *(unsigned int *)(v8 + 52);
        sub_10004D2C8(v7);
      }
      else
      {
        uint64_t v9 = *(unsigned int *)(v8 + 52);
      }
      uint64_t v10 = operator new(8uLL);
      long long __p = v10;
      void *v10 = &_mh_execute_header;
      uint64_t v12 = v10 + 1;
      uint64_t v13 = v10 + 1;
      (*(void (**)(void *, uint64_t, const char *, uint64_t, uint64_t, void **))(*a1 + 176))(a1, v9, "WiFiOffInAirplaneMode", 1, 36, &__p);
      if (__p)
      {
        uint64_t v12 = __p;
        operator delete(__p);
      }
    }
  }
}

void sub_101161FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101161FFC(void *a1)
{
  int v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136315138;
    uint64_t v12 = "handleExitLowPower_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Exiting low power mode", (uint8_t *)&v11, 0xCu);
  }
  sub_101172474((uint64_t)a1);
  uint64_t v3 = a1[18];
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  while (v4 != v5)
  {
    uint64_t v6 = *(void *)(v4 + 40);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 496))(v6);
    }
    v4 += 432;
  }
  uint64_t v7 = (uint64_t *)a1[517];
  for (uint64_t i = (uint64_t *)a1[518]; v7 != i; v7 += 2)
  {
    uint64_t v9 = *v7;
    uint64_t v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v9 + 376))(v9);
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_101162164(_Unwind_Exception *exception_object)
{
}

void sub_101162184(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(v1 + 4512) + 16))(&v8);
    if (v8)
    {
      DataServiceController::checkSliceDataStall((DataServiceController *)v1, &v8);
      uint64_t v2 = *(void *)(v1 + 144);
      uint64_t v3 = *(void *)(v2 + 8);
      for (uint64_t i = *(void *)(v2 + 16); v3 != i; v3 += 432)
      {
        uint64_t v5 = *(void *)(v3 + 24);
        if (v5)
        {
          if (((*(uint64_t (**)(uint64_t, void **))(*(void *)v5 + 576))(v5, &v8) & 1) == 0)
          {
            uint64_t v6 = *(NSObject **)(v1 + 40);
            if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v7 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "failed to report PDPStatistics", v7, 2u);
            }
          }
        }
      }
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
}

void sub_1011622B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011622D4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "startDataServiceController_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  sub_100058DB0(buf, "slicing: initial start");
  (*(void (**)(uint64_t, uint64_t, uint8_t *, void))(*(void *)a1 + 2328))(a1, 3, buf, 0);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  LOBYTE(v107) = 0;
  uint64_t v4 = sub_100365D74();
  sub_100058DB0(buf, "GsmRadioModule::fCellularDataIsEnabled");
  BOOL v5 = sub_100571C98(v4, (void **)buf, &v107);
  BOOL v6 = v5;
  if ((char)buf[23] < 0)
  {
    operator delete(*(void **)buf);
    if (!v6) {
      goto LABEL_14;
    }
  }
  else if (!v5)
  {
    goto LABEL_14;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 315));
    uint64_t v9 = asStringBool((_BYTE)v107 != 0);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I (restore) fCellularDataIsEnabledPersisted changed: %s ==>> %s", buf, 0x16u);
  }
  BOOL v10 = (_BYTE)v107 != 0;
  *(unsigned char *)(a1 + 315) = (_BYTE)v107 != 0;
  uint64_t v11 = *(void *)(a1 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(v11 + 24));
  *(unsigned char *)(v11 + 85) = v10;
  os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 24));
  *(void *)long long buf = 1;
  *(void *)&uint8_t buf[8] = a1 + 3848;
  *(void *)&uint8_t buf[16] = 0;
  uint8_t buf[16] = *(unsigned char *)(a1 + 315);
  sub_101198DF8((uint64_t)buf);
LABEL_14:
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = asStringBool(*(unsigned char *)(a1 + 316));
    uint64_t v14 = asStringBool(*(unsigned char *)(a1 + 315));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I (restore) fCellularDataIsEnabled changed: %s ==>> %s", buf, 0x16u);
  }
  unsigned __int8 v15 = *(unsigned char *)(a1 + 315);
  *(unsigned char *)(a1 + 316) = v15;
  *(void *)long long buf = 1;
  *(void *)&uint8_t buf[8] = a1 + 3888;
  *(void *)&uint8_t buf[16] = v15;
  sub_1011956A0((uint64_t)buf);
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "bindPDPManagers_sync";
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: bindPDPManagers_sync started...", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 104));
  uint64_t v19 = ServiceMap;
  if (v20 < 0)
  {
    __int16 v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v24)
  {
    uint64_t v26 = v24[3];
    uint64_t v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      if (!v26) {
        goto LABEL_24;
      }
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v19);
  uint64_t v25 = 0;
  char v27 = 1;
  if (!v26)
  {
LABEL_24:
    int v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "bindPDPManagers_sync";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#E %s: PDPConfig service is not initialized", buf, 0xCu);
    }
    goto LABEL_53;
  }
LABEL_28:
  char v97 = v27;
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v26 + 136))(buf, v26);
  uint64_t v29 = *(uint64_t **)(a1 + 4136);
  for (uint64_t i = *(uint64_t **)(a1 + 4144); v29 != i; v29 += 2)
  {
    uint64_t v32 = *v29;
    uint64_t v31 = (std::__shared_weak_count *)v29[1];
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v33 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 72))(v32);
    long long v34 = *(_OWORD *)(*(void *)buf + 16 * v33);
    BOOL v35 = *(std::__shared_weak_count **)(*(void *)buf + 16 * v33 + 8);
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v36 = v34;
    if ((void)v34)
    {
      long long v98 = v34;
      long long v107 = 0uLL;
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v32 + 48))(&v107, v32);
      if ((void)v107)
      {
        long long v106 = v107;
        if (*((void *)&v107 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v107 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, long long *))(*(void *)v36 + 56))(v36, &v106);
        if (*((void *)&v106 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v106 + 1));
        }
        long long v105 = v98;
        if (v35) {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, long long *))(*(void *)v32 + 56))(v32, &v105);
        if (*((void *)&v105 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v105 + 1));
        }
      }
      if (*((void *)&v107 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v107 + 1));
      }
    }
    if (v35) {
      sub_10004D2C8(v35);
    }
    if (v31) {
      sub_10004D2C8(v31);
    }
  }
  uint64_t v37 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v107) = 136315138;
    *(void *)((char *)&v107 + 4) = "bindPDPManagers_sync";
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: bindPDPManagers_sync completed", (uint8_t *)&v107, 0xCu);
  }
  *(void *)&long long v107 = buf;
  sub_10005CBF0((void ***)&v107);
  char v27 = v97;
LABEL_53:
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  uint64_t v38 = *(void *)(a1 + 224);
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 24))(v38);
  }
  DataServiceController::initAgentPolicies_sync((DataServiceController *)a1);
  uint64_t v39 = *(void *)(a1 + 144);
  int v40 = *(void **)(v39 + 8);
  for (uint64_t j = *(void **)(v39 + 16); v40 != j; v40 += 54)
  {
    uint64_t v42 = v40[3];
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 312))(v42);
    }
    uint64_t v43 = v40[5];
    if (v43) {
      (*(void (**)(uint64_t))(*(void *)v43 + 304))(v43);
    }
    uint64_t v45 = v40[52];
    uint64_t v44 = (std::__shared_weak_count *)v40[53];
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v46 = *(unsigned int *)(v45 + 52);
      sub_10004D2C8(v44);
    }
    else
    {
      uint64_t v46 = *(unsigned int *)(v45 + 52);
    }
    sub_1011633E8(a1, v46);
  }
  sub_100058DB0(__p, "fDataModuleInitialized is true");
  *(_DWORD *)long long buf = 3;
  uint8_t buf[4] = 1;
  if (SHIBYTE(v104) < 0)
  {
    sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
    uint64_t v109 = v104;
  }
  sub_10011AE40();
  if (SHIBYTE(v109) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (SHIBYTE(v104) < 0) {
    operator delete(__p[0]);
  }
  sub_101163798((void *)a1);
  sub_101164980((void *)a1, 0x10uLL, 0);
  uint64_t v47 = *(void *)(a1 + 144);
  uint64_t v48 = *(void *)(v47 + 8);
  for (uint64_t k = *(void *)(v47 + 16); v48 != k; v48 += 432)
  {
    uint64_t v51 = *(void *)(v48 + 416);
    uint64_t v50 = *(std::__shared_weak_count **)(v48 + 424);
    if (v50)
    {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v52 = *(unsigned int *)(v51 + 52);
      sub_10004D2C8(v50);
    }
    else
    {
      uint64_t v52 = *(unsigned int *)(v51 + 52);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 216))(a1, v52, 29, 0);
  }
  uint64_t v53 = *(void *)(a1 + 4160);
  if (v53) {
    (*(void (**)(uint64_t))(*(void *)v53 + 16))(v53);
  }
  uint64_t v54 = *(void *)(a1 + 240);
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 24))(v54);
  }
  uint64_t v55 = *(void *)(a1 + 256);
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
  }
  uint64_t v56 = *(void *)(a1 + 144);
  uint64_t v57 = *(void *)(v56 + 8);
  for (uint64_t m = *(void *)(v56 + 16); v57 != m; v57 += 432)
  {
    uint64_t v60 = *(void *)(v57 + 416);
    int v59 = *(std::__shared_weak_count **)(v57 + 424);
    if (v59)
    {
      atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v61 = *(unsigned int *)(v60 + 52);
      sub_10004D2C8(v59);
    }
    else
    {
      uint64_t v61 = *(unsigned int *)(v60 + 52);
    }
    sub_101163938(a1, v61);
  }
  aBlock[5] = _NSConcreteStackBlock;
  void aBlock[6] = 0x40000000;
  void aBlock[7] = sub_101164410;
  aBlock[8] = &unk_101A955C8;
  aBlock[9] = a1;
  sub_10017B514();
  int v63 = (std::mutex *)Registry::getServiceMap(v62, *(Registry **)(a1 + 104));
  uint64_t v64 = v63;
  if (v65 < 0)
  {
    uint64_t v66 = (unsigned __int8 *)(v65 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v67 = 5381;
    do
    {
      uint64_t v65 = v67;
      unsigned int v68 = *v66++;
      uint64_t v67 = (33 * v67) ^ v68;
    }
    while (v68);
  }
  std::mutex::lock(v63);
  *(void *)long long buf = v65;
  __int16 v69 = sub_10004D37C(&v64[1].__m_.__sig, (unint64_t *)buf);
  if (v69)
  {
    uint64_t v71 = v69[3];
    uint64_t v70 = (std::__shared_weak_count *)v69[4];
    if (v70)
    {
      atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v64);
      atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v70);
      char v72 = 0;
      if (!v71) {
        goto LABEL_118;
      }
      goto LABEL_98;
    }
  }
  else
  {
    uint64_t v71 = 0;
  }
  std::mutex::unlock(v64);
  uint64_t v70 = 0;
  char v72 = 1;
  if (!v71) {
    goto LABEL_118;
  }
LABEL_98:
  sub_10003E168(buf, (void *)(a1 + 8));
  uint64_t v74 = *(void *)buf;
  uint64_t v73 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v73);
    atomic_fetch_add_explicit(&v73->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v75 = *(void *)(a1 + 24);
  if (v75) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 24));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_101164488;
  aBlock[3] = &unk_101A955E8;
  aBlock[4] = a1;
  if (v75)
  {
    uint32_t v76 = _Block_copy(aBlock);
    uint64_t v77 = v76;
    *(void *)&long long v107 = v75;
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 1174405120;
    *(void *)&uint8_t buf[16] = sub_101194D94;
    uint64_t v109 = &unk_101A98BB8;
    uint64_t v110 = v74;
    uint64_t v111 = v73;
    if (v73) {
      atomic_fetch_add_explicit(&v73->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    if (v76) {
      uint64_t v78 = _Block_copy(v76);
    }
    else {
      uint64_t v78 = 0;
    }
    uint64_t v112 = v78;
    (*(void (**)(uint64_t, const char *, uint64_t, long long *, uint8_t *))(*(void *)v71 + 40))(v71, "commCenterSwitchState", 1, &v107, buf);
    if ((void)v107) {
      dispatch_release((dispatch_object_t)v107);
    }
    if (v112) {
      _Block_release(v112);
    }
    if (v111) {
      std::__shared_weak_count::__release_weak(v111);
    }
    if (v77) {
      _Block_release(v77);
    }
  }
  if (v73)
  {
    std::__shared_weak_count::__release_weak(v73);
    std::__shared_weak_count::__release_weak(v73);
  }
LABEL_118:
  if ((v72 & 1) == 0) {
    sub_10004D2C8(v70);
  }
  uint64_t v79 = *(void *)(a1 + 112);
  *(void *)&long long v107 = *(void *)(a1 + 104);
  *((void *)&v107 + 1) = v79;
  if (v79) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v79 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*((void *)&v107 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v107 + 1));
  }
  uint64_t v82 = *(uint64_t **)buf;
  uint64_t v81 = *(uint64_t **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8])
  {
    uint64_t v83 = *(uint64_t (**)(void))&buf[16];
    while ((v83(*(unsigned int *)v82) & 1) == 0)
    {
      uint64_t v82 = (uint64_t *)((char *)v82 + 4);
      if (v82 == v81)
      {
        uint64_t v82 = v81;
        break;
      }
    }
    BOOL v84 = *(uint64_t **)&buf[8];
    while (v82 != v84)
    {
      LODWORD(v106) = 0;
      LODWORD(v106) = *(_DWORD *)v82;
      __int16 v85 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
      *(void *)&long long v107 = &v106;
      *((_WORD *)sub_100A949B8((uint64_t **)(a1 + 4456), (int *)&v106, (uint64_t)&unk_10144E20E, (_DWORD **)&v107) + 16) = v85;
      sub_1011646C8((void *)a1, v106, 23, 1, 1);
      char v80 = (uint64_t *)((char *)v82 + 4);
      uint64_t v82 = v81;
      if (v80 != v81)
      {
        uint64_t v82 = v80;
        while ((v83(*(unsigned int *)v82) & 1) == 0)
        {
          uint64_t v82 = (uint64_t *)((char *)v82 + 4);
          if (v82 == v81)
          {
            uint64_t v82 = v81;
            break;
          }
        }
      }
    }
  }
  uint64_t v86 = (std::mutex *)Registry::getServiceMap(v80, *(Registry **)(a1 + 104));
  unsigned int v87 = v86;
  if (v88 < 0)
  {
    int v89 = (unsigned __int8 *)(v88 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v90 = 5381;
    do
    {
      uint64_t v88 = v90;
      unsigned int v91 = *v89++;
      uint64_t v90 = (33 * v90) ^ v91;
    }
    while (v91);
  }
  std::mutex::lock(v86);
  *(void *)long long buf = v88;
  uint64_t v92 = sub_10004D37C(&v87[1].__m_.__sig, (unint64_t *)buf);
  if (v92)
  {
    uint64_t v94 = v92[3];
    int v93 = (std::__shared_weak_count *)v92[4];
    if (v93)
    {
      atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v87);
      atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v93);
      char v95 = 0;
      if (!v94) {
        goto LABEL_151;
      }
      goto LABEL_145;
    }
  }
  else
  {
    uint64_t v94 = 0;
  }
  std::mutex::unlock(v87);
  int v93 = 0;
  char v95 = 1;
  if (!v94) {
    goto LABEL_151;
  }
LABEL_145:
  unint64_t v96 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v96;
  if (v96) {
    dispatch_retain(v96);
  }
  sub_100058DB0(v99, "DATA.ServiceController");
  (*(void (**)(uint64_t, dispatch_object_t *, void **))(*(void *)v94 + 16))(v94, &object, v99);
  if (v100 < 0) {
    operator delete(v99[0]);
  }
  if (object) {
    dispatch_release(object);
  }
LABEL_151:
  if ((v95 & 1) == 0) {
    sub_10004D2C8(v93);
  }
}

void sub_1011630A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,dispatch_object_t object,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::initAgentPolicies_sync(DataServiceController *this)
{
  uint64_t v1 = *((void *)this + 18);
  uint64_t v2 = *(uint64_t ***)(v1 + 8);
  for (uint64_t i = *(uint64_t ***)(v1 + 16); v2 != i; v2 += 54)
  {
    BOOL v5 = *v2;
    uint64_t v4 = v2[1];
    while (v5 != v4)
    {
      uint64_t v7 = *v5;
      BOOL v6 = (std::__shared_weak_count *)v5[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v7)
      {
        uint64_t v8 = *((void *)this + 5);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 48))(v7);
          *(_DWORD *)long long buf = 136315138;
          uint64_t v12 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I initializing network policy for %s", buf, 0xCu);
        }
        (*(void (**)(uint64_t))(*(void *)v7 + 72))(v7);
      }
      if (v6) {
        sub_10004D2C8(v6);
      }
      v5 += 2;
    }
  }
}

void sub_1011633CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1011633E8(uint64_t a1, uint64_t a2)
{
  uint64_t result = (const void **)sub_10003B004(*(void *)(a1 + 144), a2);
  BOOL v5 = *(uint64_t **)(*(void *)(a1 + 144) + 16);
  if (v5 == (uint64_t *)result) {
    return result;
  }
  BOOL v6 = result;
  uint64_t v30 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 104));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    BOOL v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (!v13)
  {
    uint64_t v15 = 0;
    goto LABEL_9;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v15 + 96))(&v30, v15, a2, 1, @"AllowedDataModesForServices", 0, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  uint64_t v17 = v30;
  if (v30) {
    uint64_t v18 = sub_100080934;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18)
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "extractAllowedDataModesForServices";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Extracting allowed Data Modes for all services", buf, 0xCu);
      uint64_t v17 = v30;
    }
    int v28 = v17;
    CFTypeRef cf = 0;
    if (v17)
    {
      CFRetain(v17);
      uint64_t v32 = v17;
      CFRetain(v17);
    }
    else
    {
      uint64_t v32 = 0;
    }
    uint64_t v31 = 0;
    *(void *)long long buf = 0;
    sub_100044D6C(buf, &v32);
    if (*(void *)buf) {
      uint64_t v20 = sub_100083F10;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v20) {
      sub_100449580(&v31, (const void **)buf);
    }
    sub_100044D00((const void **)buf);
    __int16 v21 = v31;
    CFTypeRef cf = v31;
    uint64_t v31 = 0;
    sub_100044D00(&v31);
    sub_1000577C4(&v32);
    sub_1000577C4(&v28);
    if (v21) {
      uint64_t v22 = sub_100083F10;
    }
    else {
      uint64_t v22 = 0;
    }
    if (v22)
    {
      unsigned int v23 = (uint64_t *)*v6;
      uint64_t v24 = v6[1];
      if (*v6 != v24)
      {
        do
        {
          uint64_t v25 = *v23;
          uint64_t v26 = (std::__shared_weak_count *)v23[1];
          if (v26) {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v25)
          {
            CFTypeRef v27 = cf;
            if (cf) {
              CFRetain(cf);
            }
            (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v25 + 504))(v25, &v27);
            sub_100044D00(&v27);
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
          v23 += 2;
        }
        while (v23 != v24);
      }
    }
    sub_100044D00(&cf);
  }
  return sub_1000577C4(&v30);
}

void sub_101163718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101163798(void *a1)
{
  uint64_t v2 = a1[19];
  uint64_t v3 = (os_unfair_lock_s *)(v2 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 24));
  uint64_t v4 = *(unsigned __int8 *)(v2 + 84);
  os_unfair_lock_unlock(v3);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  BOOL v5 = sub_10116991C((uint64_t)a1, (uint64_t)__p);
  BOOL v6 = (uint64_t *)a1[517];
  uint64_t v7 = (uint64_t *)a1[518];
  if (v6 != v7)
  {
    BOOL v8 = !v5;
    do
    {
      uint64_t v9 = *v6;
      BOOL v10 = (std::__shared_weak_count *)v6[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v9 + 64))(&v12);
      if (v12)
      {
        (*(void (**)(void))(*(void *)v12 + 160))();
        (*(void (**)(uint64_t, BOOL, uint64_t))(*(void *)v12 + 160))(v12, v8, 4);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      v6 += 2;
    }
    while (v6 != v7);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1011638F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_101163938(uint64_t a1, uint64_t a2)
{
  unsigned int v77 = a2;
  uint64_t v4 = 4216;
  BOOL v5 = (uint64_t **)(a1 + 4216);
  BOOL v6 = *(uint64_t **)(a1 + 4224);
  if (v6)
  {
    uint64_t v4 = a1 + 4224;
    uint64_t v7 = (uint64_t *)(a1 + 4224);
    BOOL v8 = v6;
    do
    {
      int v9 = *((_DWORD *)v8 + 8);
      BOOL v10 = v9 < (int)a2;
      if (v9 >= (int)a2) {
        uint64_t v11 = (uint64_t **)v8;
      }
      else {
        uint64_t v11 = (uint64_t **)(v8 + 1);
      }
      if (!v10) {
        uint64_t v7 = v8;
      }
      BOOL v8 = *v11;
    }
    while (*v11);
    if (v7 != (uint64_t *)v4)
    {
      uint64_t v4 = *((unsigned int *)v7 + 8);
      if ((int)v4 <= (int)a2)
      {
        uint64_t v12 = (uint64_t *)v7[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            uint64_t v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          uint64_t v14 = v7;
          do
          {
            uint64_t v13 = (uint64_t *)v14[2];
            BOOL v15 = *v13 == (void)v14;
            uint64_t v14 = v13;
          }
          while (!v15);
        }
        if (*v5 == v7) {
          *BOOL v5 = v13;
        }
        --*(void *)(a1 + 4232);
        sub_10005EE6C(v6, v7);
        char v16 = (std::__shared_weak_count *)v7[6];
        if (v16) {
          sub_10004D2C8(v16);
        }
        operator delete(v7);
      }
    }
  }
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v4, *(Registry **)(a1 + 104));
  uint64_t v18 = ServiceMap;
  if ((v19 & 0x8000000000000000) != 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      std::string::size_type v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v19;
  unsigned int v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_30:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v25 + 80))(&cf, v25, a2, 1, @"EvoBlacklistedGIDs", 0, 0);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  CFTypeRef v27 = cf;
  if (cf) {
    int v28 = sub_100080934;
  }
  else {
    int v28 = 0;
  }
  if (v28)
  {
    CFTypeRef v74 = cf;
    std::string::size_type v75 = 0;
    if (cf)
    {
      CFRetain(cf);
      *(void *)unsigned int v87 = v27;
      CFRetain(v27);
    }
    else
    {
      *(void *)unsigned int v87 = 0;
    }
    __str.__r_.__value_.__r.__words[0] = 0;
    buf.__r_.__value_.__r.__words[0] = 0;
    sub_100044D6C(&buf, (CFTypeRef *)v87);
    if (buf.__r_.__value_.__r.__words[0]) {
      int v33 = sub_100083F10;
    }
    else {
      int v33 = 0;
    }
    if (v33) {
      sub_100449580((const void **)&__str.__r_.__value_.__l.__data_, (const void **)&buf.__r_.__value_.__l.__data_);
    }
    sub_100044D00((const void **)&buf.__r_.__value_.__l.__data_);
    std::string::size_type v75 = __str.__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = 0;
    sub_100044D00((const void **)&__str.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)v87);
    sub_1000577C4(&v74);
    int v34 = v77;
    char v72 = v5;
    BOOL v35 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v77);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I kEvoBlacklistedGIDsKey found", (uint8_t *)&buf, 2u);
    }
    int v71 = v34;
    uint64_t v36 = (uint64_t *)operator new(0x30uLL);
    v36[1] = 0;
    v36[2] = 0;
    uint64_t *v36 = (uint64_t)off_101A98CA8;
    sub_100062740((const void **)&theArray, (const void **)&v75);
    uint64_t v73 = v36;
    v36[3] = 0;
    v36[4] = 0;
    uint64_t v37 = v36 + 3;
    v37[2] = 0;
    if (theArray) {
      uint64_t v38 = sub_100083F10;
    }
    else {
      uint64_t v38 = 0;
    }
    if (v38)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFArrayGetValueAtIndex(theArray, i);
          memset(&__str, 0, sizeof(__str));
          sub_100058DB0(&v84, "");
          ctu::cf::assign();
          std::string __str = v84;
          memset(&v84, 0, sizeof(v84));
          unsigned __int8 v41 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::size_type size = __str.__r_.__value_.__l.__size_;
            if (!__str.__r_.__value_.__l.__size_) {
              goto LABEL_97;
            }
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          else
          {
            if (!*((unsigned char *)&__str.__r_.__value_.__s + 23)) {
              continue;
            }
            std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            p_str = &__str;
          }
          uint64_t v44 = (std::string *)((char *)p_str + size);
          if (p_str != (std::string *)((char *)p_str + size))
          {
            do
            {
              p_str->__r_.__value_.__s.__data_[0] = __tolower(p_str->__r_.__value_.__s.__data_[0]);
              p_str = (std::string *)((char *)p_str + 1);
            }
            while (p_str != v44);
            unsigned __int8 v41 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
          long long v45 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
          if ((v41 & 0x80u) == 0) {
            int64_t v46 = v41;
          }
          else {
            int64_t v46 = __str.__r_.__value_.__l.__size_;
          }
          if ((v41 & 0x80u) == 0) {
            uint64_t v47 = &__str;
          }
          else {
            uint64_t v47 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (v46 >= 1)
          {
            uint64_t v48 = (char *)v47 + v46;
            char v49 = v47;
            while (1)
            {
              uint64_t v50 = memchr(v49, 45, v46);
              if (!v50) {
                goto LABEL_87;
              }
              if (*v50 == 45) {
                break;
              }
              char v49 = (std::string *)(v50 + 1);
              int64_t v46 = v48 - (unsigned char *)v49;
              if (v48 - (unsigned char *)v49 < 1) {
                goto LABEL_87;
              }
            }
            if (v50 == v48) {
              goto LABEL_87;
            }
            std::string::size_type v51 = v50 - (unsigned char *)v47;
            if (v51 == -1) {
              goto LABEL_87;
            }
            memset(&v82, 0, sizeof(v82));
            std::string::basic_string(&v82, &__str, 0, v51, (std::allocator<char> *)&v81);
            memset(&v81, 0, sizeof(v81));
            std::string::basic_string(&v81, &__str, v51 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v86);
            std::string::size_type v52 = HIBYTE(v82.__r_.__value_.__r.__words[2]);
            if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v52 = v82.__r_.__value_.__l.__size_;
            }
            if (!v52) {
              goto LABEL_100;
            }
            std::string::size_type v53 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
            if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v53 = v81.__r_.__value_.__l.__size_;
            }
            if (v53)
            {
              if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84(&buf, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
                if ((*((unsigned char *)&v81.__r_.__value_.__s + 23) & 0x80) != 0) {
                  goto LABEL_105;
                }
LABEL_86:
                std::string v80 = v81;
              }
              else
              {
                std::string buf = v82;
                if ((*((unsigned char *)&v81.__r_.__value_.__s + 23) & 0x80) == 0) {
                  goto LABEL_86;
                }
LABEL_105:
                sub_10004FC84(&v80, v81.__r_.__value_.__l.__data_, v81.__r_.__value_.__l.__size_);
              }
              uint64_t v90 = 0;
              char v62 = (char *)operator new(0x38uLL);
              int v63 = v62;
              *(void *)char v62 = off_101A98D88;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(v62 + 8, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else {
                *(std::string *)(v62 + 8) = buf;
              }
              uint64_t v64 = v63 + 32;
              if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84(v64, v80.__r_.__value_.__l.__data_, v80.__r_.__value_.__l.__size_);
              }
              else
              {
                *(_OWORD *)uint64_t v64 = *(_OWORD *)&v80.__r_.__value_.__l.__data_;
                *((void *)v63 + 6) = *((void *)&v80.__r_.__value_.__l + 2);
              }
              uint64_t v90 = v63;
              sub_101196CA0(v37, (uint64_t)v87);
              sub_101197178(v87);
              if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v80.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              uint64_t v65 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v66 = &v82;
                if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v66 = (std::string *)v82.__r_.__value_.__r.__words[0];
                }
                uint64_t v67 = &v81;
                if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v67 = (std::string *)v81.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)unsigned int v87 = 136315394;
                *(void *)&v87[4] = v66;
                __int16 v88 = 2080;
                int v89 = v67;
                int v59 = v65;
                uint64_t v60 = "#I Added blocked GID range '%s - %s'";
                uint32_t v61 = 22;
                goto LABEL_122;
              }
            }
            else
            {
LABEL_100:
              uint64_t v57 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v58 = &__str;
                if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v58 = (std::string *)__str.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)unsigned int v87 = 136315138;
                *(void *)&v87[4] = v58;
                int v59 = v57;
                uint64_t v60 = "#E Fail to parse GID range '%s'";
                uint32_t v61 = 12;
LABEL_122:
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, v60, v87, v61);
              }
            }
            if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v81.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v82.__r_.__value_.__l.__data_);
            }
            goto LABEL_96;
          }
LABEL_87:
          if ((v41 & 0x80) != 0) {
            sub_10004FC84(&__p, (void *)v45, *((unint64_t *)&v45 + 1));
          }
          else {
            std::string __p = __str;
          }
          uint64_t v90 = 0;
          uint64_t v54 = (char *)operator new(0x20uLL);
          *(void *)uint64_t v54 = off_101A98CF8;
          *(std::string *)(v54 + 8) = __p;
          memset(&__p, 0, sizeof(__p));
          uint64_t v90 = v54;
          sub_101196CA0(v37, (uint64_t)v87);
          sub_101197178(v87);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          uint64_t v55 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v56 = &__str;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v56 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)unsigned int v87 = 136315138;
            *(void *)&v87[4] = v56;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Added blocked GID '%s'", v87, 0xCu);
          }
LABEL_96:
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
LABEL_97:
          }
            operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
    }
    sub_100044D00((const void **)&theArray);
    unsigned int v68 = sub_100256E84(v72, v71, &v77);
    __int16 v69 = (std::__shared_weak_count *)v68[6];
    v68[5] = v37;
    v68[6] = v73;
    if (v69) {
      sub_10004D2C8(v69);
    }
    sub_100044D00((const void **)&v75);
  }
  else
  {
    int v29 = v77;
    uint64_t v30 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v77);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I kEvoBlacklistedGIDsKey not found", (uint8_t *)&buf, 2u);
    }
    uint64_t v31 = sub_100256E84(v5, v29, &v77);
    uint64_t v32 = (std::__shared_weak_count *)v31[6];
    v31[5] = 0;
    v31[6] = 0;
    if (v32) {
      sub_10004D2C8(v32);
    }
  }
  return sub_1000577C4(&cf);
}

void sub_101164270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, const void *a20,const void *a21,uint64_t a22,const void *a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (v52[31] < 0) {
    operator delete(*v50);
  }
  operator delete(v52);
  sub_1001085D8((uint64_t)&a24);
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (*(char *)(v53 - 153) < 0) {
    operator delete(*(void **)(v53 - 176));
  }
  *(void *)(v53 - 144) = v51;
  sub_1011974F0((void ***)(v53 - 144));
  sub_100044D00(&a23);
  std::__shared_weak_count::~__shared_weak_count(a14);
  operator delete(v55);
  sub_100044D00(&a20);
  sub_1000577C4(&a21);
  _Unwind_Resume(a1);
}

void sub_101164410(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(unsigned char *)(v1 + 315);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  void v3[2] = sub_1011866E4;
  uint64_t v3[3] = &unk_101A95DC8;
  v3[4] = v1;
  char v4 = v2;
  sub_1011864F4((wis::MetricFactory *)v3);
}

void sub_101164488(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(*(void *)(a1 + 32) + 104));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v4;
  BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&__p);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    int v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
LABEL_10:
    operator new();
  }
  uint64_t v10 = v8[3];
  int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
    goto LABEL_10;
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_101164650(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  operator delete();
}

void sub_1011646C8(void *a1, int a2, uint64_t a3, BOOL a4, BOOL a5)
{
  uint64_t v9 = sub_10003B004(a1[18], a2);
  if (*(void *)(a1[18] + 16) != v9)
  {
    uint64_t v10 = v9;
    char v11 = a1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136315906;
      std::string::size_type v19 = "handleAPNSettingsChange_sync";
      __int16 v20 = 2080;
      uint64_t v21 = sub_100B15758(a3);
      __int16 v22 = 2080;
      uint64_t v23 = asStringBool(a4);
      __int16 v24 = 2080;
      uint64_t v25 = asStringBool(a5);
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn: reason = %s, bb=%s, tech=%s", (uint8_t *)&v18, 0x2Au);
    }
    if (a4)
    {
      uint64_t v12 = *(void *)(v10 + 24);
      if (v12) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a3);
      }
    }
    if (a5)
    {
      uint64_t v13 = a1[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 136315138;
        std::string::size_type v19 = "handleAPNSettingsChange_sync";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn", (uint8_t *)&v18, 0xCu);
      }
      uint64_t v14 = *(char **)(v10 + 40);
      if (v14) {
        (*(void (**)(char *, uint64_t))(*(void *)&v14[*(void *)(*(void *)v14 - 320)] + 48))(&v14[*(void *)(*(void *)v14 - 320)], a3);
      }
      BOOL v15 = a1[5];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 136315138;
        std::string::size_type v19 = "handleAPNSettingsChange_sync";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s: (3) refreshapn", (uint8_t *)&v18, 0xCu);
      }
      uint64_t v16 = a1[32];
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
      }
    }
    uint64_t v17 = a1[5];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136315138;
      std::string::size_type v19 = "handleAPNSettingsChange_sync";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: (4) refreshapn", (uint8_t *)&v18, 0xCu);
    }
    sub_101172474((uint64_t)a1);
  }
}

void sub_101164980(void *a1, unint64_t a2, char a3)
{
  int v6 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  if (sub_100AF2240(a1[18], v6))
  {
    int v7 = ConnectionMaskToType(a2);
    if (v7 < 36)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      _DWORD v10[2] = sub_1011798BC;
      v10[3] = &unk_101A959D8;
      void v10[4] = a1;
      int v11 = v6;
      int v12 = v7;
      char v13 = a3;
      uint64_t v14 = 0;
      BOOL v15 = 0;
      sub_10003E168(&v14, a1 + 1);
      uint64_t v9 = a1[3];
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 1174405120;
      uint64_t v17 = sub_101195718;
      int v18 = &unk_101A98BF0;
      uint64_t v20 = v14;
      uint64_t v21 = v15;
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::string::size_type v19 = v10;
      dispatch_async(v9, &buf);
      if (v21) {
        sub_10004D2C8(v21);
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      BOOL v8 = a1[5];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "assertionUpdate";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", (uint8_t *)&buf, 0xCu);
      }
    }
  }
}

void sub_101164B70(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_101164B7C(uint64_t a1)
{
  *(void *)a1 = off_101A94190;
  char v2 = (DataServiceInterface *)(a1 + 56);
  *(void *)(a1 + 56) = off_101A94AC0;
  *(void *)(a1 + 64) = off_101A94FB8;
  uint64_t v3 = (DataDriverObserver *)(a1 + 72);
  *(void *)(a1 + 72) = off_101A951D8;
  *(void *)(a1 + 80) = off_101A953D8;
  uint64_t v4 = (TetheringControllerInterface *)(a1 + 88);
  *(void *)(a1 + 88) = off_101A95490;
  BOOL v5 = (DataSliceManagerInterface *)(a1 + 96);
  *(void *)(a1 + 96) = off_101A954F0;
  DataServiceController::cleanSlicesStruct((DataServiceController *)a1);
  sub_100058DB0(__p, "/cc/props/provisioning_pco_switch");
  ctu::RestModule::unobserveProperty();
  if (v36 < 0) {
    operator delete(__p[0]);
  }
  sub_100119D90(*(void **)(a1 + 5136));
  sub_1000346F8(a1 + 5104, *(void **)(a1 + 5112));
  sub_1011876D8(a1 + 4616);
  sub_10005D144(*(void **)(a1 + 4600));
  sub_1000346F8(a1 + 4560, *(void **)(a1 + 4568));
  sub_101187854((void *)(a1 + 4528));
  uint64_t v6 = *(void *)(a1 + 4512);
  *(void *)(a1 + 4512) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 4504);
  *(void *)(a1 + 4504) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  sub_1000346F8(a1 + 4480, *(void **)(a1 + 4488));
  sub_1000346F8(a1 + 4456, *(void **)(a1 + 4464));
  sub_1011881D0(*(void **)(a1 + 4440));
  sub_100A8DC48(*(char **)(a1 + 4416));
  uint64_t v8 = *(void *)(a1 + 4392);
  *(void *)(a1 + 4392) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 4384);
  *(void *)(a1 + 4384) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 4360);
  *(void *)(a1 + 4360) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  sub_10003B34C((void *)(a1 + 4304));
  int v11 = *(std::__shared_weak_count **)(a1 + 4296);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 4280);
  if (v12) {
    sub_10004D2C8(v12);
  }
  char v13 = *(std::__shared_weak_count **)(a1 + 4264);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 4248);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_100119D90(*(void **)(a1 + 4224));
  BOOL v15 = *(std::__shared_weak_count **)(a1 + 4168);
  if (v15) {
    sub_10004D2C8(v15);
  }
  __p[0] = (void *)(a1 + 4136);
  sub_10005CBF0((void ***)__p);
  uint64_t v16 = *(NSObject **)(a1 + 4128);
  if (v16) {
    dispatch_release(v16);
  }
  uint64_t v17 = *(NSObject **)(a1 + 4120);
  if (v17)
  {
    dispatch_group_leave(v17);
    int v18 = *(NSObject **)(a1 + 4120);
    if (v18) {
      dispatch_release(v18);
    }
  }
  sub_1000346F8(a1 + 4072, *(void **)(a1 + 4080));
  sub_10041A760((void *)(a1 + 4040));
  sub_1000346F8(a1 + 4016, *(void **)(a1 + 4024));
  sub_1011878D8((void *)(a1 + 3984));
  sub_1000346F8(a1 + 3960, *(void **)(a1 + 3968));
  sub_1011878D8((void *)(a1 + 3928));
  sub_10030AB98((void *)(a1 + 3888));
  sub_10030AB98((void *)(a1 + 3848));
  sub_10005CD2C(a1 + 3824, *(char **)(a1 + 3832));
  sub_10097E974((void *)(a1 + 3792));
  sub_10005CD2C(a1 + 3768, *(char **)(a1 + 3776));
  sub_10118795C((void *)(a1 + 3736));
  sub_1000346F8(a1 + 3712, *(void **)(a1 + 3720));
  sub_100A8DBC4((void *)(a1 + 3680));
  sub_1000346F8(a1 + 3656, *(void **)(a1 + 3664));
  sub_1011879E0((void *)(a1 + 3624));
  sub_100B7E174(a1 + 3600, *(void **)(a1 + 3608));
  sub_101187A64((void *)(a1 + 3568));
  sub_101187AE8((void *)(a1 + 3528));
  sub_100600F40((void *)(a1 + 3488));
  sub_100600F40((void *)(a1 + 3448));
  sub_100600F40((void *)(a1 + 3408));
  sub_1000346F8(a1 + 3384, *(void **)(a1 + 3392));
  sub_101187B6C((void *)(a1 + 3352));
  sub_1000346F8(a1 + 3328, *(void **)(a1 + 3336));
  sub_10041A760((void *)(a1 + 3296));
  sub_1000346F8(a1 + 3272, *(void **)(a1 + 3280));
  sub_100A8DBC4((void *)(a1 + 3240));
  sub_1000346F8(a1 + 3216, *(void **)(a1 + 3224));
  sub_100A8DBC4((void *)(a1 + 3184));
  sub_1000886C0(a1 + 3160, *(char **)(a1 + 3168));
  sub_1000882E8((void *)(a1 + 3128));
  sub_10005D144(*(void **)(a1 + 3112));
  sub_101187BF0((void *)(a1 + 3072));
  sub_1000886C0(a1 + 3048, *(char **)(a1 + 3056));
  sub_101187C74((void *)(a1 + 3016));
  sub_10024D10C(a1 + 2992, *(void **)(a1 + 3000));
  sub_101187CF8((void *)(a1 + 2960));
  sub_1000346F8(a1 + 2936, *(void **)(a1 + 2944));
  sub_101187D7C((void *)(a1 + 2904));
  sub_1000346F8(a1 + 2880, *(void **)(a1 + 2888));
  sub_101187E00((void *)(a1 + 2848));
  sub_1000346F8(a1 + 2824, *(void **)(a1 + 2832));
  sub_1001085D8(a1 + 2776);
  sub_100136194(a1 + 1976);
  sub_100136194(a1 + 1176);
  sub_10019D5B8(a1 + 1152, *(void **)(a1 + 1160));
  sub_100313534(a1 + 1120, *(void **)(a1 + 1128));
  __p[0] = (void *)(a1 + 1088);
  sub_100047F64((void ***)__p);
  sub_10030AAD0(a1 + 1048, *(void **)(a1 + 1056));
  sub_1000346F8(a1 + 1024, *(void **)(a1 + 1032));
  sub_1000346F8(a1 + 1000, *(void **)(a1 + 1008));
  sub_1000346F8(a1 + 976, *(void **)(a1 + 984));
  sub_1000346F8(a1 + 952, *(void **)(a1 + 960));
  sub_1000346F8(a1 + 928, *(void **)(a1 + 936));
  sub_1000346F8(a1 + 896, *(void **)(a1 + 904));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 876));
  sub_10005CD2C(a1 + 848, *(char **)(a1 + 856));
  sub_10005CD2C(a1 + 808, *(char **)(a1 + 816));
  sub_1000346F8(a1 + 776, *(void **)(a1 + 784));
  sub_10026CF54(a1 + 744, *(void **)(a1 + 752));
  sub_1000346F8(a1 + 720, *(void **)(a1 + 728));
  sub_10003FB28(a1 + 696, *(void **)(a1 + 704));
  sub_1000346F8(a1 + 672, *(void **)(a1 + 680));
  sub_1000346F8(a1 + 648, *(void **)(a1 + 656));
  sub_1000346F8(a1 + 624, *(void **)(a1 + 632));
  sub_10005CD2C(a1 + 592, *(char **)(a1 + 600));
  sub_1007035FC(a1 + 568, *(void **)(a1 + 576));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 400));
  sub_1000881B0(a1 + 376, *(void **)(a1 + 384));
  __p[0] = (void *)(a1 + 344);
  sub_10008A88C((void ***)__p);
  sub_101188178(*(void **)(a1 + 328));
  uint64_t v19 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *(NSObject **)(a1 + 296);
  if (v20)
  {
    dispatch_group_leave(v20);
    uint64_t v21 = *(NSObject **)(a1 + 296);
    if (v21) {
      dispatch_release(v21);
    }
  }
  __int16 v22 = *(std::__shared_weak_count **)(a1 + 280);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(a1 + 264);
  if (v23) {
    sub_10004D2C8(v23);
  }
  __int16 v24 = *(std::__shared_weak_count **)(a1 + 248);
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(a1 + 232);
  if (v25) {
    sub_10004D2C8(v25);
  }
  char v26 = *(std::__shared_weak_count **)(a1 + 216);
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_100160A84((atomic_uint **)(a1 + 184));
  CFTypeRef v27 = *(std::__shared_weak_count **)(a1 + 176);
  if (v27) {
    sub_10004D2C8(v27);
  }
  int v28 = *(std::__shared_weak_count **)(a1 + 160);
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  uint64_t v30 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(a1 + 128);
  if (v31) {
    sub_10004D2C8(v31);
  }
  uint64_t v32 = *(std::__shared_weak_count **)(a1 + 112);
  if (v32) {
    sub_10004D2C8(v32);
  }
  DataSliceManagerInterface::~DataSliceManagerInterface(v5);
  TetheringControllerInterface::~TetheringControllerInterface(v4);
  DataDriverObserver::~DataDriverObserver(v3);
  DataServiceInterface::~DataServiceInterface(v2);
  DataWirelessTechnologyListManagerObserver::~DataWirelessTechnologyListManagerObserver((DataWirelessTechnologyListManagerObserver *)a1);
  uint64_t v33 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_101165384(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1011653AC(uint64_t a1)
{
  return sub_101164B7C(a1 - 56);
}

uint64_t sub_1011653B4(uint64_t a1)
{
  return sub_101164B7C(a1 - 64);
}

uint64_t sub_1011653BC(uint64_t a1)
{
  return sub_101164B7C(a1 - 72);
}

uint64_t sub_1011653C4(uint64_t a1)
{
  return sub_101164B7C(a1 - 80);
}

uint64_t sub_1011653CC(uint64_t a1)
{
  return sub_101164B7C(a1 - 88);
}

uint64_t sub_1011653D4(uint64_t a1)
{
  return sub_101164B7C(a1 - 96);
}

void sub_1011653DC(uint64_t a1)
{
  sub_101164B7C(a1);

  operator delete();
}

void sub_101165414(uint64_t a1)
{
  sub_101164B7C(a1 - 56);

  operator delete();
}

void sub_101165450(uint64_t a1)
{
  sub_101164B7C(a1 - 64);

  operator delete();
}

void sub_10116548C(uint64_t a1)
{
  sub_101164B7C(a1 - 72);

  operator delete();
}

void sub_1011654C8(uint64_t a1)
{
  sub_101164B7C(a1 - 80);

  operator delete();
}

void sub_101165504(uint64_t a1)
{
  sub_101164B7C(a1 - 88);

  operator delete();
}

void sub_101165540(uint64_t a1)
{
  sub_101164B7C(a1 - 96);

  operator delete();
}

uint64_t sub_10116557C(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 112);
  BOOL v5 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v3 = SlotIdFromPersonalityIdEx();
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t result = sub_10003B004(*(void *)(a1 + 144), v3);
  if (*(void *)(*(void *)(a1 + 144) + 16) != result) {
    operator new();
  }
  return result;
}

void sub_101165720()
{
  if (*(char *)(v0 + 23) < 0) {
    operator delete(*(void **)v0);
  }
  operator delete();
}

void sub_101165780(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v6 = dispatch_queue_create("installIWLanCACertificates", v5);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10117C428;
  block[3] = &unk_101A95AB8;
  block[4] = a1;
  block[5] = v4;
  int v8 = a2;
  dispatch_async(v6, block);
  if (v6) {
    dispatch_release(v6);
  }
}

uint64_t sub_101165864(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  if (a1 != a2)
  {
    while (1)
    {
      uint64_t v6 = *(void *)(a1 + 416);
      BOOL v5 = *(std::__shared_weak_count **)(a1 + 424);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v5);
      }
      if (sub_10001D294((unsigned __int8 *)(v6 + 24), (unsigned __int8 *)__p)) {
        break;
      }
      a1 += 432;
      if (a1 == a2)
      {
        a1 = a2;
        break;
      }
    }
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_101165914(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v5)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_9:
      *a3 = 0;
      a3[1] = 0;
      return;
    }
    int v10 = 136315394;
    int v11 = "getTechDataConfig_sync";
    __int16 v12 = 2080;
    uint64_t v13 = subscriber::asString();
    uint64_t v9 = "%s: No model for %s";
LABEL_11:
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v10, 0x16u);
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(v5 + 40);
  if (!v6)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    int v10 = 136315394;
    int v11 = "getTechDataConfig_sync";
    __int16 v12 = 2080;
    uint64_t v13 = subscriber::asString();
    uint64_t v9 = "%s: No TechDataDriver for %s";
    goto LABEL_11;
  }
  uint64_t v7 = *(void (**)(void))(*(void *)v6 + 312);

  v7();
}

void sub_101165AC0(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_101165AC8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_101165AD0(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (!v5)
  {
    int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v22 = 136315394;
      uint64_t v23 = "getTechDataConfig_sync";
      __int16 v24 = 2080;
      uint64_t v25 = "<invalid>";
      int v11 = "%s: Invalid Personality: %s";
      __int16 v12 = v10;
LABEL_30:
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v22, 0x16u);
      goto LABEL_31;
    }
    goto LABEL_31;
  }
  uint64_t v7 = sub_101165864(*(void *)(*(void *)(a1 + 144) + 8), *(void *)(*(void *)(a1 + 144) + 16), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v7)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = *(unsigned __int8 *)(a2 + 23);
      BOOL v15 = (v14 & 0x80u) != 0;
      uint64_t v16 = *(const char **)a2;
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(a2 + 8);
      }
      if (!v15) {
        uint64_t v16 = (const char *)a2;
      }
      if (v14) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = "<invalid>";
      }
      int v22 = 136315394;
      uint64_t v23 = "getTechDataConfig_sync";
      __int16 v24 = 2080;
      uint64_t v25 = v17;
      int v11 = "%s: No model for %s";
      goto LABEL_29;
    }
LABEL_31:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  uint64_t v8 = *(void *)(v7 + 40);
  if (!v8)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
      BOOL v19 = (v18 & 0x80u) != 0;
      uint64_t v20 = *(const char **)a2;
      if ((v18 & 0x80u) != 0) {
        uint64_t v18 = *(void *)(a2 + 8);
      }
      if (!v19) {
        uint64_t v20 = (const char *)a2;
      }
      if (v18) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = "<invalid>";
      }
      int v22 = 136315394;
      uint64_t v23 = "getTechDataConfig_sync";
      __int16 v24 = 2080;
      uint64_t v25 = v21;
      int v11 = "%s: No TechDataDriver for %s";
LABEL_29:
      __int16 v12 = v13;
      goto LABEL_30;
    }
    goto LABEL_31;
  }
  uint64_t v9 = *(void (**)(void))(*(void *)v8 + 312);

  v9();
}

void sub_101165D34(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
}

void sub_101165D3C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
}

BOOL sub_101165D44(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1008);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 1008;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  return v3 != a1 + 1008 && *(_DWORD *)(v3 + 28) <= a2 && *(unsigned char *)(v3 + 32) != 0;
}

BOOL sub_101165D9C(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 952);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 952;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  return v3 != a1 + 952 && *(_DWORD *)(v3 + 28) <= a2 && *(unsigned char *)(v3 + 32) != 0;
}

capabilities::ct *sub_101165DF4(capabilities::ct *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (uint64_t (***)(void, uint64_t, uint64_t, uint64_t))*((void *)a1 + 530);
  if (capabilities::ct::supportsCellRadio(a1)) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (capabilities::ct *)(**v8)(v8, v9, a3, a4);
  if (!a3)
  {
    if (!capabilities::ct::supportsCellRadio(result)) {
      a2 = 0;
    }
    uint64_t result = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *))(*(void *)a1 + 1088))(a1);
    if (a2 == result)
    {
      int v11 = *(uint64_t (**)(void))(**((void **)a1 + 530) + 8);
      return (capabilities::ct *)v11();
    }
  }
  return result;
}

capabilities::ct *sub_101165F04(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  return sub_101165DF4((capabilities::ct *)(a1 - 64), a2, a3, a4);
}

uint64_t sub_101165F0C(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int *a5)
{
  int v80 = a2;
  if (a3)
  {
    uint64_t v8 = 0;
    goto LABEL_42;
  }
  int v9 = a2;
  *(_OWORD *)std::string::size_type v75 = 0u;
  long long v76 = 0u;
  NetworkInterfaceInfo::NetworkInterfaceInfo();
  unint64_t v10 = *a5;
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 4136);
    if (v10 < (*(void *)(a1 + 4144) - v11) >> 4)
    {
      __int16 v12 = (uint64_t *)(v11 + 16 * v10);
      uint64_t v13 = *v12;
      uint64_t v14 = (std::__shared_weak_count *)v12[1];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v13)
      {
        std::string __p = 0;
        std::string v84 = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v13 + 480))(&__p);
        if (__p)
        {
          (*(void (**)(void *))(*(void *)__p + 536))(__p);
          BYTE13(v76) = isNetworkServicePrimaryRankDefault();
        }
        if (v84) {
          sub_10004D2C8(v84);
        }
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
  }
  BOOL v15 = (uint64_t *)(a1 + 3056);
  uint64_t v16 = *(void *)(a1 + 3056);
  if (!v16)
  {
    uint64_t v78 = 1;
    uint64_t v79 = a1 + 3016;
    goto LABEL_35;
  }
  uint64_t v17 = a1 + 3056;
  uint64_t v18 = *(void *)(a1 + 3056);
  do
  {
    int v19 = *(_DWORD *)(v18 + 32);
    BOOL v20 = v19 < v9;
    if (v19 >= v9) {
      uint64_t v21 = (uint64_t *)v18;
    }
    else {
      uint64_t v21 = (uint64_t *)(v18 + 8);
    }
    if (!v20) {
      uint64_t v17 = v18;
    }
    uint64_t v18 = *v21;
  }
  while (*v21);
  if ((uint64_t *)v17 == v15 || *(_DWORD *)(v17 + 32) > v9)
  {
LABEL_28:
    uint64_t v78 = 1;
    uint64_t v79 = a1 + 3016;
    if (v16)
    {
      do
      {
        while (1)
        {
          uint64_t v22 = v16;
          int v23 = *(_DWORD *)(v16 + 32);
          if (v23 <= v9) {
            break;
          }
          uint64_t v16 = *(void *)v22;
          if (!*(void *)v22)
          {
            CFTypeRef v74 = (uint64_t **)v22;
            goto LABEL_36;
          }
        }
        if (v23 >= v9) {
          goto LABEL_39;
        }
        uint64_t v16 = *(void *)(v22 + 8);
      }
      while (v16);
      CFTypeRef v74 = (uint64_t **)(v22 + 8);
      goto LABEL_36;
    }
LABEL_35:
    CFTypeRef v74 = (uint64_t **)(a1 + 3056);
    uint64_t v22 = a1 + 3056;
LABEL_36:
    uint64_t v82 = 0;
    __int16 v24 = (uint64_t *)operator new(0x48uLL);
    v81[0] = (uint64_t)v24;
    v81[1] = a1 + 3056;
    *((_DWORD *)v24 + 8) = v9;
    sub_100058DB0(&__p, "");
    NetworkInterfaceInfo::NetworkInterfaceInfo();
    if (v85 < 0) {
      operator delete(__p);
    }
    LOBYTE(v82) = 1;
    sub_100046C38((uint64_t **)(a1 + 3048), v22, v74, v24);
    uint64_t v22 = v81[0];
LABEL_39:
    std::string::operator=((std::string *)(v22 + 40), (const std::string *)v75);
    *(_DWORD *)(v22 + 64) = DWORD2(v76);
    *(_WORD *)(v22 + 68) = WORD6(v76);
    sub_101194EC0((uint64_t)&v78);
    uint64_t v8 = 1;
    goto LABEL_40;
  }
  if ((operator==() & 1) == 0)
  {
    int v9 = v80;
    uint64_t v16 = *v15;
    goto LABEL_28;
  }
  uint64_t v8 = 0;
LABEL_40:
  if (SBYTE7(v76) < 0) {
    operator delete(v75[0]);
  }
LABEL_42:
  if (*((unsigned char *)a5 + 40)) {
    goto LABEL_102;
  }
  uint64_t v25 = (uint64_t **)(a1 + 3000);
  char v26 = *(uint64_t **)(a1 + 3000);
  int v27 = v80;
  if (v26)
  {
    uint64_t v28 = a1 + 3000;
    uint64_t v29 = *(void *)(a1 + 3000);
    do
    {
      int v30 = *(_DWORD *)(v29 + 32);
      BOOL v31 = v30 < v80;
      if (v30 >= v80) {
        uint64_t v32 = (uint64_t *)v29;
      }
      else {
        uint64_t v32 = (uint64_t *)(v29 + 8);
      }
      if (!v31) {
        uint64_t v28 = v29;
      }
      uint64_t v29 = *v32;
    }
    while (*v32);
    if ((uint64_t **)v28 != v25 && v80 >= *(_DWORD *)(v28 + 32))
    {
      uint64_t v35 = *(void *)(v28 + 48);
      uint64_t v33 = v28 + 48;
      uint64_t v34 = v35;
      if (v35)
      {
        uint64_t v36 = v33;
        do
        {
          int v37 = *(_DWORD *)(v34 + 32);
          BOOL v38 = v37 < a3;
          if (v37 >= a3) {
            uint64_t v39 = (uint64_t *)v34;
          }
          else {
            uint64_t v39 = (uint64_t *)(v34 + 8);
          }
          if (!v38) {
            uint64_t v36 = v34;
          }
          uint64_t v34 = *v39;
        }
        while (*v39);
        if (v36 != v33 && *(_DWORD *)(v36 + 32) <= a3 && *(_DWORD *)(v36 + 40) == *a5 && *(_DWORD *)(v36 + 44) == a5[1])
        {
          uint64_t v40 = 0;
          unsigned __int8 v41 = a5 + 2;
          do
          {
            BOOL v43 = *(_DWORD *)(v36 + v40 * 4 + 48) == v41[v40]
               && *(void *)(v36 + v40 * 4 + 56) == *(void *)&v41[v40 + 2];
            BOOL v44 = !v43 || v40 == 4;
            v40 += 4;
          }
          while (!v44);
          if (v43 && !*(unsigned char *)(v36 + 80) && *(_DWORD *)(v36 + 84) == a5[11]) {
            goto LABEL_102;
          }
        }
      }
    }
    v75[0] = (void *)1;
    v75[1] = (void *)(a1 + 2960);
    while (1)
    {
      while (1)
      {
        long long v45 = (uint64_t **)v26;
        int v46 = *((_DWORD *)v26 + 8);
        if (v46 <= v80) {
          break;
        }
        char v26 = *v45;
        uint64_t v25 = v45;
        if (!*v45) {
          goto LABEL_88;
        }
      }
      if (v46 >= v80) {
        break;
      }
      char v26 = v45[1];
      if (!v26)
      {
        uint64_t v25 = v45 + 1;
        goto LABEL_88;
      }
    }
  }
  else
  {
    v75[0] = (void *)1;
    v75[1] = (void *)(a1 + 2960);
    long long v45 = (uint64_t **)(a1 + 3000);
LABEL_88:
    uint64_t v47 = operator new(0x40uLL);
    uint8_t v47[8] = v27;
    *((void *)v47 + 7) = 0;
    *((void *)v47 + 6) = 0;
    *((void *)v47 + 5) = v47 + 12;
    sub_100046C38((uint64_t **)(a1 + 2992), (uint64_t)v45, v25, (uint64_t *)v47);
    long long v45 = (uint64_t **)v47;
  }
  uint64_t v50 = v45[6];
  char v49 = v45 + 6;
  uint64_t v48 = v50;
  if (v50)
  {
    do
    {
      while (1)
      {
        uint64_t v51 = (uint64_t **)v48;
        int v52 = *((_DWORD *)v48 + 8);
        if (v52 <= a3) {
          break;
        }
        uint64_t v48 = *v51;
        uint64_t v53 = v51;
        if (!*v51) {
          goto LABEL_98;
        }
      }
      if (v52 >= a3)
      {
        uint64_t v56 = (char *)v51;
        goto LABEL_101;
      }
      uint64_t v48 = v51[1];
    }
    while (v48);
    uint64_t v53 = v51 + 1;
  }
  else
  {
    uint64_t v53 = v49;
    uint64_t v51 = v49;
  }
LABEL_98:
  uint64_t v56 = (char *)operator new(0x58uLL);
  uint64_t v54 = 0;
  *((_DWORD *)v56 + 8) = a3;
  *((_OWORD *)v56 + 3) = 0u;
  *((_OWORD *)v56 + 4) = 0u;
  *((void *)v56 + 10) = 0;
  *((void *)v56 + 5) = 0xFFFFFFFFLL;
  do
  {
    uint64_t v55 = &v56[v54];
    *((_DWORD *)v55 + 12) = 0;
    *((void *)v55 + 7) = 0;
    v54 += 16;
  }
  while (v54 != 32);
  v56[80] = 0;
  *((_DWORD *)v56 + 21) = 2;
  sub_100046C38(v49 - 1, (uint64_t)v51, v53, (uint64_t *)v56);
LABEL_101:
  long long v57 = *(_OWORD *)a5;
  long long v58 = *((_OWORD *)a5 + 1);
  *(_OWORD *)(v56 + 72) = *((_OWORD *)a5 + 2);
  *(_OWORD *)(v56 + 56) = v58;
  *(_OWORD *)(v56 + 40) = v57;
  sub_101194F24((uint64_t)v75);
  uint64_t v8 = 1;
LABEL_102:
  if (isSlice())
  {
    char v59 = 0;
    int v60 = 28;
    int v61 = v80;
    do
    {
      v75[0] = 0;
      v75[1] = 0;
      DataServiceController::getConnection_sync(a1, v61, v60, (uint64_t *)v75);
      if (v75[0] && (*(unsigned int (**)(void *))(*(void *)v75[0] + 168))(v75[0])) {
        char v59 = 1;
      }
      if (v75[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v75[1]);
      }
      ++v60;
    }
    while (v60 != 36);
    v75[0] = (void *)1;
    long long v76 = 0u;
    uint64_t v77 = 0;
    v75[1] = (void *)(a1 + 4040);
    char v62 = sub_10005DF14((uint64_t *)&v76, a1 + 4072);
    int v63 = (uint64_t *)&v76 + 1;
    uint64_t v64 = *((void *)&v76 + 1);
    if (!*((void *)&v76 + 1)) {
      goto LABEL_121;
    }
    uint64_t v65 = (uint64_t *)&v76 + 1;
    do
    {
      uint64_t v66 = (uint64_t *)v64;
      uint64_t v67 = v65;
      int v68 = *(_DWORD *)(v64 + 28);
      if (v68 >= v61) {
        uint64_t v65 = (uint64_t *)v64;
      }
      else {
        v64 += 8;
      }
      uint64_t v64 = *(void *)v64;
    }
    while (v64);
    if (v65 != (uint64_t *)((char *)&v76 + 8)
      && (v68 >= v61 ? (v69 = v66) : (v69 = v67), int v63 = v65, v61 >= *((_DWORD *)v69 + 7)))
    {
      if (v68 < v61) {
        uint64_t v66 = v67;
      }
      *((unsigned char *)v66 + 32) = v59;
    }
    else
    {
LABEL_121:
      std::string __p = 0;
      v81[0] = 0;
      uint64_t v70 = sub_10005CF3C(v62, v63, (uint64_t **)&__p, v81, &v80);
      if (!*v70)
      {
        int v71 = operator new(0x28uLL);
        v71[7] = v80;
        *((unsigned char *)v71 + 32) = v59;
        char v72 = __p;
        *(void *)int v71 = 0;
        *((void *)v71 + 1) = 0;
        *((void *)v71 + 2) = v72;
        *uint64_t v70 = (uint64_t)v71;
        if (*(void *)v76)
        {
          *(void *)&long long v76 = *(void *)v76;
          int v71 = (_DWORD *)*v70;
        }
        sub_100046C90(*((uint64_t **)&v76 + 1), (uint64_t *)v71);
        ++v77;
      }
    }
    sub_101194F88((uint64_t)v75);
  }
  return v8;
}

void sub_101166598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DataServiceController::getPDPActivator@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(this + 4136), a2 >= (unint64_t)((*(void *)(this + 4144) - v3) >> 4)))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return this;
}

void DataServiceController::getConnection_sync(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v7)
  {
    uint64_t v8 = *(uint64_t **)v7;
    int v9 = *(uint64_t **)(v7 + 8);
    if (*(uint64_t **)v7 != v9)
    {
      do
      {
        uint64_t v10 = *v8;
        uint64_t v11 = (std::__shared_weak_count *)v8[1];
        *a4 = *v8;
        a4[1] = (uint64_t)v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v10)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 472))(v10) == a3) {
            return;
          }
          if (!v11) {
            goto LABEL_9;
          }
        }
        else if (!v11)
        {
          goto LABEL_9;
        }
        sub_10004D2C8(v11);
LABEL_9:
        v8 += 2;
      }
      while (v8 != v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_101166788(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011667A0(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int *a5)
{
  return sub_101165F0C(a1 - 64, a2, a3, a4, a5);
}

void sub_1011667A8(uint64_t a1, char a2)
{
}

void sub_1011667B0(uint64_t a1, char a2)
{
  xpc_object_t v2 = xpc_BOOL_create(a2 != 0);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/events/ota_activation_assertion_changed");
  xpc_object_t object = v2;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v6 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_101166850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_101166898(uint64_t a1, char a2)
{
}

void sub_1011668A0(uint64_t a1, char a2)
{
}

void sub_1011668A8(uint64_t a1, char a2)
{
}

uint64_t sub_1011668B0(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v10 = (uint64_t **)(a1 + 3768);
  uint64_t v11 = (char *)(a1 + 3776);
  __int16 v12 = *(void **)(a1 + 3776);
  if (!v12) {
    goto LABEL_11;
  }
  uint64_t v13 = (char *)(a1 + 3776);
  do
  {
    char v14 = sub_100046FE8(v12 + 4, (void **)a2);
    if (v14 >= 0) {
      BOOL v15 = v12;
    }
    else {
      BOOL v15 = v12 + 1;
    }
    if (v14 >= 0) {
      uint64_t v13 = (char *)v12;
    }
    __int16 v12 = (void *)*v15;
  }
  while (*v15);
  if (v13 == v11 || (sub_100046FE8((void *)a2, (void **)v13 + 4) & 0x80) != 0)
  {
LABEL_11:
    uint64_t v20 = 0;
    uint64_t v16 = (void **)sub_100046ED4((uint64_t)v10, &v20, (void **)a2);
    uint64_t v13 = (char *)*v16;
    if (!*v16)
    {
      uint64_t v17 = (uint64_t **)v16;
      uint64_t v13 = (char *)operator new(0x48uLL);
      uint64_t v18 = v13 + 32;
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(v18, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)uint64_t v18 = *(_OWORD *)a2;
        *((void *)v13 + 6) = *(void *)(a2 + 16);
      }
      *((void *)v13 + 7) = 2;
      *((_DWORD *)v13 + 16) = 0;
      sub_100046C38(v10, v20, v17, (uint64_t *)v13);
    }
  }
  *((_DWORD *)v13 + 14) = a3;
  *((_DWORD *)v13 + 15) = a4;
  *((_DWORD *)v13 + 16) = a5;
  uint64_t result = *(void *)(a1 + 3760);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)result + 48))(result, v10);
  }
  return result;
}

void sub_101166A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  sub_1000C6EE8(v10, v9);
  _Unwind_Resume(a1);
}

uint64_t sub_101166A38(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  return sub_1011668B0(a1 - 64, a2, a3, a4, a5);
}

void sub_101166A40(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  __int16 v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  sub_10005C928(&v11, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  __int16 v16 = a4;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  sub_10005C928(&v17, v11, (uint64_t)v12, v12 - (unsigned char *)v11);
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v27 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v27 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_12;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_11:
  xpc_object_t v27 = v7;
LABEL_12:
  xpc_release(v6);
  write_rest_value();
  std::string __p = &v27;
  uint64_t v21 = "first";
  sub_100035E70((uint64_t)&__p, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  write_rest_value();
  std::string __p = &v27;
  uint64_t v21 = "second";
  sub_100035E70((uint64_t)&__p, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_object_t v8 = v27;
  if (v27) {
    xpc_retain(v27);
  }
  else {
    xpc_object_t v8 = xpc_null_create();
  }
  xpc_release(v27);
  sub_100058DB0(&__p, "/cc/events/ims_pco");
  xpc_object_t v27 = v8;
  xpc_object_t v9 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v22 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
  if (v17)
  {
    uint64_t v18 = v17;
    operator delete(v17);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
  if (v11)
  {
    __int16 v12 = v11;
    operator delete(v11);
  }
}

void sub_101166C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101166D3C(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
}

unsigned __int8 *sub_101166D44(uint64_t a1, uint64_t a2, int a3)
{
  xpc_object_t v6 = (uint64_t **)(a1 + 3824);
  uint64_t result = (unsigned __int8 *)sub_100046F68(a1 + 3824, (void **)a2);
  xpc_object_t v8 = result;
  if ((unsigned __int8 *)(a1 + 3832) == result)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = asStringBool(a3);
      uint64_t v17 = *(unsigned __int8 *)(a2 + 23);
      BOOL v18 = (v17 & 0x80u) != 0;
      if ((v17 & 0x80u) != 0) {
        uint64_t v17 = *(void *)(a2 + 8);
      }
      if (v18) {
        uint64_t v19 = *(const char **)a2;
      }
      else {
        uint64_t v19 = (const char *)a2;
      }
      if (v17) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)xpc_object_t v26 = v16;
      *(_WORD *)&v26[8] = 2080;
      *(void *)&v26[10] = v20;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I ims_handover_state: %s for %s", buf, 0x16u);
    }
    uint64_t v24 = 0;
    uint64_t v21 = (uint64_t **)sub_100046ED4((uint64_t)v6, &v24, (void **)a2);
    if (!*v21)
    {
      *(void *)&v26[12] = 0;
      char v22 = (char *)operator new(0x40uLL);
      *(void *)&v26[4] = v8;
      xpc_object_t v23 = v22 + 32;
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(v23, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)xpc_object_t v23 = *(_OWORD *)a2;
        *((void *)v22 + 6) = *(void *)(a2 + 16);
      }
      v22[56] = a3;
      sub_100046C38(v6, v24, v21, (uint64_t *)v22);
    }
  }
  else
  {
    if (result[56] == a3) {
      return result;
    }
    xpc_object_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asStringBool(a3);
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      BOOL v12 = (v11 & 0x80u) != 0;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v12) {
        uint64_t v13 = *(const char **)a2;
      }
      else {
        uint64_t v13 = (const char *)a2;
      }
      if (v11) {
        char v14 = v13;
      }
      else {
        char v14 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)xpc_object_t v26 = v10;
      *(_WORD *)&v26[8] = 2080;
      *(void *)&v26[10] = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ims_handover_state: %s for %s", buf, 0x16u);
    }
    v8[56] = a3;
  }
  uint64_t result = *(unsigned __int8 **)(a1 + 3816);
  if (result) {
    return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, uint64_t **))(*(void *)result + 48))(result, v6);
  }
  return result;
}

void sub_101166F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_1000C6EE8(v11, v12);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_101166FC0(uint64_t a1, uint64_t a2, int a3)
{
  return sub_101166D44(a1 - 64, a2, a3);
}

void sub_101166FC8(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  uint64_t v4 = 1;
  uint64_t v5 = a1 + 3184;
  xpc_object_t v7 = (unsigned int *)&v6;
  *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 3216), &v6, (uint64_t)&unk_10144E20E, &v7) + 8) = a3;
  sub_101167050(a1);
}

void sub_10116703C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_101167050(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  sub_10003E168(&v3, (void *)(a1 + 8));
  xpc_object_t v2 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_10003E168(&v3, v1);
  operator new();
}

void sub_101167174(uint64_t a1, int a2, int a3)
{
}

void sub_101167180(uint64_t a1)
{
}

uint64_t sub_101167188(uint64_t a1, int a2, int a3)
{
  int v5 = a2;
  v4[0] = 1;
  v4[1] = a1 + 3240;
  int v6 = (unsigned int *)&v5;
  *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 3272), &v5, (uint64_t)&unk_10144E20E, &v6) + 8) = a3;
  return sub_101195120((uint64_t)v4);
}

void sub_1011671F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_101167204(uint64_t a1, int a2, int a3)
{
  return sub_101167188(a1 - 72, a2, a3);
}

void sub_10116720C(uint64_t a1, int a2, int a3, uint64_t a4)
{
  xpc_object_t v7 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = a3;
    __int16 v10 = 2048;
    uint64_t v11 = a4;
    __int16 v12 = 1024;
    int v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I application ID update: appID=%d, connectionMask=%llu, slot %d", buf, 0x18u);
  }
  write_rest_value();
  sub_100058DB0(buf, "/cc/events/application_id");
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(0);
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v8);
}

void sub_10116737C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, xpc_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011673DC(uint64_t a1, int a2, int a3, uint64_t a4)
{
}

void sub_1011673E4(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4)
{
  if (*(unsigned char *)(a1 + 312))
  {
    xpc_object_t v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    xpc_object_t v8 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = asString();
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asStringBool(a4);
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I deactivateAllContexts: %s: %s", buf, 0x16u);
    }
    uint64_t v9 = *(void *)(a1 + 112);
    *(void *)&long long v21 = *(void *)(a1 + 104);
    *((void *)&v21 + 1) = v9;
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    subscriber::makeSimSlotRange();
    if (*((void *)&v21 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v21 + 1));
    }
    uint64_t v11 = *(int **)buf;
    __int16 v10 = *(int **)&buf[8];
    if (*(void *)buf != *(void *)&buf[8])
    {
      __int16 v12 = *(uint64_t (**)(void))&buf[16];
      while ((v12(*v11) & 1) == 0)
      {
        if (++v11 == v10)
        {
          uint64_t v11 = v10;
          break;
        }
      }
      int v13 = *(int **)&buf[8];
      while (v11 != v13)
      {
        uint64_t v14 = sub_10003B004(*(void *)(a1 + 144), *v11);
        if (*(void *)(*(void *)(a1 + 144) + 16) != v14)
        {
          uint64_t v15 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = asString();
            LODWORD(v21) = 136315138;
            *(void *)((char *)&v21 + 4) = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I deactivateAllContexts: working on: %s", (uint8_t *)&v21, 0xCu);
          }
          uint64_t v17 = *(char **)(v14 + 24);
          if (v17) {
            (*(void (**)(char *, uint64_t))(*(void *)&v17[*(void *)(*(void *)v17 - 320)] + 72))(&v17[*(void *)(*(void *)v17 - 320)], a3);
          }
          if (!a4)
          {
            BOOL v18 = *(char **)(v14 + 40);
            if (v18) {
              (*(void (**)(char *, uint64_t))(*(void *)&v18[*(void *)(*(void *)v18 - 320)] + 72))(&v18[*(void *)(*(void *)v18 - 320)], a3);
            }
          }
        }
        uint64_t v19 = v11 + 1;
        uint64_t v11 = v10;
        if (v19 != v10)
        {
          uint64_t v11 = v19;
          while ((v12(*v11) & 1) == 0)
          {
            if (++v11 == v10)
            {
              uint64_t v11 = v10;
              break;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "deactivateAllContexts_sync";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
  }
}

void sub_101167710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_101167730(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 4096)) {
    BOOL v4 = *(unsigned char *)(a1 + 617) != 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = *(_DWORD *)(a1 + 1144);
  BOOL v6 = v5 == 2;
  if (v5 == 2
    || *(unsigned char *)(a1 + 921)
    || capabilities::ct::getRadioModuleType((capabilities::ct *)a1) != 2)
  {
    int v19 = 0;
    goto LABEL_15;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 104));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_39:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_13;
    }
LABEL_40:
    int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 64))(v16) ^ 1;
    goto LABEL_41;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_39;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
    goto LABEL_40;
  }
LABEL_13:
  int v18 = 1;
LABEL_41:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  uint64_t v35 = *(void *)(a1 + 344);
  uint64_t v36 = *(void *)(a1 + 352);
  if (v35 != v36)
  {
    do
    {
      if (subscriber::isSimPresent())
      {
        int v39 = 1;
        goto LABEL_52;
      }
      v35 += 168;
    }
    while (v35 != v36);
    uint64_t v37 = *(void *)(a1 + 344);
    uint64_t v38 = *(void *)(a1 + 352);
    while (v37 != v38)
    {
      if (subscriber::isSimInTransientState())
      {
        uint64_t v40 = *(NSObject **)(a1 + 40);
        BOOL v41 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
        int v19 = 0;
        int v20 = 0;
        if (v41)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I SIM is in transient state", buf, 2u);
          int v19 = 0;
          int v20 = 0;
        }
        goto LABEL_16;
      }
      v37 += 168;
    }
  }
  int v39 = 0;
LABEL_52:
  int v19 = v18 | v39;
LABEL_15:
  int v20 = 1;
LABEL_16:
  unsigned int v21 = v19 | (v20 << 8);
  char v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v23 = v5 == 2;
    uint64_t v24 = asStringBool();
    uint64_t v25 = asStringBool(v4);
    uint64_t v26 = asStringBool(v23);
    *(_DWORD *)long long buf = 136316162;
    *(void *)&uint8_t buf[4] = "updateCellularDataSettingsChangeNotification_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a2;
    __int16 v54 = 2080;
    uint64_t v55 = v24;
    __int16 v56 = 2080;
    uint64_t v57 = v25;
    __int16 v58 = 2080;
    uint64_t v59 = v26;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: Sending kCTCellularDataSettingsChangeNotification as something changed (%s): isCapable = %s, isEnabled = %s, isAirplaneMode = %s", buf, 0x34u);
  }
  if (v21 >= 0x100)
  {
    BOOL value = v4;
    BOOL v43 = v6;
    BOOL v44 = v19;
    uint64_t v27 = *(void *)(a1 + 152);
    os_unfair_lock_lock((os_unfair_lock_t)(v27 + 24));
    *(unsigned char *)(v27 + 86) = v19;
    os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 24));
    xpc_object_t v52 = 0;
    xpc_object_t v28 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v29 = v28;
    if (v28)
    {
      xpc_object_t v52 = v28;
    }
    else
    {
      xpc_object_t v29 = xpc_null_create();
      xpc_object_t v52 = v29;
      if (!v29)
      {
        xpc_object_t v30 = xpc_null_create();
        xpc_object_t v29 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v29);
LABEL_27:
      xpc_release(v29);
      xpc_object_t v50 = xpc_BOOL_create(value);
      if (!v50) {
        xpc_object_t v50 = xpc_null_create();
      }
      *(void *)long long buf = &v52;
      *(void *)&uint8_t buf[8] = "kCellularDataEnabled";
      sub_100035E70((uint64_t)buf, &v50, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v50);
      xpc_object_t v50 = 0;
      xpc_object_t v48 = xpc_BOOL_create(v43);
      if (!v48) {
        xpc_object_t v48 = xpc_null_create();
      }
      *(void *)long long buf = &v52;
      *(void *)&uint8_t buf[8] = "kAirplaneMode";
      sub_100035E70((uint64_t)buf, &v48, &v49);
      xpc_release(v49);
      xpc_object_t v49 = 0;
      xpc_release(v48);
      xpc_object_t v48 = 0;
      xpc_object_t v46 = xpc_BOOL_create(v44);
      if (!v46) {
        xpc_object_t v46 = xpc_null_create();
      }
      *(void *)long long buf = &v52;
      *(void *)&uint8_t buf[8] = "kCellularDataCapable";
      sub_100035E70((uint64_t)buf, &v46, &v47);
      xpc_release(v47);
      xpc_object_t v47 = 0;
      xpc_release(v46);
      xpc_object_t v46 = 0;
      xpc_object_t v31 = v52;
      *(void *)long long buf = v52;
      if (v52)
      {
        xpc_retain(v52);
      }
      else
      {
        xpc_object_t v31 = xpc_null_create();
        *(void *)long long buf = v31;
      }
      xpc_object_t v32 = xpc_null_create();
      xpc_object_t v45 = v32;
      sub_1000452AC(170, (xpc_object_t *)buf, &v45);
      xpc_release(v32);
      xpc_release(v31);
      (*(void (**)(void, BOOL *))(**(void **)(a1 + 4240) + 120))(*(void *)(a1 + 4240), &value);
      xpc_release(v52);
      int v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
      sub_101168D34(*(void *)(a1 + 144), v33);
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.commcenter.DataSettingsChangedNotification", 0, 0, 0);
      return;
    }
    xpc_object_t v30 = xpc_null_create();
LABEL_26:
    xpc_object_t v52 = v30;
    goto LABEL_27;
  }
}

void sub_101167C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t object)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_101167D40(uint64_t a1, int a2, unsigned char *a3, char *a4)
{
  xpc_object_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)&v15[4] = asString();
    *(_WORD *)&v15[12] = 2080;
    *(void *)&v15[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I (change states) old basebandProvisionedState = %s, new basebandProvisionedState = %s", v15, 0x16u);
  }
  uint64_t v9 = (void *)sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void **)(*(void *)(a1 + 144) + 16) != v9)
  {
    uint64_t v10 = *(void *)(a1 + 152);
    uint64_t v11 = (std::__shared_weak_count *)v9[53];
    *(void *)uint64_t v15 = v9[52];
    *(void *)&v15[8] = v11;
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100AE5214(v10, (uint64_t)v15, *a4);
      sub_10004D2C8(v11);
    }
    else
    {
      sub_100AE5214(v10, (uint64_t)v15, *a4);
    }
    int v12 = *a4;
    if ((*a3 != 2) == (v12 == 2))
    {
      uint64_t v13 = v9[3];
      uint64_t v14 = (std::__shared_weak_count *)v9[4];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v13) {
        (*(void (**)(uint64_t, BOOL))(*(void *)v13 + 400))(v13, v12 == 2);
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
  }
}

void sub_101167F1C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101167F3C(uint64_t a1, int a2)
{
  BOOL result = sub_100AF2240(*(void *)(a1 + 144), a2);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 152);
    uint64_t v6 = sub_100AEFE40(*(void *)(a1 + 144), a2);
    xpc_object_t v7 = *(std::__shared_weak_count **)(v6 + 424);
    v9[0] = *(void *)(v6 + 416);
    v9[1] = v7;
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      int v8 = sub_100AE5180(v5, (uint64_t)v9);
      sub_10004D2C8(v7);
    }
    else
    {
      int v8 = sub_100AE5180(v5, (uint64_t)v9);
    }
    return v8 == 2;
  }
  return result;
}

BOOL sub_101167FD4(uint64_t a1, int a2)
{
  return sub_101167F3C(a1 - 56, a2);
}

BOOL sub_101167FDC(uint64_t a1, int a2)
{
  return sub_101167F3C(a1 - 64, a2);
}

BOOL sub_101167FE4(uint64_t a1, int a2)
{
  BOOL v4 = sub_100AF2240(*(void *)(a1 + 144), a2);
  if (!v4) {
    return 0;
  }
  if (!capabilities::ct::supportsGemini((capabilities::ct *)v4))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 104));
    int v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    v22[0] = v13;
    char v17 = sub_10004D37C(&v12[1].__m_.__sig, v22);
    if (v17)
    {
      uint64_t v19 = v17[3];
      int v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        if (!v19) {
          goto LABEL_20;
        }
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    int v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_20;
    }
LABEL_17:
    if ((*(uint64_t (**)(uint64_t))(*(void *)v19 + 168))(v19))
    {
      uint64_t v10 = 1;
      if (v20) {
        return v10;
      }
      goto LABEL_21;
    }
LABEL_20:
    uint64_t v10 = 0;
    if (v20) {
      return v10;
    }
LABEL_21:
    sub_10004D2C8(v18);
    return v10;
  }
  uint64_t v6 = *(void *)(a1 + 152);
  uint64_t v7 = sub_100AEFE40(*(void *)(a1 + 144), a2);
  int v8 = *(std::__shared_weak_count **)(v7 + 424);
  v22[0] = *(void *)(v7 + 416);
  v22[1] = (unint64_t)v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    int v9 = sub_100AE5180(v6, (uint64_t)v22);
    sub_10004D2C8(v8);
  }
  else
  {
    int v9 = sub_100AE5180(v6, (uint64_t)v22);
  }
  return v9 == 1;
}

void sub_101168184(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1011681A0(uint64_t a1, int a2)
{
  return sub_101167FE4(a1 - 56, a2);
}

BOOL sub_1011681A8(uint64_t a1, int a2)
{
  return sub_101167FE4(a1 - 64, a2);
}

uint64_t sub_1011681B0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 800);
}

uint64_t sub_1011681B8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 744);
}

uint64_t sub_1011681C0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 736);
}

uint64_t sub_1011681C8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 314);
}

uint64_t sub_1011681D0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 258);
}

uint64_t sub_1011681D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 250);
}

uint64_t sub_1011681E0@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(result + 4136), a2 >= (unint64_t)((*(void *)(result + 4144) - v3) >> 4)))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

uint64_t sub_101168224(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 4144) - *(void *)(a1 + 4136)) >> 4;
}

uint64_t sub_101168238@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(result + 4064), a2 >= (unint64_t)((*(void *)(result + 4072) - v3) >> 4)))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

uint64_t sub_10116827C@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(result + 4064), a2 >= (unint64_t)((*(void *)(result + 4072) - v3) >> 4)))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

uint64_t DataServiceController::getPDPActivators(DataServiceController *this)
{
  return (uint64_t)this + 4136;
}

uint64_t sub_1011682CC(uint64_t a1)
{
  return a1 + 4064;
}

uint64_t sub_1011682D4(uint64_t a1)
{
  return a1 + 4136;
}

uint64_t sub_1011682E0(uint64_t a1)
{
  return a1 + 4064;
}

void sub_1011682E8(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_100AE6B74(&v9, *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * ((a3[1] - *a3) >> 5));
  void v12[4] = a1;
  int v13 = a2;
  uint64_t v15 = 0;
  long long v14 = 0uLL;
  sub_100AE6B74(&v14, v9, v10, 0xCCCCCCCCCCCCCCCDLL * ((v10 - v9) >> 5));
  uint64_t v16 = a4;
  sub_1000DFC90((uint64_t)&v17, a5);
  v12[0] = 0;
  v12[1] = 0;
  sub_10003E168(v12, (void *)(a1 + 8));
  operator new();
}

void sub_1011684BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10116850C(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
}

void sub_101168514(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_100AE6B74(&v9, *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * ((a3[1] - *a3) >> 5));
  void v12[4] = a1;
  int v13 = a2;
  uint64_t v15 = 0;
  long long v14 = 0uLL;
  sub_100AE6B74(&v14, v9, v10, 0xCCCCCCCCCCCCCCCDLL * ((v10 - v9) >> 5));
  uint64_t v16 = a4;
  sub_1000DFC90((uint64_t)&v17, a5);
  v12[0] = 0;
  v12[1] = 0;
  sub_10003E168(v12, (void *)(a1 + 8));
  operator new();
}

void sub_1011686E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_101168738(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
}

void sub_101168740(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  void v5[4] = a1;
  int v6 = a2;
  uint64_t v7 = a3;
  sub_1008DC004((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_101168888(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1011688A0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
}

void DataServiceController::enableContextStateChangeNotificationRepost(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 136315394;
    uint64_t v17 = "enableContextStateChangeNotificationRepost";
    __int16 v18 = 2080;
    uint64_t v19 = a4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: %s", (uint8_t *)&v16, 0x16u);
  }
  uint64_t v11 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v11)
  {
    int v12 = *(uint64_t **)v11;
    int v13 = *(uint64_t **)(v11 + 8);
    if (*(uint64_t **)v11 != v13)
    {
      do
      {
        uint64_t v15 = *v12;
        long long v14 = (std::__shared_weak_count *)v12[1];
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v15 && (a3 == 36 || (*(unsigned int (**)(uint64_t))(*(void *)v15 + 472))(v15) == a3)) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 528))(v15, a5);
        }
        if (v14) {
          sub_10004D2C8(v14);
        }
        v12 += 2;
      }
      while (v12 != v13);
    }
  }
}

void sub_101168A4C(_Unwind_Exception *exception_object)
{
}

void sub_101168A6C(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
}

void sub_101168A74(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
}

void sub_101168A7C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_101168A84(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_101168A8C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

uint64_t sub_101168A94(uint64_t a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 4176));
  return v1 & 1;
}

uint64_t sub_101168AA8(uint64_t a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 4120));
  return v1 & 1;
}

BOOL sub_101168ABC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1144) == 2;
}

BOOL sub_101168ACC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1088) == 2;
}

uint64_t DataServiceController::isDataAllowed(DataServiceController *this)
{
  uint64_t v1 = *((void *)this + 19);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 84);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168B18(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 84);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168B54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 84);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168B90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 84);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168BCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 152);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 85);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168C08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 85);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168C44(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 85);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168C80(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 85);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168CBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 152);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 86);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t sub_101168CF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  char v2 = (os_unfair_lock_s *)(v1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 86);
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_101168D34(uint64_t a1, int a2)
{
  uint64_t v2 = sub_100AEFE40(a1, a2);
  uint64_t v3 = *(uint64_t **)v2;
  long long v4 = *(uint64_t **)(v2 + 8);
  if (*(uint64_t **)v2 != v4)
  {
    do
    {
      uint64_t v5 = *v3;
      int v6 = (std::__shared_weak_count *)v3[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v5) {
        (*(void (**)(uint64_t, uint64_t, void, void, void))(*(void *)v5 + 520))(v5, 20, 0, 0, 0);
      }
      if (v6) {
        sub_10004D2C8(v6);
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
}

void sub_101168DD4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101168DEC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(void *)(v3 + 4384);
        *(void *)(v3 + 4384) = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        uint64_t v7 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v3 + 4176));
          int v9 = 136315138;
          uint64_t v10 = asStringBool(v8 & 1);
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fired fIsRadioOffTimer while fAirplaneModeStatus is %s", (uint8_t *)&v9, 0xCu);
        }
        *(unsigned char *)(v3 + 4377) = 0;
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101168F00(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101168F14(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4377);
}

uint64_t sub_101168F20(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4305);
}

uint64_t sub_101168F2C()
{
  return 1;
}

uint64_t sub_101168F34()
{
  return 1;
}

void DataServiceController::getConnection_sync(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v7
    || (unsigned __int8 v8 = *(uint64_t **)v7, v9 = *(uint64_t **)(v7 + 8), *(uint64_t **)v7 == v9))
  {
LABEL_13:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    uint64_t v10 = (std::__shared_weak_count *)v8[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v11)
    {
      if (!v10) {
        goto LABEL_9;
      }
LABEL_8:
      sub_10004D2C8(v10);
      goto LABEL_9;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 472))(v11) == a3) {
      break;
    }
    if (v10) {
      goto LABEL_8;
    }
LABEL_9:
    v8 += 2;
    if (v8 == v9) {
      goto LABEL_13;
    }
  }
  *a4 = v11;
  a4[1] = v10;
}

void sub_101169034(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::canActivateConnection_sync(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (*(unsigned char *)(a1 + 312))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    DataServiceController::getConnection_sync(a1, a2, a3, &v6);
    if (v6)
    {
      (*(void (**)(uint64_t, void))(*(void *)v6 + 80))(v6, 0);
    }
    else
    {
      *(_DWORD *)a4 = -3;
      *(void *)(a4 + 8) = "Invalid connection type";
      *(void *)(a4 + 16) = "";
      *(_DWORD *)(a4 + 24) = 0;
      *(unsigned char *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 32) = 2;
      *(void *)(a4 + 44) = 0;
      *(void *)(a4 + 36) = 0;
      *(_DWORD *)(a4 + 52) = 0;
    }
    uint64_t v5 = v7;
    if (v7)
    {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    *(_DWORD *)a4 = -3;
    *(void *)(a4 + 8) = "too early start";
    *(void *)(a4 + 16) = "";
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(_DWORD *)(a4 + 32) = 2;
    *(void *)(a4 + 44) = 0;
    *(void *)(a4 + 36) = 0;
    *(_DWORD *)(a4 + 52) = 0;
  }
}

void sub_10116915C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101169174(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
}

void sub_10116917C(uint64_t a1, int a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10116928C;
  v5[3] = &unk_101A95638;
  int v6 = a2;
  void v5[4] = a1;
  void v5[5] = a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  long long v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v9;
  unsigned __int8 v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_10116928C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 312))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(v1 + 312), *(Registry **)(v1 + 104));
    long long v4 = ServiceMap;
    uint64_t v5 = "16IPCU_CellProfile";
    if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
    {
      int v6 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        uint64_t v5 = (const char *)v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v5;
    uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&buf);
    if (v9)
    {
      uint64_t v11 = v9[3];
      uint64_t v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v13 = 0;
        if (!v11)
        {
LABEL_14:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v10);
          }
          uint64_t v15 = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(v1 + 104));
          int v16 = v15;
          if (v17 < 0)
          {
            __int16 v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v19 = 5381;
            do
            {
              uint64_t v17 = v19;
              unsigned int v20 = *v18++;
              uint64_t v19 = (33 * v19) ^ v20;
            }
            while (v20);
          }
          std::mutex::lock(v15);
          *(void *)&long long buf = v17;
          unsigned int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&buf);
          if (v21)
          {
            uint64_t v23 = v21[3];
            char v22 = (std::__shared_weak_count *)v21[4];
            if (v22)
            {
              atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v16);
              atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v22);
              char v24 = 0;
              if (!v23)
              {
LABEL_41:
                if ((v24 & 1) == 0) {
                  sub_10004D2C8(v22);
                }
                return;
              }
LABEL_25:
              uint64_t v25 = *(std::__shared_weak_count **)(v1 + 112);
              xpc_object_t v31 = v25;
              if (v25) {
                atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              subscriber::makeSimSlotRange();
              if (v31) {
                sub_10004D2C8(v31);
              }
              uint64_t v26 = (unsigned int *)*((void *)&buf + 1);
              uint64_t v27 = (unsigned int *)buf;
              if ((void)buf != *((void *)&buf + 1))
              {
                xpc_object_t v28 = v33;
                while ((v28(*v27) & 1) == 0)
                {
                  if (++v27 == v26)
                  {
                    uint64_t v27 = v26;
                    break;
                  }
                }
                xpc_object_t v29 = (unsigned int *)*((void *)&buf + 1);
LABEL_35:
                while (v27 != v29)
                {
                  (*(void (**)(uint64_t, void, void))(*(void *)v23 + 16))(v23, *v27, *(void *)(a1 + 40));
                  xpc_object_t v30 = v27 + 1;
                  uint64_t v27 = v26;
                  if (v30 != v26)
                  {
                    uint64_t v27 = v30;
                    while ((v28(*v27) & 1) == 0)
                    {
                      if (++v27 == v26)
                      {
                        uint64_t v27 = v26;
                        goto LABEL_35;
                      }
                    }
                  }
                }
              }
              goto LABEL_41;
            }
          }
          else
          {
            uint64_t v23 = 0;
          }
          std::mutex::unlock(v16);
          char v22 = 0;
          char v24 = 1;
          if (!v23) {
            goto LABEL_41;
          }
          goto LABEL_25;
        }
LABEL_13:
        (*(void (**)(uint64_t))(*(void *)v11 + 40))(v11);
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v13 = 1;
    if (!v11) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  long long v14 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "refreshPDPs_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&buf, 0xCu);
  }
}

void sub_1011695A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101169600(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_101169608(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 312))
  {
    if ((a2 & 0x80000000) != 0
      || (uint64_t v4 = *(void *)(a1 + 4136), a2 >= (unint64_t)((*(void *)(a1 + 4144) - v4) >> 4)))
    {
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v5 = (uint64_t *)(v4 + 16 * a2);
      uint64_t v6 = *v5;
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6)
      {
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v6 + 64))(v9);
        *(_OWORD *)a3 = *(_OWORD *)v9;
        if (!v7) {
          return;
        }
LABEL_11:
        sub_10004D2C8(v7);
        return;
      }
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    if (!v7) {
      return;
    }
    goto LABEL_11;
  }
  unsigned int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)&void v9[4] = "getCSIPDPManager";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", v9, 0xCu);
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
}

void sub_101169740(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101169758(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
}

BOOL sub_101169760(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 312))
  {
    if ((a2 & 0x80000000) != 0
      || (uint64_t v3 = *(void *)(a1 + 4136), a2 >= (unint64_t)((*(void *)(a1 + 4144) - v3) >> 4)))
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v4 = (uint64_t *)(v3 + 16 * a2);
      uint64_t v5 = *v4;
      uint64_t v6 = (std::__shared_weak_count *)v4[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v5)
      {
        long long v10 = 0uLL;
        (*(void (**)(long long *__return_ptr))(*(void *)v5 + 64))(&v10);
        uint64_t v7 = v10;
        if ((void)v10) {
          BOOL v2 = (*(unsigned int (**)(void))(*(void *)v10 + 88))(v10) == 1;
        }
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
        if (v7) {
          goto LABEL_11;
        }
      }
    }
    BOOL v2 = 0;
LABEL_11:
    if (v6) {
      sub_10004D2C8(v6);
    }
    return v2;
  }
  unsigned int v8 = *(NSObject **)(a1 + 40);
  BOOL v2 = 0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v10) = 136315138;
    *(void *)((char *)&v10 + 4) = "getPacketInterfaceAvailable";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v10, 0xCu);
    return 0;
  }
  return v2;
}

void sub_1011698E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101169914(uint64_t a1, unsigned int a2)
{
  return sub_101169760(a1 - 56, a2);
}

BOOL sub_10116991C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    *(void *)(a2 + 8) = 7;
    uint64_t v4 = *(char **)a2;
  }
  else
  {
    *(unsigned char *)(a2 + 23) = 7;
    uint64_t v4 = (char *)a2;
  }
  strcpy(v4, "unknown");
  if (*(unsigned char *)(a1 + 312))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 312), *(Registry **)(a1 + 104));
    uint64_t v6 = ServiceMap;
    if (v7 < 0)
    {
      unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v7;
    char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
    if (v11)
    {
      uint64_t v13 = v11[3];
      int v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        if (!v13)
        {
LABEL_27:
          if ((v14 & 1) == 0) {
            sub_10004D2C8(v12);
          }
          return *(unsigned char *)(a1 + 313) != 0;
        }
LABEL_16:
        if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 40))(v13))
        {
          sub_1003F2A04();
          CFPropertyListRef v16 = CFPreferencesCopyValue(@"DisallowCellularDataConnections", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          CFTypeRef cf = v16;
          if (v16) {
            uint64_t v17 = sub_100080934;
          }
          else {
            uint64_t v17 = 0;
          }
          if (v17)
          {
            CFTypeID v18 = CFGetTypeID(v16);
            if (v18 == CFBooleanGetTypeID())
            {
              if (cf)
              {
                CFTypeID v19 = CFGetTypeID(cf);
                if (v19 == CFBooleanGetTypeID()) {
                  CFBooleanRef v20 = (const __CFBoolean *)cf;
                }
                else {
                  CFBooleanRef v20 = 0;
                }
              }
              else
              {
                CFBooleanRef v20 = 0;
              }
              int Value = CFBooleanGetValue(v20);
              v47[0] = 0;
              CFPropertyListRef v23 = CFPreferencesCopyValue(@"DisallowCellularDataConnectionsByWhom", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
              v47[0] = v23;
              if (v23) {
                char v24 = sub_100080934;
              }
              else {
                char v24 = 0;
              }
              if (v24)
              {
                CFTypeID v25 = CFGetTypeID(v23);
                if (v25 == CFStringGetTypeID())
                {
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  uint64_t v26 = *(void *)buf;
                  __p[0] = *(void **)&buf[8];
                  *(void **)((char *)__p + 7) = *(void **)&buf[15];
                  uint8_t v27 = buf[23];
                  if (*(char *)(a2 + 23) < 0) {
                    operator delete(*(void **)a2);
                  }
                  xpc_object_t v28 = __p[0];
                  *(void *)a2 = v26;
                  *(void *)(a2 + 8) = v28;
                  *(void **)(a2 + 15) = *(void **)((char *)__p + 7);
                  *(unsigned char *)(a2 + 23) = v27;
                }
                else
                {
                  xpc_object_t v29 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Read data blocked: wrong type of byWhom stored value", buf, 2u);
                  }
                }
              }
              sub_1000577C4(v47);
              memset(__p, 0, sizeof(__p));
              sub_100058DB0(__p, "unknown");
              CFPropertyListRef v30 = CFPreferencesCopyValue(@"DisallowCellularDataConnectionsTime", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
              uint64_t v42 = v30;
              if (v30) {
                xpc_object_t v31 = sub_100080934;
              }
              else {
                xpc_object_t v31 = 0;
              }
              if (v31)
              {
                CFTypeID v32 = CFGetTypeID(v30);
                if (v32 == CFStringGetTypeID())
                {
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  int v33 = *(void **)buf;
                  v47[0] = *(const void **)&buf[8];
                  *(const void **)((char *)v47 + 7) = *(const void **)&buf[15];
                  uint8_t v34 = buf[23];
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                  __p[0] = v33;
                  __p[1] = (void *)v47[0];
                  *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v47 + 7);
                  HIBYTE(__p[2]) = v34;
                }
                else
                {
                  uint64_t v35 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Read data blocked: wrong type of timeRef stored value", buf, 2u);
                  }
                }
              }
              sub_1000577C4(&v42);
              uint64_t v36 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v37 = "NO";
                if (Value == 1) {
                  uint64_t v37 = "YES";
                }
                if (*(char *)(a2 + 23) >= 0) {
                  uint64_t v38 = (char *)a2;
                }
                else {
                  uint64_t v38 = *(char **)a2;
                }
                *(void *)&uint8_t buf[4] = "readDataBlocked";
                int v39 = __p;
                *(_DWORD *)long long buf = 136315906;
                if (SHIBYTE(__p[2]) < 0) {
                  int v39 = (void **)__p[0];
                }
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v37;
                *(_WORD *)&unsigned char buf[22] = 2082;
                BOOL v44 = v38;
                __int16 v45 = 2082;
                xpc_object_t v46 = v39;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s: Read data blocked: [%s] by %{public}s (%{public}s) in DataBlocked() from com.apple.commcenter", buf, 0x2Au);
              }
              sub_10003E168(buf, (void *)(a1 + 8));
              uint64_t v40 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8])
              {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
                sub_10004D2C8(v40);
              }
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              sub_10003E168(buf, (void *)(a1 + 8));
              operator new();
            }
          }
          sub_1000577C4(&cf);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_27;
    }
    goto LABEL_16;
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "readDataBlocked";
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
  }
  return *(unsigned char *)(a1 + 313) != 0;
}

void sub_101169F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a10);
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_1000577C4((const void **)&a9);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10116A02C(uint64_t a1, uint64_t a2)
{
  return sub_10116991C(a1 - 56, a2);
}

BOOL sub_10116A034(uint64_t a1, uint64_t a2)
{
  return sub_10116991C(a1 - 72, a2);
}

void sub_10116A03C(unint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 104));
  unsigned int v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v17);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_18;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_18;
  }
LABEL_10:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 40))(v15))
  {
    __dst[0] = 0;
    __dst[1] = 0;
    unsigned int v21 = 0;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a3;
      unsigned int v21 = *(void **)(a3 + 16);
    }
    unint64_t v17 = a1;
    char v18 = a2;
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      __p[2] = v21;
    }
    v22[0] = 0;
    v22[1] = 0;
    sub_10003E168(v22, (void *)(a1 + 8));
    operator new();
  }
LABEL_18:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_10116A2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(exception_object);
}

void sub_10116A2EC(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
}

void sub_10116A2F4(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t v42 = *(void *)(a1 + 104);
  v43.i64[0] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v43.i64[0]) {
    sub_10004D2C8((std::__shared_weak_count *)v43.i64[0]);
  }
  uint64_t v7 = v39;
  uint64_t v6 = v40;
  if (v39 != v40)
  {
    unsigned int v8 = v41;
    while ((v41(*v7) & 1) == 0)
    {
      if (++v7 == v40)
      {
        uint64_t v7 = v40;
        break;
      }
    }
    unint64_t v9 = v40;
    if (v7 != v40)
    {
      uint64_t v36 = v4;
      do
      {
        uint64_t v10 = *v7;
        uint64_t v11 = sub_10003B004(*(void *)(v4 + 144), *v7);
        if (*(void *)(*(void *)(v4 + 144) + 16) != v11)
        {
          unsigned int v12 = (int64x2_t *)v11;
          if (*((char *)a3 + 23) < 0)
          {
            sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
          }
          else
          {
            long long __p = *a3;
            uint64_t v38 = *((void *)a3 + 2);
          }
          unint64_t v13 = v12[6].u64[0];
          unint64_t v14 = v12[5].u64[1];
          if (v14 >= v13)
          {
            char v16 = a3;
            unint64_t v17 = v9;
            uint64_t v18 = v12[5].i64[0];
            uint64_t v19 = (uint64_t)(v14 - v18) >> 5;
            unint64_t v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v21 = v13 - v18;
            if (v21 >> 4 > v20) {
              unint64_t v20 = v21 >> 4;
            }
            if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v20;
            }
            __int16 v45 = v12 + 6;
            if (v22) {
              CFPropertyListRef v23 = (char *)sub_1000F5A68((uint64_t)v12[6].i64, v22);
            }
            else {
              CFPropertyListRef v23 = 0;
            }
            char v24 = &v23[32 * v19];
            *char v24 = 0;
            long long v25 = __p;
            *((void *)v24 + 3) = v38;
            *(_OWORD *)(v24 + 8) = v25;
            uint64_t v38 = 0;
            long long __p = 0uLL;
            uint64_t v27 = v12[5].i64[0];
            unint64_t v26 = v12[5].u64[1];
            if (v26 == v27)
            {
              int64x2_t v31 = vdupq_n_s64(v26);
              char v28 = &v23[32 * v19];
              unint64_t v9 = v17;
            }
            else
            {
              char v28 = &v23[32 * v19];
              unint64_t v9 = v17;
              do
              {
                char v29 = *(unsigned char *)(v26 - 32);
                v26 -= 32;
                *(v28 - 32) = v29;
                v28 -= 32;
                long long v30 = *(_OWORD *)(v26 + 8);
                *((void *)v28 + 3) = *(void *)(v26 + 24);
                *(_OWORD *)(v28 + 8) = v30;
                *(void *)(v26 + 16) = 0;
                *(void *)(v26 + 24) = 0;
                *(void *)(v26 + 8) = 0;
              }
              while (v26 != v27);
              int64x2_t v31 = v12[5];
            }
            a3 = v16;
            CFTypeID v32 = v24 + 32;
            v12[5].i64[0] = (uint64_t)v28;
            v12[5].i64[1] = (uint64_t)(v24 + 32);
            int64x2_t v43 = v31;
            uint64_t v33 = v12[6].i64[0];
            v12[6].i64[0] = (uint64_t)&v23[32 * v22];
            uint64_t v44 = v33;
            uint64_t v42 = v31.i64[0];
            sub_100255B70((uint64_t)&v42);
            int v34 = SHIBYTE(v38);
            v12[5].i64[1] = (uint64_t)v32;
            uint64_t v4 = v36;
            if (v34 < 0) {
              operator delete((void *)__p);
            }
          }
          else
          {
            *(unsigned char *)unint64_t v14 = 0;
            long long v15 = __p;
            *(void *)(v14 + 24) = v38;
            *(_OWORD *)(v14 + 8) = v15;
            v12[5].i64[1] = v14 + 32;
          }
          sub_10116A5D8(v4, v10, 1, 0);
        }
        uint64_t v35 = v7 + 1;
        uint64_t v7 = v6;
        if (v35 != v6)
        {
          uint64_t v7 = v35;
          while ((v8(*v7) & 1) == 0)
          {
            if (++v7 == v6)
            {
              uint64_t v7 = v6;
              break;
            }
          }
        }
      }
      while (v7 != v9);
    }
  }
}

void sub_10116A5A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_10116A5D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v538 = a2;
  if (*(unsigned char *)(a1 + 288)) {
    return;
  }
  uint64_t v4 = (uint64_t **)a1;
  if (*(unsigned char *)(a1 + 312))
  {
    uint64_t v8 = *(void *)(a1 + 144);
    if (a2 == 3)
    {
      uint64_t v9 = *(void *)(v8 + 8);
      for (uint64_t i = *(void *)(v8 + 16); v9 != i; v9 += 432)
      {
        uint64_t v12 = *(void *)(v9 + 416);
        uint64_t v11 = *(std::__shared_weak_count **)(v9 + 424);
        if (v11)
        {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v13 = *(unsigned int *)(v12 + 52);
          sub_10004D2C8(v11);
        }
        else
        {
          uint64_t v13 = *(unsigned int *)(v12 + 52);
        }
        sub_10116A5D8(v4, v13, a3, a4);
      }
      return;
    }
    uint64_t v15 = sub_10003B004(v8, a2);
    if (v4[18][2] == v15) {
      return;
    }
    unint64_t v16 = *(void *)(v15 + 88) - *(void *)(v15 + 80);
    if (!v16) {
      return;
    }
    v464 = (uint64_t **)v15;
    if (a4 > 4 || (v16 <= 0x5F ? (BOOL v17 = a3 == 0) : (BOOL v17 = 0), !v17))
    {
      memset(__src, 0, 32);
      sub_100058DB0(&__src[1], "");
      uint64_t v19 = sub_10003B004((uint64_t)v4[18], a2);
      if (v4[18][2] != v19)
      {
        unint64_t v20 = v4;
        uint64_t v21 = *(void *)(v19 + 80);
        uint64_t v22 = *(void *)(v19 + 88);
        CFPropertyListRef v23 = (uint64_t *)(v19 + 80);
        if (v21 != v22)
        {
          char v24 = (long long *)(v21 + 8);
          do
          {
            memset(buf, 0, 32);
            uint64_t v26 = (uint64_t)v24 - 8;
            char v25 = *((unsigned char *)v24 - 8);
            LOBYTE(buf[0]) = v25;
            if (*((char *)v24 + 23) < 0)
            {
              sub_10004FC84(&buf[1], *(void **)v24, *((void *)v24 + 1));
              char v25 = buf[0];
            }
            else
            {
              long long v27 = *v24;
              buf[3] = *((void *)v24 + 2);
              *(_OWORD *)&buf[1] = v27;
            }
            LOBYTE(__src[0]) |= v25;
            std::string::operator=((std::string *)&__src[1], (const std::string *)&buf[1]);
            if (SHIBYTE(buf[3]) < 0) {
              operator delete((void *)buf[1]);
            }
            if (LOBYTE(__src[0])) {
              break;
            }
            v24 += 2;
          }
          while (v26 + 32 != v22);
        }
        sub_1002C0814(v23);
        uint64_t v4 = v20;
      }
      int v28 = LOBYTE(__src[0]);
      __dst[1] = 0;
      __dst[0] = 0;
      v533 = 0;
      if (SHIBYTE(__src[3]) < 0)
      {
        sub_10004FC84(__dst, __src[1], (unint64_t)__src[2]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)&__src[1];
        v533 = __src[3];
      }
      v488 = (os_log_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*v4[6] + 16))(v4[6], a2);
      int v531 = 0;
      __n128 v529 = 0uLL;
      uint64_t v530 = 0;
      uint64_t v527 = 0;
      uint64_t v526 = 0;
      uint64_t v528 = 0;
      v524 = 0;
      v523 = 0;
      unint64_t v525 = 0;
      uint64_t v29 = (uint64_t)v4[19];
      long long v30 = (std::__shared_weak_count *)v464[53];
      buf[0] = v464[52];
      buf[1] = v30;
      if (v30)
      {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100AE4090(v29, (uint64_t)buf, &v531, (char *)&v529, (uint64_t)&v526, (uint64_t *)&v523);
        sub_10004D2C8(v30);
      }
      else
      {
        sub_100AE4090(v29, (uint64_t)buf, &v531, (char *)&v529, (uint64_t)&v526, (uint64_t *)&v523);
      }
      if (*((unsigned char *)v4 + 291))
      {
        *((unsigned char *)v4 + 291) = 0;
        BOOL v449 = 1;
      }
      else
      {
        BOOL v449 = v28 != 0;
      }
      int64x2_t v31 = v488;
      uint64_t v521 = 0;
      uint64_t v520 = 0;
      uint64_t v522 = 0;
      sub_100AE7A2C(&v520, v523, v524, 0x6DB6DB6DB6DB6DB7 * (((char *)v524 - (char *)v523) >> 3));
      uint64_t v463 = 0;
      char v462 = 0;
      char v459 = 0;
      v518 = 0;
      v517 = 0;
      uint64_t v519 = 0;
      v515 = 0;
      v514 = 0;
      uint64_t v516 = 0;
      LODWORD(v541) = 0;
      v467 = v4 + 41;
      v443 = v4 + 367;
      v445 = v4 + 368;
      v447 = v4 + 363;
      v493 = v4;
      while (1)
      {
        unsigned int v32 = v541;
        if ((int)v541 >= 36) {
          break;
        }
        unint64_t v33 = (int)v541 + 1;
        int v34 = v524;
        uint64_t v35 = v523;
        unint64_t v36 = 0x6DB6DB6DB6DB6DB7 * (((char *)v524 - (char *)v523) >> 3);
        if (v36 < v33)
        {
          do
          {
            if ((unint64_t)v34 >= v525)
            {
              uint64_t v37 = 0x6DB6DB6DB6DB6DB7 * (((char *)v34 - (char *)v35) >> 3);
              if ((unint64_t)(v37 + 1) > 0x492492492492492) {
                sub_100AE785C();
              }
              unint64_t v38 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v525 - (void)v35) >> 3);
              uint64_t v39 = 2 * v38;
              if (2 * v38 <= v37 + 1) {
                uint64_t v39 = v37 + 1;
              }
              if (v38 >= 0x249249249249249) {
                unint64_t v40 = 0x492492492492492;
              }
              else {
                unint64_t v40 = v39;
              }
              uint8_t buf[4] = &v525;
              BOOL v41 = (char *)sub_100341ECC((uint64_t)&v525, v40);
              uint64_t v42 = &v41[56 * v37];
              buf[0] = v41;
              buf[1] = v42;
              buf[3] = &v41[56 * v43];
              *(_DWORD *)uint64_t v42 = -8;
              *((void *)v42 + 1) = "";
              *((void *)v42 + 2) = "";
              *((_DWORD *)v42 + 6) = 0;
              v42[28] = 0;
              *((_DWORD *)v42 + 8) = 2;
              *(void *)(v42 + 44) = 0;
              *(void *)(v42 + 36) = 0;
              *((_DWORD *)v42 + 13) = 0;
              uint8_t buf[2] = v42 + 56;
              sub_100AE823C((uint64_t *)&v523, buf);
              int v34 = v524;
              sub_100AE83DC((void **)buf);
            }
            else
            {
              *(_DWORD *)int v34 = -8;
              *((void *)v34 + 1) = "";
              *((void *)v34 + 2) = "";
              *((_DWORD *)v34 + 6) = 0;
              *((unsigned char *)v34 + 28) = 0;
              *((_DWORD *)v34 + 8) = 2;
              *(void *)((char *)v34 + 44) = 0;
              *(void *)((char *)v34 + 36) = 0;
              *((_DWORD *)v34 + 13) = 0;
              int v34 = (long long *)((char *)v34 + 56);
            }
            v524 = v34;
            uint64_t v35 = v523;
            unint64_t v36 = 0x6DB6DB6DB6DB6DB7 * (((char *)v34 - (char *)v523) >> 3);
          }
          while (v36 < v33);
          unsigned int v32 = v541;
        }
        *(void *)v545 = 4294967293;
        v546[0] = 0u;
        *(void *)&v545[8] = "Default new availability";
        *(void *)&v546[0] = "";
        LODWORD(v546[1]) = 2;
        memset((char *)&v546[1] + 4, 0, 20);
        if (v36 <= v32) {
          sub_10015B728();
        }
        uint64_t v44 = (char *)v35 + 56 * v32;
        *(_OWORD *)std::string __str = *(_OWORD *)v44;
        *(_OWORD *)&__str[16] = *((_OWORD *)v44 + 1);
        uint64_t v511 = *((void *)v44 + 4);
        uint64_t v512 = *((void *)v44 + 5);
        __int16 v45 = (std::__shared_weak_count *)*((void *)v44 + 6);
        v513 = v45;
        if (v45) {
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        xpc_object_t v46 = *v464;
        if (v32 >= (unint64_t)(((char *)v464[1] - (char *)*v464) >> 4)) {
          sub_10015B728();
        }
        long long v47 = *(_OWORD *)&v46[2 * v32];
        xpc_object_t v48 = (std::__shared_weak_count *)v46[2 * v32 + 1];
        if (v48) {
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long v479 = v47;
        uint64_t v49 = v47;
        v465 = v48;
        if ((void)v47)
        {
          (*(void (**)(void *__return_ptr, void, void))(*(void *)v47 + 80))(buf, v47, 0);
          *(_OWORD *)v545 = *(_OWORD *)buf;
          v546[0] = *(_OWORD *)&buf[2];
          uint64_t v50 = buf[5];
          uint64_t v51 = (atomic_ullong *)buf[6];
          v546[1] = *(_OWORD *)&buf[4];
          *(void *)&v546[2] = buf[6];
        }
        else
        {
          uint64_t v51 = 0;
          uint64_t v50 = 0;
        }
        if (sub_101187F4C((uint64_t)v545, (uint64_t)__str))
        {
          int v52 = 0;
          if (!v49) {
            goto LABEL_317;
          }
LABEL_181:
          if (v541) {
            goto LABEL_317;
          }
          int v129 = v538;
          int v130 = ((uint64_t (*)(uint64_t **))(*v4)[136])(v4);
          if ((v449 | v52) == 1 && v129 == v130) {
            (*(void (**)(uint64_t *, BOOL))(*v4[530] + 80))(v4[530], *(_DWORD *)v545 == 0);
          }
          v509 = 0;
          *(_OWORD *)v507 = 0u;
          long long v508 = 0u;
          *(_OWORD *)v506 = 0u;
          (*(void (**)(xpc_object_t *__return_ptr, uint64_t, uint64_t))(*(void *)v49 + 80))(v506, v49, 1);
          if (!LODWORD(v506[0]))
          {
            uint64_t v131 = sub_10003B004((uint64_t)v4[18], v129);
            if (v4[18][2] == v131
              || (uint64_t v132 = *(void *)(v131 + 24)) == 0
              || ((*(uint64_t (**)(uint64_t))(*(void *)v132 + 424))(v132) & 1) == 0)
            {
              LODWORD(v506[0]) = -6;
              v506[1] = "Data bearer unavailable";
              *(void *)v507 = "";
              *(_DWORD *)&v507[8] = 0;
              v507[12] = 0;
              long long v508 = 0uLL;
              int v133 = v509;
              v509 = 0;
              if (v133) {
                sub_10004D2C8(v133);
              }
            }
          }
          int v134 = v467;
          uint64_t v135 = *v467;
          if (*v467)
          {
            xpc_object_t v136 = v467;
            do
            {
              int v137 = *(_DWORD *)(v135 + 32);
              BOOL v138 = v137 < v129;
              if (v137 >= v129) {
                int v139 = (uint64_t *)v135;
              }
              else {
                int v139 = (uint64_t *)(v135 + 8);
              }
              if (!v138) {
                xpc_object_t v136 = (void *)v135;
              }
              uint64_t v135 = *v139;
            }
            while (*v139);
            int v134 = v467;
            if (v136 != v467)
            {
              int v134 = v467;
              if (v129 >= *((_DWORD *)v136 + 8))
              {
                int v134 = v136;
                if (sub_101187F4C((uint64_t)(v136 + 5), (uint64_t)v506))
                {
LABEL_315:
                  if (v509) {
                    sub_10004D2C8(v509);
                  }
                  goto LABEL_317;
                }
              }
            }
          }
          __int16 v140 = *v31;
          if (os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "#I Internal event start (any sim): ==>>", (uint8_t *)buf, 2u);
            __int16 v140 = *v31;
          }
          BOOL v141 = os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT);
          if (v134 == v467)
          {
            if (!v141) {
              goto LABEL_210;
            }
            uint64_t v148 = asString();
            LODWORD(buf[0]) = 136315394;
            *(void *)((char *)buf + 4) = v148;
            WORD2(buf[1]) = 2080;
            *(xpc_object_t *)((char *)&buf[1] + 6) = v506[1];
            uint64_t v145 = v140;
            v146 = "#I      Internal event (any sim): new BOOL value = %s(%s)";
            uint32_t v147 = 22;
          }
          else
          {
            if (!v141) {
              goto LABEL_210;
            }
            uint64_t v142 = asString();
            uint64_t v143 = v134[6];
            uint64_t v144 = asString();
            LODWORD(buf[0]) = 136315906;
            *(void *)((char *)buf + 4) = v142;
            WORD2(buf[1]) = 2080;
            *(void *)((char *)&buf[1] + 6) = v143;
            HIWORD(buf[2]) = 2080;
            buf[3] = v144;
            LOWORD(buf[4]) = 2080;
            *(xpc_object_t *)((char *)&buf[4] + 2) = v506[1];
            uint64_t v145 = v140;
            v146 = "#I      Internal event (any sim): old BOOL value = %s(%s) new BOOL value = %s(%s)";
            uint32_t v147 = 42;
          }
          _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, v146, (uint8_t *)buf, v147);
LABEL_210:
          BOOL v149 = v507[12];
          BOOL v150 = *v31;
          BOOL v151 = os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT);
          int v471 = v129;
          if (v149)
          {
            if (v151)
            {
              int v152 = asLetter();
              uint64_t v153 = "";
              if (v508 == 1) {
                uint64_t v153 = "w";
              }
              if (v508) {
                unint64_t v154 = v153;
              }
              else {
                unint64_t v154 = "b";
              }
              if (LODWORD(v506[0])) {
                int v155 = "f";
              }
              else {
                int v155 = "t";
              }
              if (LODWORD(v506[0])) {
                uint64_t v156 = (const char *)asString();
              }
              else {
                uint64_t v156 = "OK";
              }
              xpc_object_t v162 = v506[1];
              uint64_t v163 = *(void *)v507;
              uint64_t v164 = asStringBool(v507[8]);
              uint64_t v165 = asStringBool(v507[9]);
              uint64_t v166 = asStringBool(v507[10]);
              uint64_t v167 = asStringBool(v507[11]);
              LODWORD(buf[0]) = 67111426;
              HIDWORD(buf[0]) = v152;
              LOWORD(buf[1]) = 2080;
              *(void *)((char *)&buf[1] + 2) = v154;
              WORD1(buf[2]) = 2080;
              *(void *)((char *)&buf[2] + 4) = v155;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v156;
              HIWORD(buf[4]) = 2080;
              buf[5] = v162;
              LOWORD(buf[6]) = 2080;
              *(void *)((char *)&buf[6] + 2) = v163;
              WORD1(buf[7]) = 2080;
              *(void *)((char *)&buf[7] + 4) = v164;
              WORD2(buf[8]) = 2080;
              *(void *)((char *)&buf[8] + 6) = v165;
              HIWORD(buf[9]) = 2080;
              buf[10] = v166;
              LOWORD(buf[11]) = 2080;
              *(void *)((char *)&buf[11] + 2) = v167;
              _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I      internal event: %c%s%s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", (uint8_t *)buf, 0x62u);
              uint64_t v4 = v493;
              int64x2_t v31 = v488;
              goto LABEL_242;
            }
LABEL_243:
            uint64_t v171 = *((void *)&v508 + 1);
            uint64_t v172 = v509;
            if (v509) {
              atomic_fetch_add_explicit(&v509->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v171)
            {
              while (1)
              {
                int v173 = *(unsigned __int8 *)(v171 + 28);
                xpc_object_t v174 = *v31;
                BOOL v175 = os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT);
                if (v173)
                {
                  if (v175)
                  {
                    int v176 = asLetter();
                    int v177 = *(_DWORD *)(v171 + 32);
                    char v178 = "";
                    if (v177 == 1) {
                      char v178 = "w";
                    }
                    if (v177) {
                      uint64_t v179 = v178;
                    }
                    else {
                      uint64_t v179 = "b";
                    }
                    uint64_t v180 = "f";
                    if (!*(_DWORD *)v171) {
                      uint64_t v180 = "t";
                    }
                    __pb = v180;
                    v482 = v179;
                    if (*(_DWORD *)v171) {
                      uint64_t v181 = (const char *)asString();
                    }
                    else {
                      uint64_t v181 = "OK";
                    }
                    uint64_t v188 = *(void *)(v171 + 8);
                    uint64_t v189 = *(void *)(v171 + 16);
                    uint64_t v190 = asStringBool(*(unsigned char *)(v171 + 24));
                    uint64_t v191 = asStringBool(*(unsigned char *)(v171 + 25));
                    uint64_t v192 = asStringBool(*(unsigned char *)(v171 + 26));
                    uint64_t v193 = asStringBool(*(unsigned char *)(v171 + 27));
                    LODWORD(buf[0]) = 67111426;
                    HIDWORD(buf[0]) = v176;
                    LOWORD(buf[1]) = 2080;
                    *(void *)((char *)&buf[1] + 2) = v482;
                    WORD1(buf[2]) = 2080;
                    *(void *)((char *)&buf[2] + 4) = __pb;
                    WORD2(buf[3]) = 2080;
                    *(void *)((char *)&buf[3] + 6) = v181;
                    HIWORD(buf[4]) = 2080;
                    buf[5] = v188;
                    LOWORD(buf[6]) = 2080;
                    *(void *)((char *)&buf[6] + 2) = v189;
                    WORD1(buf[7]) = 2080;
                    *(void *)((char *)&buf[7] + 4) = v190;
                    WORD2(buf[8]) = 2080;
                    *(void *)((char *)&buf[8] + 6) = v191;
                    HIWORD(buf[9]) = 2080;
                    buf[10] = v192;
                    LOWORD(buf[11]) = 2080;
                    *(void *)((char *)&buf[11] + 2) = v193;
                    _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "#I      chained:      internal event: %c%s%s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", (uint8_t *)buf, 0x62u);
                    uint64_t v4 = v493;
                    int64x2_t v31 = v488;
                    goto LABEL_277;
                  }
                }
                else if (v175)
                {
                  int v182 = asLetter();
                  int v183 = *(_DWORD *)(v171 + 32);
                  uint64_t v184 = "";
                  if (v183 == 1) {
                    uint64_t v184 = "w";
                  }
                  if (v183) {
                    unint64_t v185 = v184;
                  }
                  else {
                    unint64_t v185 = "b";
                  }
                  if (*(_DWORD *)v171) {
                    uint64_t v186 = "f";
                  }
                  else {
                    uint64_t v186 = "t";
                  }
                  if (*(_DWORD *)v171) {
                    unsigned __int8 v187 = (const char *)asString();
                  }
                  else {
                    unsigned __int8 v187 = "OK";
                  }
                  uint64_t v194 = *(unsigned char **)(v171 + 8);
                  if (v194)
                  {
                    uint64_t v195 = *(void *)(v171 + 16);
                    if (*v194)
                    {
                      uint64_t v196 = "{";
                      uint64_t v197 = "}";
                      goto LABEL_276;
                    }
                  }
                  else
                  {
                    uint64_t v195 = *(void *)(v171 + 16);
                  }
                  uint64_t v197 = "";
                  uint64_t v196 = "";
LABEL_276:
                  LODWORD(buf[0]) = 67110914;
                  HIDWORD(buf[0]) = v182;
                  LOWORD(buf[1]) = 2080;
                  *(void *)((char *)&buf[1] + 2) = v185;
                  WORD1(buf[2]) = 2080;
                  *(void *)((char *)&buf[2] + 4) = v186;
                  WORD2(buf[3]) = 2080;
                  *(void *)((char *)&buf[3] + 6) = v187;
                  HIWORD(buf[4]) = 2080;
                  buf[5] = v196;
                  LOWORD(buf[6]) = 2080;
                  *(void *)((char *)&buf[6] + 2) = v194;
                  WORD1(buf[7]) = 2080;
                  *(void *)((char *)&buf[7] + 4) = v195;
                  WORD2(buf[8]) = 2080;
                  *(void *)((char *)&buf[8] + 6) = v197;
                  _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "#I      chained:      internal event: %c%s%s(%s%s%s %s%s)", (uint8_t *)buf, 0x4Eu);
LABEL_277:
                  int v129 = v471;
                }
                uint64_t v199 = *(void *)(v171 + 40);
                uint64_t v198 = *(std::__shared_weak_count **)(v171 + 48);
                if (v198) {
                  atomic_fetch_add_explicit(&v198->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v172) {
                  sub_10004D2C8(v172);
                }
                uint64_t v172 = v198;
                uint64_t v171 = v199;
                if (!v199)
                {
                  if (v198) {
                    goto LABEL_284;
                  }
                  goto LABEL_285;
                }
              }
            }
            uint64_t v198 = v172;
            if (v172) {
LABEL_284:
            }
              sub_10004D2C8(v198);
LABEL_285:
            uint64_t v200 = (uint64_t **)v467;
            long long v201 = (uint64_t *)*v467;
            uint64_t v202 = (uint64_t **)v467;
            if (*v467)
            {
              do
              {
                while (1)
                {
                  uint64_t v200 = (uint64_t **)v201;
                  int v203 = *((_DWORD *)v201 + 8);
                  if (v203 <= v129) {
                    break;
                  }
                  long long v201 = *v200;
                  uint64_t v202 = v200;
                  if (!*v200) {
                    goto LABEL_293;
                  }
                }
                if (v203 >= v129)
                {
                  uint64_t v206 = (char *)v200;
                  goto LABEL_298;
                }
                long long v201 = v200[1];
              }
              while (v201);
              uint64_t v202 = v200 + 1;
            }
LABEL_293:
            uint64_t v206 = (char *)operator new(0x60uLL);
            *((_DWORD *)v206 + 8) = v129;
            *(_OWORD *)(v206 + 40) = 0u;
            *(_OWORD *)(v206 + 56) = 0u;
            *((void *)v206 + 6) = "";
            *((void *)v206 + 7) = "";
            *((_DWORD *)v206 + 18) = 2;
            *(void *)(v206 + 84) = 0;
            *(void *)(v206 + 76) = 0;
            *((_DWORD *)v206 + 23) = 0;
            *(void *)uint64_t v206 = 0;
            *((void *)v206 + 1) = 0;
            *((void *)v206 + 2) = v200;
            char *v202 = (uint64_t *)v206;
            uint64_t v204 = (uint64_t *)v206;
            uint64_t v205 = (uint64_t *)*v4[40];
            if (v205)
            {
              v4[40] = v205;
              uint64_t v204 = *v202;
            }
            sub_100046C90(v4[41], v204);
            v4[42] = (uint64_t *)((char *)v4[42] + 1);
LABEL_298:
            long long v207 = *(_OWORD *)v507;
            *(_OWORD *)(v206 + 40) = *(_OWORD *)v506;
            *(_OWORD *)(v206 + 56) = v207;
            *((void *)v206 + 9) = v508;
            uint64_t v208 = *((void *)&v508 + 1);
            int v209 = v509;
            if (v509) {
              atomic_fetch_add_explicit(&v509->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v210 = (std::__shared_weak_count *)*((void *)v206 + 11);
            *((void *)v206 + 10) = v208;
            *((void *)v206 + 11) = v209;
            if (v210) {
              sub_10004D2C8(v210);
            }
            buf[0] = 1;
            buf[1] = v447;
            unint64_t v211 = (uint64_t *)LODWORD(v506[0]);
            uint64_t v212 = v445;
            unint64_t v213 = v445;
            uint64_t v214 = *v445;
            if (*v445)
            {
              while (1)
              {
                while (1)
                {
                  unint64_t v213 = (uint64_t **)v214;
                  int v215 = *((_DWORD *)v214 + 7);
                  if (v215 <= v129) {
                    break;
                  }
                  uint64_t v214 = *v213;
                  uint64_t v212 = v213;
                  if (!*v213) {
                    goto LABEL_309;
                  }
                }
                if (v215 >= v129) {
                  break;
                }
                uint64_t v214 = v213[1];
                if (!v214)
                {
                  uint64_t v212 = v213 + 1;
                  goto LABEL_309;
                }
              }
            }
            else
            {
LABEL_309:
              uint64_t v216 = operator new(0x28uLL);
              v216[7] = v129;
              *((void *)v216 + 4) = 0x200000000;
              sub_100046C38(v443, (uint64_t)v213, v212, (uint64_t *)v216);
              unint64_t v213 = (uint64_t **)v216;
            }
            v213[4] = v211;
            int64x2_t v31 = v488;
            int v217 = *v488;
            if (os_log_type_enabled(*v488, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v218 = __dst;
              if (SHIBYTE(v533) < 0) {
                uint64_t v218 = (void **)__dst[0];
              }
              *(_DWORD *)v544 = 136315138;
              *(void *)&v544[4] = v218;
              _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I <<== Internal event end (any sim): due to %s", v544, 0xCu);
            }
            sub_101195C28((uint64_t)buf);
            goto LABEL_315;
          }
          if (!v151) {
            goto LABEL_243;
          }
          int v157 = asLetter();
          uint64_t v158 = "";
          if (v508 == 1) {
            uint64_t v158 = "w";
          }
          if (v508) {
            uint64_t v159 = v158;
          }
          else {
            uint64_t v159 = "b";
          }
          if (LODWORD(v506[0])) {
            uint64_t v160 = "f";
          }
          else {
            uint64_t v160 = "t";
          }
          if (LODWORD(v506[0])) {
            uint64_t v161 = (const char *)asString();
          }
          else {
            uint64_t v161 = "OK";
          }
          if (v506[1])
          {
            uint64_t v168 = *(void *)v507;
            if (*(unsigned char *)v506[1])
            {
              uint64_t v169 = "{";
              uint64_t v170 = "}";
LABEL_241:
              LODWORD(buf[0]) = 67110914;
              HIDWORD(buf[0]) = v157;
              LOWORD(buf[1]) = 2080;
              *(void *)((char *)&buf[1] + 2) = v159;
              WORD1(buf[2]) = 2080;
              *(void *)((char *)&buf[2] + 4) = v160;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v161;
              HIWORD(buf[4]) = 2080;
              buf[5] = v169;
              LOWORD(buf[6]) = 2080;
              *(xpc_object_t *)((char *)&buf[6] + 2) = v506[1];
              WORD1(buf[7]) = 2080;
              *(void *)((char *)&buf[7] + 4) = v168;
              WORD2(buf[8]) = 2080;
              *(void *)((char *)&buf[8] + 6) = v170;
              _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I      internal event: %c%s%s(%s%s%s %s%s)", (uint8_t *)buf, 0x4Eu);
LABEL_242:
              int v129 = v471;
              goto LABEL_243;
            }
          }
          else
          {
            uint64_t v168 = *(void *)v507;
          }
          uint64_t v170 = "";
          uint64_t v169 = "";
          goto LABEL_241;
        }
        unsigned int v53 = v541;
        __int16 v54 = v523;
        if (0x6DB6DB6DB6DB6DB7 * (((char *)v524 - (char *)v523) >> 3) <= (unint64_t)v541) {
          sub_10015B728();
        }
        uint64_t v55 = (char *)v523 + 56 * v541;
        *(_OWORD *)uint64_t v55 = *(_OWORD *)v545;
        *((_OWORD *)v55 + 1) = v546[0];
        *((void *)v55 + 4) = *(void *)&v546[1];
        if (v51) {
          atomic_fetch_add_explicit(v51 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v470 = v49;
        long long __p = (std::__shared_weak_count *)v51;
        *((void *)v55 + 5) = v50;
        __int16 v56 = (char *)v54 + 56 * v53;
        uint64_t v57 = (std::__shared_weak_count *)*((void *)v56 + 6);
        *((void *)v56 + 6) = v51;
        if (v57) {
          sub_10004D2C8(v57);
        }
        int v58 = *(_DWORD *)v545;
        int v59 = *(_DWORD *)__str;
        if (!*(_DWORD *)v545)
        {
          if (*(_DWORD *)__str) {
            int v60 = &v514;
          }
          else {
            int v60 = &v517;
          }
          if (*(_DWORD *)__str) {
            int v61 = &v516;
          }
          else {
            int v61 = &v519;
          }
          char v62 = v60[1];
          unint64_t v63 = (unint64_t)v60[2];
          if ((unint64_t)v62 >= v63)
          {
            uint64_t v65 = ((char *)v62 - (char *)*v60) >> 4;
            unint64_t v66 = v65 + 1;
            if ((unint64_t)(v65 + 1) >> 60) {
              sub_10006A748();
            }
            uint64_t v67 = v63 - (void)*v60;
            if (v67 >> 3 > v66) {
              unint64_t v66 = v67 >> 3;
            }
            if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v68 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v68 = v66;
            }
            uint8_t buf[4] = v61;
            __int16 v69 = (char *)sub_10006A794((uint64_t)v61, v68);
            int v71 = &v69[16 * v65];
            *(_OWORD *)int v71 = v479;
            if (v465) {
              atomic_fetch_add_explicit(&v465->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v73 = *v60;
            char v72 = v60[1];
            if (v72 == *v60)
            {
              long long v76 = v60[1];
              CFTypeRef v74 = &v69[16 * v65];
            }
            else
            {
              CFTypeRef v74 = &v69[16 * v65];
              do
              {
                long long v75 = *((_OWORD *)v72 - 1);
                v72 -= 2;
                *((_OWORD *)v74 - 1) = v75;
                v74 -= 16;
                *char v72 = 0;
                v72[1] = 0;
              }
              while (v72 != v73);
              long long v76 = *v60;
              char v72 = v60[1];
            }
            uint64_t v64 = (uint64_t *)(v71 + 16);
            *int v60 = (uint64_t *)v74;
            v60[1] = (uint64_t *)(v71 + 16);
            uint64_t v77 = v60[2];
            v60[2] = (uint64_t *)&v69[16 * v70];
            uint8_t buf[2] = v72;
            buf[3] = v77;
            buf[1] = v76;
            buf[0] = v76;
            sub_10019E528((uint64_t)buf);
          }
          else
          {
            *(_OWORD *)char v62 = v479;
            if (v465) {
              atomic_fetch_add_explicit(&v465->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v64 = v62 + 2;
          }
          v60[1] = v64;
        }
        BOOL v456 = v58 == 0;
        BOOL v454 = v58 != v59;
        int v78 = v546[1];
        BOOL v452 = LODWORD(v546[1]) != v511;
        uint64_t v79 = *v31;
        BOOL v450 = v59 == 0;
        if ((v459 & 1) == 0 && os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I Internal event start: ==>>", (uint8_t *)buf, 2u);
          uint64_t v79 = *v31;
        }
        int v80 = BYTE12(v546[0]);
        BOOL v81 = os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT);
        if (!v80)
        {
          if (!v81) {
            goto LABEL_137;
          }
          int v86 = asLetter();
          unsigned int v87 = "";
          if (v78 == 1) {
            unsigned int v87 = "w";
          }
          if (v78) {
            __int16 v88 = v87;
          }
          else {
            __int16 v88 = "b";
          }
          if (v58) {
            int v89 = "f";
          }
          else {
            int v89 = "t";
          }
          if (v58) {
            uint64_t v90 = (const char *)asString();
          }
          else {
            uint64_t v90 = "OK";
          }
          if (*(void *)&v545[8])
          {
            uint64_t v97 = *(void *)&v546[0];
            if (**(unsigned char **)&v545[8])
            {
              long long v98 = "{";
              int v99 = "}";
LABEL_136:
              LODWORD(buf[0]) = 67110914;
              HIDWORD(buf[0]) = v86;
              LOWORD(buf[1]) = 2080;
              *(void *)((char *)&buf[1] + 2) = v88;
              WORD1(buf[2]) = 2080;
              *(void *)((char *)&buf[2] + 4) = v89;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v90;
              HIWORD(buf[4]) = 2080;
              buf[5] = v98;
              LOWORD(buf[6]) = 2080;
              *(void *)((char *)&buf[6] + 2) = *(void *)&v545[8];
              WORD1(buf[7]) = 2080;
              *(void *)((char *)&buf[7] + 4) = v97;
              WORD2(buf[8]) = 2080;
              *(void *)((char *)&buf[8] + 6) = v99;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I      internal event: %c%s%s(%s%s%s %s%s)", (uint8_t *)buf, 0x4Eu);
              uint64_t v4 = v493;
              goto LABEL_137;
            }
          }
          else
          {
            uint64_t v97 = *(void *)&v546[0];
          }
          int v99 = "";
          long long v98 = "";
          goto LABEL_136;
        }
        if (v81)
        {
          int v82 = asLetter();
          uint64_t v83 = "";
          if (v78 == 1) {
            uint64_t v83 = "w";
          }
          if (!v78) {
            uint64_t v83 = "b";
          }
          v480 = v83;
          std::string v84 = "f";
          if (!v58) {
            std::string v84 = "t";
          }
          v460 = v84;
          if (v58) {
            char v85 = (const char *)asString();
          }
          else {
            char v85 = "OK";
          }
          uint64_t v92 = *(void *)&v545[8];
          uint64_t v91 = *(void *)&v546[0];
          uint64_t v93 = asStringBool(SBYTE8(v546[0]));
          uint64_t v94 = asStringBool(SBYTE9(v546[0]));
          uint64_t v95 = asStringBool(SBYTE10(v546[0]));
          uint64_t v96 = asStringBool(SBYTE11(v546[0]));
          LODWORD(buf[0]) = 67111426;
          HIDWORD(buf[0]) = v82;
          LOWORD(buf[1]) = 2080;
          *(void *)((char *)&buf[1] + 2) = v480;
          WORD1(buf[2]) = 2080;
          *(void *)((char *)&buf[2] + 4) = v460;
          WORD2(buf[3]) = 2080;
          *(void *)((char *)&buf[3] + 6) = v85;
          HIWORD(buf[4]) = 2080;
          buf[5] = v92;
          LOWORD(buf[6]) = 2080;
          *(void *)((char *)&buf[6] + 2) = v91;
          WORD1(buf[7]) = 2080;
          *(void *)((char *)&buf[7] + 4) = v93;
          WORD2(buf[8]) = 2080;
          *(void *)((char *)&buf[8] + 6) = v94;
          HIWORD(buf[9]) = 2080;
          buf[10] = v95;
          LOWORD(buf[11]) = 2080;
          *(void *)((char *)&buf[11] + 2) = v96;
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I      internal event: %c%s%s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", (uint8_t *)buf, 0x62u);
          uint64_t v4 = v493;
        }
LABEL_137:
        char v100 = v4;
        unint64_t v101 = __p;
        if (__p) {
          atomic_fetch_add_explicit(&__p->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v50)
        {
          while (1)
          {
            int v102 = *(unsigned __int8 *)(v50 + 28);
            unsigned int v103 = *v31;
            BOOL v104 = os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT);
            if (v102)
            {
              if (v104)
              {
                int v105 = asLetter();
                int v106 = *(_DWORD *)(v50 + 32);
                long long v107 = "";
                if (v106 == 1) {
                  long long v107 = "w";
                }
                if (v106) {
                  uint64_t v108 = v107;
                }
                else {
                  uint64_t v108 = "b";
                }
                uint64_t v109 = "f";
                if (!*(_DWORD *)v50) {
                  uint64_t v109 = "t";
                }
                __pa = v109;
                v481 = v108;
                if (*(_DWORD *)v50) {
                  uint64_t v110 = (const char *)asString();
                }
                else {
                  uint64_t v110 = "OK";
                }
                uint64_t v117 = *(void *)(v50 + 8);
                uint64_t v118 = *(void *)(v50 + 16);
                uint64_t v119 = asStringBool(*(unsigned char *)(v50 + 24));
                uint64_t v120 = asStringBool(*(unsigned char *)(v50 + 25));
                uint64_t v121 = asStringBool(*(unsigned char *)(v50 + 26));
                uint64_t v122 = asStringBool(*(unsigned char *)(v50 + 27));
                LODWORD(buf[0]) = 67111426;
                HIDWORD(buf[0]) = v105;
                LOWORD(buf[1]) = 2080;
                *(void *)((char *)&buf[1] + 2) = v481;
                WORD1(buf[2]) = 2080;
                *(void *)((char *)&buf[2] + 4) = __pa;
                WORD2(buf[3]) = 2080;
                *(void *)((char *)&buf[3] + 6) = v110;
                HIWORD(buf[4]) = 2080;
                buf[5] = v117;
                LOWORD(buf[6]) = 2080;
                *(void *)((char *)&buf[6] + 2) = v118;
                WORD1(buf[7]) = 2080;
                *(void *)((char *)&buf[7] + 4) = v119;
                WORD2(buf[8]) = 2080;
                *(void *)((char *)&buf[8] + 6) = v120;
                HIWORD(buf[9]) = 2080;
                buf[10] = v121;
                LOWORD(buf[11]) = 2080;
                *(void *)((char *)&buf[11] + 2) = v122;
                _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I      chained:      internal event: %c%s%s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", (uint8_t *)buf, 0x62u);
                char v100 = v493;
                int64x2_t v31 = v488;
              }
              goto LABEL_171;
            }
            if (v104) {
              break;
            }
LABEL_171:
            uint64_t v128 = *(void *)(v50 + 40);
            uint64_t v127 = *(std::__shared_weak_count **)(v50 + 48);
            if (v127) {
              atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v101) {
              sub_10004D2C8(v101);
            }
            uint64_t v50 = v128;
            unint64_t v101 = v127;
            if (!v128) {
              goto LABEL_178;
            }
          }
          int v111 = asLetter();
          int v112 = *(_DWORD *)(v50 + 32);
          uint64_t v113 = "";
          if (v112 == 1) {
            uint64_t v113 = "w";
          }
          if (v112) {
            uint64_t v114 = v113;
          }
          else {
            uint64_t v114 = "b";
          }
          if (*(_DWORD *)v50) {
            uint64_t v115 = "f";
          }
          else {
            uint64_t v115 = "t";
          }
          if (*(_DWORD *)v50) {
            uint64_t v116 = (const char *)asString();
          }
          else {
            uint64_t v116 = "OK";
          }
          uint64_t v123 = *(unsigned char **)(v50 + 8);
          if (v123)
          {
            uint64_t v124 = *(void *)(v50 + 16);
            if (*v123)
            {
              uint64_t v125 = "{";
              uint64_t v126 = "}";
LABEL_170:
              LODWORD(buf[0]) = 67110914;
              HIDWORD(buf[0]) = v111;
              LOWORD(buf[1]) = 2080;
              *(void *)((char *)&buf[1] + 2) = v114;
              WORD1(buf[2]) = 2080;
              *(void *)((char *)&buf[2] + 4) = v115;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v116;
              HIWORD(buf[4]) = 2080;
              buf[5] = v125;
              LOWORD(buf[6]) = 2080;
              *(void *)((char *)&buf[6] + 2) = v123;
              WORD1(buf[7]) = 2080;
              *(void *)((char *)&buf[7] + 4) = v124;
              WORD2(buf[8]) = 2080;
              *(void *)((char *)&buf[8] + 6) = v126;
              _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I      chained:      internal event: %c%s%s(%s%s%s %s%s)", (uint8_t *)buf, 0x4Eu);
              goto LABEL_171;
            }
          }
          else
          {
            uint64_t v124 = *(void *)(v50 + 16);
          }
          uint64_t v126 = "";
          uint64_t v125 = "";
          goto LABEL_170;
        }
        uint64_t v127 = __p;
LABEL_178:
        v462 |= v454;
        LOBYTE(v463) = v452 | v463;
        int v52 = v456 ^ v450;
        HIDWORD(v463) |= v456 ^ v450;
        if (v127) {
          sub_10004D2C8(v127);
        }
        char v459 = 1;
        uint64_t v49 = v470;
        uint64_t v4 = v100;
        if (v470) {
          goto LABEL_181;
        }
LABEL_317:
        if (v465) {
          sub_10004D2C8(v465);
        }
        if (v513) {
          sub_10004D2C8(v513);
        }
        if (*(void *)&v546[2]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v546[2]);
        }
        inc();
      }
      if (v459)
      {
        uint64_t v219 = *v31;
        if (os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v220 = __dst;
          if (SHIBYTE(v533) < 0) {
            uint64_t v220 = (void **)__dst[0];
          }
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = v220;
          _os_log_impl((void *)&_mh_execute_header, v219, OS_LOG_TYPE_DEFAULT, "#I <<== Internal event end: due to %s", (uint8_t *)buf, 0xCu);
        }
      }
      uint64_t v221 = (uint64_t)v464[52];
      uint64_t v222 = (std::__shared_weak_count *)v464[53];
      if (v222) {
        atomic_fetch_add_explicit(&v222->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v429 = v222;
      uint64_t v223 = sub_101181070(v4[18][1], v4[18][2], v221, v222);
      if (v4[18][2] == v223)
      {
        LOBYTE(v251) = 0;
      }
      else
      {
        uint64_t v483 = v223;
        uint64_t v448 = v221;
        unint64_t v224 = v529.n128_u64[0];
        unint64_t v225 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v529.n128_u64[1] - v529.n128_u64[0]) >> 3);
        if ((int)v225 >= 1)
        {
          uint64_t v226 = 0;
          uint64_t v227 = 0;
          unint64_t v228 = 0;
          do
          {
            if (v225 <= v228) {
              sub_10015B728();
            }
            uint64_t v229 = v4[517];
            if (v228 >= ((char *)v4[518] - (char *)v229) >> 4) {
              goto LABEL_365;
            }
            uint64_t v230 = &v229[v227];
            uint64_t v231 = *v230;
            unint64_t v232 = (std::__shared_weak_count *)v230[1];
            if (v232) {
              atomic_fetch_add_explicit(&v232->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v231)
            {
              v489 = v232;
              int v233 = (*(uint64_t (**)(uint64_t))(*(void *)v231 + 208))(v231);
              int v234 = (*(uint64_t (**)(uint64_t))(*(void *)v231 + 216))(v231);
              if ((v228 & 0x80000000) != 0 || (uint64_t v235 = v493[517], v228 >= ((char *)v493[518] - (char *)v235) >> 4))
              {
                int v239 = 0;
              }
              else
              {
                uint64_t v236 = &v235[v227];
                uint64_t v237 = *v236;
                int v238 = (std::__shared_weak_count *)v236[1];
                if (v238) {
                  atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v237) {
                  int v239 = (*(uint64_t (**)(uint64_t))(*(void *)v237 + 144))(v237);
                }
                else {
                  int v239 = 0;
                }
                if (v238) {
                  sub_10004D2C8(v238);
                }
              }
              int v240 = *(_DWORD *)(v224 + v226);
              if (v240 != v233) {
                *(_DWORD *)(v224 + v226) = v233;
              }
              uint64_t v241 = v224 + v226;
              int v242 = *(_DWORD *)(v224 + v226 + 4);
              if (v242 != v234) {
                *(_DWORD *)(v241 + 4) = v234;
              }
              if (*(unsigned __int8 *)(v241 + 8) != v239)
              {
                *(unsigned char *)(v241 + 8) = v239;
                unint64_t v232 = v489;
LABEL_361:
                int v244 = v493[5];
                if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v245 = asString();
                  int v246 = *(_DWORD *)(v224 + v226);
                  uint64_t v247 = asString();
                  int v248 = *(_DWORD *)(v241 + 4);
                  uint64_t v249 = asStringBool(*(unsigned char *)(v241 + 8));
                  LODWORD(buf[0]) = 136316674;
                  *(void *)((char *)buf + 4) = "updateStateCache_sync";
                  WORD2(buf[1]) = 1024;
                  *(_DWORD *)((char *)&buf[1] + 6) = v228;
                  WORD1(buf[2]) = 2080;
                  *(void *)((char *)&buf[2] + 4) = v245;
                  WORD2(buf[3]) = 1024;
                  *(_DWORD *)((char *)&buf[3] + 6) = v246;
                  WORD1(buf[4]) = 2080;
                  *(void *)((char *)&buf[4] + 4) = v247;
                  WORD2(buf[5]) = 1024;
                  *(_DWORD *)((char *)&buf[5] + 6) = v248;
                  WORD1(buf[6]) = 2080;
                  *(void *)((char *)&buf[6] + 4) = v249;
                  _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_DEFAULT, "#I %s: Context %d: familyActive=%s(%d), familyAvailable=%s(%d), active=%s", (uint8_t *)buf, 0x3Cu);
                  unint64_t v232 = v489;
                }
                goto LABEL_363;
              }
              BOOL v243 = v240 == v233 && v242 == v234;
              unint64_t v232 = v489;
              if (!v243) {
                goto LABEL_361;
              }
            }
LABEL_363:
            uint64_t v4 = v493;
            if (v232) {
              sub_10004D2C8(v232);
            }
LABEL_365:
            ++v228;
            unint64_t v224 = v529.n128_u64[0];
            unint64_t v225 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v529.n128_u64[1] - v529.n128_u64[0]) >> 3);
            v227 += 2;
            v226 += 152;
          }
          while ((uint64_t)v228 < (int)v225);
        }
        unsigned int v250 = *(void **)v483;
        v442 = *(void **)(v483 + 8);
        if (*(void **)v483 != v442)
        {
          int v251 = 0;
          int64x2_t v31 = v488;
          uint64_t v222 = v429;
          uint64_t v252 = v448;
          while (1)
          {
            uint64_t v254 = *v250;
            uint64_t v253 = (std::__shared_weak_count *)v250[1];
            if (v253) {
              atomic_fetch_add_explicit(&v253->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (!v254) {
              goto LABEL_472;
            }
            v490 = v253;
            uint64_t v255 = (*(uint64_t (**)(uint64_t))(*(void *)v254 + 472))(v254);
            uint64_t v256 = v526;
            if (0xCCCCCCCCCCCCCCCDLL * ((v527 - v526) >> 4) <= v255) {
              sub_10015B728();
            }
            v469 = v250;
            int v468 = v251;
            unsigned int v542 = 0;
            unsigned int v542 = ((uint64_t (*)(uint64_t **, void, uint64_t))(*v493)[143])(v493, *(unsigned int *)(v252 + 52), v255);
            if (v542 >= 0xFFFFFFFE) {
              (*(void (**)(uint64_t, unsigned int *))(*(void *)v254 + 328))(v254, &v542);
            }
            int v484 = sub_101178288((uint64_t)v493, *(_DWORD *)(v252 + 52), v255, 0);
            int v257 = sub_101178288((uint64_t)v493, *(_DWORD *)(v252 + 52), v255, 1);
            uint64_t v541 = 4294967294;
            int v540 = 2;
            uint64_t v258 = *(unsigned int *)(v252 + 52);
            buf[1] = 0;
            buf[0] = 0;
            DataServiceController::getConnection_sync((uint64_t)v493, v258, v255, buf);
            uint64_t v259 = buf[0];
            if (buf[0])
            {
              int v260 = v255;
              unsigned int v261 = ((uint64_t (*)(uint64_t **, uint64_t))(*v493)[131])(v493, v258);
              uint64_t v262 = v493[19];
              uint64_t v263 = (os_unfair_lock_s *)(v262 + 3);
              os_unfair_lock_lock((os_unfair_lock_t)v262 + 6);
              LODWORD(v262) = *((unsigned __int8 *)v262 + 84);
              os_unfair_lock_unlock(v263);
              if (v262) {
                uint64_t v264 = v261;
              }
              else {
                uint64_t v264 = 0;
              }
              (*(void (**)(uint64_t, uint64_t *, char *, uint64_t, int *))(*(void *)v259 + 160))(v259, &v541, (char *)&v541 + 4, v264, &v540);
              LODWORD(v541) = sub_1011781EC((uint64_t)v493, v258, v541);
              uint64_t v252 = v448;
              LODWORD(v255) = v260;
            }
            else
            {
              uint64_t v265 = *(NSObject **)(*(uint64_t (**)(uint64_t *, uint64_t))(*v493[6] + 16))(v493[6], v258);
              if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v266 = asString();
                *(_DWORD *)v545 = 136315138;
                *(void *)&v545[4] = v266;
                _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#E getActiveAndIdByConnection: Connection %s not found", v545, 0xCu);
              }
            }
            if (buf[1]) {
              sub_10004D2C8((std::__shared_weak_count *)buf[1]);
            }
            int v267 = sub_101178A88((uint64_t)v493, *(_DWORD *)(v252 + 52), v255);
            ActiveNetworkByConnection_synCC_SHA1_CTX c = DataServiceController::getActiveNetworkByConnection_sync((uint64_t)v493, *(_DWORD *)(v252 + 52), v255);
            int v466 = (*(uint64_t (**)(uint64_t))(*(void *)v254 + 488))(v254);
            memset(v545, 0, sizeof(v545));
            *(void *)&v546[0] = 0;
            (*(void (**)(void *__return_ptr, uint64_t, void, void))(*(void *)v254 + 456))(buf, v254, 0, 0);
            __pCC_SHA1_CTX c = (void *)buf[0];
            unint64_t v269 = buf[1];
            v539[0] = buf[2];
            *(_DWORD *)((char *)v539 + 3) = *(_DWORD *)((char *)&buf[2] + 3);
            unint64_t log = HIBYTE(buf[2]);
            (*(void (**)(void *__return_ptr, uint64_t))(*(void *)v254 + 464))(buf, v254);
            sub_10005CBB4((uint64_t *)v545);
            *(_OWORD *)v545 = *(_OWORD *)buf;
            *(void *)&v546[0] = buf[2];
            memset(buf, 0, 24);
            *(void *)v544 = buf;
            sub_100047F64((void ***)v544);
            uint64_t v270 = v256 + 80 * v255;
            int v271 = *(unsigned __int8 *)(v270 + 4);
            v458 = (BOOL *)(v270 + 4);
            if (v271 != v484) {
              BOOL *v458 = v484;
            }
            uint64_t v272 = v256 + 80 * v255;
            int v273 = *(unsigned __int8 *)(v272 + 5);
            v455 = (BOOL *)(v272 + 5);
            if (v273 != v257) {
              BOOL *v455 = v257;
            }
            BOOL v275 = v271 != v484 || v273 != v257;
            BOOL v485 = v275;
            unsigned int v276 = v542;
            v457 = (unsigned int *)(v256 + 80 * v255);
            unsigned int v439 = *v457;
            if (*v457 != v542) {
              unsigned int *v457 = v542;
            }
            unsigned int v440 = v276;
            uint64_t v277 = v256 + 80 * v255;
            int v279 = *(_DWORD *)(v277 + 8);
            __int16 v278 = (int *)(v277 + 8);
            int v280 = v541;
            int v438 = v279;
            unint64_t v281 = log;
            if (v279 != v541) {
              *__int16 v278 = v541;
            }
            uint64_t v282 = v256 + 80 * v255;
            int v284 = *(unsigned __int8 *)(v282 + 12);
            uint64_t v283 = (BOOL *)(v282 + 12);
            int v285 = BYTE4(v541);
            int v436 = v284;
            if (v284 != BYTE4(v541)) {
              *uint64_t v283 = BYTE4(v541);
            }
            int v437 = v280;
            v444 = v283;
            v446 = v278;
            uint64_t v286 = v256 + 80 * v255;
            int v288 = *(unsigned __int8 *)(v286 + 16);
            uint64_t v287 = (BOOL *)(v286 + 16);
            int v434 = v288;
            int v435 = v285;
            if (v288 != v267) {
              *uint64_t v287 = v267;
            }
            v431 = v287;
            uint64_t v289 = v256 + 80 * v255;
            int v291 = *(unsigned __int8 *)(v289 + 17);
            unint64_t v290 = (BOOL *)(v289 + 17);
            int v433 = v291;
            if (v291 != ActiveNetworkByConnection_sync) {
              *unint64_t v290 = ActiveNetworkByConnection_sync;
            }
            v453 = (int *)(v256 + 80 * v255 + 20);
            int v432 = *v453;
            int v461 = v540;
            if (*v453 != v540) {
              int *v453 = v540;
            }
            if ((log & 0x80) != 0)
            {
              sub_10004FC84(__str, __pc, v269);
              unint64_t v281 = __str[23];
              unint64_t v269 = *(void *)&__str[8];
            }
            else
            {
              *(void *)std::string __str = __pc;
              *(void *)&__str[8] = v269;
              *(_DWORD *)&__str[16] = v539[0];
              *(_DWORD *)&__str[19] = *(_DWORD *)((char *)v539 + 3);
              __str[23] = log;
            }
            unint64_t v292 = (std::string *)(v256 + 80 * v255 + 24);
            uint64_t v293 = *(unsigned __int8 *)(v256 + 80 * v255 + 47);
            if ((v293 & 0x80u) == 0) {
              uint64_t v294 = *(unsigned __int8 *)(v256 + 80 * v255 + 47);
            }
            else {
              uint64_t v294 = *(void *)(v256 + 80 * v255 + 32);
            }
            if ((v281 & 0x80u) == 0) {
              unint64_t v295 = v281;
            }
            else {
              unint64_t v295 = v269;
            }
            uint64_t v472 = v256 + 80 * v255 + 24;
            if (v294 != v295) {
              goto LABEL_425;
            }
            if ((v281 & 0x80u) == 0) {
              int v296 = __str;
            }
            else {
              int v296 = *(unsigned __int8 **)__str;
            }
            if ((v293 & 0x80) != 0)
            {
              int v298 = memcmp(v292->__r_.__value_.__l.__data_, v296, *(void *)(v256 + 80 * v255 + 32));
              unint64_t v292 = (std::string *)(v256 + 80 * v255 + 24);
              if (v298) {
                goto LABEL_425;
              }
            }
            else if (*(unsigned char *)(v256 + 80 * v255 + 47))
            {
              uint64_t v297 = (unsigned __int8 *)(v256 + 80 * v255 + 24);
              while (*v297 == *v296)
              {
                ++v297;
                ++v296;
                if (!--v293) {
                  goto LABEL_432;
                }
              }
LABEL_425:
              std::string::operator=(v292, (const std::string *)__str);
              char v299 = 1;
              if ((__str[23] & 0x80) == 0) {
                goto LABEL_427;
              }
LABEL_426:
              operator delete(*(void **)__str);
              goto LABEL_427;
            }
LABEL_432:
            char v299 = 0;
            if ((v281 & 0x80) != 0) {
              goto LABEL_426;
            }
LABEL_427:
            v506[1] = 0;
            v506[0] = 0;
            *(void *)v507 = 0;
            sub_1000302C0((char *)v506, *(long long **)v545, *(long long **)&v545[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v545[8] - *(void *)v545) >> 3));
            v451 = v290;
            unint64_t v300 = (xpc_object_t *)(v256 + 80 * v255 + 48);
            uint64_t v301 = v256 + 80 * v255;
            uint64_t v302 = *(unsigned __int8 **)(v301 + 56);
            v430 = (std::string **)(v301 + 56);
            unint64_t v303 = (unsigned __int8 *)*v300;
            v304 = (unsigned __int8 *)v506[0];
            v441 = (std::string **)v300;
            if (v302 - (unsigned char *)*v300 == (char *)v506[1] - (char *)v506[0])
            {
              while (1)
              {
                if (v303 == v302)
                {
                  int v305 = v267;
                  char v306 = 0;
                  goto LABEL_439;
                }
                if (!sub_1000609C0((uint64_t)buf, v303, v304)) {
                  break;
                }
                v303 += 24;
                v304 += 24;
              }
              unint64_t v300 = (xpc_object_t *)(v256 + 80 * v255 + 48);
            }
            if (v300 != v506) {
              sub_10005CA3C((uint64_t)v300, (std::string *)v506[0], (long long *)v506[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v506[1] - (char *)v506[0]) >> 3));
            }
            int v305 = v267;
            char v306 = 1;
LABEL_439:
            buf[0] = v506;
            sub_100047F64((void ***)buf);
            uint64_t v307 = v256 + 80 * v255;
            int v309 = *(_DWORD *)(v307 + 72);
            v308 = (_DWORD *)(v307 + 72);
            if (v309 == v466)
            {
              char v310 = v299 | v306;
              if (v438 != v437) {
                char v310 = 1;
              }
              if (v439 != v440) {
                char v310 = 1;
              }
              if (v436 != v435) {
                char v310 = 1;
              }
              if (v434 != v305) {
                char v310 = 1;
              }
              if (v433 != ActiveNetworkByConnection_sync) {
                char v310 = 1;
              }
              if (!((v485 || v432 != v461) | v310 & 1))
              {
                int v311 = 0;
                goto LABEL_464;
              }
            }
            else
            {
              _DWORD *v308 = v466;
            }
            v312 = v493[5];
            if (os_log_type_enabled(v312, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v313 = asString();
              unsigned int v314 = *v457;
              uint64_t v315 = asStringBool(*v458);
              uint64_t v316 = asStringBool(*v455);
              uint64_t v317 = asStringBool(*v431);
              uint64_t v318 = asStringBool(*v451);
              uint64_t v319 = asString();
              LODWORD(buf[0]) = 136316930;
              *(void *)((char *)buf + 4) = "updateStateCache_sync";
              WORD2(buf[1]) = 2080;
              *(void *)((char *)&buf[1] + 6) = v313;
              HIWORD(buf[2]) = 1024;
              LODWORD(buf[3]) = v314;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v315;
              HIWORD(buf[4]) = 2080;
              buf[5] = v316;
              LOWORD(buf[6]) = 2080;
              *(void *)((char *)&buf[6] + 2) = v317;
              WORD1(buf[7]) = 2080;
              *(void *)((char *)&buf[7] + 4) = v318;
              WORD2(buf[8]) = 2080;
              *(void *)((char *)&buf[8] + 6) = v319;
              _os_log_impl((void *)&_mh_execute_header, v312, OS_LOG_TYPE_DEFAULT, "#I %s: %s: idByMask=%d, configuredByMask[BB]=%s, configuredByMask[iW]=%s, activeByMask=%s, networkActive=%s, activeOver=%s", (uint8_t *)buf, 0x4Eu);
              uint64_t v253 = v490;
              v312 = v493[5];
            }
            if (os_log_type_enabled(v312, OS_LOG_TYPE_DEFAULT))
            {
              int v320 = *v446;
              uint64_t v321 = asStringBool(*v444);
              if (*(char *)(v472 + 23) < 0) {
                uint64_t v472 = *(void *)v472;
              }
              sub_100062B40(*v441, *v430, ",", 1uLL, (std::string *)v544);
              int v322 = v544[23];
              v323 = *(unsigned char **)v544;
              uint64_t v324 = asString();
              LODWORD(buf[0]) = 136316418;
              uint64_t v325 = v544;
              if (v322 < 0) {
                uint64_t v325 = v323;
              }
              *(void *)((char *)buf + 4) = "updateStateCache_sync";
              WORD2(buf[1]) = 1024;
              *(_DWORD *)((char *)&buf[1] + 6) = v320;
              WORD1(buf[2]) = 2080;
              *(void *)((char *)&buf[2] + 4) = v321;
              WORD2(buf[3]) = 2080;
              *(void *)((char *)&buf[3] + 6) = v472;
              HIWORD(buf[4]) = 2080;
              buf[5] = v325;
              LOWORD(buf[6]) = 2080;
              *(void *)((char *)&buf[6] + 2) = v324;
              _os_log_impl((void *)&_mh_execute_header, v312, OS_LOG_TYPE_DEFAULT, "#I %s:     activeAndIdByConnection:  id=%d, active=%s, currentInterface=%s/{%s}, transportType=%s", (uint8_t *)buf, 0x3Au);
              uint64_t v222 = v429;
              unsigned int v250 = v469;
              char v326 = log;
              if ((v544[23] & 0x80000000) != 0) {
                operator delete(*(void **)v544);
              }
              int v311 = 1;
              int64x2_t v31 = v488;
              goto LABEL_465;
            }
            int v311 = 1;
LABEL_464:
            int64x2_t v31 = v488;
            uint64_t v222 = v429;
            unsigned int v250 = v469;
            char v326 = log;
LABEL_465:
            if (0x6DB6DB6DB6DB6DB7 * (((char *)v524 - (char *)v523) >> 3) <= (unint64_t)v255) {
              sub_10015B728();
            }
            if (0x6DB6DB6DB6DB6DB7 * ((v521 - v520) >> 3) <= (unint64_t)v255) {
              sub_10015B728();
            }
            uint64_t v327 = 56 * v255;
            int v328 = *(_DWORD *)((char *)v523 + v327);
            if ((v311 | (v328 == 0) ^ (*(_DWORD *)(v520 + v327) == 0)) == 1) {
              (*(void (**)(uint64_t, BOOL, BOOL, void))(*(void *)v254 + 432))(v254, *v451, v328 == 0, 0);
            }
            int v329 = v326;
            buf[0] = v545;
            sub_100047F64((void ***)buf);
            uint64_t v252 = v448;
            if (v329 < 0) {
              operator delete(__pc);
            }
            int v251 = v468 | v485;
LABEL_472:
            uint64_t v4 = v493;
            if (v253) {
              sub_10004D2C8(v253);
            }
            v250 += 2;
            if (v250 == v442) {
              goto LABEL_478;
            }
          }
        }
        LOBYTE(v251) = 0;
        int64x2_t v31 = v488;
        uint64_t v222 = v429;
      }
LABEL_478:
      if (v222) {
        sub_10004D2C8(v222);
      }
      unint64_t v330 = (char *)v464[3];
      if (v330)
      {
        int v331 = (*(uint64_t (**)(char *))(*(void *)&v330[*(void *)(*(void *)v330 - 320)] + 56))(&v330[*(void *)(*(void *)v330 - 320)]);
        if (v531 != v331) {
          int v531 = v331;
        }
      }
      if (v251) {
        sub_10116E640();
      }
      unsigned int v491 = v538;
      uint64_t v332 = (capabilities::ct *)sub_10003B004((uint64_t)v4[18], v538);
      uint64_t v333 = v332;
      if ((capabilities::ct *)v4[18][2] != v332)
      {
        unint64_t v334 = capabilities::ct::supportedPDPContextCount(v332);
        if (HIDWORD(v334)) {
          __assert_rtn("updateDataStatus_sync", "DataServiceController.cpp", 6162, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<unsigned>::max()");
        }
        unsigned int v335 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v334);
        uint64_t v336 = v335;
        if (v335)
        {
          unint64_t v337 = 0;
          uint64_t v338 = 8;
          uint64_t v473 = v335;
          __pd = v333;
          do
          {
            unint64_t v339 = v529.n128_u64[0];
            if (0x86BCA1AF286BCA1BLL * ((uint64_t)(v529.n128_u64[1] - v529.n128_u64[0]) >> 3) <= v337) {
              break;
            }
            if ((v337 & 0x80000000) == 0)
            {
              unint64_t v340 = v493[517];
              if (v337 < ((char *)v493[518] - (char *)v340) >> 4)
              {
                v341 = &v340[2 * v337];
                uint64_t v342 = *v341;
                v343 = (std::__shared_weak_count *)v341[1];
                if (v343) {
                  atomic_fetch_add_explicit(&v343->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v342)
                {
                  long long v549 = 0u;
                  long long v550 = 0u;
                  long long v547 = 0u;
                  long long v548 = 0u;
                  *(_OWORD *)v545 = 0u;
                  memset(v546, 0, sizeof(v546));
                  uint32_t v344 = (atomic_ullong *)*((void *)v333 + 53);
                  v506[0] = *((xpc_object_t *)v333 + 52);
                  v506[1] = v344;
                  if (v344) {
                    atomic_fetch_add_explicit(v344 + 1, 1uLL, memory_order_relaxed);
                  }
                  int v345 = (*(uint64_t (**)(uint64_t, xpc_object_t *, uint8_t *))(*(void *)v342 + 200))(v342, v506, v545);
                  if (v506[1]) {
                    sub_10004D2C8((std::__shared_weak_count *)v506[1]);
                  }
                  unint64_t v346 = v339 + 152 * v337;
                  unsigned int v349 = *(_DWORD *)(v346 + 144);
                  v348 = (_DWORD *)(v346 + 144);
                  uint64_t v347 = v349;
                  if (v349 == v345)
                  {
                    while ((int)v347 >= 1)
                    {
                      uint64_t v350 = *(void *)(v339 + v338 + 8 * v347);
                      uint64_t v351 = *(void *)&v544[8 * v347-- + 24];
                      if (v350 != v351) {
                        goto LABEL_502;
                      }
                    }
                  }
                  else
                  {
LABEL_502:
                    v352 = v493[5];
                    if (os_log_type_enabled(v352, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v354 = *(void *)v545;
                      uint64_t v353 = *(void *)&v545[8];
                      long long v355 = v546[0];
                      uint64_t v486 = *(void *)&v546[1];
                      asStringMask((uint64_t *)__str, *((unint64_t *)&v546[1] + 1));
                      v356 = __str;
                      if (__str[23] < 0) {
                        v356 = *(unsigned char **)__str;
                      }
                      LODWORD(buf[0]) = 67112706;
                      HIDWORD(buf[0]) = v337;
                      LOWORD(buf[1]) = 2048;
                      *(void *)((char *)&buf[1] + 2) = v354;
                      WORD1(buf[2]) = 2048;
                      *(void *)((char *)&buf[2] + 4) = v353;
                      WORD2(buf[3]) = 2048;
                      *(void *)((char *)&buf[3] + 6) = v355;
                      HIWORD(buf[4]) = 2048;
                      buf[5] = *((void *)&v355 + 1);
                      LOWORD(buf[6]) = 2048;
                      *(void *)((char *)&buf[6] + 2) = v486;
                      WORD1(buf[7]) = 2080;
                      *(void *)((char *)&buf[7] + 4) = v356;
                      WORD2(buf[8]) = 2048;
                      *(void *)((char *)&buf[8] + 6) = *((void *)&v546[1] + 1);
                      HIWORD(buf[9]) = 2048;
                      buf[10] = *(void *)&v546[2];
                      LOWORD(buf[11]) = 2048;
                      *(void *)((char *)&buf[11] + 2) = *((void *)&v546[2] + 1);
                      WORD1(buf[12]) = 2048;
                      *(void *)((char *)&buf[12] + 4) = v547;
                      WORD2(buf[13]) = 2048;
                      *(void *)((char *)&buf[13] + 6) = *((void *)&v547 + 1);
                      HIWORD(buf[14]) = 2048;
                      buf[15] = v548;
                      LOWORD(buf[16]) = 2048;
                      *(void *)((char *)&buf[16] + 2) = *((void *)&v548 + 1);
                      WORD1(buf[17]) = 1024;
                      HIDWORD(buf[17]) = v345;
                      _os_log_impl((void *)&_mh_execute_header, v352, OS_LOG_TYPE_DEFAULT, "#I dumpDataStatusIfDifferent: pdp_id=%d  pdp=%lld state=%lld dataAtt=%lld ind=%lld roam=%lld mask=%s(0x%llx) tech=%lld IPf=%lld overrideDP=%lld p9=%lld overrideInd = %lld simSlot = %lld (num=%d)", (uint8_t *)buf, 0x90u);
                      if ((__str[23] & 0x80000000) != 0) {
                        operator delete(*(void **)__str);
                      }
                      uint64_t v336 = v473;
                      uint64_t v333 = __pd;
                    }
                  }
                  v357 = v348 - 32;
                  long long v358 = *(_OWORD *)v545;
                  long long v359 = v546[0];
                  long long v360 = v546[2];
                  v357[2] = v546[1];
                  v357[3] = v360;
                  _OWORD *v357 = v358;
                  v357[1] = v359;
                  long long v361 = v547;
                  long long v362 = v548;
                  long long v363 = v550;
                  v357[6] = v549;
                  v357[7] = v363;
                  v357[4] = v361;
                  v357[5] = v362;
                  _DWORD *v348 = v345;
                  int64x2_t v31 = v488;
                }
                if (v343) {
                  sub_10004D2C8(v343);
                }
              }
            }
            ++v337;
            v338 += 152;
          }
          while (v337 != v336);
        }
      }
      uint64_t v364 = (uint64_t)v493[19];
      unint64_t v365 = (std::__shared_weak_count *)v464[53];
      buf[0] = v464[52];
      buf[1] = v365;
      if (v365) {
        atomic_fetch_add_explicit(&v365->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v366 = v491;
      char v367 = sub_10116E684((uint64_t)v493, v491);
      sub_100AE42A0(v364, (uint64_t)buf, v367);
      if (v365) {
        sub_10004D2C8(v365);
      }
      if (((v449 | v462) | (v463 | BYTE4(v463))))
      {
        memset(buf, 0, sizeof(buf));
        ConnectionAvailabilityContainer::ConnectionAvailabilityContainer();
        *(void *)v545 = 1;
        *(void *)&v545[8] = v493 + 356;
        uint64_t v368 = sub_101195CF0(v493 + 360, v491, &v538);
        memcpy(v368 + 4, buf, 0x120uLL);
        sub_101195C8C((uint64_t)v545);
        if ((v449 | HIDWORD(v463)))
        {
          memset(v545, 0, sizeof(v545));
          *(void *)&v546[0] = 0;
          char v369 = v524;
          uint64_t v370 = v523;
          if (v524 != v523)
          {
            uint64_t v371 = 0;
            unsigned int v372 = 0;
            do
            {
              if (!*((_DWORD *)v370 + 14 * v371))
              {
                uint64_t v373 = kCTDataConnectionServiceTypeFromIndex();
                uint64_t v374 = v373;
                uint64_t v375 = *(void *)&v545[8];
                if (*(void *)&v545[8] >= *(void *)&v546[0])
                {
                  uint64_t v377 = (uint64_t)(*(void *)&v545[8] - *(void *)v545) >> 3;
                  if ((unint64_t)(v377 + 1) >> 61) {
                    sub_10006A748();
                  }
                  unint64_t v378 = (uint64_t)(*(void *)&v546[0] - *(void *)v545) >> 2;
                  if (v378 <= v377 + 1) {
                    unint64_t v378 = v377 + 1;
                  }
                  if (*(void *)&v546[0] - *(void *)v545 >= 0x7FFFFFFFFFFFFFF8uLL) {
                    unint64_t v379 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v379 = v378;
                  }
                  if (v379) {
                    v380 = (char *)sub_10004EF74((uint64_t)v546, v379);
                  }
                  else {
                    v380 = 0;
                  }
                  v381 = (uint64_t *)&v380[8 * v377];
                  uint64_t *v381 = v374;
                  v376 = v381 + 1;
                  v383 = *(char **)v545;
                  uint32_t v382 = *(char **)&v545[8];
                  if (*(void *)&v545[8] != *(void *)v545)
                  {
                    do
                    {
                      uint64_t v384 = *((void *)v382 - 1);
                      v382 -= 8;
                      *--v381 = v384;
                    }
                    while (v382 != v383);
                    uint32_t v382 = *(char **)v545;
                  }
                  *(void *)v545 = v381;
                  *(void *)&v545[8] = v376;
                  *(void *)&v546[0] = &v380[8 * v379];
                  if (v382) {
                    operator delete(v382);
                  }
                }
                else
                {
                  **(void **)&v545[8] = v373;
                  v376 = (void *)(v375 + 8);
                }
                *(void *)&v545[8] = v376;
                char v369 = v524;
                uint64_t v370 = v523;
              }
              uint64_t v371 = ++v372;
            }
            while (0x6DB6DB6DB6DB6DB7 * (((char *)v369 - (char *)v370) >> 3) > (unint64_t)v372);
          }
          uint32_t v385 = v493[5];
          if (os_log_type_enabled(v385, OS_LOG_TYPE_DEFAULT))
          {
            if (SHIBYTE(v533) >= 0) {
              v386 = __dst;
            }
            else {
              v386 = (void **)__dst[0];
            }
            uint64_t v387 = asStringBool(v449);
            uint64_t v388 = asStringBool(v462 & 1);
            uint64_t v389 = asStringBool(v463 & 1);
            uint64_t v390 = asStringBool(v463 & 0x100000000);
            LODWORD(buf[0]) = 136316418;
            *(void *)((char *)buf + 4) = "recalculateConnectionAvailabilityProcessQueue_sync";
            WORD2(buf[1]) = 2080;
            *(void *)((char *)&buf[1] + 6) = v386;
            HIWORD(buf[2]) = 2080;
            buf[3] = v387;
            LOWORD(buf[4]) = 2080;
            *(void *)((char *)&buf[4] + 2) = v388;
            WORD1(buf[5]) = 2080;
            *(void *)((char *)&buf[5] + 4) = v389;
            WORD2(buf[6]) = 2080;
            *(void *)((char *)&buf[6] + 6) = v390;
            _os_log_impl((void *)&_mh_execute_header, v385, OS_LOG_TYPE_DEFAULT, "#I %s: sending CT event due to %s (forceSend %s, errorChanged %s, contextTypeChanged %s, availabilityChanged %s)", (uint8_t *)buf, 0x3Eu);
          }
          int v391 = (capabilities::ct *)((uint64_t (*)(uint64_t **))(*v493)[136])(v493);
          int v392 = v464;
          if (v491 != v391) {
            goto LABEL_617;
          }
          v506[0] = 0;
          xpc_object_t v393 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v394 = v393;
          if (v393)
          {
            v506[0] = v393;
          }
          else
          {
            xpc_object_t v394 = xpc_null_create();
            v506[0] = v394;
            if (!v394)
            {
              xpc_object_t v418 = xpc_null_create();
              xpc_object_t v394 = 0;
              goto LABEL_601;
            }
          }
          if (xpc_get_type(v394) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v394);
LABEL_602:
            xpc_release(v394);
            memset(buf, 0, 24);
            ctu::cf::assign();
            *(void *)v544 = 0;
            CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (Mutable)
            {
              uint64_t v420 = *(void *)v544;
              *(void *)v544 = Mutable;
              *(void *)std::string __str = v420;
              sub_1000440D4((const void **)__str);
            }
            long long v421 = *(const void ***)v545;
            v422 = *(const void ***)&v545[8];
            while (v421 != v422)
              CFArrayAppendValue(*(CFMutableArrayRef *)v544, *v421++);
            xpc_object_t v504 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
            if (!v504) {
              xpc_object_t v504 = xpc_null_create();
            }
            long long v423 = buf;
            if (buf[2] < 0) {
              long long v423 = (void *)buf[0];
            }
            *(void *)std::string __str = v506;
            *(void *)&__str[8] = v423;
            sub_100035E70((uint64_t)__str, &v504, &object);
            xpc_release(object);
            xpc_object_t object = 0;
            xpc_release(v504);
            xpc_object_t v504 = 0;
            xpc_object_t v424 = v506[0];
            *(xpc_object_t *)std::string __str = v506[0];
            if (v506[0])
            {
              xpc_retain(v506[0]);
            }
            else
            {
              xpc_object_t v424 = xpc_null_create();
              *(void *)std::string __str = v424;
            }
            xpc_object_t v425 = xpc_null_create();
            uint64_t v541 = (uint64_t)v425;
            sub_1000452AC(141, (xpc_object_t *)__str, (xpc_object_t *)&v541);
            xpc_release(v425);
            xpc_release(v424);
            sub_1000440D4((const void **)v544);
            if (SHIBYTE(buf[2]) < 0) {
              operator delete((void *)buf[0]);
            }
            xpc_release(v506[0]);
            unsigned int v366 = v538;
LABEL_617:
            v426 = v493[530];
            int v427 = capabilities::ct::supportsCellRadio(v391);
            v502 = 0;
            v501 = 0;
            uint64_t v503 = 0;
            sub_101188034(&v501, *(const void **)v545, *(uint64_t *)&v545[8], (uint64_t)(*(void *)&v545[8] - *(void *)v545) >> 3);
            if (v427) {
              uint64_t v428 = v366;
            }
            else {
              uint64_t v428 = 0;
            }
            (*(void (**)(uint64_t *, uint64_t, void **))(*v426 + 72))(v426, v428, &v501);
            if (v501)
            {
              v502 = v501;
              operator delete(v501);
            }
            if (*(void *)v545)
            {
              *(void *)&v545[8] = *(void *)v545;
              operator delete(*(void **)v545);
            }
            goto LABEL_552;
          }
          xpc_object_t v418 = xpc_null_create();
LABEL_601:
          v506[0] = v418;
          goto LABEL_602;
        }
        unsigned int v395 = *v31;
        if (os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT))
        {
          v396 = __dst;
          if (SHIBYTE(v533) < 0) {
            v396 = (void **)__dst[0];
          }
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = v396;
          _os_log_impl((void *)&_mh_execute_header, v395, OS_LOG_TYPE_DEFAULT, "#I availability not changed due to %s", (uint8_t *)buf, 0xCu);
        }
      }
      int v392 = v464;
LABEL_552:
      uint64_t v397 = (uint64_t)v493[19];
      int v398 = v392[53];
      buf[0] = v392[52];
      buf[1] = v398;
      if (v398) {
        atomic_fetch_add_explicit(v398 + 1, 1uLL, memory_order_relaxed);
      }
      sub_100AE41C4(v397, (uint64_t)buf, v531, &v529, (uint64_t)&v526, (uint64_t)&v523);
      if (buf[1]) {
        sub_10004D2C8((std::__shared_weak_count *)buf[1]);
      }
      memset(v545, 0, sizeof(v545));
      *(void *)&v546[0] = 0;
      int v492 = v366;
      sub_100AE46E0((uint64_t)v493[19], v366, v545);
      int64x2_t v400 = *v392;
      v399 = v392[1];
      if (*v392 != v399)
      {
        do
        {
          uint64_t v402 = *v400;
          unint64_t v401 = (std::__shared_weak_count *)v400[1];
          if (v401) {
            atomic_fetch_add_explicit(&v401->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v402)
          {
            (*(void (**)(uint64_t))(*(void *)v402 + 152))(v402);
            unsigned int v403 = (*(uint64_t (**)(uint64_t))(*(void *)v402 + 472))(v402);
            unsigned int v404 = v403;
            if (0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)&v545[8] - *(void *)v545) >> 3) > v403)
            {
              v405 = (long long *)(*(void *)v545 + 152 * v403);
              (*(void (**)(uint64_t, long long *))(*(void *)v402 + 568))(v402, v405);
              v406 = (os_unfair_lock_s *)v493[19];
              v407 = v464[53];
              buf[0] = v464[52];
              buf[1] = v407;
              if (v407) {
                atomic_fetch_add_explicit(v407 + 1, 1uLL, memory_order_relaxed);
              }
              sub_100AE5CBC((uint64_t)&v494, v405);
              sub_100AE4A54(v406, (uint64_t)buf, v404, &v494);
              sub_10005D9E0((uint64_t)v500, v500[1]);
              sub_10005DBA4(v499);
              if (v498 < 0) {
                operator delete(v497);
              }
              if (v496 < 0) {
                operator delete(v495);
              }
              if (buf[1]) {
                sub_10004D2C8((std::__shared_weak_count *)buf[1]);
              }
            }
          }
          if (v401) {
            sub_10004D2C8(v401);
          }
          v400 += 2;
        }
        while (v400 != v399);
      }
      if (((v449 | v462) | (v463 | BYTE4(v463))))
      {
        if (v493[520])
        {
          memset(buf, 0, 56);
          sub_100AE478C((uint64_t)v493[19], v492, 0x19u, (uint64_t)buf);
          (*(void (**)(void))(*v493[520] + 272))();
          if (buf[6]) {
            sub_10004D2C8((std::__shared_weak_count *)buf[6]);
          }
        }
      }
      long long v408 = v517;
      for (uint64_t j = v518; v408 != j; v408 += 2)
      {
        uint64_t v410 = *v408;
        unint64_t v411 = (std::__shared_weak_count *)v408[1];
        if (v411)
        {
          atomic_fetch_add_explicit(&v411->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v411->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10116E924((uint64_t)v493, v492, 30, 0, v410, v411);
          sub_10004D2C8(v411);
          sub_10004D2C8(v411);
        }
        else
        {
          sub_10116E924((uint64_t)v493, v492, 30, 0, v410, 0);
        }
      }
      v412 = v514;
      for (uint64_t k = v515; v412 != k; v412 += 2)
      {
        uint64_t v415 = *v412;
        v414 = (std::__shared_weak_count *)v412[1];
        if (v414) {
          atomic_fetch_add_explicit(&v414->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v416 = *v488;
        if (os_log_type_enabled(*v488, OS_LOG_TYPE_DEFAULT))
        {
          (*(void (**)(uint64_t))(*(void *)v415 + 472))(v415);
          uint64_t v417 = asString();
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = v417;
          _os_log_impl((void *)&_mh_execute_header, v416, OS_LOG_TYPE_DEFAULT, "#I New connection available: %s", (uint8_t *)buf, 0xCu);
        }
        (*(void (**)(uint64_t))(*(void *)v415 + 592))(v415);
        if (v414)
        {
          atomic_fetch_add_explicit(&v414->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10116E924((uint64_t)v493, v492, 31, 1, v415, v414);
          sub_10004D2C8(v414);
          sub_10004D2C8(v414);
        }
        else
        {
          sub_10116E924((uint64_t)v493, v492, 31, 1, v415, 0);
        }
      }
      buf[0] = v545;
      sub_100AE5AA8((void ***)buf);
      buf[0] = &v514;
      sub_10005CBF0((void ***)buf);
      buf[0] = &v517;
      sub_10005CBF0((void ***)buf);
      buf[0] = &v520;
      sub_1002AC5A8((void ***)buf);
      buf[0] = &v523;
      sub_1002AC5A8((void ***)buf);
      buf[0] = &v526;
      sub_100AE5BF0((void ***)buf);
      if (v529.n128_u64[0])
      {
        v529.n128_u64[1] = v529.n128_u64[0];
        operator delete((void *)v529.n128_u64[0]);
      }
      if (SHIBYTE(v533) < 0) {
        operator delete(__dst[0]);
      }
      if (SHIBYTE(__src[3]) < 0) {
        operator delete(__src[1]);
      }
      return;
    }
    v535[0] = _NSConcreteStackBlock;
    v535[1] = 0x40000000;
    v535[2] = sub_10116E628;
    v535[3] = &unk_101A95678;
    v535[4] = v4;
    int v536 = a2;
    int v537 = a4;
    memset(v545, 0, sizeof(v545));
    sub_10003E168(v545, v4 + 1);
    uint64_t v18 = v4[3];
    buf[0] = _NSConcreteStackBlock;
    buf[1] = 1174405120;
    uint8_t buf[2] = sub_101195718;
    buf[3] = &unk_101A98BF0;
    buf[5] = *(void *)v545;
    buf[6] = *(void *)&v545[8];
    if (*(void *)&v545[8]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v545[8] + 8), 1uLL, memory_order_relaxed);
    }
    uint8_t buf[4] = v535;
    dispatch_async(v18, buf);
    if (buf[6]) {
      sub_10004D2C8((std::__shared_weak_count *)buf[6]);
    }
    if (*(void *)&v545[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v545[8]);
    }
  }
  else
  {
    unint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "recalculateConnectionAvailabilityProcessQueue_sync";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: fDataModuleInitialized is false, bailing for now", (uint8_t *)buf, 0xCu);
    }
  }
}

void sub_10116DCFC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10116E154(uint64_t a1, uint64_t a2, long long *a3)
{
}

void sub_10116E15C(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(void *)(a1 + 112);
  blocuint64_t k = *(void ***)(a1 + 104);
  v51.i64[0] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v51.i64[0]) {
    sub_10004D2C8((std::__shared_weak_count *)v51.i64[0]);
  }
  uint64_t v9 = v47;
  uint64_t v8 = v48;
  if (v47 != v48)
  {
    uint64_t v10 = v49;
    while ((v49(*v9) & 1) == 0)
    {
      if (++v9 == v48)
      {
        uint64_t v9 = v48;
        break;
      }
    }
    uint64_t v11 = v48;
    if (v9 != v48)
    {
      BOOL v41 = (void *)(v6 + 8);
      uint64_t v39 = v48;
      uint64_t v40 = v6;
      do
      {
        uint64_t v12 = *v9;
        uint64_t v13 = sub_10003B004(*(void *)(v6 + 144), *v9);
        if (*(void *)(*(void *)(v6 + 144) + 16) != v13)
        {
          unint64_t v14 = (int64x2_t *)v13;
          LOBYTE(v44) = a3;
          if (*((char *)a4 + 23) < 0)
          {
            sub_10004FC84(&__p, *(void **)a4, *((void *)a4 + 1));
          }
          else
          {
            long long __p = *a4;
            uint64_t v46 = *((void *)a4 + 2);
          }
          unint64_t v15 = v14[6].u64[0];
          unint64_t v16 = v14[5].u64[1];
          if (v16 >= v15)
          {
            uint64_t v18 = a4;
            uint64_t v19 = a3;
            uint64_t v20 = v14[5].i64[0];
            uint64_t v21 = (uint64_t)(v16 - v20) >> 5;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v23 = v15 - v20;
            if (v23 >> 4 > v22) {
              unint64_t v22 = v23 >> 4;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            unsigned int v53 = v14 + 6;
            if (v24) {
              char v25 = (char *)sub_1000F5A68((uint64_t)v14[6].i64, v24);
            }
            else {
              char v25 = 0;
            }
            uint64_t v26 = &v25[32 * v21];
            char *v26 = v44;
            long long v27 = __p;
            *((void *)v26 + 3) = v46;
            *(_OWORD *)(v26 + 8) = v27;
            uint64_t v46 = 0;
            long long __p = 0uLL;
            uint64_t v29 = v14[5].i64[0];
            unint64_t v28 = v14[5].u64[1];
            if (v28 == v29)
            {
              int64x2_t v33 = vdupq_n_s64(v28);
              long long v30 = &v25[32 * v21];
            }
            else
            {
              long long v30 = &v25[32 * v21];
              do
              {
                char v31 = *(unsigned char *)(v28 - 32);
                v28 -= 32;
                *(v30 - 32) = v31;
                v30 -= 32;
                long long v32 = *(_OWORD *)(v28 + 8);
                *((void *)v30 + 3) = *(void *)(v28 + 24);
                *(_OWORD *)(v30 + 8) = v32;
                *(void *)(v28 + 16) = 0;
                *(void *)(v28 + 24) = 0;
                *(void *)(v28 + 8) = 0;
              }
              while (v28 != v29);
              int64x2_t v33 = v14[5];
            }
            int v34 = v26 + 32;
            v14[5].i64[0] = (uint64_t)v30;
            v14[5].i64[1] = (uint64_t)(v26 + 32);
            int64x2_t v51 = v33;
            uint64_t v35 = (void *)v14[6].i64[0];
            v14[6].i64[0] = (uint64_t)&v25[32 * v24];
            int v52 = v35;
            blocuint64_t k = (void **)v33.i64[0];
            sub_100255B70((uint64_t)&block);
            int v36 = SHIBYTE(v46);
            v14[5].i64[1] = (uint64_t)v34;
            a3 = v19;
            a4 = v18;
            uint64_t v11 = v39;
            uint64_t v6 = v40;
            if (v36 < 0)
            {
              operator delete((void *)__p);
              if (!a3)
              {
LABEL_37:
                v42[0] = _NSConcreteStackBlock;
                v42[1] = 0x40000000;
                v42[2] = sub_10116E558;
                v42[3] = &unk_101A95658;
                v42[4] = v6;
                int v43 = v12;
                uint64_t v44 = 0;
                *(void *)&long long __p = 0;
                sub_10003E168(&v44, v41);
                uint64_t v37 = *(NSObject **)(v6 + 24);
                blocuint64_t k = _NSConcreteStackBlock;
                v51.i64[0] = 1174405120;
                v51.i64[1] = (uint64_t)sub_101195718;
                int v52 = &unk_101A98BF0;
                uint64_t v54 = v44;
                uint64_t v55 = (std::__shared_weak_count *)__p;
                if ((void)__p) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(__p + 8), 1uLL, memory_order_relaxed);
                }
                unsigned int v53 = (int64x2_t *)v42;
                dispatch_async(v37, &block);
                if (v55) {
                  sub_10004D2C8(v55);
                }
                if ((void)__p) {
                  sub_10004D2C8((std::__shared_weak_count *)__p);
                }
                goto LABEL_43;
              }
            }
            else if (!a3)
            {
              goto LABEL_37;
            }
          }
          else
          {
            *(unsigned char *)unint64_t v16 = v44;
            long long v17 = __p;
            *(void *)(v16 + 24) = v46;
            *(_OWORD *)(v16 + 8) = v17;
            v14[5].i64[1] = v16 + 32;
            if (!a3) {
              goto LABEL_37;
            }
          }
          sub_10116A5D8(v6, v12, 1, 0);
        }
LABEL_43:
        unint64_t v38 = v9 + 1;
        uint64_t v9 = v8;
        if (v38 != v8)
        {
          uint64_t v9 = v38;
          while ((v10(*v9) & 1) == 0)
          {
            if (++v9 == v8)
            {
              uint64_t v9 = v8;
              break;
            }
          }
        }
      }
      while (v9 != v11);
    }
  }
}

void sub_10116E520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a31) {
    sub_10004D2C8(a31);
  }
  _Unwind_Resume(exception_object);
}

void sub_10116E558(uint64_t a1)
{
}

void sub_10116E570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 16);
  }
  sub_10116E15C(a1, a2, a4, (long long *)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10116E5F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10116E610(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_10116E618(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_10116E620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_10116E628(uint64_t a1)
{
  return sub_10116A5D8(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40), 0, (*(_DWORD *)(a1 + 44) + 1));
}

atomic_uint **sub_10116E640()
{
  sub_100477910(&event::data::connectionConfigChanged[3]);
  uint64_t v0 = (uint64_t *)sub_100161CDC(&event::data::connectionConfigChanged[1]);

  return sub_10035414C(v0);
}

uint64_t sub_10116E684(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v23 = (std::__shared_weak_count *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v23);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_10:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12)
    {
LABEL_7:
      int v14 = 1;
      if (v13) {
        goto LABEL_24;
      }
LABEL_23:
      sub_10004D2C8(v11);
      goto LABEL_24;
    }
    goto LABEL_11;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_7;
  }
LABEL_11:
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  (*(void (**)(std::__shared_weak_count **__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v23, v12, a2);
  unint64_t v15 = v23;
  unint64_t v16 = v24;
  if (v23 == v24)
  {
LABEL_22:
    uint64_t v26 = &v23;
    sub_10005CBF0((void ***)&v26);
    int v14 = 1;
    if (v13) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  while (1)
  {
    uint64_t v18 = v15->__vftable;
    shared_owners = (std::__shared_weak_count *)v15->__shared_owners_;
    if (shared_owners) {
      atomic_fetch_add_explicit(&shared_owners->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (((uint64_t)v18[3].__on_zero_shared_weak & 1) == 0 || !LOBYTE(v18[5].~__shared_weak_count))
    {
      char v19 = 1;
      if (!shared_owners) {
        goto LABEL_20;
      }
LABEL_19:
      sub_10004D2C8(shared_owners);
      goto LABEL_20;
    }
    char v19 = 0;
    LOBYTE(v5) = HIBYTE(v18[4].__on_zero_shared_weak) != 0;
    if (shared_owners) {
      goto LABEL_19;
    }
LABEL_20:
    if ((v19 & 1) == 0) {
      break;
    }
    unint64_t v15 = (std::__shared_weak_count *)((char *)v15 + 16);
    if (v15 == v16) {
      goto LABEL_22;
    }
  }
  uint64_t v26 = &v23;
  sub_10005CBF0((void ***)&v26);
  int v14 = 0;
  if ((v13 & 1) == 0) {
    goto LABEL_23;
  }
LABEL_24:
  if (v14)
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    DataServiceController::getConnection_sync(a1, a2, 0, &v23);
    uint64_t v20 = v23;
    if (v23) {
      LOBYTE(v5) = ((uint64_t (*)(std::__shared_weak_count *))v23->__vftable[14].~__shared_weak_count)(v23);
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (!v20)
    {
      uint64_t v21 = *(std::__shared_weak_count **)(a1 + 112);
      uint64_t v23 = *(std::__shared_weak_count **)(a1 + 104);
      unint64_t v24 = v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LOBYTE(v5) = suspendInternetOnBBCall((Registry **)&v23, a2);
      if (v24) {
        sub_10004D2C8(v24);
      }
    }
  }
  return v5 & 1;
}

void sub_10116E8F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10116E924(uint64_t a1, int a2, int a3, char a4, uint64_t a5, std::__shared_weak_count *a6)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  v8[2] = sub_101177940;
  v8[3] = &unk_101A95938;
  int v10 = a3;
  int v11 = a2;
  char v12 = a4;
  v8[4] = a1;
  v8[5] = a5;
  unsigned int v9 = a6;
  if (a6) {
    atomic_fetch_add_explicit(&a6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  sub_10003E168(&v15, (void *)(a1 + 8));
  uint64_t v7 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v15;
  int v14 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v8;
  dispatch_async(v7, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10116EA58(uint64_t a1, int *a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 1174405120;
  void v4[2] = sub_10116EB70;
  void v4[3] = &unk_101A95698;
  void v4[4] = a1;
  int v5 = *a2;
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_10116EB70(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(a1 + 40);
  int v3 = v4;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *, int *))(*(void *)v1 + 16))(v1, 3, &v4, &v3);
}

uint64_t sub_10116EBD0(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void sub_10116EBE0(uint64_t a1, int *a2)
{
}

void sub_10116EBE8(uint64_t a1, uint64_t a2, WirelessTechnologyList *a3, WirelessTechnologyList *a4)
{
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    WirelessTechnologyList::asString((uint64_t *)v29, a3);
    int v8 = v29[23];
    unsigned int v9 = *(unsigned char **)v29;
    WirelessTechnologyList::asString((uint64_t *)&__p, a4);
    int v10 = v29;
    if (v8 < 0) {
      int v10 = v9;
    }
    if (v28 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136315394;
    long long v32 = v10;
    __int16 v33 = 2080;
    int v34 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I activateController with %s / %s", buf, 0x16u);
    if (v28 < 0) {
      operator delete(__p);
    }
    if ((v29[23] & 0x80000000) != 0) {
      operator delete(*(void **)v29);
    }
  }
  if (!*(unsigned char *)(a1 + 288))
  {
    char v12 = *(std::__shared_weak_count **)(a1 + 112);
    long long __p = *(void **)(a1 + 104);
    long long v27 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    subscriber::makeSimSlotRange();
    if (v27) {
      sub_10004D2C8(v27);
    }
    int v14 = *(int **)v29;
    char v13 = *(int **)&v29[8];
    if (*(void *)v29 != *(void *)&v29[8])
    {
      uint64_t v15 = *(uint64_t (**)(void))&v29[16];
      while ((v15(*v14) & 1) == 0)
      {
        if (++v14 == v13)
        {
          int v14 = v13;
          break;
        }
      }
      unint64_t v16 = *(int **)&v29[8];
LABEL_23:
      while (v14 != v16)
      {
        uint64_t v17 = sub_10003B004(*(void *)(a1 + 144), *v14);
        uint64_t v18 = v17;
        if (*(void *)(*(void *)(a1 + 144) + 16) != v17)
        {
          uint64_t v19 = *(void *)(v17 + 24);
          if (v19) {
            (*(void (**)(uint64_t, void))(*(void *)v19 + 48))(v19, 0);
          }
          uint64_t v20 = *(char **)(v18 + 40);
          if (v20) {
            (*(void (**)(char *, void))(*(void *)&v20[*(void *)(*(void *)v20 - 320)] + 48))(&v20[*(void *)(*(void *)v20 - 320)], 0);
          }
        }
        uint64_t v21 = v14 + 1;
        int v14 = v13;
        if (v21 != v13)
        {
          int v14 = v21;
          while ((v15(*v14) & 1) == 0)
          {
            if (++v14 == v13)
            {
              int v14 = v13;
              goto LABEL_23;
            }
          }
        }
      }
    }
    uint64_t v22 = *(void *)(a1 + 256);
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 40))(v22);
    }
    if (*(unsigned char *)(a1 + 312))
    {
      sub_100058DB0(v24, "DataServiceController activation");
      *(_DWORD *)uint64_t v29 = 3;
      v29[4] = 1;
      if (SHIBYTE(v25) < 0)
      {
        sub_10004FC84(&v29[8], v24[0], (unint64_t)v24[1]);
      }
      else
      {
        *(_OWORD *)&v29[8] = *(_OWORD *)v24;
        uint64_t v30 = v25;
      }
      sub_10011AE40();
      if (SHIBYTE(v30) < 0) {
        operator delete(*(void **)&v29[8]);
      }
      if (SHIBYTE(v25) < 0) {
        operator delete(v24[0]);
      }
    }
    else
    {
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v29 = 136315138;
        *(void *)&v29[4] = "activateController_sync";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: ERR: fDataModuleInitialized is false, bailing for now", v29, 0xCu);
      }
    }
  }
}

void sub_10116EF88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10116EFF0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1144) != 2;
}

BOOL sub_10116F000(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1088) != 2;
}

BOOL sub_10116F010(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1080) != 2;
}

uint64_t sub_10116F020(capabilities::ct *a1, uint64_t a2)
{
  int v4 = (capabilities::ct *)capabilities::ct::supportsHOVirtualInterfaces(a1);
  if (v4) {
    return 1;
  }
  if (capabilities::ct::getRadioModuleType(v4) != 2) {
    return 0;
  }
  if ((*(unsigned int (**)(capabilities::ct *, uint64_t))(*(void *)a1 + 320))(a1, a2)) {
    uint64_t v5 = _os_feature_enabled_impl();
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *((void *)a1 + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    int v8 = 136315394;
    unsigned int v9 = "supportsHOVirtualInterfaces";
    __int16 v10 = 2080;
    uint64_t v11 = asStringBool(v5);
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#D %s: ret = %s", (uint8_t *)&v8, 0x16u);
  }
  return v5;
}

uint64_t sub_10116F160(uint64_t a1, uint64_t a2)
{
  return sub_10116F020((capabilities::ct *)(a1 - 56), a2);
}

uint64_t sub_10116F168(uint64_t a1, uint64_t a2)
{
  return sub_10116F020((capabilities::ct *)(a1 - 64), a2);
}

uint64_t sub_10116F170(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v4) {
    return 0;
  }
  uint64_t v5 = v4;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v18 = 0;
  if (sub_10116991C(a1, (uint64_t)__p))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    int v8 = __p;
    if (v18 < 0) {
      int v8 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    __int16 v21 = 2082;
    uint64_t v22 = v8;
    unsigned int v9 = "#I %s: not available because the Cellular Data is blocked by %{public}s";
    __int16 v10 = v6;
    uint32_t v11 = 22;
    goto LABEL_25;
  }
  uint64_t v12 = *(void *)(a1 + 152);
  char v13 = (os_unfair_lock_s *)(v12 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v12 + 24));
  LODWORD(v12) = *(unsigned __int8 *)(v12 + 84);
  os_unfair_lock_unlock(v13);
  if (!v12)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    unsigned int v9 = "#I %s: not available because the Cellular Data is OFF";
    goto LABEL_24;
  }
  if (!*(void *)(v5 + 24))
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    unsigned int v9 = "#I %s: not available because the Cellular Data Driver is empty";
    goto LABEL_24;
  }
  unsigned __int8 v14 = atomic_load((unsigned __int8 *)(a1 + 4176));
  if (v14)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    unsigned int v9 = "#I %s: not available because the Cellular Data is OFF or Airplane mode (1)";
    goto LABEL_24;
  }
  if (((*(uint64_t (**)(void))(**(void **)(v5 + 24) + 408))(*(void *)(v5 + 24)) & 1) == 0)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    unsigned int v9 = "#I %s: not available because the Cellular Data is OFF or Airplane mode (2)";
    goto LABEL_24;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1048))(a1, a2))
  {
    uint64_t v7 = 1;
    goto LABEL_26;
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  uint64_t v7 = 0;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "cellularDataAvailableForActivationByExternOptions_sync";
    unsigned int v9 = "#I %s: not available because of the Cellular Data roaming status";
LABEL_24:
    __int16 v10 = v15;
    uint32_t v11 = 12;
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
    uint64_t v7 = 0;
  }
LABEL_26:
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_10116F4B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10116F4D0(uint64_t a1, int a2, int a3, const void **a4)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  v8[2] = sub_10116F604;
  v8[3] = &unk_101A956C8;
  v8[4] = a1;
  uint64_t v5 = (void *)(a1 + 8);
  int v10 = a2;
  int v11 = a3;
  sub_100058198(&v9, a4);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, v5);
  uint64_t v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v14;
  char v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v8;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  return sub_100057D78(&v9);
}

void sub_10116F604(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  DataServiceController::getConnection_sync(v2, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), &v5);
  uint64_t v3 = v5;
  if (v5)
  {
    sub_100058198(&v4, (const void **)(a1 + 40));
    (*(void (**)(uint64_t, const void **))(*(void *)v3 + 64))(v3, &v4);
    sub_100057D78(&v4);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_10116F694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

const void **sub_10116F6B4(uint64_t a1, int a2, int a3, const void **a4)
{
  return sub_10116F4D0(a1 - 56, a2, a3, a4);
}

void sub_10116F6BC(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4, int a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 104));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  int v66 = a5;
  if (v15)
  {
    uint64_t v16 = v15[3];
    uint64_t v17 = (std::__shared_weak_count *)v15[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v18 = 0;
      if (!v16) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v17 = 0;
  char v18 = 1;
  if (!v16)
  {
LABEL_7:
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "recalculateInHome_sync";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E %s: roaming interface not found!", buf, 0xCu);
    }
    goto LABEL_60;
  }
LABEL_11:
  uint64_t v64 = v17;
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1032))(a1, a2);
  unint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v16 + 16))(v16, a2);
  unsigned int v21 = a2;
  unint64_t v22 = v20;
  char v65 = v18;
  unsigned int v67 = v21;
  unint64_t v23 = HIDWORD(v20);
  unint64_t v63 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  unint64_t v24 = *v63;
  if (os_log_type_enabled(*v63, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v62 = asStringBool();
    uint64_t v25 = asStringBool(v22 != 0);
    unint64_t v23 = asString();
    uint64_t v26 = asStringBool(a4);
    uint64_t v27 = asStringBool(v68 != 0);
    uint64_t v28 = asString();
    *(_DWORD *)long long buf = 136316418;
    *(void *)&uint8_t buf[4] = v62;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v25;
    __int16 v70 = 2080;
    uint64_t v71 = v23;
    __int16 v72 = 2080;
    uint64_t v73 = v26;
    __int16 v74 = 2080;
    uint64_t v75 = v27;
    __int16 v76 = 2080;
    uint64_t v77 = v28;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I (change states) inHomeCountry: value=%s; actual=%s; data mode=%s (force=%s, old value=%s, old data mode=%s)",
      buf,
      0x3Eu);
    LODWORD(v23) = HIDWORD(v22);
  }
  char v29 = v22 != v68 || a4;
  if ((v29 & 1) != 0 || v23 != HIDWORD(v68))
  {
    uint64_t v31 = sub_10003B004(*(void *)(a1 + 144), v67);
    long long v32 = (void *)v31;
    if (*(void *)(*(void *)(a1 + 144) + 16) == v31)
    {
      BOOL v30 = 0;
    }
    else
    {
      if (!sub_101170698(*(_DWORD *)(v31 + 128), v23)) {
        operator new();
      }
      __int16 v33 = (std::__shared_weak_count *)v32[18];
      v32[17] = 0;
      v32[18] = 0;
      if (v33) {
        sub_10004D2C8(v33);
      }
      uint64_t v34 = *(void *)(a1 + 152);
      uint64_t v35 = v32[53];
      *(void *)long long buf = v32[52];
      *(void *)&uint8_t buf[8] = v35;
      if (v35) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
      }
      BOOL v36 = sub_100AE5338(v34, (uint64_t)buf, v22 != 0, v23);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v36)
      {
        uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v67);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = asStringBool(v22 != 0);
          uint64_t v39 = asString();
          uint64_t v40 = asString();
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v39;
          __int16 v70 = 2080;
          uint64_t v71 = v40;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I (change states) inHome changed: %s (dataMode %s, rawDataMode %s)", buf, 0x20u);
        }
        BOOL v30 = 1;
      }
      else
      {
        BOOL v30 = 0;
      }
      BOOL v41 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v67);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v42 = asStringBool(v22 != 0);
        uint64_t v43 = asString();
        uint64_t v44 = asString();
        uint64_t v45 = asStringBool(v30);
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = v42;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v43;
        __int16 v70 = 2080;
        uint64_t v71 = v44;
        __int16 v72 = 2080;
        uint64_t v73 = v45;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I (change states) updateInHome_sync: %s (dataMode %s, rawDataMode %s) ret=%s", buf, 0x2Au);
      }
    }
    (*(void (**)(uint64_t, void, BOOL))(*(void *)a1 + 2088))(a1, v67, v22 != 0);
    char v46 = v29 ^ 1;
    if (!(_BYTE)v22) {
      char v46 = 1;
    }
    if ((v46 & 1) == 0) {
      (*(void (**)(uint64_t, void))(*(void *)a1 + 2112))(a1, v67);
    }
  }
  else
  {
    BOOL v30 = 0;
  }
  if (!v30)
  {
    if (v66)
    {
      uint64_t v47 = sub_10003B004(*(void *)(a1 + 144), v67);
      uint64_t v48 = v47;
      if (*(void *)(*(void *)(a1 + 144) + 16) != v47)
      {
        uint64_t v49 = *(void *)(v47 + 136);
        if (v49)
        {
          if (sub_101170698(*(_DWORD *)(v47 + 128), *(_DWORD *)(v49 + 4)))
          {
            uint64_t v50 = *(void *)(a1 + 152);
            uint64_t v51 = *(void *)(v48 + 424);
            *(void *)long long buf = *(void *)(v48 + 416);
            *(void *)&uint8_t buf[8] = v51;
            if (v51) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
            }
            BOOL v52 = sub_100AE5338(v50, (uint64_t)buf, **(unsigned char **)(v48 + 136), *(_DWORD *)(*(void *)(v48 + 136) + 4));
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            if (v52)
            {
              unsigned int v53 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v67);
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v54 = asStringBool(**(unsigned char **)(v48 + 136));
                uint64_t v55 = asString();
                *(_DWORD *)long long buf = 136315394;
                *(void *)&uint8_t buf[4] = v54;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v55;
                _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I (change states) inHome changed on dataMode event: %s (dataMode %s)", buf, 0x16u);
              }
              (*(void (**)(uint64_t, void, void))(*(void *)a1 + 2088))(a1, v67, **(unsigned __int8 **)(v48 + 136));
            }
            __int16 v56 = *(std::__shared_weak_count **)(v48 + 144);
            *(void *)(v48 + 136) = 0;
            *(void *)(v48 + 144) = 0;
            if (v56) {
              sub_10004D2C8(v56);
            }
          }
        }
      }
    }
  }
  int v57 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 1040))(a1, v67);
  BOOL v58 = v57;
  char v18 = v65;
  uint64_t v17 = v64;
  if (v57 != v68)
  {
    int v59 = *v63;
    if (os_log_type_enabled(*v63, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v60 = asStringBool(v68 != 0);
      uint64_t v61 = asStringBool(v58);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v60;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v61;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I (change states) inHomeCountry something changed: old value=%s, new value=%s", buf, 0x16u);
    }
    sub_100058DB0(buf, "Internation Roaming state changed");
    (*(void (**)(uint64_t, void, unsigned char *, void))(*(void *)a1 + 2328))(a1, v67, buf, 0);
    if (SHIBYTE(v70) < 0) {
      operator delete(*(void **)buf);
    }
  }
LABEL_60:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_10116FF80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, int a12, char a13, uint64_t a14, uint64_t a15, void *__p, std::__shared_weak_count *a17, int a18, __int16 a19, char a20,char a21)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_101170020(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v5)
  {
    uint64_t v17 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Empty model of SIM slot", v18, 2u);
    }
  }
  else
  {
    uint64_t v7 = *(void **)(v5 + 56);
    for (uint64_t i = *(void **)(v5 + 64); v7 != i; v7 += 2)
    {
      *(void *)char v18 = 0;
      uint64_t v19 = 0;
      (*(void (**)(uint8_t *__return_ptr))(*(void *)*v7 + 464))(v18);
      if (*(void *)v18)
      {
        if (*(_DWORD *)(*(void *)v18 + 168) != *(_DWORD *)(*(void *)v18 + 172))
        {
          int v8 = (*(uint64_t (**)(void))(*(void *)*v7 + 1048))(*v7);
          if (v8 != *(_DWORD *)(*(void *)v18 + 168))
          {
            char v9 = 0;
            uint64_t v10 = 0;
            *(void *)long long buf = &_mh_execute_header;
            do
            {
              uint64_t v11 = *(unsigned int *)&buf[4 * v10];
              char v12 = v9;
              if ((*(uint64_t (**)(void, uint64_t))(*(void *)*v7 + 784))(*v7, v11))
              {
                if ((*(unsigned int (**)(void, uint64_t))(*(void *)*v7 + 56))(*v7, v11)
                  && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1456))(a1, a2) & 1) != 0)
                {
                  break;
                }
                (*(void (**)(void, uint64_t, uint64_t, const char *, const char *))(*(void *)*v7 + 728))(*v7, v11, 37, "inHomeCountry changed", "CommCenter");
              }
              char v9 = 1;
              uint64_t v10 = 1;
            }
            while ((v12 & 1) == 0);
          }
        }
      }
      else
      {
        uint64_t v13 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
        {
          uint64_t v14 = *v7;
          uint64_t v15 = (std::__shared_weak_count *)v7[1];
          if (v15) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v16 = "nothing";
          if (v14) {
            uint64_t v16 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 48))(v14, 2);
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Empty APNInfo of settings: %s", buf, 0xCu);
          if (v15) {
            sub_10004D2C8(v15);
          }
        }
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
    }
  }
}

void sub_1011703A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011703E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 112);
  long long __p = *(void **)(a1 + 104);
  unint64_t v22 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v7 = v24;
  uint64_t v6 = v25;
  if (v24 != v25)
  {
    int v8 = v26;
    while ((v26(*v7) & 1) == 0)
    {
      if (++v7 == v25)
      {
        uint64_t v7 = v25;
        break;
      }
    }
    unint64_t v20 = v25;
    if (v7 != v25)
    {
      uint64_t v19 = v4;
      do
      {
        uint64_t v9 = *v7;
        uint64_t v10 = sub_10003B004(*(void *)(v4 + 144), *v7);
        if (*(void *)(*(void *)(v4 + 144) + 16) != v10)
        {
          uint64_t v11 = v10;
          uint64_t v13 = *(uint64_t **)v10;
          char v12 = *(uint64_t **)(v10 + 8);
          while (v13 != v12)
          {
            uint64_t v14 = *v13;
            uint64_t v15 = (std::__shared_weak_count *)v13[1];
            if (v15) {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v14) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 256))(v14, a3);
            }
            if (v15) {
              sub_10004D2C8(v15);
            }
            v13 += 2;
          }
          sub_100058DB0(&__p, "inHomeCountryUpdate");
          uint64_t v4 = v19;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t))(*(void *)v19 + 2072))(v19, v9, 1, &__p, 25);
          if (v23 < 0) {
            operator delete(__p);
          }
          uint64_t v16 = *(char **)(v11 + 24);
          if (v16) {
            (*(void (**)(char *))(*(void *)&v16[*(void *)(*(void *)v16 - 320)] + 128))(&v16[*(void *)(*(void *)v16 - 320)]);
          }
          uint64_t v17 = *(char **)(v11 + 40);
          if (v17) {
            (*(void (**)(char *))(*(void *)&v17[*(void *)(*(void *)v17 - 320)] + 128))(&v17[*(void *)(*(void *)v17 - 320)]);
          }
        }
        char v18 = v7 + 1;
        uint64_t v7 = v6;
        if (v18 != v6)
        {
          uint64_t v7 = v18;
          while ((v8(*v7) & 1) == 0)
          {
            if (++v7 == v6)
            {
              uint64_t v7 = v6;
              break;
            }
          }
        }
      }
      while (v7 != v20);
    }
  }
}

void sub_101170658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101170698(int a1, int a2)
{
  uint64_t result = 1;
  if (a2 >= 1 && a1 >= 1 && a1 != a2)
  {
    int v4 = isCdmaDataMode();
    return v4 ^ isCdmaDataMode() ^ 1;
  }
  return result;
}

void sub_1011706F8(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v7)
  {
    int v8 = *(uint64_t **)v7;
    uint64_t v9 = *(uint64_t **)(v7 + 8);
    if (*(uint64_t **)v7 != v9)
    {
      while (1)
      {
        uint64_t v11 = *v8;
        uint64_t v10 = (std::__shared_weak_count *)v8[1];
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v11) {
          break;
        }
        int v12 = 3;
        if (v10) {
          goto LABEL_10;
        }
LABEL_11:
        if (v12 == 3 || !v12)
        {
          v8 += 2;
          if (v8 != v9) {
            continue;
          }
        }
        return;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 472))(v11) == a4)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)v11 + 520))(v11, a3, 1, 0, 0);
        int v12 = 2;
        if (!v10) {
          goto LABEL_11;
        }
      }
      else
      {
        int v12 = 0;
        if (!v10) {
          goto LABEL_11;
        }
      }
LABEL_10:
      sub_10004D2C8(v10);
      goto LABEL_11;
    }
  }
}

void sub_101170830(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::reactivateAsserted_sync(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a1 + 112);
  *(void *)long long buf = *(void *)(a1 + 104);
  *(void *)&uint8_t buf[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v7 = v40;
  uint64_t v6 = v41;
  if (v40 != v41)
  {
    uint64_t v34 = v4;
    int v8 = v42;
    while ((v42(*v7) & 1) == 0)
    {
      if (++v7 == v41)
      {
        uint64_t v7 = v41;
        break;
      }
    }
    __int16 v33 = v41;
    if (v7 != v41)
    {
      uint64_t v31 = v42;
      long long v32 = v41;
      do
      {
        uint64_t v35 = sub_10003B004(*(void *)(v4 + 144), *v7);
        uint64_t v9 = *(void *)(*(void *)(v4 + 144) + 16);
        uint64_t v4 = v34;
        if (v9 != v35)
        {
          uint64_t v10 = *(NSObject **)(v34 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = asStringConnectionStateChangeReason();
            uint64_t v12 = asStringBool(a4);
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = "reactivateAsserted_sync";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v11;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v48 = v12;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s:  due to %s force=%s", buf, 0x20u);
            uint64_t v4 = v34;
          }
          *(void *)long long buf = buf;
          *(void *)&uint8_t buf[8] = buf;
          *(void *)&uint8_t buf[16] = 0;
          uint64_t v14 = *(uint64_t **)v35;
          uint64_t v13 = *(uint64_t **)(v35 + 8);
          if (*(uint64_t **)v35 != v13)
          {
            while (1)
            {
              uint64_t v15 = *v14;
              uint64_t v16 = (std::__shared_weak_count *)v14[1];
              if (v16) {
                atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (!v15) {
                goto LABEL_44;
              }
              *(_DWORD *)uint64_t v43 = 0;
              unsigned int v39 = 0;
              if (!(*(unsigned int (**)(uint64_t, uint8_t *, unsigned int *, BOOL))(*(void *)v15 + 216))(v15, v43, &v39, a4))goto LABEL_44; {
              uint64_t v17 = *(uint64_t **)v35;
              }
              char v18 = *(uint64_t **)(v35 + 8);
              if (*(uint64_t **)v35 == v18)
              {
LABEL_40:
                if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 224))(v15))
                {
                  char v23 = operator new(0x20uLL);
                  _DWORD v23[2] = v15;
                  v23[3] = v16;
                  if (v16) {
                    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  uint64_t v24 = *(void *)buf;
                  *char v23 = *(void *)buf;
                  v23[1] = buf;
                  *(void *)(v24 + 8) = v23;
                  *(void *)long long buf = v23;
                  ++*(void *)&buf[16];
                }
                goto LABEL_44;
              }
              char v19 = 0;
              do
              {
                uint64_t v20 = *v17;
                unsigned int v21 = (std::__shared_weak_count *)v17[1];
                if (v21) {
                  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v20)
                {
                  if (v15 == v20
                    || (unsigned int v37 = 0,
                        int v38 = -1,
                        !(*(unsigned int (**)(uint64_t, int *, unsigned int *, BOOL))(*(void *)v20 + 216))(v20, &v38, &v37, a4))|| *(_DWORD *)v43 != v38|| v39 <= v37)
                  {
                    int v22 = 0;
                    if (!v21) {
                      goto LABEL_33;
                    }
LABEL_32:
                    sub_10004D2C8(v21);
                    goto LABEL_33;
                  }
                  int v22 = 10;
                  char v19 = 1;
                  if (v21) {
                    goto LABEL_32;
                  }
                }
                else
                {
                  int v22 = 11;
                  if (v21) {
                    goto LABEL_32;
                  }
                }
LABEL_33:
                if (v22 != 11 && v22) {
                  break;
                }
                v17 += 2;
              }
              while (v17 != v18);
              uint64_t v4 = v34;
              if ((v19 & 1) == 0) {
                goto LABEL_40;
              }
LABEL_44:
              if (v16) {
                sub_10004D2C8(v16);
              }
              v14 += 2;
              if (v14 == v13)
              {
                for (uint64_t i = *(void *)&buf[8]; (unsigned char *)i != buf; uint64_t i = *(void *)(i + 8))
                {
                  uint64_t v26 = *(void *)(i + 16);
                  uint64_t v27 = *(std::__shared_weak_count **)(i + 24);
                  if (v27) {
                    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  uint64_t v28 = *(NSObject **)(v4 + 40);
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 56))(v26);
                    *(_DWORD *)uint64_t v43 = 136315394;
                    uint64_t v44 = "reactivateAsserted_sync";
                    __int16 v45 = 2080;
                    uint64_t v46 = v29;
                    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: trying to reactivate %s", v43, 0x16u);
                  }
                  (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v26 + 88))(v26, "reactivate asserted", "CommCenter", 0, 0);
                  if (v27) {
                    sub_10004D2C8(v27);
                  }
                }
                break;
              }
            }
          }
          sub_10011A838((uint64_t *)buf);
          int v8 = v31;
          uint64_t v6 = v32;
        }
        BOOL v30 = v7 + 1;
        uint64_t v7 = v6;
        if (v30 != v6)
        {
          uint64_t v7 = v30;
          while ((v8(*v7) & 1) == 0)
          {
            if (++v7 == v6)
            {
              uint64_t v7 = v6;
              break;
            }
          }
          uint64_t v4 = v34;
        }
      }
      while (v7 != v33);
    }
  }
}

void sub_101170D08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 - 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101170D64(uint64_t a1, uint64_t a2, int a3, int a4, void *a5, uint64_t a6)
{
  if (a4 >= 36)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "Wrong connectionType";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataServiceController.cpp";
      __int16 v19 = 1024;
      int v20 = 2725;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT connectionType < kDataConnectionTotal\n %s\n at %s:%d\n**********", buf, 0x1Cu);
    }
    __TUAssertTrigger();
  }
  if (*a5
    && (*(unsigned int (**)(void))(*(void *)(*a5 + *(void *)(*(void *)*a5 - 56)) + 24))(*a5 + *(void *)(*(void *)*a5 - 56)) != a3)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "Wrong simSlot";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataServiceController.cpp";
      __int16 v19 = 1024;
      int v20 = 2726;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT (!dataSettings || dataSettings->simSlot() == simSlot)\n %s\n at %s:%d\n**********", buf, 0x1Cu);
    }
    if (*a5
      && (*(unsigned int (**)(void))(*(void *)(*a5 + *(void *)(*(void *)*a5 - 56)) + 24))(*a5 + *(void *)(*(void *)*a5 - 56)) != a3)
    {
      __TUAssertTrigger();
    }
  }
  if (a2 >= 2 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "Wrong context type";
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT\n %s\n**********", buf, 0xCu);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  DataServiceController::getConnection_sync(a1, a3, a4, (uint64_t *)buf);
  uint64_t v12 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v13 = (std::__shared_weak_count *)a5[1];
    uint64_t v16 = (void *)*a5;
    uint64_t v17 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v12 + 128))(v12, a2, &v16, a6);
    if (v17) {
      sub_10004D2C8(v17);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return v14;
}

void sub_10117107C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011710A8(uint64_t a1, uint64_t a2, int a3, int a4, void *a5, uint64_t a6)
{
  return sub_101170D64(a1 - 72, a2, a3, a4, a5, a6);
}

void sub_1011710B0(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a4 >= 36)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v8 = 136315650;
      *(void *)&v8[4] = "Wrong connectionType";
      *(_WORD *)&v8[12] = 2080;
      *(void *)&v8[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataServiceController.cpp";
      __int16 v9 = 1024;
      int v10 = 2736;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT connectionType < kDataConnectionTotal\n %s\n at %s:%d\n**********", v8, 0x1Cu);
    }
    __TUAssertTrigger();
  }
  if (a3 >= 2 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int v8 = 136315138;
    *(void *)&v8[4] = "Wrong context type";
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT\n %s\n**********", v8, 0xCu);
  }
  *(void *)int v8 = 0;
  *(void *)&v8[8] = 0;
  DataServiceController::getConnection_sync(a1, a2, a4, (uint64_t *)v8);
  if (*(void *)v8) {
    (*(void (**)(void, uint64_t))(**(void **)v8 + 144))(*(void *)v8, a3);
  }
  if (*(void *)&v8[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v8[8]);
  }
}

void sub_10117125C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117127C(uint64_t a1, int a2, uint64_t a3, int a4)
{
}

void sub_101171284(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5 >= 36)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v10 = 136315650;
      *(void *)&void v10[4] = "Wrong connectionType";
      *(_WORD *)&v10[12] = 2080;
      *(void *)&v10[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataServiceController.cpp";
      __int16 v11 = 1024;
      int v12 = 2747;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT connectionType < kDataConnectionTotal\n %s\n at %s:%d\n**********", v10, 0x1Cu);
    }
    __TUAssertTrigger();
  }
  *(void *)int v10 = 0;
  *(void *)&v10[8] = 0;
  DataServiceController::getConnection_sync(a1, a2, a5, (uint64_t *)v10);
  if (*(void *)v10) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)v10 + 288))(*(void *)v10, a3, a4);
  }
  if (*(void *)&v10[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v10[8]);
  }
}

void sub_1011713E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101171408(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
}

void sub_101171410(uint64_t a1@<X0>, uint64_t a2@<X1>, MCCAndMNC *a3@<X8>)
{
  *((_OWORD *)a3 + 2) = 0u;
  *((_OWORD *)a3 + 3) = 0u;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + 1) = 0u;
  MCCAndMNC::MCCAndMNC(a3, 0, 0);
  uint64_t v6 = *(void **)(a1 + 1152);
  if (v6 != (void *)(a1 + 1160))
  {
    do
    {
      if (*((_DWORD *)v6 + 8) == a2)
      {
        MCCAndMNC::MCCAndMNC();
        MCC::operator=();
        MCC::operator=();
        if (v21 < 0) {
          operator delete(__p);
        }
        if (v19 < 0) {
          operator delete(v17);
        }
        uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          MCCAndMNC::getStringValue((uint64_t *)v16, a3);
          int v8 = v18 >= 0 ? v16 : *(uint8_t **)v16;
          *(_DWORD *)long long buf = 136315138;
          v23[0] = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I HPlmn is %s", buf, 0xCu);
          if (v18 < 0) {
            operator delete(*(void **)v16);
          }
        }
      }
      __int16 v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          __int16 v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          uint64_t v6 = v10;
        }
        while (!v11);
      }
      uint64_t v6 = v10;
    }
    while (v10 != (void *)(a1 + 1160));
  }
  MCCAndMNC::getMcc((uint64_t *)v16, a3);
  if (MCC::valid((MCC *)v16))
  {
    MCCAndMNC::getMnc((uint64_t *)buf, a3);
    int v12 = MCC::valid((MCC *)buf) ^ 1;
    if (v24 < 0) {
      operator delete(*(void **)((char *)v23 + 4));
    }
  }
  else
  {
    int v12 = 1;
  }
  if (v19 < 0)
  {
    operator delete(v17);
    if (!v12) {
      return;
    }
  }
  else if (!v12)
  {
    return;
  }
  if (*(void *)(*(void *)(a1 + 144) + 16) == sub_10003B004(*(void *)(a1 + 144), a2))
  {
    uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Both HPLMN and RPLMN are invalid!", v16, 2u);
    }
  }
  else
  {
    MCC::operator=();
    MCC::operator=();
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      MCCAndMNC::getStringValue((uint64_t *)v16, a3);
      if (v18 >= 0) {
        uint64_t v14 = v16;
      }
      else {
        uint64_t v14 = *(uint8_t **)v16;
      }
      *(_DWORD *)long long buf = 136315138;
      v23[0] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I RPlmn is %s", buf, 0xCu);
      if (v18 < 0) {
        operator delete(*(void **)v16);
      }
    }
  }
}

void sub_1011717AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_10013C44C(v28);
  _Unwind_Resume(a1);
}

void sub_101171824(uint64_t a1@<X0>, uint64_t a2@<X1>, MCCAndMNC *a3@<X8>)
{
}

uint64_t sub_10117182C(void *a1, int a2)
{
  uint64_t v2 = a1[79];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 79;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = (void *)v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 79 && *((_DWORD *)v3 + 7) <= a2 && *((unsigned char *)v3 + 32)) {
    return (*(uint64_t (**)(void))(*a1 + 1120))();
  }
  else {
    return 0;
  }
}

uint64_t sub_1011718A8(uint64_t a1, int a2)
{
  return sub_10117182C((void *)(a1 - 64), a2);
}

uint64_t sub_1011718B0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 680);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 680;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 680 && *(_DWORD *)(v3 + 28) <= a2) {
    return *(unsigned int *)(v3 + 32);
  }
  else {
    return 0;
  }
}

uint64_t sub_101171900(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 616);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 616;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 616 && *(_DWORD *)(v3 + 28) <= a2) {
    return *(unsigned int *)(v3 + 32);
  }
  else {
    return 0;
  }
}

uint64_t sub_101171950(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  __int16 v9 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v3 = v10;
  if (v10 == v11) {
    goto LABEL_22;
  }
  while ((v12(*v3) & 1) == 0)
  {
    if (++v3 == v11)
    {
      uint64_t v3 = v11;
      break;
    }
  }
  if (v3 == v11)
  {
LABEL_22:
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), *v3);
      if (*(void *)(*(void *)(a1 + 144) + 16) != v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if ((v6 == 0) | v4 & 1) {
          v4 |= v6 != 0;
        }
        else {
          char v4 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 368))(v6);
        }
      }
      uint64_t v7 = v3 + 1;
      uint64_t v3 = v11;
      if (v7 != v11)
      {
        uint64_t v3 = v7;
        while ((v12(*v3) & 1) == 0)
        {
          if (++v3 == v11)
          {
            uint64_t v3 = v11;
            break;
          }
        }
      }
    }
    while (v3 != v11);
  }
  return v4 & 1;
}

void sub_101171AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101171ABC(uint64_t a1)
{
  return sub_101171950(a1 - 64);
}

uint64_t sub_101171AC4(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 512))(v4);

  return DataUtils::toCellularDataTechnology();
}

uint64_t sub_101171B50(uint64_t a1, int a2)
{
  return sub_101171AC4(a1 - 64, a2);
}

unint64_t sub_101171B58(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  unint64_t result = *(void *)(v3 + 24);
  if (result) {
    return (unint64_t)(*(uint64_t (**)(unint64_t))(*(void *)result + 512))(result) >> 32;
  }
  return result;
}

unint64_t sub_101171BD0(uint64_t a1, int a2)
{
  return sub_101171B58(a1 - 64, a2);
}

uint64_t sub_101171BD8(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1032);
  if (!v2) {
    return 11;
  }
  uint64_t v3 = a1 + 1032;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 1032 && *(_DWORD *)(v3 + 28) <= a2) {
    return *(unsigned int *)(v3 + 32);
  }
  else {
    return 11;
  }
}

uint64_t sub_101171C28(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 976);
  if (!v2) {
    return 11;
  }
  uint64_t v3 = a1 + 976;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 976 && *(_DWORD *)(v3 + 28) <= a2) {
    return *(unsigned int *)(v3 + 32);
  }
  else {
    return 11;
  }
}

uint64_t sub_101171C78(uint64_t a1)
{
  unsigned int v1 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1136))(a1) + 1;
  return (v1 > 0xC) | (0xB84u >> v1) & 1;
}

uint64_t sub_101171CD4(uint64_t a1)
{
  unsigned int v1 = (*(uint64_t (**)(void))(*(void *)(a1 - 64) + 1136))() + 1;
  return (v1 > 0xC) | (0xB84u >> v1) & 1;
}

void sub_101171D30(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v5)
  {
    uint64_t v6 = *(uint64_t **)v5;
    uint64_t v7 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v7)
    {
      do
      {
        uint64_t v8 = *v6;
        __int16 v9 = (std::__shared_weak_count *)v6[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 272))(v8, a3);
        }
        if (v9) {
          sub_10004D2C8(v9);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
}

void sub_101171DE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101171E00(uint64_t a1, int a2, uint64_t a3)
{
}

BOOL sub_101171E08(uint64_t a1, int a2, int a3, int a4)
{
  unsigned int v4 = a3 & 0xFFFFFFFE;
  if ((a3 & 0xFFFFFFFE) == 0x96)
  {
    int v6 = a3;
    __int16 v9 = (void *)(a1 + 4600);
    int v10 = *(uint64_t **)(a1 + 4600);
    if (v10)
    {
      while (1)
      {
        while (1)
        {
          BOOL v11 = (uint64_t **)v10;
          int v12 = *((_DWORD *)v10 + 7);
          if (v12 <= a2) {
            break;
          }
          int v10 = *v11;
          uint64_t v13 = v11;
          if (!*v11) {
            goto LABEL_10;
          }
        }
        if (v12 >= a2) {
          break;
        }
        int v10 = v11[1];
        if (!v10)
        {
          uint64_t v13 = v11 + 1;
          goto LABEL_10;
        }
      }
    }
    else
    {
      uint64_t v13 = (uint64_t **)(a1 + 4600);
      BOOL v11 = (uint64_t **)(a1 + 4600);
LABEL_10:
      uint64_t v14 = (uint64_t *)v11;
      BOOL v11 = (uint64_t **)operator new(0x28uLL);
      *((_DWORD *)v11 + 7) = a2;
      *((_DWORD *)v11 + 8) = 0;
      *((unsigned char *)v11 + 36) = 0;
      int *v11 = 0;
      v11[1] = 0;
      void v11[2] = v14;
      *uint64_t v13 = (uint64_t *)v11;
      uint64_t v15 = **(void **)(a1 + 4592);
      uint64_t v16 = (uint64_t *)v11;
      if (v15)
      {
        *(void *)(a1 + 4592) = v15;
        uint64_t v16 = *v13;
      }
      sub_100046C90(*(uint64_t **)(a1 + 4600), v16);
      ++*(void *)(a1 + 4608);
    }
    *((_DWORD *)v11 + 8) = v6;
    *((unsigned char *)v11 + 36) = a4;
    uint64_t v17 = *(void **)(a1 + 4592);
    if (v17 != v9)
    {
      char v18 = *(void **)(a1 + 4592);
      do
      {
        BOOL v19 = *((_DWORD *)v18 + 8) != 150 || *((unsigned char *)v18 + 36) == 0;
        if (!v19)
        {
          a4 = 1;
          int v6 = 150;
          goto LABEL_38;
        }
        int v20 = (void *)v18[1];
        if (v20)
        {
          do
          {
            char v21 = v20;
            int v20 = (void *)*v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            char v21 = (void *)v18[2];
            BOOL v19 = *v21 == (void)v18;
            char v18 = v21;
          }
          while (!v19);
        }
        char v18 = v21;
      }
      while (v21 != v9);
      while (*((_DWORD *)v17 + 8) != 151 || *((unsigned char *)v17 + 36) == 0)
      {
        int v22 = (void *)v17[1];
        if (v22)
        {
          do
          {
            char v23 = v22;
            int v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            char v23 = (void *)v17[2];
            BOOL v19 = *v23 == (void)v17;
            uint64_t v17 = v23;
          }
          while (!v19);
        }
        uint64_t v17 = v23;
        if (v23 == v9) {
          goto LABEL_38;
        }
      }
      a4 = 1;
      int v6 = 151;
    }
LABEL_38:
    sub_100CC9650((uint64_t)&v27, v6, a4);
    uint64_t v25 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
    sub_100A01420(v25, (uint64_t)&v27);
    if (__p)
    {
      uint64_t v29 = __p;
      operator delete(__p);
    }
  }
  return v4 == 150;
}

void sub_101172008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101172024(uint64_t a1, int a2, int a3, int a4)
{
  return sub_101171E08(a1 - 72, a2, a3, a4);
}

void sub_10117202C(uint64_t a1, int a2, long long *a3)
{
  unsigned int v4 = (void *)(a1 + 8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _DWORD v6[2] = sub_101172178;
  uint64_t v6[3] = &unk_101A956F8;
  void v6[4] = a1;
  int v9 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v8 = *((void *)a3 + 2);
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, v4);
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  BOOL v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete((void *)__p);
  }
}

uint64_t sub_101172178(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v5[0] = 1;
  v5[1] = v2 + 3128;
  int v6 = (_DWORD *)(a1 + 64);
  uint64_t v3 = sub_10008CC40((uint64_t **)(v2 + 3160), (int *)(a1 + 64), (uint64_t)&unk_10144E20E, &v6);
  std::string::operator=((std::string *)(v3 + 5), (const std::string *)(a1 + 40));
  return sub_101195E58((uint64_t)v5);
}

void sub_1011721E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1011721F8(uint64_t a1, int a2, long long *a3)
{
}

void sub_101172200(uint64_t a1, int a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_101172314;
  v5[3] = &unk_101A95728;
  void v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  uint64_t v10 = 0;
  BOOL v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  unsigned int v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v10;
  int v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_101172314(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    int v3 = *(unsigned __int8 *)(v1 + 312);
    unsigned int v4 = *(NSObject **)(v1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (!v3)
    {
      if (!v5) {
        return;
      }
      int v9 = 136315138;
      uint64_t v10 = "handleAPNSettingsChange_block_invoke";
      int v7 = "#E %s: !!! too early start";
      uint64_t v8 = v4;
      goto LABEL_9;
    }
    if (v5)
    {
      int v9 = 136315138;
      uint64_t v10 = "handleAPNSettingsChange_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn", (uint8_t *)&v9, 0xCu);
    }
    sub_1011646C8((void *)v1, *(_DWORD *)(a1 + 40), *(unsigned int *)(a1 + 44), 1, 1);
    int v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      uint64_t v10 = "handleAPNSettingsChange_block_invoke";
      int v7 = "#I %s: (2) refreshapn";
      uint64_t v8 = v6;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v9, 0xCu);
    }
  }
}

void sub_10117246C(uint64_t a1, int a2, int a3)
{
}

void sub_101172474(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 16);
  if (v2 != v3)
  {
    int v4 = 0;
    do
    {
      BOOL v5 = *(uint64_t **)(v2 + 56);
      int v6 = *(uint64_t **)(v2 + 64);
      while (v5 != v6)
      {
        uint64_t v8 = *v5;
        int v7 = (std::__shared_weak_count *)v5[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        for (uint64_t i = 0; i != 2; ++i)
        {
          if (v8) {
            v4 |= (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 56))(v8, dword_1015C55B0[i]);
          }
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
        v5 += 2;
      }
      v2 += 432;
    }
    while (v2 != v3);
    if (v4)
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v13 = "wakeUpSDM";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: notify SD to exit low power mode", buf, 0xCu);
      }
      sub_100358C28((uint64_t)&event::data::controlServiceOnLowPowerModeTransition, 0);
    }
  }
}

void sub_1011725F0(_Unwind_Exception *exception_object)
{
}

void sub_101172610(uint64_t a1, int a2, unint64_t a3, char a4, long long *a5, char a6, char a7)
{
  int v13 = ConnectionMaskToType(a3);
  if (v13 < 36)
  {
    atomic_fetch_add((atomic_uint *volatile)(a1 + 4180), 1u);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 1174405120;
    int v16[2] = sub_101172834;
    v16[3] = &unk_101A95748;
    void v16[4] = a1;
    int v19 = a2;
    int v20 = v13;
    char v21 = a4;
    if (*((char *)a5 + 23) < 0)
    {
      sub_10004FC84(&__p, *(void **)a5, *((void *)a5 + 1));
    }
    else
    {
      long long __p = *a5;
      uint64_t v18 = *((void *)a5 + 2);
    }
    char v22 = a6;
    char v23 = a7;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    sub_10003E168(&v24, (void *)(a1 + 8));
    uint64_t v15 = *(NSObject **)(a1 + 24);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 1174405120;
    uint64_t v27 = sub_101195718;
    uint64_t v28 = &unk_101A98BF0;
    uint64_t v30 = v24;
    uint64_t v31 = v25;
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v29 = v16;
    dispatch_async(v15, &buf);
    if (v31) {
      sub_10004D2C8(v31);
    }
    if (v25) {
      sub_10004D2C8(v25);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "setConnectionActive";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_101172828(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101172834(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 64);
    int v4 = *(_DWORD *)(a1 + 68);
    int v5 = *(unsigned __int8 *)(a1 + 72);
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 40);
      uint64_t v7 = *(void *)(a1 + 56);
    }
    DataServiceController::setConnectionActive_sync((uint64_t *)v1, v3, v4, v5 != 0, (const std::string::value_type *)__p, *(unsigned __int8 *)(a1 + 73), *(unsigned char *)(a1 + 74));
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
    atomic_fetch_add((atomic_uint *volatile)(v1 + 4180), 0xFFFFFFFF);
  }
}

void sub_1011728F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::setConnectionActive_sync(uint64_t *a1, uint64_t a2, int a3, int a4, const std::string::value_type *a5, BOOL a6, BOOL a7)
{
  if (*((unsigned char *)a1 + 312))
  {
    unsigned int v13 = a2;
    if (a7)
    {
      uint64_t v14 = a2;
    }
    else
    {
      uint64_t v14 = (*(uint64_t (**)(uint64_t *))(*a1 + 1088))(a1);
      BOOL v16 = sub_100AF2240(a1[18], v13);
      if (v13 && v16 && v14 != v13)
      {
        uint64_t v17 = 0;
        uint64_t v18 = &qword_1015C55C8;
        while (dword_1015C55B8[v17] != a3)
        {
          if (++v17 == 4) {
            goto LABEL_14;
          }
        }
        uint64_t v18 = (uint64_t *)&dword_1015C55B8[v17];
LABEL_14:
        if ((char *)v18 - (char *)dword_1015C55B8 == 16)
        {
          LODWORD(v14) = (*(uint64_t (**)(uint64_t *))(*a1 + 1072))(a1);
          if (sub_100AF2240(a1[18], v13) && v14 != v13) {
            uint64_t v14 = v13;
          }
          else {
            uint64_t v14 = v14;
          }
        }
      }
    }
    if (sub_100AF2240(a1[18], v14))
    {
      int v19 = *(NSObject **)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[6] + 16))(a1[6], v14);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = "de";
        int v35 = a4;
        if (a4) {
          int v20 = "";
        }
        uint64_t v34 = v20;
        uint64_t v33 = asString();
        char v21 = a5;
        if (a5[23] < 0) {
          char v21 = *(const std::string::value_type **)a5;
        }
        uint64_t v22 = asStringBool(a6);
        unsigned int v23 = atomic_load((unsigned int *)a1 + 1045);
        *(_DWORD *)long long buf = 136316418;
        *(void *)&uint8_t buf[4] = v34;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v33;
        *(_WORD *)&unsigned char buf[22] = 2080;
        unsigned int v39 = v21;
        __int16 v40 = 2080;
        uint64_t v41 = v22;
        __int16 v42 = 1024;
        unsigned int v43 = v23;
        __int16 v44 = 2080;
        uint64_t v45 = asStringBool(a7);
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I connection: %sactivating %s reason %s doNotCleanDataStatusCache %s pending %u , doNotAdjustSim %s", buf, 0x3Au);
        a4 = v35;
      }
      sub_100058DB0(&v37, "setConnectionActive ");
      int v24 = a5[23];
      if (v24 >= 0) {
        uint64_t v25 = a5;
      }
      else {
        uint64_t v25 = *(const std::string::value_type **)a5;
      }
      if (v24 >= 0) {
        std::string::size_type v26 = *((unsigned __int8 *)a5 + 23);
      }
      else {
        std::string::size_type v26 = *((void *)a5 + 1);
      }
      uint64_t v27 = std::string::append(&v37, v25, v26);
      long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      *(void *)&uint8_t buf[16] = *((void *)&v27->__r_.__value_.__l + 2);
      *(_OWORD *)long long buf = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v37.__r_.__value_.__l.__data_);
        if (a6)
        {
LABEL_39:
          *(_OWORD *)&v37.__r_.__value_.__l.__data_ = 0uLL;
          DataServiceController::getConnection_sync((uint64_t)a1, v14, a3, (uint64_t *)&v37);
          std::string::size_type v30 = v37.__r_.__value_.__r.__words[0];
          if (v37.__r_.__value_.__r.__words[0])
          {
            uint64_t v31 = (*(uint64_t (**)(std::string::size_type))(*(void *)v37.__r_.__value_.__l.__data_ + 48))(v37.__r_.__value_.__r.__words[0]);
            if (a4) {
              (*(void (**)(std::string::size_type, const char *, uint64_t, void, BOOL))(*(void *)v30 + 88))(v30, "setConnectionActive", v31, 0, a6);
            }
            else {
              (*(void (**)(std::string::size_type, const char *, uint64_t))(*(void *)v30 + 96))(v30, "setConnectionActive", v31);
            }
          }
          else
          {
            long long v32 = *(NSObject **)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[6] + 16))(a1[6], v14);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)BOOL v36 = 0;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N Connection not found", v36, 2u);
            }
          }
          if (v37.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v37.__r_.__value_.__l.__size_);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          return;
        }
      }
      else if (a6)
      {
        goto LABEL_39;
      }
      if (buf[23] >= 0) {
        uint64_t v29 = buf;
      }
      else {
        uint64_t v29 = *(unsigned char **)buf;
      }
      DataServiceController::enableContextStateChangeNotificationRepost((uint64_t)a1, v14, a3, (uint64_t)v29, 0);
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v15 = a1[5];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "setConnectionActive_sync";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
  }
}

void sub_101172DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101172E30(uint64_t a1, int a2, unint64_t a3, char a4, long long *a5, char a6, char a7)
{
}

void sub_101172E38(uint64_t a1, int a2, unint64_t a3, char a4, long long *a5, char a6, char a7)
{
}

void sub_101172E40(uint64_t a1, int a2, unint64_t a3, char a4, long long *a5, char a6, char a7)
{
}

void sub_101172E48(uint64_t a1, int a2, int a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_101172F60;
  uint64_t v6[3] = &unk_101A95778;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  char v9 = a4;
  uint64_t v12 = 0;
  unsigned int v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  int v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  BOOL v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101172F60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 40);
    int v3 = *(_DWORD *)(a1 + 44);
    int v4 = *(unsigned __int8 *)(a1 + 48);
    if (sub_100AF2240(*(void *)(v1 + 144), v2))
    {
      int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
      int v6 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = asString();
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = asStringBool(v4 != 0);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I  %s asserted to %s", buf, 0x16u);
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      DataServiceController::getConnection_sync(v1, v2, v3, (uint64_t *)buf);
      if (*(void *)buf)
      {
        (*(void (**)(void))(**(void **)buf + 296))();
      }
      else
      {
        int v7 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Connection not found", v8, 2u);
        }
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
  }
}

void sub_10117312C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117314C(uint64_t a1, int a2, int a3, char a4)
{
}

void sub_101173154(uint64_t a1, int a2, int a3, char a4)
{
}

uint64_t sub_10117315C(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    uint64_t v10 = "handleOTAAPNSettingsChange";
    __int16 v11 = 1024;
    int v12 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: %d", (uint8_t *)&v9, 0x12u);
  }
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v7) {
    return 0;
  }
  uint64_t result = *(void *)(v7 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 64))(result, a3);
  }
  return result;
}

uint64_t sub_101173270(uint64_t a1, int a2, uint64_t a3)
{
  return sub_10117315C(a1 - 64, a2, a3);
}

uint64_t sub_101173278@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 248);
  *a2 = *(void *)(result + 240);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173294@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 192);
  *a2 = *(void *)(result + 184);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011732B0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 184);
  *a2 = *(void *)(result + 176);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011732CC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 176);
  *a2 = *(void *)(result + 168);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011732E8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 264);
  *a2 = *(void *)(result + 256);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173304@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 208);
  *a2 = *(void *)(result + 200);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173320@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 200);
  *a2 = *(void *)(result + 192);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10117333C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 192);
  *a2 = *(void *)(result + 184);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173358@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 280);
  *a2 = *(void *)(result + 272);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173374@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 224);
  *a2 = *(void *)(result + 216);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101173390@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 208);
  *a2 = *(void *)(result + 200);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011733AC(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 272))
  {
    int v3 = *(std::__shared_weak_count **)(a1 + 112);
    uint64_t v5 = *(void *)(a1 + 104);
    int v6 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v8 = a2;
    sub_10058A500(&v5, &v8, &v7);
    int v4 = *(std::__shared_weak_count **)(a1 + 280);
    *(_OWORD *)(a1 + 272) = v7;
    if (v4) {
      sub_10004D2C8(v4);
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_10117342C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101173444(uint64_t a1, int a2)
{
}

void sub_10117344C(uint64_t a1, int a2)
{
  uint64_t v2 = (BOOL *)(a1 + 4584);
  if (*(unsigned __int8 *)(a1 + 4584) != a2)
  {
    BOOL v3 = a2;
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315138;
      uint64_t v7 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Wifi availability is changing to %s", (uint8_t *)&v6, 0xCu);
    }
    *uint64_t v2 = v3;
    DataServiceController::resetSlicePoliciesOnWiFiChange_sync((DataServiceController *)a1, v3);
  }
}

void sub_101173520(uint64_t a1, int a2)
{
}

uint64_t sub_101173528(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3 || (uint64_t v4 = *(void *)(v3 + 40)) == 0)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      int v9 = "isiWLanOverCellSupported";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: No TechDataDriver", (uint8_t *)&v8, 0xCu);
    }
    return 0;
  }
  else
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 512);
    return v5();
  }
}

uint64_t sub_101173650(uint64_t a1, int a2)
{
  return sub_101173528(a1 - 64, a2);
}

BOOL sub_101173658(uint64_t *a1)
{
  int v2 = (*(uint64_t (**)(uint64_t *))(*a1 + 1088))(a1);
  uint64_t v3 = sub_10003B004(a1[18], v2);
  if (*(void *)(a1[18] + 16) == v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = a1[19];
  int v6 = *(std::__shared_weak_count **)(v4 + 424);
  v9[0] = *(void *)(v4 + 416);
  v9[1] = v6;
  if (!v6) {
    return sub_100AE4330(v5, (uint64_t)v9);
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v7 = sub_100AE4330(v5, (uint64_t)v9);
  sub_10004D2C8(v6);
  return v7;
}

BOOL sub_101173718(uint64_t a1)
{
  return sub_101173658((uint64_t *)(a1 - 56));
}

uint64_t sub_101173720(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    uint64_t v10 = "handleTetheringSettingsChange_sync";
    __int16 v11 = 1024;
    int v12 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: %d", (uint8_t *)&v9, 0x12u);
  }
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v7) {
    return 0;
  }
  uint64_t result = *(void *)(v7 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 80))(result, a3);
  }
  return result;
}

uint64_t sub_101173834(uint64_t a1, int a2, uint64_t a3)
{
  return sub_101173720(a1 - 56, a2, a3);
}

void sub_10117383C(uint64_t a1, char a2, long long *a3)
{
  atomic_fetch_add((atomic_uint *volatile)(a1 + 4180), 1u);
  uint64_t v4 = (void *)(a1 + 8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _DWORD v6[2] = sub_101173998;
  uint64_t v6[3] = &unk_101A95798;
  void v6[4] = a1;
  char v9 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v8 = *((void *)a3 + 2);
  }
  uint64_t v12 = 0;
  unsigned int v13 = 0;
  sub_10003E168(&v12, v4);
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  __int16 v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete((void *)__p);
  }
}

void sub_101173998(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      int v2 = (const char *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        int v2 = *(const char **)v2;
      }
      DataServiceController::setInternetActive_sync(*(DataServiceController **)(a1 + 32), *(unsigned __int8 *)(a1 + 64) != 0, v2);
      atomic_fetch_add((atomic_uint *volatile)(v1 + 4180), 0xFFFFFFFF);
    }
    else
    {
      uint64_t v3 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = 136315138;
        uint64_t v5 = "setInternetActive_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v4, 0xCu);
      }
    }
  }
}

void DataServiceController::setInternetActive_sync(DataServiceController *this, int a2, const char *a3)
{
  int v6 = *((void *)this + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v7 = atomic_load((unsigned int *)this + 1045);
    uint64_t v8 = "de";
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "setInternetActive_sync";
    if (a2) {
      uint64_t v8 = "";
    }
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v8;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = a3;
    LOWORD(v42) = 1024;
    *(_DWORD *)((char *)&v42 + 2) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: %sactivating internet reason %s pending %u", buf, 0x26u);
  }
  uint64_t v9 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
  uint64_t v10 = sub_10003B004(*((void *)this + 18), v9);
  if (*(void *)(*((void *)this + 18) + 16) != v10)
  {
    sub_100058DB0(buf, "setInternetActive ");
    size_t v11 = strlen(a3);
    uint64_t v12 = std::string::append((std::string *)buf, a3, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    int64_t v30 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v14 = *(uint64_t **)v10;
    uint64_t v15 = *(uint64_t **)(v10 + 8);
    if (*(uint64_t **)v10 != v15)
    {
      while (1)
      {
        uint64_t v17 = *v14;
        BOOL v16 = (std::__shared_weak_count *)v14[1];
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v17) {
          break;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v17 + 472))(v17))
        {
          int v18 = 0;
          if (v16) {
            goto LABEL_14;
          }
        }
        else
        {
          if (a2)
          {
            unsigned int v43 = 0;
            long long v42 = 0u;
            memset(buf, 0, sizeof(buf));
            DataServiceController::canActivateConnection_sync((uint64_t)this, v9, 0, (uint64_t)buf);
            int v19 = *((void *)this + 5);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v20 = asString();
              uint64_t v21 = asStringBool(*(_DWORD *)buf == 0);
              *(_DWORD *)uint64_t v31 = 136316162;
              long long v32 = "setInternetActive_sync";
              __int16 v33 = 2080;
              uint64_t v34 = v20;
              __int16 v35 = 2080;
              uint64_t v36 = v21;
              __int16 v37 = 2080;
              uint64_t v38 = *(void *)&buf[8];
              __int16 v39 = 2080;
              uint64_t v40 = *(void *)&buf[16];
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Availability of connection %s for internet: %s (%s %s)", v31, 0x34u);
            }
            if (*(_DWORD *)buf)
            {
              sub_101174050((unint64_t)this, v9, 0, *(int *)buf);
            }
            else
            {
              uint64_t v25 = *((void *)this + 5);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v26 = asString();
                *(_DWORD *)uint64_t v31 = 136315394;
                long long v32 = "setInternetActive_sync";
                __int16 v33 = 2080;
                uint64_t v34 = v26;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s: Activating %s...", v31, 0x16u);
              }
              if (v30 >= 0) {
                uint64_t v27 = __p;
              }
              else {
                uint64_t v27 = (void **)__p[0];
              }
              DataServiceController::enableContextStateChangeNotificationRepost((uint64_t)this, v9, 0, (uint64_t)v27, 0);
              (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v17 + 88))(v17, "setInternetActive_sync", "CommCenter", 0, 0);
            }
            if (v43) {
              sub_10004D2C8(v43);
            }
          }
          else
          {
            uint64_t v22 = *((void *)this + 5);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v23 = asString();
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = "setInternetActive_sync";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v23;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating %s...", buf, 0x16u);
            }
            if (v30 >= 0) {
              int v24 = __p;
            }
            else {
              int v24 = (void **)__p[0];
            }
            DataServiceController::enableContextStateChangeNotificationRepost((uint64_t)this, v9, 0, (uint64_t)v24, 1);
            (*(void (**)(uint64_t, const char *, const char *))(*(void *)v17 + 96))(v17, "setInternetActive_sync", "CommCenter");
          }
          int v18 = 1;
          if (v16) {
            goto LABEL_14;
          }
        }
LABEL_15:
        if (v18 != 7 && v18) {
          goto LABEL_45;
        }
        v14 += 2;
        if (v14 == v15) {
          goto LABEL_42;
        }
      }
      int v18 = 7;
      if (!v16) {
        goto LABEL_15;
      }
LABEL_14:
      sub_10004D2C8(v16);
      goto LABEL_15;
    }
LABEL_42:
    long long v28 = *((void *)this + 5);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "setInternetActive_sync";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: No Internet connection configured, failing", buf, 0xCu);
    }
    sub_101174050((unint64_t)this, v9, 0, -3);
LABEL_45:
    if (SHIBYTE(v30) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_101173FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37)
{
  if (a37) {
    sub_10004D2C8(a37);
  }
  if (v37) {
    sub_10004D2C8(v37);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101174048(uint64_t a1, char a2, long long *a3)
{
}

BOOL sub_101174050(unint64_t a1, uint64_t a2, int a3, int a4)
{
  BOOL result = sub_100AF2240(*(void *)(a1 + 144), a2);
  if (result)
  {
    uint64_t v9 = a3;
    unsigned int v10 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)a1 + 1688))(a1, a2);
    uint64_t v11 = a4;
    unint64_t v12 = ConnectionTypeToMask();
    unsigned int v13 = subscriber::simSlotAsInstance();
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      asStringMask((uint64_t *)__p, v12);
      uint64_t v15 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 134218754;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v11;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v15;
      LOWORD(v22) = 2048;
      *(void *)((char *)&v22 + 2) = v12;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I activate failed ----- { fPdpId=%lld, errCode=%lld, connectionMask=%s(0x%llx) }", buf, 0x2Au);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    BOOL v16 = operator new(0x38uLL);
    *BOOL v16 = v9;
    v16[1] = 0;
    int v16[2] = v10;
    v16[3] = v11;
    void v16[4] = v12;
    void v16[5] = v13;
    void v16[6] = 52;
    sub_10003E168(buf, (void *)(a1 + 8));
    uint64_t v18 = *(void *)buf;
    uint64_t v17 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      *(void *)long long buf = v18;
      *(void *)&uint8_t buf[8] = v17;
      atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      *(void *)&uint8_t buf[8] = 0;
    }
    *(_OWORD *)&uint8_t buf[16] = a1;
    long long v22 = 0uLL;
    sub_1006121D4(&buf[24], v16, (uint64_t)(v16 + 7), 7uLL);
    int v23 = a2;
    __p[0] = 0;
    __p[1] = 0;
    sub_10003E168(__p, (void *)(a1 + 8));
    operator new();
  }
  return result;
}

void sub_101174380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
}

void sub_1011743F8(uint64_t a1, char a2)
{
  atomic_fetch_add((atomic_uint *volatile)(a1 + 4180), 1u);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_101174518;
  void v4[3] = &unk_101A957C8;
  void v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v8;
  unsigned int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_101174518(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      int v2 = *(unsigned __int8 *)(a1 + 40);
      uint64_t v3 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v4 = "";
        unsigned int v5 = atomic_load((unsigned int *)(v1 + 4180));
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "setTetheringActive_sync";
        if (!v2) {
          int v4 = "de";
        }
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v4;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: %sactivating tethering pending %u", buf, 0x1Cu);
      }
      uint64_t v6 = (*(uint64_t (**)(unint64_t))(*(void *)v1 + 1896))(v1);
      uint64_t v7 = sub_10003B004(*(void *)(v1 + 144), v6);
      if (*(void *)(*(void *)(v1 + 144) + 16) != v7)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v25 = 0;
        sub_100058DB0(__p, "setTetheringActive");
        uint64_t v8 = *(uint64_t **)v7;
        uint64_t v9 = *(uint64_t **)(v7 + 8);
        if (*(uint64_t **)v7 != v9)
        {
          while (1)
          {
            uint64_t v11 = *v8;
            unsigned int v10 = (std::__shared_weak_count *)v8[1];
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (!v11) {
              break;
            }
            if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 472))(v11) == 4)
            {
              if (v2)
              {
                uint64_t v38 = 0;
                long long v37 = 0u;
                memset(buf, 0, sizeof(buf));
                DataServiceController::canActivateConnection_sync(v1, v6, 4, (uint64_t)buf);
                unint64_t v12 = *(NSObject **)(v1 + 40);
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v13 = asString();
                  uint64_t v14 = asStringBool(*(_DWORD *)buf == 0);
                  *(_DWORD *)uint64_t v26 = 136316162;
                  uint64_t v27 = "setTetheringActive_sync";
                  __int16 v28 = 2080;
                  uint64_t v29 = v13;
                  __int16 v30 = 2080;
                  uint64_t v31 = v14;
                  __int16 v32 = 2080;
                  uint64_t v33 = *(void *)&buf[8];
                  __int16 v34 = 2080;
                  uint64_t v35 = *(void *)&buf[16];
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Availability of connection %s for tethering: %s (%s %s)", v26, 0x34u);
                }
                if (*(_DWORD *)buf)
                {
                  sub_101174050(v1, v6, 0, *(int *)buf);
                }
                else
                {
                  int v19 = *(NSObject **)(v1 + 40);
                  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v20 = asString();
                    *(_DWORD *)uint64_t v26 = 136315394;
                    uint64_t v27 = "setTetheringActive_sync";
                    __int16 v28 = 2080;
                    uint64_t v29 = v20;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Activating %s...", v26, 0x16u);
                  }
                  if (v25 >= 0) {
                    uint64_t v21 = __p;
                  }
                  else {
                    uint64_t v21 = (void **)__p[0];
                  }
                  DataServiceController::enableContextStateChangeNotificationRepost(v1, v6, 4, (uint64_t)v21, 0);
                  (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v11 + 88))(v11, "setTetheringActive_sync", "CommCenter", 0, 0);
                }
                if (v38) {
                  sub_10004D2C8(v38);
                }
              }
              else
              {
                BOOL v16 = *(NSObject **)(v1 + 40);
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v17 = asString();
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = "setTetheringActive_sync";
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v17;
                  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating %s...", buf, 0x16u);
                }
                if (v25 >= 0) {
                  uint64_t v18 = __p;
                }
                else {
                  uint64_t v18 = (void **)__p[0];
                }
                DataServiceController::enableContextStateChangeNotificationRepost(v1, v6, 4, (uint64_t)v18, 1);
                (*(void (**)(uint64_t, const char *, const char *))(*(void *)v11 + 96))(v11, "setTetheringActive_sync", "CommCenter");
              }
              int v15 = 1;
              if (v10) {
                goto LABEL_21;
              }
            }
            else
            {
              int v15 = 0;
              if (v10) {
                goto LABEL_21;
              }
            }
LABEL_22:
            if (v15 != 7 && v15) {
              goto LABEL_47;
            }
            v8 += 2;
            if (v8 == v9) {
              goto LABEL_44;
            }
          }
          int v15 = 7;
          if (!v10) {
            goto LABEL_22;
          }
LABEL_21:
          sub_10004D2C8(v10);
          goto LABEL_22;
        }
LABEL_44:
        int v23 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "setTetheringActive_sync";
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: No Tethering connection configured, failing", buf, 0xCu);
        }
        sub_101174050(v1, v6, 0, -3);
LABEL_47:
        if (SHIBYTE(v25) < 0) {
          operator delete(__p[0]);
        }
      }
      atomic_fetch_add((atomic_uint *volatile)(v1 + 4180), 0xFFFFFFFF);
    }
    else
    {
      long long v22 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "setTetheringActive_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
      }
    }
  }
}

void sub_101174AA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  if (a34) {
    sub_10004D2C8(a34);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101174AFC(uint64_t a1, char a2)
{
}

BOOL sub_101174B04(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return sub_101174050(a1 - 64, a2, a3, a4);
}

BOOL sub_101174B0C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v6 = *(void *)(a1 + 144);
  uint64_t v7 = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v6 + 16);
  if (v7 == v8)
  {
    int v9 = 0;
  }
  else
  {
    int v9 = 0;
    do
    {
      unsigned int v10 = *(char **)(v7 + 24);
      if (v10) {
        int v11 = (*(uint64_t (**)(char *))(*(void *)&v10[*(void *)(*(void *)v10 - 320)] + 216))(&v10[*(void *)(*(void *)v10 - 320)]);
      }
      else {
        int v11 = 0;
      }
      unint64_t v12 = *(char **)(v7 + 40);
      if (v12) {
        int v13 = (*(uint64_t (**)(char *))(*(void *)&v12[*(void *)(*(void *)v12 - 320)] + 216))(&v12[*(void *)(*(void *)v12 - 320)]);
      }
      else {
        int v13 = 0;
      }
      v9 += v11 + v13;
      v7 += 432;
    }
    while (v7 != v8);
    uint64_t v6 = *(void *)(a1 + 144);
  }
  *((_DWORD *)a3 + 10) = 0;
  *((_DWORD *)a3 + 11) = v9;
  uint64_t v14 = sub_10003B004(v6, a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v14)
  {
    uint64_t v15 = v14;
    BOOL v16 = *(char **)(v14 + 24);
    if (v16) {
      int v17 = (*(uint64_t (**)(char *))(*(void *)&v16[*(void *)(*(void *)v16 - 320)] + 216))(&v16[*(void *)(*(void *)v16 - 320)]);
    }
    else {
      int v17 = 0;
    }
    uint64_t v18 = *(char **)(v15 + 40);
    if (v18) {
      int v19 = (*(uint64_t (**)(char *))(*(void *)&v18[*(void *)(*(void *)v18 - 320)] + 216))(&v18[*(void *)(*(void *)v18 - 320)]);
    }
    else {
      int v19 = 0;
    }
    *((_DWORD *)a3 + 10) = v19 + v17;
  }
  a3[48] = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1040))(a1, a2);
  BOOL result = sub_100AF2240(*(void *)(a1 + 144), a2);
  if (result)
  {
    uint64_t v21 = sub_100AEFE40(*(void *)(a1 + 144), a2);
    uint64_t v22 = *(void *)(a1 + 152);
    int v23 = *(std::__shared_weak_count **)(v21 + 424);
    uint64_t v39 = *(void *)(v21 + 416);
    uint64_t v40 = v23;
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100AE4E14(v22, (uint64_t)&v39, (uint64_t)v45);
      sub_10004D2C8(v23);
    }
    else
    {
      sub_100AE4E14(v22, (uint64_t)&v39, (uint64_t)v45);
    }
    if (*a3 == v45[0]
      && a3[1] == v45[1]
      && *((_DWORD *)a3 + 1) == v46
      && a3[8] == v47
      && *((_DWORD *)a3 + 3) == v48
      && *((_DWORD *)a3 + 4) == v49
      && *((_DWORD *)a3 + 5) == v50
      && *((_DWORD *)a3 + 6) == v51
      && a3[28] == v52
      && *((_DWORD *)a3 + 8) == v53
      && a3[36] == v54
      && *((_DWORD *)a3 + 10) == v55
      && *((_DWORD *)a3 + 11) == v56
      && a3[48] == v57)
    {
      return 0;
    }
    else
    {
      int v24 = v49;
      int v25 = *((_DWORD *)a3 + 4);
      uint64_t v26 = *(void *)(a1 + 152);
      uint64_t v27 = *(void *)(v21 + 416);
      __int16 v28 = *(std::__shared_weak_count **)(v21 + 424);
      uint64_t v39 = v27;
      uint64_t v40 = v28;
      if (v28) {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v29 = *((_OWORD *)a3 + 1);
      v43[0] = *(_OWORD *)a3;
      v43[1] = v29;
      v43[2] = *((_OWORD *)a3 + 2);
      uint64_t v44 = *((void *)a3 + 6);
      sub_100AE4EF8(v26, (uint64_t)&v39, v43);
      if (v28) {
        sub_10004D2C8(v28);
      }
      (*(void (**)(void, uint64_t, unsigned __int8 *, BOOL))(**(void **)(a1 + 4240) + 88))(*(void *)(a1 + 4240), a2, a3, v24 != v25);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1088))(a1) == a2) {
        (*(void (**)(void, unsigned __int8 *, unsigned char *))(**(void **)(a1 + 4240) + 96))(*(void *)(a1 + 4240), a3, v45);
      }
      int v30 = *((_DWORD *)a3 + 1);
      int v31 = *((_DWORD *)a3 + 8);
      uint64_t v39 = 1;
      long long v41 = 0u;
      uint64_t v42 = 0;
      uint64_t v40 = (std::__shared_weak_count *)(a1 + 3624);
      sub_100A579C0((uint64_t *)&v41, a1 + 3656);
      __int16 v32 = (uint64_t *)*((void *)&v41 + 1);
      if (*((void *)&v41 + 1))
      {
        do
        {
          while (1)
          {
            uint64_t v33 = (uint64_t **)v32;
            int v34 = *((_DWORD *)v32 + 7);
            if (v34 <= (int)a2) {
              break;
            }
            __int16 v32 = *v33;
            uint64_t v35 = v33;
            if (!*v33) {
              goto LABEL_54;
            }
          }
          if (v34 >= (int)a2)
          {
            long long v37 = v33;
            goto LABEL_57;
          }
          __int16 v32 = v33[1];
        }
        while (v32);
        uint64_t v35 = v33 + 1;
      }
      else
      {
        uint64_t v35 = (uint64_t **)&v41 + 1;
        uint64_t v33 = (uint64_t **)&v41 + 1;
      }
LABEL_54:
      long long v37 = operator new(0x28uLL);
      v37[7] = a2;
      v37[8] = 0;
      *(void *)long long v37 = 0;
      *((void *)v37 + 1) = 0;
      *((void *)v37 + 2) = v33;
      *uint64_t v35 = (uint64_t *)v37;
      uint64_t v36 = (uint64_t *)v37;
      if (*(void *)v41)
      {
        *(void *)&long long v41 = *(void *)v41;
        uint64_t v36 = *v35;
      }
      sub_100046C90(*((uint64_t **)&v41 + 1), v36);
      ++v42;
LABEL_57:
      if (v31) {
        int v38 = v31;
      }
      else {
        int v38 = v30;
      }
      v37[8] = v38;
      sub_1011966F8((uint64_t)&v39);
      return 1;
    }
  }
  return result;
}

void sub_101175058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10117506C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  return sub_101174B0C(a1 - 64, a2, a3);
}

void sub_101175074(uint64_t a1, int a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_101175188;
  v5[3] = &unk_101A957E8;
  void v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  uint64_t v10 = 0;
  int v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  int v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v10;
  int v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_101175188(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      uint64_t v2 = *(int *)(a1 + 44);
      uint64_t v3 = (void *)sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 40));
      if (*(void **)(*(void *)(v1 + 144) + 16) != v3)
      {
        if (v3[3])
        {
          uint64_t v4 = *(void *)(v1 + 4136);
          if ((int)v2 < (int)((unint64_t)(*(void *)(v1 + 4144) - v4) >> 4))
          {
            unsigned int v5 = (uint64_t *)(v4 + 16 * v2);
            uint64_t v6 = *v5;
            int v7 = (std::__shared_weak_count *)v5[1];
            if (v7) {
              atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v8 = v3[53];
            *(void *)&long long v10 = v3[52];
            *((void *)&v10 + 1) = v8;
            if (v8) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, void, long long *, uint64_t, uint64_t))(*(void *)v6 + 280))(v6, 0, &v10, 3, 1);
            if (*((void *)&v10 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
            }
            if (v7) {
              sub_10004D2C8(v7);
            }
          }
        }
      }
    }
    else
    {
      int v9 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v10) = 136315138;
        *(void *)((char *)&v10 + 4) = "suspendContext_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v10, 0xCu);
      }
    }
  }
}

void sub_10117530C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101175330(uint64_t a1, int a2, int a3)
{
}

void sub_101175338(uint64_t a1, int a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10117544C;
  v5[3] = &unk_101A95808;
  void v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  uint64_t v10 = 0;
  int v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v10;
  int v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_10117544C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      uint64_t v2 = *(int *)(a1 + 44);
      uint64_t v3 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 40));
      if (*(void *)(*(void *)(v1 + 144) + 16) != v3)
      {
        uint64_t v4 = (void *)v3;
        if (*(void *)(v3 + 24))
        {
          uint64_t v5 = *(void *)(v1 + 4136);
          if ((int)v2 < (int)((unint64_t)(*(void *)(v1 + 4144) - v5) >> 4))
          {
            int v6 = (uint64_t *)(v5 + 16 * v2);
            uint64_t v7 = *v6;
            uint64_t v8 = (std::__shared_weak_count *)v6[1];
            if (v8) {
              atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v9 = v4[53];
            *(void *)&long long v12 = v4[52];
            *((void *)&v12 + 1) = v9;
            if (v9) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, void, long long *, void))(*(void *)v7 + 288))(v7, 0, &v12, 0);
            if (*((void *)&v12 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
            }
            if (v8) {
              sub_10004D2C8(v8);
            }
          }
          uint64_t v10 = v4[3] + *(void *)(*(void *)v4[3] - 320);
          (*(void (**)(uint64_t))(*(void *)v10 + 136))(v10);
        }
      }
    }
    else
    {
      int v11 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v12) = 136315138;
        *(void *)((char *)&v12 + 4) = "resumeContext_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v12, 0xCu);
      }
    }
  }
}

void sub_101175618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101175644(uint64_t a1, int a2, int a3)
{
}

void sub_10117564C(uint64_t a1, uint64_t a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v5 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v5 = *(void **)(a2 + 16);
  }
  if (SHIBYTE(v5) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    __p[2] = v5;
  }
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_1011757C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011757E8(uint64_t a1, uint64_t a2)
{
}

void sub_1011757F0(uint64_t a1, int a2, int a3, char a4, int a5)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10117590C;
  v7[3] = &unk_101A95828;
  void v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  char v11 = a4;
  int v10 = a5;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, (void *)(a1 + 8));
  int v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v14;
  int v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_10117590C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v12 = 0;
    int v13 = 0;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), &v12);
    uint64_t v3 = v12;
    if (v12)
    {
      uint64_t v4 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 40));
      if (*(void *)(*(void *)(v1 + 144) + 16) != v4)
      {
        uint64_t v5 = *(unsigned char *)(a1 + 52) ? *(unsigned int *)(a1 + 48) : 2;
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v3 + 512))(v3, v5))
        {
          uint64_t v7 = *(uint64_t **)(v4 + 56);
          for (uint64_t i = *(uint64_t **)(v4 + 64); v7 != i; v7 += 2)
          {
            uint64_t v9 = *v7;
            int v10 = (std::__shared_weak_count *)v7[1];
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v9) {
              (*(void (**)(uint64_t, void, void, void))(*(void *)v9 + 1032))(v9, *(unsigned int *)(a1 + 44), *(unsigned __int8 *)(a1 + 52), *(unsigned int *)(a1 + 48));
            }
            if (v10) {
              sub_10004D2C8(v10);
            }
          }
        }
      }
    }
    else
    {
      int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(a1 + 40));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Connection not found", v11, 2u);
      }
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_101175ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_101175AF0(uint64_t a1, int a2, int a3, char a4, int a5)
{
}

BOOL sub_101175AF8(capabilities::ct *a1)
{
  return !capabilities::ct::supportsCellRadio(a1) || *((unsigned char *)a1 + 801) != 0;
}

BOOL sub_101175B34(capabilities::ct *a1)
{
  return !capabilities::ct::supportsCellRadio(a1) || *((unsigned char *)a1 + 737) != 0;
}

void sub_101175B70(uint64_t a1, int a2, int a3, char a4)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    void v6[2] = sub_101175C90;
    uint64_t v6[3] = &unk_101A95848;
    void v6[4] = a1;
    int v7 = a2;
    int v8 = a3;
    char v9 = a4;
    uint64_t v12 = 0;
    int v13 = 0;
    sub_10003E168(&v12, (void *)(a1 + 8));
    uint64_t v5 = *(NSObject **)(a1 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_101195718;
    block[3] = &unk_101A98BF0;
    block[5] = v12;
    char v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v6;
    dispatch_async(v5, block);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_101175C90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v5 = 0;
    int v6 = 0;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), &v5);
    if (v5)
    {
      (*(void (**)(uint64_t, void))(*(void *)v5 + 392))(v5, *(unsigned __int8 *)(a1 + 48));
    }
    else
    {
      uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(a1 + 40));
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Connection not found", v4, 2u);
      }
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_101175D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_101175DA4(uint64_t a1, int a2, int a3, char a4)
{
}

uint64_t sub_101175DAC(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 48);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_101175DF8(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
}

void sub_101175E00(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
  if (a3 < 36)
  {
    uint64_t v7 = *(void *)(a1 + 152);
    sub_100AE4C54(v7, a2, a3, a4);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315394;
      char v9 = "currentQosFlows";
      __int16 v10 = 2080;
      uint64_t v11 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type: %s", (uint8_t *)&v8, 0x16u);
    }
    QosFlowsContainerDefault = (void *)getQosFlowsContainerDefault();
    sub_100AE60F4(a4, QosFlowsContainerDefault);
  }
}

void sub_101175F24(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
}

void sub_101175F2C(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
}

void sub_101175F34(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
  if (a3 < 36)
  {
    uint64_t v12 = 0;
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    *(_OWORD *)long long __p = 0u;
    long long v9 = 0u;
    long long v7 = 0u;
    memset(v6, 0, sizeof(v6));
    sub_10000C004(*(void *)(a1 + 152), a2, a3, (uint64_t)v6);
    if (SBYTE7(v9) < 0)
    {
      sub_10004FC84((unsigned char *)a4, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)__p;
      *(void *)(a4 + 16) = v9;
    }
    sub_10005D9E0((uint64_t)&v11, *((void **)&v11 + 1));
    sub_10005DBA4(v10);
    if (SBYTE7(v9) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v7) < 0) {
      operator delete(*((void **)&v6[1] + 1));
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v6[0]) = 136315394;
      *(void *)((char *)v6 + 4) = "getApnNameByConnection";
      WORD6(v6[0]) = 2080;
      *(void *)((char *)v6 + 14) = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type: %s", (uint8_t *)v6, 0x16u);
    }
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
}

void sub_1011760A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1011760B4(uint64_t a1@<X0>, int a2@<W1>, signed int a3@<W2>, uint64_t a4@<X8>)
{
}

void sub_1011760BC(uint64_t a1, int a2, uint64_t a3, char a4, int a5, uint64_t a6)
{
  __int16 v10 = (void *)(a1 + 8);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_101176220;
  v12[3] = &unk_101A95868;
  int v17 = a2;
  void v12[4] = a1;
  long long __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_1011880B0(&__p, *(const void **)a6, *(void *)(a6 + 8), (uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 2);
  int v18 = a5;
  uint64_t v16 = a3;
  char v19 = a4;
  uint64_t v22 = 0;
  int v23 = 0;
  sub_10003E168(&v22, v10);
  long long v11 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v22;
  uint64_t v21 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v12;
  dispatch_async(v11, block);
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
}

void sub_101176220(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v18 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 72));
    if (*(void *)(*(void *)(v1 + 144) + 16) != v18)
    {
      uint64_t v3 = *(unsigned int **)(a1 + 40);
      uint64_t v20 = *(unsigned int **)(a1 + 48);
      if (v3 != v20)
      {
        int v4 = 0;
        uint64_t v19 = v1;
        while (1)
        {
          uint64_t v5 = *v3;
          if (validContextType()) {
            break;
          }
          long long v11 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = asString();
            *(_DWORD *)long long buf = 136315394;
            int v24 = "resetFatalActivationBlockers_block_invoke";
            __int16 v25 = 2080;
            uint64_t v26 = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", buf, 0x16u);
          }
LABEL_22:
          ++v3;
          uint64_t v1 = v19;
          if (v3 == v20) {
            goto LABEL_25;
          }
        }
        long long v7 = *(uint64_t **)(v18 + 56);
        int v6 = *(uint64_t **)(v18 + 64);
        while (1)
        {
          if (v7 == v6) {
            goto LABEL_22;
          }
          uint64_t v9 = *v7;
          int v8 = (std::__shared_weak_count *)v7[1];
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (!v9) {
            break;
          }
          if (*(_DWORD *)(a1 + 76) != 36)
          {
            uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 216))(v9, v5, 1, 1);
            if ((ConnectionTypeToMask() & v10) == 0) {
              break;
            }
          }
          v4 |= (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v9 + 432))(v9, v5, *(void *)(a1 + 64));
          if (*(unsigned char *)(a1 + 80)) {
            break;
          }
          v4 |= (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(*(void *)v9 + 424))(v9, v5, *(void *)(a1 + 64), 0, 0);
          if (v8) {
            goto LABEL_16;
          }
LABEL_17:
          v7 += 2;
        }
        if (!v8) {
          goto LABEL_17;
        }
LABEL_16:
        sub_10004D2C8(v8);
        goto LABEL_17;
      }
      LOBYTE(v4) = 0;
LABEL_25:
      int v13 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a1 + 64);
        uint64_t v15 = asString();
        uint64_t v16 = asStringBool(v4 & 1);
        *(_DWORD *)long long buf = 136315906;
        int v24 = "resetFatalActivationBlockers_block_invoke";
        __int16 v25 = 2080;
        uint64_t v26 = v14;
        __int16 v27 = 2080;
        uint64_t v28 = v15;
        __int16 v29 = 2080;
        uint64_t v30 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: %s: for %s: changed: %s", buf, 0x2Au);
      }
      if (v4)
      {
        uint64_t v17 = *(unsigned int *)(a1 + 72);
        sub_100058DB0(__p, "resetFatalActivationBlockers");
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v1 + 1328))(v1, v17, __p, 0);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
}

void sub_101176570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1011765A8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = (void *)(a1 + 40);
  v2[2] = 0;
  return sub_1011880B0(v2, *(const void **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 2);
}

void sub_1011765C4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_1011765DC(uint64_t a1, int a2, uint64_t a3, char a4, int a5, uint64_t a6)
{
}

uint64_t sub_1011765E4(void *a1, unsigned int a2)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = a1[19];
  int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  sub_100AE43CC(v3, v4, a2, (uint64_t)v6);
  return LODWORD(v6[0]);
}

uint64_t sub_101176670(uint64_t a1, unsigned int a2)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = *(void *)(a1 + 96);
  int v4 = (*(uint64_t (**)(void))(*(void *)(a1 - 56) + 1088))();
  sub_100AE43CC(v3, v4, a2, (uint64_t)v6);
  return LODWORD(v6[0]);
}

uint64_t sub_1011766FC(void *a1, unsigned int a2)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = a1[19];
  int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  sub_100AE43CC(v3, v4, a2, (uint64_t)v6);
  return DWORD1(v6[0]);
}

uint64_t sub_101176788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  uint64_t v10 = *(void *)(a1 - 56);
  uint64_t v9 = a1 - 56;
  uint64_t v11 = *(void *)(v9 + 152);
  int v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, void, void, void, void, void, void, void))(v10 + 1088))(v9, a2, a3, a4, a5, a6, a7, a8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  sub_100AE43CC(v11, v12, v8, (uint64_t)v14);
  return DWORD1(v14[0]);
}

uint64_t sub_101176814(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4584);
}

uint64_t sub_101176820(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4528);
}

void sub_10117682C(uint64_t a1, int a2, int a3, double a4, double a5)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_101176944;
  v7[3] = &unk_101A95898;
  void v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  *(double *)&void v7[5] = a4;
  *(double *)&void v7[6] = a5;
  uint64_t v12 = 0;
  int v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  int v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101176944(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288) && sub_100AF2240(*(void *)(v1 + 144), *(_DWORD *)(a1 + 56)))
  {
    uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(a1 + 56));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 60);
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = *(void *)(a1 + 48);
      LODWORD(v12) = 67109632;
      HIDWORD(v12) = v4;
      *(_WORD *)int v13 = 2048;
      *(void *)&std::string v13[2] = v5;
      __int16 v14 = 2048;
      uint64_t v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I updateInactivityTimeout: id=%u, timeout=%f, checkpoint=%f", (uint8_t *)&v12, 0x1Cu);
    }
    uint64_t v12 = 0;
    *(void *)int v13 = 0;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 56), 0, &v12);
    if (v12 && !*(_DWORD *)(a1 + 60)) {
      (*(void (**)(double))(*(void *)v12 + 280))(*(double *)(a1 + 40));
    }
    unint64_t v7 = *(unsigned int *)(a1 + 60);
    if ((v7 & 0x80000000) == 0)
    {
      uint64_t v8 = *(void *)(v1 + 4136);
      if (v7 < (*(void *)(v1 + 4144) - v8) >> 4)
      {
        int v9 = (uint64_t *)(v8 + 16 * v7);
        uint64_t v10 = *v9;
        uint64_t v11 = (std::__shared_weak_count *)v9[1];
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v10) {
          (*(void (**)(uint64_t, double, double))(*(void *)v10 + 128))(v10, *(double *)(a1 + 40) * 1000.0, *(double *)(a1 + 48) * 1000.0);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
    }
    if (*(void *)v13) {
      sub_10004D2C8(*(std::__shared_weak_count **)v13);
    }
  }
}

void sub_101176B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101176B60(uint64_t a1, int a2, int a3, double a4, double a5)
{
}

void sub_101176B68(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v5)
  {
    uint64_t v6 = *(uint64_t **)v5;
    unint64_t v7 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v7)
    {
      do
      {
        uint64_t v8 = *v6;
        int v9 = (std::__shared_weak_count *)v6[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)v8 + 520))(v8, a3, 1, 0, 0);
        }
        if (v9) {
          sub_10004D2C8(v9);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
}

void sub_101176C2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101176C44(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_101176C4C(uint64_t a1, int a2, int a3, int a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_101176D64;
  uint64_t v6[3] = &unk_101A958B8;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  int v9 = a4;
  uint64_t v12 = 0;
  int v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101176D64(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    if (*(unsigned char *)(v2 + 312))
    {
      int v3 = *(_DWORD *)(a1 + 40);
      uint64_t v4 = *(unsigned int *)(a1 + 44);
      int v5 = *(_DWORD *)(a1 + 48);
      sub_1011706F8(v2, v3, v4, v5);
    }
    else
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315138;
        int v8 = "postConnectionStateChangeNotification_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void sub_101176E60(uint64_t a1, int a2, int a3, int a4)
{
}

void sub_101176E68(uint64_t a1, int a2, int a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_101176F80;
  uint64_t v6[3] = &unk_101A958D8;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  char v9 = a4;
  uint64_t v12 = 0;
  int v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  int v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101176F80(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v3 = *(void *)(v1 + 112);
    *(void *)&long long buf = *(void *)(v1 + 104);
    *((void *)&buf + 1) = v3;
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    subscriber::makeSimSlotRange();
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    uint64_t v4 = v13;
    if (v13 != v14)
    {
      do
      {
        if (v15(*v4)) {
          goto LABEL_11;
        }
        ++v4;
      }
      while (v4 != v14);
      uint64_t v4 = v14;
LABEL_11:
      if (v4 == v14) {
        return;
      }
      do
      {
        uint64_t v5 = *v4;
        uint64_t v6 = sub_10003B004(*(void *)(v1 + 144), *v4);
        if (*(void *)(*(void *)(v1 + 144) + 16) != v6)
        {
          if (!*(unsigned char *)(v1 + 312))
          {
            uint64_t v12 = *(NSObject **)(v1 + 40);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = "reactivateAssertedAndPostStatus_block_invoke";
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&buf, 0xCu);
            }
            return;
          }
          DataServiceController::reactivateAsserted_sync(v1, v5, *(unsigned int *)(a1 + 44), *(unsigned __int8 *)(a1 + 48));
          int v7 = *(uint64_t **)v6;
          int v8 = *(uint64_t **)(v6 + 8);
          while (v7 != v8)
          {
            uint64_t v9 = *v7;
            uint64_t v10 = (std::__shared_weak_count *)v7[1];
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v9) {
              (*(void (**)(uint64_t, void, void, void, void))(*(void *)v9 + 520))(v9, *(unsigned int *)(a1 + 44), 0, 0, 0);
            }
            if (v10) {
              sub_10004D2C8(v10);
            }
            v7 += 2;
          }
        }
        uint64_t v11 = v4 + 1;
        uint64_t v4 = v14;
        if (v11 != v14)
        {
          uint64_t v4 = v11;
          while ((v15(*v4) & 1) == 0)
          {
            if (++v4 == v14)
            {
              uint64_t v4 = v14;
              break;
            }
          }
        }
      }
      while (v4 != v14);
    }
  }
}

void sub_1011771B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011771E4(uint64_t a1, int a2, int a3, char a4)
{
}

void sub_1011771EC(uint64_t a1, int a2, int a3, char a4)
{
}

void sub_1011771F4(uint64_t a1, int a2, int a3, int a4, char a5)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_101177310;
  v7[3] = &unk_101A958F8;
  void v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  char v11 = a5;
  int v10 = a4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v14;
  int v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_101177310(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  __int16 v25 = 0;
  memset(v24, 0, sizeof(v24));
  DataServiceController::canActivateConnection_sync(v1, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), (uint64_t)v24);
  uint64_t v3 = *(void *)(v1 + 112);
  *(void *)long long buf = *(void *)(v1 + 104);
  *(void *)&uint8_t buf[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v4 = v21;
  uint64_t v5 = v22;
  if (v21 == v22) {
    goto LABEL_40;
  }
  uint64_t v6 = v23;
  while ((v23(*v4) & 1) == 0)
  {
    if (++v4 == v22)
    {
      uint64_t v4 = v22;
      break;
    }
  }
  int v7 = v22;
  if (v4 == v22) {
    goto LABEL_40;
  }
  uint64_t v18 = v22;
  uint64_t v19 = v1;
  do
  {
    int v8 = *v4;
    uint64_t v9 = sub_10003B004(*(void *)(v1 + 144), *v4);
    if (*(void *)(*(void *)(v1 + 144) + 16) == v9) {
      goto LABEL_34;
    }
    uint64_t v20 = 0;
    char v11 = *(uint64_t **)v9;
    int v10 = *(uint64_t **)(v9 + 8);
    while (v11 != v10)
    {
      uint64_t v13 = *v11;
      uint64_t v12 = (std::__shared_weak_count *)v11[1];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v13)
      {
        int v16 = 5;
        if (!v12) {
          goto LABEL_28;
        }
LABEL_27:
        sub_10004D2C8(v12);
        goto LABEL_28;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 472))(v13) == *(_DWORD *)(a1 + 44)
        && (*(unsigned int (**)(uint64_t, char *, uint64_t *, void))(*(void *)v13 + 216))(v13, (char *)&v20 + 4, &v20, *(unsigned __int8 *)(a1 + 52))&& (*(unsigned int (**)(uint64_t))(*(void *)v13 + 224))(v13))
      {
        uint64_t v14 = *(NSObject **)(v19 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = "reactivateAssertedConnection_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Activating %s...", buf, 0x16u);
        }
        DataServiceController::enableContextStateChangeNotificationRepost(v19, v8, *(_DWORD *)(a1 + 44), (uint64_t)"reactivation required", 0);
        (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v13 + 88))(v13, "reactivate asserted", "CommCenter", 0, 0);
        (*(void (**)(uint64_t, void, void, void, void))(*(void *)v13 + 520))(v13, *(unsigned int *)(a1 + 48), 0, 0, 0);
        int v16 = 1;
        if (v12) {
          goto LABEL_27;
        }
      }
      else
      {
        int v16 = 0;
        if (v12) {
          goto LABEL_27;
        }
      }
LABEL_28:
      if (v16 != 5 && v16) {
        goto LABEL_41;
      }
      v11 += 2;
    }
    int v7 = v18;
    unint64_t v1 = v19;
LABEL_34:
    uint64_t v17 = v4 + 1;
    uint64_t v4 = v5;
    if (v17 != v5)
    {
      uint64_t v4 = v17;
      while ((v6(*v4) & 1) == 0)
      {
        if (++v4 == v5)
        {
          uint64_t v4 = v5;
          break;
        }
      }
    }
  }
  while (v4 != v7);
LABEL_40:
  sub_101174050(v1, *(unsigned int *)(a1 + 40), 0, v24[0]);
LABEL_41:
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_1011776AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_101177700(uint64_t a1, int a2, int a3, int a4, char a5)
{
}

void sub_101177708(uint64_t a1, int a2, int a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_101177820;
  uint64_t v6[3] = &unk_101A95918;
  void v6[4] = a1;
  int v7 = a3;
  int v8 = a2;
  char v9 = a4;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  char v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101177820(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    if (*(unsigned char *)(v2 + 312))
    {
      uint64_t v4 = *(unsigned int *)(a1 + 40);
      uint64_t v3 = *(unsigned int *)(a1 + 44);
      int v5 = *(unsigned __int8 *)(a1 + 48);
      DataServiceController::reactivateAsserted_sync(v2, v3, v4, v5);
    }
    else
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315394;
        int v8 = "reactivateAsserted_block_invoke";
        __int16 v9 = 2080;
        uint64_t v10 = asStringConnectionStateChangeReason();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start: %s", (uint8_t *)&v7, 0x16u);
      }
    }
  }
}

void sub_101177930(uint64_t a1, int a2, int a3, char a4)
{
}

void sub_101177938(uint64_t a1, int a2, int a3, char a4)
{
}

void sub_101177940(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  if (!*(unsigned char *)(v1 + 312))
  {
    uint64_t v12 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      int v24 = "reactivateAsserted_block_invoke";
      __int16 v25 = 2080;
      uint64_t v26 = asStringConnectionStateChangeReason();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start: %s", buf, 0x16u);
    }
    return;
  }
  int v2 = *(_DWORD *)(a1 + 60);
  int v3 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = sub_10003B004(*(void *)(v1 + 144), v2);
  if (*(void *)(*(void *)(v1 + 144) + 16) == v6 || v5 == 0) {
    goto LABEL_38;
  }
  int v8 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asStringConnectionStateChangeReason();
    uint64_t v10 = asStringBool(v3 != 0);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5);
    *(_DWORD *)long long buf = 136315906;
    int v24 = "reactivateAsserted_sync";
    __int16 v25 = 2080;
    uint64_t v26 = v9;
    __int16 v27 = 2080;
    uint64_t v28 = v10;
    __int16 v29 = 2080;
    uint64_t v30 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s:  due to %s force=%s connection=%s", buf, 0x2Au);
  }
  uint64_t v22 = 0;
  if (!(*(unsigned int (**)(uint64_t, char *, uint64_t *, BOOL))(*(void *)v5 + 216))(v5, (char *)&v22 + 4, &v22, v3 != 0))goto LABEL_38; {
  uint64_t v13 = *(uint64_t **)v6;
  }
  uint64_t v14 = *(uint64_t **)(v6 + 8);
  if (*(uint64_t **)v6 == v14) {
    goto LABEL_35;
  }
  char v20 = 0;
  do
  {
    uint64_t v15 = *v13;
    int v16 = (std::__shared_weak_count *)v13[1];
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v15)
    {
      if (v5 == v15
        || (*(_DWORD *)long long buf = -1,
            unsigned int v21 = 0,
            !(*(unsigned int (**)(uint64_t, uint8_t *, unsigned int *, BOOL))(*(void *)v15 + 216))(v15, buf, &v21, v3 != 0))|| HIDWORD(v22) != *(_DWORD *)buf|| v22 <= v21)
      {
        int v17 = 0;
        if (!v16) {
          goto LABEL_28;
        }
LABEL_27:
        sub_10004D2C8(v16);
        goto LABEL_28;
      }
      int v17 = 6;
      char v20 = 1;
      if (v16) {
        goto LABEL_27;
      }
    }
    else
    {
      int v17 = 7;
      if (v16) {
        goto LABEL_27;
      }
    }
LABEL_28:
    if (v17 != 7 && v17) {
      break;
    }
    v13 += 2;
  }
  while (v13 != v14);
  if ((v20 & 1) == 0)
  {
LABEL_35:
    uint64_t v18 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5);
      *(_DWORD *)long long buf = 136315394;
      int v24 = "reactivateAsserted_sync";
      __int16 v25 = 2080;
      uint64_t v26 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s: trying to reactivate %s", buf, 0x16u);
    }
    (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v5 + 88))(v5, "reactivate asserted", "CommCenter", 0, 0);
  }
LABEL_38:
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_101177D4C(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101177D80(uint64_t a1, int a2, unint64_t a3)
{
  signed int v5 = ConnectionMaskToType(a3);
  if (v5 < 36)
  {
    memset(v13, 0, sizeof(v13));
    *(_OWORD *)long long __p = 0u;
    long long v12 = 0u;
    *(_OWORD *)long long buf = 0u;
    sub_10003009C(*(void *)(a1 + 152), a2, v5, (uint64_t)buf);
    uint64_t v7 = *(unsigned int *)buf;
    uint64_t v9 = (void **)v13;
    sub_100047F64(&v9);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "getIdByMask";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", buf, 0xCu);
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

uint64_t sub_101177E94(uint64_t a1, int a2, unint64_t a3)
{
  return sub_101177D80(a1 - 56, a2, a3);
}

BOOL sub_101177E9C(uint64_t a1, int a2, unint64_t a3, unsigned int a4)
{
  signed int v7 = ConnectionMaskToType(a3);
  if (v7 < 36)
  {
    if (a4 > 1) {
      return 0;
    }
    memset(v15, 0, sizeof(v15));
    *(_OWORD *)long long __p = 0u;
    long long v14 = 0u;
    *(_OWORD *)long long buf = 0u;
    sub_10003009C(*(void *)(a1 + 152), a2, v7, (uint64_t)buf);
    BOOL v9 = buf[a4 + 4] != 0;
    uint64_t v11 = (void **)v15;
    sub_100047F64(&v11);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
    int v8 = *(NSObject **)(a1 + 40);
    BOOL v9 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "getContextConfiguredByMask";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", buf, 0xCu);
      return 0;
    }
  }
  return v9;
}

BOOL sub_101177FD8(uint64_t a1, int a2, unint64_t a3, unsigned int a4)
{
  return sub_101177E9C(a1 - 56, a2, a3, a4);
}

void sub_101177FE0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void sub_101177FE8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

uint64_t sub_101177FF0(void *a1)
{
  (*(void (**)(void *__return_ptr))(*a1 + 304))(v5);
  BOOL v2 = LODWORD(v5[0]) != 0;
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v3 = a1[520];
  if (v3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  return v2;
}

uint64_t sub_101178094(uint64_t a1)
{
  return sub_101177FF0((void *)(a1 - 56));
}

uint64_t sub_10117809C(uint64_t a1, int a2, int a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  DataServiceController::getConnection_sync(a1, a2, a3, &v10);
  if (v10)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 200))(v10);
    uint64_t v6 = sub_1011781EC(a1, a2, v5);
  }
  else
  {
    signed int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      *(_DWORD *)long long buf = 136315394;
      uint64_t v13 = "getIdByConnection_sync";
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: no connection %s", buf, 0x16u);
    }
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v6;
}

void sub_1011781C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011781EC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if ((a3 & 0x80000000) != 0)
  {
    uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
    if (*(void *)(*(void *)(a1 + 144) + 16) != v5)
    {
      uint64_t v6 = *(char **)(v5 + 24);
      if (!v6
        || !(*(unsigned int (**)(char *))(*(void *)&v6[*(void *)(*(void *)v6 - 320)] + 40))(&v6[*(void *)(*(void *)v6 - 320)]))
      {
        return 4294967294;
      }
    }
  }
  return v3;
}

uint64_t sub_101178280(uint64_t a1, int a2, int a3)
{
  return sub_10117809C(a1 - 56, a2, a3);
}

uint64_t sub_101178288(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  DataServiceController::getConnection_sync(a1, a2, a3, &v10);
  if (v10)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 208))(v10, a4);
  }
  else
  {
    signed int v7 = *(NSObject **)(a1 + 40);
    uint64_t v6 = 0;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      *(_DWORD *)long long buf = 136315394;
      uint64_t v13 = "isContextConfiguredByConnection_sync";
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: no connection %s", buf, 0x16u);
      uint64_t v6 = 0;
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v6;
}

void sub_1011783AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011783D0(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return sub_101178288(a1 - 72, a2, a3, a4);
}

uint64_t sub_1011783D8(std::__shared_weak_count *a1, int a2)
{
  void (***v16)(uint64_t *__return_ptr, void, uint64_t);
  char v17;
  char v18;
  uint64_t *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t v24;

  shared_owners = (uint64_t *)a1[35].__shared_owners_;
  p_shared_weak_owners = &a1[35].__shared_weak_owners_;
  if (shared_owners == &a1[35].__shared_weak_owners_) {
    return 0;
  }
  uint64_t v5 = a1;
  while (!*((unsigned char *)shared_owners + 56))
  {
LABEL_26:
    uint64_t v19 = (uint64_t *)shared_owners[1];
    if (v19)
    {
      do
      {
        char v20 = v19;
        uint64_t v19 = (uint64_t *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        char v20 = (uint64_t *)shared_owners[2];
        unsigned int v21 = *v20 == (void)shared_owners;
        shared_owners = v20;
      }
      while (!v21);
    }
    shared_owners = v20;
    if (v20 == p_shared_weak_owners) {
      return 0;
    }
  }
  if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
    return 1;
  }
  uint64_t result = 1;
  if (!a2 || a2 == 3) {
    return result;
  }
  uint64_t v22 = 0;
  int v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, (Registry *)v5[4].__shared_owners_);
  BOOL v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  int v24 = v10;
  __int16 v14 = sub_10004D37C(&v9[1].__m_.__sig, &v24);
  if (v14)
  {
    int v16 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      int v17 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    int v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  int v17 = 1;
LABEL_15:
  (**v16)(&v22, v16, (uint64_t)(shared_owners + 4));
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v22)
  {
    if (*(unsigned char *)(v22 + 49))
    {
      if (a2 == 1)
      {
LABEL_20:
        uint64_t v18 = 1;
        goto LABEL_23;
      }
    }
    else if (*(_DWORD *)(v22 + 52) == a2)
    {
      goto LABEL_20;
    }
  }
  uint64_t v18 = 0;
LABEL_23:
  a1 = v23;
  if (v23) {
    sub_10004D2C8(v23);
  }
  if ((v18 & 1) == 0) {
    goto LABEL_26;
  }
  return 1;
}

void sub_1011785B0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011785CC(uint64_t a1, int a2)
{
  return sub_1011783D8((std::__shared_weak_count *)(a1 - 56), a2);
}

uint64_t sub_1011785D4(uint64_t a1, int a2)
{
  return sub_1011783D8((std::__shared_weak_count *)(a1 - 64), a2);
}

uint64_t sub_1011785DC(uint64_t a1, int a2)
{
  return sub_1011783D8((std::__shared_weak_count *)(a1 - 72), a2);
}

uint64_t sub_1011785E4()
{
  return isActive();
}

uint64_t sub_1011785EC()
{
  return isActive();
}

uint64_t sub_1011785F4(uint64_t a1, int a2, unint64_t a3)
{
  int v5 = ConnectionMaskToType(a3);
  if (v5 > 35)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "getActiveAndIdByMask";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", buf, 0xCu);
    }
    goto LABEL_11;
  }
  unsigned int v6 = v5;
  if (!sub_100030AFC(*(void *)(a1 + 152), a2))
  {
LABEL_11:
    uint64_t v10 = 0;
    uint64_t v9 = 0xFFFFFFFFLL;
    return v9 | v10;
  }
  memset(v17, 0, sizeof(v17));
  *(_OWORD *)long long __p = 0u;
  long long v16 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_10003009C(*(void *)(a1 + 152), a2, v6, (uint64_t)buf);
  uint64_t v7 = buf[12];
  unsigned int v8 = *(_DWORD *)&buf[8];
  unsigned int v13 = (void **)v17;
  sub_100047F64(&v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  if (v8 == -3) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = v8;
  }
  uint64_t v10 = v7 << 32;
  return v9 | v10;
}

uint64_t sub_101178744(uint64_t a1, int a2, unint64_t a3)
{
  return sub_1011785F4(a1 - 56, a2, a3);
}

uint64_t sub_101178764(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 4180));
}

uint64_t sub_101178774(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 4124));
}

BOOL sub_101178784(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 312))
  {
    signed int v7 = ConnectionMaskToType(a3);
    if (v7 < 36)
    {
      memset(v18, 0, sizeof(v18));
      long long v17 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_10003009C(*(void *)(a1 + 152), a2, v7, (uint64_t)buf);
      BOOL v9 = buf[16] != 0;
      uint64_t v15 = (void **)v18;
      sub_100047F64(&v15);
      if (SHIBYTE(v17) < 0) {
        operator delete(*(void **)&buf[24]);
      }
    }
    else
    {
      unsigned int v8 = *(NSObject **)(a1 + 40);
      BOOL v9 = 0;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "getActiveByMask";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = asString();
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = a4;
        uint64_t v10 = "#I %s: Wrong Connection type %s (%s)";
        uint64_t v11 = v8;
        uint32_t v12 = 32;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
        return 0;
      }
    }
  }
  else
  {
    unsigned int v13 = *(NSObject **)(a1 + 40);
    BOOL v9 = 0;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "getActiveByMask";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a4;
      uint64_t v10 = "#E %s: !!! too early start: %s";
      uint64_t v11 = v13;
      uint32_t v12 = 22;
      goto LABEL_7;
    }
  }
  return v9;
}

BOOL sub_101178938(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  return sub_101178784(a1 - 56, a2, a3, a4);
}

uint64_t sub_101178940(uint64_t a1, int a2, unint64_t a3)
{
  if (!*(unsigned char *)(a1 + 312))
  {
    unsigned int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      uint64_t v10 = "getActiveByMask_sync";
      signed int v7 = "#E %s: !!! too early start";
      goto LABEL_7;
    }
    return 0;
  }
  int v5 = ConnectionMaskToType(a3);
  if (v5 >= 36)
  {
    unsigned int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      uint64_t v10 = "getActiveByMask_sync";
      signed int v7 = "#I %s: Wrong Connection type";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v9, 0xCu);
      return 0;
    }
    return 0;
  }

  return sub_101178A88(a1, a2, v5);
}

uint64_t sub_101178A88(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  DataServiceController::getConnection_sync(a1, a2, a3, &v5);
  if (v5) {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 168))(v5);
  }
  else {
    uint64_t v3 = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v3;
}

void sub_101178B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101178B18(uint64_t a1, int a2, unint64_t a3)
{
  return sub_101178940(a1 - 56, a2, a3);
}

uint64_t DataServiceController::getActiveNetworkByConnection_sync(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  DataServiceController::getConnection_sync(a1, a2, a3, &v5);
  if (v5) {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 192))(v5);
  }
  else {
    uint64_t v3 = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v3;
}

void sub_101178B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101178BB0(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 312))
  {
    uint64_t v9 = 0;
    memset(v8, 0, sizeof(v8));
    uint64_t v3 = *(void *)(a1 + 152);
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
    sub_100AE43CC(v3, v4, a2, (uint64_t)v8);
    return BYTE8(v8[0]) != 0;
  }
  else
  {
    unsigned int v6 = *(NSObject **)(a1 + 40);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (v7)
    {
      LODWORD(v8[0]) = 136315138;
      *(void *)((char *)v8 + 4) = "getActiveById";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)v8, 0xCu);
      return 0;
    }
  }
  return result;
}

BOOL sub_101178CD8(uint64_t a1, unsigned int a2)
{
  return sub_101178BB0(a1 - 56, a2);
}

uint64_t sub_101178CE0@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t result = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == result || (unsigned int v6 = *(void **)(result + 24)) == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    BOOL v7 = *(uint64_t (**)(void))(*(void *)((char *)v6 + *(void *)(*v6 - 320)) + 88);
    return v7();
  }
  return result;
}

uint64_t sub_101178D88@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  return sub_101178CE0(a1 - 56, a2, a3);
}

void sub_101178D90(uint64_t a1, int a2, int a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_101178EA8;
  uint64_t v6[3] = &unk_101A95968;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  char v9 = a4;
  uint64_t v12 = 0;
  unsigned int v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_101178EA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288)) {
    sub_1011673E4(v2, *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), *(unsigned char *)(a1 + 48));
  }
}

void sub_101178EC8(uint64_t a1, int a2, int a3, char a4)
{
}

uint64_t sub_101178ED0(void *a1, unsigned int a2, void *a3)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  long long v9 = 0u;
  uint64_t v5 = a1[19];
  int v6 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  sub_100AE43CC(v5, v6, a2, (uint64_t)&v9);
  uint64_t v7 = (int)v11;
  memcpy(a3, v10, 8 * (int)v11);
  return v7;
}

uint64_t sub_101178F84(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v4 = a2;
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  long long v11 = 0u;
  uint64_t v6 = *(void *)(a1 - 56);
  uint64_t v5 = a1 - 56;
  uint64_t v7 = *(void *)(v5 + 152);
  int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 1088))(v5, a2);
  sub_100AE43CC(v7, v8, v4, (uint64_t)&v11);
  uint64_t v9 = (int)v13;
  memcpy(a3, v12, 8 * (int)v13);
  return v9;
}

void sub_101179038(uint64_t a1, int a2, long long *a3, char a4)
{
  uint64_t v6 = (void *)(a1 + 8);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  v8[2] = sub_101179194;
  v8[3] = &unk_101A95988;
  v8[4] = a1;
  int v11 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v10 = *((void *)a3 + 2);
  }
  char v12 = a4;
  uint64_t v15 = 0;
  long long v16 = 0;
  sub_10003E168(&v15, v6);
  uint64_t v7 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v15;
  __int16 v14 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v8;
  dispatch_async(v7, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__p);
  }
}

void sub_101179194(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    if (*(unsigned char *)(v2 + 312))
    {
      uint64_t v3 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      uint64_t v4 = *(unsigned int *)(a1 + 64);
      uint64_t v5 = *(unsigned __int8 *)(a1 + 68);
      sub_1011792A4((void *)v2, v4, (uint64_t)v3, v5, 0);
    }
    else
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315138;
        int v8 = "reInitThrottleTimer_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void sub_1011792A4(void *a1, uint64_t a2, uint64_t a3, BOOL a4, char a5)
{
  int v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "reInitThrottleTimer_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a3;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v26 = asStringBool(a4);
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: %s resetThrottleCounter=%s", buf, 0x20u);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[14];
  int v24 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v24) {
    sub_10004D2C8(v24);
  }
  int v11 = *(int **)buf;
  uint64_t v10 = *(int **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8])
  {
    char v12 = *(uint64_t (**)(void))&buf[16];
    while ((v12(*v11) & 1) == 0)
    {
      if (++v11 == v10)
      {
        int v11 = v10;
        break;
      }
    }
    uint64_t v13 = *(int **)&buf[8];
    for (i = *(int **)&buf[8]; v11 != v13; uint64_t v13 = i)
    {
      uint64_t v14 = sub_10003B004(a1[18], *v11);
      if (*(void *)(a1[18] + 16) == v14) {
        break;
      }
      if ((a5 & 1) == 0)
      {
        if (qword_101B14190)
        {
          uint64_t v15 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
          if (v15)
          {
            long long v16 = v15;
            if (DataPlanManagerBootstrap::sInstance) {
              (*(void (**)(uint64_t))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 128))(DataPlanManagerBootstrap::sInstance + 8);
            }
            sub_10004D2C8(v16);
          }
        }
      }
      long long v17 = *(uint64_t **)(v14 + 56);
      uint64_t v18 = *(uint64_t **)(v14 + 64);
      while (v17 != v18)
      {
        uint64_t v20 = *v17;
        uint64_t v19 = (std::__shared_weak_count *)v17[1];
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v20
          && ((a5 & 1) == 0
           || ((*(uint64_t (**)(uint64_t, void))(*(void *)v20 + 56))(v20, 0) & 1) != 0
           || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 56))(v20, 1) & 1) != 0))
        {
          (*(void (**)(uint64_t, BOOL))(*(void *)v20 + 600))(v20, a4);
        }
        if (v19) {
          sub_10004D2C8(v19);
        }
        v17 += 2;
      }
      unsigned int v21 = v11 + 1;
      int v11 = v10;
      if (v21 != v10)
      {
        int v11 = v21;
        while ((v12(*v11) & 1) == 0)
        {
          if (++v11 == v10)
          {
            int v11 = v10;
            break;
          }
        }
      }
    }
  }
}

void sub_10117959C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011795D4(uint64_t a1, int a2, long long *a3, char a4)
{
}

void sub_1011795DC(void *a1, int a2, unint64_t a3)
{
  if (sub_100AF2240(a1[18], a2))
  {
    int v6 = ConnectionMaskToType(a3);
    if (v6 < 36)
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000;
      void v9[2] = sub_1011797A0;
      v9[3] = &unk_101A959B8;
      void v9[4] = a1;
      int v10 = a2;
      int v11 = v6;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      sub_10003E168(&v12, a1 + 1);
      int v8 = a1[3];
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 1174405120;
      uint64_t v15 = sub_101195718;
      long long v16 = &unk_101A98BF0;
      uint64_t v18 = v12;
      uint64_t v19 = v13;
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v17 = v9;
      dispatch_async(v8, &buf);
      if (v19) {
        sub_10004D2C8(v19);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
    }
    else
    {
      int v7 = a1[5];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "resetThrottlingByConnection";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", (uint8_t *)&buf, 0xCu);
      }
    }
  }
}

void sub_101179794(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1011797A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v7 = 0;
    int v8 = 0;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), &v7);
    if (v7)
    {
      unsigned int v2 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 200))(v7);
      if ((v2 & 0x80000000) == 0)
      {
        uint64_t v3 = *(void *)(v1 + 4136);
        if (v2 < (unint64_t)((*(void *)(v1 + 4144) - v3) >> 4))
        {
          uint64_t v4 = (uint64_t *)(v3 + 16 * v2);
          uint64_t v5 = *v4;
          int v6 = (std::__shared_weak_count *)v4[1];
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v5) {
            (*(void (**)(uint64_t, void))(*(void *)v5 + 168))(v5, 0);
          }
          if (v6) {
            sub_10004D2C8(v6);
          }
        }
      }
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
}

void sub_101179888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011798B4(uint64_t a1, int a2, unint64_t a3)
{
}

void sub_1011798BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    DataServiceController::getConnection_sync(v2, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), &v3);
    if (v3) {
      (*(void (**)(uint64_t, void))(*(void *)v3 + 232))(v3, *(unsigned __int8 *)(a1 + 48));
    }
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

void sub_10117993C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101179954(uint64_t a1, unint64_t a2, char a3)
{
}

uint64_t sub_10117995C(uint64_t a1)
{
  uint64_t v1 = *(os_unfair_lock_s **)(a1 + 152);
  uint64_t v2 = v1 + 6;
  os_unfair_lock_lock(v1 + 6);
  uint64_t os_unfair_lock_opaque = v1[20]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque;
}

uint64_t sub_101179998(uint64_t a1)
{
  uint64_t v1 = *(os_unfair_lock_s **)(a1 + 96);
  uint64_t v2 = v1 + 6;
  os_unfair_lock_lock(v1 + 6);
  uint64_t os_unfair_lock_opaque = v1[20]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque;
}

void sub_1011799D4(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v17 = 0;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a4;
    uint64_t v17 = *(void *)(a4 + 16);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  _DWORD v10[2] = sub_101179B90;
  _OWORD v10[3] = &unk_101A959F8;
  void v10[4] = a1;
  int v13 = a2;
  int v14 = a3;
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    long long __p = *(_OWORD *)__dst;
    uint64_t v12 = v17;
  }
  int v15 = a5;
  uint64_t v20 = 0;
  unsigned int v21 = 0;
  sub_10003E168(&v20, (void *)(a1 + 8));
  uint64_t v9 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v20;
  uint64_t v19 = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v10;
  dispatch_async(v9, block);
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_101179B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101179B90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      uint64_t v2 = *(unsigned int *)(a1 + 64);
      uint64_t v3 = *(unsigned int *)(a1 + 68);
      uint64_t v4 = *(unsigned int *)(a1 + 72);
      uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v1 + 2072);
      uint64_t v6 = a1 + 40;
      uint64_t v7 = *(void *)(a1 + 32);
      v5(v7, v2, v3, v6, v4);
    }
    else
    {
      int v8 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 136315138;
        int v10 = "handlePacketContextCellChanged_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v9, 0xCu);
      }
    }
  }
}

void sub_101179CB8(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
}

void sub_101179CC0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(void *)(a1 + 112);
  *(void *)long long buf = *(void *)(a1 + 104);
  *(void *)&uint8_t buf[8] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  unsigned int v62 = a5;
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  int v8 = v71;
  if (v71 != v72)
  {
    while ((v73(*v8) & 1) == 0)
    {
      if (++v8 == v72)
      {
        int v8 = v72;
        break;
      }
    }
    uint64_t v61 = v72;
    if (v8 != v72)
    {
      uint64_t v63 = v6;
      int v59 = v73;
      uint64_t v60 = v72;
      while (1)
      {
        unsigned int v65 = *v8;
        uint64_t v9 = sub_10003B004(*(void *)(v6 + 144), *v8);
        if (*(void *)(*(void *)(v6 + 144) + 16) == v9) {
          return;
        }
        if (a3)
        {
          uint64_t v10 = *(void *)(v6 + 152);
          int v11 = (os_unfair_lock_s *)(v10 + 24);
          os_unfair_lock_lock((os_unfair_lock_t)(v10 + 24));
          int v12 = *(unsigned __int8 *)(v10 + 84);
          os_unfair_lock_unlock(v11);
        }
        else
        {
          int v12 = sub_101163798((void *)v6);
        }
        int v13 = (capabilities::ct *)qword_101B14190;
        if (qword_101B14190)
        {
          int v13 = (capabilities::ct *)std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
          int v14 = v13;
          if (v13) {
            uint64_t v15 = DataPlanManagerBootstrap::sInstance;
          }
          else {
            uint64_t v15 = 0;
          }
        }
        else
        {
          uint64_t v15 = 0;
          int v14 = 0;
        }
        int v16 = capabilities::ct::supportsDataPlanNotifications(v13);
        if (v15) {
          int v17 = v16;
        }
        else {
          int v17 = 0;
        }
        if (v17 == 1) {
          unsigned int v18 = (*(uint64_t (**)(void))(*(void *)(v15 + 8) + 96))();
        }
        else {
          unsigned int v18 = 1;
        }
        uint64_t v19 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = asStringBool(v12 != 0);
          uint64_t v21 = asStringBool(v18);
          if (*((char *)a4 + 23) >= 0) {
            uint64_t v22 = a4;
          }
          else {
            uint64_t v22 = (uint64_t *)*a4;
          }
          *(_DWORD *)long long buf = 136316162;
          *(void *)&uint8_t buf[4] = "handlePacketContextCellChanged_sync";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v20;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v76 = v21;
          __int16 v77 = 1024;
          unsigned int v78 = a3;
          __int16 v79 = 2080;
          int v80 = v22;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: dataAllowedAvailability: %s, dataPlanAllow: %s, type: %d, reason %s", buf, 0x30u);
        }
        uint64_t v64 = (std::__shared_weak_count *)v14;
        if (v12) {
          uint64_t v23 = v18;
        }
        else {
          uint64_t v23 = 0;
        }
        if (a3 != 1)
        {
          unint64_t v26 = 0;
          uint64_t v25 = 0;
          LOBYTE(v24) = a3 == 0;
          goto LABEL_61;
        }
        unint64_t v24 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 1032))(v6, v65);
        uint64_t v25 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 1056))(v6, v65);
        unint64_t v26 = HIDWORD(v24);
        __int16 v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), v65);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = asStringBool(v24 != 0);
          uint64_t v29 = asStringBool(v25);
          uint64_t v30 = asString();
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v28;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v29;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v76 = v30;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I packetContextCellChanged: isInHomeCountry = %s isDataRoamingAllowed = %s dataMode = %s", buf, 0x20u);
          uint64_t v6 = v63;
        }
        int v31 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
        add_explicit = (uint64_t *)v65;
        if (v65 == v31)
        {
          add_explicit = *(uint64_t **)(v6 + 4136);
          if (*(uint64_t **)(v6 + 4144) != add_explicit)
          {
            uint64_t v33 = *add_explicit;
            int v34 = (std::__shared_weak_count *)add_explicit[1];
            if (v34) {
              add_explicit = (uint64_t *)atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v33)
            {
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              (*(void (**)(unsigned char *__return_ptr))(*(void *)v33 + 64))(buf);
              if (*(void *)buf) {
                (*(void (**)(void))(**(void **)buf + 160))();
              }
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
            }
            if (v34) {
              sub_10004D2C8(v34);
            }
          }
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, *(Registry **)(v6 + 104));
        uint64_t v36 = ServiceMap;
        if ((v37 & 0x8000000000000000) != 0)
        {
          int v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v39 = 5381;
          do
          {
            unint64_t v37 = v39;
            unsigned int v40 = *v38++;
            uint64_t v39 = (33 * v39) ^ v40;
          }
          while (v40);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v74 = v37;
        long long v41 = sub_10004D37C(&v36[1].__m_.__sig, &v74);
        if (!v41) {
          break;
        }
        uint64_t v43 = v41[3];
        uint64_t v42 = (std::__shared_weak_count *)v41[4];
        if (!v42) {
          goto LABEL_56;
        }
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v36);
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v58 = v42;
        sub_10004D2C8(v42);
        char v44 = 0;
LABEL_57:
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v43 + 8))(buf, v43, v65);
        uint64_t v6 = v63;
        (*(void (**)(void))(**(void **)buf + 400))(*(void *)buf);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if ((v44 & 1) == 0) {
          sub_10004D2C8(v58);
        }
LABEL_61:
        uint64_t v45 = *(void *)(v9 + 24);
        if (v45)
        {
          if (v23)
          {
            if ((_BYTE)v24) {
              uint64_t v46 = 0;
            }
            else {
              uint64_t v46 = v25 ^ 1;
            }
          }
          else
          {
            uint64_t v46 = 1;
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v45 + 456))(v45, v46);
        }
        unsigned __int8 v47 = *(uint64_t **)(v6 + 4136);
        int v48 = *(uint64_t **)(v6 + 4144);
        while (v47 != v48)
        {
          uint64_t v49 = *v47;
          int v50 = (std::__shared_weak_count *)v47[1];
          if (v50) {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v51 = *(std::__shared_weak_count **)(v9 + 424);
          uint64_t v69 = *(void *)(v9 + 416);
          __int16 v70 = v51;
          if (v51) {
            atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, void, uint64_t *, uint64_t, BOOL, uint64_t, unint64_t))(*(void *)v49 + 296))(v49, a3, &v69, v23, v24 != 0, v25, v26);
          if (v70) {
            sub_10004D2C8(v70);
          }
          if (v50) {
            sub_10004D2C8(v50);
          }
          v47 += 2;
        }
        unsigned __int8 v52 = *(uint64_t **)v9;
        int v53 = *(uint64_t **)(v9 + 8);
        uint64_t v6 = v63;
        if (*(uint64_t **)v9 != v53)
        {
          do
          {
            uint64_t v54 = *v52;
            int v55 = (std::__shared_weak_count *)v52[1];
            if (v55) {
              atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v54) {
              (*(void (**)(uint64_t, void, void, void, void))(*(void *)v54 + 520))(v54, v62, 0, 0, 0);
            }
            if (v55) {
              sub_10004D2C8(v55);
            }
            v52 += 2;
          }
          while (v52 != v53);
        }
        DataServiceController::reactivateAsserted_sync(v63, v65, v62, 1);
        sub_100058DB0(__p, "Packet context change");
        *(_DWORD *)long long buf = v65;
        uint8_t buf[4] = 0;
        if (SHIBYTE(v68) < 0)
        {
          sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
          uint64_t v76 = v68;
        }
        sub_10011AE40();
        if (SHIBYTE(v76) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (SHIBYTE(v68) < 0)
        {
          operator delete(__p[0]);
          if (!v64) {
            goto LABEL_95;
          }
LABEL_94:
          sub_10004D2C8(v64);
          goto LABEL_95;
        }
        if (v64) {
          goto LABEL_94;
        }
LABEL_95:
        int v56 = v8 + 1;
        int v8 = v60;
        if (v56 != v60)
        {
          int v8 = v56;
          while ((v59(*v8) & 1) == 0)
          {
            if (++v8 == v60)
            {
              int v8 = v60;
              break;
            }
          }
        }
        if (v8 == v61) {
          return;
        }
      }
      uint64_t v43 = 0;
LABEL_56:
      std::mutex::unlock(v36);
      BOOL v58 = 0;
      char v44 = 1;
      goto LABEL_57;
    }
  }
}

void sub_10117A504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33)
{
  uint64_t v36 = *(std::__shared_weak_count **)(v34 - 136);
  if (v36) {
    sub_10004D2C8(v36);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117A604(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_10117A6E0(uint64_t a1)
{
}

unint64_t sub_10117A6E8(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 152);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 424);
  v9[0] = *(void *)(v4 + 416);
  v9[1] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = sub_100AE52A4(v5, (uint64_t)v9);
    sub_10004D2C8(v6);
  }
  else
  {
    uint64_t v7 = sub_100AE52A4(v5, (uint64_t)v9);
  }
  return v7 & 0xFFFFFFFF000000FFLL;
}

unint64_t sub_10117A778(uint64_t a1, int a2)
{
  return sub_10117A6E8(a1 - 56, a2);
}

unint64_t sub_10117A780(uint64_t a1, int a2)
{
  return sub_10117A6E8(a1 - 72, a2);
}

uint64_t sub_10117A788(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_100AF2240(a1[18], a2);
  if (result)
  {
    if ((*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 1040))(a1, a2))
    {
      return 1;
    }
    else
    {
      uint64_t v5 = *(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 1056);
      return v5(a1, a2);
    }
  }
  return result;
}

uint64_t sub_10117A840(uint64_t a1, uint64_t a2)
{
  return sub_10117A788((uint64_t *)(a1 - 64), a2);
}

BOOL sub_10117A848(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 984);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 984;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  return v3 != a1 + 984 && *(_DWORD *)(v3 + 28) <= a2 && *(unsigned char *)(v3 + 32) != 0;
}

BOOL sub_10117A8A0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 912);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 912;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  return v3 != a1 + 912 && *(_DWORD *)(v3 + 28) <= a2 && *(unsigned char *)(v3 + 32) != 0;
}

BOOL sub_10117A8F8(uint64_t a1, int a2)
{
  return sub_10003AE20(a1 - 56, a2);
}

BOOL sub_10117A900(uint64_t a1, int a2)
{
  return sub_10003AE20(a1 - 64, a2);
}

BOOL sub_10117A908(uint64_t a1, int a2)
{
  return sub_10003AE20(a1 - 72, a2);
}

uint64_t sub_10117A910(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 802);
}

uint64_t sub_10117A918(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 738);
}

BOOL sub_10117A920(uint64_t a1, uint64_t a2, void **a3)
{
  int v6 = *(unsigned __int8 *)(a1 + 312);
  uint64_t v7 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "setNAISelection";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    return 0;
  }
  if (result)
  {
    uint64_t v10 = a3;
    if (*((char *)a3 + 23) < 0) {
      uint64_t v10 = *a3;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "setNAISelection";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: setNAISelection: %s", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 104));
  int v12 = ServiceMap;
  if (v13 < 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    std::mutex::unlock(v12);
    return 0;
  }
  uint64_t v19 = v17[3];
  unsigned int v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
    std::mutex::unlock(v12);
    if (v19) {
      goto LABEL_17;
    }
    return 0;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  if (!v19)
  {
LABEL_24:
    sub_10004D2C8(v18);
    return 0;
  }
LABEL_17:
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 16))(buf, v19, a2);
  if (!*(void *)buf || !(*(unsigned int (**)(void))(**(void **)buf + 88))(*(void *)buf))
  {
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (!v18) {
      return 0;
    }
    goto LABEL_24;
  }
  uint64_t v20 = *(void *)buf;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__p, *a3, (unint64_t)a3[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v22 = a3[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v20 + 16))(v20, __p);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  ResetAllPacketHandlersAPNs(a2, 15, 0xFFFFFFFFLL, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 344))(a1, a2, 16, 0);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  return 1;
}

void sub_10117AC40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10117AC9C(uint64_t a1, uint64_t a2, void **a3)
{
  return sub_10117A920(a1 - 56, a2, a3);
}

void sub_10117ACA4(void *a1, unsigned int a2)
{
  int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  if (sub_100AF2240(a1[18], v4))
  {
    BOOL v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315394;
      uint64_t v7 = "QosReleased";
      __int16 v8 = 1024;
      unsigned int v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: releasing index %d", (uint8_t *)&v6, 0x12u);
    }
    sub_100AE3CB8(a1[19], v4, a2, 0);
  }
}

void sub_10117ADB4(uint64_t a1, unsigned int a2)
{
}

void sub_10117ADBC(uint64_t a1, unsigned int a2)
{
}

void sub_10117ADC4(uint64_t a1, unint64_t a2, const __CFDictionary **a3, int *a4)
{
  if (!*(unsigned char *)(a1 + 312))
  {
    int v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "requestQos";
    int v12 = "#E %s: !!! too early start";
    uint64_t v13 = v14;
    goto LABEL_8;
  }
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
  if (!sub_100AF2240(*(void *)(a1 + 144), v8)) {
    return;
  }
  *a4 = -1;
  int v9 = ConnectionMaskToType(a2);
  uint64_t v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9 >= 36)
  {
    if (!v11) {
      return;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "requestQos";
    int v12 = "#I %s: Wrong Connection type";
    uint64_t v13 = v10;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&buf, 0xCu);
    return;
  }
  if (v11)
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "requestQos";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&buf, 0xCu);
  }
  CFDictionaryRef v15 = *a3;
  CFTypeRef cf = 0;
  if (v15)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v15, kCTQaulityOfServiceFlowType);
    CFStringRef v17 = Value;
    if (Value && (CFTypeID v18 = CFGetTypeID(Value), v18 == CFStringGetTypeID()))
    {
      if (CFStringCompare(v17, kCTQualityOfServiceFlowAudio, 0))
      {
        if (CFStringCompare(v17, kCTQualityOfServiceFlowVideo, 0))
        {
          uint64_t v19 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            long long buf = 0uLL;
            int v56 = 0;
            ctu::cf::assign();
            *(_OWORD *)long long __p = buf;
            uint64_t v49 = v56;
            uint64_t v20 = __p;
            if (SHIBYTE(v56) < 0) {
              uint64_t v20 = (void **)__p[0];
            }
            *(_DWORD *)int v51 = 136315394;
            unsigned __int8 v52 = "requestQos";
            __int16 v53 = 2080;
            uint64_t v54 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong flow type %s", v51, 0x16u);
            if (SHIBYTE(v49) < 0) {
              operator delete(__p[0]);
            }
          }
          goto LABEL_62;
        }
        int v24 = 1;
      }
      else
      {
        int v24 = 0;
      }
      unint64_t v26 = (const void *)kCTQualityOfServiceFamilyIPv4;
      if (CFDictionaryContainsKey(v15, kCTQualityOfServiceFamilyIPv4))
      {
        CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(v15, v26);
        CFDictionaryRef v28 = v27;
        if (v27)
        {
          CFTypeID v29 = CFGetTypeID(v27);
          if (v29 == CFDictionaryGetTypeID()) {
            CFDictionaryRef v30 = v28;
          }
          else {
            CFDictionaryRef v30 = 0;
          }
        }
        else
        {
          CFDictionaryRef v30 = 0;
        }
        __p[0] = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v30);
        *(void *)&long long buf = 0;
        sub_1003AA8C0(&buf, (CFTypeRef *)__p);
        CFTypeRef v36 = cf;
        CFTypeRef cf = (CFTypeRef)buf;
        *(void *)&long long buf = v36;
        sub_100057D78((const void **)&buf);
        if (CFDictionaryContainsKey(v15, kCTQualityOfServiceFamilyIPv6))
        {
          unint64_t v37 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "requestQos";
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: Both v4 and v6 values are present in request, ignoring v6", (uint8_t *)&buf, 0xCu);
          }
        }
        int v25 = 1;
        goto LABEL_46;
      }
      int v31 = (const void *)kCTQualityOfServiceFamilyIPv6;
      if (CFDictionaryContainsKey(v15, kCTQualityOfServiceFamilyIPv6))
      {
        CFDictionaryRef v32 = (const __CFDictionary *)CFDictionaryGetValue(v15, v31);
        CFDictionaryRef v33 = v32;
        if (v32)
        {
          CFTypeID v34 = CFGetTypeID(v32);
          if (v34 == CFDictionaryGetTypeID()) {
            CFDictionaryRef v35 = v33;
          }
          else {
            CFDictionaryRef v35 = 0;
          }
        }
        else
        {
          CFDictionaryRef v35 = 0;
        }
        *(void *)&long long buf = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v35);
        sub_10117B530(&cf, (CFTypeRef *)&buf);
        int v25 = 2;
LABEL_46:
        int v38 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "requestQos";
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s: looking for Index", (uint8_t *)&buf, 0xCu);
        }
        sub_100AE3D48(*(os_unfair_lock_s **)(a1 + 152), v8, a4);
        goto LABEL_49;
      }
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "requestQos";
      uint64_t v22 = "#I %s: required kCTQualityOfServiceFamilyIPv4/v6 parameter is missing";
    }
    else
    {
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "requestQos";
      uint64_t v22 = "#I %s: required kCTQaulityOfServiceFlowType parameter is missing";
    }
LABEL_61:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&buf, 0xCu);
    goto LABEL_62;
  }
  uint64_t v23 = *(NSObject **)(a1 + 40);
  int v24 = 0;
  int v25 = 0;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "requestQos";
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: no dict", (uint8_t *)&buf, 0xCu);
    int v24 = 0;
    int v25 = 0;
  }
LABEL_49:
  int v39 = *a4;
  if (*a4 != -1)
  {
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 1174405120;
    v41[2] = sub_10117B580;
    v41[3] = &unk_101A95A28;
    int v43 = v8;
    int v44 = v9;
    int v45 = v25;
    int v46 = v24;
    v41[4] = a1;
    CFTypeRef v42 = cf;
    if (cf) {
      CFRetain(cf);
    }
    int v47 = v39;
    __p[0] = 0;
    __p[1] = 0;
    sub_10003E168(__p, (void *)(a1 + 8));
    unsigned int v40 = *(NSObject **)(a1 + 24);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 1174405120;
    int v56 = sub_101195718;
    unsigned __int8 v57 = &unk_101A98BF0;
    int v59 = __p[0];
    uint64_t v60 = (std::__shared_weak_count *)__p[1];
    if (__p[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
    }
    BOOL v58 = v41;
    dispatch_async(v40, &buf);
    if (v60) {
      sub_10004D2C8(v60);
    }
    if (__p[1]) {
      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
    }
    sub_100057D78(&v42);
    goto LABEL_62;
  }
  uint64_t v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "requestQos";
    uint64_t v22 = "#I %s: bad index";
    goto LABEL_61;
  }
LABEL_62:
  sub_100057D78(&cf);
}

void sub_10117B4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,const void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a22);
  _Unwind_Resume(a1);
}

const void **sub_10117B530(const void **a1, CFTypeRef *a2)
{
  BOOL v5 = 0;
  sub_1003AA8C0(&v5, a2);
  uint64_t v3 = *a1;
  *a1 = v5;
  BOOL v5 = v3;
  sub_100057D78(&v5);
  return a1;
}

void sub_10117B580(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v11 = 0;
    int v12 = 0;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), &v11);
    uint64_t v3 = v11;
    if (v11)
    {
      uint64_t v4 = *(unsigned int *)(a1 + 56);
      uint64_t v5 = *(unsigned int *)(a1 + 60);
      sub_100058198(&v10, (const void **)(a1 + 40));
      int v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const void **, void))(*(void *)v3 + 320))(v3, v4, v5, &v10, *(unsigned int *)(a1 + 64));
      sub_100057D78(&v10);
      sub_100AE3C24(*(void *)(v1 + 152), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 64), v6);
      if ((validContextType() & 1) == 0)
      {
        uint64_t v7 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(_DWORD *)(a1 + 64);
          *(_DWORD *)long long buf = 136315650;
          *(void *)long long __p = "requestQos_block_invoke";
          *(_WORD *)&__p[8] = 1024;
          *(_DWORD *)&__p[10] = v8;
          *(_WORD *)&__p[14] = 1024;
          *(_DWORD *)&__p[16] = 3;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: qos status ----- { flowIndex=%d status=%d }", buf, 0x18u);
        }
        sub_100CC96D8((uint64_t)buf, 183, *(_DWORD *)(a1 + 64), 3);
        int v9 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
        sub_100A01420(v9, (uint64_t)buf);
        if (*(void *)&__p[4])
        {
          *(void *)&unsigned char __p[12] = *(void *)&__p[4];
          operator delete(*(void **)&__p[4]);
        }
        sub_10117ACA4((void *)v1, *(_DWORD *)(a1 + 64));
      }
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
}

void sub_10117B750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117B79C(uint64_t a1, unint64_t a2, const __CFDictionary **a3, int *a4)
{
}

uint64_t sub_10117B7A4(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v24 = v3;
  uint64_t v25 = v4;
  uint64_t v7 = a1;
  while (2)
  {
    int v8 = *(void **)v7;
    int v9 = *(void **)(v7 + 8);
    while (v8 != v9)
    {
      if (*v8 && (*(unsigned int (**)(void))(*(void *)*v8 + 168))(*v8))
      {
        (*(void (**)(void **__return_ptr))(*(void *)*v8 + 456))(&__p);
        if ((v23 & 0x80u) == 0) {
          size_t v10 = v23;
        }
        else {
          size_t v10 = __n;
        }
        uint64_t v11 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
        int v12 = (char)v11;
        if ((char)v11 < 0) {
          uint64_t v11 = a3[1];
        }
        if ((unsigned __int8 *)v10 == v11)
        {
          if (v12 >= 0) {
            uint64_t v13 = (unsigned __int8 *)a3;
          }
          else {
            uint64_t v13 = *a3;
          }
          if ((v23 & 0x80) != 0)
          {
            CFTypeID v18 = __p;
            int v19 = memcmp(__p, v13, __n);
            operator delete(v18);
            if (!v19) {
              return (*(uint64_t (**)(void, unsigned __int8 *))(*(void *)*v8 + 472))(*v8, v13);
            }
          }
          else
          {
            if (!v23) {
              return (*(uint64_t (**)(void, unsigned __int8 *))(*(void *)*v8 + 472))(*v8, v13);
            }
            uint64_t v14 = 0;
            do
            {
              int v15 = *((unsigned __int8 *)&__p + v14);
              int v16 = v13[v14];
            }
            while (v15 == v16 && v23 - 1 != v14++);
            if (v15 == v16) {
              return (*(uint64_t (**)(void, unsigned __int8 *))(*(void *)*v8 + 472))(*v8, v13);
            }
          }
        }
        else if ((v23 & 0x80) != 0)
        {
          operator delete(__p);
        }
      }
      v8 += 2;
    }
    v7 += 432;
    if (v7 != a2) {
      continue;
    }
    break;
  }
  return 0;
}

const void **sub_10117B964(void *a1, uint64_t a2, char a3, const void **a4)
{
  int v8 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  BOOL result = (const void **)sub_100AF2240(a1[18], v8);
  if (result)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 1174405120;
    void v11[2] = sub_10117BAF0;
    void v11[3] = &unk_101A95A58;
    void v11[4] = a1;
    v11[5] = a2;
    sub_100058198(&v12, a4);
    char v14 = a3;
    int v13 = v8;
    uint64_t v17 = 0;
    CFTypeID v18 = 0;
    sub_10003E168(&v17, a1 + 1);
    size_t v10 = a1[3];
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_101195718;
    block[3] = &unk_101A98BF0;
    block[5] = v17;
    int v16 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v11;
    dispatch_async(v10, block);
    if (v16) {
      sub_10004D2C8(v16);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    return sub_100057D78(&v12);
  }
  return result;
}

void sub_10117BAF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  if (!*(unsigned char *)(v1 + 312))
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "setPacketNotificationFilter_block_invoke";
    uint64_t v5 = "#E %s: !!! too early start";
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0xCu);
    return;
  }
  int v3 = ConnectionMaskToType(*(void *)(a1 + 40));
  if (v3 >= 36)
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "setPacketNotificationFilter_block_invoke";
    uint64_t v5 = "#I %s: Wrong Connection type";
    goto LABEL_9;
  }
  int v6 = v3;
  uint64_t v7 = (const void **)(a1 + 48);
  sub_100058198((const void **)&theDict, (const void **)(a1 + 48));
  if (theDict) {
    int v8 = sub_100080778;
  }
  else {
    int v8 = 0;
  }
  if (v8
    && (CFStringRef Value = CFDictionaryGetValue(theDict, kCTInterfaceName)) != 0
    && (CFTypeID v10 = CFGetTypeID(Value), v10 == CFStringGetTypeID()))
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v23 = *(void *)&buf[16];
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v11 = HIBYTE(*(void *)&buf[16]);
    uint64_t v12 = *(void *)&buf[8];
  }
  else
  {
    uint64_t v12 = 0;
    LODWORD(v11) = 0;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
  }
  sub_100057D78((const void **)&theDict);
  uint64_t v13 = v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v13 = v12;
  }
  if (v13) {
    int v6 = sub_10117B7A4(*(void *)(*(void *)(v1 + 144) + 8), *(void *)(*(void *)(v1 + 144) + 16), (unsigned __int8 **)__p);
  }
  char v14 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asString();
    uint64_t v16 = asStringBool(*(unsigned char *)(a1 + 60));
    uint64_t v17 = (void **)__p[0];
    if ((v11 & 0x80u) == 0) {
      uint64_t v17 = __p;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = "setPacketNotificationFilter_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v15;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v25 = v16;
    __int16 v26 = 2080;
    CFDictionaryRef v27 = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: type=%s, enable=%s, ifName=%s", buf, 0x2Au);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 56), v6, (uint64_t *)buf);
  uint64_t v18 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v19 = *(unsigned __int8 *)(a1 + 60);
    sub_100058198(&v20, v7);
    (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v18 + 344))(v18, v19, &v20);
    sub_100057D78(&v20);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10117BE08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

const void **sub_10117BE74(uint64_t a1, uint64_t a2)
{
  return sub_100058198((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_10117BE80(uint64_t a1)
{
  return sub_100057D78((const void **)(a1 + 48));
}

const void **sub_10117BE88(uint64_t a1, uint64_t a2, char a3, const void **a4)
{
  return sub_10117B964((void *)(a1 - 56), a2, a3, a4);
}

const void **sub_10117BE90(void *a1, uint64_t a2, const void **a3)
{
  int v6 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  BOOL result = (const void **)sub_100AF2240(a1[18], v6);
  if (result)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 1174405120;
    void v9[2] = sub_10117C014;
    v9[3] = &unk_101A95A88;
    void v9[4] = a1;
    void v9[5] = a2;
    sub_100062740(&v10, a3);
    int v11 = v6;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    sub_10003E168(&v14, a1 + 1);
    int v8 = a1[3];
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_101195718;
    block[3] = &unk_101A98BF0;
    block[5] = v14;
    uint64_t v13 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v9;
    dispatch_async(v8, block);
    if (v13) {
      sub_10004D2C8(v13);
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
    return sub_100044D00(&v10);
  }
  return result;
}

void sub_10117C014(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  if (!*(unsigned char *)(v1 + 312))
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "dropIPPackets_block_invoke";
    uint64_t v5 = "#E %s: !!! too early start";
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0xCu);
    return;
  }
  int v3 = ConnectionMaskToType(*(void *)(a1 + 40));
  if (v3 >= 36)
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "dropIPPackets_block_invoke";
    uint64_t v5 = "#I %s: Wrong Connection type";
    goto LABEL_9;
  }
  int v6 = v3;
  sub_100062740((const void **)&theArray, (const void **)(a1 + 48));
  if (theArray) {
    uint64_t v7 = sub_100083F10;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7
    && CFArrayGetCount(theArray) > 0
    && (CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0)) != 0
    && (CFTypeID v9 = CFGetTypeID(ValueAtIndex), v9 == CFStringGetTypeID()))
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v20 = *(void *)&buf[16];
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v10 = HIBYTE(*(void *)&buf[16]);
    uint64_t v11 = *(void *)&buf[8];
  }
  else
  {
    uint64_t v11 = 0;
    LODWORD(v10) = 0;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v20 = 0;
  }
  sub_100044D00((const void **)&theArray);
  uint64_t v12 = v10;
  if ((v10 & 0x80u) != 0) {
    uint64_t v12 = v11;
  }
  if (v12) {
    int v6 = sub_10117B7A4(*(void *)(*(void *)(v1 + 144) + 8), *(void *)(*(void *)(v1 + 144) + 16), (unsigned __int8 **)__p);
  }
  uint64_t v13 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    uint64_t v15 = (void **)__p[0];
    if ((v10 & 0x80u) == 0) {
      uint64_t v15 = __p;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "dropIPPackets_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v22 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: type=%s, ifName=%s", buf, 0x20u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 56), v6, (uint64_t *)buf);
  uint64_t v16 = *(void *)buf;
  if (*(void *)buf)
  {
    sub_100062740(&v17, (const void **)(a1 + 48));
    (*(void (**)(uint64_t, const void **))(*(void *)v16 + 352))(v16, &v17);
    sub_100044D00(&v17);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10117C318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_100044D00(&a10);
  _Unwind_Resume(a1);
}

const void **sub_10117C384(uint64_t a1, uint64_t a2)
{
  return sub_100062740((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_10117C390(uint64_t a1)
{
  return sub_100044D00((const void **)(a1 + 48));
}

const void **sub_10117C398(uint64_t a1, uint64_t a2, const void **a3)
{
  return sub_10117BE90((void *)(a1 - 56), a2, a3);
}

uint64_t DataServiceController::getRawDataMode(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  else {
    return *(unsigned int *)(v3 + 128);
  }
}

uint64_t sub_10117C3E4(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 80), a2);
  if (*(void *)(*(void *)(a1 + 80) + 16) == v3) {
    return 0;
  }
  else {
    return *(unsigned int *)(v3 + 128);
  }
}

const void **sub_10117C428(uint64_t a1)
{
  CFDataRef theData = 0;
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  uint64_t v3 = *(os_log_t **)(a1 + 40);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  uint64_t v5 = (Registry *)v2[13];
  memset(buf, 0, sizeof(buf));
  int64_t v38 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, v5);
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    CFTypeID v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFDictionaryRef v35 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v35);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 160))(&v36, v14, v4);
  uint64_t v16 = std::string::append(&v36, "/CarrierCA.crt", 0xEuLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  int64_t v38 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long buf = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v15) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  operator delete(v36.__r_.__value_.__l.__data_);
  if ((v15 & 1) == 0) {
LABEL_11:
  }
    sub_10004D2C8(v13);
LABEL_12:
  CFDataRef theData = 0;
  *(void *)CFDictionaryRef v35 = &off_101A0BD40;
  sub_1007EE138(kCFAllocatorDefault, (uint64_t)buf, &theData);
  CFDataRef v18 = theData;
  if (theData) {
    uint64_t v19 = sub_10008324C;
  }
  else {
    uint64_t v19 = 0;
  }
  os_log_t v20 = *v3;
  BOOL v21 = os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (!v21) {
      goto LABEL_25;
    }
    int Length = CFDataGetLength(v18);
    LODWORD(v36.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(v36.__r_.__value_.__r.__words[0]) = Length;
    uint64_t v23 = "#I ePDG CA certificate file of size %d loaded";
    uint64_t v24 = v20;
    uint32_t v25 = 8;
  }
  else
  {
    if (!v21) {
      goto LABEL_25;
    }
    __int16 v26 = buf;
    if (v38 < 0) {
      __int16 v26 = *(uint8_t **)buf;
    }
    LODWORD(v36.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
    uint64_t v23 = "#I Unable to open '%s' for reading";
    uint64_t v24 = v20;
    uint32_t v25 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v36, v25);
LABEL_25:
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)v35);
  if (SHIBYTE(v38) < 0) {
    operator delete(*(void **)buf);
  }
  CFDataRef v27 = theData;
  if (theData) {
    CFDictionaryRef v28 = sub_10008324C;
  }
  else {
    CFDictionaryRef v28 = 0;
  }
  if (v28)
  {
    CFTypeID v29 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex v30 = CFDataGetLength(v27);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I caCertData of size: %lu", buf, 0xCu);
      CFDataRef v27 = theData;
    }
    memset(buf, 0, sizeof(buf));
    int64_t v38 = 0;
    BytePtr = (UInt8 *)CFDataGetBytePtr(v27);
    size_t v32 = CFDataGetLength(theData);
    sub_1000D95C8(buf, BytePtr, v32);
    sub_1008A95DC();
  }
  return sub_100030068((const void **)&theData);
}

void sub_10117C888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_100047F64((void ***)&a15);
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (*(char *)(v24 - 73) < 0) {
    operator delete(*(void **)(v24 - 96));
  }
  sub_100030068(&a14);
  _Unwind_Resume(a1);
}

void DataServiceController::updateIpcConfiguration_sync(Registry **this@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, this[13]);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    CFTypeID v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  CFTypeID v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v10 + 168))(v10);
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_10117CA4C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117CA6C(uint64_t a1, char a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10117FD98;
  v5[3] = &unk_101A95C88;
  void v5[4] = a1;
  char v7 = a2;
  int v6 = a3;
  uint64_t v10 = 0;
  char v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  unint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v10;
  CFTypeID v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_10117CB84(void *a1, unint64_t a2, char a3, int a4)
{
  int v8 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  if (sub_100AF2240(a1[18], v8))
  {
    int v9 = ConnectionMaskToType(a2);
    uint64_t v10 = a1[5];
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (v9 < 36)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "setQuality";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = asString();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: type=%s, userInfo", buf, 0x16u);
      }
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 0x40000000;
      _OWORD v13[2] = sub_10117CDE8;
      void v13[3] = &unk_101A95AD8;
      v13[4] = a1;
      int v14 = v8;
      int v15 = v9;
      char v17 = a3;
      int v16 = a4;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      sub_10003E168(&v18, a1 + 1);
      unint64_t v12 = a1[3];
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_101195718;
      BOOL v21 = &unk_101A98BF0;
      uint64_t v23 = v18;
      uint64_t v24 = v19;
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v22 = v13;
      dispatch_async(v12, buf);
      if (v24) {
        sub_10004D2C8(v24);
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
    }
    else if (v11)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "setQuality";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong Connection type", buf, 0xCu);
    }
  }
}

void sub_10117CDDC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10117CDE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    DataServiceController::getConnection_sync(v2, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), &v3);
    if (v3) {
      (*(void (**)(uint64_t, void, void))(*(void *)v3 + 368))(v3, *(unsigned __int8 *)(a1 + 52), *(unsigned int *)(a1 + 48));
    }
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

void sub_10117CE74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117CE8C(uint64_t a1, unint64_t a2, char a3, int a4)
{
}

void *sub_10117CE94(uint64_t a1, int a2, long long *a3, uint64_t a4)
{
  long long v8 = *a3;
  uint64_t v9 = *((void *)a3 + 2);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  _DWORD v14[2] = sub_10117D024;
  void v14[3] = &unk_101A95AF8;
  v14[4] = a1;
  sub_100017108((uint64_t)v15, a4);
  int v16 = a2;
  long long v17 = v8;
  uint64_t v18 = v9;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  int v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v12;
  BOOL v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v14;
  dispatch_async(v6, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  return sub_10001C9D4(v15);
}

void sub_10117D018(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10117D024(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  if (!*(unsigned char *)(v1 + 312))
  {
    int v15 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "setVoLTEAudioCodec_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
    sub_100060854(a1 + 40, 0x1000000001);
    return;
  }
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(a1 + 72));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v1 + 104));
  int v6 = ServiceMap;
  char v7 = "14AudioInterface";
  if (((unint64_t)"14AudioInterface" & 0x8000000000000000) != 0)
  {
    long long v8 = (unsigned __int8 *)((unint64_t)"14AudioInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      char v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_15:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_19;
    }
LABEL_16:
    if ((*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v13 + 48))(v13, *(unsigned int *)(a1 + 72), a1 + 76))
    {
      sub_100060854(a1 + 40, 0);
      if (v14) {
        return;
      }
LABEL_33:
      sub_10004D2C8(v12);
      return;
    }
    goto LABEL_19;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_15;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13) {
    goto LABEL_16;
  }
LABEL_19:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (sub_100AF2240(*(void *)(v1 + 144), *(_DWORD *)(a1 + 72)))
  {
    uint64_t v16 = sub_100AEFE40(*(void *)(v1 + 144), *(_DWORD *)(a1 + 72));
    uint64_t v17 = *(void *)(v16 + 24);
    uint64_t v12 = *(std::__shared_weak_count **)(v16 + 32);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v17)
    {
      sub_100017108((uint64_t)v21, a1 + 40);
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 800))(v17, a1 + 76, v21);
      sub_10001C9D4(v21);
    }
    else
    {
      os_log_t v20 = *v3;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E volteAudioCodec: No BB driver", buf, 2u);
      }
      sub_100060854(a1 + 40, 0x600000001);
    }
    if (v12) {
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v18 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E volteAudioCodec: Invalid sim %s", buf, 0xCu);
    }
    sub_100060854(a1 + 40, 0x1600000001);
  }
}

void sub_10117D36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10001C9D4(&a9);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void *sub_10117D3B8(uint64_t a1, int a2, long long *a3, uint64_t a4)
{
  return sub_10117CE94(a1 - 56, a2, a3, a4);
}

void sub_10117D3C0(void *a1, int a2)
{
  int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_10117D500;
  uint64_t v6[3] = &unk_101A95B28;
  void v6[4] = a1;
  int v7 = v4;
  int v8 = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_10003E168(&v11, a1 + 1);
  uint64_t v5 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v11;
  unsigned int v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_10117D500(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  if (!*(unsigned char *)(v1 + 312))
  {
    int v7 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = 136315138;
    int v15 = "releaseQos_block_invoke";
    int v8 = "#E %s: !!! too early start";
    uint64_t v9 = v7;
    uint32_t v10 = 12;
    goto LABEL_17;
  }
  uint64_t v3 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 40));
  if (*(void *)(*(void *)(v1 + 144) + 16) == v3) {
    return;
  }
  uint64_t v4 = v3;
  int v5 = sub_100AE3E00(*(void *)(v1 + 152), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44));
  if (v5 != 1)
  {
    if (!v5)
    {
      int v6 = *(void **)(v4 + 24);
      if (!v6) {
        return;
      }
      goto LABEL_12;
    }
    uint64_t v12 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v13 = *(unsigned int *)(a1 + 44);
    int v14 = 136315394;
    int v15 = "releaseQos_block_invoke";
    __int16 v16 = 2048;
    uint64_t v17 = v13;
    int v8 = "#I %s: ERR: Wrong context type or flow index (%lu)";
    uint64_t v9 = v12;
    uint32_t v10 = 22;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v14, v10);
    return;
  }
  int v6 = *(void **)(v4 + 40);
  if (!v6) {
    return;
  }
LABEL_12:
  uint64_t v11 = *(void (**)(void))(*(void *)((char *)v6 + *(void *)(*v6 - 320)) + 104);

  v11();
}

void sub_10117D6EC(uint64_t a1, int a2)
{
}

void sub_10117D6F4(void *a1, int a2, int a3, int a4)
{
  int v8 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  _DWORD v10[2] = sub_10117D848;
  _OWORD v10[3] = &unk_101A95B48;
  void v10[4] = a1;
  int v11 = v8;
  int v12 = a2;
  int v13 = a3;
  int v14 = a4;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_10003E168(&v17, a1 + 1);
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v17;
  __int16 v16 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v10;
  dispatch_async(v9, block);
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
}

void sub_10117D848(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      uint64_t v2 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 40));
      if (*(void *)(*(void *)(v1 + 144) + 16) != v2)
      {
        uint64_t v3 = *(void *)(v2 + 24);
        if (v3)
        {
          uint64_t v4 = *(void (**)(void))(*(void *)v3 + 696);
          v4();
        }
      }
    }
    else
    {
      int v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315138;
        int v7 = "pushVoipAppInfo_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v6, 0xCu);
      }
    }
  }
}

void sub_10117D990(uint64_t a1, int a2, int a3, int a4)
{
}

uint64_t sub_10117D998(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void **)(v3 + 24);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(uint64_t (**)(void))(*(void *)((char *)v4 + *(void *)(*v4 - 320)) + 184);

  return v5();
}

uint64_t sub_10117DA34(uint64_t a1, int a2)
{
  return sub_10117D998(a1 - 56, a2);
}

uint64_t sub_10117DA3C(uint64_t a1, int a2)
{
  return sub_10117D998(a1 - 64, a2);
}

uint64_t sub_10117DA44(uint64_t a1, int a2)
{
  return sub_10117D998(a1 - 80, a2);
}

uint64_t sub_10117DA4C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 292);
}

uint64_t sub_10117DA54(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 236);
}

void sub_10117DA5C(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10117DB70;
  void v4[3] = &unk_101A95B68;
  void v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10117DB70(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 312);
  uint64_t v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      uint64_t v6 = asStringBool(*(unsigned char *)(v2 + 293));
      uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 40));
      int v8 = 136315650;
      uint64_t v9 = "setBlockInCallHandover_block_invoke";
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      __int16 v12 = 2080;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Changing fIsInCallHandoverBlocked from %s to %s", (uint8_t *)&v8, 0x20u);
    }
    *(unsigned char *)(v2 + 293) = *(unsigned char *)(a1 + 40);
  }
  else if (v5)
  {
    int v8 = 136315138;
    uint64_t v9 = "setBlockInCallHandover_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v8, 0xCu);
  }
}

void sub_10117DC9C(uint64_t a1, char a2)
{
}

uint64_t sub_10117DCA4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 293);
}

uint64_t sub_10117DCAC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 237);
}

void sub_10117DCB4(uint64_t a1, int a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _OWORD v6[2] = sub_10117DDEC;
  uint64_t v6[3] = &unk_101A95B88;
  uint64_t v4 = (void *)(a1 + 8);
  void v6[4] = a1;
  int v8 = a2;
  sub_100B89508(v7, a3);
  uint64_t v11 = 0;
  __int16 v12 = 0;
  sub_10003E168(&v11, v4);
  BOOL v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v11;
  __int16 v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_1000346F8((uint64_t)v7, (void *)v7[1]);
}

void sub_10117DDEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 312))
  {
    uint64_t v3 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 64));
    if (*(void *)(*(void *)(v1 + 144) + 16) != v3)
    {
      uint64_t v4 = *(void *)(v3 + 40);
      if (v4)
      {
        sub_100B89508(v6, a1 + 40);
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 432))(v4, v6);
        sub_1000346F8((uint64_t)v6, (void *)v6[1]);
      }
    }
  }
  else
  {
    BOOL v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      int v8 = "addiRatSubcription_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
  }
}

void sub_10117DF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t *sub_10117DF30(uint64_t a1, uint64_t a2)
{
  return sub_100B89508((uint64_t *)(a1 + 40), a2 + 40);
}

void sub_10117DF3C(uint64_t a1)
{
}

void sub_10117DF4C(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_10117DF54(uint64_t a1, int a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  _OWORD v6[2] = sub_10117E08C;
  uint64_t v6[3] = &unk_101A95BB8;
  uint64_t v4 = (void *)(a1 + 8);
  void v6[4] = a1;
  int v8 = a2;
  sub_100B89508(v7, a3);
  uint64_t v11 = 0;
  __int16 v12 = 0;
  sub_10003E168(&v11, v4);
  BOOL v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v11;
  __int16 v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_1000346F8((uint64_t)v7, (void *)v7[1]);
}

void sub_10117E08C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 312))
  {
    uint64_t v3 = sub_10003B004(*(void *)(v1 + 144), *(_DWORD *)(a1 + 64));
    if (*(void *)(*(void *)(v1 + 144) + 16) != v3)
    {
      uint64_t v4 = *(void *)(v3 + 40);
      if (v4)
      {
        sub_100B89508(v6, a1 + 40);
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 440))(v4, v6);
        sub_1000346F8((uint64_t)v6, (void *)v6[1]);
      }
    }
  }
  else
  {
    BOOL v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      int v8 = "removeiRatSubcription_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
  }
}

void sub_10117E1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_10117E1D0(uint64_t a1, int a2, uint64_t a3)
{
}

uint64_t sub_10117E1D8(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      __int16 v10 = "getHOPreferredMode_sync";
      int v8 = "#I %s: wrong SIM index, default to Wifi Preferred";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v9, 0xCu);
    }
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 40);
  if (!v4)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      __int16 v10 = "getHOPreferredMode_sync";
      int v8 = "#I %s: No TechDataDriver, default to Wifi Preferred";
      goto LABEL_10;
    }
    return 0;
  }
  BOOL v5 = *(uint64_t (**)(void))(*(void *)v4 + 480);

  return v5();
}

uint64_t sub_10117E340(uint64_t a1, int a2)
{
  return sub_10117E1D8(a1 - 56, a2);
}

void sub_10117E348(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v5)
  {
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 40) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 30) = 0;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 44));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 68));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 92));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 116));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 140));
  }
  else
  {
    uint64_t v6 = v5;
    *(_DWORD *)a3 = *(_DWORD *)(v5 + 152);
    if (*(char *)(v5 + 183) < 0)
    {
      sub_10004FC84((unsigned char *)(a3 + 8), *(void **)(v5 + 160), *(void *)(v5 + 168));
    }
    else
    {
      long long v7 = *(_OWORD *)(v5 + 160);
      *(void *)(a3 + 24) = *(void *)(v5 + 176);
      *(_OWORD *)(a3 + 8) = v7;
    }
    uint64_t v8 = *(void *)(v6 + 184);
    *(_DWORD *)(a3 + 40) = *(_DWORD *)(v6 + 192);
    *(void *)(a3 + 32) = v8;
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 44), (const CSIPacketAddress *)(v6 + 196));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 68), (const CSIPacketAddress *)(v6 + 220));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 92), (const CSIPacketAddress *)(v6 + 244));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 116), (const CSIPacketAddress *)(v6 + 268));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a3 + 140), (const CSIPacketAddress *)(v6 + 292));
  }
}

void sub_10117E458(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117E478(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
}

void sub_10117E480(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (v3)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 40));
      dispatch_group_enter(v3);
    }
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "shutDownDataService";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Shutting down Data Service", buf, 0xCu);
    }
    DataServiceController::setSliceEventsListeners_sync((DataServiceController *)v1, 0, 0, 0);
    if (v3)
    {
      dispatch_retain(v3);
      dispatch_group_enter(v3);
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
    uint64_t v5 = v1 + 184;
    for (uint64_t i = *(void *)(v1 + 192); i != v5; uint64_t i = *(void *)(i + 8))
      sub_10016111C((uint64_t *)(i + 16));
    sub_100160A84((atomic_uint **)(v1 + 184));
    ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 120));
    for (uint64_t j = *(void *)(v1 + 192); j != v5; uint64_t j = *(void *)(j + 8))
      sub_10016111C((uint64_t *)(j + 16));
    sub_100160A84((atomic_uint **)(v1 + 184));
    *(unsigned char *)(v1 + 288) = 1;
    sub_10115F4B0((DataServiceController *)v1);
    uint64_t v8 = *(void *)(v1 + 144);
    uint64_t v9 = *(void *)(v8 + 8);
    for (uint64_t k = *(void *)(v8 + 16); v9 != k; v9 += 432)
    {
      uint64_t v11 = *(char **)(v9 + 24);
      if (v11)
      {
        int v12 = (*(uint64_t (**)(char *))(*(void *)&v11[*(void *)(*(void *)v11 - 320)] + 216))(&v11[*(void *)(*(void *)v11 - 320)]);
        if (v12)
        {
          uint64_t v13 = *(void *)(v9 + 24) + *(void *)(**(void **)(v9 + 24) - 320);
          (*(void (**)(uint64_t, void))(*(void *)v13 + 72))(v13, 0);
          int v14 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = "shutDownDataService";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Holding off Shutdown due to %d BB contexts active", buf, 0x12u);
          }
          if (v3)
          {
            dispatch_retain(v3);
            dispatch_group_enter(v3);
          }
          int v15 = *(NSObject **)(v1 + 296);
          *(void *)(v1 + 296) = v3;
          if (v15)
          {
            dispatch_group_leave(v15);
            dispatch_release(v15);
          }
        }
      }
      __int16 v16 = *(char **)(v9 + 40);
      if (v16)
      {
        int v17 = (*(uint64_t (**)(char *))(*(void *)&v16[*(void *)(*(void *)v16 - 320)] + 216))(&v16[*(void *)(*(void *)v16 - 320)]);
        if (v17)
        {
          uint64_t v18 = *(void *)(v9 + 40) + *(void *)(**(void **)(v9 + 40) - 320);
          (*(void (**)(uint64_t, void))(*(void *)v18 + 72))(v18, 0);
          uint64_t v19 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = "shutDownDataService";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v17;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Holding off Shutdown due to %d iWLAN contexts active", buf, 0x12u);
          }
          if (v3)
          {
            dispatch_retain(v3);
            dispatch_group_enter(v3);
          }
          os_log_t v20 = *(NSObject **)(v1 + 296);
          *(void *)(v1 + 296) = v3;
          if (v20)
          {
            dispatch_group_leave(v20);
            dispatch_release(v20);
          }
        }
      }
    }
    if (*(void *)(v1 + 296))
    {
      sub_10003E168(buf, (void *)(v1 + 8));
      uint64_t v22 = *(void *)buf;
      BOOL v21 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
      }
      Registry::getTimerService(&v41, *(Registry **)(v1 + 104));
      uint64_t v23 = v41;
      sub_100058DB0(__p, "DataShutdown: Shutdown safety timer");
      uint64_t v24 = *(NSObject **)(v1 + 24);
      dispatch_object_t object = v24;
      if (v24) {
        dispatch_retain(v24);
      }
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_10117EE80;
      int v45 = &unk_101A95C18;
      uint64_t v46 = v1;
      uint64_t v47 = v22;
      int v48 = v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      aBlocuint64_t k = _Block_copy(buf);
      sub_100118A44(v23, (uint64_t)__p, 0, 3000000, &object, &aBlock);
      uint64_t v25 = v43;
      uint64_t v43 = 0;
      uint64_t v26 = *(void *)(v1 + 304);
      *(void *)(v1 + 304) = v25;
      if (v26)
      {
        (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
        uint64_t v27 = v43;
        uint64_t v43 = 0;
        if (v27) {
          (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v40 < 0) {
        operator delete(__p[0]);
      }
      if (v42) {
        sub_10004D2C8(v42);
      }
      if (v48) {
        std::__shared_weak_count::__release_weak(v48);
      }
      if (v21) {
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    else
    {
      sub_10117EC58(v1);
    }
    if (v3)
    {
      dispatch_group_leave(v3);
      dispatch_release(v3);
    }
    uint64_t v28 = *(void *)(v1 + 4160);
    if (v28)
    {
      CFTypeID v29 = *(NSObject **)(a1 + 40);
      dispatch_group_t group = v29;
      if (v29)
      {
        dispatch_retain(v29);
        dispatch_group_enter(v29);
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v28 + 24))(v28, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
    }
    uint64_t v30 = *(void *)(v1 + 256);
    if (v30)
    {
      int v31 = *(NSObject **)(a1 + 40);
      dispatch_group_t v35 = v31;
      if (v31)
      {
        dispatch_retain(v31);
        dispatch_group_enter(v31);
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v30 + 32))(v30, &v35);
      if (v35)
      {
        dispatch_group_leave(v35);
        if (v35) {
          dispatch_release(v35);
        }
      }
    }
    uint64_t v32 = *(void *)(v1 + 240);
    if (v32)
    {
      CFDictionaryRef v33 = *(NSObject **)(a1 + 40);
      dispatch_group_t v34 = v33;
      if (v33)
      {
        dispatch_retain(v33);
        dispatch_group_enter(v33);
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v32 + 32))(v32, &v34);
      if (v34)
      {
        dispatch_group_leave(v34);
        if (v34) {
          dispatch_release(v34);
        }
      }
    }
  }
}

void sub_10117EB5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, dispatch_group_t a13, dispatch_group_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10117EC58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(uint64_t ***)(v2 + 8);
  for (uint64_t i = *(uint64_t ***)(v2 + 16); v3 != i; v3 += 54)
  {
    uint64_t v5 = *v3;
    uint64_t v6 = v3[1];
    while (v5 != v6)
    {
      uint64_t v7 = *v5;
      uint64_t v8 = (std::__shared_weak_count *)v5[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 120))(v7);
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      v5 += 2;
    }
  }
  for (uint64_t j = *(void *)(a1 + 192); j != a1 + 184; uint64_t j = *(void *)(j + 8))
    sub_10016111C((uint64_t *)(j + 16));
  sub_100160A84((atomic_uint **)(a1 + 184));
  __int16 v10 = *(uint64_t **)(a1 + 4136);
  for (uint64_t k = *(uint64_t **)(a1 + 4144); v10 != k; v10 += 2)
  {
    uint64_t v12 = *v10;
    uint64_t v13 = (std::__shared_weak_count *)v10[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v12 + 192))(v12);
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  uint64_t result = *(void *)(a1 + 224);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
  }
  uint64_t v15 = *(void *)(a1 + 144);
  uint64_t v16 = *(void *)(v15 + 8);
  uint64_t v17 = *(void *)(v15 + 16);
  while (v16 != v17)
  {
    uint64_t v18 = *(char **)(v16 + 24);
    if (v18) {
      uint64_t result = (*(uint64_t (**)(char *))(*(void *)&v18[*(void *)(*(void *)v18 - 320)] + 96))(&v18[*(void *)(*(void *)v18 - 320)]);
    }
    uint64_t v19 = *(char **)(v16 + 40);
    if (v19) {
      uint64_t result = (*(uint64_t (**)(char *))(*(void *)&v19[*(void *)(*(void *)v19 - 320)] + 96))(&v19[*(void *)(*(void *)v19 - 320)]);
    }
    v16 += 432;
  }
  return result;
}

void sub_10117EE64(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117EE80(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = v3[38];
        v3[38] = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        sub_10117EC58((uint64_t)v3);
        uint64_t v7 = v3[5];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136315138;
          __int16 v10 = "shutDownDataService_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Giving up on Shutdown", (uint8_t *)&v9, 0xCu);
        }
        uint64_t v8 = v3[37];
        v3[37] = 0;
        if (v8)
        {
          dispatch_group_leave(v8);
          dispatch_release(v8);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10117EFA8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10117EFBC(uint64_t a1, NSObject **a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 312);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "resetNetworkSettings";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Resetting DataService network settings", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 104));
    int v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16) {
          goto LABEL_23;
        }
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_23;
    }
LABEL_15:
    uint64_t v18 = *(void *)(a1 + 144);
    uint64_t v19 = *(void *)(v18 + 8);
    for (uint64_t i = *(void *)(v18 + 16); v19 != i; v19 += 432)
    {
      *(_OWORD *)long long buf = 0uLL;
      BOOL v21 = *(std::__shared_weak_count **)(v19 + 424);
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
      }
      sub_10022EDC4(v16, buf);
      if (*(void *)buf) {
        (*(void (**)(void, uint64_t))(**(void **)buf + 72))(*(void *)buf, 1);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
LABEL_23:
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    ResetAllPacketHandlersAPNs(3, 7, 0xFFFFFFFFLL, 0);
    uint64_t v22 = *a2;
    if (v22)
    {
      dispatch_retain(v22);
      dispatch_group_enter(v22);
    }
    *(_OWORD *)long long buf = 0uLL;
    sub_10003E168(buf, (void *)(a1 + 8));
    operator new();
  }
  if (v6)
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "resetNetworkSettings";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
  }
}

void sub_10117F2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117F32C(uint64_t a1, NSObject **a2)
{
}

void sub_10117F334(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10117F448;
  void v4[3] = &unk_101A95C48;
  void v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10117F448(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    int v3 = *(unsigned __int8 *)(v1 + 312);
    int v4 = *(NSObject **)(v1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 40));
        int v7 = 136315394;
        uint64_t v8 = "setInternetAssertions_block_invoke";
        __int16 v9 = 2080;
        uint64_t v10 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Setting fInternetAssertion to %s", (uint8_t *)&v7, 0x16u);
      }
      *(unsigned char *)(v1 + 290) = *(unsigned char *)(a1 + 40);
    }
    else if (v5)
    {
      int v7 = 136315138;
      uint64_t v8 = "setInternetAssertions_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v7, 0xCu);
    }
  }
}

void sub_10117F568(uint64_t a1, char a2)
{
}

void sub_10117F570(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10117F684;
  void v4[3] = &unk_101A95C68;
  void v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  __int16 v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  int v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_101195718;
  block[3] = &unk_101A98BF0;
  block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10117F684(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    int v3 = *(unsigned __int8 *)(v1 + 312);
    int v4 = *(NSObject **)(v1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 40));
        int v7 = 136315394;
        uint64_t v8 = "setTetheringAssertion_block_invoke";
        __int16 v9 = 2080;
        uint64_t v10 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Setting fTetheringAssertion to %s", (uint8_t *)&v7, 0x16u);
      }
      *(unsigned char *)(v1 + 289) = *(unsigned char *)(a1 + 40);
    }
    else if (v5)
    {
      int v7 = 136315138;
      uint64_t v8 = "setTetheringAssertion_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v7, 0xCu);
    }
  }
}

void sub_10117F7A4(uint64_t a1, char a2)
{
}

BOOL sub_10117F7AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 312)) {
    return *(unsigned char *)(a1 + 290) != 0;
  }
  uint64_t v2 = *(NSObject **)(a1 + 40);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v3)
  {
    int v4 = 136315138;
    BOOL v5 = "getInternetAssertions_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v4, 0xCu);
    return 0;
  }
  return result;
}

BOOL sub_10117F870(uint64_t a1)
{
  return sub_10117F7AC(a1 - 64);
}

uint64_t sub_10117F878(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 289);
}

uint64_t sub_10117F880(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 225);
}

void sub_10117F888(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_10117F890(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void sub_10117F898(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  if (sub_100030AFC(*(void *)(a1 + 152), a2))
  {
    uint64_t v11 = 0;
    memset(v10, 0, sizeof(v10));
    sub_100AE478C(*(void *)(a1 + 152), a2, a3, (uint64_t)v10);
    sub_10117F98C(*(void *)(a4 + 24), (LODWORD(v10[0]) == 0) | ((unint64_t)LODWORD(v10[0]) << 32));
    uint64_t v8 = v11;
    if (v11)
    {
      sub_10004D2C8(v8);
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a4 + 24);
    sub_10117F98C(v9, 0);
  }
}

void sub_10117F974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10117F98C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_10117F9DC(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
}

void sub_10117F9E4(uint64_t a1, int a2, uint64_t a3)
{
  if (sub_100030AFC(*(void *)(a1 + 152), a2))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    sub_100AE46E0(*(void *)(a1 + 152), a2, &v24);
    uint64_t v6 = 0;
    int v7 = 0;
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    for (unint64_t i = 0; i != 36; ++i)
    {
      if (i >= 0x86BCA1AF286BCA1BLL * ((v25 - v24) >> 3)) {
        break;
      }
      if (*(_DWORD *)(v24 + 152 * i + 4) == 2)
      {
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = (v9 - v6) >> 2;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 62) {
            sub_10006A748();
          }
          if ((uint64_t)(v8 - (void)v6) >> 1 > v12) {
            unint64_t v12 = (uint64_t)(v8 - (void)v6) >> 1;
          }
          if (v8 - (unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v12;
          }
          if (v13)
          {
            unint64_t v13 = (unint64_t)sub_1000492A8(v13);
            uint64_t v9 = v7;
          }
          else
          {
            uint64_t v14 = 0;
          }
          uint64_t v15 = (char *)(v13 + 4 * v11);
          *(_DWORD *)uint64_t v15 = i;
          int v7 = v15 + 4;
          while (v9 != v6)
          {
            int v16 = *((_DWORD *)v9 - 1);
            v9 -= 4;
            *((_DWORD *)v15 - 1) = v16;
            v15 -= 4;
          }
          unint64_t v8 = v13 + 4 * v14;
          if (v6) {
            operator delete(v6);
          }
          uint64_t v6 = v15;
          uint64_t v9 = v7;
        }
        else
        {
          *(_DWORD *)uint64_t v9 = i;
          v9 += 4;
          int v7 = v9;
        }
      }
    }
    long long __p = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    int64_t v17 = v9 - v6;
    if (v9 != v6)
    {
      if (v17 < 0) {
        sub_10006A748();
      }
      long long __p = sub_1000492A8(v17 >> 2);
      uint64_t v23 = (char *)__p + 4 * v18;
      memmove(__p, v6, v17);
      uint64_t v22 = (char *)__p + 4 * (v17 >> 2);
    }
    uint64_t v19 = *(void *)(a3 + 24);
    if (!v19) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v19 + 48))(v19, &__p);
    if (__p)
    {
      uint64_t v22 = (char *)__p;
      operator delete(__p);
    }
    if (v6) {
      operator delete(v6);
    }
    uint64_t v30 = (void **)&v24;
    sub_100AE5AA8(&v30);
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v20 = *(void *)(a3 + 24);
    if (!v20) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v20 + 48))(v20, &v27);
    if (v27)
    {
      uint64_t v28 = v27;
      operator delete(v27);
    }
  }
}

void sub_10117FC54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char *a18)
{
  if (v18) {
    operator delete(v18);
  }
  a18 = &a12;
  sub_100AE5AA8((void ***)&a18);
  _Unwind_Resume(a1);
}

void sub_10117FCB4(uint64_t a1, int a2, uint64_t a3)
{
}

uint64_t sub_10117FCBC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  if (!sub_100AF2240(*(void *)(a1 + 144), a2)) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  DataServiceController::getConnection_sync(a1, v4, a3, &v8);
  uint64_t v6 = v8;
  if (v8) {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 480))(v8);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v6) {
    return 0;
  }
  return v4;
}

void sub_10117FD70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10117FD88(uint64_t a1, uint64_t a2, int a3)
{
  return sub_10117FCBC(a1 - 56, a2, a3);
}

uint64_t sub_10117FD90(uint64_t a1, uint64_t a2, int a3)
{
  return sub_10117FCBC(a1 - 64, a2, a3);
}

unsigned char *sub_10117FD98(uint64_t a1)
{
  BOOL result = *(unsigned char **)(a1 + 32);
  if (!result[288]) {
    return (unsigned char *)(*(uint64_t (**)(unsigned char *, void, void))(*(void *)result + 584))(result, *(unsigned __int8 *)(a1 + 44), *(unsigned int *)(a1 + 40));
  }
  return result;
}

void sub_10117FDE0(uint64_t a1, char a2, int a3)
{
}

void sub_10117FDE8(void *a1, BOOL a2, uint64_t a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v11 = 136315394;
    *(void *)&void v11[4] = asStringBool(a2);
    *(_WORD *)&v11[12] = 2080;
    *(void *)&v11[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Settings all interfaces availability to %s due to %s", v11, 0x16u);
  }
  int v7 = (uint64_t *)a1[517];
  for (unint64_t i = (uint64_t *)a1[518]; v7 != i; v7 += 2)
  {
    uint64_t v9 = *v7;
    uint64_t v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)uint64_t v11 = 0;
    *(void *)&unsigned char v11[8] = 0;
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v9 + 64))(v11);
    if (*(void *)v11) {
      (*(void (**)(void, BOOL, uint64_t))(**(void **)v11 + 160))(*(void *)v11, a2, a3);
    }
    if (*(void *)&v11[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v11[8]);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_10117FF64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10117FF90(uint64_t a1, BOOL a2, uint64_t a3)
{
}

void sub_10117FF98(uint64_t a1, NSObject **a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "handleEnterLowPower_sync";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Entering low power mode", (uint8_t *)&buf, 0xCu);
  }
  BOOL v5 = *(uint64_t **)(v3 + 4136);
  for (unint64_t i = *(uint64_t **)(v3 + 4144); v5 != i; v5 += 2)
  {
    uint64_t v7 = *v5;
    uint64_t v8 = (std::__shared_weak_count *)v5[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v7 + 384))(v7);
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  sub_10003E168(&v25, (void *)(v3 + 8));
  long long v9 = v25;
  long long buf = v25;
  if (*((void *)&v25 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v25 + 1) + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
  }
  uint64_t v10 = *a2;
  uint64_t v29 = v3;
  uint64_t v30 = v10;
  if (v10)
  {
    dispatch_retain(v10);
    dispatch_group_enter(v10);
  }
  uint64_t v11 = *(void *)(v3 + 144);
  unint64_t v12 = *(void **)(v11 + 8);
  unint64_t v13 = *(void **)(v11 + 16);
  if (v12 != v13)
  {
    uint64_t v14 = *((void *)&v9 + 1);
    do
    {
      uint64_t v15 = v12[5];
      if (v15)
      {
        *(void *)&long long v24 = v9;
        *((void *)&v24 + 1) = v14;
        if (v14)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
          uint64_t v3 = v29;
          uint64_t v10 = v30;
        }
        if (v10)
        {
          dispatch_retain(v10);
          int v16 = v10;
          dispatch_group_enter(v10);
        }
        else
        {
          int v16 = 0;
        }
        uint64_t v27 = 0;
        uint64_t v20 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v20 = off_101A98E08;
        *(_OWORD *)(v20 + 8) = v24;
        *((void *)v20 + 3) = v3;
        *((void *)v20 + 4) = v16;
        uint64_t v27 = v20;
        (*(void (**)(uint64_t, void *))(*(void *)v15 + 488))(v15, v26);
        sub_1008FDE68(v26);
      }
      else
      {
        uint64_t v18 = v12[52];
        int64_t v17 = (std::__shared_weak_count *)v12[53];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v19 = *(unsigned int *)(v18 + 52);
          sub_10004D2C8(v17);
        }
        else
        {
          uint64_t v19 = *(unsigned int *)(v18 + 52);
        }
        uint64_t v3 = v29;
        if (*((void *)&v9 + 1))
        {
          BOOL v21 = std::__shared_weak_count::lock(*((std::__shared_weak_count **)&v9 + 1));
          if (v21)
          {
            uint64_t v22 = v21;
            if ((void)v9)
            {
              uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v19);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v25) = 0;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I enterLowPower callback from iWLAN driver", (uint8_t *)&v25, 2u);
              }
            }
            sub_10004D2C8(v22);
          }
          uint64_t v14 = *((void *)&v9 + 1);
        }
        else
        {
          uint64_t v14 = 0;
        }
      }
      v12 += 54;
    }
    while (v12 != v13);
    uint64_t v10 = v30;
  }
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  if (*((void *)&v9 + 1)) {
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v9 + 1));
  }
}

void sub_1011802E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_10118033C(uint64_t a1, NSObject **a2)
{
}

void *sub_101180344(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "enterLowPower";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Entering low power mode", (uint8_t *)&buf, 0xCu);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  void v9[2] = sub_1011804F8;
  v9[3] = &unk_101A95CA8;
  void v9[4] = a1;
  sub_1000DFC90((uint64_t)v10, a2);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_10003E168(&v7, a1 + 1);
  BOOL v5 = a1[3];
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 1174405120;
  unint64_t v12 = sub_101195718;
  unint64_t v13 = &unk_101A98BF0;
  uint64_t v15 = v7;
  int v16 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = v9;
  dispatch_async(v5, &buf);
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return sub_100060644(v10);
}

void sub_1011804EC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011804F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(uint64_t **)(v1 + 4136);
  for (unint64_t i = *(uint64_t **)(v1 + 4144); v2 != i; v2 += 2)
  {
    uint64_t v4 = *v2;
    BOOL v5 = (std::__shared_weak_count *)v2[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 384))(v4);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  uint64_t v6 = dispatch_group_create();
  uint64_t v7 = *(void *)(v1 + 144);
  long long v9 = *(void **)(v7 + 8);
  uint64_t v8 = *(void **)(v7 + 16);
  if (v9 == v8)
  {
LABEL_34:
    sub_10003E168(buf, (void *)(v1 + 8));
    uint64_t v20 = v23;
    v24[0] = *(std::__shared_weak_count **)buf;
    v24[1] = v23;
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
    }
    uint64_t v25 = v1;
    sub_1000DFC90((uint64_t)&v26, a1 + 40);
    operator new();
  }
  while (1)
  {
    sub_10003E168(buf, (void *)(v1 + 8));
    uint64_t v10 = *(std::__shared_weak_count **)buf;
    uint64_t v11 = v23;
    v24[0] = *(std::__shared_weak_count **)buf;
    v24[1] = v23;
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
    }
    uint64_t v25 = v1;
    uint64_t v26 = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    uint64_t v12 = v9[5];
    if (v12)
    {
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6)
      {
        dispatch_retain(v6);
        dispatch_group_enter(v6);
      }
      uint64_t v28 = 0;
      unint64_t v13 = operator new(0x28uLL);
      *unint64_t v13 = off_101A98E88;
      v13[1] = v10;
      _OWORD v13[2] = v11;
      void v13[3] = v1;
      v13[4] = v6;
      uint64_t v28 = v13;
      (*(void (**)(uint64_t, void *))(*(void *)v12 + 488))(v12, v27);
      sub_1008FDE68(v27);
    }
    else if (*(void *)(a1 + 64))
    {
      uint64_t v15 = v9[52];
      uint64_t v14 = (std::__shared_weak_count *)v9[53];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v16 = *(unsigned int *)(v15 + 52);
        sub_10004D2C8(v14);
        if (v11) {
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v16 = *(unsigned int *)(v15 + 52);
        if (v11)
        {
LABEL_29:
          int64_t v17 = std::__shared_weak_count::lock(v11);
          if (v17)
          {
            uint64_t v18 = v17;
            if (v10)
            {
              uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v16);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I enterLowPower callback from iWLAN driver", buf, 2u);
              }
            }
            sub_10004D2C8(v18);
          }
        }
      }
    }
    if (v6)
    {
      dispatch_group_leave(v6);
      dispatch_release(v6);
    }
    if (v11) {
      std::__shared_weak_count::__release_weak(v11);
    }
    v9 += 54;
    if (v9 == v8) {
      goto LABEL_34;
    }
  }
}

void sub_1011808A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v26 = *(std::__shared_weak_count **)(v25 + 8);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  operator delete();
}

uint64_t sub_101180960(uint64_t a1)
{
  sub_100060644((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_101180998(uint64_t a1, uint64_t a2)
{
  return sub_101180344((void *)(a1 - 56), a2);
}

void sub_1011809A0(void *a1, void *a2)
{
  if (*a2)
  {
    int v4 = *(_DWORD *)(*a2 + 32);
    if (!v4) {
      int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
    }
    if (sub_100AF2240(a1[18], v4))
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 1174405120;
      void v9[2] = sub_101180BBC;
      v9[3] = &unk_101A95CD8;
      uint64_t v6 = *a2;
      BOOL v5 = (std::__shared_weak_count *)a2[1];
      void v9[4] = a1;
      void v9[5] = v6;
      uint64_t v10 = v5;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v11 = v4;
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      sub_10003E168(&v12, a1 + 1);
      uint64_t v7 = a1[3];
      *(void *)&blocuint64_t k = _NSConcreteStackBlock;
      *((void *)&block + 1) = 1174405120;
      uint64_t v15 = sub_101195718;
      uint64_t v16 = &unk_101A98BF0;
      uint64_t v18 = v12;
      uint64_t v19 = v13;
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int64_t v17 = v9;
      dispatch_async(v7, &block);
      if (v19) {
        sub_10004D2C8(v19);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
  }
  else
  {
    uint64_t v8 = a1[5];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block) = 136315138;
      *(void *)((char *)&block + 4) = "assertConnection";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Invalid Data Connection Assertion Source", (uint8_t *)&block, 0xCu);
    }
  }
}

void sub_101180BB0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101180BBC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(*(void *)(a1 + 40) + 16);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  DataServiceController::getConnection_sync(v2, *(_DWORD *)(a1 + 56), v3, &v14);
  uint64_t v4 = v14;
  if (v14)
  {
    BOOL v5 = *(std::__shared_weak_count **)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 40);
    unint64_t v13 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 304))(v4, &v12);
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  uint64_t v6 = (capabilities::ct *)v15;
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (capabilities::ct::supportsGemini(v6))
  {
    int v7 = DataUtils::otherSimSlot();
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    DataServiceController::getConnection_sync(v2, v7, v3, &v14);
    uint64_t v8 = v14;
    if (v14)
    {
      long long v9 = *(std::__shared_weak_count **)(a1 + 48);
      uint64_t v10 = *(void *)(a1 + 40);
      int v11 = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 304))(v8, &v10);
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
}

void sub_101180D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101180D38(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101180D54(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101180D64(uint64_t a1, void *a2)
{
}

void sub_101180D6C(void *a1, int a2, int a3)
{
  int v4 = a2;
  if (!a2) {
    int v4 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  }
  if (sub_100AF2240(a1[18], v4))
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    void v7[2] = sub_101180ED4;
    uint64_t v7[3] = &unk_101A95D08;
    void v7[4] = a1;
    int v8 = v4;
    int v9 = a3;
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    sub_10003E168(&v12, a1 + 1);
    uint64_t v6 = a1[3];
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_101195718;
    block[3] = &unk_101A98BF0;
    block[5] = v12;
    int v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v7;
    dispatch_async(v6, block);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_101180ED4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 312))
  {
    long long v6 = 0uLL;
    DataServiceController::getConnection_sync(v1, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), (uint64_t *)&v6);
    if ((void)v6) {
      (*(void (**)(void))(*(void *)v6 + 312))(v6);
    }
    int v3 = (capabilities::ct *)*((void *)&v6 + 1);
    if (*((void *)&v6 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
    }
    if (capabilities::ct::supportsGemini(v3))
    {
      int v4 = DataUtils::otherSimSlot();
      long long v6 = 0uLL;
      DataServiceController::getConnection_sync(v1, v4, *(_DWORD *)(a1 + 44), (uint64_t *)&v6);
      if ((void)v6) {
        (*(void (**)(void))(*(void *)v6 + 312))(v6);
      }
      if (*((void *)&v6 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
      }
    }
  }
  else
  {
    BOOL v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v6) = 136315138;
      *(void *)((char *)&v6 + 4) = "removeConnectionAssertion_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_101181044(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101181068(uint64_t a1, int a2, int a3)
{
}

uint64_t sub_101181070(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4)
{
  uint64_t v5 = a1;
  int v9 = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a1 != a2)
  {
    while (1)
    {
      long long v6 = *(std::__shared_weak_count **)(v5 + 424);
      uint64_t v10 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char matched = DataUtils::matchPersonality();
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (matched) {
        break;
      }
      v5 += 432;
      if (v5 == a2)
      {
        uint64_t v5 = a2;
        break;
      }
    }
    a4 = v9;
  }
  if (a4) {
    sub_10004D2C8(a4);
  }
  return v5;
}

void sub_10118111C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101181140(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 312))
  {
    unsigned __int8 v57 = 0;
    *(_OWORD *)int v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    sub_100AE44D0(*(void *)(a1 + 152), (uint64_t)&v54);
    if (sub_101187F4C(a2, (uint64_t)&v54))
    {
LABEL_52:
      if (v57) {
        sub_10004D2C8(v57);
      }
      return;
    }
    BOOL v4 = v55[12];
    uint64_t v5 = *(NSObject **)(a1 + 40);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (!v6) {
        goto LABEL_27;
      }
      int v7 = "f";
      if (!v54) {
        int v7 = "t";
      }
      int v48 = v7;
      if (v54) {
        int v8 = (const char *)asString();
      }
      else {
        int v8 = "OK";
      }
      uint64_t v12 = (const char *)*((void *)&v54 + 1);
      unint64_t v13 = *(unsigned char **)v55;
      uint64_t v14 = asStringBool(v55[8]);
      uint64_t v15 = asStringBool(v55[9]);
      uint64_t v16 = asStringBool(v55[10]);
      uint64_t v17 = asStringBool(v55[11]);
      *(_DWORD *)long long buf = 136317442;
      int v59 = "setLastInternetActivateError_sync";
      __int16 v60 = 2080;
      uint64_t v61 = "changing lastInternetActivationError from";
      __int16 v62 = 2080;
      uint64_t v63 = v48;
      __int16 v64 = 2080;
      unsigned int v65 = v8;
      __int16 v66 = 2080;
      unsigned int v67 = v12;
      __int16 v68 = 2080;
      uint64_t v69 = v13;
      __int16 v70 = 2080;
      uint64_t v71 = v14;
      __int16 v72 = 2080;
      uint64_t v73 = v15;
      __int16 v74 = 2080;
      uint64_t v75 = v16;
      __int16 v76 = 2080;
      uint64_t v77 = v17;
      uint64_t v18 = "#I %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
      uint64_t v19 = v5;
      uint32_t v20 = 102;
      goto LABEL_26;
    }
    if (!v6) {
      goto LABEL_27;
    }
    if (v54) {
      uint64_t v10 = "f";
    }
    else {
      uint64_t v10 = "t";
    }
    if (v54) {
      int v11 = (const char *)asString();
    }
    else {
      int v11 = "OK";
    }
    if (*((void *)&v54 + 1))
    {
      uint64_t v21 = *(void *)v55;
      if (**((unsigned char **)&v54 + 1))
      {
        uint64_t v22 = "}";
        uint64_t v23 = "{";
LABEL_25:
        *(_DWORD *)long long buf = 136316930;
        int v59 = "setLastInternetActivateError_sync";
        __int16 v60 = 2080;
        uint64_t v61 = "changing lastInternetActivationError from";
        __int16 v62 = 2080;
        uint64_t v63 = v10;
        __int16 v64 = 2080;
        unsigned int v65 = v11;
        __int16 v66 = 2080;
        unsigned int v67 = v23;
        __int16 v68 = 2080;
        uint64_t v69 = (unsigned char *)*((void *)&v54 + 1);
        __int16 v70 = 2080;
        uint64_t v71 = v21;
        __int16 v72 = 2080;
        uint64_t v73 = (uint64_t)v22;
        uint64_t v18 = "#I %s: %s: %s(%s%s%s %s%s)";
        uint64_t v19 = v5;
        uint32_t v20 = 82;
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
LABEL_27:
        int v24 = *(unsigned __int8 *)(a2 + 28);
        uint64_t v25 = *(NSObject **)(a1 + 40);
        BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
        if (v24)
        {
          if (!v26) {
            goto LABEL_49;
          }
          uint64_t v27 = "f";
          if (!*(_DWORD *)a2) {
            uint64_t v27 = "t";
          }
          uint64_t v49 = v27;
          if (*(_DWORD *)a2) {
            uint64_t v28 = (const char *)asString();
          }
          else {
            uint64_t v28 = "OK";
          }
          int v31 = *(const char **)(a2 + 8);
          uint64_t v32 = *(unsigned char **)(a2 + 16);
          uint64_t v33 = asStringBool(*(unsigned char *)(a2 + 24));
          uint64_t v34 = asStringBool(*(unsigned char *)(a2 + 25));
          uint64_t v35 = asStringBool(*(unsigned char *)(a2 + 26));
          uint64_t v36 = asStringBool(*(unsigned char *)(a2 + 27));
          *(_DWORD *)long long buf = 136317442;
          int v59 = "setLastInternetActivateError_sync";
          __int16 v60 = 2080;
          uint64_t v61 = "changing lastInternetActivationError to";
          __int16 v62 = 2080;
          uint64_t v63 = v49;
          __int16 v64 = 2080;
          unsigned int v65 = v28;
          __int16 v66 = 2080;
          unsigned int v67 = v31;
          __int16 v68 = 2080;
          uint64_t v69 = v32;
          __int16 v70 = 2080;
          uint64_t v71 = v33;
          __int16 v72 = 2080;
          uint64_t v73 = v34;
          __int16 v74 = 2080;
          uint64_t v75 = v35;
          __int16 v76 = 2080;
          uint64_t v77 = v36;
          unint64_t v37 = "#I %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
          int64_t v38 = v25;
          uint32_t v39 = 102;
          goto LABEL_48;
        }
        if (!v26) {
          goto LABEL_49;
        }
        if (*(_DWORD *)a2) {
          uint64_t v29 = "f";
        }
        else {
          uint64_t v29 = "t";
        }
        if (*(_DWORD *)a2) {
          uint64_t v30 = (const char *)asString();
        }
        else {
          uint64_t v30 = "OK";
        }
        char v40 = *(unsigned char **)(a2 + 8);
        if (v40)
        {
          uint64_t v41 = *(void *)(a2 + 16);
          if (*v40)
          {
            CFTypeRef v42 = "}";
            uint64_t v43 = "{";
LABEL_47:
            *(_DWORD *)long long buf = 136316930;
            int v59 = "setLastInternetActivateError_sync";
            __int16 v60 = 2080;
            uint64_t v61 = "changing lastInternetActivationError to";
            __int16 v62 = 2080;
            uint64_t v63 = v29;
            __int16 v64 = 2080;
            unsigned int v65 = v30;
            __int16 v66 = 2080;
            unsigned int v67 = v43;
            __int16 v68 = 2080;
            uint64_t v69 = v40;
            __int16 v70 = 2080;
            uint64_t v71 = v41;
            __int16 v72 = 2080;
            uint64_t v73 = (uint64_t)v42;
            unint64_t v37 = "#I %s: %s: %s(%s%s%s %s%s)";
            int64_t v38 = v25;
            uint32_t v39 = 82;
LABEL_48:
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
LABEL_49:
            uint64_t v44 = *(void *)(a1 + 152);
            long long v45 = *(_OWORD *)(a2 + 16);
            v50[0] = *(_OWORD *)a2;
            v50[1] = v45;
            uint64_t v46 = *(void *)(a2 + 40);
            uint64_t v51 = *(void *)(a2 + 32);
            uint64_t v52 = v46;
            uint64_t v47 = *(std::__shared_weak_count **)(a2 + 48);
            __int16 v53 = v47;
            if (v47)
            {
              atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_100AE4548(v44, v50);
              sub_10004D2C8(v47);
            }
            else
            {
              sub_100AE4548(v44, v50);
            }
            goto LABEL_52;
          }
        }
        else
        {
          uint64_t v41 = *(void *)(a2 + 16);
        }
        uint64_t v43 = "";
        CFTypeRef v42 = "";
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v21 = *(void *)v55;
    }
    uint64_t v23 = "";
    uint64_t v22 = "";
    goto LABEL_25;
  }
  int v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    int v59 = "setLastInternetActivateError_sync";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
  }
}

void sub_1011816A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011816C4(uint64_t a1, uint64_t a2)
{
}

void *sub_1011816CC(uint64_t a1, char a2, int a3, uint64_t a4)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 1174405120;
  void v11[2] = sub_10118182C;
  void v11[3] = &unk_101A95D28;
  void v11[4] = a1;
  char v14 = a2;
  int v13 = a3;
  sub_1000F0058((uint64_t)v12, a4);
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  void v7[2] = sub_101195718;
  uint64_t v7[3] = &unk_101A98BF0;
  void v7[5] = v9;
  int v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v7[4] = v11;
  dispatch_async(v5, v7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  return sub_10003B34C(v12);
}

void sub_101181820(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10118182C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 144);
  BOOL v4 = *(void **)(v3 + 8);
  for (unint64_t i = *(void **)(v3 + 16); v4 != i; v4 += 54)
  {
    if (v4[3])
    {
      uint64_t v7 = v4[52];
      BOOL v6 = (std::__shared_weak_count *)v4[53];
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *(unsigned int *)(v7 + 52);
        sub_10004D2C8(v6);
      }
      else
      {
        uint64_t v8 = *(unsigned int *)(v7 + 52);
      }
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(unsigned __int8 *)(a1 + 76);
        int v11 = *(_DWORD *)(a1 + 72);
        *(_DWORD *)long long buf = 67109376;
        int v24 = v10;
        __int16 v25 = 1024;
        int v26 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I start: enableOutgoingTraffic enable=%d, reason=%d", buf, 0xEu);
      }
      uint64_t v12 = *(uint64_t **)(v2 + 4136);
      int v13 = *(uint64_t **)(v2 + 4144);
      while (v12 != v13)
      {
        uint64_t v14 = *v12;
        uint64_t v15 = (std::__shared_weak_count *)v12[1];
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v16 = (std::__shared_weak_count *)v4[53];
        uint64_t v21 = v4[52];
        uint64_t v22 = v16;
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, void, uint64_t *, void, void))(*(void *)v14 + 304))(v14, 0, &v21, *(unsigned __int8 *)(a1 + 76), *(unsigned int *)(a1 + 72));
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v15) {
          sub_10004D2C8(v15);
        }
        v12 += 2;
      }
    }
  }
  uint64_t v17 = *(void *)(a1 + 64);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 48))(v17);
  }
  uint64_t v18 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(unsigned __int8 *)(a1 + 76);
    int v20 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)long long buf = 67109376;
    int v24 = v19;
    __int16 v25 = 1024;
    int v26 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I done: enableOutgoingTraffic enable=%d, reason=%d", buf, 0xEu);
  }
}

void sub_101181A9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void *sub_101181AC8(uint64_t a1, char a2, int a3, uint64_t a4)
{
  return sub_1011816CC(a1 - 56, a2, a3, a4);
}

uint64_t sub_101181AD0(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 432);

  return v5();
}

uint64_t sub_101181B58(uint64_t a1, int a2)
{
  return sub_101181AD0(a1 - 56, a2);
}

uint64_t sub_101181B60(uint64_t a1, int a2)
{
  return sub_101181AD0(a1 - 64, a2);
}

unint64_t sub_101181B68(capabilities::ct *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = a2;
  BOOL v6 = a1;
  unsigned int v194 = a2;
  if (!capabilities::ct::supportsCellRadio(a1))
  {
    *(_OWORD *)(a3 + 16) = xmmword_1015C5590;
    uint64_t v28 = 7;
    uint64_t v29 = 6;
LABEL_27:
    *(void *)(a3 + 8 * v29) = v28;
    return a4;
  }
  *(void *)(a3 + 16) = (*(unsigned int (**)(capabilities::ct *, uint64_t))(*(void *)v6 + 1688))(v6, v5);
  *(void *)(a3 + 48) = (*(int (**)(capabilities::ct *, uint64_t))(*(void *)v6 + 1136))(v6, v5);
  uint64_t v7 = *((void *)v6 + 19);
  uint64_t v8 = (os_unfair_lock_s *)(v7 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
  LODWORD(v7) = *(unsigned __int8 *)(v7 + 84);
  os_unfair_lock_unlock(v8);
  char v9 = (*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v6 + 1048))(v6, v5);
  if (!v7 || (v9 & 1) == 0)
  {
    int v30 = 0;
    int v31 = 0;
    *(void *)(a3 + 32) = 0;
    goto LABEL_63;
  }
  if (!*(void *)(a3 + 16))
  {
LABEL_62:
    int v30 = 0;
    int v31 = 0;
LABEL_63:
    *(void *)(a3 + 24) = 0;
    uint64_t v37 = 1;
LABEL_64:
    int v185 = 1;
    goto LABEL_65;
  }
  uint64_t v10 = *((void *)v6 + 82);
  if (!v10) {
    goto LABEL_15;
  }
  int v11 = (void *)((char *)v6 + 656);
  do
  {
    int v12 = *(_DWORD *)(v10 + 28);
    BOOL v13 = v12 < (int)v5;
    if (v12 >= (int)v5) {
      uint64_t v14 = (uint64_t *)v10;
    }
    else {
      uint64_t v14 = (uint64_t *)(v10 + 8);
    }
    if (!v13) {
      int v11 = (void *)v10;
    }
    uint64_t v10 = *v14;
  }
  while (*v14);
  if (v11 != (void *)((char *)v6 + 656) && *((_DWORD *)v11 + 7) <= (int)v5) {
    int v15 = *((_DWORD *)v11 + 8);
  }
  else {
LABEL_15:
  }
    int v15 = -1;
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v6 + 14);
  CFTypeRef cf2 = (CFTypeRef)*((void *)v6 + 13);
  uint64_t v193 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((subscriber::isValidSimSlot() & 1) == 0) {
    uint64_t v5 = (*(uint64_t (**)(capabilities::ct *))(*(void *)v6 + 1088))(v6);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *((Registry **)v6 + 13));
  int v19 = ServiceMap;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v20;
  int v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v24)
  {
    uint64_t v26 = v24[3];
    __int16 v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v19);
  __int16 v25 = 0;
  char v27 = 1;
LABEL_31:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v26 + 96))(cf, v26, v5, 1, @"ShowUIIndicatorWhenInternetRejected", kCFBooleanFalse, 0);
  uint64_t v32 = (BOOL *)cf[0];
  buf[0] = 0;
  if (cf[0])
  {
    CFTypeID v33 = CFGetTypeID(cf[0]);
    if (v33 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v32, v34);
    }
    LODWORD(v32) = buf[0];
  }
  sub_1000577C4(cf);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (v32)
  {
    LODWORD(v35) = 0;
  }
  else
  {
    cf[0] = 0;
    cf[1] = 0;
    DataServiceController::getConnection_sync((uint64_t)v6, v5, 0, cf);
    CFTypeRef v35 = cf[0];
    if (cf[0])
    {
      if ((*(uint64_t (**)(CFTypeRef))(*(void *)cf[0] + 168))(cf[0]))
      {
        LODWORD(v35) = 0;
      }
      else
      {
        __p[0] = 0;
        __p[1] = 0;
        (*(void (**)(void **__return_ptr, CFTypeRef, void))(*(void *)v35 + 136))(__p, v35, 0);
        if (__p[0])
        {
          *(void *)long long buf = 0;
          uint64_t v202 = 0;
          *(void *)&uint8_t buf[8] = "";
          *(void *)&uint8_t buf[16] = "";
          int v203 = 2;
          *(void *)uint64_t v205 = 0;
          uint64_t v204 = 0;
          *(_DWORD *)&v205[8] = 0;
          if ((*(unsigned int (**)(void *, void, uint8_t *))(*(void *)__p[0] + 248))(__p[0], 0, buf))
          {
            BOOL v36 = v204 == 1 || *(_DWORD *)buf == 90;
            LODWORD(v35) = v36;
          }
          else
          {
            LODWORD(v35) = 0;
          }
          if (*(void *)&v205[4]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v205[4]);
          }
        }
        else
        {
          LODWORD(v35) = 0;
        }
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
      }
    }
    if (cf[1]) {
      sub_10004D2C8((std::__shared_weak_count *)cf[1]);
    }
  }
  if (v193) {
    sub_10004D2C8(v193);
  }
  if (v35) {
    goto LABEL_62;
  }
  switch(v15)
  {
    case 1:
      int v30 = 0;
      *(void *)(a3 + 24) = 1;
      uint64_t v37 = 1;
      int v185 = 1;
      int v31 = 1;
      break;
    case 2:
      int v30 = 0;
      uint64_t v37 = 2;
      goto LABEL_131;
    case 3:
    case 11:
    case 12:
    case 13:
    case 15:
      int v30 = 0;
      uint64_t v37 = 3;
      goto LABEL_131;
    case 4:
      int v30 = 0;
      uint64_t v37 = 4;
      goto LABEL_131;
    case 5:
      int v30 = 0;
      uint64_t v37 = 5;
LABEL_131:
      *(void *)(a3 + 24) = v37;
      goto LABEL_132;
    case 10:
      int v30 = 0;
      uint64_t v37 = 1;
      *(void *)(a3 + 24) = 1;
      int v31 = 1;
      goto LABEL_64;
    case 14:
      goto LABEL_164;
    case 16:
      sub_10118358C((uint64_t)v6 + 4480, (int *)&v194);
      if ((hasDataUiModifierBit() & 1) != 0 || hasDataUiModifierBit())
      {
        int v30 = 0;
        int v185 = 0;
        int v31 = 8;
        *(void *)(a3 + 24) = 8;
      }
      else
      {
LABEL_164:
        uint64_t v37 = 7;
        *(void *)(a3 + 24) = 7;
        int v30 = 1;
LABEL_132:
        int v185 = 1;
LABEL_133:
        int v31 = v37;
      }
      break;
    case 17:
      int v30 = 0;
      int v185 = 0;
      uint64_t v37 = 8;
      *(void *)(a3 + 24) = 8;
      goto LABEL_133;
    default:
      goto LABEL_62;
  }
LABEL_65:
  uint64_t v38 = v194;
  unsigned int v195 = v194;
  CFTypeRef cf2 = 0;
  uint32_t v39 = (std::mutex *)Registry::getServiceMap((uint64_t *)v37, *((Registry **)v6 + 13));
  char v40 = v39;
  uint64_t v42 = v41;
  if (v41 < 0)
  {
    uint64_t v43 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v44 = 5381;
    do
    {
      uint64_t v42 = v44;
      unsigned int v45 = *v43++;
      uint64_t v44 = (33 * v44) ^ v45;
    }
    while (v45);
  }
  std::mutex::lock(v39);
  *(void *)long long buf = v42;
  uint64_t v46 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
  int v186 = v30;
  if (v46)
  {
    uint64_t v48 = v46[3];
    uint64_t v47 = (std::__shared_weak_count *)v46[4];
    if (v47)
    {
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v40);
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v47);
      char v49 = 0;
      goto LABEL_73;
    }
  }
  else
  {
    uint64_t v48 = 0;
  }
  std::mutex::unlock(v40);
  uint64_t v47 = 0;
  char v49 = 1;
LABEL_73:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v48 + 96))(cf, v48, v38, 1, @"DataIndicatorOverride", 0, 0);
  sub_100056248(&cf2, cf);
  sub_1000577C4(cf);
  if ((v49 & 1) == 0) {
    sub_10004D2C8(v47);
  }
  uint64_t v198 = 0;
  uint64_t v51 = (std::mutex *)Registry::getServiceMap(v50, *((Registry **)v6 + 13));
  uint64_t v52 = v51;
  uint64_t v53 = v41;
  if (v41 < 0)
  {
    long long v54 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v55 = 5381;
    do
    {
      uint64_t v53 = v55;
      unsigned int v56 = *v54++;
      uint64_t v55 = (33 * v55) ^ v56;
    }
    while (v56);
  }
  std::mutex::lock(v51);
  *(void *)long long buf = v53;
  unsigned __int8 v57 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)buf);
  if (v57)
  {
    uint64_t v59 = v57[3];
    BOOL v58 = (std::__shared_weak_count *)v57[4];
    if (v58)
    {
      int v60 = v31;
      uint64_t v61 = v41;
      uint64_t v62 = v38;
      uint64_t v63 = v6;
      uint64_t v64 = a3;
      int v65 = v60;
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v52);
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      int v66 = v65;
      a3 = v64;
      BOOL v6 = v63;
      uint64_t v38 = v62;
      uint64_t v41 = v61;
      int v31 = v66;
      sub_10004D2C8(v58);
      char v67 = 0;
      goto LABEL_83;
    }
  }
  else
  {
    uint64_t v59 = 0;
  }
  std::mutex::unlock(v52);
  BOOL v58 = 0;
  char v67 = 1;
LABEL_83:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v59 + 96))(cf, v59, v38, 2, @"DataIndicatorOverride", 0, 0);
  sub_100056248(&v198, cf);
  sub_1000577C4(cf);
  if ((v67 & 1) == 0) {
    sub_10004D2C8(v58);
  }
  if (cf2) {
    __int16 v68 = sub_1000810B8;
  }
  else {
    __int16 v68 = 0;
  }
  if (!v68) {
    goto LABEL_107;
  }
  if (!(v198 ? sub_1000810B8 : 0)) {
    goto LABEL_107;
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
  uint64_t v200 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v197 = *(void *)&buf[16];
  CFTypeRef v70 = (CFTypeRef)HIBYTE(v200);
  int v71 = SHIBYTE(v200);
  if (v200 < 0) {
    CFTypeRef v70 = cf[1];
  }
  if (v70 != (CFTypeRef)2) {
    goto LABEL_105;
  }
  __int16 v72 = (void *)cf[0];
  uint64_t v73 = cf;
  if (v200 < 0) {
    uint64_t v73 = (CFTypeRef *)cf[0];
  }
  if (*(_WORD *)v73 != 18228) {
    goto LABEL_105;
  }
  __int16 v74 = (void *)HIBYTE(v197);
  if (v197 < 0) {
    __int16 v74 = __p[1];
  }
  if (v74 != (void *)2) {
    goto LABEL_105;
  }
  uint64_t v75 = __p;
  if (v197 < 0) {
    uint64_t v75 = (void **)__p[0];
  }
  if (*(_WORD *)v75 != 18228)
  {
LABEL_105:
    if (SHIBYTE(v197) < 0)
    {
      operator delete(__p[0]);
      if ((v71 & 0x80000000) == 0) {
        goto LABEL_107;
      }
    }
    else if ((SHIBYTE(v200) & 0x80000000) == 0)
    {
LABEL_107:
      int v76 = 0;
      goto LABEL_108;
    }
    operator delete((void *)cf[0]);
    goto LABEL_107;
  }
  if (SHIBYTE(v197) < 0) {
    operator delete(__p[0]);
  }
  if (v71 < 0) {
    operator delete(v72);
  }
  int v76 = 1;
LABEL_108:
  sub_1000558F4(&v198);
  unint64_t DeviceEvoType = (unint64_t)sub_1000558F4(&cf2);
  if (v76)
  {
    if ((v31 - 3) < 3)
    {
      LOBYTE(v78) = 1;
      unsigned int v79 = 7;
      goto LABEL_207;
    }
    unsigned int v79 = v31;
    if (v31 != 7)
    {
      LOBYTE(v78) = 1;
      unsigned int v79 = v31;
      goto LABEL_207;
    }
  }
  else
  {
    unsigned int v79 = 0;
    LOBYTE(v78) = 0;
    if (!v186) {
      goto LABEL_207;
    }
  }
  unint64_t DeviceEvoType = capabilities::ct::getDeviceEvoType((capabilities::ct *)DeviceEvoType);
  int v80 = DeviceEvoType;
  if (!DeviceEvoType) {
    goto LABEL_206;
  }
  BOOL v81 = (uint64_t *)*((void *)v6 + 120);
  if (!v81) {
    goto LABEL_206;
  }
  int v82 = (uint64_t **)((char *)v6 + 960);
  uint64_t v83 = (uint64_t **)((char *)v6 + 960);
  uint64_t v84 = *((void *)v6 + 120);
  do
  {
    int v85 = *(_DWORD *)(v84 + 28);
    BOOL v86 = v85 < (int)v38;
    if (v85 >= (int)v38) {
      unsigned int v87 = (uint64_t *)v84;
    }
    else {
      unsigned int v87 = (uint64_t *)(v84 + 8);
    }
    if (!v86) {
      uint64_t v83 = (uint64_t **)v84;
    }
    uint64_t v84 = *v87;
  }
  while (*v87);
  if (v83 == v82 || *((_DWORD *)v83 + 7) > (int)v38) {
    goto LABEL_206;
  }
  uint64_t v89 = *((void *)v6 + 43);
  uint64_t v88 = *((void *)v6 + 44);
  if (v89 != v88)
  {
    while (*(_DWORD *)v89 != v38)
    {
      v89 += 168;
      if (v89 == v88) {
        goto LABEL_206;
      }
    }
  }
  if (v89 == v88) {
    goto LABEL_206;
  }
  uint64_t v90 = *((void *)v6 + 528);
  if (v90)
  {
    uint64_t v91 = (void **)(v89 + 120);
    uint64_t v92 = (void *)((char *)v6 + 4224);
    do
    {
      int v93 = *(_DWORD *)(v90 + 32);
      BOOL v94 = v93 < (int)v38;
      if (v93 >= (int)v38) {
        uint64_t v95 = (uint64_t *)v90;
      }
      else {
        uint64_t v95 = (uint64_t *)(v90 + 8);
      }
      if (!v94) {
        uint64_t v92 = (void *)v90;
      }
      uint64_t v90 = *v95;
    }
    while (*v95);
    if (v92 != (void *)((char *)v6 + 4224) && *((_DWORD *)v92 + 8) <= (int)v38)
    {
      uint64_t v96 = (capabilities::ct **)v92[5];
      if (v96)
      {
        uint64_t v97 = *(unsigned __int8 *)(v89 + 143);
        int v98 = (char)v97;
        unint64_t v99 = *(void *)(v89 + 128);
        if ((v97 & 0x80u) != 0) {
          uint64_t v97 = *(void *)(v89 + 128);
        }
        if (!v97) {
          goto LABEL_189;
        }
        if (*v96 != v96[1])
        {
          int v182 = v31;
          int v183 = v96;
          memset(buf, 0, sizeof(buf));
          if (v98 < 0)
          {
            sub_10004FC84(buf, *v91, v99);
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)v91;
            *(void *)&uint8_t buf[16] = *(void *)(v89 + 136);
          }
          char v100 = &buf[buf[23]];
          if ((buf[23] & 0x80u) == 0)
          {
            unint64_t v101 = buf;
          }
          else
          {
            char v100 = (uint8_t *)(*(void *)buf + *(void *)&buf[8]);
            unint64_t v101 = *(uint8_t **)buf;
          }
          unsigned __int8 v187 = (capabilities::ct *)v100;
          while (v101 != v100)
          {
            uint8_t *v101 = __tolower((char)*v101);
            ++v101;
            char v100 = (uint8_t *)v187;
          }
          uint64_t v188 = v183[1];
          if (*v183 == v188)
          {
            unint64_t DeviceEvoType = 0;
          }
          else
          {
            uint64_t v102 = (uint64_t)*v183 + 32;
            do
            {
              uint64_t v103 = *(void *)(v102 - 8);
              if (!v103) {
                sub_10007B600();
              }
              unint64_t DeviceEvoType = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v103 + 48))(v103, buf);
              if ((capabilities::ct *)v102 == v188) {
                int v104 = 1;
              }
              else {
                int v104 = DeviceEvoType;
              }
              v102 += 32;
            }
            while (v104 != 1);
          }
          int v31 = v182;
          if ((char)buf[23] < 0)
          {
            unsigned int v189 = DeviceEvoType;
            operator delete(*(void **)buf);
            unint64_t DeviceEvoType = v189;
          }
          uint64_t v91 = (void **)(v89 + 120);
          if (DeviceEvoType)
          {
LABEL_189:
            int v105 = v91;
            int v106 = *((void *)v6 + 5);
            unint64_t DeviceEvoType = os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT);
            if (DeviceEvoType)
            {
              if (*(char *)(v89 + 143) < 0) {
                int v105 = (void **)*v105;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v105;
              _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I GID '%s' is blocked from EVO coverage", buf, 0xCu);
            }
            goto LABEL_206;
          }
          BOOL v81 = *v82;
        }
      }
    }
  }
  if (!v81) {
LABEL_200:
  }
    sub_1000C14F0("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v107 = *((_DWORD *)v81 + 7);
      if (v107 <= (int)v38) {
        break;
      }
      BOOL v81 = (uint64_t *)*v81;
      if (!v81) {
        goto LABEL_200;
      }
    }
    if (v107 >= (int)v38) {
      break;
    }
    BOOL v81 = (uint64_t *)v81[1];
    if (!v81) {
      goto LABEL_200;
    }
  }
  int v108 = *((unsigned __int8 *)v81 + 32);
  if (v108 != 1 && (v108 != 2 || v80 != 2))
  {
LABEL_206:
    LOBYTE(v78) = v76;
    goto LABEL_207;
  }
  int v134 = &qword_101B13290;
  LOBYTE(v134) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B13290, memory_order_acquire);
  if ((v134 & 1) == 0 && __cxa_guard_acquire(&qword_101B13290))
  {
    sub_100058DB0(buf, "5GE");
    sub_100058DB0(&v202, "LTEA");
    sub_100058DB0(&v205[4], "LTEPlus");
    qword_101B132A8 = 0;
    qword_101B132B0 = 0;
    qword_101B132B8 = 0;
    cf[0] = &qword_101B132A8;
    cf[1] = 0;
    qword_101B132A8 = (uint64_t)operator new(0x48uLL);
    qword_101B132B0 = qword_101B132A8;
    qword_101B132B8 = qword_101B132A8 + 72;
    uint64_t v177 = 0;
    qword_101B132B0 = (uint64_t)sub_1000D8A18((uint64_t)&qword_101B132B8, (long long *)buf, &v206, (char *)qword_101B132A8);
    do
    {
      if ((char)v205[v177 + 27] < 0) {
        operator delete(*(void **)&v205[v177 + 4]);
      }
      v177 -= 24;
    }
    while (v177 != -72);
    __cxa_atexit((void (*)(void *))sub_100E7F06C, &qword_101B132A8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B13290);
  }
  uint64_t v135 = (std::mutex *)Registry::getServiceMap(v134, *((Registry **)v6 + 13));
  xpc_object_t v136 = v135;
  uint64_t v137 = v41;
  if (v41 < 0)
  {
    BOOL v138 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v139 = 5381;
    do
    {
      uint64_t v137 = v139;
      unsigned int v140 = *v138++;
      uint64_t v139 = (33 * v139) ^ v140;
    }
    while (v140);
  }
  std::mutex::lock(v135);
  *(void *)long long buf = v137;
  BOOL v141 = sub_10004D37C(&v136[1].__m_.__sig, (unint64_t *)buf);
  if (!v141)
  {
    std::mutex::unlock(v136);
    LOBYTE(v78) = 0;
    goto LABEL_207;
  }
  uint64_t v78 = v141[3];
  uint64_t v142 = (std::__shared_weak_count *)v141[4];
  if (v142)
  {
    atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v136);
    atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v142);
    if (!v78) {
      goto LABEL_312;
    }
  }
  else
  {
    std::mutex::unlock(v136);
    if (!v78) {
      goto LABEL_207;
    }
  }
  __p[0] = 0;
  (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v78 + 80))(__p, v78, v38, 1, @"DataIndicatorOverrideForEvo", 0, 0);
  CFTypeRef cf2 = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v78 + 80))(&cf2, v78, v38, 2, @"DataIndicatorOverrideForEvo", 0, 0);
  if (__p[0]) {
    uint64_t v143 = sub_100080934;
  }
  else {
    uint64_t v143 = 0;
  }
  if (!v143 || (cf2 ? (uint64_t v144 = sub_100080934) : (uint64_t v144 = 0), !v144))
  {
    uint64_t v161 = *((void *)v6 + 5);
    if (!os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
    {
LABEL_310:
      LOBYTE(v78) = 0;
      goto LABEL_311;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v162 = "#I Not overriding 4G to EVO because override is not configured in carrier or operator bundle";
LABEL_309:
    _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_DEFAULT, v162, buf, 2u);
    goto LABEL_310;
  }
  if (!CFEqual(__p[0], cf2))
  {
    uint64_t v161 = *((void *)v6 + 5);
    if (!os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_310;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v162 = "#I Not overriding 4G to EVO because not on home network";
    goto LABEL_309;
  }
  uint64_t v190 = (capabilities::ct *)v142;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
  uint64_t v200 = *(void *)&buf[16];
  uint64_t v145 = qword_101B132A8;
  if (qword_101B132B0 == qword_101B132A8)
  {
LABEL_302:
    uint64_t v159 = *((void *)v6 + 5);
    if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v160 = cf;
      if (v200 < 0) {
        uint64_t v160 = (CFTypeRef *)cf[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v160;
      _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I Not overriding 4G to EVO because of unrecognized configured value %s", buf, 0xCu);
    }
    LOBYTE(v78) = 0;
    goto LABEL_318;
  }
  uint64_t v146 = 0;
  unint64_t v147 = (qword_101B132B0 - qword_101B132A8) / 24;
  uint64_t v148 = HIBYTE(v200);
  CFTypeRef v149 = cf[0];
  CFTypeRef v150 = cf[1];
  if (v200 >= 0) {
    CFTypeRef v151 = (CFTypeRef)HIBYTE(v200);
  }
  else {
    CFTypeRef v151 = cf[1];
  }
  if (v147 <= 1) {
    uint64_t v152 = 1;
  }
  else {
    uint64_t v152 = (qword_101B132B0 - qword_101B132A8) / 24;
  }
  LOBYTE(v78) = 1;
  while (1)
  {
    uint64_t v153 = v145 + 24 * v146;
    CFTypeRef v154 = (CFTypeRef)*(unsigned __int8 *)(v153 + 23);
    int v155 = (char)v154;
    if ((char)v154 < 0) {
      CFTypeRef v154 = *(CFTypeRef *)(v153 + 8);
    }
    if (v151 != v154) {
      goto LABEL_301;
    }
    uint64_t v156 = v155 >= 0 ? (unsigned __int8 *)(v145 + 24 * v146) : *(unsigned __int8 **)v153;
    if ((v148 & 0x80) != 0) {
      break;
    }
    if (!v148)
    {
      unsigned int v79 = v146 + 13;
      uint64_t v165 = v6;
      uint64_t v163 = *((void *)v6 + 5);
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v164 = cf;
LABEL_317:
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v164;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v79;
        _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "#I 4G overridden to %s (%d)", buf, 0x12u);
        goto LABEL_318;
      }
      goto LABEL_324;
    }
    uint64_t v157 = 0;
    while (*((unsigned __int8 *)cf + v157) == v156[v157])
    {
      if (v148 == ++v157)
      {
        unsigned int v79 = v146 + 13;
        uint64_t v163 = *((void *)v6 + 5);
        if (os_log_type_enabled(*((os_log_t *)v6 + 5), OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v164 = cf;
          goto LABEL_317;
        }
        goto LABEL_318;
      }
    }
LABEL_301:
    LOBYTE(v78) = ++v146 < v147;
    if (v146 == v152) {
      goto LABEL_302;
    }
  }
  unint64_t v180 = v147;
  uint64_t v181 = v145;
  uint64_t v184 = (void *)v149;
  uint64_t v178 = v152;
  CFTypeRef v179 = v151;
  int v158 = memcmp(v149, v156, (size_t)v150);
  uint64_t v152 = v178;
  CFTypeRef v151 = v179;
  unint64_t v147 = v180;
  uint64_t v145 = v181;
  CFTypeRef v149 = v184;
  if (v158) {
    goto LABEL_301;
  }
  unsigned int v79 = v146 + 13;
  uint64_t v165 = v6;
  uint64_t v163 = *((void *)v6 + 5);
  if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v164 = (CFTypeRef *)v184;
    goto LABEL_317;
  }
LABEL_324:
  BOOL v6 = v165;
LABEL_318:
  uint64_t v142 = (std::__shared_weak_count *)v190;
  if (SHIBYTE(v200) < 0) {
    operator delete((void *)cf[0]);
  }
LABEL_311:
  sub_1000577C4(&cf2);
  unint64_t DeviceEvoType = (unint64_t)sub_1000577C4((const void **)__p);
  if (v142) {
LABEL_312:
  }
    sub_10004D2C8(v142);
LABEL_207:
  int v110 = capabilities::ct::supports5G((capabilities::ct *)DeviceEvoType) ^ 1;
  if ((v31 - 7) > 1) {
    LOBYTE(v110) = 1;
  }
  if ((v110 & 1) == 0)
  {
    sub_10118358C((uint64_t)v6 + 4480, (int *)&v195);
    if (hasDataUiModifierBit())
    {
      uint64_t v112 = v195;
      __p[0] = 0;
      uint64_t v113 = (std::mutex *)Registry::getServiceMap(v111, *((Registry **)v6 + 13));
      uint64_t v114 = v113;
      if (v41 < 0)
      {
        uint64_t v115 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v116 = 5381;
        do
        {
          uint64_t v41 = v116;
          unsigned int v117 = *v115++;
          uint64_t v116 = (33 * v116) ^ v117;
        }
        while (v117);
      }
      std::mutex::lock(v113);
      *(void *)long long buf = v41;
      uint64_t v118 = sub_10004D37C(&v114[1].__m_.__sig, (unint64_t *)buf);
      if (v118)
      {
        uint64_t v120 = v118[3];
        uint64_t v119 = (std::__shared_weak_count *)v118[4];
        if (v119)
        {
          atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v114);
          atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v119);
          char v121 = 0;
          goto LABEL_221;
        }
      }
      else
      {
        uint64_t v120 = 0;
      }
      std::mutex::unlock(v114);
      uint64_t v119 = 0;
      char v121 = 1;
LABEL_221:
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v120 + 80))(__p, v120, v112, 1, @"DataIndicatorOverrideForNRMmwave", 0, 0);
      if ((v121 & 1) == 0) {
        sub_10004D2C8(v119);
      }
      if (__p[0]) {
        uint64_t v122 = sub_100080934;
      }
      else {
        uint64_t v122 = 0;
      }
      if (v122)
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13298, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_101B13298))
        {
          uint64_t v166 = 0;
          uint64_t v167 = 0;
          qword_101B132D0 = 0;
          qword_101B132C8 = 0;
          uint64_t v168 = &qword_101B132C8;
          qword_101B132C0 = (uint64_t)&qword_101B132C8;
          while (1)
          {
            uint64_t v169 = &(&off_101A95D58)[2 * v167];
            if (v168 == &qword_101B132C8) {
              break;
            }
            if (v166)
            {
              do
              {
                uint64_t v170 = (uint64_t *)v166;
                uint64_t v166 = *(void *)(v166 + 8);
              }
              while (v166);
            }
            else
            {
              uint64_t v171 = &qword_101B132C8;
              do
              {
                uint64_t v170 = (uint64_t *)v171[2];
                BOOL v36 = *v170 == (void)v171;
                uint64_t v171 = v170;
              }
              while (v36);
            }
            int v172 = sub_101198704((char *)v170[4], &(&off_101A95D58)[2 * v167]);
            uint64_t v166 = qword_101B132C8;
            if (v172) {
              goto LABEL_335;
            }
            if (qword_101B132C8)
            {
              xpc_object_t v174 = *v169;
              int v173 = &qword_101B132C8;
              while (1)
              {
                while (1)
                {
                  uint64_t v170 = (uint64_t *)v166;
                  BOOL v175 = (char **)(v166 + 32);
                  if (!sub_101198670(v174, (char **)(v166 + 32))) {
                    break;
                  }
                  uint64_t v166 = *v170;
                  int v173 = v170;
                  if (!*v170) {
                    goto LABEL_348;
                  }
                }
                if (!sub_101198704(*v175, &(&off_101A95D58)[2 * v167])) {
                  break;
                }
                int v173 = v170 + 1;
                uint64_t v166 = v170[1];
                if (!v166) {
                  goto LABEL_348;
                }
              }
LABEL_337:
              if (*v173) {
                goto LABEL_351;
              }
              goto LABEL_348;
            }
LABEL_347:
            int v173 = &qword_101B132C8;
            uint64_t v170 = &qword_101B132C8;
LABEL_348:
            int v176 = operator new(0x30uLL);
            v176[2] = *(_OWORD *)v169;
            *(void *)int v176 = 0;
            *((void *)v176 + 1) = 0;
            *((void *)v176 + 2) = v170;
            uint64_t *v173 = (uint64_t)v176;
            if (*(void *)qword_101B132C0)
            {
              qword_101B132C0 = *(void *)qword_101B132C0;
              int v176 = (_OWORD *)*v173;
            }
            sub_100046C90((uint64_t *)qword_101B132C8, (uint64_t *)v176);
            ++qword_101B132D0;
LABEL_351:
            if (++v167 == 4)
            {
              __cxa_guard_release(&qword_101B13298);
              goto LABEL_228;
            }
            uint64_t v168 = (uint64_t *)qword_101B132C0;
            uint64_t v166 = qword_101B132C8;
          }
          uint64_t v170 = &qword_101B132C8;
LABEL_335:
          if (v166)
          {
            int v173 = v170 + 1;
            goto LABEL_337;
          }
          goto LABEL_347;
        }
LABEL_228:
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
        uint64_t v200 = *(void *)&buf[16];
        uint64_t v123 = qword_101B132C8;
        if ((buf[23] & 0x80u) == 0) {
          uint64_t v124 = (char *)cf;
        }
        else {
          uint64_t v124 = *(char **)buf;
        }
        *(void *)long long buf = v124;
        if (!qword_101B132C8) {
          goto LABEL_238;
        }
        uint64_t v125 = &qword_101B132C8;
        do
        {
          int v126 = sub_101198704(*(char **)(v123 + 32), (char **)buf);
          uint64_t v127 = (uint64_t *)(v123 + 8);
          if (!v126)
          {
            uint64_t v127 = (uint64_t *)v123;
            uint64_t v125 = (uint64_t *)v123;
          }
          uint64_t v123 = *v127;
        }
        while (*v127);
        if (v125 == &qword_101B132C8 || (sub_101198670(v124, (char **)v125 + 4) & 1) != 0)
        {
LABEL_238:
          uint64_t v128 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**((void **)v6 + 6) + 16))(*((void *)v6 + 6), v112);
          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
          {
            int v129 = cf;
            if (v200 < 0) {
              int v129 = (CFTypeRef *)cf[0];
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v129;
            _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#N Unknown Nr data status indicator override string %s", buf, 0xCu);
          }
          unsigned int v79 = 8;
        }
        else
        {
          unsigned int v79 = *((_DWORD *)v125 + 10);
        }
        if (SHIBYTE(v200) < 0) {
          operator delete((void *)cf[0]);
        }
      }
      else
      {
        unsigned int v79 = 8;
      }
      sub_1000577C4((const void **)__p);
      goto LABEL_247;
    }
    if ((v185 & hasDataUiModifierBit()) == 1)
    {
      unsigned int v79 = 8;
LABEL_247:
      LOBYTE(v78) = 1;
    }
  }
  if (v79)
  {
    if (v79 != dword_101B0B948)
    {
      int v130 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v6 + 6) + 16))(*((void *)v6 + 6), v195);
      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v131 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v131;
        _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "#I Data Indicator override string %s", buf, 0xCu);
      }
    }
  }
  dword_101B0B948 = v79;
  if (v78)
  {
    *(void *)(a3 + 80) = v79;
    uint64_t v132 = a4;
    if (a4 <= 0xB) {
      uint64_t v132 = 11;
    }
    a4 = v132;
  }
  if (sub_1011835E4((uint64_t)v6, v194))
  {
    *(void *)(a3 + 24) = 0;
    if (a4 > 0xA)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 10;
      goto LABEL_27;
    }
  }
  return a4;
}

void sub_101183298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,int a25,void **a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  qword_101B132B0 = v47;
  sub_100047F64(&a26);
  uint64_t v49 = 0;
  while (1)
  {
    if (*(&a47 + v49) < 0) {
      operator delete(*(void **)((char *)&a42 + v49));
    }
    v49 -= 24;
    if (v49 == -72)
    {
      __cxa_guard_abort(&qword_101B13290);
      _Unwind_Resume(a1);
    }
  }
}

uint64_t *sub_10118358C(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000C14F0("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 4;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

uint64_t sub_1011835E4(uint64_t a1, int a2)
{
  uint64_t v3 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 728);

  return v5();
}

unint64_t sub_10118366C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return sub_101181B68((capabilities::ct *)(a1 - 56), a2, a3, a4);
}

unint64_t sub_101183674(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return sub_101181B68((capabilities::ct *)(a1 - 64), a2, a3, a4);
}

uint64_t sub_10118367C(uint64_t a1, int a2)
{
  return sub_1011835E4(a1 - 56, a2);
}

void sub_101183684(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  sub_10003E168(&v3, (void *)(a1 + 8));
  uint64_t v2 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_10003E168(&v3, v1);
  operator new();
}

void sub_1011837BC(uint64_t a1)
{
}

void sub_1011837C4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  BOOL v6 = (void *)a1;
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = sub_100B15758(a3);
    uint64_t v9 = asStringBool(*((unsigned char *)v6 + 312));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I refreshapn: reason %s : radio module ready %s", buf, 0x16u);
  }
  if (*((unsigned char *)v6 + 312))
  {
    if (!*((unsigned char *)v6 + 288))
    {
      int v10 = a5 ^ 1;
      if (a3 == 20) {
        int v10 = 1;
      }
      BOOL v44 = v10;
      uint64_t v11 = v6[14];
      *(void *)uint64_t v51 = v6[13];
      *(void *)&uint8_t v51[8] = v11;
      if (v11) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
      }
      subscriber::makeSimSlotRange();
      if (*(void *)&v51[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v51[8]);
      }
      BOOL v13 = *(unsigned int **)buf;
      int v12 = *(unsigned int **)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        uint64_t v14 = *(uint64_t (**)(void))&buf[16];
        while ((v14(*v13) & 1) == 0)
        {
          if (++v13 == v12)
          {
            BOOL v13 = v12;
            break;
          }
        }
        uint64_t v43 = *(uint64_t **)&buf[8];
        if (v13 != *(unsigned int **)&buf[8])
        {
          char v15 = 0;
          uint64_t v16 = (uint64_t *)&byte_10144BF80[128];
          unsigned int v42 = a3;
          uint64_t v46 = v6;
          do
          {
            unsigned int v17 = *v13;
            ServiceMap = (std::mutex *)Registry::getServiceMap(v16, (Registry *)v6[13]);
            int v19 = ServiceMap;
            if (v20 < 0)
            {
              uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v22 = 5381;
              do
              {
                uint64_t v20 = v22;
                unsigned int v23 = *v21++;
                uint64_t v22 = (33 * v22) ^ v23;
              }
              while (v23);
            }
            std::mutex::lock(ServiceMap);
            *(void *)uint64_t v51 = v20;
            int v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)v51);
            unsigned int v45 = v17;
            if (v24)
            {
              uint64_t v25 = v24[3];
              uint64_t v26 = (std::__shared_weak_count *)v24[4];
              if (v26)
              {
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v19);
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v26);
                char v27 = 0;
                if (!v25) {
                  goto LABEL_24;
                }
                goto LABEL_28;
              }
            }
            else
            {
              uint64_t v25 = 0;
            }
            std::mutex::unlock(v19);
            uint64_t v26 = 0;
            char v27 = 1;
            if (!v25)
            {
LABEL_24:
              int v28 = 0;
              if (v27) {
                goto LABEL_30;
              }
LABEL_29:
              sub_10004D2C8(v26);
              goto LABEL_30;
            }
LABEL_28:
            uint64_t v29 = asWirelessTechnology();
            int v28 = (*(uint64_t (**)(uint64_t, void, uint64_t, BOOL))(*(void *)v25 + 24))(v25, v17, v29, v44);
            if ((v27 & 1) == 0) {
              goto LABEL_29;
            }
LABEL_30:
            if (v15)
            {
              int v30 = v6[5];
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v51 = 136315138;
                *(void *)&uint8_t v51[4] = "resetAllPacketHandlersAPNs_sync";
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s: refreshapn: PDP Managers already updated", v51, 0xCu);
              }
              char v31 = 1;
            }
            else
            {
              uint64_t v32 = (uint64_t *)v6[517];
              CFTypeID v33 = (uint64_t *)v6[518];
              if (v32 == v33)
              {
                char v31 = 0;
              }
              else
              {
                char v31 = 0;
                do
                {
                  uint64_t v34 = *v32;
                  CFTypeRef v35 = (std::__shared_weak_count *)v32[1];
                  if (v35) {
                    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  uint64_t v49 = 0;
                  int v50 = 0;
                  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v34 + 64))(&v49, v34);
                  if (v49)
                  {
                    if (v28)
                    {
                      uint64_t v48 = 0;
                      (*(void (**)(void))(*(void *)v49 + 184))();
                      sub_100057D78(&v48);
                      char v31 = 1;
                    }
                    else
                    {
                      (*(void (**)(void))(*(void *)v49 + 176))();
                    }
                  }
                  else
                  {
                    BOOL v36 = v46[5];
                    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                    {
                      int v37 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 72))(v34);
                      *(_DWORD *)uint64_t v51 = 136315394;
                      *(void *)&uint8_t v51[4] = "resetAllPacketHandlersAPNs_sync";
                      *(_WORD *)&v51[12] = 1024;
                      *(_DWORD *)&v51[14] = v37;
                      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s: refreshapn: PDP Manager %d is not created yet!!!!!!", v51, 0x12u);
                    }
                  }
                  if (v50) {
                    sub_10004D2C8(v50);
                  }
                  if (v35) {
                    sub_10004D2C8(v35);
                  }
                  v32 += 2;
                }
                while (v32 != v33);
              }
            }
            if (v42 == 18) {
              BOOL v38 = 1;
            }
            else {
              BOOL v38 = v28;
            }
            sub_1011646C8(v46, v45, v42, v44, v38);
            char v15 = v31;
            BOOL v6 = v46;
            uint32_t v39 = sub_100B15758(v42);
            sub_1011792A4(v46, v45, (uint64_t)v39, 1, v42 == 18);
            char v40 = v13 + 1;
            BOOL v13 = v12;
            if (v40 != v12)
            {
              BOOL v13 = v40;
              while ((v14(*v13) & 1) == 0)
              {
                if (++v13 == v12)
                {
                  BOOL v13 = v12;
                  break;
                }
              }
            }
            uint64_t v16 = v43;
          }
          while (v13 != (unsigned int *)v43);
        }
      }
    }
  }
  else
  {
    uint64_t v41 = v6[5];
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "resetAllPacketHandlersAPNs_sync";
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
    }
  }
}

void sub_101183D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    sub_10004D2C8(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_101183DBC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
}

std::string *sub_101183DC4@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
  BOOL result = (std::string *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 1144))(a1, v4, 0);
  if ((result & 0x80000000) == 0)
  {
    if (result > 0xF) {
      BOOL v6 = "";
    }
    else {
      BOOL v6 = off_1019B2768[result];
    }
    return sub_10003ED78(a2, v6);
  }
  return result;
}

void sub_101183E80(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_101183E9C@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  return sub_101183DC4(a1 - 72, a2);
}

uint64_t sub_101183EA4(uint64_t a1, unsigned int a2)
{
  if (!*(unsigned char *)(a1 + 312))
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      int v10 = "pdpCopyInfo";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v9, 0xCu);
    }
    return 0;
  }
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 4136);
  if (a2 >= (unint64_t)((*(void *)(a1 + 4144) - v2) >> 4)) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)(v2 + 16 * a2);
  uint64_t v4 = *v3;
  uint64_t v5 = (std::__shared_weak_count *)v3[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 104))(v4);
    if (!v5) {
      return v6;
    }
    goto LABEL_14;
  }
  uint64_t v6 = 0;
  if (v5) {
LABEL_14:
  }
    sub_10004D2C8(v5);
  return v6;
}

void sub_101183FD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101183FE8(uint64_t a1, unsigned int a2)
{
  return sub_101183EA4(a1 - 56, a2);
}

void sub_101183FF0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 312))
  {
    if ((a2 & 0x80000000) == 0)
    {
      uint64_t v3 = *(void *)(a1 + 4136);
      if (a2 < (unint64_t)((*(void *)(a1 + 4144) - v3) >> 4))
      {
        uint64_t v4 = (uint64_t *)(v3 + 16 * a2);
        uint64_t v5 = *v4;
        uint64_t v6 = (std::__shared_weak_count *)v4[1];
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v5) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 112))(v5, a3);
        }
        if (v6)
        {
          sub_10004D2C8(v6);
        }
      }
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      int v9 = "pdpErrorThrottling";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v8, 0xCu);
    }
  }
}

void sub_101184138(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101184150(uint64_t a1, unsigned int a2, uint64_t a3)
{
}

void sub_101184158(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if (*(unsigned char *)(a1 + 312))
  {
    if ((a2 & 0x80000000) != 0
      || (uint64_t v4 = *(void *)(a1 + 4136), a2 >= (unint64_t)((*(void *)(a1 + 4144) - v4) >> 4)))
    {
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v5 = (uint64_t *)(v4 + 16 * a2);
      uint64_t v6 = *v5;
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 120))(v6);
        if (!v7) {
          return;
        }
        goto LABEL_11;
      }
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    if (!v7) {
      return;
    }
LABEL_11:
    sub_10004D2C8(v7);
    return;
  }
  int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    int v10 = "getPDPInterface";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", (uint8_t *)&v9, 0xCu);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
}

void sub_1011842C0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011842D8(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
}

void sub_1011842E0(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(a1 + 4136), a2 >= (unint64_t)((*(void *)(a1 + 4144) - v3) >> 4)))
  {
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  uint64_t v4 = (uint64_t *)(v3 + 16 * a2);
  uint64_t v5 = *v4;
  uint64_t v6 = (std::__shared_weak_count *)v4[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v5)
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    if (!v6) {
      return;
    }
    goto LABEL_7;
  }
  (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  if (!v6) {
    return;
  }
LABEL_7:

  sub_10004D2C8(v6);
}

void sub_101184388(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011843A0(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
}

uint64_t sub_1011843A8(void *a1, uint64_t a2)
{
  if (!sub_100AF2240(a1[18], a2) || !(*(unsigned int (**)(void *, uint64_t))(*a1 + 2064))(a1, a2)) {
    return 0;
  }
  if (qword_101B14190)
  {
    uint64_t v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!DataPlanManagerBootstrap::sInstance
        || ((*(uint64_t (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 104))() & 1) != 0)
      {
        uint64_t v6 = 1;
LABEL_36:
        sub_10004D2C8(v5);
        return v6;
      }
      uint64_t v8 = sub_100AEFE40(a1[18], a2);
      int v9 = *(uint64_t **)v8;
      int v10 = *(uint64_t **)(v8 + 8);
      if (*(uint64_t **)v8 == v10)
      {
        uint64_t v11 = 0;
        int v18 = 0;
        unsigned int v17 = "";
LABEL_31:
        uint64_t v16 = a1[5];
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315650;
          *(void *)uint64_t v20 = "isInternetAllowed";
          *(_WORD *)&v20[8] = 1024;
          *(_DWORD *)&v20[10] = v18;
          __int16 v21 = 2080;
          uint64_t v22 = v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: not allowed by DataPlan, canActivate result %d(%s)", buf, 0x1Cu);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
        uint64_t v6 = 0;
        goto LABEL_36;
      }
      int v18 = 0;
      uint64_t v11 = 0;
      unsigned int v17 = "";
      while (1)
      {
        uint64_t v13 = *v9;
        int v12 = (std::__shared_weak_count *)v9[1];
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v13) {
          break;
        }
        int v14 = 3;
        if (v12) {
          goto LABEL_20;
        }
LABEL_21:
        if (v14 == 3 || !v14)
        {
          v9 += 2;
          if (v9 != v10) {
            continue;
          }
        }
        goto LABEL_31;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 472))(v13))
      {
        int v14 = 0;
        if (!v12) {
          goto LABEL_21;
        }
      }
      else
      {
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v13 + 80))(buf, v13, 0);
        int v18 = *(_DWORD *)buf;
        unsigned int v17 = *(const char **)&v20[4];
        char v15 = v24;
        uint64_t v23 = 0;
        int v24 = 0;
        if (v11)
        {
          sub_10004D2C8(v11);
          if (v24) {
            sub_10004D2C8(v24);
          }
        }
        int v14 = 2;
        uint64_t v11 = v15;
        if (!v12) {
          goto LABEL_21;
        }
      }
LABEL_20:
      sub_10004D2C8(v12);
      goto LABEL_21;
    }
  }
  return 1;
}

void sub_101184698(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011846D4(uint64_t a1, uint64_t a2)
{
  return sub_1011843A8((void *)(a1 - 56), a2);
}

uint64_t sub_1011846DC(uint64_t a1, uint64_t a2)
{
  return sub_1011843A8((void *)(a1 - 64), a2);
}

uint64_t sub_1011846E4(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 != 1) {
    return 1;
  }
  uint64_t v8 = 0;
  int v9 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 1536))(&v8);
  if (v8) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a3, a4);
  }
  else {
    uint64_t v6 = 1;
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return v6;
}

void sub_1011847A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011847BC(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  return sub_1011846E4(a1 - 56, a2, a3, a4);
}

uint64_t sub_1011847C4(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  return sub_1011846E4(a1 - 64, a2, a3, a4);
}

uint64_t sub_1011847CC(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  return sub_1011846E4(a1 - 72, a2, a3, a4);
}

uint64_t sub_1011847D4(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a3);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v5) {
    return 0;
  }
  if (!a2)
  {
    uint64_t v6 = *(void **)(v5 + 24);
    if (v6) {
      goto LABEL_5;
    }
    return 0;
  }
  if (a2 != 1) {
    return 0;
  }
  uint64_t v6 = *(void **)(v5 + 40);
  if (!v6) {
    return 0;
  }
LABEL_5:
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)((char *)v6 + *(void *)(*v6 - 320)) + 152);

  return v7();
}

uint64_t sub_10118488C(uint64_t a1, int a2, int a3)
{
  return sub_1011847D4(a1 - 64, a2, a3);
}

uint64_t sub_101184894(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = sub_10003B004(*(void *)(a1 + 144), a3);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v5) {
    return 0;
  }
  if (!a2)
  {
    uint64_t v6 = *(void **)(v5 + 24);
    if (v6) {
      goto LABEL_5;
    }
    return 0;
  }
  if (a2 != 1) {
    return 0;
  }
  uint64_t v6 = *(void **)(v5 + 40);
  if (!v6) {
    return 0;
  }
LABEL_5:
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)((char *)v6 + *(void *)(*v6 - 320)) + 160);

  return v7();
}

uint64_t sub_10118494C(uint64_t a1, int a2, int a3)
{
  return sub_101184894(a1 - 64, a2, a3);
}

void sub_101184954(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v13 = sub_10003B004(*(void *)(a1 + 144), a3);
  if (*(void *)(*(void *)(a1 + 144) + 16) == v13) {
    goto LABEL_18;
  }
  if (a2)
  {
    if (a2 == 1)
    {
      int v14 = *(char **)(v13 + 40);
      if (v14)
      {
        uint64_t v15 = *(void *)(*(void *)v14 - 320);
        uint64_t v16 = (std::__shared_weak_count *)a4[1];
        uint64_t v31 = *a4;
        uint64_t v32 = v16;
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long __p = 0;
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        sub_1008DB9AC(&__p, *(const void **)a5, *(void *)(a5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 2));
        (*(void (**)(char *, uint64_t *, void **, uint64_t))(*(void *)&v14[v15] + 256))(&v14[v15], &v31, &__p, a6);
        if (__p)
        {
          uint64_t v29 = __p;
          operator delete(__p);
        }
        unsigned int v17 = v32;
        if (!v32) {
          return;
        }
LABEL_17:
        sub_10004D2C8(v17);
        return;
      }
    }
    goto LABEL_18;
  }
  int v18 = *(char **)(v13 + 24);
  if (!v18)
  {
LABEL_18:
    uint64_t v21 = asString();
    *(_DWORD *)a7 = -9;
    uint64_t v22 = "";
    if (v21) {
      uint64_t v22 = (const char *)v21;
    }
    *(void *)(a7 + 8) = "Data not supported for this technology (controller)";
    *(void *)(a7 + 16) = v22;
    *(_DWORD *)(a7 + 24) = 0;
    *(unsigned char *)(a7 + 28) = 0;
    *(_DWORD *)(a7 + 32) = a2;
    *(void *)(a7 + 44) = 0;
    *(void *)(a7 + 36) = 0;
    *(_DWORD *)(a7 + 52) = 0;
    return;
  }
  uint64_t v19 = *(void *)(*(void *)v18 - 320);
  uint64_t v20 = (std::__shared_weak_count *)a4[1];
  uint64_t v26 = *a4;
  char v27 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  sub_1008DB9AC(&v23, *(const void **)a5, *(void *)(a5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 2));
  (*(void (**)(char *, uint64_t *, void **, uint64_t))(*(void *)&v18[v19] + 256))(&v18[v19], &v26, &v23, a6);
  if (v23)
  {
    int v24 = v23;
    operator delete(v23);
  }
  unsigned int v17 = v27;
  if (v27) {
    goto LABEL_17;
  }
}

void sub_101184B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_101184BB8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (!a18) {
    JUMPOUT(0x101184BB0);
  }
  JUMPOUT(0x101184BACLL);
}

void sub_101184BE0(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
}

uint64_t sub_101184BE8(capabilities::ct *a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = a1;
  if (!a5
    || (int v9 = *(_DWORD *)(*(void *)a4 + 52),
        a1 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *))(*(void *)a1 + 1072))(a1),
        v9 != a1)
    || (uint64_t v10 = *((void *)v8 + 517), *((void *)v8 + 518) == v10))
  {
    if (capabilities::ct::shouldUseLastPDPsForHighPriorityMedia(a1)
      && (uint64_t v13 = *((void *)v8 + 517), v14 = *((void *)v8 + 518) - v13, (unint64_t)v14 >= 0x31))
    {
      uint64_t v15 = 0;
      uint64_t v16 = v14 >> 4;
      while ((qword_1015C55C8[v15] & a3) == 0)
      {
        if (++v15 == 3) {
          goto LABEL_44;
        }
      }
      uint64_t v20 = v13 + 16 * v16;
      uint64_t v22 = *(void *)(v20 - 16);
      uint64_t v21 = *(std::__shared_weak_count **)(v20 - 8);
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v13 = *((void *)v8 + 517);
        uint64_t v16 = (*((void *)v8 + 518) - v13) >> 4;
      }
      uint64_t v23 = v13 + 16 * v16;
      uint64_t v25 = *(void *)(v23 - 32);
      int v24 = *(std::__shared_weak_count **)(v23 - 24);
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)v22 + 88))(v22))
      {
        if (((*(uint64_t (**)(uint64_t))(*(void *)v25 + 88))(v25) & 1) == 0
          || (unsigned int v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 552))(v25),
              char v27 = v21,
              v26 > (*(unsigned int (**)(uint64_t))(*(void *)v22 + 552))(v22)))
        {
          if (v24) {
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v21) {
            sub_10004D2C8(v21);
          }
          uint64_t v22 = v25;
          char v27 = v24;
        }
      }
      else
      {
        char v27 = v21;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 552))(v22) <= a2)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 40))(v22);
        int v28 = *((void *)v8 + 5);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 72))(v22);
          *(_DWORD *)long long buf = 136315394;
          BOOL v38 = "chooseSettingActivator";
          __int16 v39 = 1024;
          int v40 = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: IMS last pdp %d chosen", buf, 0x12u);
        }
      }
      if (v27) {
        sub_10004D2C8(v27);
      }
      if (v24) {
        sub_10004D2C8(v24);
      }
      if (v21) {
        sub_10004D2C8(v21);
      }
      if (v18) {
        return v18;
      }
      uint64_t v14 = *((void *)v8 + 518) - *((void *)v8 + 517);
LABEL_44:
      uint64_t v30 = (char *)operator new(0xCuLL);
      uint64_t v34 = v30;
      BOOL v36 = v30 + 12;
      *(_DWORD *)uint64_t v30 = 0;
      *(int32x2_t *)(v30 + 4) = vadd_s32(vdup_n_s32((unint64_t)v14 >> 4), (int32x2_t)-2);
      CFTypeRef v35 = v30 + 12;
      uint64_t v18 = sub_101185104((uint64_t)v8, a2, (uint64_t)&v34, 0, 0);
      uint64_t v19 = v34;
      if (!v34) {
        return v18;
      }
      CFTypeRef v35 = v34;
    }
    else
    {
      unsigned int v17 = operator new(4uLL);
      long long __p = v17;
      _DWORD *v17 = 0;
      uint64_t v32 = v17 + 1;
      CFTypeID v33 = v17 + 1;
      uint64_t v18 = sub_101185104((uint64_t)v8, a2, (uint64_t)&__p, *(_DWORD *)(*(void *)a4 + 52), a3);
      uint64_t v19 = __p;
      if (!__p) {
        return v18;
      }
      uint64_t v32 = __p;
    }
    operator delete(v19);
    return v18;
  }
  uint64_t v11 = *(uint64_t (**)(void))(**(void **)v10 + 40);

  return v11();
}

void sub_101185090(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (v15)
  {
    sub_10004D2C8(v15);
    if (!v14)
    {
LABEL_3:
      if (!v13) {
LABEL_8:
      }
        _Unwind_Resume(exception_object);
LABEL_7:
      sub_10004D2C8(v13);
      goto LABEL_8;
    }
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v14);
  if (!v13) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t sub_101185104(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6[3] = a3;
  uint64_t v7 = 0;
  v6[0] = &v7;
  v6[1] = a1;
  _OWORD v6[2] = a2;
  if (!a5) {
    goto LABEL_3;
  }
  uint64_t v11 = off_101A98F08;
  uint64_t v12 = a4;
  uint64_t v13 = a5;
  uint64_t v14 = &v11;
  sub_101198390((uint64_t)v10, (uint64_t)&v11);
  sub_1011852D4((uint64_t)v6, (uint64_t)"matching connectionMask first", (uint64_t)v10);
  sub_10119830C(v10);
  sub_10119830C(&v11);
  uint64_t result = v7;
  if (!v7)
  {
LABEL_3:
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v11 = off_101A98F98;
    uint64_t v14 = &v11;
    sub_101198390((uint64_t)v9, (uint64_t)&v11);
    sub_1011852D4((uint64_t)v6, (uint64_t)"first", (uint64_t)v9);
    sub_10119830C(v9);
    sub_10119830C(&v11);
    uint64_t result = v7;
    if (!v7)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v11 = off_101A99018;
      uint64_t v14 = &v11;
      sub_101198390((uint64_t)v8, (uint64_t)&v11);
      sub_1011852D4((uint64_t)v6, (uint64_t)"second", (uint64_t)v8);
      sub_10119830C(v8);
      sub_10119830C(&v11);
      return v7;
    }
  }
  return result;
}

void sub_101185288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10119830C(va);
  sub_10119830C((void *)(v6 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_1011852CC(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  return sub_101184BE8((capabilities::ct *)(a1 - 56), a2, a3, a4, a5);
}

void sub_1011852D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = (uint64_t *)v3[517];
  uint64_t v5 = (uint64_t *)v3[518];
  if (v4 != v5)
  {
    unsigned int v9 = 0;
    do
    {
      uint64_t v10 = *v4;
      uint64_t v24 = *v4;
      uint64_t v11 = (std::__shared_weak_count *)v4[1];
      uint64_t v25 = v11;
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 72))(v10))
      {
        uint64_t v12 = *(__int32 ***)(a1 + 24);
        uint64_t v14 = *v12;
        uint64_t v13 = v12[1];
        __int32 v15 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 72))(v24);
        uint64_t v16 = wmemchr(v14, v15, v13 - v14);
        unsigned int v17 = v16 ? v16 : v13;
        if (v17 == *(__int32 **)(*(void *)(a1 + 24) + 8))
        {
          uint64_t v18 = *(void *)(a3 + 24);
          if (!v18) {
            sub_10007B600();
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v18 + 48))(v18, &v24))
          {
            unsigned int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 552))(v24);
            unsigned int v20 = v19;
            if (v19 > *(_DWORD *)(a1 + 16) && v19 > v9)
            {
              **(void **)a1 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 40))(v24);
              uint64_t v22 = v3[5];
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 72))(v24);
                *(_DWORD *)long long buf = 136315650;
                char v27 = "operator()";
                __int16 v28 = 2080;
                uint64_t v29 = a2;
                __int16 v30 = 1024;
                int v31 = v23;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: %s grade pdp %d chosen", buf, 0x1Cu);
              }
              unsigned int v9 = v20;
            }
          }
        }
      }
      if (v25) {
        sub_10004D2C8(v25);
      }
      v4 += 2;
    }
    while (v4 != v5);
  }
}

void sub_101185570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10118559C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 4264);
  *a2 = *(void *)(result + 4256);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011855BC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 4208);
  *a2 = *(void *)(result + 4200);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

BOOL sub_1011855DC(uint64_t a1, int a2, int a3)
{
  BOOL result = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1072))(a1) != a2)
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1072))(a1);
    if (v5 == (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1088))(a1) && a3 == 0) {
      return 1;
    }
  }
  return result;
}

BOOL sub_1011856BC(uint64_t a1, int a2, int a3)
{
  return sub_1011855DC(a1 - 56, a2, a3);
}

uint64_t sub_1011856C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4240) + 112))();
}

uint64_t sub_1011856EC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4168) + 112))();
}

uint64_t sub_101185714(uint64_t a1, int a2, int a3)
{
  v12[0] = 1;
  v12[1] = a1 + 3352;
  uint64_t v6 = *(void *)(a1 + 3392);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v6;
        int v8 = *(_DWORD *)(v6 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v6 = *(void *)v7;
        unsigned int v9 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v6 = *(void *)(v7 + 8);
      if (!v6)
      {
        unsigned int v9 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v9 = (uint64_t **)(a1 + 3392);
    uint64_t v7 = a1 + 3392;
LABEL_9:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    *((_DWORD *)v10 + 7) = a2;
    *((_DWORD *)v10 + 8) = 0;
    sub_100046C38((uint64_t **)(a1 + 3384), v7, v9, v10);
    uint64_t v7 = (uint64_t)v10;
  }
  *(_DWORD *)(v7 + 32) = a3;
  return sub_101198798((uint64_t)v12);
}

void sub_1011857D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1011857EC(uint64_t a1, int a2, int a3)
{
  return sub_101185714(a1 - 72, a2, a3);
}

uint64_t sub_1011857F4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 848);
  uint64_t v2 = (void *)(a1 + 856);
  if (v1 == (void *)(a1 + 856)) {
    return 0;
  }
  do
  {
    if (*((unsigned char *)v1 + 56)) {
      BOOL v3 = *((unsigned char *)v1 + 58) == 0;
    }
    else {
      BOOL v3 = 1;
    }
    uint64_t result = !v3;
    if (!v3) {
      break;
    }
    int v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        int v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        uint64_t v6 = (void *)v1[2];
        BOOL v3 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }
      while (!v3);
    }
    uint64_t v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t sub_101185860(uint64_t a1)
{
  return sub_1011857F4(a1 - 72);
}

BOOL sub_101185868(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a2 == 2)
  {
    uint64_t v4 = (unsigned __int8 *)(a1 + 2772);
    return *v4 != 0;
  }
  if (a2 == 1)
  {
    uint64_t v4 = (unsigned __int8 *)(a1 + 1972);
    return *v4 != 0;
  }
  return 0;
}

BOOL sub_1011858C4(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 48));
  if (a2 == 1)
  {
    uint64_t v4 = 1900;
    return *(unsigned char *)(a1 + v4) != 0;
  }
  if (a2 == 2)
  {
    uint64_t v4 = 2700;
    return *(unsigned char *)(a1 + v4) != 0;
  }
  return 0;
}

uint64_t sub_101185920(uint64_t a1, uint64_t a2)
{
  return sub_100060854(a2, 0x100000001);
}

uint64_t sub_10118592C(uint64_t a1, uint64_t a2)
{
  return sub_100060854(a2, 0x100000001);
}

uint64_t sub_101185938()
{
  return 0;
}

uint64_t sub_101185940()
{
  return 0;
}

uint64_t sub_101185948()
{
  return 0;
}

uint64_t sub_101185950()
{
  return 0;
}

void sub_101185958(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v23 = a2;
  int v5 = (uint64_t **)(a1 + 4480);
  if (*(_DWORD *)sub_10118358C(a1 + 4480, (int *)&v23) != a3)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v23);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      __p[0] = &v23;
      uint64_t v7 = sub_10030B04C(v5, (int *)&v23, (uint64_t)&unk_10144E20E, (unsigned int **)__p);
      asStringUiMask((uint64_t *)v18, *((_DWORD *)v7 + 8));
      int v8 = SBYTE7(v19);
      unsigned int v9 = (void **)v18[0];
      asStringUiMask((uint64_t *)__p, a3);
      uint64_t v10 = v18;
      if (v8 < 0) {
        uint64_t v10 = v9;
      }
      if (v22 >= 0) {
        uint64_t v11 = __p;
      }
      else {
        uint64_t v11 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v25 = v10;
      __int16 v26 = 2082;
      char v27 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Updating data ui modifier from %{public}s to %{public}s", buf, 0x16u);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
      if (SBYTE7(v19) < 0) {
        operator delete(v18[0]);
      }
    }
    v18[0] = &v23;
    *((_DWORD *)sub_10030B04C(v5, (int *)&v23, (uint64_t)&unk_10144E20E, (unsigned int **)v18) + 8) = a3;
    v18[0] = (void *)1;
    long long v19 = 0u;
    uint64_t v20 = 0;
    v18[1] = (void *)(a1 + 3680);
    uint64_t v12 = sub_10098AC2C((uint64_t *)&v19, a1 + 3712);
    __p[0] = &v23;
    *((_DWORD *)sub_10030B04C((uint64_t **)v12, (int *)&v23, (uint64_t)&unk_10144E20E, (unsigned int **)__p) + 8) = a3;
    sub_1011987FC((uint64_t)v18);
    uint64_t v13 = sub_100AEFE40(*(void *)(a1 + 144), v23);
    uint64_t v14 = *(uint64_t **)v13;
    __int32 v15 = *(uint64_t **)(v13 + 8);
    if (*(uint64_t **)v13 != v15)
    {
      do
      {
        uint64_t v16 = *v14;
        unsigned int v17 = (std::__shared_weak_count *)v14[1];
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v16) {
          (*(void (**)(uint64_t, uint64_t, void, void, void))(*(void *)v16 + 520))(v16, 21, 0, 0, 0);
        }
        if (v17) {
          sub_10004D2C8(v17);
        }
        v14 += 2;
      }
      while (v14 != v15);
    }
  }
}

void sub_101185BF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101185C3C(uint64_t a1, unsigned int a2, unsigned int a3)
{
}

uint64_t sub_101185C44(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[14];
  long long v19 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v19) {
    sub_10004D2C8(v19);
  }
  BOOL v3 = v20;
  if (v20 == v21) {
    return 0;
  }
  while ((v22(*v3) & 1) == 0)
  {
    if (++v3 == v21)
    {
      BOOL v3 = v21;
      break;
    }
  }
  if (v3 == v21) {
    return 0;
  }
  uint64_t v4 = a1 + 642;
  int v5 = a1 + 639;
  while (1)
  {
    signed int v6 = *v3;
    uint64_t v7 = *v4;
    if (*v4)
    {
      int v8 = v4;
      do
      {
        signed int v9 = *(_DWORD *)(v7 + 32);
        BOOL v10 = v9 < v6;
        if (v9 >= v6) {
          uint64_t v11 = (uint64_t *)v7;
        }
        else {
          uint64_t v11 = (uint64_t *)(v7 + 8);
        }
        if (!v10) {
          int v8 = (void *)v7;
        }
        uint64_t v7 = *v11;
      }
      while (*v11);
      if (v8 != v4 && v6 >= *((_DWORD *)v8 + 8) && v8[5]) {
        return 1;
      }
    }
    uint64_t v12 = *v5;
    if (*v5)
    {
      uint64_t v13 = v5;
      do
      {
        signed int v14 = *(_DWORD *)(v12 + 28);
        BOOL v15 = v14 < v6;
        if (v14 >= v6) {
          uint64_t v16 = (uint64_t *)v12;
        }
        else {
          uint64_t v16 = (uint64_t *)(v12 + 8);
        }
        if (!v15) {
          uint64_t v13 = (void *)v12;
        }
        uint64_t v12 = *v16;
      }
      while (*v16);
      if (v13 != v5 && v6 >= *((_DWORD *)v13 + 7) && *((unsigned char *)v13 + 32)) {
        return 1;
      }
    }
    unsigned int v17 = v3 + 1;
    BOOL v3 = v21;
    if (v17 != v21)
    {
      BOOL v3 = v17;
      while ((v22(*v3) & 1) == 0)
      {
        if (++v3 == v21)
        {
          BOOL v3 = v21;
          break;
        }
      }
    }
    if (v3 == v21) {
      return 0;
    }
  }
}

void sub_101185DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101185DDC(uint64_t a1)
{
  return sub_101185C44((void *)(a1 - 56));
}

uint64_t sub_101185DE4(uint64_t a1)
{
  return sub_101185C44((void *)(a1 - 64));
}

uint64_t sub_101185DEC(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = *(void *)(a1 + 1088);
  uint64_t v3 = *(void *)(a1 + 1096);
  if (v2 == v3) {
    return 0;
  }
  char v4 = *((unsigned char *)a2 + 23);
  if (v4 >= 0) {
    int v5 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    int v5 = a2[1];
  }
  if (v4 >= 0) {
    signed int v6 = (unsigned __int8 *)a2;
  }
  else {
    signed int v6 = *a2;
  }
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 *)(v2 + 23);
    if ((v7 & 0x80u) == 0) {
      int v8 = (unsigned __int8 *)*(unsigned __int8 *)(v2 + 23);
    }
    else {
      int v8 = *(unsigned __int8 **)(v2 + 8);
    }
    if (v8 != v5) {
      goto LABEL_19;
    }
    if ((v7 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v2 + 23)) {
      return 1;
    }
    uint64_t v9 = 0;
    while (*(unsigned __int8 *)(v2 + v9) == v6[v9])
    {
      if (v7 == ++v9) {
        return 1;
      }
    }
LABEL_19:
    v2 += 24;
    if (v2 == v3) {
      return 0;
    }
  }
  if (memcmp(*(const void **)v2, v6, *(void *)(v2 + 8))) {
    goto LABEL_19;
  }
  return 1;
}

uint64_t sub_101185EA8(uint64_t a1, unsigned __int8 **a2)
{
  return sub_101185DEC(a1 - 64, a2);
}

void sub_101185EB0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (*(void *)(a1 + 40))
      {
        signed int v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = 136315138;
          uint64_t v20 = "handleBasebandRefreshComplete_sync_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: PostBasebandRefreshTimer fired", (uint8_t *)&v19, 0xCu);
        }
        uint64_t v7 = (uint64_t *)v3[642];
        if (v7)
        {
          int v8 = *(_DWORD *)(a1 + 56);
          uint64_t v9 = v3 + 642;
          uint64_t v10 = v3[642];
          do
          {
            int v11 = *(_DWORD *)(v10 + 32);
            BOOL v12 = v11 < v8;
            if (v11 >= v8) {
              uint64_t v13 = (uint64_t *)v10;
            }
            else {
              uint64_t v13 = (uint64_t *)(v10 + 8);
            }
            if (!v12) {
              uint64_t v9 = (void *)v10;
            }
            uint64_t v10 = *v13;
          }
          while (*v13);
          if (v9 != v3 + 642 && *((_DWORD *)v9 + 8) <= v8)
          {
            signed int v14 = (void *)v9[1];
            if (v14)
            {
              do
              {
                BOOL v15 = v14;
                signed int v14 = (void *)*v14;
              }
              while (v14);
            }
            else
            {
              uint64_t v16 = v9;
              do
              {
                BOOL v15 = (void *)v16[2];
                BOOL v17 = *v15 == (void)v16;
                uint64_t v16 = v15;
              }
              while (!v17);
            }
            if ((void *)v3[641] == v9) {
              v3[641] = v15;
            }
            --v3[643];
            sub_10005EE6C(v7, v9);
            uint64_t v18 = (std::__shared_weak_count *)v9[6];
            if (v18) {
              sub_10004D2C8(v18);
            }
            operator delete(v9);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101186038(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_101186138(uint64_t a1)
{
}

void sub_101186140(uint64_t a1, int a2)
{
  char v4 = *(std::__shared_weak_count **)(a1 + 112);
  int v11 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (isValidSimSlot)
  {
    uint64_t v6 = sub_100AEFE40(*(void *)(a1 + 144), a2);
    uint64_t v7 = *(uint64_t **)(v6 + 56);
    for (unint64_t i = *(uint64_t **)(v6 + 64); v7 != i; v7 += 2)
    {
      uint64_t v9 = *v7;
      uint64_t v10 = (std::__shared_weak_count *)v7[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v9 + 1144))(v9);
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
  }
}

void sub_10118621C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101186244(uint64_t a1, int a2)
{
}

void sub_10118624C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_101186358(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_101186360(capabilities::ct *a1, int a2, uint64_t *a3)
{
  int v25 = a2;
  uint64_t result = capabilities::ct::supports5G(a1);
  if (result)
  {
    v22[0] = 1;
    long long v23 = 0u;
    uint64_t v24 = 0;
    v22[1] = (char *)a1 + 4528;
    uint64_t v7 = (void *)sub_100A57A18((uint64_t)&v23, (uint64_t)a1 + 4560);
    int v8 = (uint64_t *)&v23 + 1;
    uint64_t v9 = *((void *)&v23 + 1);
    if (!*((void *)&v23 + 1)) {
      goto LABEL_13;
    }
    uint64_t v10 = (uint64_t *)&v23 + 1;
    do
    {
      int v11 = (uint64_t *)v9;
      BOOL v12 = v10;
      int v13 = *(_DWORD *)(v9 + 28);
      if (v13 >= a2) {
        uint64_t v10 = (uint64_t *)v9;
      }
      else {
        v9 += 8;
      }
      uint64_t v9 = *(void *)v9;
    }
    while (v9);
    if (v10 != (uint64_t *)((char *)&v23 + 8)
      && (v13 >= a2 ? (v14 = v11) : (v14 = v12), int v8 = v10, *((_DWORD *)v14 + 7) <= a2))
    {
      uint64_t v18 = v12 + 4;
      int v19 = v11 + 4;
      BOOL v20 = v13 < a2;
      uint64_t v21 = *a3;
      if (v20) {
        int v19 = v18;
      }
      *((unsigned char *)v19 + 8) = *((unsigned char *)a3 + 8);
      uint64_t *v19 = v21;
    }
    else
    {
LABEL_13:
      char v27 = 0;
      uint64_t v26 = 0;
      BOOL v15 = sub_10005CF3C(v7, v8, &v27, &v26, &v25);
      if (!*v15)
      {
        uint64_t v16 = operator new(0x30uLL);
        v16[7] = v25;
        *((void *)v16 + 4) = *a3;
        v16[10] = *((_DWORD *)a3 + 2);
        BOOL v17 = v27;
        *(void *)uint64_t v16 = 0;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = v17;
        *BOOL v15 = (uint64_t)v16;
        if (*(void *)v23)
        {
          *(void *)&long long v23 = *(void *)v23;
          uint64_t v16 = (_DWORD *)*v15;
        }
        sub_100046C90(*((uint64_t **)&v23 + 1), (uint64_t *)v16);
        ++v24;
      }
    }
    return sub_101199178((uint64_t)v22);
  }
  return result;
}

void sub_1011864D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1011864EC(uint64_t a1, int a2, uint64_t *a3)
{
  return sub_101186360((capabilities::ct *)(a1 - 72), a2, a3);
}

void sub_1011864F4(wis::MetricFactory *a1)
{
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v2 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80063u);
  if (v2)
  {
    uint64_t v3 = (wis::MetricContainer *)v2;
    uint64_t v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    int v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    wis::MetricContainer::~MetricContainer(v3);
    operator delete();
  }
}

void sub_101186660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1011866E4(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(a1 + 40);
  int v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "True";
    if (!v4) {
      uint64_t v6 = "False";
    }
    int v8 = 136315138;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Submitting the AWD metric for cellular data switch state: %s", (uint8_t *)&v8, 0xCu);
  }
  a2[7] |= 2u;
  a2[4] = v4;
  atomic_load((unsigned int *)(v3 + 4200));
  uint64_t result = subscriber::simSlotAsInstance();
  a2[7] |= 4u;
  a2[5] = result;
  return result;
}

void sub_1011867D8(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_1011868C4(uint64_t a1)
{
}

void sub_1011868CC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_1011869B0(uint64_t a1)
{
}

uint64_t sub_1011869BC(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 5096);
}

uint64_t sub_1011869C4(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 5040);
}

void sub_1011869CC(uint64_t a1, int a2, int a3, char a4, uint64_t a5)
{
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  char v9 = a4;
  sub_1000DFC90((uint64_t)&v10, a5);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_101186B14(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101186B2C(uint64_t a1, int a2, int a3, char a4, uint64_t a5)
{
}

void sub_101186B34(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_100323990((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_101186C78(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101186C90(uint64_t a1, int a2, uint64_t a3)
{
}

uint64_t sub_101186C98(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4240) + 16))();
}

uint64_t sub_101186CC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4176) + 16))();
}

uint64_t sub_101186CE8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4240) + 24))();
}

uint64_t sub_101186D10(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 4176) + 24))();
}

void sub_101186D38(uint64_t a1, uint64_t a2)
{
}

void sub_101186D40(uint64_t a1, uint64_t a2)
{
}

BOOL sub_101186D48(uint64_t a1, uint64_t a2)
{
  return sub_100AE5794(*(os_unfair_lock_s **)(a1 + 152), a2);
}

BOOL sub_101186D50(uint64_t a1, uint64_t a2)
{
  return sub_100AE5794(*(os_unfair_lock_s **)(a1 + 96), a2);
}

void DataServiceController::getBundleId(DataServiceController *this)
{
  uint64_t v1 = __chkstk_darwin(this);
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v6 = v5;
  add_explicit = (uint64_t *)__stack_chk_guard;
  int v8 = *(Registry **)(v1 + 104);
  char v9 = *(std::__shared_weak_count **)(v4 + 112);
  if (v9) {
    add_explicit = (uint64_t *)atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)uint64_t v6 = 0;
  *(void *)(v6 + 8) = 0;
  *(void *)(v6 + 16) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, v8);
  int v11 = ServiceMap;
  if (v12 < 0)
  {
    int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buffer = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buffer);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_11:
    std::mutex::unlock(v11);
    BOOL v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v18 = v16[3];
  BOOL v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (v18)
  {
LABEL_12:
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 104))(&buffer, v18, v3);
    *(_OWORD *)uint64_t v6 = buffer;
    *(void *)(v6 + 16) = v29;
  }
LABEL_13:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  uint64_t v20 = *(unsigned __int8 *)(v6 + 23);
  int v21 = (char)v20;
  if ((v20 & 0x80u) != 0) {
    uint64_t v20 = *(void *)(v6 + 8);
  }
  if (!v20)
  {
    bzero(&buffer, 0x1001uLL);
    if (proc_pidpath(v3, &buffer, 0x1000u) >= 1)
    {
      char v30 = 0;
      sub_100058DB0(&v26, (char *)&buffer);
      if (v21 < 0) {
        operator delete(*(void **)v6);
      }
      *(_OWORD *)uint64_t v6 = v26;
      *(void *)(v6 + 16) = v27;
      long long v26 = 0uLL;
      uint64_t v27 = 0;
      ctu::tokenize();
      if (*((void *)&v26 + 1) != (void)v26)
      {
        char v22 = (void **)(*((void *)&v26 + 1) - 24);
        if (*(char *)(*((void *)&v26 + 1) - 1) < 0)
        {
          sub_10004FC84(&v24, *v22, *(void *)(*((void *)&v26 + 1) - 16));
        }
        else
        {
          long long v23 = *(_OWORD *)v22;
          uint64_t v25 = *(void *)(*((void *)&v26 + 1) - 8);
          long long v24 = v23;
        }
        if (*(char *)(v6 + 23) < 0) {
          operator delete(*(void **)v6);
        }
        *(_OWORD *)uint64_t v6 = v24;
        *(void *)(v6 + 16) = v25;
      }
      *(void *)&long long v24 = &v26;
      sub_100047F64((void ***)&v24);
    }
  }
  if (v9)
  {
    sub_10004D2C8(v9);
  }
}

void sub_101187040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12)
{
  a9 = (void **)&a12;
  sub_100047F64(&a9);
  if ((*(unsigned char *)(v13 + 23) & 0x80) != 0) {
    operator delete(*(void **)v13);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1011870B8(uint64_t a1)
{
}

BOOL sub_1011870C0(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v4 = sub_100AE3F1C(*(void *)(a1 + 152), a2);
  if (v4 >= 0x100u) {
    return v4 != 0;
  }
  uint64_t v5 = &qword_101B132A0;
  LOBYTE(v5) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B132A0, memory_order_acquire);
  if ((v5 & 1) == 0 && __cxa_guard_acquire(&qword_101B132A0))
  {
    *(_OWORD *)long long buf = *(_OWORD *)off_101A95DE8;
    *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)off_101A95DF8;
    sub_100367E88(qword_101B132D8, buf, 4uLL);
    __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B132D8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B132A0);
  }
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 104));
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    char v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_11;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_11:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_12:
  uint64_t v18 = *(_DWORD **)(a1 + 344);
  BOOL v17 = *(_DWORD **)(a1 + 352);
  if (v18 != v17)
  {
    while (*v18 != a2)
    {
      v18 += 42;
      if (v18 == v17) {
        goto LABEL_19;
      }
    }
  }
  if (v18 == v17 || (subscriber::isSimAbsent() & 1) != 0 || subscriber::isSimUnreadable()) {
LABEL_19:
  }
    uint64_t v19 = 2;
  else {
    uint64_t v19 = 1;
  }
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t *, const CFBooleanRef, void))(*(void *)v14 + 104))(&cf, v14, a2, v19, qword_101B132D8, kCFBooleanTrue, 0);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  uint64_t v20 = (BOOL *)cf;
  if (cf) {
    int v21 = sub_100080934;
  }
  else {
    int v21 = 0;
  }
  BOOL v16 = 1;
  if (v21)
  {
    buf[0] = 1;
    if (cf)
    {
      CFTypeID v22 = CFGetTypeID(cf);
      if (v22 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v20, v23);
        BOOL v16 = buf[0] != 0;
      }
      else
      {
        BOOL v16 = 1;
      }
    }
    sub_100AE3E9C(*(void *)(a1 + 152), a2, v16);
  }
  long long v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v26 = asStringBool(v16);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "isIMSAudioOnAPEnabled_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v26;
    _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "#D %s: ret = %s", buf, 0x16u);
  }
  sub_1000577C4(&cf);
  return v16;
}

void sub_1011873F0(_Unwind_Exception *a1)
{
}

BOOL sub_101187448(uint64_t a1, uint64_t a2)
{
  return sub_1011870C0(a1 - 56, a2);
}

BOOL sub_101187450(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 2824);
  if (v2 == (void *)(a1 + 2832))
  {
    return 0;
  }
  else
  {
    BOOL v3 = 0;
    do
    {
      if (*((_DWORD *)v2 + 7) == a2) {
        BOOL v3 = *((unsigned char *)v2 + 32) != 0;
      }
      unsigned __int16 v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          unsigned __int16 v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != (void *)(a1 + 2832));
  }
  return v3;
}

BOOL sub_1011874C4(uint64_t a1, int a2)
{
  return sub_101187450(a1 - 56, a2);
}

void sub_1011874CC(uint64_t a1, unsigned int a2)
{
  if (notify_is_valid_token(*(_DWORD *)(a1 + 5152)))
  {
    uint32_t v4 = notify_set_state(*(_DWORD *)(a1 + 5152), a2);
    if (v4)
    {
      uint32_t v5 = v4;
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v10 = 134217984;
        unint64_t v11 = v5;
        int v7 = "notify_set_state() failed with error %lu";
LABEL_13:
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v10, 0xCu);
      }
    }
    else
    {
      uint32_t v8 = notify_post("com.apple.CoreTelephony.UL.Health.Emergency.Bottleneck");
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (v8)
      {
        uint32_t v9 = v8;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          int v10 = 134217984;
          unint64_t v11 = v9;
          int v7 = "notify_post() failed with error %lu";
          goto LABEL_13;
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 136315394;
        unint64_t v11 = (unint64_t)"com.apple.CoreTelephony.UL.Health.Emergency.Bottleneck";
        __int16 v12 = 1024;
        unsigned int v13 = a2;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s notified %d", (uint8_t *)&v10, 0x12u);
      }
    }
  }
  else
  {
    BOOL v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136315138;
      unint64_t v11 = (unint64_t)"com.apple.CoreTelephony.UL.Health.Emergency.Bottleneck";
      int v7 = "Failed to notify %s due to invalid token";
      goto LABEL_13;
    }
  }
}

void sub_101187684(uint64_t a1, unsigned int a2)
{
}

uint64_t sub_10118768C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 160);
  *a2 = *(void *)(result + 152);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011876A8(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 4088) - *(void *)(a1 + 4080)) >> 4;
}

uint64_t sub_1011876BC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 96);
  *a2 = *(void *)(result + 88);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011876D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 464);
  *(void *)(a1 + 464) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 400));
  sub_101187800(*(void **)(a1 + 384));
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 368);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint32_t v4 = *(std::__shared_weak_count **)(a1 + 344);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10005CD2C(a1 + 312, *(char **)(a1 + 320));
  uint32_t v5 = *(std::__shared_weak_count **)(a1 + 296);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1000DA2E4(*(char **)(a1 + 248));
  sub_10005CD2C(a1 + 216, *(char **)(a1 + 224));
  sub_10005CD2C(a1 + 192, *(char **)(a1 + 200));
  sub_10005CD2C(a1 + 168, *(char **)(a1 + 176));
  if (*(unsigned char *)(a1 + 160))
  {
    uint32_t v8 = (void **)(a1 + 136);
    sub_100B06C10(&v8);
  }
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 128);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_1001FEB64(a1 + 96, *(void **)(a1 + 104));
  sub_1000346F8(a1 + 72, *(void **)(a1 + 80));
  sub_1000346F8(a1 + 48, *(void **)(a1 + 56));
  sub_100DE6768(a1 + 24, *(void **)(a1 + 32));
  sub_1000346F8(a1, *(void **)(a1 + 8));
  return a1;
}

void sub_101187800(void *a1)
{
  if (a1)
  {
    sub_101187800(*a1);
    sub_101187800(a1[1]);
    sub_10021BC80((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void *sub_101187854(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1011878D8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10118795C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1011879E0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187A64(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187AE8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187B6C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187BF0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187C74(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187CF8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187D7C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101187E00(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_101187E88(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101187EC0(uint64_t a1)
{
}

uint64_t sub_101187EDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101187F20(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

BOOL sub_101187F4C(uint64_t a1, uint64_t a2)
{
  while (*(_DWORD *)a1 == *(_DWORD *)a2
       && !strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8))
       && !strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16))
       && *(unsigned __int8 *)(a1 + 28) == *(unsigned __int8 *)(a2 + 28)
       && *(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24)
       && *(unsigned __int8 *)(a1 + 25) == *(unsigned __int8 *)(a2 + 25)
       && *(unsigned __int8 *)(a1 + 26) == *(unsigned __int8 *)(a2 + 26)
       && *(unsigned __int8 *)(a1 + 27) == *(unsigned __int8 *)(a2 + 27)
       && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
       && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36))
  {
    a1 = *(void *)(a1 + 40);
    a2 = *(void *)(a2 + 40);
    if (!a1 || !a2) {
      return (a1 | a2) == 0;
    }
  }
  return 0;
}

void *sub_101188034(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    uint64_t result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_101188094(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1011880B0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint32_t v5 = result;
    if (a4 >> 62) {
      sub_10006A748();
    }
    uint64_t result = operator new(4 * a4);
    size_t v8 = result;
    *uint32_t v5 = result;
    v5[1] = result;
    void v5[2] = (char *)result + 4 * a4;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_101188138(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101188158()
{
}

uint64_t sub_10118816C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_101188178(void *a1)
{
  if (a1)
  {
    sub_101188178(*a1);
    sub_101188178(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[11];
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete(a1);
  }
}

void sub_1011881D0(void *a1)
{
  if (a1)
  {
    sub_1011881D0(*a1);
    sub_1011881D0(a1[1]);
    uint64_t v2 = a1[6];
    a1[6] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

void sub_101188250(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101188288(uint64_t a1)
{
}

uint64_t sub_1011882A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011882E8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101188314(ServiceManager::Service *this)
{
  *(void *)this = off_101A96338;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101188370(ServiceManager::Service *this)
{
  *(void *)this = off_101A96338;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1011883E0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DATA.ServiceController");
}

unsigned char *sub_1011883F0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101188430(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  BOOL v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 32))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_1011884B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011884DC()
{
  return 0;
}

uint64_t sub_1011884E4()
{
  return 1;
}

uint64_t sub_1011884EC()
{
  return 0;
}

uint64_t sub_1011884F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))();
}

uint64_t sub_101188520(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

void sub_101188548(void *a1)
{
  uint64_t v1 = *a1;
  uint32_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(v1 + 8);
  BOOL v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    size_t v9 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController: bootstrap 2...", buf, 0xCu);
  }
  uint32_t v4 = *(NSObject **)v1;
  dispatch_group_t group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  sub_1011522C8(v2);
}

void sub_1011886A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t *a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_10062AF08(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_1011886D8(void **a1)
{
  uint32_t v4 = a1;
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v6 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController: start 2...", buf, 0xCu);
  }
  (*(void (**)(void *))(*v1 + 56))(v1);
  BOOL v3 = v1[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v6 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController: started !", buf, 0xCu);
  }
  operator delete();
}

void sub_101188824()
{
}

uint64_t sub_101188850(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_1011888B4(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint32_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint32_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint32_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    size_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *((unsigned char *)v7 + 40) = 0;
    *((unsigned char *)v7 + 48) = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    const char *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_101188988(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController initializing...", buf, 0xCu);
  }
  uint32_t v4 = (capabilities::ct *)capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)v3);
  int v5 = (int)v4;
  int RadioModuleType = capabilities::ct::getRadioModuleType(v4);
  if (v5) {
    int v7 = 8;
  }
  else {
    int v7 = 0;
  }
  if (RadioModuleType == 2) {
    int v8 = v7 | 0xE4;
  }
  else {
    int v8 = v7;
  }
  uint64_t v9 = *(void *)(v1 + 168);
  BOOL v94 = (void *)(v1 + 8);
  sub_10003E168(buf, (void *)(v1 + 8));
  long long v121 = *(_OWORD *)buf;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(uint64_t, long long *))(*(void *)v9 + 16))(v9, &v121);
  if (*((void *)&v121 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v121 + 1));
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v10 = *(void *)(v1 + 168);
  int v120 = v8;
  unint64_t v11 = (capabilities::ct *)(*(uint64_t (**)(uint64_t, int *))(*(void *)v10 + 24))(v10, &v120);
  unint64_t v12 = capabilities::ct::supportedPDPContextCount(v11);
  if (v12 >> 31) {
    __assert_rtn("operator()", "DataServiceController.cpp", 418, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<int>::max()");
  }
  int v101 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v12);
  if (v101 >= 1)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    uint64_t v13 = *(void *)(v1 + 112);
    v119[0] = *(void *)(v1 + 104);
    v119[1] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(NSObject **)(v1 + 24);
    dispatch_object_t v118 = v14;
    if (v14) {
      dispatch_retain(v14);
    }
    sub_1003C1370((uint64_t)v119, 0, &v118);
  }
  uint64_t v15 = *(void *)(v1 + 136);
  BOOL v16 = *(NSObject **)(v1 + 24);
  dispatch_object_t v117 = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  (*(void (**)(unsigned char *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v15 + 56))(buf, v15, &v117);
  long long v17 = *(_OWORD *)buf;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  uint64_t v18 = *(std::__shared_weak_count **)(v1 + 216);
  *(_OWORD *)(v1 + 208) = v17;
  if (v18)
  {
    sub_10004D2C8(v18);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v117) {
    dispatch_release(v117);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 104));
  uint64_t v20 = ServiceMap;
  if (v21 < 0)
  {
    CFTypeID v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v21;
  uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
  if (v25)
  {
    uint64_t v26 = (std::__shared_weak_count *)v25[4];
    uint64_t v99 = v25[3];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      char v93 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v99 = 0;
  }
  std::mutex::unlock(v20);
  uint64_t v26 = 0;
  char v93 = 1;
LABEL_35:
  int v98 = v26;
  if (!v99)
  {
    uint64_t v27 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "operator()";
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%s: No Personality Shop !", buf, 0xCu);
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "Personality Shop must be present";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataServiceController.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      int v125 = 432;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT personalityShop\n %s\n at %s:%d\n**********", buf, 0x1Cu);
    }
    __TUAssertTrigger();
  }
  uint64_t v28 = *(void *)(v1 + 112);
  *(void *)uint64_t v122 = *(void *)(v1 + 104);
  *(void *)&v122[8] = v28;
  if (v28) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&v122[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
  }
  char v30 = *(int **)buf;
  uint64_t v29 = *(int **)&buf[8];
  if (*(void *)buf == *(void *)&buf[8]) {
    goto LABEL_174;
  }
  int v31 = *(uint64_t (**)(void))&buf[16];
  do
  {
    if (v31(*v30)) {
      goto LABEL_50;
    }
    ++v30;
  }
  while (v30 != v29);
  char v30 = v29;
LABEL_50:
  uint64_t v97 = *(int **)&buf[8];
  if (v30 == *(int **)&buf[8])
  {
LABEL_174:
    uint64_t v90 = *(NSObject **)(v1 + 24);
    *(void *)uint64_t v122 = v90;
    if (v90) {
      dispatch_retain(v90);
    }
    sub_1005273E4((uint64_t *)(v1 + 104), (NSObject **)v122, (uint64_t)buf);
    uint64_t v91 = *(std::__shared_weak_count **)(v1 + 4168);
    *(_OWORD *)(v1 + 4160) = *(_OWORD *)buf;
    if (v91) {
      sub_10004D2C8(v91);
    }
    if (v90) {
      dispatch_release(v90);
    }
    uint64_t v92 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "operator()";
      _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I %s: DataServiceController initialized", buf, 0xCu);
    }
    if ((v93 & 1) == 0) {
      sub_10004D2C8(v26);
    }
    operator delete();
  }
  uint64_t v100 = v1 + 72;
  uint64_t v95 = v31;
  uint64_t v96 = v29;
  while (1)
  {
    int v116 = 0;
    int v116 = *v30;
    uint64_t v32 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48));
    uint64_t v33 = sub_100AEFE40(*(void *)(v1 + 144), v116);
    long long v123 = 0uLL;
    (*(void (**)(long long *__return_ptr))(*(void *)v99 + 8))(&v123);
    uint64_t v34 = v123;
    if ((void)v123)
    {
      if (v32)
      {
        CFTypeRef v35 = *v32;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v38 = *(const char **)(v34 + 24);
          uint64_t v37 = v34 + 24;
          BOOL v36 = v38;
          uint64_t v39 = *(unsigned __int8 *)(v37 + 23);
          int v40 = (char)v39;
          if ((v39 & 0x80u) != 0) {
            uint64_t v39 = *(void *)(v37 + 8);
          }
          if (v40 >= 0) {
            BOOL v36 = (const char *)v37;
          }
          if (!v39) {
            BOOL v36 = "<invalid>";
          }
          *(_DWORD *)uint64_t v122 = 136315394;
          *(void *)&v122[4] = "operator()";
          *(_WORD *)&v122[12] = 2080;
          *(void *)&v122[14] = v36;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s: Personality: %s", v122, 0x16u);
        }
      }
      DataModel::update((std::string *)v33, (const std::string **)&v123);
    }
    else
    {
      uint64_t v41 = *v32;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v122 = 0;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#N initDataServiceController: No Personality yet", v122, 2u);
      }
    }
    if (*((void *)&v123 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
    }
    uint64_t v42 = *(void *)(v1 + 152);
    uint64_t v43 = *(std::__shared_weak_count **)(v33 + 424);
    *(void *)uint64_t v122 = *(void *)(v33 + 416);
    *(void *)&v122[8] = v43;
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100AE4010(v42, (uint64_t *)v122, v101);
      sub_10004D2C8(v43);
    }
    else
    {
      sub_100AE4010(v42, (uint64_t *)v122, v101);
    }
    uint64_t v45 = *(void *)(v1 + 152);
    int v46 = v116;
    InterfaceAppMapperService::create(&v114, v44);
    sub_100AE559C(v45, v46, &v114);
    if (v115) {
      sub_10004D2C8(v115);
    }
    for (int i = 0; i != 36; ++i)
    {
      *(void *)uint64_t v122 = 0;
      *(void *)&v122[8] = 0;
      uint64_t v48 = *(std::__shared_weak_count **)(v1 + 112);
      uint64_t v112 = *(void *)(v1 + 104);
      uint64_t v113 = v48;
      if (v48) {
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v49 = *(void *)(v33 + 424);
      *(void *)&long long v123 = *(void *)(v33 + 416);
      *((void *)&v123 + 1) = v49;
      if (v49) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v49 + 8), 1uLL, memory_order_relaxed);
      }
      int v50 = *(NSObject **)(v1 + 24);
      dispatch_object_t object = v50;
      if (v50) {
        dispatch_retain(v50);
      }
      sub_1011B0024((uint64_t)&v112, v1 + 64, &object, i, (uint64_t *)v122);
      if (object) {
        dispatch_release(object);
      }
      if (*((void *)&v123 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
      }
      if (v113) {
        sub_10004D2C8(v113);
      }
      if (!*(void *)v122)
      {
        uint64_t v51 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v52 = asString();
          LODWORD(v123) = 136315138;
          *(void *)((char *)&v123 + 4) = v52;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#N Connection empty: %s", (uint8_t *)&v123, 0xCu);
        }
      }
      sub_100CE9234((char **)v33, (long long *)v122);
      if (*(void *)&v122[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
      }
    }
    uint64_t v53 = *(void *)(v1 + 208);
    if (!v53) {
      goto LABEL_127;
    }
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v53 + 32))(v122);
    long long v54 = *(_OWORD *)v122;
    *(void *)uint64_t v122 = 0;
    *(void *)&v122[8] = 0;
    uint64_t v55 = *(std::__shared_weak_count **)(v1 + 232);
    *(_OWORD *)(v1 + 224) = v54;
    if (v55) {
      break;
    }
    uint64_t v56 = v54;
    if ((void)v54) {
      goto LABEL_98;
    }
LABEL_112:
    uint64_t v61 = *(void *)(v1 + 136);
    uint64_t v62 = *(void *)(v33 + 424);
    *(void *)&long long v123 = *(void *)(v33 + 416);
    *((void *)&v123 + 1) = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v63 = *(NSObject **)(v1 + 24);
    dispatch_object_t v110 = v63;
    if (v63) {
      dispatch_retain(v63);
    }
    uint64_t v64 = *(std::__shared_weak_count **)(v1 + 216);
    uint64_t v108 = *(void *)(v1 + 208);
    uint64_t v109 = v64;
    if (v64) {
      atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, long long *, dispatch_object_t *, uint64_t *))(*(void *)v61 + 64))(v122, v61, v100, &v123, &v110, &v108);
    long long v65 = *(_OWORD *)v122;
    *(void *)uint64_t v122 = 0;
    *(void *)&v122[8] = 0;
    int v66 = *(std::__shared_weak_count **)(v33 + 32);
    *(_OWORD *)(v33 + 24) = v65;
    if (v66)
    {
      sub_10004D2C8(v66);
      if (*(void *)&v122[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
      }
    }
    if (v109) {
      sub_10004D2C8(v109);
    }
    if (v110) {
      dispatch_release(v110);
    }
    if (*((void *)&v123 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
    }
LABEL_127:
    uint64_t v67 = *(void *)(v1 + 136);
    uint64_t v68 = *(void *)(v33 + 424);
    *(void *)&long long v123 = *(void *)(v33 + 416);
    *((void *)&v123 + 1) = v68;
    if (v68) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v68 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v69 = *(NSObject **)(v1 + 24);
    dispatch_object_t v107 = v69;
    if (v69) {
      dispatch_retain(v69);
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, long long *, dispatch_object_t *))(*(void *)v67 + 80))(v122, v67, v100, &v123, &v107);
    long long v70 = *(_OWORD *)v122;
    *(void *)uint64_t v122 = 0;
    *(void *)&v122[8] = 0;
    int v71 = *(std::__shared_weak_count **)(v33 + 48);
    *(_OWORD *)(v33 + 40) = v70;
    if (v71)
    {
      sub_10004D2C8(v71);
      if (*(void *)&v122[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
      }
    }
    if (v107) {
      dispatch_release(v107);
    }
    if (*((void *)&v123 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
    }
    sub_100AE3B80(*(os_unfair_lock_s **)(v1 + 152), v116);
    uint64_t v73 = *(void *)(v33 + 416);
    __int16 v72 = *(std::__shared_weak_count **)(v33 + 424);
    *(void *)&long long v123 = v73;
    *((void *)&v123 + 1) = v72;
    if (v72) {
      atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v74 = sub_101181070(*(void *)(*(void *)(v1 + 144) + 8), *(void *)(*(void *)(v1 + 144) + 16), v73, v72);
    if (*(void *)(*(void *)(v1 + 144) + 16) != v74)
    {
      sub_100AE3AD4(*(void *)(v1 + 152), (uint64_t *)&v123);
      uint64_t v75 = *(char **)(v74 + 24);
      if (v75)
      {
        uint32_t v76 = (*(uint64_t (**)(char *))(*(void *)&v75[*(void *)(*(void *)v75 - 320)] + 56))(&v75[*(void *)(*(void *)v75 - 320)]);
        uint64_t v77 = *(os_unfair_lock_s **)(v1 + 152);
        os_unfair_lock_lock(v77 + 6);
        v77[20]._uint64_t os_unfair_lock_opaque = v76;
        os_unfair_lock_unlock(v77 + 6);
        uint64_t v78 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v122 = 136315394;
          *(void *)&v122[4] = "initStateCache_sync";
          *(_WORD *)&v122[12] = 1024;
          *(_DWORD *)&v122[14] = v76;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I %s: fCachedDormancyMask=%x", v122, 0x12u);
        }
      }
      char v79 = sub_10116E684(v1, *(unsigned int *)(v73 + 52));
      int v80 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(v73 + 52));
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v81 = asStringBool(v79);
        *(_DWORD *)uint64_t v122 = 136315138;
        *(void *)&v122[4] = v81;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I fCache.fSuspendInternetOnBBCall = %s", v122, 0xCu);
      }
      sub_100AE42A0(*(void *)(v1 + 152), (uint64_t)&v123, v79);
    }
    if (v72) {
      sub_10004D2C8(v72);
    }
    uint64_t v26 = v98;
    int v82 = dataUiModifierMask();
    *(void *)uint64_t v122 = &v116;
    *((_DWORD *)sub_10030B04C((uint64_t **)(v1 + 4480), &v116, (uint64_t)&unk_10144E20E, (unsigned int **)v122) + 8) = v82;
    if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 2192))(v1))
    {
      uint64_t v83 = *(void *)(v1 + 136);
      sub_10003E168(&v123, v94);
      if ((void)v123) {
        uint64_t v84 = v123 + 80;
      }
      else {
        uint64_t v84 = 0;
      }
      uint64_t v105 = v84;
      int v106 = (std::__shared_weak_count *)*((void *)&v123 + 1);
      long long v123 = 0uLL;
      int v85 = *(std::__shared_weak_count **)(v33 + 424);
      uint64_t v103 = *(void *)(v33 + 416);
      int v104 = v85;
      if (v85) {
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v86 = *(NSObject **)(v1 + 24);
      dispatch_object_t v102 = v86;
      if (v86) {
        dispatch_retain(v86);
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t *, uint64_t *, dispatch_object_t *))(*(void *)v83 + 104))(v122, v83, &v105, &v103, &v102);
      long long v87 = *(_OWORD *)v122;
      *(void *)uint64_t v122 = 0;
      *(void *)&v122[8] = 0;
      uint64_t v88 = *(std::__shared_weak_count **)(v33 + 408);
      *(_OWORD *)(v33 + 400) = v87;
      if (v88)
      {
        sub_10004D2C8(v88);
        if (*(void *)&v122[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
        }
      }
      if (v102) {
        dispatch_release(v102);
      }
      if (v104) {
        sub_10004D2C8(v104);
      }
      if (v106) {
        sub_10004D2C8(v106);
      }
      if (*((void *)&v123 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
      }
    }
    uint64_t v89 = v30 + 1;
    char v30 = v96;
    if (v89 != v96)
    {
      char v30 = v89;
      do
      {
        if (v95(*v30)) {
          goto LABEL_173;
        }
        ++v30;
      }
      while (v30 != v96);
      char v30 = v96;
    }
LABEL_173:
    if (v30 == v97) {
      goto LABEL_174;
    }
  }
  sub_10004D2C8(v55);
  if (*(void *)&v122[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v122[8]);
  }
  uint64_t v56 = *(void *)(v1 + 224);
  if (!v56) {
    goto LABEL_112;
  }
LABEL_98:
  sub_10003E168(&v123, v94);
  if ((void)v123)
  {
    *(_OWORD *)uint64_t v122 = v123;
    unsigned __int8 v57 = (uint8_t *)&v123;
  }
  else
  {
    unsigned __int8 v57 = v122;
  }
  *(void *)unsigned __int8 v57 = 0;
  *((void *)v57 + 1) = 0;
  BOOL v58 = *(std::__shared_weak_count **)&v122[8];
  if (*(void *)v122) {
    uint64_t v59 = *(void *)v122 + 80;
  }
  else {
    uint64_t v59 = 0;
  }
  if (*(void *)&v122[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v122[8] + 16), 1uLL, memory_order_relaxed);
  }
  int v60 = *(std::__shared_weak_count **)(v56 + 16);
  *(void *)(v56 + 8) = v59;
  *(void *)(v56 + 16) = v58;
  if (v60) {
    std::__shared_weak_count::__release_weak(v60);
  }
  if (v58) {
    sub_10004D2C8(v58);
  }
  if (*((void *)&v123 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v123 + 1));
  }
  goto LABEL_112;
}

void sub_1011898B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,dispatch_object_t object,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,dispatch_object_t a38,dispatch_object_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a22);
  }
  operator delete();
}

void sub_101189A88()
{
}

__n128 sub_101189A9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A963B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101189AF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A963B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101189B28(void *a1, xpc *this, BOOL a3)
{
  uint32_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint32_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_101189BC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101189C04()
{
}

void sub_101189C14()
{
}

__n128 sub_101189C28(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A96438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101189C7C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A96438;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101189CB4(void *a1, xpc_object_t *a2)
{
  uint32_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned int *)a2, v7);
    *uint32_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint32_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_101189DAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101189DEC()
{
}

void sub_101189DFC()
{
}

void *sub_101189E10(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A964B8;
  result[1] = v3;
  return result;
}

uint64_t sub_101189E58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A964B8;
  a2[1] = v2;
  return result;
}

void sub_101189E84(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((const ConnectionAvailabilityContainer *)(v6 + 4));
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/connection_availability");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10118A14C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118A204(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118A244()
{
}

void sub_10118A254()
{
}

void *sub_10118A268(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96548;
  result[1] = v3;
  return result;
}

uint64_t sub_10118A2B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96548;
  a2[1] = v2;
  return result;
}

void sub_10118A2DC(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/internet_connection_availability_any_sim");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10118A5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118A65C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118A69C()
{
}

void sub_10118A6AC()
{
}

void *sub_10118A6C0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A965D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118A708(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A965D8;
  a2[1] = v2;
  return result;
}

void sub_10118A734(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/connection_state");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10118A9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118AAB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118AAF4()
{
}

void sub_10118AB04()
{
}

void *sub_10118AB18(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96668;
  result[1] = v3;
  return result;
}

uint64_t sub_10118AB60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96668;
  a2[1] = v2;
  return result;
}

void sub_10118AB8C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/internal_internet_connection_state");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10118AE54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118AF0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118AF4C()
{
}

void sub_10118AF5C()
{
}

void *sub_10118AF70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A966F8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118AFB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A966F8;
  a2[1] = v2;
  return result;
}

void sub_10118AFE4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v9);
        goto LABEL_16;
      }
      xpc_object_t v10 = xpc_null_create();
LABEL_15:
      xpc_object_t v26 = v10;
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      if (!*((unsigned char *)v6 + 48) || (xpc_object_t v22 = xpc_uint64_create(v6[5])) == 0) {
        xpc_object_t v22 = xpc_null_create();
      }
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/current_service_mask");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10118B2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118B38C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118B3CC()
{
}

void sub_10118B3DC()
{
}

void *sub_10118B3F0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96788;
  result[1] = v3;
  return result;
}

uint64_t sub_10118B438(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96788;
  a2[1] = v2;
  return result;
}

void sub_10118B464(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10008C088(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/data_routable_address");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118B508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118B54C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118B58C()
{
}

void sub_10118B59C()
{
}

void *sub_10118B5B0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96808;
  result[1] = v3;
  return result;
}

uint64_t sub_10118B5F8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96808;
  a2[1] = v2;
  return result;
}

void sub_10118B624(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A91CF8(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/active_contexts_count");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118B6C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118B70C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118B74C()
{
}

void sub_10118B75C()
{
}

void *sub_10118B770(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96888;
  result[1] = v3;
  return result;
}

uint64_t sub_10118B7B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96888;
  a2[1] = v2;
  return result;
}

void sub_10118B7E4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A91CF8(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/context_deactivate_rejects_count");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118B888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118B8CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118B90C()
{
}

void sub_10118B91C()
{
}

void *sub_10118B930(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96908;
  result[1] = v3;
  return result;
}

uint64_t sub_10118B978(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96908;
  a2[1] = v2;
  return result;
}

void sub_10118B9A4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      xpc_object_t v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      int v14 = *((_DWORD *)v6 + 8);
      uint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v14, v15, v16);
      long long __p = &v29;
      xpc_object_t v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      xpc_object_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          xpc_object_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/bb_driver_data_modes");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_10118BC7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118BD34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118BD74()
{
}

void sub_10118BD84()
{
}

__n128 sub_10118BD98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A96998;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118BDEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A96998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118BE24(void *a1, xpc_object_t *a2)
{
  xpc_object_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *xpc_object_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *xpc_object_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  xpc_object_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    xpc_object_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10118BF1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118BF5C()
{
}

void sub_10118BF6C()
{
}

void *sub_10118BF80(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96A18;
  result[1] = v3;
  return result;
}

uint64_t sub_10118BFC8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96A18;
  a2[1] = v2;
  return result;
}

void sub_10118BFF4(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/current_data_slot");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_10118C0A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118C0EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118C12C()
{
}

void sub_10118C13C()
{
}

void *sub_10118C150(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96A98;
  result[1] = v3;
  return result;
}

uint64_t sub_10118C198(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96A98;
  a2[1] = v2;
  return result;
}

void sub_10118C1C4(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/msim_config_mode");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_10118C278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118C2BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118C2FC()
{
}

void sub_10118C30C()
{
}

void *sub_10118C320(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96B28;
  result[1] = v3;
  return result;
}

uint64_t sub_10118C368(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96B28;
  a2[1] = v2;
  return result;
}

void sub_10118C394(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v36 = v3;
    }
    else
    {
      xpc_object_t v36 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v36 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v6 = v5;
      if (v5)
      {
        xpc_object_t v43 = v5;
      }
      else
      {
        xpc_object_t v6 = xpc_null_create();
        xpc_object_t v43 = v6;
        if (!v6)
        {
          xpc_object_t v7 = xpc_null_create();
          xpc_object_t v6 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v6) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v7 = xpc_null_create();
LABEL_15:
        xpc_object_t v43 = v7;
        goto LABEL_16;
      }
      xpc_retain(v6);
LABEL_16:
      xpc_release(v6);
      int v8 = *((_DWORD *)v4 + 8);
      uint64_t v9 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v41, (ctu::rest::detail *)v8, v9, v10);
      long long __p = &v43;
      uint64_t v39 = "first";
      sub_100035E70((uint64_t)&__p, &v41, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v41);
      xpc_object_t v41 = 0;
      xpc_object_t v11 = xpc_array_create(0, 0);
      if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v11);
          xpc_object_t xarray = v11;
        }
        else
        {
          xpc_object_t xarray = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t xarray = xpc_null_create();
        xpc_object_t v11 = 0;
      }
      xpc_release(v11);
      uint64_t v12 = (void *)v4[5];
      if (v12 != v4 + 6)
      {
        do
        {
          xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v14 = v13;
          if (v13)
          {
            xpc_object_t v46 = v13;
          }
          else
          {
            xpc_object_t v14 = xpc_null_create();
            xpc_object_t v46 = v14;
            if (!v14)
            {
              xpc_object_t v15 = xpc_null_create();
              xpc_object_t v14 = 0;
              goto LABEL_30;
            }
          }
          if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v14);
            goto LABEL_31;
          }
          xpc_object_t v15 = xpc_null_create();
LABEL_30:
          xpc_object_t v46 = v15;
LABEL_31:
          xpc_release(v14);
          xpc_object_t v44 = xpc_int64_create(*((int *)v12 + 8));
          if (!v44) {
            xpc_object_t v44 = xpc_null_create();
          }
          long long __p = &v46;
          uint64_t v39 = "first";
          sub_100035E70((uint64_t)&__p, &v44, &v45);
          xpc_release(v45);
          xpc_object_t v45 = 0;
          xpc_release(v44);
          xpc_object_t v44 = 0;
          xpc_object_t v16 = xpc_array_create(0, 0);
          if (v16 || (xpc_object_t v16 = xpc_null_create()) != 0)
          {
            if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_array)
            {
              xpc_retain(v16);
              xpc_object_t v17 = v16;
            }
            else
            {
              xpc_object_t v17 = xpc_null_create();
            }
          }
          else
          {
            xpc_object_t v17 = xpc_null_create();
            xpc_object_t v16 = 0;
          }
          xpc_release(v16);
          xpc_object_t v18 = (void *)v12[5];
          if (v18 != v12 + 6)
          {
            do
            {
              xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
              xpc_object_t v20 = v19;
              if (v19)
              {
                v51[0] = v19;
              }
              else
              {
                xpc_object_t v20 = xpc_null_create();
                v51[0] = v20;
                if (!v20)
                {
                  xpc_object_t v21 = xpc_null_create();
                  xpc_object_t v20 = 0;
                  goto LABEL_47;
                }
              }
              if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
              {
                xpc_object_t v21 = xpc_null_create();
LABEL_47:
                v51[0] = v21;
                goto LABEL_48;
              }
              xpc_retain(v20);
LABEL_48:
              xpc_release(v20);
              int v22 = *((_DWORD *)v18 + 7);
              uint64_t v23 = asString();
              ctu::rest::detail::write_enum_string_value((uint64_t *)&v49, (ctu::rest::detail *)v22, v23, v24);
              long long __p = v51;
              uint64_t v39 = "first";
              sub_100035E70((uint64_t)&__p, &v49, &v50);
              xpc_release(v50);
              xpc_object_t v50 = 0;
              xpc_release(v49);
              xpc_object_t v49 = 0;
              xpc_object_t v47 = xpc_BOOL_create(*((unsigned char *)v18 + 32));
              if (!v47) {
                xpc_object_t v47 = xpc_null_create();
              }
              long long __p = v51;
              uint64_t v39 = "second";
              sub_100035E70((uint64_t)&__p, &v47, &v48);
              xpc_release(v48);
              xpc_object_t v48 = 0;
              xpc_release(v47);
              xpc_object_t v47 = 0;
              xpc_object_t v25 = v51[0];
              if (v51[0]) {
                xpc_retain(v51[0]);
              }
              else {
                xpc_object_t v25 = xpc_null_create();
              }
              xpc_release(v51[0]);
              xpc_array_append_value(v17, v25);
              xpc_release(v25);
              xpc_object_t v26 = (void *)v18[1];
              if (v26)
              {
                do
                {
                  xpc_object_t v27 = v26;
                  xpc_object_t v26 = (void *)*v26;
                }
                while (v26);
              }
              else
              {
                do
                {
                  xpc_object_t v27 = (void *)v18[2];
                  BOOL v28 = *v27 == (void)v18;
                  xpc_object_t v18 = v27;
                }
                while (!v28);
              }
              xpc_object_t v18 = v27;
            }
            while (v27 != v12 + 6);
          }
          xpc_object_t v50 = v17;
          if (v17) {
            xpc_retain(v17);
          }
          else {
            xpc_object_t v50 = xpc_null_create();
          }
          xpc_release(v17);
          long long __p = &v46;
          uint64_t v39 = "second";
          sub_100035E70((uint64_t)&__p, &v50, v51);
          xpc_release(v51[0]);
          v51[0] = 0;
          xpc_release(v50);
          xpc_object_t v50 = 0;
          xpc_object_t v29 = v46;
          if (v46) {
            xpc_retain(v46);
          }
          else {
            xpc_object_t v29 = xpc_null_create();
          }
          xpc_release(v46);
          xpc_array_append_value(xarray, v29);
          xpc_release(v29);
          char v30 = (void *)v12[1];
          if (v30)
          {
            do
            {
              int v31 = v30;
              char v30 = (void *)*v30;
            }
            while (v30);
          }
          else
          {
            do
            {
              int v31 = (void *)v12[2];
              BOOL v28 = *v31 == (void)v12;
              uint64_t v12 = v31;
            }
            while (!v28);
          }
          uint64_t v12 = v31;
        }
        while (v31 != v4 + 6);
      }
      xpc_object_t v50 = xarray;
      if (xarray) {
        xpc_retain(xarray);
      }
      else {
        xpc_object_t v50 = xpc_null_create();
      }
      xpc_release(xarray);
      long long __p = &v43;
      uint64_t v39 = "second";
      sub_100035E70((uint64_t)&__p, &v50, v51);
      xpc_release(v51[0]);
      v51[0] = 0;
      xpc_release(v50);
      xpc_object_t v50 = 0;
      xpc_object_t v32 = v43;
      if (v43) {
        xpc_retain(v43);
      }
      else {
        xpc_object_t v32 = xpc_null_create();
      }
      xpc_release(v43);
      xpc_array_append_value(v36, v32);
      xpc_release(v32);
      uint64_t v33 = (void *)v4[1];
      if (v33)
      {
        do
        {
          uint64_t v34 = v33;
          uint64_t v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          uint64_t v34 = (void *)v4[2];
          BOOL v28 = *v34 == (void)v4;
          uint64_t v4 = v34;
        }
        while (!v28);
      }
      uint64_t v4 = v34;
    }
    while (v34 != a2 + 1);
  }
  xpc_object_t v35 = v36;
  if (v36) {
    xpc_retain(v36);
  }
  else {
    xpc_object_t v35 = xpc_null_create();
  }
  xpc_release(v36);
  sub_100058DB0(&__p, "/cc/props/pdp_active_state");
  v51[0] = v35;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    v51[0] = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v51[0]);
  v51[0] = 0;
  if (v40 < 0) {
    operator delete(__p);
  }
  xpc_release(v35);
}

void sub_10118CA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, xpc_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,xpc_object_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25)
{
  xpc_release(*(xpc_object_t *)(v26 - 96));
  *(void *)(v26 - 96) = 0;
  if (a19 < 0) {
    operator delete(__p);
  }
  xpc_release(v25);
  _Unwind_Resume(a1);
}

uint64_t sub_10118CC08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118CC48()
{
}

void sub_10118CC58()
{
}

void *sub_10118CC6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96BB8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118CCB4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96BB8;
  a2[1] = v2;
  return result;
}

void sub_10118CCE0(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      uint64_t v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      xpc_object_t v14 = (ctu::rest::detail *)*((unsigned int *)v6 + 8);
      unint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, v14, v15, v16);
      long long __p = &v29;
      uint64_t v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      xpc_object_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          xpc_object_t v19 = v18;
          xpc_object_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          xpc_object_t v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          xpc_object_t v6 = v19;
        }
        while (!v20);
      }
      xpc_object_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/data_ui_indicators");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_10118CFB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118D070(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118D0B0()
{
}

void sub_10118D0C0()
{
}

void *sub_10118D0D4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96C48;
  result[1] = v3;
  return result;
}

uint64_t sub_10118D11C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96C48;
  a2[1] = v2;
  return result;
}

void sub_10118D148(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A91CF8(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/data_ui_modifiers");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118D1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118D230(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118D270()
{
}

void sub_10118D280()
{
}

void *sub_10118D294(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A96CC8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118D2DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96CC8;
  a2[1] = v2;
  return result;
}

void sub_10118D308(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          xpc_object_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          xpc_object_t v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          xpc_object_t v6 = v13;
        }
        while (!v14);
      }
      xpc_object_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/ims_pref");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}