uint64_t sub_10095A4D0(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  *(void *)a1 = off_101A1EA68;
  sub_100119D90(*(void **)(a1 + 96));
  v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_10095A538(uint64_t a1)
{
  *(void *)a1 = off_101A1EA68;
  sub_100119D90(*(void **)(a1 + 96));
  v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  operator delete();
}

void sub_10095A5C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10095A5FC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10095A62C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

CFStringRef sub_10095A670()
{
  return @"ActivationState";
}

CFStringRef sub_10095A67C()
{
  return @"FactoryActivated";
}

void sub_10095A694(uint64_t a1, NSObject **a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  v12 = *a2;
  dispatch_object_t object = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  sub_10095A7C0((uint64_t)v14, a7);
  sub_100E2E5CC(&object, a3, a4, a5, a6, (uint64_t)v14);
  sub_100414310(v14);
  if (object) {
    dispatch_release(object);
  }
}

void sub_10095A758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

void sub_10095A788(MAClientInterface *a1)
{
  MAClientInterface::~MAClientInterface(a1);

  operator delete();
}

uint64_t sub_10095A7C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10095A858()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E278, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0E278))
  {
    sub_10095A8D0();
  }
  return qword_101B0E270;
}

void sub_10095A8B8(_Unwind_Exception *a1)
{
}

void sub_10095A8D0()
{
}

void sub_10095B3F8()
{
}

void sub_10095B458()
{
}

void sub_10095B478(void *a1)
{
  sub_100CC9A2C(a1);

  operator delete();
}

uint64_t sub_10095B4B0(uint64_t result, std::string *a2)
{
  if (*(void *)(result + 16) != *(void *)(result + 8))
  {
    uint64_t v3 = result;
    uint64_t v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    *(_OWORD *)v19 = 0u;
    memset(v18, 0, sizeof(v18));
    sub_10004DE24((uint64_t)v18);
    if (*(void *)(v3 + 16) != *(void *)(v3 + 8))
    {
      unint64_t v4 = 0;
      unsigned int v5 = 1;
      do
      {
        LOBYTE(__p) = 59;
        sub_10004B96C(v18, (uint64_t)&__p, 1);
        uint64_t v6 = *(void *)(v3 + 8);
        if (v4 >= (*(void *)(v3 + 16) - v6) >> 3) {
          uint64_t v7 = 0;
        }
        else {
          uint64_t v7 = *(void *)(v6 + 8 * v4);
        }
        v8 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 64))(v7);
        size_t v9 = strlen(v8);
        v10 = sub_10004B96C(v18, (uint64_t)v8, v9);
        LOBYTE(__p) = 61;
        sub_10004B96C(v10, (uint64_t)&__p, 1);
        __p = 0;
        std::string::size_type v16 = 0;
        uint64_t v17 = 0;
        if ((*(unsigned int (**)(uint64_t, void **))(*(void *)v7 + 72))(v7, &__p))
        {
          if (v17 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          if (v17 >= 0) {
            uint64_t v12 = HIBYTE(v17);
          }
          else {
            uint64_t v12 = v16;
          }
          sub_10004B96C(v18, (uint64_t)p_p, v12);
        }
        if (SHIBYTE(v17) < 0) {
          operator delete(__p);
        }
        unint64_t v4 = v5++;
      }
      while (v4 < (uint64_t)(*(void *)(v3 + 16) - *(void *)(v3 + 8)) >> 3);
    }
    sub_10004BC98((uint64_t)v18 + 8, &__p);
    if (v17 >= 0) {
      v13 = (const std::string::value_type *)&__p;
    }
    else {
      v13 = (const std::string::value_type *)__p;
    }
    if (v17 >= 0) {
      std::string::size_type v14 = HIBYTE(v17);
    }
    else {
      std::string::size_type v14 = v16;
    }
    std::string::append(a2, v13, v14);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    return std::ios::~ios();
  }
  return result;
}

void sub_10095B784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_10095B7BC(uint64_t a1, char *__s1)
{
  if (__s1 && *__s1)
  {
    uint64_t v3 = strdup(__s1);
    __lasts = 0;
    unint64_t v4 = strtok_r(v3, ";", &__lasts);
    if (v4)
    {
      unsigned int v5 = v4;
      do
      {
        uint64_t v6 = strchr(v5, 61);
        if (v6)
        {
          uint64_t v7 = v6;
          *uint64_t v6 = 0;
          uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
          uint64_t v9 = sub_101306428(v8, v5);
          if (v9)
          {
            uint64_t v10 = v9;
            (*(void (**)(uint64_t, char *))(*(void *)v9 + 16))(v9, v7 + 1);
LABEL_9:
            sub_100CC9AE4(a1, v10, 0);
          }
        }
        else
        {
          uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
          uint64_t v10 = sub_101306428(v11, v5);
          if (v10) {
            goto LABEL_9;
          }
        }
        unsigned int v5 = strtok_r(0, ";", &__lasts);
      }
      while (v5);
    }
    free(v3);
  }
  return 1;
}

void sub_10095B91C(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100CCA3B0(a1, "charset");
  if (!v4)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v4 = sub_101306428(v5, "charset");
    sub_100CC9AE4(a1, v4, 0);
  }
  *(_DWORD *)(v4 + 20) = a2;
}

void sub_10095B9A8(unsigned int *a1)
{
  if (!(*((unsigned __int8 *)a1 + 5) | *((unsigned __int8 *)a1 + 7))) {
    return;
  }
  xpc_object_t v19 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v19 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v19 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_9;
    }
  }
  if (xpc_get_type(v3) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v4 = xpc_null_create();
LABEL_9:
    xpc_object_t v19 = v4;
    goto LABEL_10;
  }
  xpc_retain(v3);
LABEL_10:
  xpc_release(v3);
  xpc_object_t v17 = xpc_int64_create(*a1);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  ctu::cf::assign();
  *(_OWORD *)__p = 0uLL;
  uint64_t v14 = 0;
  v15 = &v19;
  std::string::size_type v16 = __p;
  sub_100035E70((uint64_t)&v15, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v17);
  xpc_object_t v17 = 0;
  if (*((unsigned char *)a1 + 5))
  {
    xpc_object_t v11 = xpc_BOOL_create(*((unsigned char *)a1 + 4));
    if (!v11) {
      xpc_object_t v11 = xpc_null_create();
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    ctu::cf::assign();
    *(_OWORD *)__p = v20;
    uint64_t v14 = v21;
    uint64_t v5 = (void **)v20;
    if (v21 >= 0) {
      uint64_t v5 = __p;
    }
    v15 = &v19;
    std::string::size_type v16 = v5;
    sub_100035E70((uint64_t)&v15, &v11, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v11);
    xpc_object_t v11 = 0;
  }
  if (*((unsigned char *)a1 + 7))
  {
    xpc_object_t v9 = xpc_BOOL_create(*((unsigned char *)a1 + 6));
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    ctu::cf::assign();
    *(_OWORD *)__p = v20;
    uint64_t v14 = v21;
    uint64_t v6 = __p;
    if (v21 < 0) {
      uint64_t v6 = (void **)__p[0];
    }
    v15 = &v19;
    std::string::size_type v16 = v6;
    sub_100035E70((uint64_t)&v15, &v9, &v10);
    xpc_release(v10);
    xpc_object_t v10 = 0;
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v9);
    xpc_object_t v9 = 0;
  }
  xpc_object_t v7 = v19;
  *(void *)&long long v20 = v19;
  if (v19)
  {
    xpc_retain(v19);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    *(void *)&long long v20 = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  __p[0] = v8;
  sub_1000452AC(93, (xpc_object_t *)&v20, __p);
  xpc_release(v8);
  xpc_release(v7);
  xpc_release(v19);
}

void sub_10095BCA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  if (*(char *)(v12 - 17) < 0) {
    operator delete(*(void **)(v12 - 40));
  }
  xpc_release(v11);
  xpc_release(*(xpc_object_t *)(v12 - 48));
  _Unwind_Resume(a1);
}

void NetworkListModel::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10095C478(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t NetworkListModel::NetworkListModel(uint64_t a1, uint64_t *a2, dispatch_object_t *a3, unsigned int a4)
{
  xpc_object_t v8 = (ctu::OsLogLogger *)(a1 + 8);
  if (a4 > 3) {
    xpc_object_t v9 = "man.model.1";
  }
  else {
    xpc_object_t v9 = off_101A1EE58[a4];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__str, kCtLoggingSystemName, v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v42, (const OsLogContext *)&__str);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)&v42);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v42);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__str);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A1EC20;
  *(void *)(a1 + 32) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 48) = a4;
  *(void *)(a1 + 52) = 3;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  xpc_object_t v11 = "RegistrationModel::fNetworkSelection?";
  if (a4 == 2) {
    xpc_object_t v11 = "RegistrationModel::fNetworkSelection2";
  }
  if (a4 == 1) {
    uint64_t v12 = "RegistrationModel::fNetworkSelection";
  }
  else {
    uint64_t v12 = (char *)v11;
  }
  sub_100058DB0(&__str, v12);
  sub_100058DB0(__p, "");
  sub_10096171C(a1 + 96, *a2, a2[1], (long long *)&__str, (long long *)__p, 0);
  if (v40 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  v13 = "RegistrationModel::fNetworkSelectionMode?";
  if (a4 == 2) {
    v13 = "RegistrationModel::fNetworkSelectionMode2";
  }
  if (a4 == 1) {
    uint64_t v14 = "RegistrationModel::fNetworkSelectionMode";
  }
  else {
    uint64_t v14 = (char *)v13;
  }
  sub_100058DB0(&__str, v14);
  uint64_t v15 = a2[1];
  *(void *)(a1 + 168) = *a2;
  *(void *)(a1 + 176) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  std::string::size_type v16 = (unsigned char *)(a1 + 184);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(v16, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)std::string::size_type v16 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
    xpc_object_t v17 = (uint64_t *)__str.__r_.__value_.__r.__words[2];
    *(void *)(a1 + 200) = *((void *)&__str.__r_.__value_.__l + 2);
  }
  *(void *)(a1 + 208) = 0;
  *(_WORD *)(a1 + 216) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 168));
  xpc_object_t v19 = ServiceMap;
  if ((v20 & 0x8000000000000000) != 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      unint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v42 = v20;
  long long v24 = sub_10004D37C(&v19[1].__m_.__sig, &v42);
  v33 = a3;
  if (!v24)
  {
    uint64_t v25 = 0;
LABEL_33:
    std::mutex::unlock(v19);
    long long v26 = 0;
    char v27 = 1;
    if (!v25) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  uint64_t v25 = v24[3];
  long long v26 = (std::__shared_weak_count *)v24[4];
  if (!v26) {
    goto LABEL_33;
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v19);
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v26);
  char v27 = 0;
  if (v25) {
LABEL_34:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25 + 24))(v25, a1 + 184, a1 + 208);
LABEL_35:
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  long long v28 = "RegistrationModel::fNetworkSelectionICCID?";
  if (a4 == 2) {
    long long v28 = "RegistrationModel::fNetworkSelectionICCID2";
  }
  if (a4 == 1) {
    long long v29 = "RegistrationModel::fNetworkSelectionICCID";
  }
  else {
    long long v29 = (char *)v28;
  }
  sub_100058DB0(&__str, v29);
  sub_100058DB0(v37, "");
  sub_10096171C(a1 + 224, *a2, a2[1], (long long *)&__str, (long long *)v37, 1);
  if (v38 < 0) {
    operator delete(v37[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 396) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 349) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  uint64_t v30 = *(int *)(a1 + 48);
  if (v30 > 3) {
    uint64_t v31 = "NetworkListModel.1";
  }
  else {
    uint64_t v31 = off_101A1EE78[v30];
  }
  sub_100058DB0(&v35, v31);
  v34 = *v33;
  if (*v33) {
    dispatch_retain(*v33);
  }
  ctu::RestModule::RestModule();
  if (v34) {
    dispatch_release(v34);
  }
  if (v36 < 0) {
    operator delete(v35);
  }
  *(_DWORD *)(a1 + 320) = *(void *)(a1 + 208);
  if (*(char *)(a1 + 159) < 0) {
    sub_10004FC84(&__str, *(void **)(a1 + 136), *(void *)(a1 + 144));
  }
  else {
    std::string __str = *(std::string *)(a1 + 136);
  }
  std::string::operator=((std::string *)(a1 + 296), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_10095C960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  char v40 = *(std::__shared_weak_count **)(v34 + 408);
  if (v40) {
    sub_10004D2C8(v40);
  }
  v41 = *(std::__shared_weak_count **)(v34 + 384);
  if (v41) {
    sub_10004D2C8(v41);
  }
  if (*(char *)(v34 + 351) < 0) {
    operator delete(*v38);
  }
  if (*(char *)(v34 + 319) < 0) {
    operator delete(*v36);
  }
  sub_10096191C(v37);
  sub_1000D3AC0(v34 + 168);
  sub_10096191C(a9);
  sub_1004C3EF8((void ***)&__p);
  unint64_t v42 = *(std::__shared_weak_count **)(v34 + 40);
  if (v42) {
    sub_10004D2C8(v42);
  }
  v43 = *(std::__shared_weak_count **)(v34 + 24);
  if (v43) {
    std::__shared_weak_count::__release_weak(v43);
  }
  ctu::OsLogLogger::~OsLogLogger(v35);
  NetworkListModelInterface::~NetworkListModelInterface((NetworkListModelInterface *)v34);
  _Unwind_Resume(a1);
}

void sub_10095CA98()
{
}

void sub_10095CAA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  JUMPOUT(0x10095CA58);
}

void sub_10095CAD0()
{
}

void sub_10095CAD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v14 - 88));
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  JUMPOUT(0x10095CA84);
}

void sub_10095CAF8()
{
}

void sub_10095CB38(uint64_t a1)
{
  *(void *)a1 = off_101A1EC20;
  int v2 = *(std::__shared_weak_count **)(a1 + 408);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 384);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  if (*(char *)(a1 + 319) < 0) {
    operator delete(*(void **)(a1 + 296));
  }
  sub_10096191C(a1 + 224);
  sub_1000D3AC0(a1 + 168);
  sub_10096191C(a1 + 96);
  uint64_t v6 = (void **)(a1 + 64);
  sub_1004C3EF8(&v6);
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  NetworkListModelInterface::~NetworkListModelInterface((NetworkListModelInterface *)a1);
}

void sub_10095CC08(uint64_t a1)
{
  sub_10095CB38(a1);

  operator delete();
}

void sub_10095CC40(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 384);
  *(void *)(a1 + 376) = v4;
  *(void *)(a1 + 384) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(a1 + 32));
  ctu::RestModule::connect();
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (*(_DWORD *)(a1 + 208) == 1)
  {
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Retrieved network selection mode is manual, validating the selected operator", v7, 2u);
    }
    sub_10095CD1C(a1);
  }
}

void sub_10095CD04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10095CD1C(uint64_t a1)
{
  uint64_t v28 = 0;
  *(_OWORD *)__p = 0u;
  long long v27 = 0u;
  *(_OWORD *)long long v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)uint64_t v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)unint64_t v20 = 0u;
  long long v21 = 0u;
  NetworkListOperator::NetworkListOperator((NetworkListOperator *)v20);
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 159) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 136), *(void *)(a1 + 144));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)(a1 + 136);
      uint64_t v30 = *(void *)(a1 + 152);
    }
    uint64_t v3 = __dst;
    if (v30 < 0) {
      uint64_t v3 = *(uint8_t **)__dst;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v34 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Validating operator: %{public}s", buf, 0xCu);
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)__dst);
    }
  }
  if (*(char *)(a1 + 159) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 136), *(void *)(a1 + 144));
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(a1 + 136);
    uint64_t v30 = *(void *)(a1 + 152);
  }
  uint64_t v4 = NetworkListOperator::decodeKey();
  if (SHIBYTE(v30) < 0) {
    operator delete(*(void **)__dst);
  }
  uint64_t v5 = *(NSObject **)(a1 + 8);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      NetworkListOperator::getAsString((uint64_t *)__dst, (NetworkListOperator *)v20);
      xpc_object_t v7 = v30 >= 0 ? __dst : *(uint8_t **)__dst;
      *(_DWORD *)buf = 136446210;
      uint64_t v34 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Successfully decoded the network operator: %{public}s", buf, 0xCu);
      if (SHIBYTE(v30) < 0) {
        operator delete(*(void **)__dst);
      }
    }
    xpc_object_t v9 = *(char **)(a1 + 64);
    uint64_t v10 = *(char **)(a1 + 72);
    uint64_t v8 = (void *)(a1 + 64);
    NetworkListOperator::getKey((uint64_t *)__dst, (NetworkListOperator *)v20);
    if (v9 != v10)
    {
      while ((NetworkListOperator::operator==() & 1) == 0)
      {
        v9 += 136;
        if (v9 == v10)
        {
          xpc_object_t v9 = v10;
          break;
        }
      }
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)__dst);
    }
    if (v9 == *(char **)(a1 + 72))
    {
      unint64_t v11 = *(void *)(a1 + 80);
      if ((unint64_t)v9 >= v11)
      {
        unint64_t v13 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)&v9[-*v8] >> 3);
        if (v13 + 1 > 0x1E1E1E1E1E1E1E1) {
          sub_10006A748();
        }
        unint64_t v14 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v11 - *v8) >> 3);
        uint64_t v15 = 2 * v14;
        if (2 * v14 <= v13 + 1) {
          uint64_t v15 = v13 + 1;
        }
        if (v14 >= 0xF0F0F0F0F0F0F0) {
          unint64_t v16 = 0x1E1E1E1E1E1E1E1;
        }
        else {
          unint64_t v16 = v15;
        }
        uint64_t v32 = a1 + 80;
        if (v16) {
          xpc_object_t v17 = (char *)sub_100320E18(a1 + 80, v16);
        }
        else {
          xpc_object_t v17 = 0;
        }
        *(void *)__dst = v17;
        *(void *)&__dst[8] = &v17[136 * v13];
        uint64_t v30 = *(void *)&__dst[8];
        uint64_t v31 = &v17[136 * v16];
        sub_1004C3B28(*(char **)&__dst[8], (long long *)v20);
        v30 += 136;
        sub_1004C3C18((uint64_t *)(a1 + 64), __dst);
        uint64_t v12 = *(char **)(a1 + 72);
        sub_1004C3D9C((uint64_t)__dst);
      }
      else
      {
        sub_1004C3B28(v9, (long long *)v20);
        uint64_t v12 = v9 + 136;
        *(void *)(a1 + 72) = v9 + 136;
      }
      *(void *)(a1 + 72) = v12;
      xpc_object_t v18 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__dst = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Adding it to the operator list", __dst, 2u);
      }
    }
  }
  else
  {
    if (v6)
    {
      *(_WORD *)__dst = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Failed to decode the selected network operator, will have to change the selection mode to automatic", __dst, 2u);
    }
    *(void *)(a1 + 208) = 0;
    *(unsigned char *)(a1 + 217) = 1;
    sub_10095E2E4(a1 + 168);
    sub_100058DB0(__dst, "");
    sub_10095E644(a1 + 96, (long long *)__dst, 1);
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)__dst);
    }
  }
  if (SBYTE7(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[1]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[1]);
  }
  if (SBYTE7(v21) < 0) {
    operator delete(v20[0]);
  }
  return v4;
}

void sub_10095D134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)(v9 + 72) = v10;
  sub_1004BEA24((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10095D1A4(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 400));
}

void sub_10095D1AC(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(int *)(a1 + 52);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v2 > 3) {
        BOOL v6 = "Fetch State Unknown";
      }
      else {
        BOOL v6 = off_101A1EE98[v2];
      }
      if (a2 > 3) {
        xpc_object_t v7 = "Fetch State Unknown";
      }
      else {
        xpc_object_t v7 = off_101A1EE98[a2];
      }
      int v8 = 136315394;
      uint64_t v9 = v6;
      __int16 v10 = 2080;
      unint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating the fetch state from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(_DWORD *)(a1 + 52) = a2;
  }
}

void sub_10095D2A8(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(int *)(a1 + 56);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v2 > 3) {
        BOOL v6 = "Selection State Unknown";
      }
      else {
        BOOL v6 = off_101A1EEB8[v2];
      }
      if (a2 > 3) {
        xpc_object_t v7 = "Selection State Unknown";
      }
      else {
        xpc_object_t v7 = off_101A1EEB8[a2];
      }
      int v8 = 136315394;
      uint64_t v9 = v6;
      __int16 v10 = 2080;
      unint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating the selection state from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(_DWORD *)(a1 + 56) = a2;
  }
}

void sub_10095D3A4(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 52);
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if ((v1 & 0xFFFFFFFE) == 2)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = "Fetch State Unknown";
      if (v1 == 2) {
        uint64_t v4 = "kFetched";
      }
      if (v1 == 3) {
        uint64_t v4 = "kIdle";
      }
      int v9 = 136315138;
      __int16 v10 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Current fetch state: %s, Network scan has been requested", (uint8_t *)&v9, 0xCu);
    }
    sub_10095D1AC(a1, 0);
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Clearing the known operator list", (uint8_t *)&v9, 2u);
    }
    uint64_t v7 = *(void *)(a1 + 64);
    for (uint64_t i = *(void *)(a1 + 72); i != v7; sub_1004C3D24(i))
      i -= 136;
    *(void *)(a1 + 72) = v7;
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR))
  {
    if (v1 > 3) {
      int v8 = "Fetch State Unknown";
    }
    else {
      int v8 = off_101A1EE98[v1];
    }
    int v9 = 136315138;
    __int16 v10 = v8;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Invalid state %s when transitioning to kRequested state. Expected kIdle or kFetched", (uint8_t *)&v9, 0xCu);
  }
}

void sub_10095D550(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 52);
    if (v3 > 3) {
      uint64_t v4 = "Fetch State Unknown";
    }
    else {
      uint64_t v4 = off_101A1EE98[v3];
    }
    int v5 = 136315138;
    BOOL v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Current fetch state: %s Network scan request is being sent to BB", (uint8_t *)&v5, 0xCu);
  }
  sub_10095D1AC(a1, 1u);
}

void sub_10095D61C(uint64_t a1, NetworkListScanResult **a2)
{
  if (!*a2)
  {
    int v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v27 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid NetworkListScanResult", v27, 2u);
    }
    return;
  }
  unsigned int State = NetworkListScanResult::getState(*a2);
  if (State - 2 < 2)
  {
    uint64_t v7 = *(void *)(a1 + 64);
    for (uint64_t i = *(void *)(a1 + 72); i != v7; sub_1004C3D24(i))
      i -= 136;
    *(void *)(a1 + 72) = v7;
  }
  else if (State <= 1)
  {
    NetworkListScanResult::getOperators();
  }
  int v8 = NetworkListScanResult::getState(*a2);
  if ((v8 - 2) < 2)
  {
    unint64_t v11 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      NetworkListScanResult::getState(*a2);
      *(_DWORD *)long long v27 = 136315138;
      *(void *)&v27[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Scan was %s, not timestamping", v27, 0xCu);
    }
    sub_10095D1AC(a1, 2u);
    return;
  }
  if (!v8)
  {
    sub_10095D1AC(a1, 2u);
    uint64_t v12 = *(uint64_t **)(a1 + 64);
    if (v12 == *(uint64_t **)(a1 + 72))
    {
      *(_DWORD *)(a1 + 88) = 0;
      int v9 = *(NSObject **)(a1 + 8);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long v27 = 0;
      __int16 v10 = "#I Fetch completed, but the list is empty, not timestamping";
      goto LABEL_28;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(a1 + 32));
    unint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      unint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v27 = v15;
    xpc_object_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)v27);
    if (v19)
    {
      uint64_t v21 = v19[3];
      unint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    unint64_t v20 = 0;
    char v22 = 1;
LABEL_31:
    *(_DWORD *)(a1 + 88) = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 88))(v21);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    long long v25 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)long long v27 = 67109120;
      *(_DWORD *)&v27[4] = v26;
      __int16 v10 = "#I Scan result is complete, timestamping it with %d";
      long long v23 = v25;
      uint32_t v24 = 8;
      goto LABEL_35;
    }
    return;
  }
  if (v8 == 4)
  {
    sub_10095D1AC(a1, 2u);
    int v9 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v27 = 0;
      __int16 v10 = "#I Fetch aborted by user, not timestamping";
LABEL_28:
      long long v23 = v9;
      uint32_t v24 = 2;
LABEL_35:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v10, v27, v24);
    }
  }
}

void sub_10095D944(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10095D970(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I A network has been selected", v3, 2u);
  }
  sub_10095D2A8(a1, 1u);
}

void sub_10095D9E0(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 356);
  if (v2 != a2)
  {
    int v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v6 = "true";
      if (v2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (!a2) {
        BOOL v6 = "false";
      }
      int v8 = 136315394;
      int v9 = v7;
      __int16 v10 = 2080;
      unint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting user initiated network selection from: %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 356) = a2;
  }
}

uint64_t sub_10095DAC4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 356);
}

void sub_10095DACC(uint64_t a1)
{
}

uint64_t sub_10095DAD4(uint64_t a1, int a2, int a3)
{
  v4[0] = 0;
  v4[64] = 0;
  sub_10095DB24(a1, a2, a3, (MCCAndMNC *)v4);
  return sub_100021FF4((uint64_t)v4);
}

void sub_10095DB10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100021FF4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10095DB24(uint64_t a1, int a2, int a3, MCCAndMNC *a4)
{
  int v8 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asString();
    __int16 v10 = "false";
    if (a2) {
      __int16 v10 = "true";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v9;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Select Network with mode: %s returned with success: %s", (uint8_t *)&buf, 0x16u);
    int v8 = *(NSObject **)(a1 + 8);
  }
  BOOL v11 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v11)
    {
      uint64_t v12 = asString();
      uint64_t v13 = asString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v12;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting active mode from %s to %s", (uint8_t *)&buf, 0x16u);
    }
    *(_DWORD *)(a1 + 320) = a3;
    if (a3 == 1)
    {
      if (*((unsigned char *)a4 + 64))
      {
        MCCAndMNC::getMcc((uint64_t *)&buf, a4);
        MCC::getStringValue((uint64_t *)&v25, (MCC *)&buf);
        std::string::push_back(&v25, 45);
        std::string v26 = v25;
        memset(&v25, 0, sizeof(v25));
        if (!*((unsigned char *)a4 + 64)) {
          sub_10016C840();
        }
        MCCAndMNC::getMnc((uint64_t *)v28, a4);
        MCC::getStringValue((uint64_t *)v23, (MCC *)v28);
        if ((v24 & 0x80u) == 0) {
          unint64_t v14 = v23;
        }
        else {
          unint64_t v14 = (void **)v23[0];
        }
        if ((v24 & 0x80u) == 0) {
          std::string::size_type v15 = v24;
        }
        else {
          std::string::size_type v15 = (std::string::size_type)v23[1];
        }
        unint64_t v16 = std::string::append(&v26, (const std::string::value_type *)v14, v15);
        std::string __p = *v16;
        v16->__r_.__value_.__l.__size_ = 0;
        v16->__r_.__value_.__r.__words[2] = 0;
        v16->__r_.__value_.__r.__words[0] = 0;
        sub_10095E644(a1 + 96, (long long *)&__p, *(unsigned __int8 *)(a1 + 160));
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if ((char)v24 < 0) {
          operator delete(v23[0]);
        }
        if (v30 < 0) {
          operator delete(*(void **)&v29[4]);
        }
        if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v26.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v25.__r_.__value_.__l.__data_);
        }
        if (v32 < 0) {
          operator delete((void *)buf.__r_.__value_.__l.__size_);
        }
        sub_10095CD1C(a1);
      }
      uint64_t v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 319) < 0)
        {
          if (*(void *)(a1 + 304)) {
            unsigned int v18 = *(const char **)(a1 + 296);
          }
          else {
            unsigned int v18 = "<none>";
          }
        }
        else if (*(unsigned char *)(a1 + 319))
        {
          unsigned int v18 = (const char *)(a1 + 296);
        }
        else
        {
          unsigned int v18 = "<none>";
        }
        if (*(char *)(a1 + 159) < 0) {
          sub_10004FC84(&buf, *(void **)(a1 + 136), *(void *)(a1 + 144));
        }
        else {
          std::string buf = *(std::string *)(a1 + 136);
        }
        p_std::string buf = &buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t v28 = 136446466;
        *(void *)long long v29 = v18;
        *(_WORD *)&v29[8] = 2082;
        *(void *)&v29[10] = p_buf;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Setting active network selected code from %{public}s to %{public}s", v28, 0x16u);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      if (*(char *)(a1 + 159) < 0) {
        sub_10004FC84(&buf, *(void **)(a1 + 136), *(void *)(a1 + 144));
      }
      else {
        std::string buf = *(std::string *)(a1 + 136);
      }
      std::string::operator=((std::string *)(a1 + 296), &buf);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      sub_10095D2A8(a1, 3u);
    }
    else
    {
      sub_10095D2A8(a1, 0);
      sub_100058DB0(&buf, "");
      sub_10095E644(a1 + 96, (long long *)&buf, *(unsigned __int8 *)(a1 + 160));
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    sub_10095E1A8(a1 + 96);
    sub_10095E2E4(a1 + 168);
  }
  else
  {
    if (v11)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting the selection state to Idle and clearing fetch timestamp because of failure to complete selection", (uint8_t *)&buf, 2u);
    }
    sub_10095D2A8(a1, 0);
    (*(void (**)(uint64_t))(*(void *)a1 + 128))(a1);
    if (!a3 && *(_DWORD *)(a1 + 364) == 2)
    {
      xpc_object_t v19 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Setting of mode to automatic has failed, and manual network selection is not allowed either, resetting the baseband", (uint8_t *)&buf, 2u);
      }
      sub_100058DB0(&v21, "Resetting because of selection mode failure");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
    }
  }
}

void sub_10095E02C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (*(char *)(v48 - 89) < 0) {
    operator delete(*(void **)(v48 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10095E10C(uint64_t a1, uint64_t a2)
{
  MCC::MCC((MCC *)v5, (const MCC *)a2);
  MCC::MCC((MCC *)v6, (const MCC *)(a2 + 32));
  v6[32] = 1;
  sub_10095DB24(a1, 1, 1, (MCCAndMNC *)v5);
  return sub_100021FF4((uint64_t)v5);
}

void sub_10095E17C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10095E1A8(uint64_t a1)
{
  char v1 = (uint64_t *)*(unsigned __int8 *)(a1 + 65);
  if (*(unsigned char *)(a1 + 65))
  {
    *(unsigned char *)(a1 + 65) = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v1, *(Registry **)a1);
    uint64_t v4 = ServiceMap;
    if ((v5 & 0x8000000000000000) != 0)
    {
      BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        unint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v13 = v5;
    uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
    if (v9)
    {
      uint64_t v11 = v9[3];
      __int16 v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        if (!v11)
        {
LABEL_12:
          if ((v12 & 1) == 0) {
            sub_10004D2C8(v10);
          }
          return;
        }
LABEL_11:
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 88))(v11, a1 + 16, a1 + 40);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    __int16 v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_10095E2C8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10095E2E4(uint64_t a1)
{
  char v1 = (uint64_t *)*(unsigned __int8 *)(a1 + 49);
  if (*(unsigned char *)(a1 + 49))
  {
    *(unsigned char *)(a1 + 49) = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v1, *(Registry **)a1);
    uint64_t v4 = ServiceMap;
    if ((v5 & 0x8000000000000000) != 0)
    {
      BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        unint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v13 = v5;
    uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
    if (v9)
    {
      uint64_t v11 = v9[3];
      __int16 v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        if (!v11)
        {
LABEL_12:
          if ((v12 & 1) == 0) {
            sub_10004D2C8(v10);
          }
          return;
        }
LABEL_11:
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v11 + 64))(v11, a1 + 16, *(void *)(a1 + 40));
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    __int16 v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_10095E404(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10095E420(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Network List Model is being reset", v5, 2u);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  for (uint64_t i = *(void *)(a1 + 72); i != v4; sub_1004C3D24(i))
    i -= 136;
  *(void *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 88) = 0;
  sub_10095D1AC(a1, 3u);
  sub_10095D2A8(a1, 0);
  *(_DWORD *)(a1 + 320) = 0;
  if (*(char *)(a1 + 319) < 0)
  {
    **(unsigned char **)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 296) = 0;
    *(unsigned char *)(a1 + 319) = 0;
  }
  *(unsigned char *)(a1 + 356) = 0;
}

void sub_10095E4F0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 159) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 136);
      uint64_t v5 = *(void *)(a1 + 152);
    }
    uint64_t v3 = __p;
    if (v5 < 0) {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Network selection %{public}s is being reset", buf, 0xCu);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "");
  sub_10095E644(a1 + 96, (long long *)__p, 1);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 217) = 1;
  sub_10095E2E4(a1 + 168);
}

void sub_10095E620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10095E644(uint64_t a1, long long *a2, int a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v6, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  uint64_t v5 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)uint64_t v5 = v6;
  *(void *)(a1 + 56) = v7;
  *(unsigned char *)(a1 + 65) = 1;
  if (a3) {
    sub_10095E1A8(a1);
  }
}

uint64_t sub_10095E6DC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

void sub_10095E6E4(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 392);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      long long v6 = "true";
      if (v2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (!a2) {
        long long v6 = "false";
      }
      int v8 = 136315394;
      uint64_t v9 = v7;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Network needs reselect changing from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 392) = a2;
  }
}

uint64_t sub_10095E7C8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 392);
}

const void **sub_10095E7D0(uint64_t a1)
{
  int v2 = (const ctu::OsLogLogger *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(int *)(a1 + 52);
    if (v4 > 3) {
      uint64_t v5 = "Fetch State Unknown";
    }
    else {
      uint64_t v5 = off_101A1EE98[v4];
    }
    uint64_t v6 = *(int *)(a1 + 56);
    if (v6 > 3) {
      uint64_t v7 = "Selection State Unknown";
    }
    else {
      uint64_t v7 = off_101A1EEB8[v6];
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v66 = 2080;
    uint64_t v67 = (uint64_t)v7;
    __int16 v68 = 2080;
    uint64_t v69 = asString();
    __int16 v70 = 2080;
    uint64_t v71 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Fetch state: %s, Selection state: %s, Network Selection Allowed Raw: %s Network Selection Allowed from SIM (%s)", buf, 0x2Au);
    uint64_t v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 159) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 136), *(void *)(a1 + 144));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)(a1 + 136);
      uint64_t v64 = *(void *)(a1 + 152);
    }
    if (v64 >= 0) {
      int v8 = __dst;
    }
    else {
      int v8 = (BOOL **)__dst[0];
    }
    uint64_t v9 = asString();
    if (*(char *)(a1 + 287) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 264), *(void *)(a1 + 272));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 264);
      uint64_t v62 = *(void *)(a1 + 280);
    }
    __int16 v10 = __p;
    if (v62 < 0) {
      __int16 v10 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446723;
    *(void *)&uint8_t buf[4] = v8;
    __int16 v66 = 2080;
    uint64_t v67 = v9;
    __int16 v68 = 2081;
    uint64_t v69 = (uint64_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Selection Code: %{public}s, Selection Mode: %s, Selection ICCID: %{private}s", buf, 0x20u);
    if (SHIBYTE(v62) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v64) < 0) {
      operator delete(__dst[0]);
    }
    uint64_t v3 = *(NSObject **)v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = (void *)(a1 + 296);
    if (*(char *)(a1 + 319) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    uint64_t v12 = asString();
    unint64_t v13 = (void *)(a1 + 328);
    if (*(char *)(a1 + 351) < 0) {
      unint64_t v13 = (void *)*v13;
    }
    *(_DWORD *)std::string buf = 136446723;
    *(void *)&uint8_t buf[4] = v11;
    __int16 v66 = 2080;
    uint64_t v67 = v12;
    __int16 v68 = 2081;
    uint64_t v69 = (uint64_t)v13;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Active Selection Code: %{public}s, Active Selection Mode: %s, Active ICCID: %{private}s", buf, 0x20u);
    uint64_t v3 = *(NSObject **)v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 356)) {
      std::string::size_type v15 = "true";
    }
    else {
      std::string::size_type v15 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I User Initated Selection: %s", buf, 0xCu);
  }
  unint64_t v16 = *(NetworkListOperator **)(a1 + 64);
  uint64_t v17 = *(NetworkListOperator **)(a1 + 72);
  while (v16 != v17)
  {
    NetworkListOperator::dumpState(v16, v2);
    unint64_t v16 = (NetworkListOperator *)((char *)v16 + 136);
  }
  __dst[0] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 32));
  xpc_object_t v19 = ServiceMap;
  uint64_t v21 = v20;
  if (v20 < 0)
  {
    char v22 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v21;
  std::string v25 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v25)
  {
    uint64_t v27 = v25[3];
    std::string v26 = (std::__shared_weak_count *)v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      char v28 = 0;
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v19);
  std::string v26 = 0;
  char v28 = 1;
LABEL_48:
  (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v27 + 80))(__p, v27, *(unsigned int *)(a1 + 48), 1, @"OverrideCarrierMenuTo", 0, 0);
  sub_1000057AC(__dst, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (__dst[0]) {
    char v30 = sub_100084B4C;
  }
  else {
    char v30 = 0;
  }
  if (v30)
  {
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, __dst[0], v29);
    int v31 = buf[0];
    char v32 = *(NSObject **)v2;
    if (!os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    uint64_t v34 = "true";
    if (!v31) {
      uint64_t v34 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    v35 = "#I Override Carrier Menu To: %s";
    char v36 = v32;
    uint32_t v37 = 12;
  }
  else
  {
    char v38 = *(NSObject **)v2;
    if (!os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    *(_WORD *)std::string buf = 0;
    v35 = "#I Override Carrier Menu To is not present in the carrier bundle";
    char v36 = v38;
    uint32_t v37 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, buf, v37);
LABEL_61:
  __p[0] = 0;
  v39 = (std::mutex *)Registry::getServiceMap(v33, *(Registry **)(a1 + 32));
  char v40 = v39;
  if (v20 < 0)
  {
    v41 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      uint64_t v20 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(v39);
  *(void *)std::string buf = v20;
  v44 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
  if (v44)
  {
    uint64_t v46 = v44[3];
    v45 = (std::__shared_weak_count *)v44[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v40);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v47 = 0;
      goto LABEL_69;
    }
  }
  else
  {
    uint64_t v46 = 0;
  }
  std::mutex::unlock(v40);
  v45 = 0;
  char v47 = 1;
LABEL_69:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v46 + 80))(&v60, v46, *(unsigned int *)(a1 + 48), 1, @"DisallowCarrierMenuAtHome", 0, 0);
  sub_1000057AC(__p, &v60);
  sub_1000577C4(&v60);
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  if (__p[0]) {
    v49 = sub_100084B4C;
  }
  else {
    v49 = 0;
  }
  if (v49)
  {
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, (BOOL *)__p[0], v48);
    int v50 = buf[0];
    v51 = *(NSObject **)v2;
    if (!os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_82;
    }
    v52 = "true";
    if (!v50) {
      v52 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v52;
    v53 = "#I Disallow Carrier Menu At Home: %s";
    v54 = v51;
    uint32_t v55 = 12;
  }
  else
  {
    v56 = *(NSObject **)v2;
    if (!os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_82;
    }
    *(_WORD *)std::string buf = 0;
    v53 = "#I Disallow Carrier Menu At Home is not present in the carrier bundle";
    v54 = v56;
    uint32_t v55 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v53, buf, v55);
LABEL_82:
  v57 = *(NSObject **)v2;
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 392)) {
      v58 = "true";
    }
    else {
      v58 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v58;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Network needs reselect: %s", buf, 0xCu);
  }
  sub_100062778((const void **)__p);
  return sub_100062778((const void **)__dst);
}

void sub_10095EF1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10095EFC4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1004C3DEC(a2, *(void *)(a1 + 64), *(void *)(a1 + 72), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3));
}

void sub_10095EFEC(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v6 = *(NetworkListOperator **)(a1 + 64);
  uint64_t v7 = *(NetworkListOperator **)(a1 + 72);
  MCC::MCC((MCC *)&v10, (const MCC *)a2);
  MCC::MCC((MCC *)&v13, (const MCC *)(a2 + 32));
  if (v6 != v7)
  {
    while (1)
    {
      NetworkListOperator::getMCC(v22, v6);
      MCCAndMNC::getMcc(v20, (MCCAndMNC *)&v10);
      if (MCC::operator==())
      {
        NetworkListOperator::getMNC(v18, v6);
        MCCAndMNC::getMnc(v16, (MCCAndMNC *)&v10);
        char v8 = MCC::operator==();
        if (v17 < 0) {
          operator delete((void *)v16[1]);
        }
        if (v19 < 0) {
          operator delete((void *)v18[1]);
        }
      }
      else
      {
        char v8 = 0;
      }
      if (v21 < 0) {
        operator delete((void *)v20[1]);
      }
      if (v23 < 0) {
        operator delete((void *)v22[1]);
      }
      if (v8) {
        break;
      }
      uint64_t v6 = (NetworkListOperator *)((char *)v6 + 136);
      if (v6 == v7)
      {
        uint64_t v6 = v7;
        break;
      }
    }
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  if (v6 == *(NetworkListOperator **)(a1 + 72))
  {
    char v9 = 0;
    *a3 = 0;
  }
  else
  {
    sub_1004C3B28(a3, (long long *)v6);
    char v9 = 1;
  }
  a3[136] = v9;
}

void sub_10095F150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10095F1E0(uint64_t a1, void **a2, void **a3, _DWORD *a4)
{
  uint64_t v8 = a1 + 136;
  if (*(char *)(a1 + 159) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v8;
    *(void *)&__p[16] = *(void *)(a1 + 152);
  }
  if ((__p[23] & 0x80000000) == 0)
  {
    if (__p[23]) {
      goto LABEL_6;
    }
LABEL_9:
    char v12 = *(NSObject **)(a1 + 8);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    *(_WORD *)std::string __p = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Selected network code is empty", __p, 2u);
    return 0;
  }
  uint64_t v11 = *(void *)&__p[8];
  operator delete(*(void **)__p);
  if (!v11) {
    goto LABEL_9;
  }
LABEL_6:
  char v9 = *(NetworkListOperator **)(a1 + 64);
  uint64_t v10 = *(NetworkListOperator **)(a1 + 72);
  if (*(char *)(a1 + 159) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v8;
    *(void *)&__p[16] = *(void *)(v8 + 16);
  }
  if (v9 != v10)
  {
    while ((NetworkListOperator::operator==() & 1) == 0)
    {
      char v9 = (NetworkListOperator *)((char *)v9 + 136);
      if (v9 == v10)
      {
        char v9 = v10;
        break;
      }
    }
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v9 == *(NetworkListOperator **)(a1 + 72))
  {
    char v17 = *(NSObject **)(a1 + 8);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v18) {
      return result;
    }
    if (*(char *)(a1 + 159) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v8;
      *(void *)&__p[16] = *(void *)(v8 + 16);
    }
    char v19 = __p;
    if (__p[23] < 0) {
      char v19 = *(unsigned char **)__p;
    }
    *(_DWORD *)std::string buf = 136446210;
    char v23 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Failed to find the current selected NetworkListOperator (%{public}s) in the scanned list", buf, 0xCu);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    return 0;
  }
  NetworkListOperator::getCompositeName((uint64_t *)__p, v9);
  if (*((char *)a2 + 23) < 0) {
    operator delete(*a2);
  }
  *(_OWORD *)a2 = *(_OWORD *)__p;
  a2[2] = *(void **)&__p[16];
  NetworkListOperator::getKey((uint64_t *)__p, v9);
  if (*((char *)a3 + 23) < 0) {
    operator delete(*a3);
  }
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = *(void **)&__p[16];
  *a4 = NetworkListOperator::getRAT(v9);
  char v15 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (void **)*a2;
    }
    if (*((char *)a3 + 23) < 0) {
      a3 = (void **)*a3;
    }
    uint64_t v16 = asString();
    *(_DWORD *)std::string __p = 136446722;
    *(void *)&__p[4] = a2;
    *(_WORD *)&__p[12] = 2080;
    *(void *)&__p[14] = a3;
    *(_WORD *)&__p[22] = 2080;
    uint64_t v21 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Filling current selected Network List Operator name: %{public}s, code: %s, RAT: %s", __p, 0x20u);
  }
  return 1;
}

void sub_10095F4E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

BOOL sub_10095F50C(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  if (v4 == v5)
  {
    uint64_t v6 = *(void *)(a1 + 64);
  }
  else
  {
    while ((NetworkListOperator::operator==() & 1) == 0)
    {
      v4 += 136;
      if (v4 == v5)
      {
        uint64_t v4 = v5;
        break;
      }
    }
    uint64_t v6 = v4;
    uint64_t v4 = *(void *)(a1 + 72);
  }
  uint64_t v7 = *(NSObject **)(a1 + 8);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6 == v4)
  {
    if (!v8) {
      return v6 != v4;
    }
    if (*((char *)a2 + 23) >= 0) {
      char v12 = (uint64_t *)a2;
    }
    else {
      char v12 = *(uint64_t **)a2;
    }
    int v20 = 136446210;
    uint64_t v21 = v12;
    BOOL v13 = "#N Failed to find the given NetworkListOperator %{public}s in the NetworkListOperator list";
    unint64_t v14 = v7;
    uint32_t v15 = 12;
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v20, v15);
    return v6 != v4;
  }
  if (v8)
  {
    if (*((char *)a2 + 23) >= 0) {
      char v9 = (uint64_t *)a2;
    }
    else {
      char v9 = *(uint64_t **)a2;
    }
    int v20 = 136446210;
    uint64_t v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Setting the selected network to %{public}s", (uint8_t *)&v20, 0xCu);
  }
  sub_10095E644(a1 + 96, a2, *(unsigned __int8 *)(a1 + 160));
  (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  char v10 = *(unsigned char *)(a1 + 351);
  if (v10 < 0) {
    uint64_t v11 = *(void *)(a1 + 336);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 351);
  }
  uint64_t v16 = *(NSObject **)(a1 + 8);
  BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (!v17) {
      return v6 != v4;
    }
    LOWORD(v20) = 0;
    BOOL v13 = "#N Active ICCID is blank";
    unint64_t v14 = v16;
    uint32_t v15 = 2;
    goto LABEL_29;
  }
  if (v17)
  {
    BOOL v18 = (uint64_t *)(a1 + 328);
    if (v10 < 0) {
      BOOL v18 = *(uint64_t **)(a1 + 328);
    }
    int v20 = 136380675;
    uint64_t v21 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I persisting active ICCID %{private}s", (uint8_t *)&v20, 0xCu);
  }
  sub_10095E644(a1 + 224, (long long *)(a1 + 328), *(unsigned __int8 *)(a1 + 288));
  return v6 != v4;
}

uint64_t sub_10095F750(uint64_t a1, uint64_t a2)
{
  if (sub_10095FA3C((void *)a1) == 1)
  {
    if (sub_10095CD1C(a1))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v20 = 0;
      uint64_t v4 = (_OWORD *)(a1 + 136);
      if (*(char *)(a1 + 159) < 0)
      {
        sub_10004FC84(buf, *(void **)(a1 + 136), *(void *)(a1 + 144));
      }
      else
      {
        *(_OWORD *)std::string buf = *v4;
        uint64_t v20 = *(void *)(a1 + 152);
      }
      char v9 = *(const std::string **)(a1 + 64);
      BOOL v8 = *(const std::string **)(a1 + 72);
      char v10 = v9;
      if (v9 == v8)
      {
        uint64_t v11 = *(const std::string **)(a1 + 64);
      }
      else
      {
        while ((NetworkListOperator::operator==() & 1) == 0)
        {
          char v10 = (const std::string *)((char *)v10 + 136);
          if (v10 == v8)
          {
            char v10 = v8;
            break;
          }
        }
        uint64_t v11 = *(const std::string **)(a1 + 72);
      }
      BOOL v6 = v10 != v11;
      if (v10 == v11)
      {
        char v12 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a1 + 159) < 0)
          {
            sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
          }
          else
          {
            *(_OWORD *)std::string __p = *v4;
            uint64_t v16 = *(void *)(a1 + 152);
          }
          BOOL v13 = __p;
          if (v16 < 0) {
            BOOL v13 = (void **)__p[0];
          }
          *(_DWORD *)BOOL v17 = 136446210;
          BOOL v18 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Could not find the selected code %{public}s in the Network List Operator list", v17, 0xCu);
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      else
      {
        std::string::operator=((std::string *)a2, v10);
        *(_DWORD *)(a2 + 24) = *((_DWORD *)&v9[1].__r_.__value_.__l.__data_ + 2 * (((char *)v10 - (char *)v9) >> 3));
        MCC::operator=();
        MCC::operator=();
        std::string::operator=((std::string *)(a2 + 96), (const std::string *)((char *)v9 + 8 * (((char *)v10 - (char *)v9) >> 3) + 96));
        *(_OWORD *)(a2 + 120) = *(_OWORD *)(&v9[5].__r_.__value_.__l.__data_ + (((char *)v10 - (char *)v9) >> 3));
      }
      if (SHIBYTE(v20) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      uint64_t v7 = *(NSObject **)(a1 + 8);
      BOOL v6 = 0;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Validation of the selected operator has failed, selection mode will be changed to automatic", buf, 2u);
        return 0;
      }
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Mode is not manual selection: %s, giving default NetworkListOperator", buf, 0xCu);
    }
    return 1;
  }
  return v6;
}

void sub_10095FA10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10095FA3C(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 208))(a1);
  if (result == 1)
  {
    if ((*(unsigned int (**)(void *))(*a1 + 248))(a1) == 2)
    {
      uint64_t v3 = a1[1];
      BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v4)
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Selection mode is currently Manual, but that is not allowed any more. Changing it to Automatic", v5, 2u);
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void sub_10095FB10(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 208);
  uint64_t v5 = *(NSObject **)(a1 + 8);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 == a2)
  {
    if (v6)
    {
      int v9 = 136315394;
      uint64_t v10 = asString();
      __int16 v11 = 2080;
      uint64_t v12 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Current selection mode: %s is same as the one being set: %s", (uint8_t *)&v9, 0x16u);
    }
  }
  else
  {
    if (v6)
    {
      int v9 = 136315394;
      uint64_t v10 = asString();
      __int16 v11 = 2080;
      uint64_t v12 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting selection mode from %s to %s", (uint8_t *)&v9, 0x16u);
    }
    int v7 = *(unsigned __int8 *)(a1 + 216);
    *(void *)(a1 + 208) = a2;
    *(unsigned char *)(a1 + 217) = 1;
    if (v7) {
      sub_10095E2E4(a1 + 168);
    }
    if (!a2)
    {
      BOOL v8 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v9) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Network selection mode is being set to Automatic, clearing off the network list timestamp", (uint8_t *)&v9, 2u);
      }
      sub_10095D1AC(a1, 3u);
      *(_DWORD *)(a1 + 88) = 0;
    }
  }
}

std::string *sub_10095FCB0(std::string *result, const std::string *a2)
{
  int v2 = a2;
  uint64_t v3 = result;
  int v4 = (std::string *)((char *)result + 328);
  std::string::value_type v5 = result[14].__r_.__value_.__s.__data_[15];
  if (v5 >= 0) {
    std::string::pointer data = (std::string::pointer)result[14].__r_.__value_.__s.__data_[15];
  }
  else {
    std::string::pointer data = result[14].__r_.__value_.__l.__data_;
  }
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  int v8 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (data == (std::string::pointer)size)
  {
    if (v8 < 0) {
      a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if (result[14].__r_.__value_.__s.__data_[15] < 0)
    {
      uint64_t v12 = (std::string *)v4->__r_.__value_.__r.__words[0];
      uint64_t result = (std::string *)memcmp(v4->__r_.__value_.__l.__data_, a2, result[14].__r_.__value_.__r.__words[0]);
      if (!result) {
        return result;
      }
      __int16 v11 = v3->__r_.__value_.__l.__size_;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      return std::string::operator=(v4, v2);
    }
    if (!result[14].__r_.__value_.__s.__data_[15]) {
      return result;
    }
    int v9 = &result[13].__r_.__value_.__s.__data_[16];
    uint64_t v10 = result[14].__r_.__value_.__s.__data_[15];
    while (*v9 == a2->__r_.__value_.__s.__data_[0])
    {
      ++v9;
      a2 = (const std::string *)((char *)a2 + 1);
      if (!--v10) {
        return result;
      }
    }
  }
  __int16 v11 = result->__r_.__value_.__l.__size_;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (v5 < 0) {
      uint64_t v12 = (std::string *)v4->__r_.__value_.__r.__words[0];
    }
    else {
      uint64_t v12 = v4;
    }
LABEL_22:
    BOOL v13 = (const std::string *)v2->__r_.__value_.__r.__words[0];
    if (v8 >= 0) {
      BOOL v13 = v2;
    }
    int v14 = 136380931;
    uint32_t v15 = v12;
    __int16 v16 = 2081;
    BOOL v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Setting active ICCID from: '%{private}s' to '%{private}s'", (uint8_t *)&v14, 0x16u);
  }
  return std::string::operator=(v4, v2);
}

uint64_t sub_10095FE30(uint64_t a1)
{
  int v2 = sub_10095FA3C((void *)a1);
  uint64_t v3 = *(NSObject **)(a1 + 8);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2 != 1)
  {
    if (v4)
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Mode is not manual: %s, bypassing ICCID validation", buf, 0xCu);
    }
    return 1;
  }
  if (v4)
  {
    std::string::value_type v5 = (void *)(a1 + 328);
    if (*(char *)(a1 + 351) < 0) {
      std::string::value_type v5 = (void *)*v5;
    }
    if (*(char *)(a1 + 287) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 264), *(void *)(a1 + 272));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(a1 + 264);
      uint64_t v24 = *(void *)(a1 + 280);
    }
    int v7 = buf;
    if (v24 < 0) {
      int v7 = *(uint8_t **)buf;
    }
    *(_DWORD *)std::string __p = 136380931;
    *(void *)&__p[4] = v5;
    __int16 v20 = 2081;
    uint64_t v21 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Active ICCID %{private}s, selected ICCID %{private}s", __p, 0x16u);
    if (SHIBYTE(v24) < 0) {
      operator delete(*(void **)buf);
    }
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v24 = 0;
  if (*(char *)(a1 + 287) < 0)
  {
    sub_10004FC84(buf, *(void **)(a1 + 264), *(void *)(a1 + 272));
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)(a1 + 264);
    uint64_t v24 = *(void *)(a1 + 280);
  }
  uint64_t v8 = HIBYTE(v24);
  int v9 = SHIBYTE(v24);
  if (v24 < 0) {
    uint64_t v8 = *(void *)&buf[8];
  }
  if (!v8) {
    goto LABEL_52;
  }
  char v10 = *(unsigned char *)(a1 + 351);
  if (v10 < 0)
  {
    if (!*(void *)(a1 + 336)) {
      goto LABEL_52;
    }
LABEL_25:
    __int16 v11 = (void *)(a1 + 328);
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 351);
    }
    else {
      uint64_t v12 = *(void *)(a1 + 336);
    }
    if (v12 == v8)
    {
      if (v24 >= 0) {
        BOOL v13 = buf;
      }
      else {
        BOOL v13 = *(uint8_t **)buf;
      }
      if ((*(unsigned char *)(a1 + 351) & 0x80) != 0)
      {
        __int16 v11 = (void *)*v11;
        if (!memcmp(v11, v13, *(void *)(a1 + 336))) {
          goto LABEL_52;
        }
        __int16 v16 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
LABEL_46:
          sub_100058DB0(__p, "");
          sub_10095E644(a1 + 224, (long long *)__p, *(unsigned __int8 *)(a1 + 288));
          if (v22 < 0) {
            operator delete(*(void **)__p);
          }
          sub_100058DB0(__p, "");
          sub_10095E644(a1 + 96, (long long *)__p, 1);
          if (v22 < 0) {
            operator delete(*(void **)__p);
          }
          (*(void (**)(uint64_t, void))(*(void *)a1 + 200))(a1, 0);
          uint64_t v6 = 0;
          if (v24 < 0) {
            goto LABEL_53;
          }
          return v6;
        }
LABEL_43:
        BOOL v17 = *(uint8_t **)buf;
        if (v9 >= 0) {
          BOOL v17 = buf;
        }
        *(_DWORD *)std::string __p = 136380931;
        *(void *)&__p[4] = v11;
        __int16 v20 = 2081;
        uint64_t v21 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Mismatch between %{private}s and %{private}s, clearing", __p, 0x16u);
        goto LABEL_46;
      }
      if (!*(unsigned char *)(a1 + 351)) {
        goto LABEL_52;
      }
      int v14 = (unsigned __int8 *)(a1 + 328);
      uint64_t v15 = *(unsigned __int8 *)(a1 + 351);
      while (*v14 == *v13)
      {
        ++v14;
        ++v13;
        if (!--v15) {
          goto LABEL_52;
        }
      }
    }
    __int16 v16 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_46;
    }
    if (v10 < 0) {
      __int16 v11 = (void *)*v11;
    }
    goto LABEL_43;
  }
  if (*(unsigned char *)(a1 + 351)) {
    goto LABEL_25;
  }
LABEL_52:
  uint64_t v6 = 1;
  if ((v9 & 0x80) != 0) {
LABEL_53:
  }
    operator delete(*(void **)buf);
  return v6;
}

void sub_1009601B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009601F8(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 352) != a2)
  {
    BOOL v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      uint64_t v8 = subscriber::asString();
      __int16 v9 = 2080;
      uint64_t v10 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting GW SIM State from %s to %s", (uint8_t *)&v7, 0x16u);
    }
    *(_DWORD *)(a1 + 352) = a2;
    if (a2 != 5)
    {
      std::string::value_type v5 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I GW SIM card state has moved away from ready, clearing the current ICCID", (uint8_t *)&v7, 2u);
        std::string::value_type v5 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = (void *)(a1 + 328);
        if (*(char *)(a1 + 351) < 0) {
          uint64_t v6 = (void *)*v6;
        }
        int v7 = 136380675;
        uint64_t v8 = (uint64_t)v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Clearing the active ICCID: '%{private}s'", (uint8_t *)&v7, 0xCu);
      }
      if (*(char *)(a1 + 351) < 0)
      {
        **(unsigned char **)(a1 + 328) = 0;
        *(void *)(a1 + 336) = 0;
      }
      else
      {
        *(unsigned char *)(a1 + 328) = 0;
        *(unsigned char *)(a1 + 351) = 0;
      }
    }
  }
}

void sub_10096038C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 360) != a2)
  {
    BOOL v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315394;
      uint64_t v6 = asString();
      __int16 v7 = 2080;
      uint64_t v8 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Menu selection allowed from SIM card is changing from %s to %s", (uint8_t *)&v5, 0x16u);
    }
    *(_DWORD *)(a1 + 360) = a2;
  }
}

void sub_100960464(uint64_t a1, uint64_t a2, unsigned int a3, char a4)
{
  __int16 v7 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Evaluating Network Selection: %s on RAT %s", buf, 0x16u);
    __int16 v7 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(int *)(a1 + 396);
    if (v8 > 3) {
      __int16 v9 = "Device Type unknown";
    }
    else {
      __int16 v9 = off_101A1EED8[v8];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device type: %s", buf, 0xCu);
  }
  if ((a4 & 1) == 0)
  {
    uint64_t v21 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      char v22 = "#I Baseband and wireless are not ready";
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
    }
LABEL_22:
    sub_100960B50(a1, 0, 0);
    return;
  }
  if (*(_DWORD *)(a1 + 352) != 5)
  {
    uint64_t v21 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      char v22 = "#I GW SIM state is not ready";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  uint64_t v10 = (uint64_t *)*(unsigned int *)(a1 + 396);
  if (!v10)
  {
    char v23 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Device type is not determined yet", buf, 2u);
    }
    return;
  }
  CFTypeRef cf1 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 32));
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  BOOL v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    BOOL v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  BOOL v18 = 0;
  char v20 = 1;
LABEL_28:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v19 + 80))(&cf, v19, *(unsigned int *)(a1 + 48), 1, @"OverrideCarrierMenuTo", 0, 0);
  sub_1000057AC(&cf1, &cf);
  sub_1000577C4(&cf);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (cf1) {
    uint64_t v24 = sub_100084B4C;
  }
  else {
    uint64_t v24 = 0;
  }
  if (v24)
  {
    if (CFEqual(cf1, kCFBooleanTrue)) {
      int v25 = 1;
    }
    else {
      int v25 = 2;
    }
    std::string v26 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = asString();
      *(_DWORD *)std::string buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v25;
      *(_WORD *)&buf[8] = 2080;
      *(void *)&buf[10] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle is overriding the carrier menu to: %d (%s)", buf, 0x12u);
    }
    int v28 = 2;
    goto LABEL_40;
  }
  int v29 = *(_DWORD *)(a1 + 360);
  if (v29 == 2)
  {
    char v32 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
LABEL_53:
      sub_100062778(&cf1);
      goto LABEL_54;
    }
    *(_WORD *)std::string buf = 0;
    v33 = "#I SIM card's setting allowing the menu to be shown";
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 2u);
    goto LABEL_53;
  }
  if (!v29)
  {
    char v30 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I SIM card's setting for manual selection is not known yet, cannot decide", buf, 2u);
    }
    sub_100062778(&cf1);
    return;
  }
  int v34 = mapRoamingResultToTriBOOL();
  int v35 = v34;
  int v25 = *(_DWORD *)(a1 + 360);
  int v36 = *(_DWORD *)(a1 + 396);
  if ((v36 - 1) < 2)
  {
    CFTypeRef cf = 0;
    sub_1008FB518(*(Registry **)(a1 + 32), (uint64_t *)buf);
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)buf + 80))(&cf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint32_t v37 = (BOOL *)cf;
    buf[0] = 0;
    if (cf)
    {
      CFTypeID v38 = CFGetTypeID(cf);
      if (v38 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v37, v39);
        if (buf[0])
        {
          if (!v35)
          {
            char v40 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              int v25 = 2;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Carrier menu is not allowed when not roaming, and Device is not roaming, do not allow carrier menu", buf, 2u);
            }
            else
            {
              int v25 = 2;
            }
          }
        }
      }
    }
    sub_1000577C4(&cf);
    goto LABEL_76;
  }
  if (v36 == 3 && !v34)
  {
    char v32 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    *(_WORD *)std::string buf = 0;
    v33 = "#I Carrier menu is not allowed when not roaming for a CDMA centric device, and Device is not roaming, do not a"
          "llow carrier menu";
    goto LABEL_52;
  }
LABEL_76:
  int v28 = 1;
LABEL_40:
  sub_100062778(&cf1);
  if (v25 != 1)
  {
    if (v25 != 2) {
      return;
    }
LABEL_54:
    sub_100960B50(a1, 2, 0);
    return;
  }
  int v31 = 1;
  if (*(_DWORD *)(a1 + 396) == 2)
  {
    int v28 = 3;
  }
  else if (a3 <= 8 && ((1 << a3) & 0x138) != 0)
  {
    v41 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      int v31 = 2;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Device is camped on CDMA tech, cannot support carrier selection", buf, 2u);
      int v28 = 0;
    }
    else
    {
      int v28 = 0;
      int v31 = 2;
    }
  }
  sub_100960B50(a1, v31, v28);
}

void sub_100960AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100062778(&a10);
  _Unwind_Resume(a1);
}

void sub_100960B50(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 364) != a2)
  {
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315394;
      uint64_t v11 = asString();
      __int16 v12 = 2080;
      uint64_t v13 = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Carrier selection is changing from %s to %s", (uint8_t *)&v10, 0x16u);
    }
    *(_DWORD *)(a1 + 364) = a2;
    (*(void (**)(void, void, BOOL))(**(void **)(a1 + 376) + 48))(*(void *)(a1 + 376), *(unsigned int *)(a1 + 48), a2 == 1);
  }
  if (*(_DWORD *)(a1 + 368) != a3)
  {
    __int16 v7 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      uint64_t v9 = asString();
      int v10 = 136315394;
      uint64_t v11 = v8;
      __int16 v12 = 2080;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Carrier menu allowed reason is changing from %s to %s", (uint8_t *)&v10, 0x16u);
    }
    *(_DWORD *)(a1 + 368) = a3;
  }
}

uint64_t sub_100960CE0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 364);
}

uint64_t sub_100960CE8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 368);
}

uint64_t sub_100960CF0(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 52);
  if (v3 < 2)
  {
    uint64_t v4 = 2;
    goto LABEL_5;
  }
  if (v3 != 2)
  {
    uint64_t v4 = v3 == 3;
    goto LABEL_5;
  }
  int v12 = *(_DWORD *)(a1 + 56);
  if ((v12 - 1) < 2)
  {
    uint64_t v4 = 4;
    goto LABEL_5;
  }
  if (v12 != 3)
  {
    if (v12) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = 3;
    }
    goto LABEL_5;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 208))(a1) != 1)
  {
    char v22 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Not in manual mode, so not updating the state with the registration status", buf, 2u);
    }
    goto LABEL_55;
  }
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v38 = 0;
  int v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  int v33 = 11;
  if (!(*(unsigned int (**)(uint64_t, void **, void **, int *))(*(void *)a1 + 160))(a1, v37, &v34, &v33))
  {
    char v23 = *(NSObject **)(a1 + 8);
    uint64_t v4 = 0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Serving PLMN is different from the selected NetworkListOperator", buf, 2u);
      uint64_t v4 = 0;
    }
    goto LABEL_49;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v32 = 0;
  uint64_t v14 = HIBYTE(v36);
  if (v36 >= 0) {
    uint64_t v15 = &v34;
  }
  else {
    uint64_t v15 = v34;
  }
  if (v36 < 0) {
    uint64_t v14 = v35;
  }
  buf[0] = 45;
  unsigned int v16 = sub_1001D40E0(v15, (unsigned __int8 *)v15 + v14, buf);
  sub_10012CD04(__p, (char *)v15, (char *)v16, v16 - (unsigned char *)v15);
  BOOL v17 = sub_10001D294((unsigned __int8 *)__p, a2);
  BOOL v18 = *(NSObject **)(a1 + 8);
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    if (v19)
    {
      if ((a2[23] & 0x80u) == 0) {
        char v20 = (const char *)a2;
      }
      else {
        char v20 = *(const char **)a2;
      }
      *(_DWORD *)std::string buf = 136446210;
      char v40 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Serving PLMN %{public}s and the manually selected NetworkListOperator are same", buf, 0xCu);
    }
    int v21 = 3;
    uint64_t v4 = 6;
  }
  else
  {
    if (v19)
    {
      int v24 = (char)a2[23];
      int v25 = *(const char **)a2;
      int v26 = SHIBYTE(v32);
      uint64_t v27 = (void **)__p[0];
      uint64_t v28 = asString();
      int v29 = __p;
      if (v26 < 0) {
        int v29 = v27;
      }
      *(_DWORD *)std::string buf = 136446722;
      if (v24 >= 0) {
        char v30 = (const char *)a2;
      }
      else {
        char v30 = v25;
      }
      char v40 = v30;
      __int16 v41 = 2082;
      uint64_t v42 = v29;
      __int16 v43 = 2080;
      uint64_t v44 = v28;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Different serving PLMN %{public}s, selected: %{public}s, selected: %s", buf, 0x20u);
    }
    uint64_t v4 = 0;
    int v21 = 0;
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
  if (!v17) {
LABEL_49:
  }
    int v21 = 0;
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  if (SHIBYTE(v38) < 0) {
    operator delete(v37[0]);
  }
  if (!v21) {
LABEL_55:
  }
    uint64_t v4 = 5;
LABEL_5:
  int v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(int *)(a1 + 52);
    if (v6 > 3) {
      __int16 v7 = "Fetch State Unknown";
    }
    else {
      __int16 v7 = off_101A1EE98[v6];
    }
    uint64_t v8 = *(int *)(a1 + 56);
    if (v8 > 3) {
      uint64_t v9 = "Selection State Unknown";
    }
    else {
      uint64_t v9 = off_101A1EEB8[v8];
    }
    uint64_t v10 = asString();
    *(_DWORD *)std::string buf = 136315650;
    char v40 = v7;
    __int16 v41 = 2080;
    uint64_t v42 = (void *)v9;
    __int16 v43 = 2080;
    uint64_t v44 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Request for Selection State, Fetch State: %s, Selection State: %s, Current State: %s", buf, 0x20u);
  }
  return v4;
}

void sub_1009610FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10096114C(uint64_t a1, int *a2)
{
  int v4 = sub_10095FA3C((void *)a1);
  *a2 = v4;
  int v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = asString();
    *(_WORD *)&unsigned char __p[12] = 2080;
    *(void *)&__p[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Current network selection mode %s, requested %s", __p, 0x16u);
    int v4 = *a2;
    int v5 = *(NSObject **)(a1 + 8);
  }
  int v6 = *(_DWORD *)(a1 + 320);
  BOOL v7 = v4 != v6;
  BOOL v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  int v9 = v4;
  if (v8)
  {
    uint64_t v10 = "true";
    if (v4 != v6) {
      uint64_t v10 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Are the selection modes matching: %s", __p, 0xCu);
    int v9 = *a2;
  }
  if (v9 == 1)
  {
    uint64_t v11 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = (void *)(a1 + 296);
      if (*(char *)(a1 + 319) < 0) {
        int v12 = (void *)*v12;
      }
      if (*(char *)(a1 + 159) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 136);
        *(void *)&__p[16] = *(void *)(a1 + 152);
      }
      uint64_t v13 = __p;
      if (__p[23] < 0) {
        uint64_t v13 = *(unsigned char **)__p;
      }
      *(_DWORD *)std::string buf = 136446466;
      uint64_t v28 = v12;
      __int16 v29 = 2082;
      char v30 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Current selected network operator: %{public}s, requested: %{public}s", buf, 0x16u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    if (v4 != v6) {
      return 1;
    }
    if (*(char *)(a1 + 159) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 136), *(void *)(a1 + 144));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 136);
      *(void *)&__p[16] = *(void *)(a1 + 152);
    }
    uint64_t v14 = *(unsigned __int8 *)(a1 + 319);
    if ((v14 & 0x80u) == 0) {
      uint64_t v15 = *(unsigned __int8 *)(a1 + 319);
    }
    else {
      uint64_t v15 = *(void *)(a1 + 304);
    }
    uint64_t v16 = __p[23];
    int v17 = __p[23];
    if (__p[23] < 0) {
      uint64_t v16 = *(void *)&__p[8];
    }
    if (v15 == v16)
    {
      BOOL v18 = (const void **)(a1 + 296);
      if (__p[23] >= 0) {
        BOOL v19 = __p;
      }
      else {
        BOOL v19 = *(unsigned __int8 **)__p;
      }
      if ((v14 & 0x80) != 0)
      {
        BOOL v7 = memcmp(*v18, v19, *(void *)(a1 + 304)) != 0;
      }
      else
      {
        if (!*(unsigned char *)(a1 + 319))
        {
          BOOL v7 = 0;
          if ((__p[23] & 0x80000000) == 0) {
            return v7;
          }
          goto LABEL_45;
        }
        uint64_t v20 = v14 - 1;
        do
        {
          int v22 = *(unsigned __int8 *)v18;
          BOOL v18 = (const void **)((char *)v18 + 1);
          int v21 = v22;
          int v23 = *v19++;
          BOOL v7 = v21 != v23;
        }
        while (v21 == v23 && v20-- != 0);
      }
      if ((v17 & 0x80000000) == 0) {
        return v7;
      }
    }
    else
    {
      BOOL v7 = 1;
      if ((__p[23] & 0x80000000) == 0) {
        return v7;
      }
    }
LABEL_45:
    operator delete(*(void **)__p);
  }
  return v7;
}

BOOL sub_100961444(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(int *)(a1 + 396);
  if (v3 != a2)
  {
    int v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 3) {
        int v6 = "Device Type unknown";
      }
      else {
        int v6 = off_101A1EED8[v3];
      }
      if (a2 > 3) {
        BOOL v7 = "Device Type unknown";
      }
      else {
        BOOL v7 = off_101A1EED8[a2];
      }
      int v9 = 136315394;
      uint64_t v10 = v6;
      __int16 v11 = 2080;
      int v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device type changing from %s to %s", (uint8_t *)&v9, 0x16u);
    }
    *(_DWORD *)(a1 + 396) = a2;
  }
  return v3 != a2;
}

BOOL sub_100961548(uint64_t a1)
{
  return *(_DWORD *)(a1 + 52) == 0;
}

BOOL sub_100961558(uint64_t a1)
{
  return *(_DWORD *)(a1 + 52) == 1;
}

BOOL sub_100961568(uint64_t a1)
{
  return *(_DWORD *)(a1 + 56) == 2;
}

uint64_t sub_100961578(uint64_t a1)
{
  return -252645135 * ((*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3);
}

uint64_t sub_100961594(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t sub_10096159C(uint64_t result)
{
  *(_DWORD *)(result + 88) = 0;
  return result;
}

BOOL sub_1009615A4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 52) == 2;
}

void sub_1009615B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100961634(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100961670(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009616A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009616D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10096171C(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, long long *a5, char a6)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v9 = *a4;
    *(void *)(a1 + 32) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 16) = v9;
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v10 = *a5;
    __int16 v11 = (uint64_t *)*((void *)a5 + 2);
    *(void *)(a1 + 56) = v11;
    *(_OWORD *)(a1 + 40) = v10;
  }
  *(unsigned char *)(a1 + 64) = a6;
  *(unsigned char *)(a1 + 65) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)a1);
  uint64_t v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v14;
  BOOL v18 = sub_10004D37C(&v13[1].__m_.__sig, &v23);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_17:
    std::mutex::unlock(v13);
    BOOL v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v20 = v18[3];
  BOOL v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20) {
LABEL_18:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 48))(v20, a1 + 16, a1 + 40);
LABEL_19:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  return a1;
}

void sub_1009618B8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  int v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10096191C(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_10096196C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = (void *)sub_100EB931C(a1, a2, a3);
  *int v6 = &off_101A1EF18;
  v6[17] = a4;
  if (!a4) {
    __assert_rtn("VoLTECallAgent", "EmergencyVoLTECallAgent.cpp", 18, "driver && \"Need valid search driver\"");
  }
  return a1;
}

void sub_1009619E0(_Unwind_Exception *a1)
{
  emergency::CallAgent::~CallAgent(v1);
  _Unwind_Resume(a1);
}

const char *sub_1009619F4(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 8);
  if (v1 > 3) {
    return "???";
  }
  else {
    return off_101A1EFA0[v1];
  }
}

uint64_t sub_100961A1C()
{
  return 3;
}

uint64_t sub_100961A24(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(a1 + 136) + 64))(*(void *)(a1 + 136), *(unsigned int *)(a1 + 8));
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 136) + 80);
    return v3();
  }
  return result;
}

uint64_t sub_100961AB8()
{
  return 0;
}

void sub_100961AC4(emergency::CallAgent *a1)
{
  emergency::CallAgent::~CallAgent(a1);

  operator delete();
}

uint64_t sub_100961AFC(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"KB"])
  {
    uint64_t v2 = 2;
  }
  else if ([v1 isEqualToString:@"MB"])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:@"GB"])
  {
    uint64_t v2 = 4;
  }
  else if ([v1 isEqualToString:@"TB"])
  {
    uint64_t v2 = 5;
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_100961B94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100961BA4(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init((Class)NSISO8601DateFormatter);
  uint64_t v3 = [v2 dateFromString:v1];

  return v3;
}

void sub_100961C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100961C28@<W0>(Registry **a1@<X0>, uint64_t a2@<X2>, uint64_t *a3@<X8>)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  int v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      std::string::size_type v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v24.__r_.__value_.__r.__words[0] = v6;
  long long v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v24);
  if (v10)
  {
    uint64_t v12 = v10[3];
    __int16 v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    __int16 v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v26 = v12;
  uint64_t v27 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
  if (v12 && (*(char *)(a2 + 23) < 0 ? (unint64_t v13 = *(void *)(a2 + 8)) : (unint64_t v13 = *(unsigned __int8 *)(a2 + 23)), v13 >= 0xA))
  {
    std::string::basic_string(&v24, (const std::string *)a2, 0, 0xAuLL, (std::allocator<char> *)&v23);
    if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v16 = &v24;
    }
    else {
      uint64_t v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
    }
    unsigned int v17 = (__CFString *)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v16, 0x8000100u);
    value = v17;
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (v17) {
      BOOL v18 = sub_1000810B8;
    }
    else {
      BOOL v18 = 0;
    }
    if (v18)
    {
      v24.__r_.__value_.__r.__words[0] = 0;
      carrier_space::getCarrierSpaceValueForKey();
      BOOL v19 = (const void *)v24.__r_.__value_.__r.__words[0];
      if (v24.__r_.__value_.__r.__words[0]) {
        uint64_t v20 = sub_100080934;
      }
      else {
        uint64_t v20 = 0;
      }
      if (v20
        && v24.__r_.__value_.__r.__words[0]
        && (CFTypeID v21 = CFGetTypeID(v24.__r_.__value_.__l.__data_), v21 == CFArrayGetTypeID()))
      {
        sub_1000577C4((const void **)&v24.__r_.__value_.__l.__data_);
        unint64_t v23 = v19;
        int v22 = sub_100083F10;
        CFRetain(v19);
      }
      else
      {
        sub_1000577C4((const void **)&v24.__r_.__value_.__l.__data_);
        BOOL v19 = 0;
        int v22 = 0;
        unint64_t v23 = 0;
      }
      if (v22)
      {
        v28.length = CFArrayGetCount((CFArrayRef)v19);
        v28.location = 0;
        BOOL v14 = CFArrayContainsValue((CFArrayRef)v19, v28, value) != 0;
      }
      else
      {
        BOOL v14 = 0;
      }
      sub_100044D00(&v23);
    }
    else
    {
      BOOL v14 = 0;
    }
    sub_1000558F4((const void **)&value);
    __int16 v11 = v27;
    if (v27) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v14 = 0;
    if (v11) {
LABEL_16:
    }
      sub_10004D2C8(v11);
  }
  return v14;
}

void sub_100961EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100961F18(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"monday"])
  {
    uint64_t v2 = 1;
  }
  else if ([v1 isEqualToString:@"tuesday"])
  {
    uint64_t v2 = 2;
  }
  else if ([v1 isEqualToString:@"wednesday"])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:@"thursday"])
  {
    uint64_t v2 = 4;
  }
  else if ([v1 isEqualToString:@"friday"])
  {
    uint64_t v2 = 5;
  }
  else if ([v1 isEqualToString:@"saturday"])
  {
    uint64_t v2 = 6;
  }
  else if ([v1 isEqualToString:@"sunday"])
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = 7;
  }

  return v2;
}

void sub_100962004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100962014(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  TechPolicyController::create(&v2);
}

void sub_10096208C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009620A8()
{
}

uint64_t sub_1009620C8()
{
  return 1;
}

uint64_t sub_1009620D0()
{
  return 1;
}

uint64_t sub_1009620D8()
{
  return 1;
}

void NetworkListController::create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::getRadioModuleType(a1) == 2) {
    operator new();
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Device does not support manual network selection, skipping", (uint8_t *)&__p, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_10096275C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, dispatch_object_t a13, dispatch_object_t a14, dispatch_object_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_100962A1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x1009629C0);
}

void sub_100962A44()
{
}

const char *sub_100962A4C(int a1)
{
  id v1 = "man.?";
  if (a1 == 2) {
    id v1 = "man.2";
  }
  if (a1 == 1) {
    return "man.1";
  }
  else {
    return v1;
  }
}

void sub_100962A78(uint64_t a1)
{
  *(void *)a1 = off_101A1F050;
  sub_1000346F8(a1 + 432, *(void **)(a1 + 440));
  sub_1000346F8(a1 + 408, *(void **)(a1 + 416));
  sub_1000346F8(a1 + 384, *(void **)(a1 + 392));
  sub_1000346F8(a1 + 360, *(void **)(a1 + 368));
  sub_1000346F8(a1 + 336, *(void **)(a1 + 344));
  sub_1000346F8(a1 + 312, *(void **)(a1 + 320));
  sub_100087F94(a1 + 288, *(void **)(a1 + 296));
  sub_1000346F8(a1 + 264, *(void **)(a1 + 272));
  uint64_t v11 = (void **)(a1 + 216);
  sub_10008A88C(&v11);
  long long v2 = *(std::__shared_weak_count **)(a1 + 208);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 184);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 168);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 152);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10005D0E4(a1 + 120, *(void **)(a1 + 128));
  std::string::size_type v6 = *(std::__shared_weak_count **)(a1 + 112);
  if (v6) {
    sub_10004D2C8(v6);
  }
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 64);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  NetworkListInterface::~NetworkListInterface((NetworkListInterface *)a1);
}

void sub_100962BE8(uint64_t a1)
{
  sub_100962A78(a1);

  operator delete();
}

void sub_100962C20(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100962D20(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  std::string::size_type v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100962E60(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  uint64_t v4 = dispatch_group_create();
  int v5 = v4;
  *a2 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v5);
  }
  std::string::size_type v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100962F6C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v28 = 0;
  __int16 v29 = 0;
  NetworkListController::getModel_sync(a1, a2, &v28);
  uint64_t v5 = v28;
  std::string::size_type v6 = *v4;
  BOOL v7 = *v4;
  if (!v28)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model for fetching network list", buf, 2u);
    }
    goto LABEL_14;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Issuing fetch Network Operator List", buf, 2u);
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 64))(v5) & 1) != 0
    || (*(unsigned int (**)(uint64_t))(*(void *)v5 + 48))(v5))
  {
    uint64_t v8 = *v4;
    uint64_t v9 = 0;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Fetch is already in progress, piggy backing another fetch request received", buf, 2u);
    goto LABEL_14;
  }
  if (*(unsigned char *)(a1 + 256))
  {
    uint64_t v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Voice call is currently active, cannot issue network fetch", buf, 2u);
    }
    (*(void (**)(void))(**(void **)(a1 + 160) + 72))(*(void *)(a1 + 160));
LABEL_14:
    uint64_t v9 = 0;
    goto LABEL_15;
  }
  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 120))(v5);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 56));
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    unsigned int v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (!v20)
  {
    uint64_t v22 = 0;
    goto LABEL_25;
  }
  uint64_t v22 = v20[3];
  CFTypeID v21 = (std::__shared_weak_count *)v20[4];
  if (!v21)
  {
LABEL_25:
    std::mutex::unlock(v15);
    CFTypeID v21 = 0;
    char v23 = 1;
    goto LABEL_26;
  }
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v15);
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  char v23 = 0;
LABEL_26:
  int v24 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 88))(v22);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  unsigned int v25 = v24 - v12;
  uint64_t v26 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v12;
    __int16 v31 = 1024;
    unsigned int v32 = v25;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Last network scan was done with timestamp %d, %d seconds ago", buf, 0xEu);
  }
  if (v12 && v25 <= 0x383)
  {
    uint64_t v27 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Not going to scan again as last fetch is still valid, declaring that the fetch is already complete", buf, 2u);
    }
    sub_100963404(a1, a2, 0);
  }
  else
  {
    subscriber::simSlotAsInstance();
    WISPostSimpleMetricWithUnsignedInteger();
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
    sub_10096360C(a1);
  }
  uint64_t v9 = 1;
LABEL_15:
  if (v29) {
    sub_10004D2C8(v29);
  }
  return v9;
}

void sub_1009633BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100963404(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = 0;
  int v12 = 0;
  NetworkListController::getModel_sync(a1, a2, &v11);
  std::string::size_type v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (v11)
  {
    long long buf = 0uLL;
    uint64_t v15 = 0;
    (*(void (**)(long long *__return_ptr))(*(void *)v11 + 144))(&buf);
    uint64_t v7 = *(void *)(a1 + 160);
    memset(v10, 0, sizeof(v10));
    sub_1004C3DEC(v10, buf, *((uint64_t *)&buf + 1), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3));
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 64))(v7, a2, a3, v10);
    p_long long buf = (void **)v10;
    sub_1004C3EF8(&p_buf);
    p_long long buf = (void **)&buf;
    sub_1004C3EF8(&p_buf);
  }
  else
  {
    uint64_t v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not get model for sending %s notification", (uint8_t *)&buf, 0xCu);
    }
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_1009635C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, char a15)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_10096360C(uint64_t a1)
{
  long long v2 = (uint64_t *)*(unsigned int *)(a1 + 192);
  int v3 = *(_DWORD *)(a1 + 196);
  unsigned int v4 = v2 - v3;
  if (v2 == v3)
  {
    __int16 v31 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 56));
    std::string::size_type v6 = ServiceMap;
    if (v7 < 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
    if (v11)
    {
      uint64_t v13 = v11[3];
      int v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    int v12 = 0;
    char v14 = 1;
LABEL_16:
    (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v13 + 32))(&v30, v13, kCarrier1BundleId, @"ManualNetworkScanDelay", 0, 0);
    sub_1000842D0(&v31, &v30);
    sub_1000577C4(&v30);
    if ((v14 & 1) == 0) {
      sub_10004D2C8(v12);
    }
    if (v31) {
      unsigned int v19 = sub_100081E58;
    }
    else {
      unsigned int v19 = 0;
    }
    if (v19)
    {
      *(_DWORD *)long long buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v31, v18);
      uint64_t v20 = *(unsigned int *)buf;
      if (*(int *)buf > 0)
      {
        CFTypeID v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Delaying performing the network scan by %llu seconds", buf, 0xCu);
        }
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 56));
        uint64_t v22 = *(void *)buf;
        sub_100058DB0(__p, "Delay Manual Scan Timer");
        char v23 = *(NSObject **)(a1 + 24);
        dispatch_object_t object = v23;
        if (v23) {
          dispatch_retain(v23);
        }
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 0x40000000;
        v25[2] = sub_100964F64;
        v25[3] = &unk_101A1F0D8;
        v25[4] = a1;
        aBlock = _Block_copy(v25);
        sub_10027A2C0(v22, (uint64_t)__p, 1, 1000000 * v20, &object, &aBlock);
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_38;
      }
      int v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Invalid ManualNetworkScanDelay carrier bundle key value: %d", buf, 8u);
      }
    }
    sub_100964F6C(a1);
LABEL_38:
    sub_1000570E8((const void **)&v31);
    return;
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = "are";
    if (v4 == 1) {
      uint64_t v16 = "is";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v16;
    unsigned int v17 = "'s";
    if (v4 <= 1) {
      unsigned int v17 = "";
    }
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    __int16 v33 = 2080;
    int v34 = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I There %s %d PDP%s active, waiting", buf, 0x1Cu);
  }
}

void sub_1009639C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100963A6C(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  uint64_t v5 = v8;
  if (v8)
  {
    if ((*(uint64_t (**)(uint64_t))(*(void *)v8 + 64))(v8)) {
      char v2 = 1;
    }
    else {
      char v2 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v5)
  {
    std::string::size_type v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model for fetch in progress query", (uint8_t *)&v8, 2u);
    }
    char v2 = 0;
  }
  return v2 & 1;
}

void sub_100963B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100963BB4(uint64_t a1, int a2, uint64_t a3)
{
  std::string::size_type v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  NetworkListController::getModel_sync(a1, a2, &v12);
  uint64_t v7 = v12;
  if (v12)
  {
    a3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 184))(v12, a3);
    uint64_t v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Request for current network selection state, returning: %s", buf, 0xCu);
    }
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (!v7)
  {
    unsigned int v10 = *v6;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not get model for selection state query", (uint8_t *)&v12, 2u);
    }
    return 0;
  }
  return a3;
}

void sub_100963D3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100963D58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  unsigned int v10 = 0;
  NetworkListController::getModel_sync(a1, a2, &v9);
  uint64_t v6 = v9;
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 200))(v9, a3);
    (*(void (**)(uint64_t, void))(*(void *)v6 + 320))(v6, 0);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not get model for setting selection mode to %s", buf, 0xCu);
    }
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100963EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100963EE0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v16 = 0;
  unsigned int v17 = 0;
  NetworkListController::getModel_sync(a1, a2, &v16);
  uint64_t v6 = v16;
  if (v16)
  {
    *(void *)long long buf = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v12 = 0;
    int v10 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(void *)(a3 + 128) = 0;
    NetworkListOperator::NetworkListOperator((NetworkListOperator *)a3);
    if ((*(unsigned int (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v6 + 160))(v6, buf, __p, &v10))
    {
      NetworkListOperator::setName();
      NetworkListOperator::setRAT();
      NetworkListOperator::decodeKey();
    }
    else
    {
      uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not get selected network", v9, 2u);
      }
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (!v6)
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find model for getting selected network info", buf, 2u);
    }
    NetworkListOperator::NetworkListOperator((NetworkListOperator *)a3);
  }
}

void sub_1009640D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  sub_1004BEA24(v24);
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  _Unwind_Resume(a1);
}

void sub_100964124(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  uint64_t v6 = v8;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 144))(v8);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v6)
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find model for getting network list", (uint8_t *)&v8, 2u);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_100964220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100964238(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  if (v8)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 240))(v8, a3);
    sub_100964350(a1, a2);
  }
  else
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model for SIM support", v7, 2u);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100964334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100964350(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = 0;
  CFTypeID v21 = 0;
  NetworkListController::getModel_sync(a1, a2, &v20);
  uint64_t v4 = v20;
  if (!v20)
  {
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    *(_WORD *)unsigned int v19 = 0;
    uint64_t v11 = "Could not find model to evaluation network selection support";
    goto LABEL_28;
  }
  uint64_t v5 = *(void *)(a1 + 320);
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = a1 + 320;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < (int)a2;
    if (v7 >= (int)a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 320 || *(_DWORD *)(v6 + 28) > (int)a2)
  {
LABEL_12:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    *(_WORD *)unsigned int v19 = 0;
    uint64_t v11 = "Could not find RoamingResult";
LABEL_28:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, v19, 2u);
    goto LABEL_29;
  }
  uint64_t v12 = *(void *)(a1 + 344);
  if (!v12) {
    goto LABEL_26;
  }
  uint64_t v13 = a1 + 344;
  do
  {
    int v14 = *(_DWORD *)(v12 + 28);
    BOOL v15 = v14 < (int)a2;
    if (v14 >= (int)a2) {
      uint64_t v16 = (uint64_t *)v12;
    }
    else {
      uint64_t v16 = (uint64_t *)(v12 + 8);
    }
    if (!v15) {
      uint64_t v13 = v12;
    }
    uint64_t v12 = *v16;
  }
  while (*v16);
  if (v13 == a1 + 344 || *(_DWORD *)(v13 + 28) > (int)a2)
  {
LABEL_26:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    *(_WORD *)unsigned int v19 = 0;
    uint64_t v11 = "Could not find RAT";
    goto LABEL_28;
  }
  if (*(unsigned char *)(a1 + 252)) {
    BOOL v17 = 0;
  }
  else {
    BOOL v17 = *(_DWORD *)(a1 + 248) == 2;
  }
  (*(void (**)(uint64_t, void, void, BOOL))(*(void *)v20 + 264))(v20, *(unsigned int *)(v6 + 32), *(unsigned int *)(v13 + 32), v17);
  sub_100964864(a1, a2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 248))(v4) == 2)
  {
    CFNumberRef v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Network selection is not allowed, Setting selection mode to automatic", v19, 2u);
    }
    sub_100963D58(a1, a2, 0);
  }
LABEL_29:
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_100964648(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100964670(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  uint64_t v5 = v8;
  if (v8) {
    BOOL v2 = (*(unsigned int (**)(uint64_t))(*(void *)v8 + 248))(v8) == 1;
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not get model for manual network selection allowed query", (uint8_t *)&v8, 2u);
    }
    return 0;
  }
  return v2;
}

void sub_100964770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100964788(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Network setting is being reset", v8, 2u);
  }
  int v3 = *(void **)(a1 + 120);
  uint64_t v4 = (void *)(a1 + 128);
  if (v3 != v4)
  {
    do
    {
      (*(void (**)(void))(*(void *)v3[5] + 296))(v3[5]);
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          int v3 = v6;
        }
        while (!v7);
      }
      int v3 = v6;
    }
    while (v6 != v4);
  }
}

void sub_100964864(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = 0;
  char v30 = 0;
  NetworkListController::getModel_sync(a1, a2, &v29);
  uint64_t v4 = v29;
  uint64_t v5 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
  if (v29)
  {
    uint64_t v6 = *(NSObject **)v5();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Applying Network Selection", (uint8_t *)&buf, 2u);
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 224))(v4);
    BOOL v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v42 = 0;
    __int16 v43 = 0;
    NetworkListController::getModel_sync(a1, a2, &v42);
    if (a2 == 2)
    {
      uint64_t v8 = (unsigned char *)(a1 + 243);
    }
    else
    {
      if (a2 != 1)
      {
        if (v42) {
          goto LABEL_24;
        }
        goto LABEL_26;
      }
      uint64_t v8 = (unsigned char *)(a1 + 240);
    }
    uint64_t v10 = v42;
    if (v42)
    {
      uint64_t v11 = *v8;
      if (*v8)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v42 + 248))(v42))
        {
          unsigned int v41 = 0;
          if ((*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v10 + 192))(v10, &v41))
          {
            uint64_t v12 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v13 = asString();
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v13;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Setting Network Selection Mode change to %s", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v56 = 0;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long buf = 0u;
            long long v49 = 0u;
            NetworkListOperator::NetworkListOperator((NetworkListOperator *)&buf);
            if (((*(uint64_t (**)(uint64_t, long long *))(*(void *)v10 + 176))(v10, &buf) & 1) == 0)
            {
              int v14 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__dst = 0;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Failed to retrieve selected operator, mode selection has been set to automatic", __dst, 2u);
              }
              unsigned int v41 = 0;
            }
            if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 104))(v10))
            {
              BOOL v15 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__dst = 0;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Selection already in progress, waiting for it to complete", __dst, 2u);
              }
            }
            else
            {
              uint64_t v23 = *(void *)(a1 + 72);
              uint64_t v24 = v41;
              sub_1004C3B28((char *)__dst, &buf);
              uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 256))(v10);
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, uint64_t, uint64_t))(*(void *)v23 + 56))(v23, a2, v24, __dst, v11, v25);
              if (v40 < 0) {
                operator delete(__p);
              }
              if (v38 < 0) {
                operator delete(v37);
              }
              if (v36 < 0) {
                operator delete(v35);
              }
              if (v34 < 0) {
                operator delete(*(void **)__dst);
              }
              uint64_t v26 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = asString();
                NetworkListOperator::getAsString((uint64_t *)v31, (NetworkListOperator *)&buf);
                uint64_t v28 = v32 >= 0 ? v31 : (void **)v31[0];
                *(_DWORD *)uint64_t v44 = 136315394;
                uint64_t v45 = v27;
                __int16 v46 = 2082;
                char v47 = v28;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Successfully sent selection with mode: %s and operator %{public}s to baseband, setting selection to be in progress", v44, 0x16u);
                if (v32 < 0) {
                  operator delete(v31[0]);
                }
              }
              if (v41 == 1) {
                (*(void (**)(uint64_t))(*(void *)v10 + 80))(v10);
              }
            }
            if (SBYTE7(v55) < 0) {
              operator delete((void *)v54);
            }
            if (SHIBYTE(v53) < 0) {
              operator delete(*((void **)&v52 + 1));
            }
            if (SHIBYTE(v51) < 0) {
              operator delete(*((void **)&v50 + 1));
            }
            if (SBYTE7(v49) < 0) {
              operator delete((void *)buf);
            }
            goto LABEL_32;
          }
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v10 + 88))(v10, 1, v41);
          os_log_t v21 = *v7;
          if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
LABEL_32:
            if (v43) {
              sub_10004D2C8(v43);
            }
            goto LABEL_34;
          }
          uint64_t v22 = asString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v22;
          BOOL v17 = "#I No need to change the mode from %s";
          unsigned int v19 = v21;
          uint32_t v20 = 12;
LABEL_31:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&buf, v20);
          goto LABEL_32;
        }
        os_log_t v16 = *v7;
        if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_32;
        }
        LOWORD(buf) = 0;
        BOOL v17 = "#N Carrier selection support is still unknown, cannot perform any network selection yet";
LABEL_30:
        unsigned int v19 = v16;
        uint32_t v20 = 2;
        goto LABEL_31;
      }
LABEL_24:
      os_log_t v16 = *v7;
      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
      LOWORD(buf) = 0;
      BOOL v17 = "#N RAT selection is still unknown, not performing any network selection yet";
      goto LABEL_30;
    }
LABEL_26:
    CFNumberRef v18 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get model for applying network selection if possible", (uint8_t *)&buf, 2u);
    }
    goto LABEL_32;
  }
  uint64_t v9 = *(NSObject **)v5();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get model for applying network selection", (uint8_t *)&buf, 2u);
  }
LABEL_34:
  if (v30) {
    sub_10004D2C8(v30);
  }
}

void sub_100964EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  sub_1004BEA24(v34 - 208);
  if (a34) {
    sub_10004D2C8(a34);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

void sub_100964F64(uint64_t a1)
{
}

void sub_100964F6C(uint64_t a1)
{
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  BOOL v2 = *(void **)(a1 + 120);
  int v3 = (void *)(a1 + 128);
  if (v2 == (void *)(a1 + 128))
  {
LABEL_9:
    BOOL v7 = 0;
LABEL_10:
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Scan was not requested, aborting", buf, 2u);
    }
    goto LABEL_12;
  }
  while (!(*(unsigned int (**)(void))(*(void *)v2[5] + 48))(v2[5]))
  {
    uint64_t v4 = (void *)v2[1];
    if (v4)
    {
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        uint64_t v5 = (void *)v2[2];
        BOOL v6 = *v5 == (void)v2;
        BOOL v2 = v5;
      }
      while (!v6);
    }
    BOOL v2 = v5;
    if (v5 == v3) {
      goto LABEL_9;
    }
  }
  uint64_t v9 = v2[5];
  BOOL v7 = (std::__shared_weak_count *)v2[6];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v41 = v9;
  uint64_t v42 = v7;
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Scan was requested", buf, 2u);
  }
  if (!v9) {
    goto LABEL_10;
  }
  int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 256))(v9);
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 312))(v9);
  uint64_t v13 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v12);
  if ((v11 - 1) < 2)
  {
    int v14 = *v13;
    if (!os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    *(_WORD *)long long buf = 0;
    BOOL v15 = "#I CDMA roaming is not supported, issuing a scan right away";
    goto LABEL_27;
  }
  if (v11)
  {
    if (v11 != 3) {
      goto LABEL_12;
    }
    int v14 = *v13;
    if (!os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
LABEL_28:
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 312))(v9);
      BOOL v17 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
      int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 312))(v9);
      if (v18 == 2)
      {
        add_explicit = (uint64_t *)(a1 + 243);
        uint32_t v20 = (unsigned __int8 *)(a1 + 244);
        os_log_t v21 = (unsigned __int8 *)(a1 + 245);
      }
      else
      {
        if (v18 != 1)
        {
          char v24 = 0;
          __int16 v23 = 0;
          __int16 v25 = 0;
LABEL_37:
          v52[0] = a1;
          v52[1] = v9;
          long long v53 = v7;
          if (v7) {
            add_explicit = (uint64_t *)atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          long long v54 = v17;
          ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, *(Registry **)(a1 + 56));
          uint64_t v27 = ServiceMap;
          if (v28 < 0)
          {
            uint64_t v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v30 = 5381;
            do
            {
              uint64_t v28 = v30;
              unsigned int v31 = *v29++;
              uint64_t v30 = (33 * v30) ^ v31;
            }
            while (v31);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long buf = v28;
          char v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
          __int16 v40 = v25;
          if (v32)
          {
            uint64_t v34 = v32[3];
            __int16 v33 = (std::__shared_weak_count *)v32[4];
            if (v33)
            {
              atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v27);
              atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v33);
              char v35 = 0;
LABEL_47:
              unsigned __int8 v36 = v24 & 0xF3;
              if (v34)
              {
                uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 312))(v9);
                *(void *)long long buf = a1;
                *(void *)&uint8_t buf[8] = v17;
                uint8_t buf[16] = v36;
                *(_WORD *)&buf[17] = v23 | (v40 << 8);
                uint64_t v44 = v9;
                uint64_t v45 = v7;
                if (v7)
                {
                  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
                  uint64_t v46 = a1;
                  uint64_t v47 = v9;
                  CFBooleanRef v48 = v7;
                  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                else
                {
                  uint64_t v46 = a1;
                  uint64_t v47 = v9;
                  CFBooleanRef v48 = 0;
                }
                long long v49 = v17;
                uint64_t v50 = v34;
                long long v51 = v33;
                if ((v35 & 1) == 0) {
                  atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v56 = 0;
                CFBooleanRef v39 = (char *)operator new(0x60uLL);
                *(void *)CFBooleanRef v39 = off_101A1F498;
                *(_OWORD *)(v39 + 8) = *(_OWORD *)buf;
                *(_DWORD *)(v39 + 23) = *(_DWORD *)&buf[15];
                *((void *)v39 + 4) = v9;
                *((void *)v39 + 5) = v7;
                if (v7)
                {
                  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
                  *((void *)v39 + 6) = a1;
                  *((void *)v39 + 7) = v9;
                  *((void *)v39 + 8) = v7;
                  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                else
                {
                  *((void *)v39 + 6) = a1;
                  *((void *)v39 + 7) = v9;
                  *((void *)v39 + 8) = 0;
                }
                *((void *)v39 + 9) = v17;
                *((void *)v39 + 10) = v34;
                *((void *)v39 + 11) = v33;
                if (v33) {
                  atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v56 = v39;
                (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v34 + 72))(v34, v37, v55);
                sub_1004CACEC(v55);
                if (v51) {
                  sub_10004D2C8(v51);
                }
                if (v48) {
                  sub_10004D2C8(v48);
                }
                if (v45) {
                  sub_10004D2C8(v45);
                }
              }
              else
              {
                char v38 = *v17;
                if (os_log_type_enabled(*v17, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Could not get MaxDataRateManager to query supported data rates", buf, 2u);
                }
                sub_100965930(v52, v36);
              }
              if ((v35 & 1) == 0) {
                sub_10004D2C8(v33);
              }
              if (v53) {
                sub_10004D2C8(v53);
              }
              goto LABEL_12;
            }
          }
          else
          {
            uint64_t v34 = 0;
          }
          std::mutex::unlock(v27);
          __int16 v33 = 0;
          char v35 = 1;
          goto LABEL_47;
        }
        add_explicit = (uint64_t *)(a1 + 240);
        uint32_t v20 = (unsigned __int8 *)(a1 + 241);
        os_log_t v21 = (unsigned __int8 *)(a1 + 242);
      }
      __int16 v23 = *v20;
      char v24 = *(unsigned char *)add_explicit;
      __int16 v25 = *v21;
      goto LABEL_37;
    }
    *(_WORD *)long long buf = 0;
    BOOL v15 = "#I CDMA roaming allowed but RAT selection does not matter, issuing a scan right away";
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    goto LABEL_28;
  }
  uint64_t v22 = *v13;
  if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I CDMA roaming support is not known, erroring out of scan", buf, 2u);
  }
  sub_100965670(a1, &v41);
LABEL_12:
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1009655F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  sub_1004CACEC((void *)(v30 - 128));
  sub_100965AA4(&a13);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  if (a27) {
    sub_10004D2C8(a27);
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
  _Unwind_Resume(a1);
}

void sub_100965670(uint64_t a1, void *a2)
{
  uint64_t v4 = (char *)operator new(0x38uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 1) = 0;
  *(void *)uint64_t v4 = off_101A1FB98;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  uint64_t v5 = *a2;
  uint64_t v12 = v4 + 24;
  uint64_t v13 = (std::__shared_weak_count *)v4;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, char **))(*(void *)v5 + 40))(v5, &v12);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)*a2 + 312))(*a2);
  BOOL v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Network fetch has failed, sending kFetchNetworkError", buf, 2u);
  }
  int v8 = (*(uint64_t (**)(void))(*(void *)*a2 + 312))(*a2);
  sub_1009674B4(a1 + 200, v8);
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 312))(*a2) == 1) {
    (*(void (**)(void))(**(void **)(a1 + 160) + 72))(*(void *)(a1 + 160));
  }
  uint64_t v9 = *(void *)(a1 + 104);
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*a2 + 312))(*a2);
  memset(v11, 0, sizeof(v11));
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)v9 + 96))(v9, a1 + 56, v10, v11, 0);
  *(void *)long long buf = v11;
  sub_1004C3EF8((void ***)buf);
  sub_10004D2C8((std::__shared_weak_count *)v4);
}

void sub_1009658EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1004C3EF8((void ***)va);
  sub_10004D2C8(v7);
  _Unwind_Resume(a1);
}

uint64_t sub_100965930(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  (*(void (**)(uint64_t))(*(void *)a1[1] + 56))(a1[1]);
  uint64_t v5 = *(NSObject **)a1[3];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    ratSelectionAsStr((uint64_t *)__p, a2);
    if (v11 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Requesting network scan with RAT selection: %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v7 = *(void *)(v4 + 72);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1[1] + 312))(a1[1]);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v8, a2);
}

void *sub_100965AA4(void *a1)
{
  BOOL v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100965AEC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  uint64_t v5 = v8;
  uint64_t v6 = *v4;
  if (v8)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting the network selection to Automatic", v7, 2u);
    }
    subscriber::simSlotAsInstance();
    WISPostSimpleMetricWithUnsignedInteger();
    WISPostSimpleMetricWithUnsignedInteger();
    sub_100963D58(a1, a2, 0);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 272))(v5, 1);
    sub_100964864(a1, a2);
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not get model for automatically selecting network", v7, 2u);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100965C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100965C7C(void **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (NSObject **)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  uint64_t v13 = 0;
  int v14 = 0;
  NetworkListController::getModel_sync((uint64_t)a1, a2, &v13);
  uint64_t v7 = v13;
  uint64_t v8 = *v6;
  if (v13)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = a3;
      if (*((char *)a3 + 23) < 0) {
        uint64_t v9 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting the network selection to Manual with code: %{public}s", buf, 0xCu);
    }
    subscriber::simSlotAsInstance();
    WISPostSimpleMetricWithUnsignedInteger();
    if (((unsigned int (*)(void **, uint64_t))(*a1)[9])(a1, a2))
    {
      WISPostSimpleMetricWithUnsignedInteger();
      sub_100963D58((uint64_t)a1, a2, 1);
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 312))(v7);
      char v11 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a3 + 23) >= 0) {
          uint64_t v12 = a3;
        }
        else {
          uint64_t v12 = (uint64_t *)*a3;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v16 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I User selected network operator: %{public}s", buf, 0xCu);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 168))(v7, a3);
      sub_100964864((uint64_t)a1, a2);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 272))(v7, 1);
    }
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a3 + 23) < 0) {
      a3 = (uint64_t *)*a3;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v16 = a3;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find model to select %{public}s network", buf, 0xCu);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100965F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100965F88(uint64_t a1, unsigned int *a2)
{
  if (a2[1] == 27 && *((void *)a2 + 1) == *((void *)a2 + 2))
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CSP File update received and it is of 0 length, marking network selection as allowed by SIM", v5, 2u);
    }
    sub_100964238(a1, *a2, 1);
  }
}

void sub_10096604C(uint64_t a1)
{
  id v1 = *(unsigned int **)(a1 + 216);
  BOOL v2 = *(unsigned int **)(a1 + 224);
  if (v1 != v2)
  {
    char v4 = 1;
    do
    {
      uint64_t v5 = *v1;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      NetworkListController::getModel_sync(a1, v5, &v11);
      uint64_t v6 = v11;
      if (v11)
      {
        uint64_t v7 = v1[2];
        if (subscriber::isSimReady())
        {
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 72))(*(void *)(a1 + 72), v5);
          (*(void (**)(uint64_t, unsigned int *))(*(void *)v6 + 216))(v6, v1 + 18);
        }
        char isSimSettled = subscriber::isSimSettled();
        (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 232))(v11, v7);
        sub_100964350(a1, v5);
        v4 &= isSimSettled;
      }
      else
      {
        uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get model for SIM state change", v10, 2u);
        }
      }
      if (v12) {
        sub_10004D2C8(v12);
      }
      v1 += 42;
    }
    while (v1 != v2);
    if (v4) {
      sub_100966230(a1);
    }
  }
}

void sub_100966214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100966230(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 252))
  {
    BOOL v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Radio is in reset", buf, 2u);
    }
    int v3 = *(void **)(a1 + 120);
    char v4 = (void *)(a1 + 128);
    if (v3 != v4)
    {
      do
      {
        (*(void (**)(void))(*(void *)v3[5] + 288))(v3[5]);
        uint64_t v5 = (void *)v3[1];
        if (v5)
        {
          do
          {
            uint64_t v6 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v6 = (void *)v3[2];
            BOOL v7 = *v6 == (void)v3;
            int v3 = v6;
          }
          while (!v7);
        }
        int v3 = v6;
      }
      while (v6 != v4);
    }
  }
  else
  {
    uint64_t v8 = *(unsigned int **)(a1 + 216);
    uint64_t v9 = *(unsigned int **)(a1 + 224);
    if (v8 == v9)
    {
      os_log_t v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Radio not in reset, but we have no SIM information. Ignoring radio mode change.", buf, 2u);
      }
    }
    else
    {
      char v10 = 1;
      do
      {
        uint64_t v11 = *v8;
        if ((subscriber::isSimSettled() & 1) == 0)
        {
          uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
          char v10 = 0;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = subscriber::asString();
            uint64_t v14 = asString();
            *(_DWORD *)long long buf = 136315394;
            uint64_t v23 = v13;
            __int16 v24 = 2080;
            uint64_t v25 = v14;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s is not settled, ignoring radio mode %s", buf, 0x16u);
            char v10 = 0;
          }
        }
        v8 += 42;
      }
      while (v8 != v9);
      int v15 = *(_DWORD *)(a1 + 248);
      if (v10 & 1 | (v15 != 2))
      {
        uint64_t v16 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = asString();
          if (*(void *)(a1 + 224) - *(void *)(a1 + 216) == 168) {
            int v18 = "SIM is";
          }
          else {
            int v18 = "SIMs are";
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v23 = v17;
          __int16 v24 = 2080;
          uint64_t v25 = (uint64_t)v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Radio (%s), %s settled", buf, 0x16u);
          int v15 = *(_DWORD *)(a1 + 248);
        }
        if (v15 == 2)
        {
          unsigned int v19 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
          if (!capabilities::ct::shouldRadioInitInAirplaneMode(v19)) {
            return;
          }
          uint32_t v20 = *(void (**)(void))(**(void **)(a1 + 88) + 32);
        }
        else
        {
          uint32_t v20 = *(void (**)(void))(**(void **)(a1 + 88) + 32);
        }
        v20();
      }
    }
  }
}

void sub_100966594(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72));
  BOOL v2 = *(void **)(a1 + 120);
  if (v2 != (void *)(a1 + 128))
  {
    do
    {
      (*(void (**)(void))(*(void *)v2[5] + 304))(v2[5]);
      int v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          char v4 = v3;
          int v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          char v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          BOOL v2 = v4;
        }
        while (!v5);
      }
      BOOL v2 = v4;
    }
    while (v4 != (void *)(a1 + 128));
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Number of activated data contexts: %d", __p, 8u);
    uint64_t v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Number of data contexts rejected deactivation: %d", __p, 8u);
    uint64_t v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 246)) {
      uint64_t v9 = "enabled";
    }
    else {
      uint64_t v9 = "disabled";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Airplane mode: %s", __p, 0xCu);
    uint64_t v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asString();
    uint64_t v11 = "true";
    if (!*(unsigned char *)(a1 + 252)) {
      uint64_t v11 = "false";
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v10;
    __int16 v18 = 2080;
    unsigned int v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Radio operating mode: %s in reset: %s", __p, 0x16u);
  }
  uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    ratSelectionAsStr((uint64_t *)__p, *(unsigned char *)(a1 + 240));
    uint64_t v14 = v20 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)long long buf = 136446210;
    uint64_t v22 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I RAT selection: %{public}s", buf, 0xCu);
    if (v20 < 0) {
      operator delete(*(void **)__p);
    }
  }
  if (capabilities::ct::supportsGemini((capabilities::ct *)v13))
  {
    int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      ratSelectionAsStr((uint64_t *)__p, *(unsigned char *)(a1 + 243));
      if (v20 >= 0) {
        uint64_t v16 = __p;
      }
      else {
        uint64_t v16 = *(unsigned char **)__p;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I RAT selection: %{public}s", buf, 0xCu);
      if (v20 < 0) {
        operator delete(*(void **)__p);
      }
    }
  }
}

void sub_100966954(uint64_t a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    char v4 = *(void **)(a1 + 288);
    if (v4 != (void *)(a1 + 296))
    {
      BOOL v5 = (void *)(a2 + 8);
      uint64_t v6 = &_mh_execute_header;
      int v7 = "#I Carrier bundle is now %s (%s)";
      do
      {
        uint64_t v8 = *v5;
        uint64_t v9 = *((unsigned int *)v4 + 8);
        if (!*v5) {
          goto LABEL_14;
        }
        uint64_t v10 = v5;
        do
        {
          int v11 = *(_DWORD *)(v8 + 32);
          BOOL v12 = v11 < (int)v9;
          if (v11 >= (int)v9) {
            BOOL v13 = (uint64_t *)v8;
          }
          else {
            BOOL v13 = (uint64_t *)(v8 + 8);
          }
          if (!v12) {
            uint64_t v10 = (void *)v8;
          }
          uint64_t v8 = *v13;
        }
        while (*v13);
        if (v10 != v5 && (int)v9 >= *((_DWORD *)v10 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_18;
          }
          __int16 v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 8));
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v25 = asString();
            uint64_t v26 = asString();
            uint64_t v27 = v6;
            uint64_t v28 = v7;
            uint64_t v29 = asString();
            uint64_t v30 = asString();
            *(_DWORD *)long long buf = 136315906;
            uint64_t v32 = v25;
            __int16 v33 = 2080;
            uint64_t v34 = v26;
            __int16 v35 = 2080;
            uint64_t v36 = v29;
            int v7 = v28;
            uint64_t v6 = v27;
            __int16 v37 = 2080;
            uint64_t v38 = v30;
            uint64_t v17 = (mach_header_64 *)v27;
            __int16 v18 = v24;
            unsigned int v19 = "#I Carrier bundle changing from %s (%s) to %s (%s)";
            uint32_t v20 = 42;
            goto LABEL_16;
          }
        }
        else
        {
LABEL_14:
          uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v9);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = asString();
            uint64_t v16 = asString();
            *(_DWORD *)long long buf = 136315394;
            uint64_t v32 = v15;
            __int16 v33 = 2080;
            uint64_t v34 = v16;
            uint64_t v17 = (mach_header_64 *)v6;
            __int16 v18 = v14;
            unsigned int v19 = v7;
            uint32_t v20 = 22;
LABEL_16:
            _os_log_impl(v17, v18, OS_LOG_TYPE_DEFAULT, v19, buf, v20);
          }
        }
        sub_100964350(a1, *((unsigned int *)v4 + 8));
LABEL_18:
        os_log_t v21 = (void *)v4[1];
        if (v21)
        {
          do
          {
            uint64_t v22 = v21;
            os_log_t v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v22 = (void *)v4[2];
            BOOL v23 = *v22 == (void)v4;
            char v4 = v22;
          }
          while (!v23);
        }
        char v4 = v22;
      }
      while (v22 != (void *)(a1 + 296));
    }
  }
}

void sub_100966C00(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 280))
  {
    BOOL v5 = (void *)*a2;
    int v3 = a2 + 1;
    char v4 = v5;
    if (v5 == v3) {
      return;
    }
    uint64_t v6 = *(void **)(a1 + 264);
    int v7 = v6;
    while (1)
    {
      BOOL v8 = *((_DWORD *)v4 + 7) == *((_DWORD *)v7 + 7) && *((_DWORD *)v4 + 8) == *((_DWORD *)v7 + 8);
      if (!v8) {
        break;
      }
      uint64_t v9 = (void *)v4[1];
      uint64_t v10 = v4;
      if (v9)
      {
        do
        {
          char v4 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          char v4 = (void *)v10[2];
          BOOL v8 = *v4 == (void)v10;
          uint64_t v10 = v4;
        }
        while (!v8);
      }
      int v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          BOOL v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v12 = (void *)v7[2];
          BOOL v8 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v8);
      }
      int v7 = v12;
      if (v4 == v3) {
        return;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void **)(a1 + 264);
  }
  BOOL v13 = (void *)(a1 + 272);
  if (v6 != (void *)(a1 + 272))
  {
    do
    {
      uint64_t v19 = 0;
      uint32_t v20 = 0;
      NetworkListController::getModel_sync(a1, *((_DWORD *)v6 + 7), &v19);
      if (v19)
      {
        if ((*(uint64_t (**)(uint64_t, void))(*(void *)v19 + 336))(v19, *((unsigned int *)v6 + 8))) {
          sub_100964350(a1, *((unsigned int *)v6 + 7));
        }
      }
      else
      {
        uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v6 + 7));
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = *((int *)v6 + 8);
          __int16 v18 = "Device Type unknown";
          if (v17 <= 3) {
            __int16 v18 = off_101A1FBD8[v17];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v22 = v18;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find model for device type (%s) change", buf, 0xCu);
        }
      }
      if (v20) {
        sub_10004D2C8(v20);
      }
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v8 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v8);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v13);
  }
}

void sub_100966E74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100966E90(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 328))
  {
    int v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    char v4 = *(void **)(a1 + 312);
    BOOL v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      int v7 = (void *)v3[1];
      BOOL v8 = v3;
      if (v7)
      {
        do
        {
          int v3 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          BOOL v8 = v3;
        }
        while (!v6);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          BOOL v5 = v10;
        }
        while (!v6);
      }
      BOOL v5 = v10;
      if (v3 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    char v4 = *(void **)(a1 + 312);
  }
  int v11 = (void *)(a1 + 320);
  if (v4 != (void *)(a1 + 320))
  {
    BOOL v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v4 + 7);
      if (!*v12) {
        goto LABEL_34;
      }
      uint64_t v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          __int16 v18 = (uint64_t *)v13;
        }
        else {
          __int16 v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          uint64_t v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 != v12 && (int)v14 >= *((_DWORD *)v15 + 7))
      {
        if (*((_DWORD *)v15 + 8) == *((_DWORD *)v4 + 8)) {
          goto LABEL_38;
        }
        uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = asString();
          uint64_t v28 = asString();
          *(_DWORD *)long long buf = 136315394;
          uint64_t v30 = v27;
          __int16 v31 = 2080;
          uint64_t v32 = v28;
          os_log_t v21 = v26;
          uint64_t v22 = "#I RoamingResult changing from %s to %s";
          uint32_t v23 = 22;
          goto LABEL_36;
        }
      }
      else
      {
LABEL_34:
        uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v30 = v20;
          os_log_t v21 = v19;
          uint64_t v22 = "#I RoamingResult is now %s";
          uint32_t v23 = 12;
LABEL_36:
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, v23);
        }
      }
      sub_100964350(a1, *((unsigned int *)v4 + 7));
LABEL_38:
      __int16 v24 = (void *)v4[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          __int16 v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v4[2];
          BOOL v6 = *v25 == (void)v4;
          char v4 = v25;
        }
        while (!v6);
      }
      char v4 = v25;
    }
    while (v25 != v11);
  }
}

void sub_100967178(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 360);
  if (v2 == (void *)(a1 + 368))
  {
    int v3 = 0;
  }
  else
  {
    int v3 = 0;
    do
    {
      char v4 = (void *)v2[1];
      BOOL v5 = v2;
      if (v4)
      {
        do
        {
          BOOL v6 = v4;
          char v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v5[2];
          BOOL v7 = *v6 == (void)v5;
          BOOL v5 = v6;
        }
        while (!v7);
      }
      v3 += *((_DWORD *)v2 + 8);
      BOOL v2 = v6;
    }
    while (v6 != (void *)(a1 + 368));
  }
  if (v3 != *(_DWORD *)(a1 + 192))
  {
    *(_DWORD *)(a1 + 192) = v3;
    BOOL v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67109120;
      v9[1] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I There are now %d activated contexts, rechecking to see if we can request the manual network scan.", (uint8_t *)v9, 8u);
    }
    sub_10096360C(a1);
  }
}

void sub_100967294(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 384);
  if (v2 == (void *)(a1 + 392))
  {
    int v3 = 0;
  }
  else
  {
    int v3 = 0;
    do
    {
      char v4 = (void *)v2[1];
      BOOL v5 = v2;
      if (v4)
      {
        do
        {
          BOOL v6 = v4;
          char v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v5[2];
          BOOL v7 = *v6 == (void)v5;
          BOOL v5 = v6;
        }
        while (!v7);
      }
      v3 += *((_DWORD *)v2 + 8);
      BOOL v2 = v6;
    }
    while (v6 != (void *)(a1 + 392));
  }
  if (v3 != *(_DWORD *)(a1 + 196))
  {
    *(_DWORD *)(a1 + 196) = v3;
    BOOL v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 67109120;
      v9[1] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I There are now %d contexts that rejected deactivation, rechecking to see if we can request the manual network scan.", (uint8_t *)v9, 8u);
    }
    sub_10096360C(a1);
  }
}

void sub_1009673B0(uint64_t a1, int a2)
{
  char v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband refresh start received", (uint8_t *)&v5, 2u);
  }
  uint64_t v5 = 0;
  BOOL v6 = 0;
  NetworkListController::getModel_sync(a1, a2, &v5);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 288))(v5);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_10096749C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009674B4(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  BOOL v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/network_list_fetch_complete");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100967558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_10096759C()
{
}

void sub_100967C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_group_t group, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char a42)
{
  sub_1004BEA24((uint64_t)&a42);
  sub_1000D4350(v43 - 224);
  if (v42) {
    dispatch_release(v42);
  }
  _Unwind_Resume(a1);
}

void sub_100967CF8(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  char v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(*a1 + 48) + 16))(*(void *)(*a1 + 48));
  xpc_object_t v8 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)a3 + 272))();
  if (capabilities::ct::shouldRadioInitInAirplaneMode(v8))
  {
    os_log_t v9 = *v7;
    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v10 = "#I Device supports radio init in airplane mode, bringing baseband online";
LABEL_30:
    uint64_t v20 = v9;
    uint32_t v21 = 2;
LABEL_31:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v10, buf, v21);
    return;
  }
  int v11 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 88) + 40))(*(void *)(v6 + 88), a2);
  BOOL v12 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = asString();
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Network attach state is %s", buf, 0xCu);
  }
  if ((v11 - 1) < 2)
  {
    os_log_t v9 = *v7;
    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v10 = "#I Skipping network attach";
    goto LABEL_30;
  }
  if (v11) {
    BOOL v13 = v11 == 3;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    int v14 = *(_DWORD *)(v6 + 248);
    uint64_t v15 = *v7;
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v14 == 2)
    {
      if (v16)
      {
        uint64_t v17 = asString();
        *(_DWORD *)long long buf = 136315138;
        uint64_t v33 = v17;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Radio mode is %s, initiating network attach", buf, 0xCu);
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 88) + 32))(*(void *)(v6 + 88), a2, 1);
      uint64_t v18 = *(void *)(v6 + 72);
      NetworkListOperator::NetworkListOperator((NetworkListOperator *)v24);
      uint64_t v19 = a1[1];
      dispatch_group_t group = v19;
      if (v19)
      {
        dispatch_retain(v19);
        dispatch_group_enter(v19);
      }
      (*(void (**)(uint64_t, uint64_t, void, void **, dispatch_group_t *))(*(void *)v18 + 64))(v18, a2, 0, v24, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      if (v31 < 0) {
        operator delete(__p);
      }
      if (v29 < 0) {
        operator delete(v28);
      }
      if (v27 < 0) {
        operator delete(v26);
      }
      if (v25 < 0) {
        operator delete(v24[0]);
      }
    }
    else if (v16)
    {
      uint64_t v22 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v33 = v22;
      uint64_t v10 = "#I Delaying network attach until radio mode (%s) is online";
      uint64_t v20 = v15;
      uint32_t v21 = 12;
      goto LABEL_31;
    }
  }
}

void sub_100968070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group, char a10)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  sub_1004BEA24((uint64_t)&a10);
  _Unwind_Resume(a1);
}

BOOL sub_1009680A4(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (a3)
  {
    uint64_t v7 = *(void *)(a1 + 440);
    if (v7)
    {
      uint64_t v8 = a1 + 440;
      uint64_t v9 = a1 + 440;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < a2;
        if (v10 >= a2) {
          BOOL v12 = (uint64_t *)v7;
        }
        else {
          BOOL v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          uint64_t v9 = v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      goto LABEL_19;
    }
LABEL_21:
    BOOL v17 = 0;
    goto LABEL_22;
  }
  uint64_t v13 = *(void *)(a1 + 416);
  if (!v13) {
    goto LABEL_21;
  }
  uint64_t v8 = a1 + 416;
  uint64_t v9 = a1 + 416;
  do
  {
    int v14 = *(_DWORD *)(v13 + 28);
    BOOL v15 = v14 < a2;
    if (v14 >= a2) {
      BOOL v16 = (uint64_t *)v13;
    }
    else {
      BOOL v16 = (uint64_t *)(v13 + 8);
    }
    if (!v15) {
      uint64_t v9 = v13;
    }
    uint64_t v13 = *v16;
  }
  while (*v16);
LABEL_19:
  if (v9 == v8 || *(_DWORD *)(v9 + 28) > a2) {
    goto LABEL_21;
  }
  BOOL v17 = *(unsigned __int8 *)(v9 + 32) != 0;
LABEL_22:
  uint64_t v18 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      uint64_t v19 = "Operator";
    }
    else {
      uint64_t v19 = "Carrier";
    }
    int v21 = 136315394;
    uint64_t v22 = v19;
    __int16 v23 = 2080;
    uint64_t v24 = asStringBool(v17);
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %sBlocksCallsOverCS: %s", (uint8_t *)&v21, 0x16u);
  }
  return v17;
}

uint64_t sub_100968230(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  NetworkListController::getModel_sync(a1, a2, &v8);
  uint64_t v5 = v8;
  if (v8) {
    char v2 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 328))(v8);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model for network needs reselect query", (uint8_t *)&v8, 2u);
    }
    char v2 = 0;
  }
  return v2 & 1;
}

void sub_100968334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100968350(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100968388(uint64_t a1)
{
}

uint64_t sub_1009683A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009683E8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100968418()
{
}

uint64_t sub_10096842C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100968438(void **a1)
{
  id v1 = *a1;
  BOOL v15 = a1;
  BOOL v16 = v1;
  char v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = v2[9];
  uint64_t v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    if (*(void *)buf) {
      dispatch_group_enter(*(dispatch_group_t *)buf);
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  uint64_t v6 = (void *)v2[15];
  if (v6 != v2 + 16)
  {
    do
    {
      uint64_t v7 = v6[5];
      uint64_t v8 = v1[1];
      dispatch_group_t group = v8;
      if (v8)
      {
        dispatch_retain(v8);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v7 + 24))(v7, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      uint64_t v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          uint64_t v6 = v10;
        }
        while (!v11);
      }
      uint64_t v6 = v10;
    }
    while (v10 != v2 + 16);
  }
  uint64_t v12 = v2[11];
  uint64_t v13 = v1[1];
  dispatch_group_t object = v13;
  if (v13)
  {
    dispatch_retain(v13);
    dispatch_group_enter(v13);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v12 + 24))(v12, &object);
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 25));
  sub_100088C88((uint64_t *)&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100968640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t a12, dispatch_group_t a13)
{
}

uint64_t *sub_1009686B4(void **a1)
{
  id v1 = *a1;
  v57 = a1;
  v58 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  int v14 = *(std::__shared_weak_count **)(v2 + 184);
  *(void *)(v2 + 176) = v13;
  *(void *)(v2 + 184) = v12;
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v16 = v1[1];
  uint64_t v15 = v1[2];
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v17 = *(std::__shared_weak_count **)(v2 + 152);
  *(void *)(v2 + 144) = v16;
  *(void *)(v2 + 152) = v15;
  if (v17) {
    sub_10004D2C8(v17);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v18 || (v19 = *(void *)(v2 + 8), (uint64_t v20 = std::__shared_weak_count::lock(v18)) == 0)) {
    sub_100088B9C();
  }
  int v21 = v20;
  uint64_t v22 = (std::__shared_weak_count *)operator new(0x30uLL);
  v22->__shared_owners_ = 0;
  v22->__shared_weak_owners_ = 0;
  v22->__vftable = (std::__shared_weak_count_vtbl *)off_101A1F2C0;
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A1F390;
  v22[1].__shared_owners_ = v19;
  v22[1].__shared_weak_owners_ = (uint64_t)v21;
  atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A1F310;
  uint64_t v23 = *(void *)(v2 + 72);
  uint64_t v24 = v1[3];
  dispatch_group_t group = v24;
  if (v24)
  {
    dispatch_retain(v24);
    dispatch_group_enter(group);
  }
  v63 = v22 + 1;
  uint64_t v64 = v22;
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, dispatch_group_t *, std::__shared_weak_count **))(*(void *)v23 + 16))(v23, &group, &v63);
  if (v64) {
    sub_10004D2C8(v64);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  char v25 = *(void **)(v2 + 120);
  if (v25 != (void *)(v2 + 128))
  {
    do
    {
      uint64_t v26 = v25[5];
      char v27 = *(std::__shared_weak_count **)(v2 + 168);
      uint64_t v61 = *(void *)(v2 + 160);
      uint64_t v62 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v28 = v1[3];
      dispatch_group_t object = v28;
      if (v28)
      {
        dispatch_retain(v28);
        if (object) {
          dispatch_group_enter(object);
        }
      }
      (*(void (**)(uint64_t, uint64_t *, dispatch_group_t *))(*(void *)v26 + 16))(v26, &v61, &object);
      if (object)
      {
        dispatch_group_leave(object);
        if (object) {
          dispatch_release(object);
        }
      }
      if (v62) {
        sub_10004D2C8(v62);
      }
      char v29 = (void *)v25[1];
      if (v29)
      {
        do
        {
          uint64_t v30 = v29;
          char v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v30 = (void *)v25[2];
          BOOL v31 = *v30 == (void)v25;
          char v25 = v30;
        }
        while (!v31);
      }
      char v25 = v30;
    }
    while (v30 != (void *)(v2 + 128));
  }
  uint64_t v32 = *(void *)(v2 + 88);
  uint64_t v33 = v1[3];
  dispatch_group_t v59 = v33;
  if (v33)
  {
    dispatch_retain(v33);
    dispatch_group_enter(v59);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v32 + 16))(v32, &v59);
  if (v59)
  {
    dispatch_group_leave(v59);
    if (v59) {
      dispatch_release(v59);
    }
  }
  sub_100058DB0(__p, "/cc/events/subscriber_sim_file_event");
  uint64_t v34 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v34 = off_101A1F598;
  *((void *)v34 + 1) = v2;
  *((void *)v34 + 2) = sub_100965F88;
  *((void *)v34 + 3) = 0;
  v73 = v34;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  __int16 v35 = (uint8_t *)operator new(0x28uLL);
  *(void *)__int16 v35 = off_101A1F618;
  *((void *)v35 + 1) = v2 + 216;
  *((void *)v35 + 2) = v2;
  *((void *)v35 + 3) = sub_10096604C;
  *((void *)v35 + 4) = 0;
  v73 = v35;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_rat_selection1");
  *(void *)long long buf = off_101A1F698;
  uint64_t v71 = v2 + 240;
  v73 = buf;
  ctu::RestModule::observeProperty();
  uint64_t v36 = (capabilities::ct *)sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsGemini(v36))
  {
    sub_100058DB0(__p, "/cc/props/reg_rat_selection2");
    *(void *)long long buf = off_101A1F718;
    uint64_t v71 = v2 + 243;
    v73 = buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (SHIBYTE(v67) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1002D80F0(v2 + 246);
  sub_100058DB0(__p, "/cc/props/radio_mode");
  __int16 v37 = (uint8_t *)operator new(0x28uLL);
  *(void *)__int16 v37 = off_101A1F798;
  *((void *)v37 + 1) = v2 + 248;
  *((void *)v37 + 2) = v2;
  *((void *)v37 + 3) = sub_100966230;
  *((void *)v37 + 4) = 0;
  v73 = v37;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v38 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v38 = off_101A1F818;
  *((void *)v38 + 1) = v2;
  *((void *)v38 + 2) = sub_100966594;
  *((void *)v38 + 3) = 0;
  v73 = v38;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_1002D795C(v2 + 256);
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  CFBooleanRef v39 = (uint8_t *)operator new(0x28uLL);
  *(void *)CFBooleanRef v39 = off_101A1F898;
  *((void *)v39 + 1) = v2 + 288;
  *((void *)v39 + 2) = v2;
  *((void *)v39 + 3) = sub_100966954;
  *((void *)v39 + 4) = 0;
  v73 = v39;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/device_types");
  __int16 v40 = (uint8_t *)operator new(0x28uLL);
  *(void *)__int16 v40 = off_101A1F918;
  *((void *)v40 + 1) = v2 + 264;
  *((void *)v40 + 2) = v2;
  *((void *)v40 + 3) = sub_100966C00;
  *((void *)v40 + 4) = 0;
  v73 = v40;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/roaming_results");
  uint64_t v41 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v41 = off_101A1F998;
  *((void *)v41 + 1) = v2 + 312;
  *((void *)v41 + 2) = v2;
  *((void *)v41 + 3) = sub_100966E90;
  *((void *)v41 + 4) = 0;
  v73 = v41;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_10012E258(v2 + 336);
  sub_100058DB0(__p, "/cc/props/active_contexts_count");
  uint64_t v42 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v42 = off_101A1FA18;
  *((void *)v42 + 1) = v2 + 360;
  *((void *)v42 + 2) = v2;
  *((void *)v42 + 3) = sub_100967178;
  *((void *)v42 + 4) = 0;
  v73 = v42;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/context_deactivate_rejects_count");
  uint64_t v43 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v43 = off_101A1FA98;
  *((void *)v43 + 1) = v2 + 384;
  *((void *)v43 + 2) = v2;
  *((void *)v43 + 3) = sub_100967294;
  *((void *)v43 + 4) = 0;
  v73 = v43;
  ctu::RestModule::observeProperty();
  uint64_t v44 = (capabilities::ct *)sub_10003F600(buf);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v45 = (capabilities::ct *)capabilities::ct::supportsVoiceCall(v44);
  if (v45)
  {
    sub_10093C120(v2 + 408);
    sub_10093C200(v2 + 432);
  }
  uint64_t v46 = (capabilities::ct *)capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot(v45);
  if (v46)
  {
    sub_100058DB0(__p, "/cc/events/baseband_refresh_start");
    uint64_t v47 = (uint8_t *)operator new(0x20uLL);
    *(void *)uint64_t v47 = off_101A1FB18;
    *((void *)v47 + 1) = v2;
    *((void *)v47 + 2) = sub_1009673B0;
    *((void *)v47 + 3) = 0;
    v73 = v47;
    ctu::RestModule::observeEvent();
    uint64_t v46 = (capabilities::ct *)sub_10003F600(buf);
    if (SHIBYTE(v67) < 0) {
      operator delete(__p[0]);
    }
  }
  char v48 = capabilities::ct::supportsGemini(v46);
  uint64_t v50 = *(void *)(v2 + 8);
  long long v49 = *(std::__shared_weak_count **)(v2 + 16);
  if (v48)
  {
    if (!v49 || (long long v51 = std::__shared_weak_count::lock(v49)) == 0) {
      sub_100088B9C();
    }
    long long v52 = v51;
    atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v51);
    *(void *)long long buf = off_101A1F418;
    uint64_t v71 = v50;
    v72 = v52;
    v73 = buf;
    sub_100364FE4((uint64_t)buf);
    sub_10003B34C(buf);
  }
  else
  {
    if (!v49 || (long long v53 = std::__shared_weak_count::lock(v49)) == 0) {
      sub_100088B9C();
    }
    long long v54 = v53;
    p_shared_weak_owners = &v53->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v53);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v71 = 1174405120;
    v72 = (std::__shared_weak_count *)sub_100969330;
    v73 = (uint8_t *)&unk_101A1F280;
    uint64_t v74 = v2;
    uint64_t v75 = v50;
    v76 = v54;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    __p[0] = _NSConcreteStackBlock;
    __p[1] = (void *)0x40000000;
    uint64_t v67 = sub_100364FD4;
    __int16 v68 = &unk_1019BD420;
    uint64_t v69 = buf;
    sub_10017B514();
    if (v76) {
      std::__shared_weak_count::__release_weak(v76);
    }
    std::__shared_weak_count::__release_weak(v54);
  }
  sub_10004D2C8(v22);
  sub_100256004((uint64_t *)&v58);
  return sub_100046B58((uint64_t *)&v57);
}

void sub_1009691C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    std::__shared_weak_count::__release_weak(a32);
  }
  std::__shared_weak_count::__release_weak(v33);
  sub_10004D2C8(v32);
  sub_100256004(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100969330(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        v11[2] = sub_100969470;
        void v11[3] = &unk_101A1F260;
        v11[4] = v3;
        uint64_t v6 = (std::__shared_weak_count *)v3[2];
        if (!v6 || (uint64_t v7 = v3[1], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v9 = v8;
        unsigned int v10 = v3[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_10096BBA0;
        block[3] = &unk_101A1F3D8;
        block[5] = v7;
        uint64_t v13 = v9;
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v11;
        dispatch_async(v10, block);
        if (v13) {
          sub_10004D2C8(v13);
        }
        sub_10004D2C8(v9);
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_100969470(uint64_t a1)
{
  unsigned int AwdSelectionTypeForSlot_sync = NetworkListController::getAwdSelectionTypeForSlot_sync(*(void ***)(a1 + 32), 1);

  return sNetworkListPostMetric_SelectionChanged(AwdSelectionTypeForSlot_sync);
}

uint64_t sub_1009694A4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009694C0(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009694D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1F2C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009694F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1F2C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100969544(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10096956C(void *a1)
{
  *a1 = off_101A1F390;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1009695B8(void *a1)
{
  *a1 = off_101A1F390;
  id v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100969624(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = "false";
          if (a2) {
            uint64_t v9 = "true";
          }
          int v10 = 136315138;
          BOOL v11 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Command driver state update received with ready %s", (uint8_t *)&v10, 0xCu);
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v7 + 88) + 32))(*(void *)(v7 + 88), 3, 3);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100969770(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100969784(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    int v10 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    NetworkListController::getModel_sync(v9, a2, &v23);
    uint64_t v11 = v23;
    if (v23)
    {
      if (a3)
      {
        if (a3 == 2)
        {
          if (HIDWORD(a3) == 4)
          {
            uint64_t v15 = *v10;
            if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I UIM is still not initialized, not sending processing further", buf, 2u);
            }
          }
          else
          {
            uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 208))(v23);
            uint64_t v17 = v16;
            switch(v16)
            {
              case 0:
                goto LABEL_23;
              case 1:
                uint64_t v20 = *v10;
                if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Current mode is manual, and network selection has failed", buf, 2u);
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)v11 + 88))(v11, 0, 1);
                (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 320))(v11, 1);
                uint64_t v21 = *(void *)(v9 + 104);
                uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 208))(v11);
                (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v21 + 112))(v21, a2, 0, v22);
                (*(void (**)(void, uint64_t))(**(void **)(v9 + 104) + 120))(*(void *)(v9 + 104), a2);
                break;
              case 2:
LABEL_23:
                uint64_t v18 = *v10;
                if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v19 = asString();
                  *(_DWORD *)long long buf = 136315138;
                  uint64_t v26 = v19;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Current mode is %s and received network selection error", buf, 0xCu);
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)v11 + 88))(v11, 0, v17);
                break;
            }
          }
        }
        else if (a3 == 1)
        {
          uint64_t v12 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Received error from driver for network scan command", buf, 2u);
          }
          sub_100965670(v9, &v23);
        }
LABEL_29:
        if (v24) {
          sub_10004D2C8(v24);
        }
        goto LABEL_31;
      }
      uint64_t v13 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_29;
      }
      *(_WORD *)long long buf = 0;
      int v14 = "Unknown command failure";
    }
    else
    {
      uint64_t v13 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_29;
      }
      *(_WORD *)long long buf = 0;
      int v14 = "Could not find model for network response error";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, buf, 2u);
    goto LABEL_29;
  }
LABEL_31:

  sub_10004D2C8(v8);
}

void sub_100969BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100969BE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint64_t v11 = *(NetworkListScanResult **)a3;
    int v10 = *(std::__shared_weak_count **)(a3 + 8);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v94 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
    uint64_t v95 = 0;
    v96 = 0;
    NetworkListController::getModel_sync(v9, a2, &v95);
    if (v95)
    {
      if (v11)
      {
        v90 = v8;
        unsigned int State = NetworkListScanResult::getState(v11);
        uint64_t v13 = *v94;
        if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Network Scan Result received: %s", buf, 0xCu);
        }
        v91 = v11;
        unsigned int v89 = State;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v93 = v9;
        uint64_t v15 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        *(void *)v127 = 0;
        v128 = 0;
        uint64_t v129 = 0;
        NetworkListScanResult::getOperators();
        v111 = 0;
        uint64_t v112 = 0;
        CFArrayRef theArray = (CFArrayRef)&v111;
        uint64_t v17 = *(NetworkListOperator **)v127;
        uint64_t v16 = v128;
        if (*(NetworkListOperator **)v127 == v128)
        {
          CFArrayRef v24 = (CFArrayRef)&v111;
        }
        else
        {
          do
          {
            uint64_t v126 = 0;
            long long v124 = 0u;
            long long v125 = 0u;
            *(_OWORD *)long long buf = 0u;
            long long v123 = 0u;
            NetworkListOperator::getMCC((uint64_t *)__dst, v17);
            NetworkListOperator::getMNC((uint64_t *)&v106, v17);
            int RAT = NetworkListOperator::getRAT(v17);
            MCCAndMNC::MCCAndMNC((MCCAndMNC *)buf, (const MCC *)__dst, (const MNC *)&v106);
            LODWORD(v126) = RAT;
            if (v109 < 0) {
              operator delete(__p);
            }
            if (SHIBYTE(v98) < 0) {
              operator delete(*(void **)&__dst[8]);
            }
            int NetworkNameSource = NetworkListOperator::getNetworkNameSource(v17);
            v106 = 0;
            uint64_t v20 = (uint64_t **)sub_10013E948((uint64_t)&theArray, &v106);
            if (!*v20)
            {
              *(void *)&long long v98 = 0;
              uint64_t v21 = operator new(0x70uLL);
              *(void *)__dst = v21;
              *(void *)&uint8_t __dst[8] = &v111;
              LOBYTE(v98) = 0;
              MCC::MCC((MCC *)(v21 + 8), (const MCC *)buf);
              MCC::MCC((MCC *)(v21 + 16), (const MCC *)&v124);
              v21[24] = v126;
              v21[26] = NetworkNameSource;
              LOBYTE(v98) = 1;
              uint64_t v22 = v106;
              uint64_t v23 = *(uint64_t **)__dst;
              **(void **)__dst = 0;
              v23[1] = 0;
              v23[2] = (uint64_t)v22;
              *uint64_t v20 = v23;
              if (*(void *)theArray)
              {
                CFArrayRef theArray = *(CFArrayRef *)theArray;
                uint64_t v23 = *v20;
              }
              sub_100046C90(v111, v23);
              ++v112;
              *(void *)__dst = 0;
              sub_10008CD68((uint64_t)__dst, 0);
            }
            if (SHIBYTE(v125) < 0) {
              operator delete(*((void **)&v124 + 1));
            }
            if (SHIBYTE(v123) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            uint64_t v17 = (NetworkListOperator *)((char *)v17 + 136);
          }
          while (v17 != v16);
          CFArrayRef v24 = theArray;
        }
        uint64_t v104 = 0;
        v105[0] = 0;
        v105[1] = 0;
        uint64_t v27 = *(void *)(v93 + 144);
        v102 = 0;
        uint64_t v103 = 0;
        v101 = &v102;
        if (v24 != (CFArrayRef)&v111)
        {
          uint64_t v28 = 0;
          char v29 = &v102;
          while (1)
          {
            *(void *)__dst = 0;
            if (v29 == &v102)
            {
              BOOL v31 = &v102;
              if (v28)
              {
LABEL_45:
                *(void *)__dst = v31;
                uint64_t v33 = v31 + 1;
                goto LABEL_47;
              }
            }
            else
            {
              uint64_t v30 = &v102;
              if (v28)
              {
                do
                {
                  BOOL v31 = (uint64_t **)v28;
                  uint64_t v28 = (uint64_t *)v28[1];
                }
                while (v28);
              }
              else
              {
                do
                {
                  BOOL v31 = (uint64_t **)v30[2];
                  BOOL v32 = *v31 == (uint64_t *)v30;
                  uint64_t v30 = v31;
                }
                while (v32);
              }
              if (!MCCAndMNC::operator<())
              {
                uint64_t v33 = (uint64_t **)sub_10013E948((uint64_t)&v101, __dst);
LABEL_47:
                if (*v33) {
                  goto LABEL_51;
                }
                goto LABEL_48;
              }
              if (v102) {
                goto LABEL_45;
              }
            }
            *(void *)__dst = &v102;
            uint64_t v33 = &v102;
LABEL_48:
            memset(buf, 0, sizeof(buf));
            *(void *)&long long v123 = 0;
            sub_10096F658((uint64_t)&v101, (_DWORD *)v24 + 8, buf);
            uint64_t v34 = *(void *)__dst;
            __int16 v35 = *(uint64_t **)buf;
            **(void **)long long buf = 0;
            v35[1] = 0;
            v35[2] = v34;
            std::__shared_weak_count *v33 = v35;
            if (*v101)
            {
              v101 = (uint64_t **)*v101;
              __int16 v35 = *v33;
            }
            sub_100046C90(v102, v35);
            ++v103;
            *(void *)long long buf = 0;
            sub_10008CD68((uint64_t)buf, 0);
LABEL_51:
            uint64_t v36 = (uint64_t *)*((void *)v24 + 1);
            if (v36)
            {
              do
              {
                __int16 v37 = (uint64_t **)v36;
                uint64_t v36 = (uint64_t *)*v36;
              }
              while (v36);
            }
            else
            {
              do
              {
                __int16 v37 = (uint64_t **)*((void *)v24 + 2);
                BOOL v32 = *v37 == (uint64_t *)v24;
                CFArrayRef v24 = (CFArrayRef)v37;
              }
              while (!v32);
            }
            if (v37 == &v111) {
              break;
            }
            char v29 = v101;
            uint64_t v28 = v102;
            CFArrayRef v24 = (CFArrayRef)v37;
          }
        }
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t ***))(*(void *)v27 + 24))(&v104, v27, a2, &v101);
        sub_1000881B0((uint64_t)&v101, v102);
        for (uint64_t i = *(NetworkListOperator **)v127; i != v128; uint64_t i = (NetworkListOperator *)((char *)i + 136))
        {
          uint64_t v126 = 0;
          long long v124 = 0u;
          long long v125 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v123 = 0u;
          NetworkListOperator::getMCC((uint64_t *)__dst, i);
          NetworkListOperator::getMNC((uint64_t *)&v106, i);
          int v39 = NetworkListOperator::getRAT(i);
          MCCAndMNC::MCCAndMNC((MCCAndMNC *)buf, (const MCC *)__dst, (const MNC *)&v106);
          LODWORD(v126) = v39;
          if (v109 < 0) {
            operator delete(__p);
          }
          if (SHIBYTE(v98) < 0) {
            operator delete(*(void **)&__dst[8]);
          }
          __int16 v40 = sub_10013E278((uint64_t)&v104);
          if (v105 == v40)
          {
            uint64_t v45 = *v15;
            if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
            {
              NetworkListOperator::getMCC((uint64_t *)__dst, i);
              int IntValue = MCC::getIntValue((MCC *)__dst);
              NetworkListOperator::getMNC((uint64_t *)&v106, i);
              int IntegerWidth = MNC::getIntegerWidth((MNC *)&v106);
              NetworkListOperator::getMNC((uint64_t *)v120, i);
              int v48 = MCC::getIntValue((MCC *)v120);
              NetworkListOperator::getRAT(i);
              uint64_t v49 = asString();
              *(_DWORD *)v113 = 67109890;
              *(_DWORD *)&v113[4] = IntValue;
              LOWORD(v114) = 1024;
              *(_DWORD *)((char *)&v114 + 2) = IntegerWidth;
              HIWORD(v114) = 1024;
              *(_DWORD *)v115 = v48;
              *(_WORD *)&v115[4] = 2080;
              *(void *)&v115[6] = v49;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Did not find overridden name for %03d-%0.*d (%s)", v113, 0x1Eu);
              if (v121 < 0) {
                operator delete(*(void **)&v120[8]);
              }
              if (v109 < 0) {
                operator delete(__p);
              }
              if (SHIBYTE(v98) < 0) {
                operator delete(*(void **)&__dst[8]);
              }
            }
            goto LABEL_103;
          }
          uint64_t v100 = 0;
          long long v98 = 0u;
          long long v99 = 0u;
          *(_OWORD *)__dst = 0u;
          sub_10013E4D0((char *)__dst, (uint64_t)(v40 + 13));
          if (!(_BYTE)v100)
          {
            uint64_t v50 = *v15;
            if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
            {
              NetworkListOperator::getMCC((uint64_t *)&v106, i);
              int v51 = MCC::getIntValue((MCC *)&v106);
              NetworkListOperator::getMNC((uint64_t *)v120, i);
              int v52 = MNC::getIntegerWidth((MNC *)v120);
              NetworkListOperator::getMNC((uint64_t *)v113, i);
              int v53 = MCC::getIntValue((MCC *)v113);
              NetworkListOperator::getRAT(i);
              uint64_t v54 = asString();
              *(_DWORD *)v117 = 67109890;
              *(_DWORD *)&v117[4] = v51;
              LOWORD(v118) = 1024;
              *(_DWORD *)((char *)&v118 + 2) = v52;
              HIWORD(v118) = 1024;
              LODWORD(v119[0]) = v53;
              WORD2(v119[0]) = 2080;
              *(void *)((char *)v119 + 6) = v54;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Found overridden name for %03d-%0.*d (%s) but it has no value", v117, 0x1Eu);
              if (v116 < 0) {
                operator delete(v114);
              }
              if (v121 < 0) {
                operator delete(*(void **)&v120[8]);
              }
              if (v109 < 0) {
                operator delete(__p);
              }
            }
            goto LABEL_102;
          }
          uint64_t v41 = HIBYTE(v99);
          if (v99 < 0) {
            uint64_t v41 = v99;
          }
          if (v41)
          {
            uint64_t v42 = *v15;
            if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
            {
              NetworkListOperator::getCompositeName((uint64_t *)&v106, i);
              uint64_t v43 = &v106;
              if (v108 < 0) {
                uint64_t v43 = v106;
              }
              if (v99 >= 0) {
                uint64_t v44 = (char *)&v98 + 8;
              }
              else {
                uint64_t v44 = (char *)*((void *)&v98 + 1);
              }
              *(_DWORD *)v120 = 136446466;
              *(void *)&v120[4] = v43;
              *(_WORD *)&v120[12] = 2082;
              *(void *)&v120[14] = v44;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Network name is being overridden with long name from %{public}s to %{public}s", v120, 0x16u);
              if (v108 < 0) {
                operator delete(v106);
              }
            }
          }
          else
          {
            uint64_t v55 = BYTE7(v98);
            if (SBYTE7(v98) < 0) {
              uint64_t v55 = *(void *)&__dst[8];
            }
            if (!v55) {
              goto LABEL_102;
            }
            uint64_t v56 = *v15;
            if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
            {
              NetworkListOperator::getCompositeName((uint64_t *)&v106, i);
              v57 = &v106;
              if (v108 < 0) {
                v57 = v106;
              }
              v58 = __dst;
              if (SBYTE7(v98) < 0) {
                v58 = *(uint8_t **)__dst;
              }
              *(_DWORD *)v120 = 136446466;
              *(void *)&v120[4] = v57;
              *(_WORD *)&v120[12] = 2082;
              *(void *)&v120[14] = v58;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Network name is being overridden with short name from %{public}s to %{public}s", v120, 0x16u);
              if (v108 < 0) {
                operator delete(v106);
              }
            }
          }
          NetworkListOperator::setName();
LABEL_102:
          sub_10013E528((uint64_t)__dst);
LABEL_103:
          if (SHIBYTE(v125) < 0) {
            operator delete(*((void **)&v124 + 1));
          }
          if (SHIBYTE(v123) < 0) {
            operator delete(*(void **)&buf[8]);
          }
        }
        NetworkListScanResult::replaceOperators();
        sub_10013E774((uint64_t)&v104, v105[0]);
        sub_1000881B0((uint64_t)&theArray, v111);
        *(void *)long long buf = v127;
        sub_1004C3EF8((void ***)buf);
        if (v10) {
          sub_10004D2C8(v10);
        }
        CFArrayRef theArray = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v59, *(Registry **)(v93 + 56));
        uint64_t v61 = ServiceMap;
        if (v62 < 0)
        {
          v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v64 = 5381;
          do
          {
            uint64_t v62 = v64;
            unsigned int v65 = *v63++;
            uint64_t v64 = (33 * v64) ^ v65;
          }
          while (v65);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v62;
        __int16 v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
        if (v66)
        {
          uint64_t v68 = v66[3];
          uint64_t v67 = (std::__shared_weak_count *)v66[4];
          if (v67)
          {
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v61);
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v67);
            char v69 = 0;
LABEL_118:
            (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v68 + 80))(__dst, v68, a2, 1, @"RemoveNetworksFromManualScanResult", 0, 0);
            uint64_t v8 = v90;
            sub_100044D6C(&theArray, (CFTypeRef *)__dst);
            uint64_t v71 = v91;
            uint64_t v70 = v93;
            sub_1000577C4((const void **)__dst);
            if ((v69 & 1) == 0) {
              sub_10004D2C8(v67);
            }
            if (theArray) {
              v72 = sub_100083F10;
            }
            else {
              v72 = 0;
            }
            if (v72)
            {
              CFIndex Count = CFArrayGetCount(theArray);
              CFIndex v74 = Count;
              if (Count)
              {
                *(void *)&v120[8] = 0;
                *(void *)&v120[16] = 0;
                *(void *)v120 = &v120[8];
                if (Count >= 1)
                {
                  CFIndex v75 = 0;
                  do
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v75);
                    if (ValueAtIndex)
                    {
                      CFGetTypeID(ValueAtIndex);
                      CFStringGetTypeID();
                    }
                    memset(buf, 0, sizeof(buf));
                    *(void *)&long long v123 = 0;
                    ctu::cf::assign();
                    *(_OWORD *)__dst = *(_OWORD *)buf;
                    *(void *)&long long v98 = v123;
                    sub_1000EA6A0((uint64_t **)v120, (void **)__dst, (uint64_t)__dst);
                    if (SBYTE7(v98) < 0) {
                      operator delete(*(void **)__dst);
                    }
                    ++v75;
                  }
                  while (v74 != v75);
                }
                *(void *)v113 = 0;
                v114 = 0;
                *(void *)v115 = 0;
                NetworkListScanResult::getOperators();
                v77 = (char *)operator new(0x38uLL);
                *((void *)v77 + 1) = 0;
                *((void *)v77 + 2) = 0;
                *(void *)v77 = off_101A1FB98;
                *(_OWORD *)(v77 + 24) = 0u;
                *(_OWORD *)(v77 + 40) = 0u;
                if (v10) {
                  sub_10004D2C8(v10);
                }
                v92 = (std::__shared_weak_count *)v77;
                v78 = (NetworkListScanResult *)(v77 + 24);
                NetworkListScanResult::setState();
                v79 = *(NetworkListOperator **)v113;
                v80 = (NetworkListOperator *)v114;
                if (*(void **)v113 != v114)
                {
                  do
                  {
                    *(void *)v117 = 0;
                    uint64_t v118 = 0;
                    v119[0] = 0;
                    NetworkListOperator::getMCC((uint64_t *)buf, v79);
                    NetworkListOperator::getMNC((uint64_t *)__dst, v79);
                    formPLMN((const MCC *)buf, (const MNC *)__dst);
                    if (SHIBYTE(v98) < 0) {
                      operator delete(*(void **)&__dst[8]);
                    }
                    if (SHIBYTE(v123) < 0) {
                      operator delete(*(void **)&buf[8]);
                    }
                    if (&v120[8] == (unsigned char *)sub_100046F68((uint64_t)v120, (void **)v117))
                    {
                      NetworkListScanResult::addOperator(v78, (const OsLogLogger *)(v93 + 40), v79);
                    }
                    else
                    {
                      v81 = *v94;
                      if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
                      {
                        NetworkListOperator::getMCC((uint64_t *)buf, v79);
                        int v82 = MCC::getIntValue((MCC *)buf);
                        NetworkListOperator::getMNC((uint64_t *)__dst, v79);
                        int v83 = MNC::getIntegerWidth((MNC *)__dst);
                        NetworkListOperator::getMNC((uint64_t *)&v106, v79);
                        int v84 = MCC::getIntValue((MCC *)&v106);
                        *(_DWORD *)v127 = 67109632;
                        *(_DWORD *)&v127[4] = v82;
                        LOWORD(v128) = 1024;
                        *(_DWORD *)((char *)&v128 + 2) = v83;
                        HIWORD(v128) = 1024;
                        LODWORD(v129) = v84;
                        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I Removing operator %03d-%0.*d as it is present in the filter list", v127, 0x14u);
                        if (v109 < 0) {
                          operator delete(__p);
                        }
                        if (SHIBYTE(v98) < 0) {
                          operator delete(*(void **)&__dst[8]);
                        }
                        if (SHIBYTE(v123) < 0) {
                          operator delete(*(void **)&buf[8]);
                        }
                      }
                    }
                    if (SHIBYTE(v119[0]) < 0) {
                      operator delete(*(void **)v117);
                    }
                    v79 = (NetworkListOperator *)((char *)v79 + 136);
                  }
                  while (v79 != v80);
                }
                *(void *)long long buf = v113;
                sub_1004C3EF8((void ***)buf);
                sub_10005CD2C((uint64_t)v120, *(char **)&v120[8]);
                int v10 = v92;
                uint64_t v70 = v93;
                uint64_t v8 = v90;
                uint64_t v71 = v78;
              }
              else
              {
                v86 = *v94;
                if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I Filter PLMNs key value in the carrier bundle is empty", buf, 2u);
                }
                uint64_t v71 = v91;
              }
            }
            else
            {
              v85 = *v94;
              if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I There are no PLMNs mentioned in the bundle to filter", buf, 2u);
              }
            }
            sub_100044D00((const void **)&theArray);
            uint64_t v87 = v95;
            *(void *)long long buf = v71;
            *(void *)&uint8_t buf[8] = v10;
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v87 + 40))(v87, buf);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            switch(v89)
            {
              case 0u:
              case 4u:
                if ((*(unsigned int (**)(uint64_t))(*(void *)v87 + 112))(v87))
                {
                  sub_1009674B4(v70 + 200, a2);
                  goto LABEL_164;
                }
                v88 = *v94;
                if (os_log_type_enabled(*v94, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)__dst = 0;
                  _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#N No operators in scanned result", __dst, 2u);
                }
                goto LABEL_167;
              case 1u:
LABEL_164:
                sub_100963404(v70, a2, v89);
                break;
              case 2u:
              case 3u:
LABEL_167:
                sub_100965670(v70, &v95);
                break;
              default:
                goto LABEL_168;
            }
            goto LABEL_168;
          }
        }
        else
        {
          uint64_t v68 = 0;
        }
        std::mutex::unlock(v61);
        uint64_t v67 = 0;
        char v69 = 1;
        goto LABEL_118;
      }
      char v25 = *v94;
      if (os_log_type_enabled(*v94, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v26 = "Invalid NetworkListScanResult";
        goto LABEL_32;
      }
    }
    else
    {
      char v25 = *v94;
      if (os_log_type_enabled(*v94, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v26 = "Could not get model for scan result";
LABEL_32:
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v26, buf, 2u);
      }
    }
LABEL_168:
    if (v96) {
      sub_10004D2C8(v96);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }

  sub_10004D2C8(v8);
}

void sub_10096ABF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,const void *a40,uint64_t a41,uint64_t a42,char a43)
{
  *(void *)(v44 - 208) = &a43;
  sub_1004C3EF8((void ***)(v44 - 208));
  sub_10005CD2C(v44 - 240, *(char **)(v44 - 232));
  sub_100044D00(&a40);
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  sub_10004D2C8(a11);
  _Unwind_Resume(a1);
}

void sub_10096AF9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v11 = *(NetworkListSelectionResult **)a3;
        int v10 = *(std::__shared_weak_count **)(a3 + 8);
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        uint64_t v13 = v12;
        if (v11)
        {
          uint64_t v28 = 0;
          char v29 = 0;
          NetworkListController::getModel_sync(v9, a2, &v28);
          uint64_t v14 = v28;
          if (v28)
          {
            int Result = NetworkListSelectionResult::getResult(v11);
            uint64_t v16 = *v13;
            BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
            if (Result)
            {
              if (v17)
              {
                NetworkListSelectionResult::getMode(v11);
                uint64_t v18 = asString();
                uint64_t ResultAsString = NetworkListSelectionResult::getResultAsString(v11);
                *(_DWORD *)long long buf = 136315394;
                uint64_t v31 = v18;
                __int16 v32 = 2080;
                uint64_t v33 = ResultAsString;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Network %s Selection failed: %s", buf, 0x16u);
              }
              uint64_t v20 = 3;
            }
            else if (v17)
            {
              *(_WORD *)long long buf = 0;
              uint64_t v20 = 2;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Network Selection Result received, selection has successfully completed", buf, 2u);
            }
            else
            {
              uint64_t v20 = 2;
            }
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v9 + 88) + 32))(*(void *)(v9 + 88), a2, v20);
            int v24 = NetworkListSelectionResult::getResult(v11);
            uint64_t Mode = NetworkListSelectionResult::getMode(v11);
            (*(void (**)(uint64_t, BOOL, uint64_t))(*(void *)v14 + 88))(v14, v24 == 0, Mode);
            (*(void (**)(uint64_t, void))(*(void *)v14 + 320))(v14, 0);
            uint64_t v26 = *(void *)(v9 + 104);
            uint64_t v27 = NetworkListSelectionResult::getMode(v11);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v26 + 112))(v26, a2, 1, v27);
          }
          else
          {
            uint64_t v22 = *v13;
            if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
            {
              NetworkListSelectionResult::getMode(v11);
              uint64_t v23 = asString();
              *(_DWORD *)long long buf = 136315138;
              uint64_t v31 = v23;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find model for %s selection result", buf, 0xCu);
            }
          }
          if (v29) {
            sub_10004D2C8(v29);
          }
        }
        else
        {
          uint64_t v21 = *v12;
          if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Invalid network selection result", buf, 2u);
          }
        }
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10096B330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10096B36C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      int v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        sub_10005EA44((MCC *)v29, a3);
        sub_10005EA44((MCC *)v28, a4);
        uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 48) + 16))(*(void *)(v11 + 48), a2);
        uint64_t v42 = 0;
        uint64_t v43 = 0;
        NetworkListController::getModel_sync(v11, a2, &v42);
        if (v42)
        {
          (*(void (**)(uint64_t))(*(void *)v42 + 128))(v42);
          int v13 = v29[64];
          int v14 = v28[64];
          uint64_t v15 = *v12;
          BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
          if (v13 && v14)
          {
            if (v16)
            {
              MCCAndMNC::getMcc(v32, (MCCAndMNC *)v28);
              int IntValue = MCC::getIntValue((MCC *)v32);
              MCCAndMNC::getMnc(v30, (MCCAndMNC *)v28);
              int IntegerWidth = MNC::getIntegerWidth((MNC *)v30);
              MCCAndMNC::getMnc(v40, (MCCAndMNC *)v28);
              int v19 = MCC::getIntValue((MCC *)v40);
              MCCAndMNC::getMcc(v38, (MCCAndMNC *)v29);
              int v20 = MCC::getIntValue((MCC *)v38);
              MCCAndMNC::getMnc(v36, (MCCAndMNC *)v29);
              int v21 = MNC::getIntegerWidth((MNC *)v36);
              MCCAndMNC::getMnc(v34, (MCCAndMNC *)v29);
              int v22 = MCC::getIntValue((MCC *)v34);
              *(_DWORD *)long long buf = 67110400;
              *(_DWORD *)&uint8_t buf[4] = IntValue;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = IntegerWidth;
              *(_WORD *)&buf[14] = 1024;
              int v45 = v19;
              __int16 v46 = 1024;
              int v47 = v20;
              __int16 v48 = 1024;
              int v49 = v21;
              __int16 v50 = 1024;
              int v51 = v22;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Baseband has selected a different PLMN %03d-%0.*d than the one selected by user %03d-%0.*d", buf, 0x26u);
              if (v35 < 0) {
                operator delete((void *)v34[1]);
              }
              if (v37 < 0) {
                operator delete((void *)v36[1]);
              }
              if (v39 < 0) {
                operator delete((void *)v38[1]);
              }
              if (v41 < 0) {
                operator delete((void *)v40[1]);
              }
              if (v31 < 0) {
                operator delete((void *)v30[1]);
              }
              if (v33 < 0) {
                operator delete((void *)v32[1]);
              }
            }
          }
          else if (v16)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Baseband has selected a different PLMN than the one selected by user", buf, 2u);
          }
          sub_10005EA44((MCC *)v32, (uint64_t)v29);
          sub_10005EA44((MCC *)v30, (uint64_t)v28);
          int v24 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
          dispatch_queue_create("com.apple.commcenter.show_network_select", v24);
          *(_DWORD *)long long buf = a2;
          *(void *)&uint8_t buf[8] = (*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 48) + 16))(*(void *)(v11 + 48), a2);
          sub_10005EA44((MCC *)&v45, (uint64_t)v32);
          sub_10005EA44((MCC *)&v52, (uint64_t)v30);
          char v25 = *(std::__shared_weak_count **)(v11 + 16);
          if (v25)
          {
            uint64_t v26 = *(std::__shared_weak_count **)(v11 + 8);
            uint64_t v27 = std::__shared_weak_count::lock(v25);
            if (v27)
            {
              v53[0] = v26;
              v53[1] = v27;
              atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v27);
              uint64_t v54 = v11;
              operator new();
            }
          }
          sub_100088B9C();
        }
        uint64_t v23 = *v12;
        if (os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find model for manual selection update", buf, 2u);
        }
        if (v43) {
          sub_10004D2C8(v43);
        }
        sub_100021FF4((uint64_t)v28);
        sub_100021FF4((uint64_t)v29);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10096B860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,void *a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a57 < 0) {
    operator delete(__p);
  }
  if (a64 < 0) {
    operator delete(a59);
  }
  if (a71 < 0) {
    operator delete(a66);
  }
  if (a73 < 0) {
    operator delete(a72);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a74) {
    sub_10004D2C8((std::__shared_weak_count *)a74);
  }
  sub_100021FF4((uint64_t)&a9);
  sub_100021FF4((uint64_t)&a18);
  sub_10004D2C8(v74);
  _Unwind_Resume(a1);
}

void sub_10096B9C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    if (a3 != 1)
    {
      if (a3 == 3)
      {
        int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v11 = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I GW SIM is ready, and there is no PLMN Mode Bit file in the card, assuming that SIM supports Network Selection", v11, 2u);
        }
        a3 = 1;
      }
      else if (a3 != 2)
      {
        goto LABEL_13;
      }
    }
    sub_100964238(v9, a2, a3);
  }
LABEL_13:

  sub_10004D2C8(v8);
}

void sub_10096BAD4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_10096BAE8(void *a1)
{
  *a1 = off_101A1F390;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10096BB34(void *a1)
{
  *a1 = off_101A1F390;
  id v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

uint64_t sub_10096BBA0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10096BBB0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10096BBCC(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_10096BBDC(void *a1)
{
  *a1 = off_101A1F418;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10096BC28(void *a1)
{
  *a1 = off_101A1F418;
  id v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10096BC94(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A1F418;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10096BCF0(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A1F418;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10096BD28(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10096BD38(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10096BD78(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10096BE90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096BED0()
{
}

uint64_t *sub_10096BEDC(uint64_t **a1)
{
  id v1 = *a1;
  uint64_t v4 = a1;
  v5[0] = (uint64_t)v1;
  uint64_t v2 = *v1;
  v5[1] = (uint64_t)_NSConcreteStackBlock;
  v5[2] = 0x40000000;
  v5[3] = (uint64_t)sub_10059E5E4;
  v5[4] = (uint64_t)&unk_1019E9948;
  v5[5] = v2;
  sub_10059E404((wis::MetricFactory *)0x80120);
  sub_1000E3958(v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10096BF74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1000E3958((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10096BF90(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v2 + 72) + 24))(*(void *)(v2 + 72));
  Registry::createRestModuleOneTimeUseConnection(&v20, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v21) {
    sub_10004D2C8(v21);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_13:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13)
  {
LABEL_14:
    uint64_t v22 = 0x160000001BLL;
    sub_100602B08((uint64_t)buf, (int *)&v22, 2);
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 160))(v13, buf);
    sub_1000346F8((uint64_t)buf, v19);
  }
LABEL_15:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_100088C88(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_10096C198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *a14)
{
  sub_1000346F8((uint64_t)&a13, a14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_10096C1FC(void *a1)
{
  *a1 = off_101A1F498;
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_10096C260(void *a1)
{
  *a1 = off_101A1F498;
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_10096C2E4(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_101A1F498;
  sub_10096C5D4((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10096C338(uint64_t a1, void *a2)
{
  *a2 = off_101A1F498;
  return sub_10096C5D4((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

void sub_10096C364(uint64_t a1)
{
}

void sub_10096C36C(void *a1)
{
  sub_10096C640(a1 + 1);

  operator delete(a1);
}

void sub_10096C3A8(void *a1)
{
  uint64_t v1 = a1[1];
  uint64_t v2 = a1[5];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a1[8];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a1[11];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10096C588(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096C5C8()
{
}

uint64_t sub_10096C5D4(uint64_t result, long long *a2)
{
  long long v2 = *a2;
  *(_DWORD *)(result + 15) = *(_DWORD *)((char *)a2 + 15);
  *(_OWORD *)uint64_t result = v2;
  uint64_t v3 = *((void *)a2 + 4);
  *(void *)(result + 24) = *((void *)a2 + 3);
  *(void *)(result + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 40) = *(long long *)((char *)a2 + 40);
  uint64_t v4 = *((void *)a2 + 7);
  *(void *)(result + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 64) = a2[4];
  uint64_t v5 = *((void *)a2 + 10);
  *(void *)(result + 80) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10096C640(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

uint64_t *sub_10096C69C(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(_DWORD *)(v1 + 8) == 3)
  {
    uint64_t v3 = **(NSObject ***)(v1 + 16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 3G has been disabled, removing UMTS technologies before issuing network scan", buf, 2u);
    }
    *(unsigned char *)(v1 + 24) &= 0xDDu;
  }
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(v1 + 32) + 312))(*(void *)(v1 + 32));
  uint64_t v5 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (sub_1009680A4(v2, v4, 1)) {
    goto LABEL_19;
  }
  uint64_t v6 = *(void *)(v2 + 320);
  if (!v6) {
    goto LABEL_16;
  }
  uint64_t v7 = v2 + 320;
  do
  {
    int v8 = *(_DWORD *)(v6 + 28);
    BOOL v9 = v8 < (int)v4;
    if (v8 >= (int)v4) {
      unsigned int v10 = (uint64_t *)v6;
    }
    else {
      unsigned int v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 != v2 + 320 && *(_DWORD *)(v7 + 28) <= (int)v4)
  {
    if (*(_DWORD *)(v7 + 32) != 5) {
      goto LABEL_24;
    }
  }
  else
  {
LABEL_16:
    uint64_t v11 = *v5;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not find RoamingResult", buf, 2u);
    }
  }
  if (sub_1009680A4(v2, v4, 0))
  {
LABEL_19:
    uint64_t v12 = **(NSObject ***)(v1 + 16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Current carrier or operator blocks calls over CS, adding LTE technologies to network scan", buf, 2u);
    }
    int v13 = *(unsigned __int8 *)(v1 + 24);
    *(unsigned char *)(v1 + 24) = v13 | 0x10;
    sub_100965930((uint64_t *)(v1 + 48), v13 | 0x10u);
    goto LABEL_22;
  }
LABEL_24:
  uint64_t v15 = *(void *)(v1 + 80);
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v1 + 32) + 312))(*(void *)(v1 + 32));
  uint64_t v17 = *(void *)(v1 + 16);
  __int16 v24 = *(_WORD *)(v1 + 24);
  char v25 = *(unsigned char *)(v1 + 26);
  long long v21 = *(_OWORD *)(v1 + 48);
  uint64_t v18 = *(std::__shared_weak_count **)(v1 + 64);
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = *(void *)(v1 + 72);
  uint64_t v27 = 0;
  uint64_t v20 = operator new(0x40uLL);
  *uint64_t v20 = off_101A1F508;
  v20[1] = v2;
  v20[2] = v17;
  *((_WORD *)v20 + 12) = v24;
  *((unsigned char *)v20 + 26) = v25;
  *((_OWORD *)v20 + 2) = v21;
  v20[6] = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v20[7] = v19;
  uint64_t v27 = v20;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v15 + 64))(v15, v16, buf);
  sub_1004CACEC(buf);
  if (v18) {
    sub_10004D2C8(v18);
  }
LABEL_22:
  sub_10096CA30(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_10096C9F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  sub_1004CACEC((uint64_t *)va2);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10096CA30((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10096CA30(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[11];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[8];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[5];
    if (v4) {
      sub_10004D2C8(v4);
    }
    operator delete();
  }
  return result;
}

void *sub_10096CA9C(void *a1)
{
  *a1 = off_101A1F508;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10096CAE8(void *a1)
{
  *a1 = off_101A1F508;
  uint64_t v1 = (std::__shared_weak_count *)a1[6];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10096CB54(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x40uLL);
  *(void *)uint64_t result = off_101A1F508;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_DWORD *)(result + 23) = *(_DWORD *)(a1 + 23);
  *((_OWORD *)result + 2) = *(_OWORD *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  *((void *)result + 6) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)result + 7) = *(void *)(a1 + 56);
  return result;
}

uint64_t sub_10096CBD0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1F508;
  long long v2 = *(_OWORD *)(result + 8);
  *(_DWORD *)(a2 + 23) = *(_DWORD *)(result + 23);
  *(_OWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(result + 32);
  uint64_t v3 = *(void *)(result + 48);
  *(void *)(a2 + 48) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a2 + 56) = *(void *)(result + 56);
  return result;
}

void sub_10096CC28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10096CC38(void *__p)
{
  long long v2 = (std::__shared_weak_count *)__p[6];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10096CC78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(void *)(v1 + 16))
  {
    if (std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v1 + 16))) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10096CDE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096CE20()
{
}

uint64_t *sub_10096CE2C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  if (*(_DWORD *)v1 == 3)
  {
    uint64_t v2 = **(NSObject ***)(v1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I LTE has been disabled, removing LTE technologies before issuing network scan", buf, 2u);
    }
    unsigned __int8 v3 = *(unsigned char *)(v1 + 16) & 0xEF;
    *(unsigned char *)(v1 + 16) = v3;
  }
  else
  {
    unsigned __int8 v3 = *(unsigned char *)(v1 + 16);
  }
  sub_100965930((uint64_t *)(v1 + 24), v3);
  sub_10096CEF0(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10096CED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10096CEF0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_10096CF48()
{
}

__n128 sub_10096CF5C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A1F598;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10096CFB0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F598;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10096CFE8(void *a1)
{
  uint64_t v5 = 0x2800000000;
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_10096D080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10096D09C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D0DC()
{
}

void sub_10096D0EC()
{
}

__n128 sub_10096D100(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1F618;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096D154(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F618;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096D18C(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10096D208(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D248()
{
}

void sub_10096D258()
{
}

void *sub_10096D26C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A1F698;
  result[1] = v3;
  return result;
}

uint64_t sub_10096D2B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1F698;
  a2[1] = v2;
  return result;
}

uint64_t sub_10096D2E0()
{
  return read_rest_value();
}

uint64_t sub_10096D2E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D328()
{
}

void sub_10096D338()
{
}

void *sub_10096D34C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A1F718;
  result[1] = v3;
  return result;
}

uint64_t sub_10096D394(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1F718;
  a2[1] = v2;
  return result;
}

uint64_t sub_10096D3C0()
{
  return read_rest_value();
}

uint64_t sub_10096D3C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D408()
{
}

void sub_10096D418()
{
}

__n128 sub_10096D42C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1F798;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096D480(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F798;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096D4B8(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_10096D534(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D574()
{
}

void sub_10096D584()
{
}

__n128 sub_10096D598(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A1F818;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10096D5EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F818;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096D624(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10096D66C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D6AC()
{
}

void sub_10096D6BC()
{
}

__n128 sub_10096D6D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1F898;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096D724(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10096D75C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_10096D81C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10096D834(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096D874()
{
}

void sub_10096D884()
{
}

__n128 sub_10096D898(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1F918;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096D8EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F918;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10096D924(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10096D9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10096D9FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096DA3C()
{
}

void sub_10096DA4C()
{
}

__n128 sub_10096DA60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1F998;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096DAB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1F998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10096DAEC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10096DBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10096DBC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096DC04()
{
}

void sub_10096DC14()
{
}

__n128 sub_10096DC28(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1FA18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096DC7C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1FA18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096DCB4(uint64_t *a1, xpc_object_t *a2)
{
  sub_10096DD7C(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10096DD30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096DD70()
{
}

void sub_10096DD7C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    v7[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      v7[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, v7, count);
    xpc_release(v7[0]);
    for (uint64_t i = v11; i != object[1] || v10 != object[0]; uint64_t i = ++v11)
    {
      v7[1] = i;
      xpc_object_t v8 = 0;
      v7[0] = &v10;
      sub_10003FBDC((uint64_t)v7, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v6 = v8;
        v7[0] = 0;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10096DFF8((int *)v7, &v6);
        xpc_release(v6);
        sub_10002713C((uint64_t **)a1, (int *)v7, (uint64_t *)v7);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_10096DF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_10096DFF8(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v10 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v10 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = &v10;
    xpc_object_t v8 = "first";
    sub_100048BAC((uint64_t)&v7, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v11 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v11, (int *)&object, v5);
      *a1 = v11;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    uint64_t v7 = &v10;
    xpc_object_t v8 = "second";
    sub_100048BAC((uint64_t)&v7, &object);
    a1[1] = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
    xpc_release(object);
    xpc_object_t v3 = v10;
  }
  xpc_release(v3);
}

void sub_10096E15C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_10096E1B4()
{
}

__n128 sub_10096E1C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A1FA98;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10096E21C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1FA98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096E254(uint64_t *a1, xpc_object_t *a2)
{
  sub_10096DD7C(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10096E2D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096E310()
{
}

void sub_10096E320()
{
}

__n128 sub_10096E334(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A1FB18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10096E388(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1FB18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10096E3C0(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  BOOL v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  int v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    BOOL v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_10096E4A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10096E4E4()
{
}

void sub_10096E4F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1FB98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10096E510(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1FB98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10096E564(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_1004C3EF8(&v1);
}

uint64_t *sub_10096E594(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 168);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    sub_100021FF4(v1 + 88);
    sub_100021FF4(v1 + 16);
    operator delete();
  }
  return result;
}

uint64_t *sub_10096E5F8(unsigned int *a1)
{
  __int16 v46 = a1;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 21);
  if (v2)
  {
    uint64_t v3 = *((void *)a1 + 22);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!*((void *)a1 + 20))
      {
LABEL_100:
        sub_10004D2C8(v5);
        return sub_10096E594((uint64_t *)&v46);
      }
      uint64_t v58 = 0;
      dispatch_group_t v59 = 0;
      NetworkListController::getModel_sync(v3, *a1, &v58);
      CFStringRef v56 = 0;
      CFStringRef theString = 0;
      v52[0] = v3;
      v52[1] = v58;
      uint64_t v55 = 0;
      int v53 = v59;
      if (v59) {
        atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v54 = *((void *)a1 + 1);
      LODWORD(v55) = *a1;
      memset(&v51, 0, sizeof(v51));
      if (!*((unsigned char *)a1 + 80)) {
        sub_10016C840();
      }
      sub_10096F1C0(&v51, v52, (MCCAndMNC *)(a1 + 4));
      unsigned int v6 = **((void **)a1 + 1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = &v51;
        if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v7 = (std::string *)v51.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I User selected PLMN's network name %{public}s", (uint8_t *)&buf, 0xCu);
      }
      if (!*((unsigned char *)a1 + 152))
      {
        CFStringRef v60 = 0;
        (*(void (**)(const __CFString **__return_ptr))(**(void **)(v3 + 176) + 16))(&v60);
        CFStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v60);
        CFStringRef v27 = theString;
        CFStringRef theString = MutableCopy;
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
        sub_10028D988((const void **)&buf.__r_.__value_.__l.__data_);
        uint64_t v28 = (__CFString *)theString;
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, v51.__r_.__value_.__l.__data_, v51.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v51;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __p;
        }
        CFStringRef v62 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = __dst;
        }
        CFStringRef v63 = 0;
        if (ctu::cf::convert_copy())
        {
          CFStringRef v36 = v62;
          CFStringRef v62 = v63;
          v47.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
          sub_1000558F4((const void **)&v47.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        CFStringRef v49 = v62;
        CFStringRef v62 = 0;
        sub_1000558F4((const void **)&v62);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        CFStringRef v37 = v49;
        v65.length = CFStringGetLength(theString);
        v65.location = 0;
        CFStringFindAndReplace(v28, @"%@", v37, v65, 0);
        sub_1000558F4((const void **)&v49);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 176) + 16))(&__dst);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
        CFStringRef v56 = (const __CFString *)__dst.__r_.__value_.__r.__words[0];
        __dst.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&v60);
        goto LABEL_93;
      }
      memset(&__p, 0, sizeof(__p));
      sub_10096F1C0(&__p, v52, (MCCAndMNC *)(a1 + 22));
      uint64_t v8 = **((void **)a1 + 1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Baseband selected PLMN's network name %{public}s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v11 = *(void *)(v3 + 272);
      if (v11)
      {
        int v12 = *a1;
        uint64_t v9 = v3 + 272;
        do
        {
          int v13 = *(_DWORD *)(v11 + 28);
          BOOL v14 = v13 < v12;
          if (v13 >= v12) {
            uint64_t v15 = (uint64_t *)v11;
          }
          else {
            uint64_t v15 = (uint64_t *)(v11 + 8);
          }
          if (!v14) {
            uint64_t v9 = v11;
          }
          uint64_t v11 = *v15;
        }
        while (*v15);
        if (v9 != v3 + 272 && v12 >= *(_DWORD *)(v9 + 28))
        {
          uint64_t v9 = *(unsigned int *)(v9 + 32);
          if (v9 >= 3)
          {
            if (v9 == 3)
            {
              int v45 = **((void **)a1 + 1);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I CDMA based, marking menu as not available", (uint8_t *)&buf, 2u);
              }
              goto LABEL_47;
            }
LABEL_70:
            CFStringRef v49 = 0;
            (*(void (**)(CFStringRef *__return_ptr))(**(void **)(v3 + 176) + 16))(&v49);
            CFStringRef v38 = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v49);
            CFStringRef v39 = theString;
            CFStringRef theString = v38;
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
            sub_10028D988((const void **)&buf.__r_.__value_.__l.__data_);
            __int16 v40 = (__CFString *)theString;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v47, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            }
            else {
              std::string v47 = __p;
            }
            if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__dst, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
            }
            else {
              std::string __dst = v47;
            }
            CFStringRef v60 = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string buf = __dst;
            }
            CFStringRef v62 = 0;
            if (ctu::cf::convert_copy())
            {
              CFStringRef v41 = v60;
              CFStringRef v60 = v62;
              CFStringRef v63 = v41;
              sub_1000558F4((const void **)&v63);
            }
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            CFStringRef v48 = v60;
            CFStringRef v60 = 0;
            sub_1000558F4((const void **)&v60);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            CFStringRef v42 = v48;
            v66.length = CFStringGetLength(theString);
            v66.location = 0;
            CFStringFindAndReplace(v40, @"%@", v42, v66, 0);
            sub_1000558F4((const void **)&v48);
            if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v47.__r_.__value_.__l.__data_);
            }
            (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 176) + 16))(&__dst);
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
            CFStringRef v56 = (const __CFString *)__dst.__r_.__value_.__r.__words[0];
            __dst.__r_.__value_.__r.__words[0] = 0;
            sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&v49);
            char v34 = 0;
LABEL_88:
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__p.__r_.__value_.__l.__data_);
              if (v34)
              {
LABEL_90:
                uint64_t v43 = **((void **)a1 + 1);
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Not showing an alert as menu will be taken away", (uint8_t *)&buf, 2u);
                }
                goto LABEL_94;
              }
            }
            else if (v34)
            {
              goto LABEL_90;
            }
LABEL_93:
            buf.__r_.__value_.__r.__words[0] = 0;
            (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 176) + 16))(&buf);
            __dst.__r_.__value_.__r.__words[0] = 0;
            (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 176) + 16))(&__dst);
            sub_1001D3C48(v3 + 56, theString, v56, (CFStringRef)buf.__r_.__value_.__l.__data_, (CFStringRef)__dst.__r_.__value_.__l.__data_, (uint64_t)"prefs:root=Carrier", 0);
            sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
LABEL_94:
            if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v51.__r_.__value_.__l.__data_);
            }
            if (v53) {
              sub_10004D2C8(v53);
            }
            sub_1000558F4((const void **)&v56);
            sub_10028D988((const void **)&theString);
            if (v59) {
              sub_10004D2C8(v59);
            }
            goto LABEL_100;
          }
        }
      }
      __dst.__r_.__value_.__r.__words[0] = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v9, *(Registry **)(v3 + 56));
      uint64_t v17 = ServiceMap;
      if ((v18 & 0x8000000000000000) != 0)
      {
        uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v20 = 5381;
        do
        {
          std::string::size_type v18 = v20;
          unsigned int v21 = *v19++;
          uint64_t v20 = (33 * v20) ^ v21;
        }
        while (v21);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v18;
      uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&buf);
      if (v22)
      {
        uint64_t v24 = v22[3];
        uint64_t v23 = (std::__shared_weak_count *)v22[4];
        if (v23)
        {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v17);
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          char v25 = 0;
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v24 = 0;
      }
      std::mutex::unlock(v17);
      uint64_t v23 = 0;
      char v25 = 1;
LABEL_37:
      (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v24 + 80))(&v47, v24, *a1, 1, @"DisallowCarrierMenuAtHome", 0, 0);
      sub_1000057AC(&__dst, (CFTypeRef *)&v47.__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&v47.__r_.__value_.__l.__data_);
      if ((v25 & 1) == 0) {
        sub_10004D2C8(v23);
      }
      if (__dst.__r_.__value_.__r.__words[0]) {
        uint64_t v30 = sub_100084B4C;
      }
      else {
        uint64_t v30 = 0;
      }
      if (v30)
      {
        buf.__r_.__value_.__s.__data_[0] = 0;
        ctu::cf::assign((ctu::cf *)&buf, (BOOL *)__dst.__r_.__value_.__l.__data_, v29);
        int v31 = buf.__r_.__value_.__s.__data_[0];
        __int16 v32 = **((void **)a1 + 1);
        BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
        if (v31)
        {
          if (v33)
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Disallow carrier menu is set to true, menu not available", (uint8_t *)&buf, 2u);
          }
          sub_100062778((const void **)&__dst.__r_.__value_.__l.__data_);
LABEL_47:
          char v34 = 1;
          goto LABEL_88;
        }
        if (!v33) {
          goto LABEL_69;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        char v35 = "#I No disallow carrier menu is set to false";
      }
      else
      {
        __int16 v32 = **((void **)a1 + 1);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
LABEL_69:
          sub_100062778((const void **)&__dst.__r_.__value_.__l.__data_);
          goto LABEL_70;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        char v35 = "#I No disallow carrier menu at home key in the bundle";
      }
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v35, (uint8_t *)&buf, 2u);
      goto LABEL_69;
    }
  }
  return sub_10096E594((uint64_t *)&v46);
}

void sub_10096EFF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37,uint64_t a38,uint64_t a39,const void *a40,const void *a41,uint64_t a42,std::__shared_weak_count *a43)
{
  sub_1000558F4((const void **)(v44 - 128));
  if (*(char *)(v44 - 137) < 0) {
    operator delete(*(void **)(v44 - 160));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)(v44 - 168));
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a37) {
    sub_10004D2C8(a37);
  }
  sub_1000558F4(&a40);
  sub_10028D988(&a41);
  if (a43) {
    sub_10004D2C8(a43);
  }
  sub_10004D2C8(v43);
  sub_10096E594(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10096F1C0(std::string *a1, uint64_t *a2, MCCAndMNC *this)
{
  uint64_t v6 = *a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  MCCAndMNC::getMcc((uint64_t *)&v32, this);
  MCCAndMNC::getMnc((uint64_t *)&buf, this);
  formPLMN((const MCC *)&v32, (const MNC *)&buf);
  if (SHIBYTE(v42) < 0) {
    operator delete(*((void **)&buf + 1));
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(*((void **)&v32 + 1));
  }
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  uint64_t v7 = a2[1];
  if (v7 && ((*(void (**)(long long *__return_ptr))(*(void *)v7 + 152))(&v32), BYTE8(v40)))
  {
    int RAT = NetworkListOperator::getRAT((NetworkListOperator *)&v32);
    int v9 = RAT;
    if (RAT == 11 || RAT == -1)
    {
      uint64_t v10 = *(NSObject **)a2[3];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v11 = a1;
        }
        else {
          uint64_t v11 = (std::string *)a1->__r_.__value_.__r.__words[0];
        }
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E Invalid RAT for network operator %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long buf = 0u;
  long long v42 = 0u;
  MCCAndMNC::getMcc((uint64_t *)&__str, this);
  MCCAndMNC::getMnc((uint64_t *)&v29, this);
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)&buf, (const MCC *)&__str, (const MNC *)&v29);
  LODWORD(v45) = v9;
  if (v31 < 0) {
    operator delete(*((void **)&v29 + 1));
  }
  if (SHIBYTE(__str_16) < 0) {
    operator delete(*((void **)&__str + 1));
  }
  uint64_t v28 = 0;
  long long __str_16 = 0u;
  long long v27 = 0u;
  long long __str = 0u;
  uint64_t v12 = *(void *)(v6 + 144);
  uint64_t v13 = *((unsigned int *)a2 + 8);
  MCC::MCC((MCC *)v18, (const MCC *)&buf);
  MCC::MCC((MCC *)&v21, (const MCC *)&v43);
  int v24 = v45;
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)v12 + 16))(&__str, v12, v13, v18, 5);
  if (v23 < 0) {
    operator delete(v22);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  if ((_BYTE)v28)
  {
    uint64_t v14 = HIBYTE(v27);
    if (v27 < 0) {
      uint64_t v14 = v27;
    }
    if (v14)
    {
      p_str = (const std::string *)((char *)&__str_16 + 8);
LABEL_36:
      std::string::operator=(a1, p_str);
      goto LABEL_37;
    }
    uint64_t v16 = BYTE7(__str_16);
    if (SBYTE7(__str_16) < 0) {
      uint64_t v16 = *((void *)&__str + 1);
    }
    if (v16)
    {
      p_str = (const std::string *)&__str;
      goto LABEL_36;
    }
  }
  else if (BYTE8(v40))
  {
    NetworkListOperator::getCompositeName((uint64_t *)&v29, (NetworkListOperator *)&v32);
    if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(a1->__r_.__value_.__l.__data_);
    }
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v29;
    a1->__r_.__value_.__r.__words[2] = v30;
  }
LABEL_37:
  sub_10013E528((uint64_t)&__str);
  if (SHIBYTE(v44) < 0) {
    operator delete(*((void **)&v43 + 1));
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(*((void **)&buf + 1));
  }
  return sub_10096F5EC((uint64_t)&v32);
}

void sub_10096F50C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_10013E528((uint64_t)&a22);
  sub_10013C44C(v47 - 144);
  sub_10096F5EC((uint64_t)&a40);
  if (*(char *)(v46 + 23) < 0) {
    operator delete(*(void **)v46);
  }
  _Unwind_Resume(a1);
}

void sub_10096F5E4()
{
}

uint64_t sub_10096F5EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    if (*(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

MCC *sub_10096F658@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0x70uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_10096F6CC((MCC *)(v6 + 32), a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10096F6B4(_Unwind_Exception *a1)
{
  sub_10008CD68(v1, 0);
  _Unwind_Resume(a1);
}

MCC *sub_10096F6CC(MCC *a1, _DWORD *a2)
{
  MCC::MCC(a1, (const MCC *)a2);
  MCC::MCC((MCC *)(v4 + 32), (const MCC *)(a2 + 8));
  *((_DWORD *)a1 + 16) = a2[16];
  *((_DWORD *)a1 + 18) = a2[18];
  return a1;
}

void sub_10096F714(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void sub_10096F730(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Bringing baseband online", buf, 2u);
  }
  sub_100058DB0(buf, "/cc/events/bring_baseband_online");
  xpc_object_t object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(*(void **)buf);
  }
  operator delete();
}

void sub_10096F804(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sd::IMSSubscriberEventHandler::create()
{
}

void sub_10096F970(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_10096F9DC(uint64_t a1)
{
  *(void *)a1 = off_101A1FC08;
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 40);
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Destroying EventHandler...", v14, 2u);
  }
  sub_100060644((void *)(a1 + 3648));
  char v4 = *(std::__shared_weak_count **)(a1 + 3640);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 3624);
  *(void *)(a1 + 3624) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 3616), 0);
  uint64_t v6 = *(NSObject **)(a1 + 3608);
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 3600);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_1007322F4(a1 + 3568, *(void **)(a1 + 3576));
  sub_10005CD2C(a1 + 3544, *(char **)(a1 + 3552));
  sub_10097E974((void *)(a1 + 3512));
  sub_10005CD2C(a1 + 3488, *(char **)(a1 + 3496));
  sub_10097E9F8((void *)(a1 + 3456));
  sub_1000346F8(a1 + 3424, *(void **)(a1 + 3432));
  sub_10010C01C(a1 + 3376, *(void **)(a1 + 3384));
  sub_1000346F8(a1 + 3352, *(void **)(a1 + 3360));
  sub_1000886C0(a1 + 3328, *(char **)(a1 + 3336));
  sub_1000886C0(a1 + 3304, *(char **)(a1 + 3312));
  sub_10005CD2C(a1 + 3272, *(char **)(a1 + 3280));
  sub_1000346F8(a1 + 3240, *(void **)(a1 + 3248));
  sub_10005CD2C(a1 + 3216, *(char **)(a1 + 3224));
  sub_10005CD2C(a1 + 3184, *(char **)(a1 + 3192));
  sub_1000886C0(a1 + 3152, *(char **)(a1 + 3160));
  sub_1000346F8(a1 + 3128, *(void **)(a1 + 3136));
  sub_10024D10C(a1 + 3104, *(void **)(a1 + 3112));
  sub_1000346F8(a1 + 3080, *(void **)(a1 + 3088));
  sub_10005CD2C(a1 + 3048, *(char **)(a1 + 3056));
  sub_1005B25E0(a1 + 3024, *(void **)(a1 + 3032));
  sub_1003C8134((unsigned char *)(a1 + 2912));
  if (*(char *)(a1 + 2895) < 0) {
    operator delete(*(void **)(a1 + 2872));
  }
  sub_10005CD2C(a1 + 2824, *(char **)(a1 + 2832));
  sub_1000886C0(a1 + 2800, *(char **)(a1 + 2808));
  sub_1000346F8(a1 + 2776, *(void **)(a1 + 2784));
  sub_1000346F8(a1 + 2752, *(void **)(a1 + 2760));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 2584));
  sub_100087ED0(a1 + 2552, *(void **)(a1 + 2560));
  sub_1000346F8(a1 + 2520, *(void **)(a1 + 2528));
  sub_10019D5B8(a1 + 2496, *(void **)(a1 + 2504));
  sub_10005CD2C(a1 + 2472, *(char **)(a1 + 2480));
  uint64_t v15 = (void **)(a1 + 2448);
  sub_10008A88C(&v15);
  sub_100087F94(a1 + 2416, *(void **)(a1 + 2424));
  sub_100087F94(a1 + 2392, *(void **)(a1 + 2400));
  sub_1000346F8(a1 + 2368, *(void **)(a1 + 2376));
  sub_100136194(a1 + 1568);
  sub_100136194(a1 + 768);
  sub_10003FB28(a1 + 744, *(void **)(a1 + 752));
  sub_1000346F8(a1 + 712, *(void **)(a1 + 720));
  sub_10041A760((void *)(a1 + 680));
  sub_1000346F8(a1 + 656, *(void **)(a1 + 664));
  sub_10041A760((void *)(a1 + 624));
  sub_100399174(a1 + 600, *(void **)(a1 + 608));
  sub_10097EA7C((void *)(a1 + 568));
  sub_10019D460(a1 + 544, *(void **)(a1 + 552));
  sub_10097EB00((void *)(a1 + 512));
  sub_10005CD2C(a1 + 488, *(char **)(a1 + 496));
  sub_10097E974((void *)(a1 + 456));
  sub_10005CD2C(a1 + 432, *(char **)(a1 + 440));
  sub_10097EB84((void *)(a1 + 400));
  sub_10097EC08(a1 + 376, *(void **)(a1 + 384));
  sub_10097ECAC((void *)(a1 + 344));
  sub_10005CD2C(a1 + 320, *(char **)(a1 + 328));
  sub_10097E9F8((void *)(a1 + 288));
  sub_10005CD2C(a1 + 264, *(char **)(a1 + 272));
  sub_10097E974((void *)(a1 + 232));
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 224);
  if (v8) {
    sub_10004D2C8(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 208);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100160A84((atomic_uint **)(a1 + 176));
  sub_1001FEC70(*(void **)(a1 + 160));
  sub_1001FEC70(*(void **)(a1 + 136));
  sub_100119D90(*(void **)(a1 + 112));
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 96);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 80);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 64);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_100087E88((void *)(a1 + 8));
  sd::IMSSubscriberEventInterface::~IMSSubscriberEventInterface((sd::IMSSubscriberEventInterface *)a1);
}

void *sub_10096FE10(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_10097E974((void *)a1);
}

void *sub_10096FE50(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_10097E9F8((void *)a1);
}

void *sub_10096FE90(uint64_t a1)
{
  sub_100399174(a1 + 32, *(void **)(a1 + 40));

  return sub_10097EA7C((void *)a1);
}

void *sub_10096FED0(uint64_t a1)
{
  sub_10019D460(a1 + 32, *(void **)(a1 + 40));

  return sub_10097EB00((void *)a1);
}

void *sub_10096FF10(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_10097EB84((void *)a1);
}

void *sub_10096FF50(uint64_t a1)
{
  sub_10097EC08(a1 + 32, *(void **)(a1 + 40));

  return sub_10097ECAC((void *)a1);
}

void sub_10096FF94(uint64_t a1)
{
  sub_10096F9DC(a1);

  operator delete();
}

void sub_10096FFCC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping EventHandler...", buf, 2u);
  }
  sub_10097290C((uint64_t)buf, a1 + 8, (uint64_t)&event::data::controlServiceOnLowPowerModeTransition, (uint64_t)sub_100972C04, 0);
}

void sub_1009724B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

atomic_uint **sub_100972894(uint64_t *a1, uint64_t a2)
{
  char v4 = operator new(0x20uLL);
  v4[1] = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v7 = 0;
  __n128 result = sub_100160AF8(&v7);
  uint64_t v6 = *a1;
  *(void *)char v4 = *a1;
  *((void *)v4 + 1) = a1;
  *(void *)(v6 + 8) = v4;
  *a1 = (uint64_t)v4;
  ++a1[2];
  return result;
}

void sub_10097290C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v9[6] = a5;
  aBlock = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  _DWORD v9[2] = sub_10097F290;
  v9[3] = &unk_101A1FF40;
  uint8_t v9[4] = a2;
  v9[5] = a4;
  aBlock = _Block_copy(v9);
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      sub_10097FEF0(v11, &aBlock, *(dispatch_object_t *)(a2 + 16));
      sub_10097FF38(&v12, v11);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100972B4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20)
{
  if (a2)
  {
    sub_100163BC8(v21 - 80);
    uint64_t v23 = *(void *)(v21 - 88);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    std::__shared_weak_count::__release_weak(v20);
    sub_10097F2DC((uint64_t)&a19);
    sub_100980DC8((uint64_t)&a17);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100972C04(uint64_t a1, BOOL a2)
{
  char v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315138;
    uint64_t v7 = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I LPM: enabled = %s", (uint8_t *)&v6, 0xCu);
  }
  return (*(uint64_t (**)(void, BOOL))(**(void **)(a1 + 72) + 80))(*(void *)(a1 + 72), a2);
}

uint64_t sub_100972CE0(uint64_t a1, int a2)
{
  uint64_t v2 = **(void **)(a1 + 72);
  if (a2) {
    return (*(uint64_t (**)(void))(v2 + 88))();
  }
  else {
    return (*(uint64_t (**)(void))(v2 + 96))();
  }
}

void sub_100972D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (sd *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  char IsDataConnectionImSupportedByDevice = sd::IsDataConnectionImSupportedByDevice(v6);
  uint64_t v8 = *(NSObject **)v6;
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (IsDataConnectionImSupportedByDevice)
  {
    if (v9)
    {
      int v10 = 136315138;
      uint64_t v11 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SimRefreshStart: for card %s", (uint8_t *)&v10, 0xCu);
    }
    (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 72) + 104))(*(void *)(a1 + 72), a2, a3, 1);
  }
  else if (v9)
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SimRefreshStart: ignoring for that type of device", (uint8_t *)&v10, 2u);
  }
}

void sub_100972E88(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  int v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)__p);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    BOOL v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  BOOL v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (!v10) {
    goto LABEL_15;
  }
LABEL_10:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v10 + 88))(__p, v10);
  long long v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = __p;
    if (v15 < 0) {
      uint64_t v13 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I CountryOfOrigination: Country determined based on location : %s", buf, 0xCu);
  }
  (*(void (**)(void, void **))(**(void **)(a1 + 72) + 176))(*(void *)(a1 + 72), __p);
  if ((SHIBYTE(v15) & 0x80000000) == 0)
  {
LABEL_15:
    if (v11) {
      return;
    }
    goto LABEL_16;
  }
  operator delete(__p[0]);
  if (v11) {
    return;
  }
LABEL_16:
  sub_10004D2C8(v9);
}

void sub_10097306C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009730B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 184))(*(void *)(a1 + 72));
  unsigned int v7 = *(void **)(a1 + 128);
  if (v7 != (void *)(a1 + 136))
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v7[7] + 104))(v7[7], a2, a3);
      uint64_t v8 = (void *)v7[1];
      if (v8)
      {
        do
        {
          BOOL v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          BOOL v9 = (void *)v7[2];
          BOOL v10 = *v9 == (void)v7;
          unsigned int v7 = v9;
        }
        while (!v10);
      }
      unsigned int v7 = v9;
    }
    while (v9 != (void *)(a1 + 136));
  }
  char v11 = *(void **)(a1 + 152);
  long long v12 = (void *)(a1 + 160);
  if (v11 != v12)
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v11[7] + 104))(v11[7], a2, a3);
      uint64_t v13 = (void *)v11[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v11[2];
          BOOL v10 = *v14 == (void)v11;
          char v11 = v14;
        }
        while (!v10);
      }
      char v11 = v14;
    }
    while (v14 != v12);
  }
  return result;
}

uint64_t sub_100973200(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 192))();
}

uint64_t sub_100973228(uint64_t result, uint64_t a2)
{
  if (HIDWORD(a2) <= 0x1A && ((1 << SBYTE4(a2)) & 0x4060000) != 0) {
    return (*(uint64_t (**)(void))(**(void **)(result + 72) + 32))();
  }
  return result;
}

uint64_t sub_100973274(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 144))();
}

uint64_t sub_10097329C(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 736);
  if (v2 != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "dis";
      if (!v2) {
        uint64_t v5 = "en";
      }
      int v7 = 136315138;
      uint64_t v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Radio %sabled", (uint8_t *)&v7, 0xCu);
    }
    uint64_t v6 = **(void **)(v3 + 72);
    if (v2) {
      return (*(uint64_t (**)(void))(v6 + 88))();
    }
    else {
      return (*(uint64_t (**)(void))(v6 + 96))();
    }
  }
  return result;
}

uint64_t sub_1009733B8(uint64_t result, uint64_t a2)
{
  if ((*(void *)(a2 + 8) & 0x60000) != 0 && (*(_DWORD *)(a2 + 16) - 1) <= 1) {
    return (*(uint64_t (**)(void))(**(void **)(result + 72) + 48))();
  }
  return result;
}

uint64_t sub_10097340C(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315138;
    uint64_t v7 = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I RFBand: Type = %s", (uint8_t *)&v6, 0xCu);
  }
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 72) + 56))(*(void *)(a1 + 72), *a2, a2[1], a2[2]);
}

void sub_1009734EC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 760))
  {
    uint64_t v3 = *(void **)(a1 + 744);
    uint64_t v4 = (void *)(a1 + 752);
    if (v3 != (void *)(a1 + 752))
    {
      uint64_t v5 = (void *)(a2 + 8);
      do
      {
        uint64_t v6 = *v5;
        int v7 = *((_DWORD *)v3 + 8);
        if (!*v5) {
          goto LABEL_35;
        }
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < v7;
          if (v9 >= v7) {
            char v11 = (uint64_t *)v6;
          }
          else {
            char v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 == v5 || v7 < *((_DWORD *)v8 + 8) || (rest::operator==() & 1) == 0)
        {
LABEL_35:
          if (subscriber::isValidSimSlot())
          {
            long long v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v3 + 8));
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              MCCAndMNC::getMcc(v24, (MCCAndMNC *)(v3 + 5));
              int IntValue = MCC::getIntValue((MCC *)v24);
              MCCAndMNC::getMnc(v22, (MCCAndMNC *)(v3 + 5));
              int IntegerWidth = MNC::getIntegerWidth((MNC *)v22);
              MCCAndMNC::getMnc(v20, (MCCAndMNC *)(v3 + 5));
              int v15 = MCC::getIntValue((MCC *)v20);
              *(_DWORD *)long long buf = 67109632;
              int v27 = IntValue;
              __int16 v28 = 1024;
              int v29 = IntegerWidth;
              __int16 v30 = 1024;
              int v31 = v15;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I ServingNetwork: PLMN: %03d-%0.*d", buf, 0x14u);
              if (v21 < 0) {
                operator delete((void *)v20[1]);
              }
              if (v23 < 0) {
                operator delete((void *)v22[1]);
              }
              if (v25 < 0) {
                operator delete((void *)v24[1]);
              }
            }
            (*(void (**)(void, void))(**(void **)(a1 + 72) + 136))(*(void *)(a1 + 72), *((unsigned int *)v3 + 8));
          }
        }
        char v16 = (void *)v3[1];
        if (v16)
        {
          do
          {
            uint64_t v17 = v16;
            char v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v17 = (void *)v3[2];
            BOOL v18 = *v17 == (void)v3;
            uint64_t v3 = v17;
          }
          while (!v18);
        }
        uint64_t v3 = v17;
      }
      while (v17 != v4);
    }
  }
  else
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v24[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E ServingNetwork: No serving network info is set", (uint8_t *)v24, 2u);
    }
  }
}

void sub_10097378C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009737E8(uint64_t a1, RegisteredNetworkInfo *this)
{
  uint64_t v3 = (RegisteredNetworkInfo *)(a1 + 1568);
  std::string __p = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  RegisteredNetworkInfo::compare((uint64_t *)&__p, this, (const RegisteredNetworkInfo *)(a1 + 1568));
  sub_1000638D8(a1, 2, (uint64_t)&__p, v3);
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }
}

void sub_100973850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097386C(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I PcscfList: updated (%s)", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v5 = (uint64_t *)*((void *)a2 + 4);
  if (v5 != (uint64_t *)0x4000000)
  {
    if ((v5 & 0x20000) == 0) {
      return;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 56));
    BOOL v18 = ServiceMap;
    if (v19 < 0)
    {
      char v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v19;
    char v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      int v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        if (!v25) {
          goto LABEL_17;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    int v24 = 0;
    char v26 = 1;
    if (!v25)
    {
LABEL_17:
      int v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf) = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, "PersonalityShop NOT found in registry", (uint8_t *)&buf, 2u);
      }
LABEL_30:
      if (v26) {
        return;
      }
      __int16 v28 = v24;
      goto LABEL_32;
    }
LABEL_28:
    long long buf = 0uLL;
    uint64_t v31 = 0;
    PersonalityIdFromSlotId();
    (*(void (**)(void, long long *, unsigned int *, void))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), &buf, a2 + 2, a2[10]);
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)buf);
    }
    goto LABEL_30;
  }
  uint64_t v6 = *(void *)(a1 + 72);
  int v7 = (std::mutex *)Registry::getServiceMap((uint64_t *)0x4000000, *(Registry **)(a1 + 56));
  uint64_t v8 = v7;
  if ((v9 & 0x8000000000000000) != 0)
  {
    BOOL v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(v7);
  unint64_t v29 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v29);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_21:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v15 + 144))(&buf, v15);
  (*(void (**)(uint64_t, long long *, unsigned int *, void))(*(void *)v6 + 40))(v6, &buf, a2 + 2, a2[10]);
  if (SHIBYTE(v31) < 0)
  {
    operator delete((void *)buf);
    if (v16) {
      return;
    }
    goto LABEL_25;
  }
  if ((v16 & 1) == 0)
  {
LABEL_25:
    __int16 v28 = v14;
LABEL_32:
    sub_10004D2C8(v28);
  }
}

void sub_100973BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100973C48(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 2392);
  int v2 = (void *)(result + 2400);
  if (v1 != (void *)(result + 2400))
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 8));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asString();
        *(_DWORD *)long long buf = 136315138;
        uint64_t v10 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I bundleChangeType: %s", buf, 0xCu);
      }
      uint64_t result = (*(uint64_t (**)(void, void, void))(**(void **)(v3 + 72) + 152))(*(void *)(v3 + 72), *((unsigned int *)v1 + 8), *((char *)v1 + 40));
      uint64_t v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

uint64_t sub_100973DB4(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 2416);
  int v2 = (void *)(result + 2424);
  if (v1 != (void *)(result + 2424))
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 8));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asString();
        *(_DWORD *)long long buf = 136315138;
        uint64_t v10 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I bundleChangeType: %s", buf, 0xCu);
      }
      uint64_t result = (*(uint64_t (**)(void, void, void))(**(void **)(v3 + 72) + 160))(*(void *)(v3 + 72), *((unsigned int *)v1 + 8), *((char *)v1 + 40));
      uint64_t v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

uint64_t sub_100973F20(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 2448);
  uint64_t v3 = *(void *)(result + 2456);
  if (v2 != v3)
  {
    uint64_t v5 = result;
    do
    {
      uint64_t v6 = *(_DWORD **)a2;
      int v7 = *(_DWORD **)(a2 + 8);
      sub_10002E664((uint64_t)v8, v2);
      if (v6 != v7)
      {
        while (*v6 != v8[0])
        {
          v6 += 42;
          if (v6 == v7)
          {
            uint64_t v6 = v7;
            break;
          }
        }
      }
      if (v19 < 0) {
        operator delete(__p);
      }
      if (v17 < 0) {
        operator delete(v16);
      }
      if (v15 < 0) {
        operator delete(v14);
      }
      if (v13 < 0) {
        operator delete(v12);
      }
      char v20 = (void **)&v11;
      sub_10002E39C(&v20);
      if (v9)
      {
        uint64_t v10 = v9;
        operator delete(v9);
      }
      if (v6 == *(_DWORD **)(a2 + 8) || (uint64_t result = BasicSimInfo::operator!=(), result)) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 72) + 200))(*(void *)(v5 + 72), v2);
      }
      v2 += 168;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_100974064(uint64_t a1, uint64_t a2)
{
  *(void *)long long buf = off_101A222C0;
  CFStringRef v60 = buf;
  *(void *)uint64_t v61 = off_101A22350;
  CFStringRef v62 = v61;
  std::string v51 = 0;
  uint64_t v52 = 0;
  __int16 v50 = 0;
  uint64_t v47 = &v50;
  uint64_t v48 = 0;
  uint64_t v3 = (char *)operator new(0x40uLL);
  uint64_t v4 = 0;
  __int16 v50 = v3;
  std::string v51 = v3;
  uint64_t v52 = v3 + 64;
  do
  {
    uint64_t v5 = &v3[v4];
    uint64_t v6 = *(unsigned char **)&v61[v4 - 8];
    if (!v6)
    {
      uint64_t v7 = 0;
      goto LABEL_6;
    }
    if (&buf[v4] != v6)
    {
      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v6 + 16))(*(void *)&v61[v4 - 8]);
LABEL_6:
      *((void *)v5 + 3) = v7;
      goto LABEL_8;
    }
    *(void *)&v3[v4 + 24] = v5;
    (*(void (**)(void))(*(void *)&buf[v4] + 24))();
LABEL_8:
    v4 += 32;
  }
  while (v4 != 64);
  std::string v51 = v3 + 64;
  for (uint64_t i = 32; i != -32; i -= 32)
    sub_10098C31C(&buf[i]);
  *(void *)long long buf = off_101A223D0;
  CFStringRef v60 = buf;
  *(void *)uint64_t v61 = off_101A22460;
  CFStringRef v62 = v61;
  uint64_t v48 = 0;
  CFStringRef v49 = 0;
  uint64_t v47 = 0;
  long long v44 = &v47;
  uint64_t v45 = 0;
  uint64_t v47 = (char **)operator new(0x40uLL);
  uint64_t v48 = (uint64_t)v47;
  CFStringRef v49 = v47 + 8;
  uint64_t v48 = sub_10097EE1C((uint64_t)buf, (uint64_t)&v63, (uint64_t)v47);
  for (uint64_t j = 32; j != -32; j -= 32)
    sub_10098C548(&buf[j]);
  *(void *)long long buf = off_101A224E0;
  CFStringRef v60 = buf;
  *(void *)uint64_t v61 = off_101A22560;
  CFStringRef v62 = v61;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  long long v44 = 0;
  int v53 = &v44;
  uint64_t v54 = 0;
  long long v44 = (char ***)operator new(0x40uLL);
  uint64_t v45 = (uint64_t)v44;
  uint64_t v46 = v44 + 8;
  uint64_t v45 = sub_10097EE1C((uint64_t)buf, (uint64_t)&v63, (uint64_t)v44);
  for (uint64_t k = 32; k != -32; k -= 32)
    sub_10098C548(&buf[k]);
  uint64_t v11 = (v51 - v50) >> 5;
  if (v11 != (v48 - (uint64_t)v47) >> 5 || v11 != (v45 - (uint64_t)v44) >> 5) {
    __assert_rtn("handleIMSProvStateChanged_sync", "IMSSubscriberEventHandler.cpp", 955, "shouldProcessThisPersonalityForVoWiFiProvState.size() == shouldProcessThisPersonalityForVoLTEFeatureSupport.size() && shouldProcessThisPersonalityForVoWiFiProvState.size() == shouldProcessThisPersonalityForVoNRFeatureSupport.size()");
  }
  uint64_t v12 = a2;
  if (v51 != v50)
  {
    unint64_t v13 = 0;
    uint64_t v14 = (void *)(a1 + 2480);
    do
    {
      char v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I handleIMSProvStateChanged_sync: Pass: %zu", buf, 0xCu);
      }
      char v16 = *(void **)(a1 + 2472);
      if (v16 != v14)
      {
        do
        {
          char v17 = sub_100046F68(v12, (void **)v16 + 4);
          LODWORD(v54) = 0;
          int v53 = 0;
          if ((void **)(a2 + 8) != v17)
          {
            int v53 = (char ****)v17[7];
            LODWORD(v54) = *((_DWORD *)v17 + 16);
          }
          uint64_t v18 = *(void *)&v50[32 * v13 + 24];
          int v55 = *((_DWORD *)v16 + 16);
          if (!v18) {
            sub_10007B600();
          }
          if ((*(unsigned int (**)(uint64_t, int *))(*(void *)v18 + 48))(v18, &v55))
          {
            char v19 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v20 = *((unsigned __int8 *)v16 + 55);
              BOOL v21 = (v20 & 0x80u) != 0;
              if ((v20 & 0x80u) != 0) {
                uint64_t v20 = v16[5];
              }
              if (v21) {
                unsigned int v22 = (const char *)v16[4];
              }
              else {
                unsigned int v22 = (const char *)(v16 + 4);
              }
              if (v20) {
                char v23 = v22;
              }
              else {
                char v23 = "<invalid>";
              }
              uint64_t v24 = asString();
              uint64_t v25 = asString();
              *(_DWORD *)long long buf = 136315906;
              *(void *)&uint8_t buf[4] = v23;
              __int16 v57 = 2080;
              uint64_t v58 = v24;
              __int16 v59 = 2080;
              CFStringRef v60 = (unsigned char *)v25;
              *(_WORD *)uint64_t v61 = 2048;
              *(void *)&v61[2] = v13;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I handleIMSProvStateChanged_sync: VoWiFiProv for PersonalityID: %s, old state: %s, new state: %s in pass %zu", buf, 0x2Au);
              uint64_t v12 = a2;
            }
            (*(void (**)(void, void *, uint64_t *, void *))(**(void **)(a1 + 72) + 208))(*(void *)(a1 + 72), v16 + 4, &v54, v16 + 8);
          }
          if (sub_10097B734((uint64_t)v47[4 * v13 + 3], *((_DWORD *)v16 + 14)))
          {
            char v26 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v27 = *((unsigned __int8 *)v16 + 55);
              BOOL v28 = (v27 & 0x80u) != 0;
              if ((v27 & 0x80u) != 0) {
                uint64_t v27 = v16[5];
              }
              if (v28) {
                unint64_t v29 = (const char *)v16[4];
              }
              else {
                unint64_t v29 = (const char *)(v16 + 4);
              }
              if (v27) {
                __int16 v30 = v29;
              }
              else {
                __int16 v30 = "<invalid>";
              }
              uint64_t v31 = asString();
              uint64_t v32 = asString();
              *(_DWORD *)long long buf = 136315906;
              *(void *)&uint8_t buf[4] = v30;
              __int16 v57 = 2080;
              uint64_t v58 = v31;
              __int16 v59 = 2080;
              CFStringRef v60 = (unsigned char *)v32;
              *(_WORD *)uint64_t v61 = 2048;
              *(void *)&v61[2] = v13;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I handleIMSProvStateChanged_sync: VoLTEFeatureSupport for PersonalityID: %s, old state: %s, new state: %s in pass %zu", buf, 0x2Au);
            }
            (*(void (**)(void, void *, void))(**(void **)(a1 + 72) + 216))(*(void *)(a1 + 72), v16 + 4, *((unsigned int *)v16 + 14));
          }
          if (sub_10097B734((uint64_t)v44[4 * v13 + 3], *((_DWORD *)v16 + 15)))
          {
            long long v33 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v34 = *((unsigned __int8 *)v16 + 55);
              BOOL v35 = (v34 & 0x80u) != 0;
              if ((v34 & 0x80u) != 0) {
                uint64_t v34 = v16[5];
              }
              if (v35) {
                long long v36 = (const char *)v16[4];
              }
              else {
                long long v36 = (const char *)(v16 + 4);
              }
              if (v34) {
                long long v37 = v36;
              }
              else {
                long long v37 = "<invalid>";
              }
              uint64_t v38 = asString();
              uint64_t v39 = asString();
              *(_DWORD *)long long buf = 136315906;
              *(void *)&uint8_t buf[4] = v37;
              __int16 v57 = 2080;
              uint64_t v58 = v38;
              __int16 v59 = 2080;
              CFStringRef v60 = (unsigned char *)v39;
              *(_WORD *)uint64_t v61 = 2048;
              *(void *)&v61[2] = v13;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I handleIMSProvStateChanged_sync: VoNRFeatureSupport for PersonalityID: %s, old state: %s, new state: %s in pass %zu", buf, 0x2Au);
            }
            (*(void (**)(void, void *, void))(**(void **)(a1 + 72) + 224))(*(void *)(a1 + 72), v16 + 4, *((unsigned int *)v16 + 15));
          }
          long long v40 = (void *)v16[1];
          if (v40)
          {
            do
            {
              CFStringRef v41 = v40;
              long long v40 = (void *)*v40;
            }
            while (v40);
          }
          else
          {
            do
            {
              CFStringRef v41 = (void *)v16[2];
              BOOL v42 = *v41 == (void)v16;
              char v16 = v41;
            }
            while (!v42);
          }
          char v16 = v41;
        }
        while (v41 != v14);
      }
      ++v13;
    }
    while (v13 < (v51 - v50) >> 5);
  }
  *(void *)long long buf = &v44;
  sub_10097EF14((void ***)buf);
  *(void *)long long buf = &v47;
  sub_10097EF14((void ***)buf);
  *(void *)long long buf = &v50;
  sub_10097ED98((void ***)buf);
}

void sub_1009747CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,void **a24,uint64_t a25,uint64_t a26,void **a27)
{
  sub_10097EF14(&a24);
  for (uint64_t i = 4; i != -4; i -= 4)
    sub_10098C548(&(&a27)[i]);
  a27 = (void **)&a18;
  sub_10097EF14(&a27);
  a27 = (void **)&a21;
  sub_10097ED98(&a27);
  _Unwind_Resume(a1);
}

void sub_1009748E0(uint64_t a1)
{
  if (*(void *)(a1 + 2512))
  {
    uint64_t v2 = *(void **)(a1 + 2496);
    uint64_t v3 = (void *)(a1 + 2504);
    if (v2 != (void *)(a1 + 2504))
    {
      do
      {
        if (subscriber::isValidSimSlot())
        {
          uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v5 = subscriber::asString();
            uint64_t v6 = v2 + 5;
            if (*((char *)v2 + 63) < 0) {
              uint64_t v6 = (void *)v2[5];
            }
            uint64_t v7 = v2 + 8;
            if (*((char *)v2 + 87) < 0) {
              uint64_t v7 = (void *)*v7;
            }
            *(_DWORD *)long long buf = 136315650;
            uint64_t v13 = v5;
            __int16 v14 = 2080;
            char v15 = v6;
            __int16 v16 = 2080;
            char v17 = v7;
            _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MCC/MNC: slot = %s, MCC: %s, MNC: %s", buf, 0x20u);
          }
          (*(void (**)(void, void, void *, void *))(**(void **)(a1 + 72) + 128))(*(void *)(a1 + 72), *((unsigned int *)v2 + 8), v2 + 5, v2 + 8);
        }
        BOOL v8 = (void *)v2[1];
        if (v8)
        {
          do
          {
            unint64_t v9 = v8;
            BOOL v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            unint64_t v9 = (void *)v2[2];
            BOOL v10 = *v9 == (void)v2;
            uint64_t v2 = v9;
          }
          while (!v10);
        }
        uint64_t v2 = v9;
      }
      while (v9 != v3);
    }
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E MCC/MNC: No info is set", buf, 2u);
    }
  }
}

void sub_100974AF4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2520);
  uint64_t v3 = (void *)(a1 + 2528);
  if (v2 != (void *)(a1 + 2528))
  {
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 7));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = asStringBool(*((unsigned char *)v2 + 32));
        *(_DWORD *)long long buf = 136315138;
        uint64_t v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ISIM: filesReady: %s", buf, 0xCu);
      }
      uint64_t v8 = *v5;
      uint64_t v9 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        goto LABEL_16;
      }
      BOOL v10 = v5;
      do
      {
        int v11 = *(_DWORD *)(v8 + 28);
        BOOL v12 = v11 < (int)v9;
        if (v11 >= (int)v9) {
          uint64_t v13 = (uint64_t *)v8;
        }
        else {
          uint64_t v13 = (uint64_t *)(v8 + 8);
        }
        if (!v12) {
          BOOL v10 = (void *)v8;
        }
        uint64_t v8 = *v13;
      }
      while (*v13);
      if (v10 == v5
        || (int)v9 < *((_DWORD *)v10 + 7)
        || *((unsigned __int8 *)v10 + 32) != *((unsigned __int8 *)v2 + 32))
      {
LABEL_16:
        (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 72) + 120))(*(void *)(a1 + 72), v9, *((unsigned __int8 *)v2 + 32));
      }
      __int16 v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          char v15 = v14;
          __int16 v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          char v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != v3);
  }
}

uint64_t sub_100974CB8(uint64_t result, unsigned int *a2)
{
  if (a2[1] == 19)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(result + 48) + 16))(*(void *)(result + 48), *a2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I AccessControlClass: is available", v5, 2u);
    }
    return (*(uint64_t (**)(void, void, unsigned int *))(**(void **)(v3 + 72) + 112))(*(void *)(v3 + 72), *a2, a2 + 2);
  }
  return result;
}

void sub_100974D90(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2552);
  uint64_t v3 = (void *)(a1 + 2560);
  if (v2 != (void *)(a1 + 2560))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((rest::operator==() & 1) == 0)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        uint64_t v12 = a1;
        uint64_t v13 = v2 + 5;
        goto LABEL_17;
      }
LABEL_18:
      __int16 v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          char v15 = v14;
          __int16 v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          char v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_16:
    uint64_t v13 = v2 + 5;
    uint64_t v12 = a1;
LABEL_17:
    sub_10098C09C(v12, v7, v13);
    goto LABEL_18;
  }
}

void sub_100974E80(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = (sd *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  char IsDataConnectionImSupportedByDevice = sd::IsDataConnectionImSupportedByDevice(v4);
  uint64_t v6 = *(NSObject **)v4;
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (IsDataConnectionImSupportedByDevice)
  {
    if (v7)
    {
      int v8 = 136315394;
      uint64_t v9 = subscriber::asString();
      __int16 v10 = 2080;
      uint64_t v11 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I SimRefresh: stage: %s for card %s", (uint8_t *)&v8, 0x16u);
    }
    if (a2[2] == 2) {
      (*(void (**)(void, void, void, uint64_t))(**(void **)(a1 + 72) + 104))(*(void *)(a1 + 72), *a2, a2[1], 2);
    }
  }
  else if (v7)
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I SimRefresh: ignoring for that type of device", (uint8_t *)&v8, 2u);
  }
}

uint64_t sub_100974FF0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  switch(*(unsigned char *)(a2 + 24))
  {
    case 0:
      __int16 v14 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(unsigned __int8 *)(a2 + 23);
        BOOL v16 = (v15 & 0x80u) != 0;
        if ((v15 & 0x80u) != 0) {
          uint64_t v15 = *(void *)(a2 + 8);
        }
        if (v16) {
          char v17 = *(const char **)a2;
        }
        else {
          char v17 = (const char *)a2;
        }
        if (v15) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = "<invalid>";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Personality is added: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 72) + 296))(*(void *)(v3 + 72), a2);
      break;
    case 1:
      char v19 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
        BOOL v21 = (v20 & 0x80u) != 0;
        if ((v20 & 0x80u) != 0) {
          uint64_t v20 = *(void *)(a2 + 8);
        }
        if (v21) {
          unsigned int v22 = *(const char **)a2;
        }
        else {
          unsigned int v22 = (const char *)a2;
        }
        if (v20) {
          char v23 = v22;
        }
        else {
          char v23 = "<invalid>";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v23;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Personality is enabled: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 72) + 304))(*(void *)(v3 + 72), a2);
      break;
    case 3:
      uint64_t v24 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(unsigned __int8 *)(a2 + 23);
        BOOL v26 = (v25 & 0x80u) != 0;
        if ((v25 & 0x80u) != 0) {
          uint64_t v25 = *(void *)(a2 + 8);
        }
        if (v26) {
          uint64_t v27 = *(const char **)a2;
        }
        else {
          uint64_t v27 = (const char *)a2;
        }
        if (v25) {
          BOOL v28 = v27;
        }
        else {
          BOOL v28 = "<invalid>";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v28;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Personality is recovered: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 72) + 312))(*(void *)(v3 + 72), a2);
      break;
    case 6:
    case 7:
      uint64_t v4 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
        BOOL v6 = (v5 & 0x80u) != 0;
        if ((v5 & 0x80u) != 0) {
          uint64_t v5 = *(void *)(a2 + 8);
        }
        if (v6) {
          BOOL v7 = *(const char **)a2;
        }
        else {
          BOOL v7 = (const char *)a2;
        }
        if (v5) {
          int v8 = v7;
        }
        else {
          int v8 = "<invalid>";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v8;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Personality is removed: %s", (uint8_t *)&buf, 0xCu);
      }
      (*(void (**)(void, uint64_t))(**(void **)(v3 + 72) + 320))(*(void *)(v3 + 72), a2);
      *(void *)&long long buf = 1;
      *((void *)&buf + 1) = v3 + 400;
      sub_100340C0C((void *)(v3 + 432), (void **)a2);
      v48[0] = 1;
      v48[1] = v3 + 456;
      sub_1000E9358((uint64_t **)(v3 + 488), (void **)a2);
      v47[0] = 1;
      v47[1] = v3 + 288;
      uint64_t v9 = (void ***)(v3 + 320);
      __int16 v10 = sub_100046F68(v3 + 320, (void **)a2);
      uint64_t v11 = v10;
      if ((void **)(v3 + 328) != v10)
      {
        uint64_t v12 = (void **)v10[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            uint64_t v12 = (void **)*v12;
          }
          while (v12);
        }
        else
        {
          unint64_t v29 = v10;
          do
          {
            uint64_t v13 = (void **)v29[2];
            BOOL v30 = *v13 == v29;
            unint64_t v29 = v13;
          }
          while (!v30);
        }
        if (*v9 == v10) {
          *uint64_t v9 = v13;
        }
        uint64_t v31 = *(uint64_t **)(v3 + 328);
        --*(void *)(v3 + 336);
        sub_10005EE6C(v31, (uint64_t *)v11);
        if (*((char *)v11 + 55) < 0) {
          operator delete(v11[4]);
        }
        operator delete(v11);
      }
      v46[0] = 1;
      v46[1] = v3 + 512;
      uint64_t v32 = (uint64_t **)(v3 + 544);
      long long v33 = (uint64_t *)sub_100046F68(v3 + 544, (void **)a2);
      uint64_t v34 = v33;
      if ((uint64_t *)(v3 + 552) != v33)
      {
        BOOL v35 = (uint64_t *)v33[1];
        if (v35)
        {
          do
          {
            long long v36 = v35;
            BOOL v35 = (uint64_t *)*v35;
          }
          while (v35);
        }
        else
        {
          long long v37 = v33;
          do
          {
            long long v36 = (uint64_t *)v37[2];
            BOOL v30 = *v36 == (void)v37;
            long long v37 = v36;
          }
          while (!v30);
        }
        if (*v32 == v33) {
          *uint64_t v32 = v36;
        }
        --*(void *)(v3 + 560);
        sub_10005EE6C(*(uint64_t **)(v3 + 552), v33);
        sub_10019D4BC((uint64_t)(v34 + 4));
        operator delete(v34);
      }
      v45[0] = 1;
      v45[1] = v3 + 568;
      uint64_t v38 = *(void **)(v3 + 608);
      if (v38)
      {
        uint64_t v39 = (void *)(v3 + 608);
        do
        {
          char v40 = sub_100046FE8(v38 + 4, (void **)a2);
          if (v40 >= 0) {
            CFStringRef v41 = v38;
          }
          else {
            CFStringRef v41 = v38 + 1;
          }
          if (v40 >= 0) {
            uint64_t v39 = v38;
          }
          uint64_t v38 = (void *)*v41;
        }
        while (*v41);
        if (v39 != (void *)(v3 + 608) && (sub_100046FE8((void *)a2, (void **)v39 + 4) & 0x80) == 0)
        {
          BOOL v42 = (void *)v39[1];
          if (v42)
          {
            do
            {
              long long v43 = v42;
              BOOL v42 = (void *)*v42;
            }
            while (v42);
          }
          else
          {
            long long v44 = v39;
            do
            {
              long long v43 = (void *)v44[2];
              BOOL v30 = *v43 == (void)v44;
              long long v44 = v43;
            }
            while (!v30);
          }
          if (*(void **)(v3 + 600) == v39) {
            *(void *)(v3 + 600) = v43;
          }
          --*(void *)(v3 + 616);
          sub_10005EE6C(*(uint64_t **)(v3 + 608), v39);
          sub_1003991D0((uint64_t)(v39 + 4));
          operator delete(v39);
        }
      }
      sub_10098C038((uint64_t)v45);
      sub_10098BFD4((uint64_t)v46);
      sub_10098BF70((uint64_t)v47);
      sub_10098BF0C((uint64_t)v48);
      uint64_t result = sub_10098BEA8((uint64_t)&buf);
      break;
    default:
      return result;
  }
  return result;
}

void sub_100975568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v12 = va_arg(va3, void);
  sub_10098BFD4((uint64_t)va);
  sub_10098BF70((uint64_t)va1);
  sub_10098BF0C((uint64_t)va2);
  sub_10098BEA8((uint64_t)va3);
  _Unwind_Resume(a1);
}

uint64_t sub_1009755CC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 3376);
  BOOL v30 = (void *)(result + 3384);
  if (v2 != (void *)(result + 3384))
  {
    uint64_t v3 = a2;
    uint64_t v4 = result;
    unint64_t v29 = (void **)(a2 + 8);
    uint64_t v28 = result;
    while (1)
    {
      uint64_t v5 = sub_100046F68(v3, (void **)v2 + 4);
      if (v29 == v5) {
        break;
      }
      uint64_t v6 = (uint64_t)(v5 + 7);
      uint64_t result = sub_1003B32FC((unsigned __int8 *)v5 + 56, (unsigned __int8 *)v2 + 56);
      if ((result & 1) == 0)
      {
        uint64_t v7 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *((unsigned __int8 *)v2 + 55);
          uint64_t v9 = (const char *)v2[4];
          uint64_t v10 = v2[5];
          sub_1003B37BC(v6, v33);
          uint64_t v11 = v3;
          int v12 = v36;
          uint64_t v13 = *(unsigned char **)v33;
          sub_1003B37BC((uint64_t)(v2 + 7), __p);
          __int16 v14 = v33;
          if (v12 < 0) {
            __int16 v14 = v13;
          }
          if ((v8 & 0x80u) == 0) {
            uint64_t v15 = v8;
          }
          else {
            uint64_t v15 = v10;
          }
          if ((v8 & 0x80u) == 0) {
            BOOL v16 = (const char *)(v2 + 4);
          }
          else {
            BOOL v16 = v9;
          }
          BOOL v17 = v15 == 0;
          uint64_t v18 = "<invalid>";
          if (!v17) {
            uint64_t v18 = v16;
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v18;
          __int16 v38 = 2080;
          char v19 = __p;
          if (v32 < 0) {
            char v19 = (void **)__p[0];
          }
          uint64_t v39 = v14;
          __int16 v40 = 2080;
          CFStringRef v41 = v19;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I DeviceID: for Personality: %s, %s -> %s", buf, 0x20u);
          if (v32 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v3 = v11;
          if (v36 < 0) {
            operator delete(*(void **)v33);
          }
          uint64_t v4 = v28;
        }
LABEL_36:
        uint64_t result = (*(uint64_t (**)(void, void *, void *))(**(void **)(v4 + 72) + 328))(*(void *)(v4 + 72), v2 + 4, v2 + 7);
      }
      BOOL v26 = (void *)v2[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          BOOL v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v2[2];
          BOOL v17 = *v27 == (void)v2;
          uint64_t v2 = v27;
        }
        while (!v17);
      }
      uint64_t v2 = v27;
      if (v27 == v30) {
        return result;
      }
    }
    uint64_t v20 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *((unsigned __int8 *)v2 + 55);
      BOOL v22 = (v21 & 0x80u) != 0;
      if ((v21 & 0x80u) != 0) {
        uint64_t v21 = v2[5];
      }
      if (v22) {
        char v23 = (const char *)v2[4];
      }
      else {
        char v23 = (const char *)(v2 + 4);
      }
      if (v21) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = "<invalid>";
      }
      sub_1003B37BC((uint64_t)(v2 + 7), buf);
      uint64_t v25 = buf;
      if (v40 < 0) {
        uint64_t v25 = *(unsigned char **)buf;
      }
      *(_DWORD *)long long v33 = 136315394;
      *(void *)&v33[4] = v24;
      __int16 v34 = 2080;
      BOOL v35 = v25;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DeviceID: New ID for Personality: %s, %s", v33, 0x16u);
      if (SHIBYTE(v40) < 0) {
        operator delete(*(void **)buf);
      }
    }
    goto LABEL_36;
  }
  return result;
}

void sub_1009758C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009758E4(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 3417);
  if (v2 != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "on";
      if (!v2) {
        uint64_t v5 = "off";
      }
      int v6 = 136315138;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Battery saving mode is %s", (uint8_t *)&v6, 0xCu);
    }
    return (*(uint64_t (**)(void))(**(void **)(v3 + 72) + 248))(*(void *)(v3 + 72));
  }
  return result;
}

uint64_t sub_1009759D4(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 2752);
  uint64_t v3 = (void *)(result + 2760);
  if (v2 != (void *)(result + 2760))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      int v7 = *((_DWORD *)v2 + 7);
      if (*v5)
      {
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 28);
          BOOL v10 = v9 < v7;
          if (v9 >= v7) {
            uint64_t v11 = (uint64_t *)v6;
          }
          else {
            uint64_t v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && v7 >= *((_DWORD *)v8 + 7)) {
          break;
        }
      }
      if ((v7 - 1) <= 1) {
        goto LABEL_14;
      }
LABEL_15:
      int v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          int v2 = v13;
        }
        while (!v14);
      }
      int v2 = v13;
      if (v13 == v3) {
        return result;
      }
    }
    if (*((_DWORD *)v8 + 8) == *((_DWORD *)v2 + 8) || (v7 - 1) >= 2) {
      goto LABEL_15;
    }
LABEL_14:
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v4 + 72) + 256))(*(void *)(v4 + 72));
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_100975AE8(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 2776);
  uint64_t v3 = (void *)(result + 2784);
  if (v2 != (void *)(result + 2784))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      int v7 = *((_DWORD *)v2 + 7);
      if (*v5)
      {
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 28);
          BOOL v10 = v9 < v7;
          if (v9 >= v7) {
            uint64_t v11 = (uint64_t *)v6;
          }
          else {
            uint64_t v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && v7 >= *((_DWORD *)v8 + 7)) {
          break;
        }
      }
      if ((v7 - 1) <= 1) {
        goto LABEL_14;
      }
LABEL_15:
      int v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          int v2 = v13;
        }
        while (!v14);
      }
      int v2 = v13;
      if (v13 == v3) {
        return result;
      }
    }
    if (*((unsigned __int8 *)v8 + 32) == *((unsigned __int8 *)v2 + 32) || (v7 - 1) >= 2) {
      goto LABEL_15;
    }
LABEL_14:
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v4 + 72) + 264))(*(void *)(v4 + 72));
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_100975C04(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 2824);
  uint64_t v3 = (void *)(result + 2832);
  if (v2 != (void *)(result + 2832))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void **)(a2 + 8);
    uint64_t v6 = (void *)(result + 136);
    do
    {
      int v7 = sub_100046F68(a2, (void **)v2 + 4);
      if (v5 == v7 || (uint64_t result = operator==(), (result & 1) == 0))
      {
        int v8 = *((unsigned __int8 *)v2 + 56);
        int v9 = *(NSObject **)(v4 + 40);
        BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v10)
          {
            uint64_t v11 = *((unsigned __int8 *)v2 + 55);
            BOOL v12 = (v11 & 0x80u) != 0;
            if ((v11 & 0x80u) != 0) {
              uint64_t v11 = v2[5];
            }
            if (v12) {
              uint64_t v13 = (const char *)v2[4];
            }
            else {
              uint64_t v13 = (const char *)(v2 + 4);
            }
            if (v11) {
              BOOL v14 = v13;
            }
            else {
              BOOL v14 = "<invalid>";
            }
            uint64_t v15 = asStringBool(*((unsigned char *)v2 + 57));
            uint64_t v16 = asStringBool(*((unsigned char *)v2 + 58));
            uint64_t v17 = asString();
            *(_DWORD *)long long buf = 136315906;
            char v36 = v14;
            __int16 v37 = 2080;
            uint64_t v38 = v15;
            __int16 v39 = 2080;
            uint64_t v40 = v16;
            __int16 v41 = 2080;
            uint64_t v42 = v17;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I CallState: Voice Call started. Personality: %s, VoIP: %s, CS: %s, Type: %s", buf, 0x2Au);
          }
          uint64_t result = (*(uint64_t (**)(void, void *, void, void, void))(**(void **)(v4 + 72) + 280))(*(void *)(v4 + 72), v2 + 4, *((unsigned __int8 *)v2 + 57), *((unsigned __int8 *)v2 + 58), *((unsigned int *)v2 + 15));
          uint64_t v18 = *(void **)(v4 + 128);
          if (v18 != v6)
          {
            do
            {
              uint64_t result = (*(uint64_t (**)(void))(*(void *)v18[7] + 128))(v18[7]);
              char v19 = (void *)v18[1];
              if (v19)
              {
                do
                {
                  uint64_t v20 = v19;
                  char v19 = (void *)*v19;
                }
                while (v19);
              }
              else
              {
                do
                {
                  uint64_t v20 = (void *)v18[2];
                  BOOL v21 = *v20 == (void)v18;
                  uint64_t v18 = v20;
                }
                while (!v21);
              }
              uint64_t v18 = v20;
            }
            while (v20 != v6);
          }
        }
        else
        {
          if (v10)
          {
            uint64_t v22 = *((unsigned __int8 *)v2 + 55);
            BOOL v23 = (v22 & 0x80u) != 0;
            if ((v22 & 0x80u) != 0) {
              uint64_t v22 = v2[5];
            }
            if (v23) {
              uint64_t v24 = (const char *)v2[4];
            }
            else {
              uint64_t v24 = (const char *)(v2 + 4);
            }
            if (v22) {
              uint64_t v25 = v24;
            }
            else {
              uint64_t v25 = "<invalid>";
            }
            uint64_t v26 = asStringBool(*((unsigned char *)v2 + 57));
            uint64_t v27 = asStringBool(*((unsigned char *)v2 + 58));
            *(_DWORD *)long long buf = 136315650;
            char v36 = v25;
            __int16 v37 = 2080;
            uint64_t v38 = v26;
            __int16 v39 = 2080;
            uint64_t v40 = v27;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I CallState: Voice Call ended. Personality: %s, VoIP: %s, CS: %s", buf, 0x20u);
          }
          uint64_t v28 = (unsigned __int8 *)v7 + 57;
          if (v5 == v7) {
            uint64_t v28 = (unsigned __int8 *)v2 + 57;
          }
          uint64_t result = (*(uint64_t (**)(void, void *, void))(**(void **)(v4 + 72) + 288))(*(void *)(v4 + 72), v2 + 4, *v28);
          unint64_t v29 = *(void **)(v4 + 128);
          if (v29 != v6)
          {
            do
            {
              uint64_t result = (*(uint64_t (**)(void))(*(void *)v29[7] + 136))(v29[7]);
              BOOL v30 = (void *)v29[1];
              if (v30)
              {
                do
                {
                  uint64_t v31 = v30;
                  BOOL v30 = (void *)*v30;
                }
                while (v30);
              }
              else
              {
                do
                {
                  uint64_t v31 = (void *)v29[2];
                  BOOL v21 = *v31 == (void)v29;
                  unint64_t v29 = v31;
                }
                while (!v21);
              }
              unint64_t v29 = v31;
            }
            while (v31 != v6);
          }
        }
      }
      char v32 = (void *)v2[1];
      if (v32)
      {
        do
        {
          long long v33 = v32;
          char v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          long long v33 = (void *)v2[2];
          BOOL v21 = *v33 == (void)v2;
          int v2 = v33;
        }
        while (!v21);
      }
      int v2 = v33;
    }
    while (v33 != v3);
  }
  return result;
}

void sub_100975FB4(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/current_calls");
  v4[0] = off_101A215B0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100976068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100976094(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asString();
    uint64_t v4 = asString();
    uint64_t v5 = asString();
    if (*(char *)(a1 + 2895) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 2872), *(void *)(a1 + 2880));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 2872);
      uint64_t v11 = *(void *)(a1 + 2888);
    }
    if (v11 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    uint64_t v7 = asString();
    uint64_t v8 = asString();
    *(_DWORD *)long long buf = 136316418;
    uint64_t v13 = v3;
    __int16 v14 = 2080;
    uint64_t v15 = v4;
    __int16 v16 = 2080;
    uint64_t v17 = v5;
    __int16 v18 = 2080;
    char v19 = v6;
    __int16 v20 = 2080;
    uint64_t v21 = v7;
    __int16 v22 = 2080;
    uint64_t v23 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WRM Telephony mode change: {Telephony: %s, WiFiCalling: %s}  ->  { %s(%s), %s }, override: %s", buf, 0x3Eu);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 232))(*(void *)(a1 + 72));
}

void sub_10097622C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100976250(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 216))(a1);
    int v5 = 136315138;
    uint64_t v6 = asStringBool(v3);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I eSim ready: %s", (uint8_t *)&v5, 0xCu);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 240))(*(void *)(a1 + 72));
}

uint64_t sub_100976340(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 3048);
  char v3 = (void *)(result + 3056);
  if (v2 != (void *)(result + 3056))
  {
    uint64_t v5 = result;
    uint64_t v6 = (void **)(a2 + 8);
    do
    {
      if (v6 == sub_100046F68(a2, (void **)v2 + 4) || (uint64_t result = operator==(), (result & 1) == 0))
      {
        uint64_t v7 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *((unsigned __int8 *)v2 + 55);
          BOOL v9 = (v8 & 0x80u) != 0;
          if ((v8 & 0x80u) != 0) {
            uint64_t v8 = v2[5];
          }
          if (v9) {
            BOOL v10 = (const char *)v2[4];
          }
          else {
            BOOL v10 = (const char *)(v2 + 4);
          }
          BOOL v11 = v8 == 0;
          BOOL v12 = "<invalid>";
          if (!v11) {
            BOOL v12 = v10;
          }
          uint64_t v13 = "en";
          if (!*((unsigned char *)v2 + 60)) {
            uint64_t v13 = "dis";
          }
          __int16 v14 = "";
          if (*((_DWORD *)v2 + 14) == 2) {
            __int16 v14 = "(emergency)";
          }
          *(_DWORD *)long long buf = 136315650;
          __int16 v18 = v12;
          __int16 v19 = 2080;
          __int16 v20 = v13;
          __int16 v21 = 2080;
          __int16 v22 = v14;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I TTYMode: for PersonalityId: %s is %sabled %s", buf, 0x20u);
        }
        uint64_t result = (*(uint64_t (**)(void, void *, void *))(**(void **)(v5 + 72) + 272))(*(void *)(v5 + 72), v2 + 4, v2 + 7);
      }
      uint64_t v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          __int16 v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          __int16 v16 = (void *)v2[2];
          BOOL v11 = *v16 == (void)v2;
          int v2 = v16;
        }
        while (!v11);
      }
      int v2 = v16;
    }
    while (v16 != v3);
  }
  return result;
}

uint64_t sub_100976534(uint64_t a1, unsigned int *a2)
{
  unsigned int v4 = a2[1];
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (v4) {
      uint64_t v6 = "kTemporary";
    }
    else {
      uint64_t v6 = "kPermanent";
    }
    sub_100058DB0(__p, v6);
    if (v10 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I bringDownIms requested: ImsShutdownType=%s", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  return (*(uint64_t (**)(void, unsigned int *))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72), a2);
}

void sub_100976680(uint64_t a1, uint64_t a2)
{
  char v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ConnectionAvailability event", buf, 2u);
  }
  unsigned int v4 = *(void **)(a1 + 3080);
  if (v4 != (void *)(a1 + 3088))
  {
    uint64_t v5 = (void *)(a2 + 8);
    uint64_t v37 = a1 + 128;
    char v36 = (void **)(a1 + 136);
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v4 + 7);
      if (!*v5) {
        goto LABEL_17;
      }
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          BOOL v11 = (uint64_t *)v6;
        }
        else {
          BOOL v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 7)) {
        goto LABEL_17;
      }
      if (operator!=()) {
        break;
      }
LABEL_41:
      uint64_t v26 = (void *)v4[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v4[2];
          BOOL v28 = *v27 == (void)v4;
          unsigned int v4 = v27;
        }
        while (!v28);
      }
      unsigned int v4 = v27;
      uint64_t v5 = (void *)(a2 + 8);
      if (v27 == (void *)(a1 + 3088)) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v4 + 7);
LABEL_17:
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
    uint64_t v54 = 0;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    *(_OWORD *)uint64_t v42 = 0u;
    long long v43 = 0u;
    memset(v41, 0, sizeof(v41));
    *(_OWORD *)long long buf = 0u;
    sub_10004BD84((uint64_t)buf);
    for (uint64_t i = 0; i != 36; ++i)
    {
      ConnectionAvailabilityContainer::error();
      uint64_t v13 = *(void *)&v41[0];
      *(void *)((char *)&v41[1] + *(void *)(*(void *)&v41[0] - 24) + 8) = 2;
      *(_DWORD *)((char *)v41 + *(void *)(v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v41 + *(void *)(v13 - 24) + 8) & 0xFFFFFFB5 | 8;
      LOBYTE(__p[0]) = 48;
      sub_1004DC904(v41, (char *)__p);
      __int16 v14 = (void *)std::ostream::operator<<();
      sub_10004B96C(v14, (uint64_t)" ", 1);
    }
    PersonalityIdFromSlotId();
    uint64_t v15 = sub_100046F68(v37, __p);
    if (v39 < 0) {
      operator delete(__p[0]);
    }
    if (v36 != v15) {
      (*(void (**)(void *, void *))(*(void *)v15[7] + 24))(v15[7], v4 + 4);
    }
    if (*((_DWORD *)v4 + 7) != 1)
    {
LABEL_38:
      *(void *)long long buf = v34;
      *(void *)&buf[*(v34 - 3)] = v33;
      *(void *)&v41[0] = v32;
      if (SHIBYTE(v43) < 0) {
        operator delete(v42[1]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      goto LABEL_41;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a1 + 56), *(Registry **)(a1 + 56));
    uint64_t v17 = ServiceMap;
    if (v18 < 0)
    {
      __int16 v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v18;
    __int16 v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)__p);
    if (v22)
    {
      uint64_t v24 = v22[3];
      uint64_t v23 = v22[4];
      if (v23)
      {
        unint64_t v29 = (std::__shared_weak_count *)v22[4];
        BOOL v30 = (atomic_ullong *)(v23 + 8);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(v30, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
LABEL_32:
        (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v24 + 144))(__p, v24);
        uint64_t v25 = sub_100046F68(v37, __p);
        if (v39 < 0) {
          operator delete(__p[0]);
        }
        if (v36 != v25) {
          (*(void (**)(void *, void *))(*(void *)v25[7] + 24))(v25[7], v4 + 4);
        }
        if ((v31 & 1) == 0) {
          sub_10004D2C8(v29);
        }
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    unint64_t v29 = 0;
    char v31 = 1;
    goto LABEL_32;
  }
}

void sub_100976BD8(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  if ((a4 & 1) == 0) {
    sub_10004D2C8(a3);
  }
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100976C1C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 3104);
  int v2 = (void *)(a1 + 3112);
  if (v1 != (void *)(a1 + 3112))
  {
    uint64_t v3 = a1 + 128;
    unsigned int v4 = (Registry **)(a1 + 56);
    uint64_t v5 = (void **)(a1 + 136);
    while (1)
    {
      PersonalityIdFromSlotId();
      uint64_t v6 = sub_100046F68(v3, __p);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      if (v5 != v6) {
        (*(void (**)(void *, void *))(*(void *)v6[7] + 40))(v6[7], v1 + 5);
      }
      uint64_t v7 = (uint64_t *)*((unsigned int *)v1 + 8);
      if (v7 != 1) {
        goto LABEL_22;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *v4);
      int v9 = ServiceMap;
      if (v10 < 0)
      {
        BOOL v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v10;
      __int16 v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
      if (!v14) {
        break;
      }
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (!v15) {
        goto LABEL_15;
      }
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
LABEL_16:
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 144))(__p, v16);
      uint64_t v18 = sub_100046F68(v3, __p);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      if (v5 != v18) {
        (*(void (**)(void *, void *))(*(void *)v18[7] + 40))(v18[7], v1 + 5);
      }
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
LABEL_22:
      __int16 v19 = (void *)v1[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          __int16 v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v1[2];
          BOOL v21 = *v20 == (void)v1;
          uint64_t v1 = v20;
        }
        while (!v21);
      }
      uint64_t v1 = v20;
      if (v20 == v2) {
        return;
      }
    }
    uint64_t v16 = 0;
LABEL_15:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_16;
  }
}

void sub_100976E50(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100976E70(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I InternetConnectionAvailability update", buf, 2u);
  }
  uint64_t v3 = *(void **)(a1 + 3128);
  if (v3 == (void *)(a1 + 3136))
  {
LABEL_14:
    uint64_t v6 = 0;
  }
  else
  {
    while (1)
    {
      if (!*((_DWORD *)v3 + 8))
      {
        unsigned int v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v5 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v15 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I InternetConnection is available on %s", buf, 0xCu);
        }
        uint64_t v6 = *((unsigned int *)v3 + 7);
        if (v6 == *(_DWORD *)(a1 + 3176)) {
          break;
        }
      }
      uint64_t v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
      if (v8 == (void *)(a1 + 3136)) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v10 = *(void **)(a1 + 152);
  BOOL v11 = (void *)(a1 + 160);
  if (v10 != v11)
  {
    do
    {
      (*(void (**)(void, uint64_t))(*(void *)v10[7] + 32))(v10[7], v6);
      uint64_t v12 = (void *)v10[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v10[2];
          BOOL v9 = *v13 == (void)v10;
          uint64_t v10 = v13;
        }
        while (!v9);
      }
      uint64_t v10 = v13;
    }
    while (v13 != v11);
  }
}

void sub_10097704C(void *a1)
{
  char v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I InternetConnection update", (uint8_t *)&v14, 2u);
  }
  uint64_t v3 = (void *)a1[394];
  if (v3 == a1 + 395)
  {
LABEL_11:
    uint64_t v7 = 0;
  }
  else
  {
    while (*((_DWORD *)v3 + 16) != 2)
    {
      unsigned int v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          unsigned int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
      if (v5 == a1 + 395) {
        goto LABEL_11;
      }
    }
    uint64_t v8 = a1[5];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = subscriber::asString();
      int v14 = 136315138;
      uint64_t v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I InternetConnection is active on %s", (uint8_t *)&v14, 0xCu);
    }
    uint64_t v7 = *((unsigned int *)v3 + 8);
  }
  uint64_t v10 = (void *)a1[19];
  BOOL v11 = a1 + 20;
  if (v10 != v11)
  {
    do
    {
      (*(void (**)(void, uint64_t))(*(void *)v10[7] + 48))(v10[7], v7);
      uint64_t v12 = (void *)v10[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v10[2];
          BOOL v6 = *v13 == (void)v10;
          uint64_t v10 = v13;
        }
        while (!v6);
      }
      uint64_t v10 = v13;
    }
    while (v13 != v11);
  }
}

void sub_10097720C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) == 0x4000000)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x4000000, *(Registry **)(a1 + 56));
    uint64_t v5 = ServiceMap;
    if (v6 < 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
    if (v10)
    {
      uint64_t v12 = v10[3];
      BOOL v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
LABEL_18:
        (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v12 + 144))(__p, v12);
        uint64_t v16 = sub_100046F68(a1 + 128, __p);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
        if ((void **)(a1 + 136) != v16) {
          (*(void (**)(void *, uint64_t))(*(void *)v16[7] + 56))(v16[7], a2);
        }
        if ((v13 & 1) == 0) {
          sub_10004D2C8(v11);
        }
        return;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    BOOL v11 = 0;
    char v13 = 1;
    goto LABEL_18;
  }
  PersonalityIdFromSlotId();
  int v14 = sub_100046F68(a1 + 128, __p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 136) != v14) {
    (*(void (**)(void *, uint64_t))(*(void *)v14[7] + 56))(v14[7], a2);
  }
  PersonalityIdFromSlotId();
  uint64_t v15 = sub_100046F68(a1 + 152, __p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 160) != v15) {
    (*(void (**)(void *, uint64_t))(*(void *)v15[7] + 56))(v15[7], a2);
  }
}

void sub_100977468(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void **sub_100977488(void **result)
{
  uint64_t v1 = (void **)result[402];
  char v2 = result + 403;
  if (v1 != result + 403)
  {
    uint64_t v3 = result;
    uint64_t v4 = (uint64_t)(result + 16);
    uint64_t v5 = result + 17;
    do
    {
      uint64_t v6 = PersonalityIDToSimSlot();
      uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*(void *)v3[6] + 16))(v3[6], v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = (void *)*((unsigned __int8 *)v1 + 55);
        BOOL v9 = (char)v8 < 0;
        if ((char)v8 < 0) {
          uint64_t v8 = v1[5];
        }
        if (v9) {
          uint64_t v10 = (const char *)v1[4];
        }
        else {
          uint64_t v10 = (const char *)(v1 + 4);
        }
        if (v8) {
          BOOL v11 = v10;
        }
        else {
          BOOL v11 = "<invalid>";
        }
        uint64_t v12 = asStringBool(*((unsigned char *)v1 + 56));
        *(_DWORD *)long long buf = 136315394;
        char v17 = v11;
        __int16 v18 = 2080;
        uint64_t v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I IMS Handover for %s: %s", buf, 0x16u);
      }
      uint64_t result = sub_100046F68(v4, v1 + 4);
      if (v5 != result) {
        uint64_t result = (void **)(*(uint64_t (**)(void *, void))(*(void *)result[7] + 88))(result[7], *((unsigned __int8 *)v1 + 56));
      }
      char v13 = (void **)v1[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          char v13 = (void **)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void **)v1[2];
          BOOL v15 = *v14 == v1;
          uint64_t v1 = v14;
        }
        while (!v15);
      }
      uint64_t v1 = v14;
    }
    while (v14 != v2);
  }
  return result;
}

void sub_100977660(uint64_t a1, int *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)a2 + 4)) {
      uint64_t v5 = "";
    }
    else {
      uint64_t v5 = "not ";
    }
    int v14 = 136315394;
    BOOL v15 = v5;
    __int16 v16 = 2080;
    uint64_t v17 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DCN: %sdelivered for: %s", (uint8_t *)&v14, 0x16u);
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v7 = a1 + 112;
  uint64_t v6 = v8;
  if (v8)
  {
    int v9 = *a2;
    uint64_t v10 = v7;
    do
    {
      int v11 = *(_DWORD *)(v6 + 32);
      BOOL v12 = v11 < v9;
      if (v11 >= v9) {
        char v13 = (uint64_t *)v6;
      }
      else {
        char v13 = (uint64_t *)(v6 + 8);
      }
      if (!v12) {
        uint64_t v10 = v6;
      }
      uint64_t v6 = *v13;
    }
    while (*v13);
    if (v10 != v7 && v9 >= *(_DWORD *)(v10 + 32)) {
      (*(void (**)(void, void))(**(void **)(v10 + 40) + 24))(*(void *)(v10 + 40), *((unsigned __int8 *)a2 + 4));
    }
  }
}

void sub_1009777A4(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  int v5 = *(_DWORD *)(a1 + 3404);
  if (*(unsigned char *)(a1 + 3412)) {
    BOOL v6 = *(_DWORD *)(a1 + 3408) == 1;
  }
  else {
    BOOL v6 = 0;
  }
  int v7 = a3 & (HIDWORD(a2) == 1);
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = a3 & 1;
    if (v7) {
      uint64_t v10 = "";
    }
    else {
      uint64_t v10 = "not ";
    }
    unint64_t v29 = v10;
    uint64_t v28 = subscriber::asString();
    uint64_t v11 = asStringBool(v9);
    uint64_t v12 = EmCallTypeAsString();
    BOOL v13 = v6;
    if (v6) {
      int v14 = "";
    }
    else {
      int v14 = "not ";
    }
    uint64_t v15 = subscriber::asString();
    uint64_t v16 = asStringBool(*(unsigned char *)(a1 + 3412));
    *(_DWORD *)long long buf = 136316930;
    char v31 = v29;
    __int16 v32 = 2080;
    uint64_t v33 = v28;
    __int16 v34 = 2080;
    uint64_t v35 = v11;
    __int16 v36 = 2080;
    uint64_t v37 = v12;
    __int16 v38 = 2080;
    char v39 = v14;
    BOOL v6 = v13;
    __int16 v40 = 2080;
    uint64_t v41 = v15;
    __int16 v42 = 2080;
    uint64_t v43 = v16;
    __int16 v44 = 2080;
    uint64_t v45 = EmCallTypeAsString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I ECBM: %sactive (%s, %s, %s) -> %sactive (%s, %s, %s)", buf, 0x52u);
  }
  if (v7 != v6)
  {
    if (subscriber::isValidSimSlot())
    {
      uint64_t v17 = *(void *)(a1 + 112);
      if (v17)
      {
        uint64_t v18 = a1 + 112;
        do
        {
          int v19 = *(_DWORD *)(v17 + 32);
          BOOL v20 = v19 < v5;
          if (v19 >= v5) {
            BOOL v21 = (uint64_t *)v17;
          }
          else {
            BOOL v21 = (uint64_t *)(v17 + 8);
          }
          if (!v20) {
            uint64_t v18 = v17;
          }
          uint64_t v17 = *v21;
        }
        while (*v21);
        if (v18 != a1 + 112 && v5 >= *(_DWORD *)(v18 + 32)) {
          (*(void (**)(void, BOOL))(**(void **)(v18 + 40) + 16))(*(void *)(v18 + 40), v6);
        }
      }
    }
    else if (!v6)
    {
      __int16 v22 = *(void **)(a1 + 104);
      if (v22 != (void *)(a1 + 112))
      {
        do
        {
          uint64_t v23 = v22[5];
          uint64_t v24 = (std::__shared_weak_count *)v22[6];
          if (v24) {
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, void))(*(void *)v23 + 16))(v23, 0);
          if (v24) {
            sub_10004D2C8(v24);
          }
          uint64_t v25 = (void *)v22[1];
          if (v25)
          {
            do
            {
              uint64_t v26 = v25;
              uint64_t v25 = (void *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              uint64_t v26 = (void *)v22[2];
              BOOL v27 = *v26 == (void)v22;
              __int16 v22 = v26;
            }
            while (!v27);
          }
          __int16 v22 = v26;
        }
        while (v26 != (void *)(a1 + 112));
      }
    }
    (*(void (**)(void, BOOL))(**(void **)(a1 + 72) + 64))(*(void *)(a1 + 72), v6);
  }
}

void sub_100977A94(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100977AB4(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 3416));
    int v5 = 136315138;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Got EmergencyCallInProgress update: %s", (uint8_t *)&v5, 0xCu);
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 72) + 72))(*(void *)(a1 + 72), *(unsigned __int8 *)(a1 + 3416));
}

uint64_t sub_100977B84(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (void **)*a2;
  BOOL v27 = (void **)(a2 + 1);
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v4 = result + 3576;
    do
    {
      uint64_t result = (uint64_t)sub_100046F68(v2 + 3568, v3 + 4);
      if (v4 == result)
      {
        int v5 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = v3 + 4;
          if (*((char *)v3 + 55) < 0) {
            uint64_t v6 = v3[4];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v33 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I LazuliInfoReady: Lazuli stack disabled for PersonalityID=%s", buf, 0xCu);
        }
        uint64_t result = (*(uint64_t (**)(void, void **))(**(void **)(v2 + 72) + 344))(*(void *)(v2 + 72), v3 + 4);
      }
      int v7 = (void **)v3[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void **)v3[2];
          BOOL v9 = *v8 == v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != v27);
  }
  uint64_t v10 = *(void **)(v2 + 3568);
  uint64_t v11 = (void *)(v2 + 3576);
  if (v10 != (void *)(v2 + 3576))
  {
    uint64_t v25 = (void *)(v2 + 3576);
    uint64_t v24 = v2;
    do
    {
      uint64_t v12 = sub_100046F68((uint64_t)a2, (void **)v10 + 4);
      if (v27 == v12
        || (uint64_t result = (uint64_t)sub_100593F38((unsigned __int8 *)v12 + 56, (unsigned __int8 *)v10 + 56), (result & 1) == 0))
      {
        BOOL v13 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = v10 + 7;
          if (*((char *)v10 + 79) < 0) {
            int v14 = (void *)v10[7];
          }
          uint64_t v15 = v10 + 10;
          if (*((char *)v10 + 103) < 0) {
            uint64_t v15 = (void *)*v15;
          }
          sub_100594204((uint64_t)(v10 + 7), v30);
          if (v31 >= 0) {
            uint64_t v16 = v30;
          }
          else {
            uint64_t v16 = (void **)v30[0];
          }
          sub_100594408((uint64_t)(v10 + 7), __p);
          int v17 = v29;
          uint64_t v18 = (void **)__p[0];
          int v19 = sd::imsServiceMaskToUint();
          *(_DWORD *)long long buf = 136447234;
          BOOL v20 = __p;
          if (v17 < 0) {
            BOOL v20 = v18;
          }
          uint64_t v33 = v14;
          __int16 v34 = 2082;
          uint64_t v35 = v15;
          __int16 v36 = 2082;
          uint64_t v37 = v16;
          __int16 v38 = 2082;
          char v39 = v20;
          __int16 v40 = 1024;
          int v41 = v19;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I LazuliInfoReady: (domain: %{public}s, impi: %{public}s, impus: %{public}s, pcscfs: [%{public}s], services: 0x%02x", buf, 0x30u);
          if (v29 < 0) {
            operator delete(__p[0]);
          }
          if (v31 < 0) {
            operator delete(v30[0]);
          }
          uint64_t v2 = v24;
          BOOL v13 = *(NSObject **)(v24 + 40);
          uint64_t v11 = v25;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v21 = (void *)v10[26];
          *(_DWORD *)long long buf = 138543362;
          uint64_t v33 = v21;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I LazuliInfoDictionary: %{public}@", buf, 0xCu);
        }
        uint64_t result = sub_10059460C((uint64_t)(v10 + 7));
        if (result) {
          uint64_t result = (*(uint64_t (**)(void, void *, void *))(**(void **)(v2 + 72) + 336))(*(void *)(v2 + 72), v10 + 4, v10 + 7);
        }
      }
      __int16 v22 = (void *)v10[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          __int16 v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v10[2];
          BOOL v9 = *v23 == (void)v10;
          uint64_t v10 = v23;
        }
        while (!v9);
      }
      uint64_t v10 = v23;
    }
    while (v23 != v11);
  }
  return result;
}

void sub_100977F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_100977F60(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting EventHandler...", buf, 2u);
  }
  uint64_t v3 = *(uint64_t ***)(a1 + 2736);
  uint64_t v4 = *v3;
  int v5 = v3[1];
  if (*v3 != v5)
  {
    do
    {
      uint64_t v7 = *v4;
      uint64_t v6 = (std::__shared_weak_count *)v4[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v9 = (const char *)(v7 + 24);
        uint64_t v10 = *(unsigned __int8 *)(v7 + 47);
        int v11 = (char)v10;
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *(void *)(v7 + 32);
        }
        if (v11 < 0) {
          BOOL v9 = *(const char **)(v7 + 24);
        }
        *(_DWORD *)long long buf = 136315394;
        if (!v10) {
          BOOL v9 = "<invalid>";
        }
        BOOL v13 = "start";
        __int16 v14 = 2080;
        uint64_t v15 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Found PersonalityID: %s", buf, 0x16u);
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 296))(*(void *)(a1 + 72), v7 + 24);
      if (v6) {
        sub_10004D2C8(v6);
      }
      v4 += 2;
    }
    while (v4 != v5);
  }
}

void sub_10097811C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100978134(uint64_t a1)
{
  uint64_t v2 = (atomic_uint **)(a1 + 176);
  for (uint64_t i = *(void *)(a1 + 184); (atomic_uint **)i != v2; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84(v2);
  sub_1010B5C28(a1 + 3592);
  sub_100058DB0(__p, "/cc/events/domain_change_delivery_result");
  ctu::RestModule::unobserveEvent();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/connection_availability");
  ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/connection_state");
  ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/connection_activate_error");
  ctu::RestModule::unobserveEvent();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_1004CD70C();

  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 216));
}

void sub_100978268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sd::IMSSubscriberEventHandler::IMSSubscriberEventHandler(uint64_t a1, void *a2, NSObject **a3, uint64_t a4, void *a5)
{
  uint64_t v10 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v30, kCtLoggingSystemName, "5wi.evt");
  void *v10 = 0;
  v10[1] = 0;
  int v11 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v28, (const OsLogContext *)&v30);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v28);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v28);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
  v34[0] = off_101999E18;
  v34[1] = sub_100978F00;
  uint64_t v34[3] = v34;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v34);
  *(void *)a1 = off_101A1FC08;
  *(void *)(a1 + 56) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 64) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *a5;
  uint64_t v14 = a5[1];
  *(void *)(a1 + 80) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void))(**(void **)a4 + 112))();
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a1 + 176;
  *(void *)(a1 + 184) = a1 + 176;
  *(void *)(a1 + 192) = 0;
  (*(void (**)(void))(**(void **)a4 + 88))();
  sub_100058DB0(&__p, "IMSSubscriberEventHandler");
  uint64_t v15 = *(NSObject **)(a1 + 24);
  dispatch_object_t v25 = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  uint64_t v16 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v25) {
    dispatch_release(v25);
  }
  if (v27 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = a1 + 272;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = a1 + 328;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = a1 + 384;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = a1 + 440;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = a1 + 496;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 560) = 0;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 544) = a1 + 552;
  *(void *)(a1 + 592) = 0;
  *(void *)(a1 + 608) = 0;
  *(void *)(a1 + 616) = 0;
  *(void *)(a1 + 600) = a1 + 608;
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 664) = 0;
  *(void *)(a1 + 672) = 0;
  *(void *)(a1 + 656) = a1 + 664;
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 728) = 0;
  *(void *)(a1 + 712) = a1 + 720;
  *(unsigned char *)(a1 + 736) = 0;
  *(void *)(a1 + 752) = 0;
  *(void *)(a1 + 744) = a1 + 752;
  *(void *)(a1 + 760) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 768));
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 1568));
  sub_10005DF14((uint64_t *)(a1 + 2368), (uint64_t)&rest::kDefaultCsAttachedStates);
  *(void *)(a1 + 2408) = 0;
  *(void *)(a1 + 2400) = 0;
  *(void *)(a1 + 2392) = a1 + 2400;
  *(void *)(a1 + 2432) = 0;
  *(void *)(a1 + 2424) = 0;
  *(void *)(a1 + 2416) = a1 + 2424;
  *(void *)(a1 + 2448) = 0;
  *(void *)(a1 + 2464) = 0;
  *(void *)(a1 + 2456) = 0;
  *(void *)(a1 + 2488) = 0;
  *(void *)(a1 + 2480) = 0;
  *(void *)(a1 + 2472) = a1 + 2480;
  *(void *)(a1 + 2512) = 0;
  *(void *)(a1 + 2504) = 0;
  *(void *)(a1 + 2496) = a1 + 2504;
  *(void *)(a1 + 2528) = 0;
  *(void *)(a1 + 2536) = 0;
  *(void *)(a1 + 2520) = a1 + 2528;
  *(void *)(a1 + 2568) = 0;
  *(void *)(a1 + 2560) = 0;
  *(void *)(a1 + 2552) = a1 + 2560;
  sub_100058DB0(&v30, "IMSSubscriberEventHandler");
  PersonalitiesTracker::PersonalitiesTracker();
  if (SHIBYTE(v31.var1.fRef) < 0) {
    operator delete(v30);
  }
  v28[0] = (void *)1;
  OsLogContext v31 = (OsLogContext)0;
  BOOL v30 = &v31;
  sub_10005CDEC((uint64_t **)&v30, (uint64_t *)&v31, (int *)v28, (uint64_t *)v28);
  var0 = v31.var0;
  *(void *)(a1 + 2752) = v30;
  uint64_t v18 = a1 + 2760;
  *(void *)(a1 + 2760) = var0;
  fRef = v31.var1.fRef;
  *(void *)(a1 + 2768) = v31.var1.fRef;
  if (fRef)
  {
    *((void *)var0 + 2) = v18;
    BOOL v30 = &v31;
    OsLogContext v31 = (OsLogContext)0;
    var0 = 0;
  }
  else
  {
    *(void *)(a1 + 2752) = v18;
  }
  sub_1000346F8((uint64_t)&v30, var0);
  *(void *)(a1 + 2792) = 0;
  *(void *)(a1 + 2784) = 0;
  *(void *)(a1 + 2776) = a1 + 2784;
  *(void *)(a1 + 2816) = 0;
  *(void *)(a1 + 2808) = 0;
  *(void *)(a1 + 2800) = a1 + 2808;
  *(void *)(a1 + 2840) = 0;
  *(void *)(a1 + 2832) = 0;
  *(void *)(a1 + 2824) = a1 + 2832;
  *(unsigned char *)(a1 + 2848) = 0;
  *(void *)(a1 + 2852) = 0;
  sub_100058DB0(v28, "");
  LODWORD(v30) = 2;
  char v20 = HIBYTE(v29);
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(&v31, v28[0], (unint64_t)v28[1]);
    int v21 = (int)v30;
    char v20 = HIBYTE(v29);
  }
  else
  {
    OsLogContext v31 = *(OsLogContext *)v28;
    uint64_t v32 = v29;
    int v21 = 2;
  }
  int v33 = 0;
  *(_DWORD *)(a1 + 2864) = v21;
  *(OsLogContext *)(a1 + 2872) = v31;
  *(void *)(a1 + 2888) = v32;
  OsLogContext v31 = (OsLogContext)0;
  uint64_t v32 = 0;
  *(_DWORD *)(a1 + 2896) = 0;
  if (v20 < 0) {
    operator delete(v28[0]);
  }
  *(_DWORD *)(a1 + 2904) = 0;
  *(unsigned char *)(a1 + 2912) = 0;
  *(void *)(a1 + 3040) = 0;
  *(void *)(a1 + 3032) = 0;
  *(void *)(a1 + 3024) = a1 + 3032;
  *(void *)(a1 + 3064) = 0;
  *(void *)(a1 + 3056) = 0;
  *(void *)(a1 + 3048) = a1 + 3056;
  *(void *)(a1 + 3096) = 0;
  *(void *)(a1 + 3088) = 0;
  *(void *)(a1 + 3080) = a1 + 3088;
  *(void *)(a1 + 3120) = 0;
  *(void *)(a1 + 3112) = 0;
  *(void *)(a1 + 3104) = a1 + 3112;
  *(void *)(a1 + 3144) = 0;
  *(void *)(a1 + 3136) = 0;
  *(void *)(a1 + 3128) = a1 + 3136;
  *(void *)(a1 + 3160) = 0;
  *(void *)(a1 + 3168) = 0;
  *(void *)(a1 + 3152) = a1 + 3160;
  *(_DWORD *)(a1 + 3176) = 0;
  *(void *)(a1 + 3200) = 0;
  *(void *)(a1 + 3192) = 0;
  *(void *)(a1 + 3184) = a1 + 3192;
  *(void *)(a1 + 3224) = 0;
  *(void *)(a1 + 3216) = a1 + 3224;
  *(void *)(a1 + 3232) = 0;
  sub_10098AC2C((uint64_t *)(a1 + 3240), (uint64_t)&rest::kDefaultTrackingAreaUpdateTimers);
  *(void *)(a1 + 3288) = 0;
  *(void *)(a1 + 3280) = 0;
  *(void *)(a1 + 3272) = a1 + 3280;
  *(void *)(a1 + 3320) = 0;
  *(void *)(a1 + 3312) = 0;
  *(void *)(a1 + 3304) = a1 + 3312;
  *(void *)(a1 + 3344) = 0;
  *(void *)(a1 + 3336) = 0;
  *(void *)(a1 + 3328) = a1 + 3336;
  *(void *)(a1 + 3368) = 0;
  *(void *)(a1 + 3360) = 0;
  *(void *)(a1 + 3352) = a1 + 3360;
  *(void *)(a1 + 3392) = 0;
  *(void *)(a1 + 3384) = 0;
  *(void *)(a1 + 3376) = a1 + 3384;
  *(_DWORD *)(a1 + 3400) = 1;
  *(unsigned char *)(a1 + 3412) = 0;
  *(void *)(a1 + 3404) = 0;
  *(_WORD *)(a1 + 3416) = 0;
  sub_100313408((uint64_t *)(a1 + 3424), (uint64_t)&kDefaultBasebandServiceProvisionedStates);
  *(void *)(a1 + 3480) = 0;
  *(void *)(a1 + 3504) = 0;
  *(void *)(a1 + 3496) = 0;
  *(void *)(a1 + 3488) = a1 + 3496;
  *(void *)(a1 + 3536) = 0;
  *(void *)(a1 + 3560) = 0;
  *(void *)(a1 + 3552) = 0;
  *(void *)(a1 + 3544) = a1 + 3552;
  *(void *)(a1 + 3584) = 0;
  *(void *)(a1 + 3576) = 0;
  *(void *)(a1 + 3568) = a1 + 3576;
  __int16 v22 = *(NSObject **)(a1 + 24);
  uint64_t v23 = v22;
  if (v22) {
    dispatch_retain(v22);
  }
  sub_1010B5B50((void *)(a1 + 3592), a2, &v23);
}

void sub_100978A80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PersonalitiesTracker *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,ctu::OsLogLogger *a21,uint64_t a22,uint64_t a23,dispatch_object_t object,dispatch_object_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  sub_10008863C((void *)(v37 - 168));
  operator delete();
}

void sub_100978ED0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a29);
  sub_100087E88(v29);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v30 - 168));
  JUMPOUT(0x100978EC0);
}

void sub_100978EF8()
{
}

const char *sub_100978F00(int a1)
{
  uint64_t v1 = "5wi.evt.?";
  if (a1 == 2) {
    uint64_t v1 = "5wi.evt.2";
  }
  if (a1 == 1) {
    return "5wi.evt.1";
  }
  else {
    return v1;
  }
}

void sub_100978F2C(void **a1, uint64_t a2, void *a3)
{
  uint64_t v6 = PersonalityIDToSimSlot();
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], v6);
  unsigned int v8 = (*(uint64_t (**)(void))(*(void *)*a3 + 16))();
  BOOL v9 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sd::asString();
    uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
    BOOL v12 = (v11 & 0x80u) != 0;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a2 + 8);
    }
    if (v12) {
      uint64_t v13 = *(const char **)a2;
    }
    else {
      uint64_t v13 = (const char *)a2;
    }
    if (v11) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Registering ConnectivityHelper %s event delegate for subscriber %s.", buf, 0x16u);
  }
  if (v8 == 2)
  {
    uint64_t v15 = (void ***)(a1 + 19);
    uint64_t v16 = sub_100046F68((uint64_t)(a1 + 19), (void **)a2);
    int v17 = v16;
    if (a1 + 20 != (void **)v16)
    {
      uint64_t v18 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = *(unsigned __int8 *)(a2 + 23);
        BOOL v20 = (v19 & 0x80u) != 0;
        if ((v19 & 0x80u) != 0) {
          uint64_t v19 = *(void *)(a2 + 8);
        }
        if (v20) {
          int v21 = *(const char **)a2;
        }
        else {
          int v21 = (const char *)a2;
        }
        if (v19) {
          __int16 v22 = v21;
        }
        else {
          __int16 v22 = "<invalid>";
        }
        (*(void (**)(void *))(*(void *)v17[7] + 16))(v17[7]);
        uint64_t v23 = sd::asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v23;
        uint64_t v24 = "ConnectivityHelper event delegate for Lazuli %s is already registered with type %s";
LABEL_34:
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v24, buf, 0x16u);
        return;
      }
      return;
    }
    uint64_t v32 = *v15;
    if (*v15 == v16)
    {
LABEL_47:
      uint64_t v32 = v17;
    }
    else
    {
      while (1)
      {
        sub_10097ED30(buf, (long long *)v32 + 2);
        int v33 = (*(uint64_t (**)(void *))(*v51 + 16))(v51);
        if (v52) {
          sub_10004D2C8(v52);
        }
        if (v50 < 0) {
          operator delete(*(void **)buf);
        }
        if (v33 == 2) {
          break;
        }
        __int16 v34 = (void **)v32[1];
        if (v34)
        {
          do
          {
            uint64_t v35 = v34;
            __int16 v34 = (void **)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v35 = (void **)v32[2];
            BOOL v36 = *v35 == v32;
            uint64_t v32 = v35;
          }
          while (!v36);
        }
        uint64_t v32 = v35;
        if (v35 == v17) {
          goto LABEL_47;
        }
      }
    }
    sub_1002B3068(buf, (long long *)a2, a3);
    sub_10098AC84(a1 + 19, (void **)buf, (uint64_t)buf);
LABEL_63:
    if (v52) {
      sub_10004D2C8(v52);
    }
    if (v50 < 0) {
      operator delete(*(void **)buf);
    }
    if (v32 == v17)
    {
      __int16 v40 = *v7;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = sd::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v41;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I First use of ConnectivityHelper %s - setting up events", buf, 0xCu);
      }
      if (v8)
      {
        if (v8 <= 2)
        {
          sub_100058DB0(__p, "/cc/props/cellular_data_blocklisted_apps");
          __int16 v42 = operator new(0x28uLL);
          *__int16 v42 = off_101A221F0;
          v42[1] = a1 + 409;
          v42[2] = a1;
          v42[3] = sub_10097A1F0;
          v42[4] = 0;
          long long v51 = v42;
          ctu::RestModule::observeProperty();
          sub_10003F600(buf);
          if (v48 < 0) {
            operator delete(__p[0]);
          }
          *(void *)long long buf = sub_100979B58;
          *(void *)&uint8_t buf[8] = 0;
          sub_10098B524((uint64_t)(a1 + 27), (uint64_t)a1, (uint64_t *)buf);
        }
      }
      else
      {
        sub_100058DB0(__p, "/cc/events/data_context_activation_blocked");
        uint64_t v43 = operator new(0x20uLL);
        void *v43 = off_101A21F70;
        v43[1] = a1;
        v43[2] = sub_10097974C;
        v43[3] = 0;
        long long v51 = v43;
        ctu::RestModule::observeEvent();
        sub_10003F600(buf);
        if (v48 < 0) {
          operator delete(__p[0]);
        }
        sub_100058DB0(__p, "/cc/props/ims_pref");
        __int16 v44 = operator new(0x28uLL);
        void *v44 = off_101A21FF0;
        v44[1] = a1 + 398;
        v44[2] = a1;
        v44[3] = sub_100979958;
        uint8_t v44[4] = 0;
        long long v51 = v44;
        ctu::RestModule::observeProperty();
        sub_10003F600(buf);
        if (v48 < 0) {
          operator delete(__p[0]);
        }
        *(void *)long long buf = sub_100979B58;
        *(void *)&uint8_t buf[8] = 0;
        sub_10098B524((uint64_t)(a1 + 27), (uint64_t)a1, (uint64_t *)buf);
        sub_100058DB0(__p, "/cc/events/ims_pco");
        uint64_t v45 = operator new(0x20uLL);
        void *v45 = off_101A220F0;
        v45[1] = a1;
        void v45[2] = sub_100979EAC;
        v45[3] = 0;
        long long v51 = v45;
        ctu::RestModule::observeEvent();
        sub_10003F600(buf);
        if (v48 < 0) {
          operator delete(__p[0]);
        }
        sub_100058DB0(__p, "/cc/props/tracking_area_update_timers");
        long long v46 = operator new(0x28uLL);
        *long long v46 = off_101A22170;
        v46[1] = a1 + 405;
        void v46[2] = a1;
        v46[3] = sub_10097A004;
        v46[4] = 0;
        long long v51 = v46;
        ctu::RestModule::observeProperty();
        sub_10003F600(buf);
        if (v48 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    return;
  }
  dispatch_object_t v25 = (void ***)(a1 + 16);
  uint64_t v26 = sub_100046F68((uint64_t)(a1 + 16), (void **)a2);
  int v17 = v26;
  if (a1 + 17 == (void **)v26)
  {
    uint64_t v32 = *v25;
    if (*v25 == v26)
    {
LABEL_61:
      uint64_t v32 = v17;
    }
    else
    {
      while (1)
      {
        sub_10097ED30(buf, (long long *)v32 + 2);
        int v37 = (*(uint64_t (**)(void *))(*v51 + 16))(v51);
        if (v52) {
          sub_10004D2C8(v52);
        }
        if (v50 < 0) {
          operator delete(*(void **)buf);
        }
        if (v37 == v8) {
          break;
        }
        __int16 v38 = (void **)v32[1];
        if (v38)
        {
          do
          {
            char v39 = v38;
            __int16 v38 = (void **)*v38;
          }
          while (v38);
        }
        else
        {
          do
          {
            char v39 = (void **)v32[2];
            BOOL v36 = *v39 == v32;
            uint64_t v32 = v39;
          }
          while (!v36);
        }
        uint64_t v32 = v39;
        if (v39 == v17) {
          goto LABEL_61;
        }
      }
    }
    sub_1002B3068(buf, (long long *)a2, a3);
    sub_10098AC84(a1 + 16, (void **)buf, (uint64_t)buf);
    goto LABEL_63;
  }
  uint64_t v18 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = *(unsigned __int8 *)(a2 + 23);
    BOOL v28 = (v27 & 0x80u) != 0;
    if ((v27 & 0x80u) != 0) {
      uint64_t v27 = *(void *)(a2 + 8);
    }
    if (v28) {
      uint64_t v29 = *(const char **)a2;
    }
    else {
      uint64_t v29 = (const char *)a2;
    }
    if (v27) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = "<invalid>";
    }
    (*(void (**)(void *))(*(void *)v17[7] + 16))(v17[7]);
    uint64_t v31 = sd::asString();
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v30;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v31;
    uint64_t v24 = "ConnectivityHelper event delegate for subscriber %s is already registered with type %s";
    goto LABEL_34;
  }
}

void sub_1009796DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10097974C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) == 0x4000000)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x4000000, *(Registry **)(a1 + 56));
    int v5 = ServiceMap;
    if (v6 < 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
    if (v10)
    {
      uint64_t v12 = v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
LABEL_14:
        (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v12 + 144))(__p, v12);
        uint64_t v15 = sub_100046F68(a1 + 128, __p);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
        if ((void **)(a1 + 136) != v15) {
          (*(void (**)(void *, uint64_t))(*(void *)v15[7] + 64))(v15[7], a2);
        }
        if ((v13 & 1) == 0) {
          sub_10004D2C8(v11);
        }
        return;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    goto LABEL_14;
  }
  PersonalityIdFromSlotId();
  uint64_t v14 = sub_100046F68(a1 + 128, __p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 136) != v14) {
    (*(void (**)(void *, uint64_t))(*(void *)v14[7] + 64))(v14[7], a2);
  }
}

void sub_100979938(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void **sub_100979958(void **result)
{
  uint64_t v1 = (void **)result[398];
  char v2 = result + 399;
  if (v1 != result + 399)
  {
    uint64_t v3 = result;
    uint64_t v4 = (uint64_t)(result + 16);
    int v5 = result + 17;
    do
    {
      uint64_t v6 = PersonalityIDToSimSlot();
      uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*(void *)v3[6] + 16))(v3[6], v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = (void *)*((unsigned __int8 *)v1 + 55);
        BOOL v9 = (char)v8 < 0;
        if ((char)v8 < 0) {
          uint64_t v8 = v1[5];
        }
        if (v9) {
          uint64_t v10 = (const char *)v1[4];
        }
        else {
          uint64_t v10 = (const char *)(v1 + 4);
        }
        if (v8) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = "<invalid>";
        }
        uint64_t v12 = asString();
        uint64_t v13 = sd::asString();
        uint64_t v14 = sd::asString();
        *(_DWORD *)long long buf = 136315906;
        uint64_t v19 = v11;
        __int16 v20 = 2080;
        uint64_t v21 = v12;
        __int16 v22 = 2080;
        uint64_t v23 = v13;
        __int16 v24 = 2080;
        uint64_t v25 = v14;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I IMS Pref for %s: ct=%s, bb_mask=[%s], tech_mask=[%s]", buf, 0x2Au);
      }
      uint64_t result = sub_100046F68(v4, v1 + 4);
      if (v5 != result) {
        uint64_t result = (void **)(*(uint64_t (**)(void *, void **))(*(void *)result[7] + 72))(result[7], v1 + 7);
      }
      uint64_t v15 = (void **)v1[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void **)v1[2];
          BOOL v17 = *v16 == v1;
          uint64_t v1 = v16;
        }
        while (!v17);
      }
      uint64_t v1 = v16;
    }
    while (v16 != v2);
  }
  return result;
}

void sub_100979B58(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asString();
    uint64_t v6 = asString();
    uint64_t v7 = asString();
    unsigned int v8 = a2[4];
    *(_DWORD *)std::string __p = 136315906;
    *(void *)&__p[4] = v5;
    __int16 v26 = 2080;
    uint64_t v27 = v6;
    __int16 v28 = 2080;
    uint64_t v29 = v7;
    __int16 v30 = 1024;
    unsigned int v31 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I iRatChangeEvent: appType: %s, dataContextType: %s, transportType: %s, reasonCode: %u", __p, 0x26u);
  }
  PersonalityIdFromSlotId();
  uint64_t v9 = a1 + 128;
  uint64_t v10 = sub_100046F68(a1 + 128, (void **)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v11 = (void **)(a1 + 136);
  if ((void **)(a1 + 136) != v10) {
    (*(void (**)(void *, void, void, void, void))(*(void *)v10[7] + 120))(v10[7], a2[1], a2[2], a2[3], a2[4]);
  }
  PersonalityIdFromSlotId();
  uint64_t v12 = sub_100046F68(a1 + 152, (void **)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)__p);
  }
  if ((void **)(a1 + 160) != v12) {
    (*(void (**)(void *, void, void, void, void))(*(void *)v12[7] + 120))(v12[7], a2[1], a2[2], a2[3], a2[4]);
  }
  uint64_t v13 = (uint64_t *)*a2;
  if (v13 == 1)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 56));
    uint64_t v15 = ServiceMap;
    if (v16 < 0)
    {
      BOOL v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string __p = v16;
    __int16 v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)__p);
    if (v20)
    {
      uint64_t v22 = v20[3];
      uint64_t v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_20:
        (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v22 + 144))(__p, v22);
        __int16 v24 = sub_100046F68(v9, (void **)__p);
        if (SHIBYTE(v28) < 0) {
          operator delete(*(void **)__p);
        }
        if (v11 != v24 && a2[1] == 1) {
          (*(void (**)(void *, uint64_t, void, void, void))(*(void *)v24[7] + 120))(v24[7], 1, a2[2], a2[3], a2[4]);
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        return;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    uint64_t v21 = 0;
    char v23 = 1;
    goto LABEL_20;
  }
}

void sub_100979E78(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void **sub_100979EAC(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4 = PersonalityIDToSimSlot();
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *((unsigned __int8 *)a2 + 23);
    BOOL v7 = (v6 & 0x80u) != 0;
    if ((v6 & 0x80u) != 0) {
      uint64_t v6 = *((void *)a2 + 1);
    }
    if (v7) {
      unsigned int v8 = *(const char **)a2;
    }
    else {
      unsigned int v8 = (const char *)a2;
    }
    if (v6) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = "<invalid>";
    }
    int v10 = a2[12];
    int v12 = 136315394;
    uint64_t v13 = v9;
    __int16 v14 = 1024;
    int v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMS Pco for %s: containerId=0x%04x", (uint8_t *)&v12, 0x12u);
  }
  uint64_t result = sub_100046F68(a1 + 128, (void **)a2);
  if ((void **)(a1 + 136) != result) {
    return (void **)(*(uint64_t (**)(void *, unsigned __int16 *))(*(void *)result[7] + 80))(result[7], a2 + 12);
  }
  return result;
}

void sub_10097A004(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 3256))
  {
    char v2 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v3 = *(void **)(a1 + 3240);
    uint64_t v4 = v3;
    while (1)
    {
      BOOL v5 = *((_DWORD *)v2 + 7) == *((_DWORD *)v4 + 7) && *((_DWORD *)v2 + 8) == *((_DWORD *)v4 + 8);
      if (!v5) {
        break;
      }
      uint64_t v6 = (void *)v2[1];
      BOOL v7 = v2;
      if (v6)
      {
        do
        {
          char v2 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          char v2 = (void *)v7[2];
          BOOL v5 = *v2 == (void)v7;
          BOOL v7 = v2;
        }
        while (!v5);
      }
      unsigned int v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          unsigned int v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v4[2];
          BOOL v5 = *v9 == (void)v4;
          uint64_t v4 = v9;
        }
        while (!v5);
      }
      uint64_t v4 = v9;
      if (v2 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 3240);
  }
  int v10 = (void *)(a1 + 3248);
  if (v3 != (void *)(a1 + 3248))
  {
    uint64_t v11 = a2 + 1;
    uint64_t v12 = a1 + 128;
    uint64_t v13 = (void **)(a1 + 136);
    do
    {
      uint64_t v14 = *v11;
      int v15 = *((_DWORD *)v3 + 7);
      if (!*v11) {
        goto LABEL_35;
      }
      uint64_t v16 = v11;
      do
      {
        int v17 = *(_DWORD *)(v14 + 28);
        BOOL v18 = v17 < v15;
        if (v17 >= v15) {
          unsigned int v19 = (uint64_t *)v14;
        }
        else {
          unsigned int v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          uint64_t v16 = (void *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 == v11 || v15 < *((_DWORD *)v16 + 7) || *((_DWORD *)v16 + 8) != *((_DWORD *)v3 + 8))
      {
LABEL_35:
        PersonalityIdFromSlotId();
        __int16 v20 = sub_100046F68(v12, &__p);
        if (v24 < 0) {
          operator delete(__p);
        }
        if (v13 != v20) {
          (*(void (**)(void *, void))(*(void *)v20[7] + 96))(v20[7], *((unsigned int *)v3 + 8));
        }
      }
      uint64_t v21 = (void *)v3[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v22 = (void *)v3[2];
          BOOL v5 = *v22 == (void)v3;
          uint64_t v3 = v22;
        }
        while (!v5);
      }
      uint64_t v3 = v22;
    }
    while (v22 != v10);
  }
}

void sub_10097A1F0(void *a1, void *a2)
{
  uint64_t v3 = (unsigned __int8 **)(a1 + 409);
  if (a2[2] == a1[411])
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 1);
    BOOL v5 = (unsigned __int8 *)*a2;
    if ((void *)*a2 == a2 + 1)
    {
LABEL_16:
      uint64_t v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v17[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I BlocklistedApps: no change", (uint8_t *)v17, 2u);
      }
      return;
    }
    uint64_t v6 = *v3;
    while ((sub_1000609C0((uint64_t)&v18, v5 + 32, v6 + 32) & 1) != 0)
    {
      BOOL v7 = (unsigned __int8 *)*((void *)v5 + 1);
      unsigned int v8 = v5;
      if (v7)
      {
        do
        {
          BOOL v5 = v7;
          BOOL v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v5 = (unsigned __int8 *)*((void *)v8 + 2);
          BOOL v9 = *(void *)v5 == (void)v8;
          unsigned int v8 = v5;
        }
        while (!v9);
      }
      int v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          int v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (unsigned __int8 *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v5 == v4) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v13 = (void *)a1[16];
  uint64_t v14 = a1 + 17;
  if (v13 != v14)
  {
    do
    {
      (*(void (**)(void, unsigned __int8 **))(*(void *)v13[7] + 112))(v13[7], v3);
      int v15 = (void *)v13[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v13[2];
          BOOL v9 = *v16 == (void)v13;
          uint64_t v13 = v16;
        }
        while (!v9);
      }
      uint64_t v13 = v16;
    }
    while (v16 != v14);
  }
}

void sub_10097A380(void **a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = PersonalityIDToSimSlot();
  BOOL v7 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], v6);
  unsigned int v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    BOOL v10 = (v9 & 0x80u) != 0;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    if (v10) {
      uint64_t v11 = *(const char **)a2;
    }
    else {
      uint64_t v11 = (const char *)a2;
    }
    if (v9) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = "<invalid>";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Unregistering ConnectivityHelper event delegate for subscriber %s.", __p, 0xCu);
  }
  if (a3 == 2)
  {
    uint64_t v13 = (uint64_t *)sub_100046F68((uint64_t)(a1 + 19), (void **)a2);
    uint64_t v14 = (long long *)(a1 + 20);
    if (a1 + 20 != (void **)v13)
    {
      int v15 = v13;
      sub_1000F5B04(a1 + 19, v13);
      sub_1001FEC1C((uint64_t)(v15 + 4));
      operator delete(v15);
      uint64_t v16 = (long long *)a1[19];
      if (v16 != v14)
      {
        while (1)
        {
          sub_10097ED30(__p, v16 + 2);
          int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 16))(v39);
          if (v40) {
            sub_10004D2C8(v40);
          }
          if (v38 < 0) {
            operator delete(*(void **)__p);
          }
          if (v17 == 2) {
            goto LABEL_40;
          }
          char v18 = (long long *)*((void *)v16 + 1);
          if (v18)
          {
            do
            {
              unsigned int v19 = v18;
              char v18 = *(long long **)v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              unsigned int v19 = (long long *)*((void *)v16 + 2);
              BOOL v20 = *(void *)v19 == (void)v16;
              uint64_t v16 = v19;
            }
            while (!v20);
          }
          uint64_t v16 = v19;
          if (v19 == v14) {
            goto LABEL_41;
          }
        }
      }
      goto LABEL_41;
    }
    __int16 v28 = *v7;
    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v29 = *(unsigned __int8 *)(a2 + 23);
    BOOL v30 = (v29 & 0x80u) != 0;
    if ((v29 & 0x80u) != 0) {
      uint64_t v29 = *(void *)(a2 + 8);
    }
    if (v30) {
      unsigned int v31 = *(const char **)a2;
    }
    else {
      unsigned int v31 = (const char *)a2;
    }
    if (v29) {
      uint64_t v32 = v31;
    }
    else {
      uint64_t v32 = "<invalid>";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v32;
LABEL_76:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "ConnectivityHelper event delegate is not registered for %s", __p, 0xCu);
    return;
  }
  uint64_t v21 = (uint64_t *)sub_100046F68((uint64_t)(a1 + 16), (void **)a2);
  uint64_t v14 = (long long *)(a1 + 17);
  if (a1 + 17 == (void **)v21)
  {
    __int16 v28 = *v7;
    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v33 = *(unsigned __int8 *)(a2 + 23);
    BOOL v34 = (v33 & 0x80u) != 0;
    if ((v33 & 0x80u) != 0) {
      uint64_t v33 = *(void *)(a2 + 8);
    }
    if (v34) {
      uint64_t v35 = *(const char **)a2;
    }
    else {
      uint64_t v35 = (const char *)a2;
    }
    if (v33) {
      BOOL v36 = v35;
    }
    else {
      BOOL v36 = "<invalid>";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v36;
    goto LABEL_76;
  }
  uint64_t v22 = v21;
  sub_1000F5B04(a1 + 16, v21);
  sub_1001FEC1C((uint64_t)(v22 + 4));
  operator delete(v22);
  uint64_t v16 = (long long *)a1[16];
  if (v16 != v14)
  {
    while (1)
    {
      sub_10097ED30(__p, v16 + 2);
      int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 16))(v39);
      if (v40) {
        sub_10004D2C8(v40);
      }
      if (v38 < 0) {
        operator delete(*(void **)__p);
      }
      if (v23 == a3) {
        break;
      }
      char v24 = (long long *)*((void *)v16 + 1);
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          char v24 = *(long long **)v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (long long *)*((void *)v16 + 2);
          BOOL v20 = *(void *)v25 == (void)v16;
          uint64_t v16 = v25;
        }
        while (!v20);
      }
      uint64_t v16 = v25;
      if (v25 == v14) {
        goto LABEL_41;
      }
    }
LABEL_40:
    if (v14 != v16) {
      return;
    }
  }
LABEL_41:
  __int16 v26 = *v7;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = sd::asString();
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I No more ConnectivityHelper %s left - cleaning up events", __p, 0xCu);
  }
  if (a3)
  {
    if (a3 > 2) {
      return;
    }
    sub_10097A8D0();
    sub_100058DB0(__p, "/cc/props/cellular_data_blocklisted_apps");
    ctu::RestModule::unobserveProperty();
  }
  else
  {
    sub_100058DB0(__p, "/cc/events/data_context_activation_blocked");
    ctu::RestModule::unobserveEvent();
    if (v38 < 0) {
      operator delete(*(void **)__p);
    }
    sub_100058DB0(__p, "/cc/props/ims_pref");
    ctu::RestModule::unobserveProperty();
    if (v38 < 0) {
      operator delete(*(void **)__p);
    }
    sub_10097A8D0();
    sub_100058DB0(__p, "/cc/events/ims_pco");
    ctu::RestModule::unobserveEvent();
    if (v38 < 0) {
      operator delete(*(void **)__p);
    }
    sub_100058DB0(__p, "/cc/props/tracking_area_update_timers");
    ctu::RestModule::unobserveProperty();
  }
  if (v38 < 0) {
    operator delete(*(void **)__p);
  }
}

void sub_10097A888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097A8D0()
{
  sub_100058DB0(&__p, "/cc/events/irat_change");
  ctu::RestModule::unobserveEvent();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_10097A924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097A940(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Registering DCN event delegate.", buf, 2u);
  }
  unsigned int v8 = (uint64_t *)(a1 + 112);
  uint64_t v9 = *(_DWORD **)(a1 + 112);
  BOOL v10 = (void **)(a1 + 104);
  if (v9)
  {
    uint64_t v11 = a1 + 112;
    uint64_t v12 = *(void *)(a1 + 112);
    do
    {
      int v13 = *(_DWORD *)(v12 + 32);
      BOOL v14 = v13 < a2;
      if (v13 >= a2) {
        int v15 = (uint64_t *)v12;
      }
      else {
        int v15 = (uint64_t *)(v12 + 8);
      }
      if (!v14) {
        uint64_t v11 = v12;
      }
      uint64_t v12 = *v15;
    }
    while (*v15);
    if ((uint64_t *)v11 != v8 && *(_DWORD *)(v11 + 32) <= a2)
    {
      uint64_t v16 = *v6;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)
        || (v28[0] = 0,
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "DCN event delegate is already registered. Overwriting.", (uint8_t *)v28, 2u), (uint64_t v9 = (_DWORD *)*v8) != 0))
      {
        int v17 = (uint64_t *)(a1 + 112);
        do
        {
          int v18 = v9[8];
          BOOL v19 = v18 < a2;
          if (v18 >= a2) {
            BOOL v20 = v9;
          }
          else {
            BOOL v20 = v9 + 2;
          }
          if (!v19) {
            int v17 = (uint64_t *)v9;
          }
          uint64_t v9 = (_DWORD *)*v20;
        }
        while (*v20);
        if (v17 != v8 && *((_DWORD *)v17 + 8) <= a2) {
          sub_10098BE10((uint64_t **)(a1 + 104), v17);
        }
      }
    }
  }
  uint64_t v22 = *a3;
  uint64_t v21 = (std::__shared_weak_count *)a3[1];
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v23 = (uint64_t *)*v8;
  char v24 = (uint64_t *)(a1 + 112);
  if (*v8)
  {
    while (1)
    {
      while (1)
      {
        char v24 = v23;
        int v25 = *((_DWORD *)v23 + 8);
        if (v25 <= a2) {
          break;
        }
        int v23 = (uint64_t *)*v24;
        unsigned int v8 = v24;
        if (!*v24) {
          goto LABEL_33;
        }
      }
      if (v25 >= a2) {
        break;
      }
      int v23 = (uint64_t *)v24[1];
      if (!v23)
      {
        unsigned int v8 = v24 + 1;
        goto LABEL_33;
      }
    }
    if (v21) {
      sub_10004D2C8(v21);
    }
  }
  else
  {
LABEL_33:
    __int16 v26 = operator new(0x38uLL);
    v26[8] = a2;
    *((void *)v26 + 5) = v22;
    *((void *)v26 + 6) = v21;
    *(void *)__int16 v26 = 0;
    *((void *)v26 + 1) = 0;
    *((void *)v26 + 2) = v24;
    uint64_t *v8 = (uint64_t)v26;
    uint64_t v27 = (void *)**v10;
    if (v27)
    {
      unsigned __int8 *v10 = v27;
      __int16 v26 = (_DWORD *)*v8;
    }
    sub_100046C90(*(uint64_t **)(a1 + 112), (uint64_t *)v26);
    ++*(void *)(a1 + 120);
  }
}

void sub_10097AB68(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097AB80(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315138;
    uint64_t v15 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Unregistering DCN event delegate: %s", (uint8_t *)&v14, 0xCu);
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v7 = a1 + 112;
  uint64_t v6 = v8;
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = v7;
  do
  {
    int v10 = *(_DWORD *)(v6 + 32);
    BOOL v11 = v10 < a2;
    if (v10 >= a2) {
      uint64_t v12 = (uint64_t *)v6;
    }
    else {
      uint64_t v12 = (uint64_t *)(v6 + 8);
    }
    if (!v11) {
      uint64_t v9 = v6;
    }
    uint64_t v6 = *v12;
  }
  while (*v12);
  if (v9 != v7 && *(_DWORD *)(v9 + 32) <= a2)
  {
    sub_10098BE10((uint64_t **)(v7 - 8), (uint64_t *)v9);
  }
  else
  {
LABEL_13:
    int v13 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "DCN event delegate is not registered", (uint8_t *)&v14, 2u);
    }
  }
}

uint64_t sub_10097ACE0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 736);
}

BOOL sub_10097ACE8(uint64_t a1)
{
  uint64_t v2 = a1 + 2824;
  PersonalityIdFromSlotId();
  uint64_t v3 = sub_100046F68(v2, &__p);
  if (v6 < 0) {
    operator delete(__p);
  }
  return (void **)(a1 + 2832) != v3 && *((unsigned char *)v3 + 56) != 0;
}

void sub_10097AD60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10097AD7C(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_100046F68(a1 + 2824, a2);
  return (void **)(a1 + 2832) != v3 && *((unsigned char *)v3 + 57) && *((unsigned char *)v3 + 56) != 0;
}

uint64_t sub_10097ADCC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 2448);
  uint64_t v5 = *(void *)(a1 + 2456);
  if (v4 != v5)
  {
    while (*(_DWORD *)v4 != a2)
    {
      v4 += 168;
      if (v4 == v5) {
        return 0;
      }
    }
  }
  if (v4 == v5) {
    return 0;
  }
  *(_OWORD *)a3 = *(_OWORD *)v4;
  if (v4 != a3)
  {
    sub_10008A534((char *)(a3 + 16), *(char **)(v4 + 16), *(void *)(v4 + 24), (uint64_t)(*(void *)(v4 + 24) - *(void *)(v4 + 16)) >> 2);
    sub_10008A640((uint64_t *)(a3 + 40), *(void *)(v4 + 40), *(void *)(v4 + 48), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v4 + 48) - *(void *)(v4 + 40)) >> 3));
  }
  int v6 = *(_DWORD *)(v4 + 64);
  *(_WORD *)(a3 + 68) = *(_WORD *)(v4 + 68);
  *(_DWORD *)(a3 + 64) = v6;
  std::string::operator=((std::string *)(a3 + 72), (const std::string *)(v4 + 72));
  std::string::operator=((std::string *)(a3 + 96), (const std::string *)(v4 + 96));
  std::string::operator=((std::string *)(a3 + 120), (const std::string *)(v4 + 120));
  std::string::operator=((std::string *)(a3 + 144), (const std::string *)(v4 + 144));
  return 1;
}

uint64_t sub_10097AEB0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 3360);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 3360;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 3360 && *(_DWORD *)(v3 + 28) <= a2) {
    return *(unsigned int *)(v3 + 32);
  }
  else {
    return 0;
  }
}

void *sub_10097AF00@<X0>(void *result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = (char *)result[414];
  if (!v3) {
    goto LABEL_11;
  }
  int v4 = (char *)(result + 414);
  do
  {
    int v5 = *((_DWORD *)v3 + 8);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = (char **)v3;
    }
    else {
      uint64_t v7 = (char **)(v3 + 8);
    }
    if (!v6) {
      int v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != (char *)(result + 414) && *((_DWORD *)v4 + 8) <= a2)
  {
    if (v4[63] < 0)
    {
      return sub_10004FC84((unsigned char *)a3, *((void **)v4 + 5), *((void *)v4 + 6));
    }
    else
    {
      long long v8 = *(_OWORD *)(v4 + 40);
      *(void *)(a3 + 16) = *((void *)v4 + 7);
      *(_OWORD *)a3 = v8;
    }
  }
  else
  {
LABEL_11:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return result;
}

void *sub_10097AF74@<X0>(void *result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = (char *)result[417];
  if (!v3) {
    goto LABEL_11;
  }
  int v4 = (char *)(result + 417);
  do
  {
    int v5 = *((_DWORD *)v3 + 8);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = (char **)v3;
    }
    else {
      uint64_t v7 = (char **)(v3 + 8);
    }
    if (!v6) {
      int v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != (char *)(result + 417) && *((_DWORD *)v4 + 8) <= a2)
  {
    if (v4[63] < 0)
    {
      return sub_10004FC84((unsigned char *)a3, *((void **)v4 + 5), *((void *)v4 + 6));
    }
    else
    {
      long long v8 = *(_OWORD *)(v4 + 40);
      *(void *)(a3 + 16) = *((void *)v4 + 7);
      *(_OWORD *)a3 = v8;
    }
  }
  else
  {
LABEL_11:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return result;
}

uint64_t sub_10097AFE8(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 2448);
  uint64_t v3 = *(_DWORD **)(a1 + 2456);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      v2 += 42;
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 == v3) {
    return 0;
  }
  else {
    return v2[2];
  }
}

void sub_10097B02C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v6 = sub_100046F68(a1 + 3376, (void **)a2);
  uint64_t v7 = (void **)(a1 + 3384);
  long long v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7 == v6)
  {
    if (v9)
    {
      uint64_t v16 = *(unsigned __int8 *)(a2 + 23);
      BOOL v17 = (v16 & 0x80u) != 0;
      if ((v16 & 0x80u) != 0) {
        uint64_t v16 = *(void *)(a2 + 8);
      }
      if (v17) {
        int v18 = *(const char **)a2;
      }
      else {
        int v18 = (const char *)a2;
      }
      if (v16) {
        BOOL v19 = v18;
      }
      else {
        BOOL v19 = "<invalid>";
      }
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I No DeviceID for Personality %s", __p, 0xCu);
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    if (v9)
    {
      sub_1003B37BC((uint64_t)(v6 + 7), __p);
      if (v21 >= 0) {
        int v10 = __p;
      }
      else {
        int v10 = *(unsigned char **)__p;
      }
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      BOOL v12 = (v11 & 0x80u) != 0;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v12) {
        int v13 = *(const char **)a2;
      }
      else {
        int v13 = (const char *)a2;
      }
      if (v11) {
        int v14 = v13;
      }
      else {
        int v14 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315394;
      int v23 = v10;
      __int16 v24 = 2080;
      int v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Got DeviceID %s for Personality %s", buf, 0x16u);
      if (v21 < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (*((char *)v6 + 79) < 0)
    {
      sub_10004FC84((unsigned char *)a3, v6[7], (unint64_t)v6[8]);
    }
    else
    {
      long long v15 = *(_OWORD *)(v6 + 7);
      *(void *)(a3 + 16) = v6[9];
      *(_OWORD *)a3 = v15;
    }
  }
}

void sub_10097B1F8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v6 = sub_100046F68(a1 + 3376, (void **)a2);
  uint64_t v7 = (void **)(a1 + 3384);
  long long v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7 == v6)
  {
    if (v9)
    {
      uint64_t v16 = *(unsigned __int8 *)(a2 + 23);
      BOOL v17 = (v16 & 0x80u) != 0;
      if ((v16 & 0x80u) != 0) {
        uint64_t v16 = *(void *)(a2 + 8);
      }
      if (v17) {
        int v18 = *(const char **)a2;
      }
      else {
        int v18 = (const char *)a2;
      }
      if (v16) {
        BOOL v19 = v18;
      }
      else {
        BOOL v19 = "<invalid>";
      }
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I No DeviceAccountUUID for Personality %s", __p, 0xCu);
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    if (v9)
    {
      sub_1003B37BC((uint64_t)(v6 + 7), __p);
      if (v21 >= 0) {
        int v10 = __p;
      }
      else {
        int v10 = *(unsigned char **)__p;
      }
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      BOOL v12 = (v11 & 0x80u) != 0;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v12) {
        int v13 = *(const char **)a2;
      }
      else {
        int v13 = (const char *)a2;
      }
      if (v11) {
        int v14 = v13;
      }
      else {
        int v14 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315394;
      int v23 = v10;
      __int16 v24 = 2080;
      int v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Got DeviceID %s for Personality %s", buf, 0x16u);
      if (v21 < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (*((char *)v6 + 103) < 0)
    {
      sub_10004FC84((unsigned char *)a3, v6[10], (unint64_t)v6[11]);
    }
    else
    {
      long long v15 = *((_OWORD *)v6 + 5);
      *(void *)(a3 + 16) = v6[12];
      *(_OWORD *)a3 = v15;
    }
  }
}

BOOL sub_10097B3C4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 2520);
  uint64_t v3 = (void *)(a1 + 2528);
  if (v2 != (void *)(a1 + 2528))
  {
    while (*((_DWORD *)v2 + 7) != a2)
    {
      int v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          int v5 = v4;
          int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          int v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
      if (v5 == v3) {
        return 0;
      }
    }
  }
  return v2 != v3 && *((unsigned char *)v2 + 32) != 0;
}

uint64_t sub_10097B43C(uint64_t a1, int a2, std::string *this)
{
  int v4 = *(void **)(a1 + 2496);
  int v5 = (void *)(a1 + 2504);
  if (v4 != (void *)(a1 + 2504))
  {
    while (*((_DWORD *)v4 + 8) != a2)
    {
      BOOL v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          int v4 = v7;
        }
        while (!v8);
      }
      int v4 = v7;
      if (v7 == v5) {
        return 0;
      }
    }
  }
  if (v4 == v5) {
    return 0;
  }
  std::string::operator=(this, (const std::string *)(v4 + 5));
  std::string::operator=(this + 1, (const std::string *)(v4 + 8));
  return 1;
}

BOOL sub_10097B4E0(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 2560);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = a1 + 2560;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      BOOL v8 = (uint64_t *)v3;
    }
    else {
      BOOL v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 2560 || *(_DWORD *)(v5 + 32) > a2) {
    return 0;
  }
  sub_10098C220((uint64_t *)&v11);
  int v10 = *(std::__shared_weak_count **)(a3 + 8);
  *(_OWORD *)a3 = v11;
  if (v10) {
    sub_10004D2C8(v10);
  }
  return *(unsigned char *)(v5 + 120) != 0;
}

uint64_t sub_10097B57C(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_100046F68(a1 + 3048, a2);
  if ((void **)(a1 + 3056) != v3) {
    BOOL v4 = *((unsigned char *)v3 + 60) != 0;
  }
  return (a1 + 3056 != (void)v3) & v4;
}

BOOL sub_10097B5CC(uint64_t a1)
{
  return *(unsigned char *)(a1 + 2848) == 2;
}

uint64_t sub_10097B5DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 56));
  int v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v7;
  long long v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
  if (v11)
  {
    int v13 = (GestaltUtilityInterface *)v11[3];
    BOOL v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    int v13 = 0;
  }
  std::mutex::unlock(v6);
  BOOL v12 = 0;
  char v14 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (isWatch) {
    return 2;
  }
  uint64_t v17 = *(unsigned __int8 *)(a2 + 23);
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *(void *)(a2 + 8);
  }
  if (!v17) {
    return 0;
  }
  int v18 = sub_100046F68(a1 + 3024, (void **)a2);
  if ((void **)(a1 + 3032) == v18) {
    return 0;
  }
  else {
    return *((unsigned __int8 *)v18 + 56);
  }
}

void sub_10097B718(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10097B734(uint64_t a1, int a2)
{
  int v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 48))(a1, &v3);
}

BOOL sub_10097B784(uint64_t a1)
{
  char v1 = *(void **)(a1 + 2472);
  char v2 = (void *)(a1 + 2480);
  if (v1 == (void *)(a1 + 2480)) {
    return 0;
  }
  do
  {
    int v3 = *((_DWORD *)v1 + 16);
    BOOL result = v3 == 2;
    if (v3 == 2) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        int v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        char v1 = v6;
      }
      while (!v7);
    }
    char v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t sub_10097B7E8(uint64_t a1, void **a2)
{
  int v3 = sub_100046F68(a1 + 2472, a2);
  if ((void **)(a1 + 2480) == v3) {
    return 0;
  }
  else {
    return *((unsigned int *)v3 + 16);
  }
}

void sub_10097B828(void **a1@<X0>, int a2@<W1>, RegisteredNetworkInfo *a3@<X8>)
{
  int v6 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I getRegisteredNetworkInfo", (uint8_t *)v8, 2u);
  }
  switch(a2)
  {
    case 1:
      BOOL v7 = (const RegisteredNetworkInfo *)(a1 + 96);
      goto LABEL_7;
    case 2:
      BOOL v7 = (const RegisteredNetworkInfo *)(a1 + 196);
LABEL_7:
      RegisteredNetworkInfo::RegisteredNetworkInfo(a3, v7);
      break;
    default:
      RegisteredNetworkInfo::RegisteredNetworkInfo(a3);
      break;
  }
}

uint64_t sub_10097B918(unsigned char *a1)
{
  if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)a1) != 2 || !a1[2912]) {
    return 0;
  }

  return cellplan::RemoteSimSubscriptionInfo::isSimReadyToUse((cellplan::RemoteSimSubscriptionInfo *)(a1 + 2920));
}

uint64_t sub_10097B970(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 0;
  }
  BOOL v4 = sub_100046F68(a1 + 2472, (void **)a2);
  if ((void **)(a1 + 2480) == v4) {
    return 0;
  }
  else {
    return *((unsigned int *)v4 + 14);
  }
}

BOOL sub_10097B9C8(_DWORD *a1)
{
  BOOL v1 = a1[716] == 2 || a1[724] == 2;
  int v2 = a1[726];
  if (v2) {
    return v2 == 2;
  }
  else {
    return v1;
  }
}

BOOL sub_10097BA00(uint64_t a1)
{
  return *(_DWORD *)(a1 + 2864) == 1 && *(_DWORD *)(a1 + 2896) == 2;
}

uint64_t sub_10097BA24(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3417);
}

uint64_t sub_10097BA2C(uint64_t a1, int a2, uint64_t a3, int a4)
{
  BOOL v4 = *(void **)(a1 + 3080);
  uint64_t v5 = (void *)(a1 + 3088);
  if (v4 == (void *)(a1 + 3088)) {
    return 0;
  }
  while (*((_DWORD *)v4 + 7) != a2 || a4 != 2 && ConnectionAvailabilityContainer::contextType() != a4)
  {
    BOOL v8 = (void *)v4[1];
    if (v8)
    {
      do
      {
        uint64_t v9 = v8;
        BOOL v8 = (void *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        uint64_t v9 = (void *)v4[2];
        BOOL v10 = *v9 == (void)v4;
        BOOL v4 = v9;
      }
      while (!v10);
    }
    BOOL v4 = v9;
    if (v9 == v5) {
      return 0;
    }
  }

  return ConnectionAvailabilityContainer::available();
}

BOOL sub_10097BB08(uint64_t a1)
{
  BOOL v1 = *(void **)(a1 + 3128);
  int v2 = (void *)(a1 + 3136);
  if (v1 == (void *)(a1 + 3136)) {
    return 0;
  }
  do
  {
    int v3 = *((_DWORD *)v1 + 8);
    BOOL result = v3 == 0;
    if (!v3) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        int v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        BOOL v1 = v6;
      }
      while (!v7);
    }
    BOOL v1 = v6;
  }
  while (v6 != v2);
  return result;
}

BOOL sub_10097BB6C(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 3112);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = a1 + 3112;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 3112) {
    return 0;
  }
  if (*(_DWORD *)(v4 + 32) > a2) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 48);
  uint64_t v8 = v4 + 48;
  uint64_t v9 = v10;
  if (!v10) {
    return 0;
  }
  uint64_t v11 = v8;
  do
  {
    int v12 = *(_DWORD *)(v9 + 32);
    BOOL v13 = v12 < a3;
    if (v12 >= a3) {
      char v14 = (uint64_t *)v9;
    }
    else {
      char v14 = (uint64_t *)(v9 + 8);
    }
    if (!v13) {
      uint64_t v11 = v9;
    }
    uint64_t v9 = *v14;
  }
  while (*v14);
  return v11 != v8 && *(_DWORD *)(v11 + 32) <= a3 && *(_DWORD *)(v11 + 44) == 2;
}

uint64_t sub_10097BC00(uint64_t a1, _DWORD *a2)
{
  int v2 = *(void **)(a1 + 3152);
  if (v2 == (void *)(a1 + 3160))
  {
LABEL_9:
    BOOL v6 = *(NSObject **)(a1 + 40);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v7)
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I InternetConnection is NOT active", (uint8_t *)&v10, 2u);
      return 0;
    }
  }
  else
  {
    while (*((_DWORD *)v2 + 16) != 2)
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          int v2 = v4;
        }
        while (!v5);
      }
      int v2 = v4;
      if (v4 == (void *)(a1 + 3160)) {
        goto LABEL_9;
      }
    }
    *a2 = *((_DWORD *)v2 + 8);
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315138;
      uint64_t v11 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I InternetConnection is active on %s", (uint8_t *)&v10, 0xCu);
    }
    return 1;
  }
  return result;
}

uint64_t sub_10097BD4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 3192);
  if (!v3) {
    return 0;
  }
  BOOL v7 = (void **)(a1 + 3192);
  uint64_t v8 = (void **)(a1 + 3192);
  do
  {
    char v9 = sub_100046FE8(v3 + 4, (void **)a2);
    if (v9 >= 0) {
      int v10 = v3;
    }
    else {
      int v10 = v3 + 1;
    }
    if (v9 >= 0) {
      uint64_t v8 = (void **)v3;
    }
    uint64_t v3 = (void *)*v10;
  }
  while (*v10);
  if (v8 == v7 || (sub_100046FE8((void *)a2, v8 + 4) & 0x80) != 0) {
    return 0;
  }
  uint64_t v11 = PersonalityIDToSimSlot();
  int v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(unsigned __int8 *)(a2 + 23);
    BOOL v14 = (v13 & 0x80u) != 0;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(a2 + 8);
    }
    if (v14) {
      long long v15 = *(const char **)a2;
    }
    else {
      long long v15 = (const char *)a2;
    }
    if (v13) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = "<invalid>";
    }
    int v19 = 136315906;
    BOOL v20 = v16;
    __int16 v21 = 2080;
    uint64_t v22 = asString();
    __int16 v23 = 2080;
    uint64_t v24 = sd::asString();
    __int16 v25 = 2080;
    uint64_t v26 = sd::asString();
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I IMS Pref for %s: ct=%s, bb_mask=[%s], tech_mask=[%s]", (uint8_t *)&v19, 0x2Au);
  }
  uint64_t v17 = v8[7];
  *(_DWORD *)(a3 + 8) = *((_DWORD *)v8 + 16);
  *(void *)a3 = v17;
  return 1;
}

std::string *sub_10097BF08@<X0>(std::string *result@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  std::string::pointer data = result[117].__r_.__value_.__l.__data_;
  if (data)
  {
    uint64_t v4 = result + 117;
    do
    {
      int v5 = *((_DWORD *)data + 8);
      BOOL v6 = v5 < 1;
      if (v5 >= 1) {
        BOOL v7 = (std::string::pointer *)data;
      }
      else {
        BOOL v7 = (std::string::pointer *)(data + 8);
      }
      if (!v6) {
        uint64_t v4 = (std::string *)data;
      }
      std::string::pointer data = *v7;
    }
    while (*v7);
    if (v4 != &result[117] && SLODWORD(v4[1].__r_.__value_.__r.__words[1]) <= 1) {
      return std::string::operator=(a2, (std::string *)((char *)v4 + 40));
    }
  }
  return result;
}

void sub_10097BF7C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10097BF98(uint64_t a1, uint64_t a2, int a3, int a4, BOOL a5)
{
  int v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
    BOOL v12 = (v11 & 0x80u) != 0;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a2 + 8);
    }
    if (v12) {
      uint64_t v13 = *(const char **)a2;
    }
    else {
      uint64_t v13 = (const char *)a2;
    }
    if (v11) {
      BOOL v14 = v13;
    }
    else {
      BOOL v14 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)uint64_t v22 = v14;
    *(_WORD *)&v22[8] = 2080;
    *(void *)&v22[10] = sd::asString();
    *(_WORD *)&v22[18] = 2080;
    uint64_t v23 = sd::asString();
    __int16 v24 = 2080;
    uint64_t v25 = asStringBool(a5);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I ImsFeature: sending ims_feature_state for account: %s (cell mask: [%s], wifi mask: [%s], VoNR enabled: %s)", buf, 0x2Au);
  }
  v19[0] = 1;
  v19[1] = a1 + 400;
  uint64_t v20 = 0;
  long long v15 = (uint64_t **)sub_100046ED4(a1 + 432, &v20, (void **)a2);
  uint64_t v16 = *v15;
  if (!*v15)
  {
    *(void *)&v22[12] = 0;
    uint64_t v16 = (uint64_t *)operator new(0x48uLL);
    *(void *)&v22[4] = a1 + 440;
    v22[12] = 0;
    uint64_t v17 = v16 + 4;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v17, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
      v16[6] = *(void *)(a2 + 16);
    }
    *((unsigned char *)v16 + 64) = 0;
    v16[7] = 0;
    sub_100046C38((uint64_t **)(a1 + 432), v20, v15, v16);
  }
  *((_DWORD *)v16 + 14) = a3;
  *((_DWORD *)v16 + 15) = a4;
  *((unsigned char *)v16 + 64) = a5;
  return sub_10098BEA8((uint64_t)v19);
}

void sub_10097C170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  a13 = 0;
  sub_1000C6EE8(v13, v14);
  sub_10098BEA8((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void **sub_10097C19C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)(a1 + 432);
  uint64_t result = sub_100046F68(a1 + 432, (void **)a2);
  if ((void **)(a1 + 440) != result)
  {
    uint64_t v6 = a1 + 400;
    BOOL v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
      BOOL v9 = (v8 & 0x80u) != 0;
      if ((v8 & 0x80u) != 0) {
        uint64_t v8 = *(void *)(a2 + 8);
      }
      if (v9) {
        int v10 = *(const char **)a2;
      }
      else {
        int v10 = (const char *)a2;
      }
      if (v8) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = "<invalid>";
      }
      LODWORD(v12) = 136315138;
      *(void *)((char *)&v12 + 4) = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I ImsFeature: removing ims_feature_state for account: %s", (uint8_t *)&v12, 0xCu);
    }
    *(void *)&long long v12 = 1;
    *((void *)&v12 + 1) = v6;
    sub_100340C0C(v4, (void **)a2);
    return (void **)sub_10098BEA8((uint64_t)&v12);
  }
  return result;
}

void sub_10097C2A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v8) {
      BOOL v9 = *(const char **)a2;
    }
    else {
      BOOL v9 = (const char *)a2;
    }
    if (v7) {
      int v10 = v9;
    }
    else {
      int v10 = "<invalid>";
    }
    sub_1005933FC(a3, __p);
    if (SHIBYTE(v89[0]) >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = (void **)__p[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I IMSInfo: sending SIM ims_info_ready for subscriber %s: %s", (uint8_t *)&buf, 0x16u);
    if (SHIBYTE(v89[0]) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  if (v12)
  {
    buf.__r_.__value_.__r.__words[0] = 1;
    buf.__r_.__value_.__l.__size_ = a1 + 512;
    __str.__r_.__value_.__r.__words[0] = 0;
    uint64_t v13 = (uint64_t **)sub_100046ED4(a1 + 544, &__str, (void **)a2);
    BOOL v14 = *v13;
    if (!*v13)
    {
      v89[0] = 0;
      long long v15 = (char *)operator new(0x100uLL);
      __p[0] = v15;
      __p[1] = (void *)(a1 + 552);
      LOBYTE(v89[0]) = 0;
      uint64_t v16 = v15 + 32;
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(v16, *(void **)a2, *(void *)(a2 + 8));
        uint64_t v17 = (uint64_t *)__p[0];
      }
      else
      {
        *(_OWORD *)uint64_t v16 = *(_OWORD *)a2;
        *((void *)v15 + 6) = *(void *)(a2 + 16);
        uint64_t v17 = (uint64_t *)v15;
      }
      *((void *)v15 + 31) = 0;
      *(_OWORD *)(v15 + 232) = 0u;
      *(_OWORD *)(v15 + 216) = 0u;
      *(_OWORD *)(v15 + 200) = 0u;
      *(_OWORD *)(v15 + 184) = 0u;
      *(_OWORD *)(v15 + 168) = 0u;
      *(_OWORD *)(v15 + 152) = 0u;
      *(_OWORD *)(v15 + 136) = 0u;
      *(_OWORD *)(v15 + 120) = 0u;
      *(_OWORD *)(v15 + 104) = 0u;
      *(_OWORD *)(v15 + 88) = 0u;
      *(_OWORD *)(v15 + 72) = 0u;
      *(_OWORD *)(v15 + 56) = 0u;
      LOBYTE(v89[0]) = 1;
      sub_100046C38((uint64_t **)(a1 + 544), (uint64_t)__str.__r_.__value_.__l.__data_, v13, v17);
      BOOL v14 = (uint64_t *)__p[0];
      __p[0] = 0;
      sub_1001A9054((uint64_t)__p, 0);
    }
    sub_1001A9310((uint64_t)(v14 + 7), a3);
    sub_10098BFD4((uint64_t)&buf);
    uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a3 + 8);
    }
    if (v18)
    {
      int v19 = (uint64_t **)(a1 + 600);
      uint64_t v20 = sub_100046F68(a1 + 600, (void **)a2);
      if ((void **)(a1 + 608) != v20)
      {
        uint64_t v21 = *((unsigned __int8 *)v20 + 79);
        if ((v21 & 0x80u) == 0) {
          uint64_t v22 = (void *)*((unsigned __int8 *)v20 + 79);
        }
        else {
          uint64_t v22 = v20[8];
        }
        uint64_t v23 = (void *)*(unsigned __int8 *)(a3 + 23);
        int v24 = (char)v23;
        if ((char)v23 < 0) {
          uint64_t v23 = *(void **)(a3 + 8);
        }
        if (v22 == v23)
        {
          uint64_t v25 = (const void **)(v20 + 7);
          if (v24 >= 0) {
            uint64_t v26 = (unsigned __int8 *)a3;
          }
          else {
            uint64_t v26 = *(unsigned __int8 **)a3;
          }
          if ((v21 & 0x80) != 0)
          {
            if (!memcmp(*v25, v26, (size_t)v20[8])) {
              return;
            }
          }
          else
          {
            if (!*((unsigned char *)v20 + 79)) {
              return;
            }
            while (*(unsigned __int8 *)v25 == *v26)
            {
              uint64_t v25 = (const void **)((char *)v25 + 1);
              ++v26;
              if (!--v21) {
                return;
              }
            }
          }
        }
      }
      *(_OWORD *)v91 = 0u;
      long long v92 = 0u;
      *(_OWORD *)v90 = 0u;
      *(_OWORD *)std::string __p = 0u;
      memset(v89, 0, sizeof(v89));
      __int16 v28 = __p;
      std::string::operator=((std::string *)__p, (const std::string *)a3);
      uint64_t v29 = (uint64_t *)*(unsigned __int8 *)(a3 + 95);
      if ((char)v29 >= 0) {
        BOOL v30 = (void *)(a3 + 72);
      }
      else {
        BOOL v30 = *(void **)(a3 + 72);
      }
      if (SHIBYTE(v89[0]) >= 0)
      {
        int64_t v31 = HIBYTE(v89[0]);
      }
      else
      {
        __int16 v28 = (void **)__p[0];
        int64_t v31 = (int64_t)__p[1];
      }
      if (v31)
      {
        if ((char)v29 < 0) {
          uint64_t v29 = *(uint64_t **)(a3 + 80);
        }
        if ((uint64_t)v29 >= v31)
        {
          __int16 v42 = (char *)v29 + (void)v30;
          int v43 = *(char *)v28;
          __int16 v44 = v30;
          do
          {
            uint64_t v29 = (uint64_t *)((char *)v29 - v31);
            if (v29 == (uint64_t *)-1) {
              break;
            }
            uint64_t v45 = (char *)memchr(v44, v43, (size_t)v29 + 1);
            if (!v45) {
              break;
            }
            long long v46 = v45;
            if (!memcmp(v45, v28, v31))
            {
              if (v46 == v42) {
                break;
              }
              uint64_t v29 = (uint64_t *)(v46 - (unsigned char *)v30);
              if (v46 - (unsigned char *)v30 == -1) {
                break;
              }
              goto LABEL_112;
            }
            __int16 v44 = v46 + 1;
            uint64_t v29 = (uint64_t *)(v42 - (v46 + 1));
          }
          while ((uint64_t)v29 >= v31);
        }
        memset(&__str, 0, sizeof(__str));
        ServiceMap = (std::mutex *)Registry::getServiceMap(v29, *(Registry **)(a1 + 56));
        uint64_t v33 = ServiceMap;
        if ((v34 & 0x8000000000000000) != 0)
        {
          uint64_t v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v36 = 5381;
          do
          {
            std::string::size_type v34 = v36;
            unsigned int v37 = *v35++;
            uint64_t v36 = (33 * v36) ^ v37;
          }
          while (v37);
        }
        std::mutex::lock(ServiceMap);
        buf.__r_.__value_.__r.__words[0] = v34;
        char v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)&buf);
        if (v38)
        {
          uint64_t v40 = v38[3];
          uint64_t v39 = (std::__shared_weak_count *)v38[4];
          if (v39)
          {
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v33);
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v39);
            char v41 = 0;
LABEL_68:
            (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v40 + 24))(&cf, v40, a2, @"homeIMSI", 0, 0, 1);
            CFTypeRef v96 = cf;
            if (cf) {
              CFRetain(cf);
            }
            uint64_t v95 = 0;
            buf.__r_.__value_.__r.__words[0] = 0;
            sub_100056248(&buf, &v96);
            if (buf.__r_.__value_.__r.__words[0]) {
              long long v47 = sub_1000810B8;
            }
            else {
              long long v47 = 0;
            }
            if (v47) {
              sub_100083EB8(&v95, (const void **)&buf.__r_.__value_.__l.__data_);
            }
            sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
            uint64_t v93 = v95;
            uint64_t v95 = 0;
            sub_1000558F4(&v95);
            sub_1000577C4(&v96);
            memset(&buf, 0, sizeof(buf));
            ctu::cf::assign();
            std::string __str = buf;
            sub_1000558F4(&v93);
            sub_1000577C4(&cf);
            if ((v41 & 1) == 0) {
              sub_10004D2C8(v39);
            }
            std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __str.__r_.__value_.__l.__size_;
            }
            if (size)
            {
              std::string::operator=((std::string *)&v89[1], &__str);
              long long v49 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v50 = *(unsigned __int8 *)(a2 + 23);
                BOOL v51 = (v50 & 0x80u) != 0;
                if ((v50 & 0x80u) != 0) {
                  uint64_t v50 = *(void *)(a2 + 8);
                }
                if (v51) {
                  long long v52 = *(const char **)a2;
                }
                else {
                  long long v52 = (const char *)a2;
                }
                if (v50) {
                  long long v53 = v52;
                }
                else {
                  long long v53 = "<invalid>";
                }
                if (SHIBYTE(v89[3]) >= 0) {
                  uint64_t v54 = &v89[1];
                }
                else {
                  uint64_t v54 = (void **)v89[1];
                }
                int v55 = __p;
                if (SHIBYTE(v89[0]) < 0) {
                  int v55 = (void **)__p[0];
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v53;
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v54;
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                long long v98 = v55;
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I subscriber %s using last home IMSI:%s instead of current roaming broker IMSI:%s", (uint8_t *)&buf, 0x20u);
              }
            }
            else
            {
              CFStringRef v56 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v57 = *(unsigned __int8 *)(a2 + 23);
                BOOL v58 = (v57 & 0x80u) != 0;
                if ((v57 & 0x80u) != 0) {
                  uint64_t v57 = *(void *)(a2 + 8);
                }
                if (v58) {
                  __int16 v59 = *(const char **)a2;
                }
                else {
                  __int16 v59 = (const char *)a2;
                }
                if (v57) {
                  CFStringRef v60 = v59;
                }
                else {
                  CFStringRef v60 = "<invalid>";
                }
                uint64_t v61 = __p;
                if (SHIBYTE(v89[0]) < 0) {
                  uint64_t v61 = (void **)__p[0];
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                long long v98 = (void *)v60;
                __int16 v99 = 2080;
                uint64_t v100 = v61;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%ssubscriber %s obtained IMSI:%s which seems to belong to roaming broker, but since it is the only available IMSI - temporary using it as home IMSI", (uint8_t *)&buf, 0x2Au);
              }
              std::string::operator=((std::string *)&v89[1], (const std::string *)__p);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
LABEL_152:
            sub_100E63EA4((uint64_t)&buf);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v90;
            __str.__r_.__value_.__l.__size_ = (std::string::size_type)&v91[1];
            sub_100294590(&__str, (long long *)&buf);
            if (v101 < 0) {
              operator delete(v98);
            }
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            __str.__r_.__value_.__r.__words[0] = 1;
            __str.__r_.__value_.__l.__size_ = a1 + 568;
            CFTypeRef v96 = 0;
            v80 = (uint64_t **)sub_100046ED4((uint64_t)v19, &v96, (void **)a2);
            v81 = *v80;
            if (!*v80)
            {
              buf.__r_.__value_.__r.__words[2] = 0;
              int v82 = (char *)operator new(0x98uLL);
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v82;
              buf.__r_.__value_.__l.__size_ = a1 + 608;
              buf.__r_.__value_.__s.__data_[16] = 0;
              int v83 = v82 + 32;
              if (*(char *)(a2 + 23) < 0)
              {
                sub_10004FC84(v83, *(void **)a2, *(void *)(a2 + 8));
                int v84 = (uint64_t *)buf.__r_.__value_.__r.__words[0];
              }
              else
              {
                *(_OWORD *)int v83 = *(_OWORD *)a2;
                *((void *)v82 + 6) = *(void *)(a2 + 16);
                int v84 = (uint64_t *)v82;
              }
              *(_OWORD *)(v82 + 136) = 0u;
              *(_OWORD *)(v82 + 120) = 0u;
              *(_OWORD *)(v82 + 104) = 0u;
              *(_OWORD *)(v82 + 88) = 0u;
              *(_OWORD *)(v82 + 72) = 0u;
              *(_OWORD *)(v82 + 56) = 0u;
              buf.__r_.__value_.__s.__data_[16] = 1;
              sub_100046C38(v19, (uint64_t)v96, v80, v84);
              v81 = (uint64_t *)buf.__r_.__value_.__r.__words[0];
              buf.__r_.__value_.__r.__words[0] = 0;
              sub_10039AAC8((uint64_t)&buf, 0);
            }
            std::string::operator=((std::string *)(v81 + 7), (const std::string *)__p);
            std::string::operator=((std::string *)(v81 + 10), (const std::string *)&v89[1]);
            std::string::operator=((std::string *)(v81 + 13), (const std::string *)v90);
            std::string::operator=((std::string *)(v81 + 16), (const std::string *)&v91[1]);
            sub_10098C038((uint64_t)&__str);
            if (SHIBYTE(v92) < 0) {
              operator delete(v91[1]);
            }
            if (SHIBYTE(v91[0]) < 0) {
              operator delete(v90[0]);
            }
            if (SHIBYTE(v89[3]) < 0) {
              operator delete(v89[1]);
            }
            if (SHIBYTE(v89[0]) < 0) {
              operator delete(__p[0]);
            }
            return;
          }
        }
        else
        {
          uint64_t v40 = 0;
        }
        std::mutex::unlock(v33);
        uint64_t v39 = 0;
        char v41 = 1;
        goto LABEL_68;
      }
LABEL_112:
      std::string::operator=((std::string *)&v89[1], (const std::string *)__p);
      uint64_t v63 = (std::mutex *)Registry::getServiceMap(v62, *(Registry **)(a1 + 56));
      uint64_t v64 = v63;
      if ((v65 & 0x8000000000000000) != 0)
      {
        CFRange v66 = (unsigned __int8 *)(v65 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v67 = 5381;
        do
        {
          std::string::size_type v65 = v67;
          unsigned int v68 = *v66++;
          uint64_t v67 = (33 * v67) ^ v68;
        }
        while (v68);
      }
      std::mutex::lock(v63);
      buf.__r_.__value_.__r.__words[0] = v65;
      char v69 = sub_10004D37C(&v64[1].__m_.__sig, (unint64_t *)&buf);
      if (v69)
      {
        uint64_t v71 = v69[3];
        uint64_t v70 = (std::__shared_weak_count *)v69[4];
        if (v70)
        {
          atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v64);
          atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v70);
          char v72 = 0;
LABEL_120:
          if (SHIBYTE(v89[3]) < 0) {
            sub_10004FC84(&__dst, v89[1], (unint64_t)v89[2]);
          }
          else {
            std::string __dst = *(std::string *)&v89[1];
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = __dst;
          }
          uint64_t v93 = 0;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&buf, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          }
          else {
            std::string buf = __str;
          }
          uint64_t v95 = 0;
          if (ctu::cf::convert_copy())
          {
            v73 = v93;
            uint64_t v93 = v95;
            CFTypeRef v96 = v73;
            sub_1000558F4(&v96);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          uint64_t v87 = v93;
          uint64_t v93 = 0;
          sub_1000558F4(&v93);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, void, void, uint64_t, void))(*(void *)v71 + 16))(v71, a2, @"homeIMSI", v87, 0, 0, 1, 0);
          sub_1000558F4(&v87);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          if ((v72 & 1) == 0) {
            sub_10004D2C8(v70);
          }
          CFIndex v74 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v75 = *(unsigned __int8 *)(a2 + 23);
            BOOL v76 = (v75 & 0x80u) != 0;
            if ((v75 & 0x80u) != 0) {
              uint64_t v75 = *(void *)(a2 + 8);
            }
            if (v76) {
              v77 = *(const char **)a2;
            }
            else {
              v77 = (const char *)a2;
            }
            if (v75) {
              v78 = v77;
            }
            else {
              v78 = "<invalid>";
            }
            if (SHIBYTE(v89[3]) >= 0) {
              v79 = &v89[1];
            }
            else {
              v79 = (void **)v89[1];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v79;
            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I subscriber %s obtained home IMSI:%s", (uint8_t *)&buf, 0x16u);
          }
          goto LABEL_152;
        }
      }
      else
      {
        uint64_t v71 = 0;
      }
      std::mutex::unlock(v64);
      uint64_t v70 = 0;
      char v72 = 1;
      goto LABEL_120;
    }
    uint64_t v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Missing IMSI in ims_info_ready! Neither current no home IMSI are published/updated", (uint8_t *)__p, 2u);
    }
  }
}

void sub_10097CDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  sub_10039AAC8(v40 - 160, 0);
  sub_10098C038((uint64_t)&__p);
  sub_100169704((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_10097CF58(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  int v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/proceed_with_subscription_change");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_10097D000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10097D044(uint64_t a1, long long *a2, char a3, int a4)
{
  uint64_t v7 = 1;
  uint64_t v8 = a1 + 288;
  BOOL v9 = a2;
  sub_10098C91C((uint64_t **)(a1 + 320), (void **)a2, &v9)[64] = a3;
  BOOL v9 = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(v8 + 32), (void **)a2, &v9) + 17) = a4;
  return sub_10098BF70((uint64_t)&v7);
}

void sub_10097D0C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10098BF70((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10097D0D4(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  uint64_t v20 = 1;
  uint64_t v21 = a1 + 288;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(a1 + 320), (void **)a2, (long long **)buf) + 14) = a3;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf) + 15) = a4;
  *(void *)std::string buf = a2;
  sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf)[64] = a5;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf) + 18) = a6;
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    BOOL v14 = *(const char **)a2;
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v15 = sd::asString();
    if ((v12 & 0x80u) == 0) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = v13;
    }
    if ((v12 & 0x80u) == 0) {
      uint64_t v17 = (const char *)a2;
    }
    else {
      uint64_t v17 = v14;
    }
    if (v16) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v18;
    __int16 v23 = 2080;
    uint64_t v24 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending IMS State: for %s: %s", buf, 0x16u);
  }
  return sub_10098BF70((uint64_t)&v20);
}

void sub_10097D24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10097D264(uint64_t a1, long long *a2, char a3)
{
  v4[0] = 1;
  v4[1] = a1 + 232;
  int v5 = a2;
  *((unsigned char *)sub_1001010C0((uint64_t **)(a1 + 264), (void **)a2, (uint64_t)&unk_10144E20E, &v5) + 56) = a3;
  return sub_10098CA0C((uint64_t)v4);
}

void sub_10097D2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10097D2D4(uint64_t a1, uint64_t a2, long long **a3)
{
  v28[0] = 1;
  v28[1] = a1 + 344;
  uint64_t v6 = (uint64_t **)(a1 + 376);
  uint64_t v31 = 0;
  uint64_t v7 = (uint64_t **)sub_100046ED4(a1 + 376, &v31, (void **)a2);
  uint64_t v8 = *v7;
  if (!*v7)
  {
    uint64_t v30 = 0;
    BOOL v9 = operator new(0x50uLL);
    v29[0] = v9;
    v29[1] = a1 + 384;
    int v10 = v9 + 4;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v10, *(void **)a2, *(void *)(a2 + 8));
      uint64_t v11 = (uint64_t *)v29[0];
    }
    else
    {
      *(_OWORD *)int v10 = *(_OWORD *)a2;
      v9[6] = *(void *)(a2 + 16);
      uint64_t v11 = v9;
    }
    void v9[7] = 0;
    v9[8] = 0;
    v9[9] = 0;
    LOBYTE(v30) = 1;
    sub_100046C38(v6, v31, v7, v11);
    uint64_t v8 = (uint64_t *)v29[0];
    v29[0] = 0;
    sub_10098CAD4((uint64_t)v29, 0);
  }
  uint64_t v12 = (void **)(v8 + 7);
  if (v8 + 7 != (uint64_t *)a3)
  {
    BOOL v14 = *a3;
    uint64_t v13 = a3[1];
    unint64_t v15 = ((char *)v13 - (char *)v14) >> 5;
    uint64_t v16 = v8[9];
    uint64_t v17 = (std::string *)v8[7];
    if (v15 > (v16 - (uint64_t)v17) >> 5)
    {
      if (v17)
      {
        sub_1000D8350(v8 + 7);
        operator delete(*v12);
        uint64_t v16 = 0;
        NSObject *v12 = 0;
        __int16 v8[8] = 0;
        v8[9] = 0;
      }
      if ((char *)v13 - (char *)v14 < 0) {
        goto LABEL_28;
      }
      uint64_t v18 = v16 >> 4;
      if (v16 >> 4 <= v15) {
        uint64_t v18 = ((char *)v13 - (char *)v14) >> 5;
      }
      unint64_t v19 = (unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0 ? 0x7FFFFFFFFFFFFFFLL : v18;
      if (v19 >> 59) {
LABEL_28:
      }
        sub_10006A748();
      uint64_t v20 = sub_1000F5A68((uint64_t)(v8 + 9), v19);
      v8[7] = (uint64_t)v20;
      __int16 v8[8] = (uint64_t)v20;
      v8[9] = (uint64_t)&v20[4 * v21];
      uint64_t v22 = sub_10097EF98((uint64_t)(v8 + 9), v14, v13, v20);
      goto LABEL_20;
    }
    unint64_t v23 = (v8[8] - (uint64_t)v17) >> 5;
    if (v23 < v15)
    {
      uint64_t v24 = (std::string *)&v14[2 * v23];
      sub_10097F060((std::string *)v14, v24, v17);
      uint64_t v22 = sub_10097EF98((uint64_t)(v8 + 9), (long long *)v24, v13, (void *)v8[8]);
LABEL_20:
      __int16 v8[8] = (uint64_t)v22;
      return sub_10098CA70((uint64_t)v28);
    }
    uint64_t v25 = sub_10097F060((std::string *)v14, (std::string *)v13, v17);
    for (uint64_t i = (std::string *)v8[8]; i != v25; uint64_t i = (std::string *)((char *)i - 32))
    {
      if (i[-1].__r_.__value_.__s.__data_[15] < 0) {
        operator delete((void *)i[-2].__r_.__value_.__r.__words[2]);
      }
    }
    __int16 v8[8] = (uint64_t)v25;
  }
  return sub_10098CA70((uint64_t)v28);
}

void sub_10097D504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *sub_10097D544(void *result)
{
  if (!result[454])
  {
    uint64_t v1 = result;
    uint64_t v2 = (uint64_t)(result + 449);
    uint64_t v3 = result[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFiCalling-only mode: true. Acquiring baseband booted assertion", buf, 2u);
    }
    sub_1010B5C28(v2);
    sub_100058DB0(buf, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v7 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[455];
    *((_OWORD *)v1 + 227) = v5;
    if (v4) {
      sub_10004D2C8(v4);
    }
    sub_1010B5CD8(v2, 20);
    v8[0] = off_101A225E0;
    v8[1] = v1;
    v8[3] = v8;
    sub_10033A644(v1 + 456, (uint64_t)v8);
    return sub_100060644(v8);
  }
  return result;
}

void sub_10097D68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
}

void sub_10097D6C0(uint64_t a1)
{
  if (*(void *)(a1 + 3632)) {
    sub_1010B5C28(a1 + 3592);
  }
}

BOOL sub_10097D6D4(uint64_t a1)
{
  return *(void *)(a1 + 3632) != 0;
}

uint64_t sub_10097D6E4(uint64_t a1, uint64_t a2, int a3)
{
  v13[0] = 1;
  v13[1] = a1 + 456;
  *(void *)std::string buf = a2;
  *((unsigned char *)sub_1001010C0((uint64_t **)(a1 + 488), (void **)a2, (uint64_t)&unk_10144E20E, (long long **)buf) + 56) = a3;
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v8) {
      BOOL v9 = *(const char **)a2;
    }
    else {
      BOOL v9 = (const char *)a2;
    }
    BOOL v10 = v7 == 0;
    uint64_t v11 = "is not";
    if (v10) {
      BOOL v9 = "<invalid>";
    }
    if (a3) {
      uint64_t v11 = "is";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v15 = 2080;
    uint64_t v16 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I IMSClient: for %s %s ready", buf, 0x16u);
  }
  return sub_10098BF0C((uint64_t)v13);
}

void sub_10097D810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10098BF0C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10097D824(uint64_t a1, uint64_t a2, int a3)
{
  v13[0] = 1;
  v13[1] = a1 + 3512;
  *(void *)std::string buf = a2;
  *((unsigned char *)sub_1001010C0((uint64_t **)(a1 + 3544), (void **)a2, (uint64_t)&unk_10144E20E, (long long **)buf) + 56) = a3;
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v8) {
      BOOL v9 = *(const char **)a2;
    }
    else {
      BOOL v9 = (const char *)a2;
    }
    BOOL v10 = v7 == 0;
    uint64_t v11 = "is not";
    if (v10) {
      BOOL v9 = "<invalid>";
    }
    if (a3) {
      uint64_t v11 = "is";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v15 = 2080;
    uint64_t v16 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I LazuliClient: for %s %s ready", buf, 0x16u);
  }
  return sub_10098CCC0((uint64_t)v13);
}

void sub_10097D950(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10098CCC0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10097D964(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  uint64_t v20 = 1;
  uint64_t v21 = a1 + 3456;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(a1 + 3488), (void **)a2, (long long **)buf) + 14) = a3;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf) + 15) = a4;
  *(void *)std::string buf = a2;
  sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf)[64] = a5;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_10098C91C((uint64_t **)(v21 + 32), (void **)a2, (long long **)buf) + 18) = a6;
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    BOOL v14 = *(const char **)a2;
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v15 = sd::asString();
    if ((v12 & 0x80u) == 0) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = v13;
    }
    if ((v12 & 0x80u) == 0) {
      uint64_t v17 = (const char *)a2;
    }
    else {
      uint64_t v17 = v14;
    }
    if (v16) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v18;
    __int16 v23 = 2080;
    uint64_t v24 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending Lazuli IMS State: for %s: %s", buf, 0x16u);
  }
  return sub_10098CD24((uint64_t)&v20);
}

void sub_10097DADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10097DAF4(uint64_t a1, uint64_t a2, long long *a3, long long **a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v9 = *((void *)a3 + 2);
  }
  memset(v10, 0, sizeof(v10));
  sub_1000302C0((char *)v10, *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3));
  xpc_object_t v14 = 0;
  sub_100592650((uint64_t)v6, &v14);
  sub_100058DB0(v12, "/cc/events/p_associated_uri_changed");
  xpc_object_t object = v14;
  xpc_object_t v14 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v13 < 0) {
    operator delete(v12[0]);
  }
  xpc_release(v14);
  v12[0] = v10;
  sub_100047F64(v12);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_10097DC48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t object)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097DCD4(uint64_t a1, int a2)
{
  int v2 = a2;
  sub_10097DD00(a1 + 216, &v2);
}

void sub_10097DD00(uint64_t a1, int *a2)
{
  xpc_object_t v8 = 0;
  int v2 = (ctu::rest::detail *)*a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/drop_ims_packets");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_10097DDA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_10097DDE8()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/events/trigger_domain_change_ntf");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10097DE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  xpc_release(object);
  if (a18 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v18 - 24));
  _Unwind_Resume(a1);
}

void sub_10097DECC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v2, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)char v2 = *(_OWORD *)a2;
    uint64_t v3 = *(void *)(a2 + 16);
  }
  rest::ResetPayload::ResetPayload();
  sub_1004BC4DC();
  if (v5 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_10097DF5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097DF90(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4, uint64_t a5, uint64_t a6)
{
  xpc_object_t v34 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v34 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v34 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_9;
  }
  xpc_object_t v14 = xpc_null_create();
LABEL_8:
  xpc_object_t v34 = v14;
LABEL_9:
  xpc_release(v13);
  xpc_object_t v32 = xpc_BOOL_create(a4);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  ctu::cf::assign();
  memset(buf, 0, sizeof(buf));
  __p[0] = &v34;
  __p[1] = buf;
  sub_100035E70((uint64_t)__p, &v32, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v32);
  xpc_object_t v32 = 0;
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string buf = *(_OWORD *)v35;
  *(void *)&uint8_t buf[16] = v36;
  if (v36 >= 0) {
    uint64_t v15 = buf;
  }
  else {
    uint64_t v15 = *(uint8_t **)buf;
  }
  xpc_object_t v30 = xpc_string_create((const char *)v15);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)v35;
  uint64_t v27 = v36;
  uint64_t v16 = (void **)v35[0];
  if (v36 >= 0) {
    uint64_t v16 = __p;
  }
  __int16 v28 = &v34;
  uint64_t v29 = v16;
  sub_100035E70((uint64_t)&v28, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v30);
  xpc_object_t v30 = 0;
  if ((char)buf[23] < 0)
  {
    operator delete(*(void **)buf);
    if (!a4) {
      goto LABEL_37;
    }
  }
  else if (!a4)
  {
    goto LABEL_37;
  }
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string buf = *(_OWORD *)v35;
  *(void *)&uint8_t buf[16] = v36;
  if (v36 >= 0) {
    uint64_t v17 = buf;
  }
  else {
    uint64_t v17 = *(uint8_t **)buf;
  }
  xpc_object_t v24 = xpc_string_create((const char *)v17);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)v35;
  uint64_t v27 = v36;
  uint64_t v18 = (void **)v35[0];
  if (v36 >= 0) {
    uint64_t v18 = __p;
  }
  __int16 v28 = &v34;
  uint64_t v29 = v18;
  sub_100035E70((uint64_t)&v28, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
LABEL_37:
  unint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = sub_100027EA4(162);
    xpc::object::to_string((uint64_t *)v35, (xpc::object *)&v34);
    uint64_t v21 = v36 >= 0 ? v35 : (void **)v35[0];
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Sending notification %s with notification dictionary of %s", buf, 0x16u);
    if (SHIBYTE(v36) < 0) {
      operator delete(v35[0]);
    }
  }
  xpc_object_t v22 = v34;
  v35[0] = v34;
  if (v34)
  {
    xpc_retain(v34);
  }
  else
  {
    xpc_object_t v22 = xpc_null_create();
    v35[0] = v22;
  }
  xpc_object_t v23 = xpc_null_create();
  *(void *)std::string buf = v23;
  sub_1000452AC(162, v35, (xpc_object_t *)buf);
  xpc_release(v23);
  xpc_release(v22);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 88) + 72))(*(void *)(a1 + 88), a1 + 56, a2, a3, a5, a6);
  xpc_release(v34);
}

void sub_10097E438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t object,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

BOOL sub_10097E580(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 3432);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 3432;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == a1 + 3432 || *(_DWORD *)(v3 + 28) > a2) {
    return 0;
  }
  xpc_object_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Baseband service provisioned state: %s", (uint8_t *)&v9, 0xCu);
  }
  return (*(unsigned char *)(v3 + 32) & 0xFD) == 1;
}

void sub_10097E678()
{
}

void sub_10097E680()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/request_dump_state");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10097E714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10097E758(uint64_t a1, int a2, char a3)
{
  int v9 = a2;
  v6[0] = 1;
  long long v7 = 0u;
  uint64_t v8 = 0;
  v6[1] = a1 + 624;
  int v4 = sub_10005DF14((uint64_t *)&v7, a1 + 656);
  uint64_t v10 = &v9;
  *((unsigned char *)sub_10005CE78((uint64_t **)v4, &v9, (uint64_t)&unk_10144E20E, &v10) + 32) = a3;
  return sub_10098CD88((uint64_t)v6);
}

void sub_10097E7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10097E7F4(uint64_t a1, int a2, char a3)
{
  int v9 = a2;
  v6[0] = 1;
  long long v7 = 0u;
  uint64_t v8 = 0;
  v6[1] = a1 + 680;
  int v4 = sub_10005DF14((uint64_t *)&v7, a1 + 712);
  uint64_t v10 = &v9;
  *((unsigned char *)sub_10005CE78((uint64_t **)v4, &v9, (uint64_t)&unk_10144E20E, &v10) + 32) = a3;
  return sub_10098CEBC((uint64_t)v6);
}

void sub_10097E87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10097E890(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 2784);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 2784;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  return v3 != a1 + 2784 && *(_DWORD *)(v3 + 28) <= a2 && *(unsigned char *)(v3 + 32) != 0;
}

uint64_t sub_10097E8E8(uint64_t a1)
{
  if (capabilities::ct::supportsGemini((capabilities::ct *)a1))
  {
    if (subscriber::isValidSimSlot()) {
      return *(unsigned int *)(a1 + 3400);
    }
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Defaulting data preferred sub to sim#1, since the data SIM preference is invalid", v4, 2u);
    }
  }
  return 1;
}

void *sub_10097E974(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10097E9F8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10097EA7C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10097EB00(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10097EB84(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10097EC08(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10097EC08(a1, *a2);
    sub_10097EC08(a1, a2[1]);
    sub_10097EC64((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10097EC64(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  sub_1000D82FC(&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void *sub_10097ECAC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10097ED30(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  uint64_t v5 = *((void *)a2 + 4);
  __dst[3] = *((void *)a2 + 3);
  __dst[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return __dst;
}

void sub_10097ED98(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    long long v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        long long v4 = sub_10098C31C(v4 - 4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10097EE1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = a3 + v6;
      uint64_t v8 = a1 + v6;
      uint64_t v9 = *(void *)(a1 + v6 + 24);
      if (v9)
      {
        if (v8 == v9)
        {
          *(void *)(a3 + v6 + 24) = v7;
          (*(void (**)(void, uint64_t))(**(void **)(v8 + 24) + 24))(*(void *)(v8 + 24), a3 + v6);
          goto LABEL_8;
        }
        uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
      }
      *(void *)(v7 + 24) = v9;
LABEL_8:
      v6 += 32;
      if (a1 + v6 == a2)
      {
        a3 += v6;
        return a3;
      }
    }
  }
  return a3;
}

void sub_10097EEF0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 32;
    do
    {
      sub_10098C548((void *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097EF14(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = sub_10098C548(v4 - 4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_10097EF98(uint64_t a1, long long *a2, long long *a3, void *__dst)
{
  uint64_t v4 = __dst;
  xpc_object_t v12 = __dst;
  xpc_object_t v13 = __dst;
  v10[0] = a1;
  v10[1] = &v12;
  v10[2] = &v13;
  uint64_t v11 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v8 = v13;
      }
      else
      {
        long long v7 = *v6;
        void v4[2] = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
        uint64_t v8 = v4;
      }
      *((_DWORD *)v4 + 6) = *((_DWORD *)v6 + 6);
      v6 += 2;
      uint64_t v4 = v8 + 4;
      xpc_object_t v13 = v8 + 4;
    }
    while (v6 != a3);
  }
  LOBYTE(v11) = 1;
  sub_10016DE78((uint64_t)v10);
  return v4;
}

void sub_10097F04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

std::string *sub_10097F060(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    uint64_t v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      LODWORD(this[1].__r_.__value_.__l.__data_) = v5[1].__r_.__value_.__l.__data_;
      this = (std::string *)((char *)this + 32);
      uint64_t v5 = (std::string *)((char *)v5 + 32);
    }
    while (v5 != a2);
  }
  return this;
}

void sub_10097F0C0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10097F18C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10097F264);
  __cxa_rethrow();
}

void sub_10097F1B4(_Unwind_Exception *a1)
{
}

void sub_10097F1CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10097F204(uint64_t a1)
{
}

uint64_t sub_10097F220(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10097F264(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10097F290(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10097F2DC(uint64_t a1)
{
  sub_100980A44((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_10097F31C(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_10097F414(a1, v3);
}

void sub_10097F3E4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10097F414(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_10097F50C(a1, a2);
}

void sub_10097F4F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_10097F50C(uint64_t *a1, void *a2)
{
}

void sub_10097F580()
{
}

uint64_t *sub_10097F5A4(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1003590CC(a1, a2, 1, 2);
}

void sub_10097F6A0()
{
}

void sub_10097F6C4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A1FF70;
  operator new();
}

void sub_10097F7D8(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_10097F840(uint64_t a1)
{
  sub_10097FBF4(a1);

  operator delete();
}

BOOL sub_10097F878(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_10097FC64((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_10097F928(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10097F958(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10097F984(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_10097F9B0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_10097FA0C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10097FA78(&v2);
}

void sub_10097FA64(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10097FA78(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10097FAE8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10097FB10(v1);
  __cxa_rethrow();
}

void sub_10097FAFC(_Unwind_Exception *a1)
{
}

uint64_t sub_10097FB10(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100980A44((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_10097FB70()
{
}

uint64_t sub_10097FB84(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100980A44((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_10097FBDC()
{
  return 0;
}

uint64_t sub_10097FBE4()
{
  return 0;
}

uint64_t sub_10097FBEC()
{
  return 0;
}

uint64_t sub_10097FBF4(uint64_t a1)
{
  *(void *)a1 = off_101A1FF70;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_10097FC64(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1003593AC((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1003593AC(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_10097FD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10097FD68(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10097FDD4(&v2);
}

void sub_10097FDC0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10097FDD4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10097FE44(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_10097FE7C(_Unwind_Exception *a1)
{
}

void sub_10097FE94()
{
}

uint64_t sub_10097FEA8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10097FED8()
{
  return 0;
}

uint64_t sub_10097FEE0()
{
  return 0;
}

uint64_t sub_10097FEE8()
{
  return 0;
}

dispatch_object_t *sub_10097FEF0(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    xpc_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_10097FF38(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_10097FF90((uint64_t)a1, a2);
  return a1;
}

void sub_10097FF70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100980A44((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10097FF90(uint64_t a1, NSObject **a2)
{
  sub_10098006C(v4, a2);
  sub_10097FFE8((uint64_t *)(a1 + 24), v4);
  return sub_100980DC8((uint64_t)v4);
}

void sub_10097FFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_10097FFE8(uint64_t *a1, NSObject **a2)
{
  sub_10098006C(v4, a2);
  sub_100980134(v5, v4);
  sub_1009800B8(v5, a1);
  sub_100980A44(v5);
  sub_100980DC8((uint64_t)v4);
  return a1;
}

void sub_100980048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_10098006C(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_1009800B8(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100980984((uint64_t)v4, result);
    sub_100980984(v3, a2);
    sub_100980984((uint64_t)a2, (uint64_t *)v4);
    return sub_100980A44((uint64_t *)v4);
  }
  return result;
}

void sub_100980120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100980134(void *a1, NSObject **a2)
{
  sub_10098006C(v4, a2);
  sub_100980194(a1, v4);
  sub_100980DC8((uint64_t)v4);
  return a1;
}

void sub_100980180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100980194(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_10098006C(v4, a2);
  sub_1009801F4((uint64_t)a1, v4);
  sub_100980DC8((uint64_t)v4);
  return a1;
}

void sub_1009801E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1009801F4(uint64_t a1, NSObject **a2)
{
  sub_10098006C(v6, a2);
  int v3 = sub_10098034C((uint64_t)off_101A20078, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_100980DC8((uint64_t)v6);
  if (v3) {
    long long v5 = off_101A20078;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_10098025C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100980270(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10098006C((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100980DC8(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvbEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvbEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_10098034C(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_10098006C(v7, a2);
  uint64_t v5 = sub_10098093C(a1, v7, a3);
  sub_100980DC8((uint64_t)v7);
  return v5;
}

void sub_1009803A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1009803B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlocuint64_t k = v1;
  sub_1009805C4(&v3, &aBlock);
  operator new();
}

void sub_1009804EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, char a11)
{
}

uint64_t sub_100980540(uint64_t a1)
{
  sub_1003595BC(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100980A44(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void *sub_1009805C4(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_100980640(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_100980624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100980640(void *a1, void **a2)
{
  *a1 = 0;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_1009806BC((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1009806A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009806BC(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  int v4 = sub_100980784((uint64_t)off_101A200B8, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_101A200B8;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_100980738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100980754(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_100980808(a1, a2, a3);
  }
}

uint64_t sub_100980774(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100980784(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlocuint64_t k = v5;
  uint64_t v6 = sub_1009808DC(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_1009807EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100980808(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvbEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvbEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_1009808DC(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (int v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_10098093C(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_10098006C(v5, a2);
  sub_10098006C(a3, v5);
  sub_100980DC8((uint64_t)v5);
  return 1;
}

uint64_t sub_100980984(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_100980A20(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_100980A30(_Unwind_Exception *a1)
{
}

uint64_t *sub_100980A44(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100980A98(void *a1)
{
  *a1 = off_101A200E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100980AE4(void *a1)
{
  *a1 = off_101A200E8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100980B50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100980C00(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100980C18(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100980C38()
{
}

void *sub_100980CA4(void *a1)
{
  *a1 = off_101A20138;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100980CF0(void *a1)
{
  *a1 = off_101A20138;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100980D5C()
{
}

uint64_t sub_100980DC8(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_100980E04(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100980E50(uint64_t a1)
{
  sub_100982604((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100980E90(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100980F88(a1, v3);
}

void sub_100980F58(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100980F88(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100981080(a1, a2);
}

void sub_100981068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100981080(uint64_t *a1, void *a2)
{
}

void sub_1009810F4()
{
}

uint64_t *sub_100981118(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_100730830(a1, a2, 1, 2);
}

void sub_100981214()
{
}

void sub_100981238(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A20198;
  operator new();
}

void sub_10098134C(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_1009813B4(uint64_t a1)
{
  sub_100981768(a1);

  operator delete();
}

BOOL sub_1009813EC(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_1009817D8((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_10098149C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009814CC(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_1009814F8(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100981524@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100981580(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1009815EC(&v2);
}

void sub_1009815D8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1009815EC(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10098165C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100981684(v1);
  __cxa_rethrow();
}

void sub_100981670(_Unwind_Exception *a1)
{
}

uint64_t sub_100981684(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100982604((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_1009816E4()
{
}

uint64_t sub_1009816F8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100982604((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100981750()
{
  return 0;
}

uint64_t sub_100981758()
{
  return 0;
}

uint64_t sub_100981760()
{
  return 0;
}

uint64_t sub_100981768(uint64_t a1)
{
  *(void *)a1 = off_101A20198;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_1009817D8(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_100730B10((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100730B10(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_1009818BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1009818DC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100981948(&v2);
}

void sub_100981934(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100981948(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1009819B8(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_1009819F0(_Unwind_Exception *a1)
{
}

void sub_100981A08()
{
}

uint64_t sub_100981A1C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100981A4C()
{
  return 0;
}

uint64_t sub_100981A54()
{
  return 0;
}

uint64_t sub_100981A5C()
{
  return 0;
}

dispatch_object_t *sub_100981A64(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    xpc_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_100981AAC(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_100981B04((uint64_t)a1, a2);
  return a1;
}

void sub_100981AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100982604((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100981B04(uint64_t a1, NSObject **a2)
{
  sub_100981BE0(v4, a2);
  sub_100981B5C((uint64_t *)(a1 + 24), v4);
  return sub_100982658((uint64_t)v4);
}

void sub_100981B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100981B5C(uint64_t *a1, NSObject **a2)
{
  sub_100981BE0(v4, a2);
  sub_100981CA8(v5, v4);
  sub_100981C2C(v5, a1);
  sub_100982604(v5);
  sub_100982658((uint64_t)v4);
  return a1;
}

void sub_100981BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_100981BE0(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_100981C2C(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100982544((uint64_t)v4, result);
    sub_100982544(v3, a2);
    sub_100982544((uint64_t)a2, (uint64_t *)v4);
    return sub_100982604((uint64_t *)v4);
  }
  return result;
}

void sub_100981C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100981CA8(void *a1, NSObject **a2)
{
  sub_100981BE0(v4, a2);
  sub_100981D08(a1, v4);
  sub_100982658((uint64_t)v4);
  return a1;
}

void sub_100981CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100981D08(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_100981BE0(v4, a2);
  sub_100981D68((uint64_t)a1, v4);
  sub_100982658((uint64_t)v4);
  return a1;
}

void sub_100981D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100981D68(uint64_t a1, NSObject **a2)
{
  sub_100981BE0(v6, a2);
  int v3 = sub_100981EC0((uint64_t)off_101A202A0, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_100982658((uint64_t)v6);
  if (v3) {
    long long v5 = off_101A202A0;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_100981DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100981DE4(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100981BE0((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100982658(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENS3_7SimCardEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENS3_7SimCardEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_100981EC0(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100981BE0(v7, a2);
  uint64_t v5 = sub_1009824FC(a1, v7, a3);
  sub_100982658((uint64_t)v7);
  return v5;
}

void sub_100981F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100981F28(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlocuint64_t k = v1;
  sub_100982184(&v3, &aBlock);
  operator new();
}

void sub_100982088(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, char a10)
{
}

uint64_t sub_1009820DC(uint64_t a1)
{
  sub_100730B98(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100982604(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

void *sub_100982184(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_100982200(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1009821E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100982200(void *a1, void **a2)
{
  *a1 = 0;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_10098227C((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_100982260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_10098227C(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  int v4 = sub_100982344((uint64_t)off_101A202E0, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_101A202E0;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_1009822F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100982314(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_1009823C8(a1, a2, a3);
  }
}

uint64_t sub_100982334(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100982344(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlocuint64_t k = v5;
  uint64_t v6 = sub_10098249C(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_1009823AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009823C8(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENS1_7SimCardEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENS1_7SimCardEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_10098249C(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (int v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_1009824FC(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100981BE0(v5, a2);
  sub_100981BE0(a3, v5);
  sub_100982658((uint64_t)v5);
  return 1;
}

uint64_t sub_100982544(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_1009825E0(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_1009825F0(_Unwind_Exception *a1)
{
}

uint64_t *sub_100982604(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100982658(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_100982694(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_1009826E0(void *a1, uint64_t a2, long long **a3)
{
  uint64_t v5 = (void (*)(void *, uint64_t, void *))a1[5];
  uint64_t v4 = a1[6];
  uint64_t v6 = (void *)(a1[4] + (v4 >> 1) - 8);
  if (v4) {
    uint64_t v5 = *(void (**)(void *, uint64_t, void *))(*v6 + v5);
  }
  memset(v7, 0, sizeof(v7));
  sub_1000302C0((char *)v7, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  v5(v6, a2, v7);
  uint64_t v8 = (void **)v7;
  sub_100047F64(&v8);
}

void sub_1009827A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1009827C4()
{
}

__n128 sub_1009827D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A20350;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098282C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20350;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100982864(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1009828AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009828EC()
{
}

void sub_1009828FC()
{
}

__n128 sub_100982910(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A203D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100982964(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A203D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098299C(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void, void))(*v4 + v2);
  }
  return v2(v4, 0, 0);
}

uint64_t sub_100982A1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100982A5C()
{
}

void sub_100982A6C()
{
}

__n128 sub_100982A80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A20450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100982AD4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100982B0C(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100982BF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100982C30()
{
}

void sub_100982C40()
{
}

void *sub_100982C54(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A204D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100982C9C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A204D0;
  a2[1] = v2;
  return result;
}

void sub_100982CC8(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100982DFC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/ims_registration_started");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100982D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100982DB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100982DF0()
{
}

void sub_100982DFC(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v8 = (void *)*a1;
  uint64_t v6 = a1 + 1;
  long long v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_100982F68((uint64_t)(v7 + 4), &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      uint64_t v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          long long v7 = v10;
        }
        while (!v11);
      }
      long long v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100982F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_100982F68(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v14 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v14 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v6;
LABEL_9:
  xpc_release(v5);
  write_rest_value();
  uint64_t v10 = &v14;
  BOOL v11 = "first";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v8 = xpc_BOOL_create(*(unsigned char *)(a1 + 24));
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  BOOL v11 = "second";
  sub_100035E70((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_object_t v7 = v14;
  *a2 = v14;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v14);
}

void sub_1009830E8(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void *sub_10098310C(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100983374(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100983384()
{
}

void *sub_100983398(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20560;
  result[1] = v3;
  return result;
}

uint64_t sub_1009833E0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20560;
  a2[1] = v2;
  return result;
}

void sub_10098340C(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_100983544(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/ims_registration_state");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1009834B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1009834F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100983538()
{
}

void sub_100983544(xpc_object_t *a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v8 = (int *)*a2;
  xpc_object_t v6 = (int *)(a2 + 1);
  xpc_object_t v7 = v8;
  if (v8 != v6)
  {
    do
    {
      xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v10 = v9;
      if (v9)
      {
        xpc_object_t v22 = v9;
      }
      else
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v22 = v10;
        if (!v10)
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t v10 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v11 = xpc_null_create();
LABEL_15:
        xpc_object_t v22 = v11;
        goto LABEL_16;
      }
      xpc_retain(v10);
LABEL_16:
      xpc_release(v10);
      write_rest_value();
      uint64_t v18 = &v22;
      unint64_t v19 = "first";
      sub_100035E70((uint64_t)&v18, &v20, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v20);
      xpc_object_t v20 = 0;
      sub_1005916F8(v7 + 14, &v16);
      uint64_t v18 = &v22;
      unint64_t v19 = "second";
      sub_100035E70((uint64_t)&v18, &v16, &v17);
      xpc_release(v17);
      xpc_object_t v17 = 0;
      xpc_release(v16);
      xpc_object_t v16 = 0;
      xpc_object_t v12 = v22;
      if (v22) {
        xpc_retain(v22);
      }
      else {
        xpc_object_t v12 = xpc_null_create();
      }
      xpc_release(v22);
      xpc_array_append_value(v5, v12);
      xpc_release(v12);
      unsigned int v13 = (int *)*((void *)v7 + 1);
      if (v13)
      {
        do
        {
          xpc_object_t v14 = v13;
          unsigned int v13 = *(int **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          xpc_object_t v14 = (int *)*((void *)v7 + 2);
          BOOL v15 = *(void *)v14 == (void)v7;
          xpc_object_t v7 = v14;
        }
        while (!v15);
      }
      xpc_object_t v7 = v14;
    }
    while (v14 != v6);
  }
  *a1 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_1009837AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void *sub_100983808(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100983A70(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100983A80()
{
}

void *sub_100983A94(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A205F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100983ADC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A205F0;
  a2[1] = v2;
  return result;
}

void sub_100983B08(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v27 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v27 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v9);
        goto LABEL_16;
      }
      xpc_object_t v10 = xpc_null_create();
LABEL_15:
      xpc_object_t v27 = v10;
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      xpc_object_t value = &v27;
      uint64_t v21 = "first";
      sub_100035E70((uint64_t)&value, &v25, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v11 = xpc_array_create(0, 0);
      if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v11);
          xpc_object_t v12 = v11;
        }
        else
        {
          xpc_object_t v12 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v11 = 0;
      }
      xpc_release(v11);
      uint64_t v13 = v6[7];
      uint64_t v14 = v6[8];
      while (v13 != v14)
      {
        sub_100591D54(v13, &value);
        xpc_array_append_value(v12, value);
        xpc_release(value);
        v13 += 32;
      }
      xpc_object_t v23 = v12;
      if (v12) {
        xpc_retain(v12);
      }
      else {
        xpc_object_t v23 = xpc_null_create();
      }
      xpc_release(v12);
      xpc_object_t value = &v27;
      uint64_t v21 = "second";
      sub_100035E70((uint64_t)&value, &v23, &v24);
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v15 = v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        xpc_object_t v15 = xpc_null_create();
      }
      xpc_release(v27);
      xpc_array_append_value(v4, v15);
      xpc_release(v15);
      xpc_object_t v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          xpc_object_t v17 = v16;
          xpc_object_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          xpc_object_t v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          xpc_object_t v6 = v17;
        }
        while (!v18);
      }
      xpc_object_t v6 = v17;
    }
    while (v17 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&value, "/cc/props/ims_registration_identity");
  xpc_object_t v27 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v22 < 0) {
    operator delete(value);
  }
  xpc_release(v19);
}

void sub_100983E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,xpc_object_t object)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100983F74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100983FB4()
{
}

void sub_100983FC4()
{
}

void *sub_100983FD8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20680;
  result[1] = v3;
  return result;
}

uint64_t sub_100984020(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20680;
  a2[1] = v2;
  return result;
}

void sub_10098404C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      sub_1005923A0((uint64_t)(v6 + 7), &v19);
      long long __p = &v23;
      xpc_object_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      xpc_object_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          xpc_object_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          xpc_object_t v6 = v13;
        }
        while (!v14);
      }
      xpc_object_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/ims_feature_state");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_100984304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1009843BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009843FC()
{
}

void sub_10098440C()
{
}

void *sub_100984420(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20710;
  result[1] = v3;
  return result;
}

uint64_t sub_100984468(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20710;
  a2[1] = v2;
  return result;
}

void sub_100984494(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100982DFC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/ims_client_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100984538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10098457C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009845BC()
{
}

void sub_1009845CC()
{
}

void *sub_1009845E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20790;
  result[1] = v3;
  return result;
}

uint64_t sub_100984628(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20790;
  a2[1] = v2;
  return result;
}

void sub_100984654(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      sub_1005935B0((uint64_t)(v6 + 7), &v19);
      long long __p = &v23;
      xpc_object_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      xpc_object_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          xpc_object_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          xpc_object_t v6 = v13;
        }
        while (!v14);
      }
      xpc_object_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/ims_info_ready");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_10098490C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1009849C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100984A04()
{
}

void sub_100984A14()
{
}

void *sub_100984A28(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20820;
  result[1] = v3;
  return result;
}

uint64_t sub_100984A70(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20820;
  a2[1] = v2;
  return result;
}

void sub_100984A9C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      xpc_object_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          xpc_object_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          xpc_object_t v6 = v13;
        }
        while (!v14);
      }
      xpc_object_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/imsi_identity_ready");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_100984D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100984E0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100984E4C()
{
}

void sub_100984E5C()
{
}

void *sub_100984E70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A208B0;
  result[1] = v3;
  return result;
}

uint64_t sub_100984EB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A208B0;
  a2[1] = v2;
  return result;
}

void sub_100984EE4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/carrier_blocks_calls_over_cs");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100984F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100984FCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098500C()
{
}

void sub_10098501C()
{
}

void *sub_100985030(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20930;
  result[1] = v3;
  return result;
}

uint64_t sub_100985078(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20930;
  a2[1] = v2;
  return result;
}

void sub_1009850A4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/operator_blocks_calls_over_cs");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100985148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10098518C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009851CC()
{
}

void sub_1009851DC()
{
}

__n128 sub_1009851F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A209B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100985244(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A209B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098527C(void *a1, xpc *this, BOOL a3)
{
  char v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *char v4 = xpc::dyn_cast_or_default(this, 0, a3);
  xpc_object_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100985318(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985358()
{
}

void sub_100985368()
{
}

__n128 sub_10098537C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A20A30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009853D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20A30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100985408(void *a1)
{
  v6[1] = 0;
  void v6[2] = 0;
  v6[0] = 0xFFFFFFFFLL;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void *))a1[2];
  uint64_t v3 = a1[3];
  char v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void *))(*v4 + v2);
  }
  return v2(v4, v6);
}

uint64_t sub_100985494(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009854D4()
{
}

void sub_1009854E4()
{
}

__n128 sub_1009854F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A20AB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098554C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20AB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100985584(void *a1)
{
  int v7 = 0;
  uint64_t v6 = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  char v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100985608(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985648()
{
}

void sub_100985658()
{
}

__n128 sub_10098566C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20B30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009856C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20B30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009856F8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  int v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *char v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1005BF770((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10003FB28((uint64_t)&v9, v10);
}

void sub_1009857B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009857D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985810()
{
}

void sub_100985820()
{
}

__n128 sub_100985834(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20BB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100985888(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20BB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009858C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985900()
{
}

void sub_100985910()
{
}

__n128 sub_100985924(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20C30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100985978(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009859B0(void *a1, const xpc::object *a2)
{
  char v4 = (const RegisteredNetworkInfo *)a1[1];
  bzero(v9, 0x320uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)v9, v4);
  read_rest_value(v4, a2);
  int v5 = (void (*)(void *, unsigned char *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    int v5 = *(void (**)(void *, unsigned char *))(*v7 + v5);
  }
  v5(v7, v9);
  if (v18 && v17 < 0) {
    operator delete(__p);
  }
  sub_10002B2D8((uint64_t)&v15);
  sub_10002B28C((uint64_t)&v14);
  sub_10002B1F4((uint64_t)&v13);
  sub_10002B1A8((uint64_t)&v12);
  sub_10002B1A8((uint64_t)&v11);
  return sub_10002B240((uint64_t)&v10);
}

void sub_100985AD0(_Unwind_Exception *a1)
{
}

uint64_t sub_100985B30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985B70()
{
}

void sub_100985B80()
{
}

__n128 sub_100985B94(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A20CB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100985BE8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20CB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100985C20(void *a1)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  DWORD2(v6) = -1;
  read_rest_value();
  uint64_t v2 = (void (*)(void *, _OWORD *))a1[2];
  uint64_t v3 = a1[3];
  char v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, _OWORD *))(*v4 + v2);
  }
  v2(v4, v5);
  uint64_t v7 = (void **)v5 + 1;
  sub_100047F64(&v7);
}

void sub_100985CC4(_Unwind_Exception *a1)
{
  *(void *)(v2 - 24) = v1;
  sub_100047F64((void ***)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100985CDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985D1C()
{
}

void sub_100985D2C()
{
}

__n128 sub_100985D40(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20D30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100985D94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100985DCC(uint64_t *a1, xpc_object_t *a2)
{
  sub_10008AAD8(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100985E48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985E88()
{
}

void sub_100985E98()
{
}

__n128 sub_100985EAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20DB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100985F00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20DB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100985F38(uint64_t *a1, xpc_object_t *a2)
{
  sub_10008AAD8(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100985FB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100985FF4()
{
}

void sub_100986004()
{
}

__n128 sub_100986018(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20E30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098606C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20E30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009860A4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  long long v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  xpc_object_t v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100986148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100986164(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009861A4()
{
}

void sub_1009861B4()
{
}

void *sub_1009861C8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A20EB0;
  result[1] = v3;
  return result;
}

uint64_t sub_100986210(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A20EB0;
  a2[1] = v2;
  return result;
}

void sub_10098623C(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100986244(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986284()
{
}

void sub_100986294()
{
}

__n128 sub_1009862A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20F30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009862FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20F30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100986334(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  xpc_object_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100A57F10((uint64_t)v3, a2, "PersonalityID", "IMSProvisioningState");
  long long v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100986404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10098641C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098645C()
{
}

void sub_10098646C()
{
}

__n128 sub_100986480(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A20FB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009864D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A20FB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098650C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1001A789C((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10019D5B8((uint64_t)&v9, v10);
}

void sub_1009865CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009865E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986624()
{
}

void sub_100986634()
{
}

__n128 sub_100986648(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21030;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098669C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009866D4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100986794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009867AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009867EC()
{
}

void sub_1009867FC()
{
}

__n128 sub_100986810(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A210B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100986864(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A210B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098689C(void *a1)
{
  uint64_t v5 = 0x2800000000;
  long long __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_100986934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100986950(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986990()
{
}

void sub_1009869A0()
{
}

__n128 sub_1009869B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21130;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100986A08(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21130;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100986A40(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10008B2E4((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087ED0((uint64_t)&v9, v10);
}

void sub_100986B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100986B18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986B58()
{
}

void sub_100986B68()
{
}

__n128 sub_100986B7C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A211B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100986BD0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A211B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100986C08(void *a1)
{
  long long v6 = &_mh_execute_header;
  int v7 = 0;
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, const mach_header_64 **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, const mach_header_64 **))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100986C94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986CD4()
{
}

void sub_100986CE4()
{
}

__n128 sub_100986CF8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A21230;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100986D4C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21230;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100986D84(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  long long v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    return (*(uint64_t (**)(void))(*v6 + v4))();
  }
  else {
    return v4(v6, a3);
  }
}

uint64_t sub_100986DD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100986E10()
{
}

void sub_100986E20()
{
}

__n128 sub_100986E34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A212B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100986E88(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A212B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100986EC0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  uint64_t v5 = (void *)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  char v18 = *(uint64_t **)v3;
  xpc_object_t v19 = v4;
  if (*(void *)(v3 + 16))
  {
    _OWORD v4[2] = &v19;
    *(void *)uint64_t v3 = v5;
    *uint64_t v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    char v18 = (uint64_t *)&v19;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_10010C01C(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v27, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v26, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v28; ; uint64_t i = ++v28)
    {
      if (i == v26[1] && v27 == v26[0])
      {
        xpc_release(v27);
        xpc_release(v27);
        goto LABEL_45;
      }
      xpc_object_t v25 = 0;
      object[0] = &v27;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v25);
      if (xpc_get_type(v25) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_43:
      xpc_release(v25);
    }
    uint64_t v24 = 0;
    *(_OWORD *)long long __p = 0u;
    *(_OWORD *)xpc_object_t object = 0u;
    memset(v22, 0, sizeof(v22));
    xpc_object_t v9 = v25;
    if (v25)
    {
      xpc_retain(v25);
      v33[0] = (uint64_t)v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      v33[0] = (uint64_t)v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
LABEL_30:
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v30 = v33;
        xpc_object_t v31 = "first";
        sub_100048BAC((uint64_t)&v30, &v29);
        read_rest_value();
        xpc_release(v29);
        xpc_object_t v30 = v33;
        xpc_object_t v31 = "second";
        sub_100048BAC((uint64_t)&v30, &v29);
        sub_1003B35E0((uint64_t)&v22[1], &v29);
        xpc_release(v29);
        xpc_object_t v10 = (xpc_object_t)v33[0];
      }
      xpc_release(v10);
      xpc_release(v9);
      v33[0] = 0;
      uint64_t v11 = (uint64_t **)sub_100046ED4(v3, v33, object);
      if (!*v11)
      {
        uint64_t v32 = 0;
        uint64_t v12 = (char *)operator new(0x68uLL);
        xpc_object_t v30 = (uint64_t *)v12;
        xpc_object_t v31 = (const char *)(v3 + 8);
        LOBYTE(v32) = 0;
        uint64_t v13 = v12 + 32;
        if (SHIBYTE(v22[0]) < 0)
        {
          sub_10004FC84(v13, object[0], (unint64_t)object[1]);
          uint64_t v14 = v30;
        }
        else
        {
          *(_OWORD *)uint64_t v13 = *(_OWORD *)object;
          *((void **)v12 + 6) = v22[0];
          uint64_t v14 = (uint64_t *)v12;
        }
        *(_OWORD *)(v12 + 56) = *(_OWORD *)&v22[1];
        *((void **)v12 + 9) = v22[3];
        memset(&v22[1], 0, 24);
        *((_OWORD *)v12 + 5) = *(_OWORD *)__p;
        *((void *)v12 + 12) = v24;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v24 = 0;
        LOBYTE(v32) = 1;
        sub_100046C38((uint64_t **)v3, v33[0], v11, v14);
        xpc_object_t v30 = 0;
        sub_10010E324((uint64_t)&v30, 0);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v22[3]) < 0) {
        operator delete(v22[1]);
      }
      if (SHIBYTE(v22[0]) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_43;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    v33[0] = (uint64_t)v10;
    goto LABEL_30;
  }
LABEL_45:
  xpc_release(v6);
  uint64_t v15 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v16 = a1[4];
  char v17 = (void *)(a1[2] + (v16 >> 1));
  if (v16) {
    uint64_t v15 = *(void (**)(void *, uint64_t **))(*v17 + v15);
  }
  v15(v17, &v18);
  sub_10010C01C((uint64_t)&v18, v19);
}

void sub_100987308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, xpc_object_t object, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,xpc_object_t a31,xpc_object_t a32,uint64_t a33,xpc_object_t a34)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a34);
  xpc_release(v34);
  sub_10010C01C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100987440(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100987480()
{
}

void sub_100987490()
{
}

__n128 sub_1009874A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21330;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009874F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21330;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100987530(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  xpc_object_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1009875CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098760C()
{
}

void sub_10098761C()
{
}

__n128 sub_100987630(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A213B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100987684(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A213B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009876BC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10098777C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100987794(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009877D4()
{
}

void sub_1009877E4()
{
}

__n128 sub_1009877F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21430;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098784C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21430;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100987884(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100987944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10098795C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098799C()
{
}

void sub_1009879AC()
{
}

void *sub_1009879C0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A214B0;
  result[1] = v3;
  return result;
}

uint64_t sub_100987A08(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A214B0;
  a2[1] = v2;
  return result;
}

void sub_100987A34(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100987A3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100987A7C()
{
}

void sub_100987A8C()
{
}

__n128 sub_100987AA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21530;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100987AF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21530;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100987B2C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  xpc_object_t v9 = (char **)*v3;
  xpc_object_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10031571C((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100987BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100987C04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100987C44()
{
}

void sub_100987C54()
{
}

void *sub_100987C68(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A215B0;
  result[1] = v3;
  return result;
}

uint64_t sub_100987CB0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A215B0;
  a2[1] = v2;
  return result;
}

void sub_100987CDC(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100987CE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100987D24()
{
}

void sub_100987D30(uint64_t *a1, xpc_object_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_1001F299C((uint64_t *)&v4, a2);
  memset(v3, 0, sizeof(v3));
  sub_1001F1EB0(v3, v4, v5, v5 - v4);
  sub_100987DE0(v2, v3);
  uint64_t v7 = v3;
  sub_1001F1FAC((void ***)&v7);
  uint64_t v7 = &v4;
  sub_1001F1FAC((void ***)&v7);
}

void sub_100987DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 24) = v13;
  sub_1001F1FAC((void ***)(v14 - 24));
  *(void *)(v14 - 24) = &a13;
  sub_1001F1FAC((void ***)(v14 - 24));
  _Unwind_Resume(a1);
}

void sub_100987DE0(uint64_t a1, void ***a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    do
    {
      uint64_t v5 = *v2;
      xpc_object_t v13 = v5;
      if (v5) {
        xpc_retain(v5);
      }
      else {
        xpc_object_t v13 = xpc_null_create();
      }
      xpc_object_t v10 = &v13;
      uint64_t v11 = "kCallType";
      sub_100048BAC((uint64_t)&v10, &object);
      int v7 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v6);
      xpc_release(object);
      if ((v7 & 0xFFFFFFFE) == 2)
      {
        xpc_object_t v10 = &v13;
        uint64_t v11 = "kCallSimSlot";
        sub_100048BAC((uint64_t)&v10, &object);
        *(_DWORD *)(a1 + 4) = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v8);
        xpc_release(object);
        xpc_object_t v10 = &v13;
        uint64_t v11 = "kCallSubType";
        sub_100048BAC((uint64_t)&v10, &object);
        *(unsigned char *)a1 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v9);
        xpc_release(object);
        *(_DWORD *)(a1 + 8) = v7;
      }
      xpc_release(v13);
      ++v2;
    }
    while (v2 != v3);
  }
}

void sub_100987F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t object)
{
}

void sub_100987F74()
{
}

__n128 sub_100987F88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21630;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100987FDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21630;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100988014(void *a1, void **a2)
{
  uint64_t v3 = a1[1];
  uint64_t v9 = 0;
  memset(__p, 0, sizeof(__p));
  LODWORD(__p[0]) = *(_DWORD *)v3;
  uint64_t v4 = *(void **)(v3 + 24);
  *(_OWORD *)&__p[1] = *(_OWORD *)(v3 + 8);
  __p[3] = v4;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 8) = 0;
  LODWORD(v9) = *(_DWORD *)(v3 + 32);
  sub_100992C80(v3, a2);
  uint64_t v5 = (void (*)(void *, void **))a1[3];
  uint64_t v6 = a1[4];
  int v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, void **))(*v7 + v5);
  }
  v5(v7, __p);
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
}

void sub_1009880D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009880F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100988130()
{
}

void sub_100988140()
{
}

__n128 sub_100988154(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A216B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009881A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A216B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009881E0(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  int v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v15 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v15, (int *)a2, v7);
    *uint64_t v4 = v15;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  xpc_object_t v10 = (void (*)(void *, int *))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    xpc_object_t v10 = *(void (**)(void *, int *))(*v12 + v10);
  }
  sub_100058DB0(v13, "");
  int v15 = v5;
  if (SHIBYTE(v14) < 0)
  {
    sub_10004FC84(&__p, v13[0], (unint64_t)v13[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v13;
    uint64_t v17 = v14;
  }
  int v18 = 0;
  v10(v12, &v15);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
}

void sub_100988340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100988374(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009883B4()
{
}

void sub_1009883C4()
{
}

__n128 sub_1009883D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21730;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098842C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21730;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100988464(uint64_t a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  sub_1003C8A7C(*(unsigned char **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1009884E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100988520()
{
}

void sub_100988530()
{
}

void *sub_100988544(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A217B0;
  result[1] = v3;
  return result;
}

uint64_t sub_10098858C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A217B0;
  a2[1] = v2;
  return result;
}

void sub_1009885B8(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009885C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100988600()
{
}

void sub_10098860C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1005B25E0(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v13, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v12, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v14; i != v12[1] || v13 != v12[0]; uint64_t i = ++v14)
    {
      xpc_object_t v11 = 0;
      object[0] = &v13;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v11);
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v10 = 0;
        long long v8 = 0u;
        *(_OWORD *)long long __p = 0u;
        *(_OWORD *)xpc_object_t object = 0u;
        xpc_object_t v6 = v11;
        if (v11) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1009888C4((uint64_t)object, &v6);
        xpc_release(v6);
        sub_100988A14((uint64_t **)a1, object, (long long *)object);
        if (SHIBYTE(v10) < 0) {
          operator delete(__p[0]);
        }
        if (SBYTE7(v8) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v11);
    }
    xpc_release(v13);
    xpc_release(v13);
  }
  xpc_release(v3);
}

void sub_100988828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v19 - 48));
  xpc_release(v18);
  _Unwind_Resume(a1);
}

void sub_1009888C4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v2 = *a2;
  xpc_object_t v7 = v2;
  if (v2 && xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v2);
  }
  else
  {
    xpc_object_t v2 = xpc_null_create();
    xpc_object_t v7 = v2;
  }
  if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = &v7;
    int v5 = "first";
    sub_100048BAC((uint64_t)&v4, &object);
    read_rest_value();
    xpc_release(object);
    uint64_t v4 = &v7;
    int v5 = "second";
    sub_100048BAC((uint64_t)&v4, &v3);
    read_rest_value();
    xpc_release(v3);
    xpc_object_t v3 = 0;
    xpc_object_t v2 = v7;
  }
  xpc_release(v2);
}

void sub_1009889BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14)
{
}

uint64_t *sub_100988A14(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  int v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v10, a2);
  xpc_object_t v6 = *v5;
  if (!*v5)
  {
    xpc_object_t v7 = v5;
    memset(v9, 0, sizeof(v9));
    sub_100988AB4((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, v9[0]);
    xpc_object_t v6 = v9[0];
    v9[0] = 0;
    sub_1005B3D9C((uint64_t)v9, 0);
  }
  return v6;
}

void *sub_100988AB4@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = operator new(0x58uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_100988B28(v6 + 4, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100988B10(_Unwind_Exception *a1)
{
  sub_1005B3D9C(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_100988B28(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((_WORD *)__dst + 12) = *((_WORD *)a2 + 12);
  long long v5 = a2[2];
  __dst[6] = *((void *)a2 + 6);
  *((_OWORD *)__dst + 2) = v5;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 4) = 0;
  return __dst;
}

void sub_100988B9C()
{
}

__n128 sub_100988BB0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21830;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100988C04(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21830;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100988C3C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  long long v5 = (void *)(v3 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v17 = *(uint64_t **)v3;
  int v18 = (char *)v4;
  if (*(void *)(v3 + 16))
  {
    *(void *)(v4 + 16) = &v18;
    *(void *)uint64_t v3 = v5;
    *long long v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    uint64_t v17 = (uint64_t *)&v18;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_10005CD2C(v3, *(char **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v24, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v23, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v25; ; uint64_t i = ++v25)
    {
      if (i == v23[1] && v24 == v23[0])
      {
        xpc_release(v24);
        xpc_release(v24);
        goto LABEL_41;
      }
      xpc_object_t v22 = 0;
      object[0] = &v24;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v22);
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_39:
      xpc_release(v22);
    }
    *(_OWORD *)xpc_object_t object = 0u;
    long long v21 = 0u;
    xpc_object_t v9 = v22;
    if (v22)
    {
      xpc_retain(v22);
      v31[0] = (uint64_t)v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      v31[0] = (uint64_t)v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
LABEL_30:
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        __int16 v28 = v31;
        uint64_t v29 = "first";
        sub_100048BAC((uint64_t)&v28, &v27);
        read_rest_value();
        xpc_release(v27);
        __int16 v28 = v31;
        uint64_t v29 = "second";
        sub_100048BAC((uint64_t)&v28, &v26);
        read_rest_value();
        xpc_release(v26);
        xpc_object_t v26 = 0;
        xpc_object_t v10 = (xpc_object_t)v31[0];
      }
      xpc_release(v10);
      xpc_release(v9);
      v31[0] = 0;
      xpc_object_t v11 = (uint64_t **)sub_100046ED4(v3, v31, object);
      if (!*v11)
      {
        uint64_t v30 = 0;
        uint64_t v12 = (uint64_t *)operator new(0x40uLL);
        uint64_t v29 = (const char *)(v3 + 8);
        LOBYTE(v30) = 0;
        xpc_object_t v13 = v12 + 4;
        if (SBYTE7(v21) < 0)
        {
          sub_10004FC84(v13, object[0], (unint64_t)object[1]);
        }
        else
        {
          *(_OWORD *)xpc_object_t v13 = *(_OWORD *)object;
          v12[6] = v21;
        }
        v12[7] = *((void *)&v21 + 1);
        sub_100046C38((uint64_t **)v3, v31[0], v11, v12);
      }
      if (SBYTE7(v21) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_39;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    v31[0] = (uint64_t)v10;
    goto LABEL_30;
  }
LABEL_41:
  xpc_release(v6);
  uint64_t v14 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v15 = a1[4];
  uint64_t v16 = (void *)(a1[2] + (v15 >> 1));
  if (v15) {
    uint64_t v14 = *(void (**)(void *, uint64_t **))(*v16 + v14);
  }
  v14(v16, &v17);
  sub_10005CD2C((uint64_t)&v17, v18);
}

void sub_10098901C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11, char *a12, uint64_t a13, xpc_object_t object, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,xpc_object_t a21,xpc_object_t a22,uint64_t a23,xpc_object_t a24,uint64_t a25,xpc_object_t a26,xpc_object_t a27,uint64_t a28)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a24);
  xpc_release(v28);
  sub_10005CD2C((uint64_t)&a11, a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10098913C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098917C()
{
}

void sub_10098918C()
{
}

__n128 sub_1009891A0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A218B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009891F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A218B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098922C(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v13 = 0;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    uint64_t v15 = "first";
    sub_100048BAC((uint64_t)&p_object, &v16);
    xpc_type_t type = xpc_get_type(v16);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v18 = 0;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v18, (int *)&v16, v6);
      LODWORD(v13) = v18;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      LODWORD(v13) = xpc::dyn_cast_or_default((xpc *)&v16, 0, (uint64_t)v6);
    }
    xpc_release(v16);
    p_xpc_object_t object = &object;
    uint64_t v15 = "second";
    sub_100048BAC((uint64_t)&p_object, &v16);
    xpc_type_t v7 = xpc_get_type(v16);
    if (v7 == (xpc_type_t)&_xpc_type_string)
    {
      int v18 = 0;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v18, (int *)&v16, v8);
      HIDWORD(v13) = v18;
    }
    else if (v7 == (xpc_type_t)&_xpc_type_BOOL {
           || v7 == (xpc_type_t)&_xpc_type_int64
    }
           || v7 == (xpc_type_t)&_xpc_type_uint64)
    {
      HIDWORD(v13) = xpc::dyn_cast_or_default((xpc *)&v16, 0, (uint64_t)v8);
    }
    xpc_release(v16);
  }
  xpc_release(object);
  xpc_object_t v9 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v10 = a1[3];
  xpc_object_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    xpc_object_t v9 = *(uint64_t (**)(void *, uint64_t *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

void sub_100989428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

uint64_t sub_10098947C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009894BC()
{
}

void sub_1009894CC()
{
}

__n128 sub_1009894E0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21930;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100989534(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21930;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098956C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1005BEA0C((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10098962C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100989644(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100989684()
{
}

void sub_100989694()
{
}

__n128 sub_1009896A8(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A219B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009896FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A219B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100989734(uint64_t *a1, xpc_object_t *a2)
{
  sub_100318E34(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  long long v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1009897B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009897F0()
{
}

void sub_100989800()
{
}

__n128 sub_100989814(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21A30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100989868(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21A30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009898A0(uint64_t *a1, xpc_object_t *a2)
{
  sub_100989968(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  long long v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10098991C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098995C()
{
}

void sub_100989968(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    *(void *)&long long v7 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      *(void *)&long long v7 = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, (void **)&v7, count);
    xpc_release((xpc_object_t)v7);
    for (uint64_t i = v11; i != object[1] || v10 != object[0]; uint64_t i = ++v11)
    {
      *((void *)&v7 + 1) = i;
      xpc_object_t v8 = 0;
      *(void *)&long long v7 = &v10;
      sub_10003FBDC((uint64_t)&v7, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        LODWORD(v7) = 0;
        *(void *)((char *)&v7 + 4) = 0x200000000;
        xpc_object_t v6 = v8;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100989BF8((int *)&v7, &v6);
        xpc_release(v6);
        sub_100256DC0((uint64_t **)a1, (int *)&v7, (uint64_t)&v7);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_100989B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100989BF8(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    long long v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    long long v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_100989D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_100989DB0()
{
}

__n128 sub_100989DC4(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21AB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100989E18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21AB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100989E50(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CED98(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  long long v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100989ECC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100989F0C()
{
}

void sub_100989F1C()
{
}

__n128 sub_100989F30(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A21B30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100989F84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21B30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100989FBC(void *a1)
{
  v6[0] = 0;
  v6[1] = 0;
  read_rest_value();
  xpc_object_t v2 = (uint64_t (*)(void *, void *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    xpc_object_t v2 = *(uint64_t (**)(void *, void *))(*v4 + v2);
  }
  return v2(v4, v6);
}

uint64_t sub_10098A03C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A07C()
{
}

void sub_10098A08C()
{
}

__n128 sub_10098A0A0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21BB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098A0F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21BB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098A12C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  xpc_object_t v9 = (char **)*v3;
  int v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100256368((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_10098A1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10098A204(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A244()
{
}

void sub_10098A254()
{
}

__n128 sub_10098A268(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A21C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098A2BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098A2F4(void *a1, xpc_object_t *a2)
{
  uint64_t v7 = 0;
  sub_100034810((int *)&v7, a2);
  uint64_t v3 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t *))(*v5 + v3);
  }
  return v3(v5, &v7);
}

uint64_t sub_10098A374(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A3B4()
{
}

void sub_10098A3C4()
{
}

__n128 sub_10098A3D8(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21CB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098A42C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21CB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098A464(void *a1)
{
  xpc_object_t v2 = (uint64_t *)a1[1];
  uint64_t v3 = *v2;
  uint64_t v4 = *((unsigned int *)v2 + 2);
  read_rest_value();
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v7 + v5);
  }

  return v5(v7, v3, v4);
}

uint64_t sub_10098A4F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A538()
{
}

void sub_10098A548()
{
}

__n128 sub_10098A55C(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21D30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098A5B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098A5E8(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_10098A670(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A6B0()
{
}

void sub_10098A6C0()
{
}

__n128 sub_10098A6D4(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A21DB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098A728(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21DB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098A760(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10093A438((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1007322F4((uint64_t)&v9, v10);
}

void sub_10098A820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10098A838(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098A878()
{
}

void sub_10098A888()
{
}

void *sub_10098A89C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A21E30;
  result[1] = v3;
  return result;
}

uint64_t sub_10098A8E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A21E30;
  a2[1] = v2;
  return result;
}

void sub_10098A910(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_100983544(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/lazuli_registration_state");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10098A9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_10098A9FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098AA3C()
{
}

void sub_10098AA4C()
{
}

void *sub_10098AA60(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A21EB0;
  result[1] = v3;
  return result;
}

uint64_t sub_10098AAA8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A21EB0;
  a2[1] = v2;
  return result;
}

void sub_10098AAD4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100982DFC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/lazuli_client_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10098AB78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10098ABBC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098ABFC()
{
}

void sub_10098AC0C()
{
}

uint64_t sub_10098AC20(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_10098AC2C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10098AC6C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10098AC84(uint64_t **a1, void **a2, uint64_t a3)
{
  xpc_object_t v6 = a1 + 1;
  xpc_object_t v5 = (char *)a1[1];
  uint64_t v7 = (char **)(a1 + 1);
  xpc_object_t v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      xpc_object_t v8 = (char **)v5;
      int v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      xpc_object_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    xpc_object_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  if (!*v7)
  {
LABEL_10:
    uint64_t v15 = 0;
    xpc_object_t v11 = (char *)operator new(0x48uLL);
    v14[0] = v11;
    v14[1] = v6;
    uint64_t v12 = v11 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v12 = *(_OWORD *)a3;
      *((void *)v11 + 6) = *(void *)(a3 + 16);
    }
    *(_OWORD *)(v11 + 56) = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    LOBYTE(v15) = 1;
    *(void *)xpc_object_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    *uint64_t v7 = v11;
    uint64_t v13 = (uint64_t *)**a1;
    if (v13)
    {
      *a1 = v13;
      xpc_object_t v11 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v14[0] = 0;
    sub_1001FEBC4((uint64_t)v14);
  }
}

void sub_10098ADCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10098ADE4()
{
}

__n128 sub_10098ADF8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A21F70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098AE4C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21F70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098AE84(void *a1)
{
  long long v6 = 0xFFFFFFFF00000000;
  uint64_t v7 = 0;
  uint64_t v8 = 2;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, long long *))a1[2];
  uint64_t v3 = a1[3];
  char v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, long long *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_10098AF1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098AF5C()
{
}

void sub_10098AF6C()
{
}

__n128 sub_10098AF80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A21FF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098AFD4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A21FF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098B00C(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  uint64_t v4 = a1[1];
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C(v4, *(char **)(v4 + 8));
  *(void *)uint64_t v4 = v4 + 8;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v21, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v20, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v22; ; uint64_t i = ++v22)
    {
      if (i == v20[1] && v21 == v20[0])
      {
        xpc_release(v21);
        xpc_release(v21);
        goto LABEL_38;
      }
      xpc_object_t v19 = 0;
      object[0] = &v21;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v19);
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_36:
      xpc_release(v19);
    }
    uint64_t v18 = 0;
    *(_OWORD *)xpc_object_t object = 0u;
    long long v17 = 0u;
    DWORD2(v17) = 2;
    xpc_object_t v7 = v19;
    if (v19)
    {
      xpc_retain(v19);
      xpc_object_t v27 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v27 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v24 = (uint64_t *)&v27;
        xpc_object_t v25 = "first";
        sub_100048BAC((uint64_t)&v24, &v23);
        read_rest_value();
        xpc_release(v23);
        xpc_object_t v24 = (uint64_t *)&v27;
        xpc_object_t v25 = "second";
        sub_100048BAC((uint64_t)&v24, &v23);
        read_rest_value();
        xpc_release(v23);
        xpc_object_t v8 = v27;
      }
      xpc_release(v8);
      xpc_release(v7);
      xpc_object_t v27 = 0;
      xpc_object_t v9 = (uint64_t **)sub_100046ED4(v4, &v27, object);
      if (!*v9)
      {
        uint64_t v26 = 0;
        int v10 = (char *)operator new(0x48uLL);
        xpc_object_t v25 = (const char *)(v4 + 8);
        LOBYTE(v26) = 0;
        xpc_object_t v11 = v10 + 32;
        if (SBYTE7(v17) < 0)
        {
          sub_10004FC84(v11, object[0], (unint64_t)object[1]);
        }
        else
        {
          *(_OWORD *)xpc_object_t v11 = *(_OWORD *)object;
          *((void *)v10 + 6) = v17;
        }
        *((void *)v10 + 7) = *((void *)&v17 + 1);
        *((_DWORD *)v10 + 16) = v18;
        sub_100046C38((uint64_t **)v4, (uint64_t)v27, v9, (uint64_t *)v10);
      }
      if (SBYTE7(v17) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_36;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v27 = v8;
    goto LABEL_27;
  }
LABEL_38:
  xpc_release(v3);
  uint64_t v12 = (uint64_t (*)(void *))a1[3];
  uint64_t v13 = a1[4];
  uint64_t v14 = (void *)(a1[2] + (v13 >> 1));
  if (v13) {
    uint64_t v12 = *(uint64_t (**)(void *))(*v14 + v12);
  }

  return v12(v14);
}

void sub_10098B3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, uint64_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,xpc_object_t a21,uint64_t a22,xpc_object_t a23,uint64_t a24,xpc_object_t a25,uint64_t a26)
{
  xpc_release(object);
  xpc_release(a23);
  xpc_release(v26);
  _Unwind_Resume(a1);
}

uint64_t sub_10098B4D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098B518()
{
}

void sub_10098B524(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  sub_100058DB0(&__p, "/cc/events/irat_change");
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  xpc_object_t v7 = operator new(0x20uLL);
  *xpc_object_t v7 = off_101A22070;
  v7[1] = a2;
  xpc_object_t v7[2] = v6;
  void v7[3] = v5;
  void v10[3] = v7;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p);
  }
}

void sub_10098B5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10098B628()
{
}

__n128 sub_10098B63C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A22070;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098B690(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A22070;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10098B6C8(void *a1)
{
  long long v6 = xmmword_1015111A0;
  int v7 = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, long long *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, long long *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_10098B754(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098B794()
{
}

void sub_10098B7A4()
{
}

__n128 sub_10098B7B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A220F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10098B80C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A220F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098B844(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  uint64_t v10 = 0;
  long long v8 = 0u;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)int v7 = 0u;
  xpc_object_t v14 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v14 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v11 = &v14;
    uint64_t v12 = "first";
    sub_100048BAC((uint64_t)&v11, &v13);
    read_rest_value();
    xpc_release(v13);
    xpc_object_t v11 = &v14;
    uint64_t v12 = "second";
    sub_100048BAC((uint64_t)&v11, &v13);
    read_rest_value();
    xpc_release(v13);
    xpc_object_t v3 = v14;
  }
  xpc_release(v3);
  uint64_t v4 = (void (*)(void *, void **))a1[2];
  uint64_t v5 = a1[3];
  long long v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, void **))(*v6 + v4);
  }
  v4(v6, v7);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SBYTE7(v8) < 0) {
    operator delete(v7[0]);
  }
}

void sub_10098B9B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
  xpc_release(*(xpc_object_t *)(v17 - 48));
  xpc_release(*(xpc_object_t *)(v17 - 40));
  if (__p) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10098BA34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098BA74()
{
}

void sub_10098BA84()
{
}

__n128 sub_10098BA98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A22170;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098BAEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A22170;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098BB24(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  char v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    char v9 = &v10;
  }
  sub_10096DD7C((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10098BBE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10098BBFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098BC3C()
{
}

void sub_10098BC4C()
{
}

__n128 sub_10098BC60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A221F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10098BCB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A221F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10098BCEC(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  char v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    char v9 = &v10;
  }
  sub_1000E4B84((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_10098BDAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10098BDC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098BE04()
{
}

void sub_10098BE10(uint64_t **a1, uint64_t *a2)
{
  xpc_object_t v3 = (uint64_t *)a2[1];
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      xpc_object_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v4 = (uint64_t *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  uint64_t v7 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_10005EE6C(v7, a2);
  long long v8 = (std::__shared_weak_count *)a2[6];
  if (v8) {
    sub_10004D2C8(v8);
  }

  operator delete(a2);
}

uint64_t sub_10098BEA8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098BF0C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098BF70(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098BFD4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098C038(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_10098C09C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    uint64_t v7 = *v6;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        long long v8 = a3;
      }
      else {
        long long v8 = (uint64_t *)*a3;
      }
      uint64_t v9 = asStringBool(*((unsigned char *)a3 + 80));
      *(_DWORD *)uint64_t v10 = 136315394;
      *(void *)&void v10[4] = v8;
      *(_WORD *)&v10[12] = 2080;
      *(void *)&v10[14] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Phone number: %s, read attempted: %s", v10, 0x16u);
    }
    *(void *)uint64_t v10 = 0;
    *(void *)&v10[8] = 0;
    sub_10098C220((uint64_t *)v10);
    (*(void (**)(void, uint64_t, unsigned char *, void))(**(void **)(a1 + 72) + 168))(*(void *)(a1 + 72), a2, v10, *((unsigned __int8 *)a3 + 80));
    if (*(void *)&v10[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v10[8]);
    }
  }
}

void sub_10098C200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10098C220(uint64_t *a1)
{
  uint64_t v2 = operator new(0xA0uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = off_101A22270;
  uint64_t result = CSIPhoneNumber::CSIPhoneNumber();
  *a1 = result;
  a1[1] = (uint64_t)v2;
  return result;
}

void sub_10098C284(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_10098C29C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A22270;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10098C2BC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A22270;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10098C310(uint64_t a1)
{
}

void *sub_10098C31C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10098C3A4()
{
}

void *sub_10098C3B8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A222C0;
  return result;
}

void sub_10098C3F0(uint64_t a1, void *a2)
{
  *a2 = off_101A222C0;
}

BOOL sub_10098C418(uint64_t a1, _DWORD *a2)
{
  return *a2 == 0;
}

uint64_t sub_10098C428(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C468()
{
}

void sub_10098C478()
{
}

void *sub_10098C48C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A22350;
  return result;
}

void sub_10098C4C4(uint64_t a1, void *a2)
{
  *a2 = off_101A22350;
}

BOOL sub_10098C4EC(uint64_t a1, _DWORD *a2)
{
  return *a2 != 0;
}

uint64_t sub_10098C4FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C53C()
{
}

void *sub_10098C548(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10098C5D0()
{
}

void *sub_10098C5E4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A223D0;
  return result;
}

void sub_10098C61C(uint64_t a1, void *a2)
{
  *a2 = off_101A223D0;
}

BOOL sub_10098C644(uint64_t a1, _DWORD *a2)
{
  return *a2 != 2;
}

uint64_t sub_10098C654(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C694()
{
}

void sub_10098C6A4()
{
}

void *sub_10098C6B8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A22460;
  return result;
}

void sub_10098C6F0(uint64_t a1, void *a2)
{
  *a2 = off_101A22460;
}

BOOL sub_10098C718(uint64_t a1, _DWORD *a2)
{
  return *a2 == 2;
}

uint64_t sub_10098C728(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C768()
{
}

void sub_10098C778()
{
}

void *sub_10098C78C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A224E0;
  return result;
}

void sub_10098C7C4(uint64_t a1, void *a2)
{
  *a2 = off_101A224E0;
}

BOOL sub_10098C7EC(uint64_t a1, _DWORD *a2)
{
  return *a2 != 2;
}

uint64_t sub_10098C7FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C83C()
{
}

void sub_10098C84C()
{
}

void *sub_10098C860()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A22560;
  return result;
}

void sub_10098C898(uint64_t a1, void *a2)
{
  *a2 = off_101A22560;
}

BOOL sub_10098C8C0(uint64_t a1, _DWORD *a2)
{
  return *a2 == 2;
}

uint64_t sub_10098C8D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098C910()
{
}

char *sub_10098C91C(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v12 = 0;
  uint64_t v5 = (void **)sub_100046ED4((uint64_t)a1, &v12, a2);
  BOOL v6 = (char *)*v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    long long v8 = *a3;
    BOOL v6 = (char *)operator new(0x50uLL);
    uint64_t v9 = v6 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v9, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *((void *)v6 + 6) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v9 = v10;
    }
    *((_DWORD *)v6 + 16) = 0;
    *((void *)v6 + 7) = 0;
    *(void *)(v6 + 68) = 0xFFFFFFFF00000002;
    sub_100046C38(a1, v12, v7, (uint64_t *)v6);
  }
  return v6;
}

void sub_10098C9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  sub_1000C6EE8(v10, v9);
  _Unwind_Resume(a1);
}

uint64_t sub_10098CA0C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098CA70(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_10098CAD4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10097EC64((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_10098CB30()
{
}

void *sub_10098CB44(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A225E0;
  result[1] = v3;
  return result;
}

uint64_t sub_10098CB8C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A225E0;
  a2[1] = v2;
  return result;
}

void sub_10098CBB8(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      uint64_t v4 = "is";
    }
    else {
      uint64_t v4 = "is not";
    }
    int v5 = 136315138;
    BOOL v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFiCalling-only mode: true. Baseband booted assertion %s granted", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_10098CC74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10098CCB4()
{
}

uint64_t sub_10098CCC0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098CD24(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_10098CD88(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      int v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        long long v8 = v4;
        if (v7)
        {
          do
          {
            uint64_t v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            long long v8 = v4;
          }
          while (!v6);
        }
        uint64_t v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            uint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            int v5 = v10;
          }
          while (!v6);
        }
        int v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_10098CEBC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      int v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        long long v8 = v4;
        if (v7)
        {
          do
          {
            uint64_t v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            long long v8 = v4;
          }
          while (!v6);
        }
        uint64_t v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            uint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            int v5 = v10;
          }
          while (!v6);
        }
        int v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_10098CFF0(uint64_t a1, Registry **a2, os_log_t *a3, uint64_t a4)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  xpc_object_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_7;
      }
LABEL_11:
      CFTypeRef cf = 0;
      int v83 = 0;
      uint64_t v19 = *(unsigned __int8 *)(a4 + 119);
      if ((v19 & 0x80u) != 0) {
        uint64_t v19 = *(void *)(a4 + 104);
      }
      if (!v19) {
        goto LABEL_24;
      }
      uint64_t v20 = *(unsigned __int8 *)(a4 + 143);
      if ((v20 & 0x80u) != 0) {
        uint64_t v20 = *(void *)(a4 + 128);
      }
      if (v20)
      {
        memset(&v82, 0, sizeof(v82));
        createPLMN();
        std::string::size_type size = HIBYTE(v82.__r_.__value_.__r.__words[2]);
        if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = v82.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            xpc_object_t v23 = v83;
            int v83 = Mutable;
            *(void *)std::string buf = v23;
            sub_10005717C((const void **)buf);
          }
          if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = v82;
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = __str;
          }
          v77.__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            v68[0] = (void *)__dst.__r_.__value_.__r.__words[2];
          }
          v79.__r_.__value_.__r.__words[0] = 0;
          if (ctu::cf::convert_copy())
          {
            std::string::size_type v24 = v77.__r_.__value_.__r.__words[0];
            v77.__r_.__value_.__r.__words[0] = v79.__r_.__value_.__r.__words[0];
            __p.__r_.__value_.__r.__words[0] = v24;
            sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v68[0]) < 0) {
            operator delete(*(void **)buf);
          }
          v86 = (const void *)v77.__r_.__value_.__r.__words[0];
          v77.__r_.__value_.__r.__words[0] = 0;
          sub_1000558F4((const void **)&v77.__r_.__value_.__l.__data_);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          sub_10010F3F0(v83, (void *)qword_101B13EC0, (uint64_t)v86);
          sub_1000558F4(&v86);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          if (*(char *)(a4 + 167) < 0) {
            sub_10004FC84(&__p, *(void **)(a4 + 144), *(void *)(a4 + 152));
          }
          else {
            std::string __p = *(std::string *)(a4 + 144);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = __p;
          }
          v86 = 0;
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            v68[0] = (void *)__dst.__r_.__value_.__r.__words[2];
          }
          v77.__r_.__value_.__r.__words[0] = 0;
          if (ctu::cf::convert_copy())
          {
            std::string::size_type v25 = (std::string::size_type)v86;
            v86 = (const void *)v77.__r_.__value_.__r.__words[0];
            v79.__r_.__value_.__r.__words[0] = v25;
            sub_1000558F4((const void **)&v79.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v68[0]) < 0) {
            operator delete(*(void **)buf);
          }
          v85 = v86;
          v86 = 0;
          sub_1000558F4(&v86);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          sub_10010F3F0(v83, @"GID1", (uint64_t)v85);
          sub_1000558F4(&v85);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (*(char *)(a4 + 191) < 0) {
            sub_10004FC84(&v79, *(void **)(a4 + 168), *(void *)(a4 + 176));
          }
          else {
            std::string v79 = *(std::string *)(a4 + 168);
          }
          if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v79.__r_.__value_.__l.__data_, v79.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v79;
          }
          v85 = 0;
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            v68[0] = (void *)__dst.__r_.__value_.__r.__words[2];
          }
          v86 = 0;
          if (ctu::cf::convert_copy())
          {
            std::string::size_type v26 = (std::string::size_type)v85;
            v85 = v86;
            v77.__r_.__value_.__r.__words[0] = v26;
            sub_1000558F4((const void **)&v77.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v68[0]) < 0) {
            operator delete(*(void **)buf);
          }
          int v84 = v85;
          v85 = 0;
          sub_1000558F4(&v85);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          sub_10010F3F0(v83, @"GID2", (uint64_t)v84);
          sub_1000558F4(&v84);
          if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v79.__r_.__value_.__l.__data_);
          }
          if (*(char *)(a4 + 39) < 0) {
            sub_10004FC84(&v77, *(void **)(a4 + 16), *(void *)(a4 + 24));
          }
          else {
            std::string v77 = *(std::string *)(a4 + 16);
          }
          if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v77.__r_.__value_.__l.__data_, v77.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v77;
          }
          int v84 = 0;
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            v68[0] = (void *)__dst.__r_.__value_.__r.__words[2];
          }
          v85 = 0;
          if (ctu::cf::convert_copy())
          {
            xpc_object_t v27 = v84;
            int v84 = v85;
            v86 = v27;
            sub_1000558F4(&v86);
          }
          if (SHIBYTE(v68[0]) < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v28 = (uint64_t)v84;
          v78 = v84;
          int v84 = 0;
          sub_1000558F4(&v84);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          sub_10010F3F0(v83, (void *)qword_101B13EB8, v28);
          sub_1000558F4(&v78);
          if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v77.__r_.__value_.__l.__data_);
          }
        }
        sub_10004EFE4(&cf, (CFTypeRef *)&v83);
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v82.__r_.__value_.__l.__data_);
        }
      }
      else
      {
LABEL_24:
        sub_10004EFE4(&cf, (CFTypeRef *)&v83);
      }
      sub_10005717C((const void **)&v83);
      if (cf) {
        uint64_t v29 = sub_100080778;
      }
      else {
        uint64_t v29 = 0;
      }
      if (!v29)
      {
        uint64_t v30 = *a3;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No matching bundle info", buf, 2u);
        }
        goto LABEL_174;
      }
      memset(&v75, 0, sizeof(v75));
      *(_OWORD *)v73 = 0u;
      long long v74 = 0u;
      *(_OWORD *)uint64_t v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      *(_OWORD *)uint64_t v70 = 0u;
      *(_OWORD *)std::string buf = 0u;
      *(_OWORD *)unsigned int v68 = 0u;
      CFTypeRef v66 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, CFTypeRef *))(*(void *)v16 + 32))(buf, v16, &v66);
      sub_100057D78(&v66);
      memset(&v82, 0, sizeof(v82));
      if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v82, v75.__r_.__value_.__l.__data_, v75.__r_.__value_.__l.__size_);
      }
      else {
        std::string v82 = v75;
      }
      std::string::size_type v31 = HIBYTE(v82.__r_.__value_.__r.__words[2]);
      if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v31 = v82.__r_.__value_.__l.__size_;
      }
      if (!v31)
      {
        uint64_t v40 = *a3;
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Bundle lookup failed", (uint8_t *)&__dst, 2u);
        }
        goto LABEL_160;
      }
      __p.__r_.__value_.__r.__words[0] = 0;
      Registry::getFileSystemInterface((uint64_t *)&__dst, *a2);
      (*(void (**)(std::string *__return_ptr))(*(void *)__dst.__r_.__value_.__l.__data_ + 152))(&__p);
      if (__dst.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
      }
      if (__p.__r_.__value_.__r.__words[0]) {
        uint64_t v32 = sub_100080778;
      }
      else {
        uint64_t v32 = 0;
      }
      if (v32)
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)__p.__r_.__value_.__l.__data_, @"BootstrapSettings");
        CFDictionaryRef v34 = Value;
        if (Value && (CFTypeID v35 = CFGetTypeID(Value), v35 == CFDictionaryGetTypeID()))
        {
          uint64_t v36 = (unsigned int *)CFDictionaryGetValue(v34, @"BootstrapSignallingReductionTimeout");
          unsigned int v37 = v36;
          LODWORD(__dst.__r_.__value_.__l.__data_) = 0;
          if (v36)
          {
            CFTypeID v38 = CFGetTypeID(v36);
            if (v38 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&__dst, v37, v39);
            }
          }
          *(_DWORD *)(a1 + 28) = __dst.__r_.__value_.__l.__data_;
        }
        else
        {
          char v41 = *a3;
          if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I No bootstrap settings", (uint8_t *)&__dst, 2u);
          }
        }
        CFDictionaryRef v42 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)__p.__r_.__value_.__l.__data_, @"CellularPlanSettings");
        CFDictionaryRef v43 = v42;
        if (v42)
        {
          CFTypeID v44 = CFGetTypeID(v42);
          if (v44 == CFDictionaryGetTypeID())
          {
            CFDictionaryRef v45 = (const __CFDictionary *)CFDictionaryGetValue(v43, @"Proxy");
            CFDictionaryRef v46 = v45;
            if (v45)
            {
              CFTypeID v47 = CFGetTypeID(v45);
              if (v47 == CFDictionaryGetTypeID())
              {
                CFDictionaryRef v48 = (const __CFDictionary *)CFDictionaryGetValue(v46, @"ProxySettings");
                CFDictionaryRef v49 = v48;
                if (v48)
                {
                  CFTypeID v50 = CFGetTypeID(v48);
                  if (v50 != CFDictionaryGetTypeID()) {
                    CFDictionaryRef v49 = 0;
                  }
                }
                memset(&__str, 0, sizeof(__str));
                CFDictionaryGetValue(v49, @"HOST");
                memset(&__dst, 0, sizeof(__dst));
                ctu::cf::assign();
                std::string __str = __dst;
                BOOL v51 = (unsigned int *)CFDictionaryGetValue(v49, @"PORT");
                long long v52 = v51;
                LODWORD(__dst.__r_.__value_.__l.__data_) = 0;
                if (v51)
                {
                  CFTypeID v53 = CFGetTypeID(v51);
                  if (v53 == CFNumberGetTypeID()) {
                    ctu::cf::assign((ctu::cf *)&__dst, v52, v54);
                  }
                }
                int data = (int)__dst.__r_.__value_.__l.__data_;
                CFStringRef v56 = *a3;
                if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
                {
                  p_str = &__str;
                  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
                  WORD2(__dst.__r_.__value_.__r.__words[1]) = 1024;
                  *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = data;
                  _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I cellular plan settings found : %s : %u", (uint8_t *)&__dst, 0x12u);
                }
                if (sub_10004D710())
                {
                  LODWORD(v79.__r_.__value_.__l.__data_) = -1;
                  uint64_t v58 = sub_100365D74();
                  sub_100058DB0(&__dst, "TestProxyIndexKey");
                  sub_1004421D8(v58, (void **)&__dst.__r_.__value_.__l.__data_, &v79);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  int v59 = (int)v79.__r_.__value_.__l.__data_;
                  if (((uint64_t)v79.__r_.__value_.__l.__data_ & 0x80000000) == 0)
                  {
                    CFStringRef v60 = *a3;
                    if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(__dst.__r_.__value_.__l.__data_) = 67109120;
                      HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v59;
                      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I override cellular plan settings found : %d", (uint8_t *)&__dst, 8u);
                      int v59 = (int)v79.__r_.__value_.__l.__data_;
                    }
                    uint64_t v61 = (const std::string *)&unk_101B0E280;
                    switch(v59)
                    {
                      case 0:
                        goto LABEL_145;
                      case 1:
                        goto LABEL_154;
                      case 2:
                        uint64_t v61 = (const std::string *)&unk_101B0E298;
LABEL_145:
                        std::string::operator=(&__str, v61);
                        int data = 80;
                        break;
                      case 3:
                        uint64_t v61 = (const std::string *)&unk_101B0E298;
LABEL_154:
                        std::string::operator=(&__str, v61);
                        int data = 443;
                        break;
                      default:
                        uint64_t v64 = *a3;
                        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
                          _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "unknown test proxy index", (uint8_t *)&__dst, 2u);
                        }
                        break;
                    }
                  }
                }
                std::string::operator=((std::string *)a1, &__str);
                *(_DWORD *)(a1 + 24) = data;
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
                goto LABEL_159;
              }
            }
            CFStringRef v62 = *a3;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
              uint64_t v63 = "No proxy key";
              goto LABEL_152;
            }
LABEL_159:
            sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
LABEL_160:
            if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v82.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v75.__r_.__value_.__l.__data_);
            }
            if (SBYTE7(v74) < 0) {
              operator delete(v73[0]);
            }
            if (SHIBYTE(v72) < 0) {
              operator delete(v71[1]);
            }
            if (SHIBYTE(v71[0]) < 0) {
              operator delete(v70[0]);
            }
            if (SHIBYTE(v69) < 0) {
              operator delete(v68[1]);
            }
            if (SHIBYTE(v68[0]) < 0) {
              operator delete(*(void **)buf);
            }
LABEL_174:
            sub_100057D78(&cf);
            goto LABEL_175;
          }
        }
        CFStringRef v62 = *a3;
        if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          goto LABEL_159;
        }
        LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
        uint64_t v63 = "No cellular plan settings key";
      }
      else
      {
        CFStringRef v62 = *a3;
        if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
          goto LABEL_159;
        }
        LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
        uint64_t v63 = "Missing carrier bundle";
      }
LABEL_152:
      _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v63, (uint8_t *)&__dst, 2u);
      goto LABEL_159;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
  if (v16) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v18 = *a3;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Missing carrier bundle interface", buf, 2u);
  }
LABEL_175:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  return a1;
}

void sub_10098DD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,const void *a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (*(char *)(v56 - 89) < 0) {
    operator delete(*(void **)(v56 - 112));
  }
  if (*(char *)(v56 - 185) < 0) {
    operator delete(*(void **)(v56 - 208));
  }
  sub_100057D78((const void **)&a48);
  if (*(char *)(v56 - 153) < 0) {
    operator delete(*(void **)(v56 - 176));
  }
  sub_10015C5A0((uint64_t)&a11);
  sub_100057D78(&a33);
  if ((v55 & 1) == 0) {
    sub_10004D2C8(v54);
  }
  if (*(char *)(v53 + 23) < 0) {
    operator delete(*(void **)v53);
  }
  _Unwind_Resume(a1);
}

double sub_10098DFC0@<D0>(long long *a1@<X0>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    if (!*((void *)a1 + 1))
    {
LABEL_8:
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 32) = 0;
      return result;
    }
  }
  else if (!*((unsigned char *)a1 + 23))
  {
    goto LABEL_8;
  }
  int v4 = *((_DWORD *)a1 + 6);
  if (!v4) {
    goto LABEL_8;
  }
  if ((*((unsigned char *)a1 + 23) & 0x80) != 0)
  {
    sub_10004FC84(&v6, *(void **)a1, *((void *)a1 + 1));
    int v4 = *((_DWORD *)a1 + 6);
  }
  else
  {
    long long v6 = *a1;
    uint64_t v7 = *((void *)a1 + 2);
  }
  double result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v7;
  *(_DWORD *)(a2 + 24) = v4;
  *(unsigned char *)(a2 + 32) = 1;
  return result;
}

uint64_t sub_10098E064()
{
  sub_100058DB0(qword_101B0E280, "sq-device-proxy-stage.apple.com");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0E280, (void *)&_mh_execute_header);
  sub_100058DB0(qword_101B0E298, "sq-device-proxy.apple.com");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0E298, (void *)&_mh_execute_header);
}

void sub_10098E0F8(uint64_t a1, os_log_t *a2, uint64_t a3, const std::string *a4, uint64_t *a5, void *a6)
{
  CFDictionaryRef v46 = a2;
  uint64_t v10 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = 0x8F5C28F5C28F5C29 * ((a5[1] - *a5) >> 3);
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a6[1] - *a6) >> 3);
    *(_DWORD *)std::string buf = 134218240;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Init CellularPlanTransferDeviceInfo with %ld blacklist plans and %ld whitelist plans", buf, 0x16u);
  }
  if (*(unsigned char *)(a3 + 240))
  {
    if (!*(unsigned char *)(a3 + 56)) {
      goto LABEL_8;
    }
    uint64_t v14 = *(unsigned __int8 *)(a3 + 87);
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *(void *)(a3 + 72);
    }
    if (!v14)
    {
LABEL_8:
      for (std::string::pointer i = a4[5].__r_.__value_.__l.__data_; i != (std::string::pointer)a4[5].__r_.__value_.__l.__size_; i += 80)
      {
        if (*(_DWORD *)i == 1)
        {
          sub_10032AFC0((unsigned char *)(a3 + 56), (const std::string *)(i + 8));
          break;
        }
      }
    }
    v45[0] = a6;
    v45[1] = &v46;
    uint64_t v16 = *a5;
    uint64_t v17 = a5[1];
    if (*a5 != v17)
    {
      do
      {
        if (*(unsigned char *)(a3 + 56))
        {
          uint64_t v18 = *(unsigned __int8 *)(a3 + 87);
          size_t v11 = *(void *)(a3 + 72);
          if ((v18 & 0x80u) == 0) {
            uint64_t v19 = *(unsigned __int8 *)(a3 + 87);
          }
          else {
            uint64_t v19 = *(void *)(a3 + 72);
          }
          int v20 = *(char *)(v16 + 47);
          uint64_t v21 = *(unsigned __int8 *)(v16 + 47);
          uint64_t v22 = *(void *)(v16 + 32);
          if (v20 >= 0) {
            uint64_t v22 = *(unsigned __int8 *)(v16 + 47);
          }
          if (v19 == v22)
          {
            if (v20 >= 0) {
              xpc_object_t v23 = (unsigned __int8 *)(v16 + 24);
            }
            else {
              xpc_object_t v23 = *(unsigned __int8 **)(v16 + 24);
            }
            if ((v18 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(a3 + 64), v23, v11))
              {
LABEL_39:
                uint64_t v26 = *(void *)(a3 + 200);
                uint64_t v25 = *(void *)(a3 + 208);
                while (v26 != v25)
                {
                  if (*(unsigned char *)(v26 + 80)) {
                    sub_10098E518((uint64_t)v45, v26, v16);
                  }
                  v26 += 88;
                }
                goto LABEL_68;
              }
            }
            else
            {
              if (!*(unsigned char *)(a3 + 87)) {
                goto LABEL_39;
              }
              std::string::size_type v24 = (unsigned __int8 *)(a3 + 64);
              while (*v24 == *v23)
              {
                ++v24;
                ++v23;
                if (!--v18) {
                  goto LABEL_39;
                }
              }
            }
          }
        }
        else
        {
          uint64_t v21 = *(unsigned __int8 *)(v16 + 47);
        }
        if ((v21 & 0x80) != 0)
        {
          if (*(void *)(v16 + 32)) {
            goto LABEL_68;
          }
        }
        else if (v21)
        {
          goto LABEL_68;
        }
        if (*(char *)(v16 + 71) < 0)
        {
          if (!*(void *)(v16 + 56)) {
            goto LABEL_68;
          }
        }
        else if (!*(unsigned char *)(v16 + 71))
        {
          goto LABEL_68;
        }
        uint64_t v27 = *(void *)(a3 + 200);
        uint64_t v28 = *(void *)(a3 + 208);
        while (v27 != v28)
        {
          if (!*(unsigned char *)(v27 + 80)) {
            goto LABEL_67;
          }
          memset(buf, 0, sizeof(buf));
          ctu::hex((uint64_t *)buf, (ctu *)(v27 + 16), (const void *)0x10, v11);
          uint64_t v29 = buf[23];
          uint8_t v30 = buf[23];
          size_t v11 = *(void *)&buf[8];
          if ((buf[23] & 0x80u) == 0) {
            uint64_t v31 = buf[23];
          }
          else {
            uint64_t v31 = *(void *)&buf[8];
          }
          uint64_t v32 = *(unsigned __int8 *)(v16 + 71);
          int v33 = (char)v32;
          if ((v32 & 0x80u) != 0) {
            uint64_t v32 = *(void *)(v16 + 56);
          }
          if (v31 == v32)
          {
            if (v33 >= 0) {
              CFDictionaryRef v34 = (unsigned __int8 *)(v16 + 48);
            }
            else {
              CFDictionaryRef v34 = *(unsigned __int8 **)(v16 + 48);
            }
            if ((char)buf[23] < 0)
            {
              uint64_t v36 = *(void **)buf;
              if (memcmp(*(const void **)buf, v34, *(size_t *)&buf[8])) {
                goto LABEL_66;
              }
LABEL_63:
              sub_10098E518((uint64_t)v45, v27, v16);
              uint8_t v30 = buf[23];
              goto LABEL_64;
            }
            if (!buf[23]) {
              goto LABEL_63;
            }
            CFTypeID v35 = buf;
            while (*v35 == *v34)
            {
              ++v35;
              ++v34;
              if (!--v29) {
                goto LABEL_63;
              }
            }
          }
LABEL_64:
          if ((v30 & 0x80) != 0)
          {
            uint64_t v36 = *(void **)buf;
LABEL_66:
            operator delete(v36);
          }
LABEL_67:
          v27 += 88;
        }
LABEL_68:
        v16 += 200;
      }
      while (v16 != v17);
    }
  }
  sub_100991F10(a1, a3);
  sub_10098E704((std::string *)(a1 + 248), a4);
  uint64_t v37 = *(void *)(a1 + 368);
  uint64_t v38 = *(void *)(a1 + 376);
  while (v37 != v38)
  {
    CFNumberRef v39 = *(void **)(v37 + 56);
    if (v39 != (void *)(v37 + 64))
    {
      do
      {
        uint64_t v40 = (void **)(v39 + 7);
        sub_100CD6B88((const void **)v39 + 7, (uint64_t)(v39 + 19), (uint64_t)buf);
        if (*((char *)v39 + 79) < 0) {
          operator delete(*v40);
        }
        *(_OWORD *)uint64_t v40 = *(_OWORD *)buf;
        v39[9] = *(void *)&buf[16];
        char v41 = (void *)v39[1];
        if (v41)
        {
          do
          {
            CFDictionaryRef v42 = v41;
            char v41 = (void *)*v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            CFDictionaryRef v42 = (void *)v39[2];
            BOOL v43 = *v42 == (void)v39;
            CFNumberRef v39 = v42;
          }
          while (!v43);
        }
        CFNumberRef v39 = v42;
      }
      while (v42 != (void *)(v37 + 64));
    }
    v37 += 80;
  }
}

void sub_10098E4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10098E518(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 56);
  uint64_t v4 = *(void *)(a2 + 64);
  if (v3 != v4)
  {
    uint64_t v7 = result;
    long long v8 = (const void **)(a3 + 72);
    do
    {
      uint64_t v9 = *(unsigned __int8 *)(a3 + 95);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = *(unsigned __int8 *)(a3 + 95);
      }
      else {
        uint64_t v10 = *(void *)(a3 + 80);
      }
      uint64_t v11 = *(unsigned __int8 *)(v3 + 39);
      int v12 = (char)v11;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(v3 + 24);
      }
      if (v10 != v11) {
        goto LABEL_21;
      }
      unint64_t v13 = (void *)(v3 + 16);
      if (v12 >= 0) {
        uint64_t v14 = (unsigned __int8 *)(v3 + 16);
      }
      else {
        uint64_t v14 = *(unsigned __int8 **)(v3 + 16);
      }
      if ((v9 & 0x80) != 0)
      {
        double result = memcmp(*v8, v14, *(void *)(a3 + 80));
        if (result) {
          goto LABEL_21;
        }
      }
      else if (*(unsigned char *)(a3 + 95))
      {
        uint64_t v15 = v8;
        while (*(unsigned __int8 *)v15 == *v14)
        {
          uint64_t v15 = (const void **)((char *)v15 + 1);
          ++v14;
          if (!--v9) {
            goto LABEL_19;
          }
        }
        goto LABEL_21;
      }
LABEL_19:
      uint64_t v16 = **(void **)v7;
      uint64_t v17 = *(void *)(*(void *)v7 + 8);
      buf[0] = 0;
      double result = sub_1000D8740(v16, v17, (unsigned __int8 **)(v3 + 16));
      if (result == *(void *)(*(void *)v7 + 8))
      {
        uint64_t v18 = ***(NSObject ****)(v7 + 8);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(v3 + 39) < 0) {
            unint64_t v13 = (void *)*v13;
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v21 = v13;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Found blacklisted ICCID to exclude: %s", buf, 0xCu);
        }
        sub_10032FC24(v3 + 216, *(void *)(a2 + 64), v3);
        uint64_t v4 = v19;
        for (double result = *(void *)(a2 + 64); result != v4; double result = sub_1000C584C(result - 216))
          ;
        *(void *)(a2 + 64) = v4;
        continue;
      }
      uint64_t v4 = *(void *)(a2 + 64);
LABEL_21:
      v3 += 216;
    }
    while (v3 != v4);
  }
  return result;
}

void sub_10098E704(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1, a2);
  std::string::operator=(a1 + 1, a2 + 1);
  std::string::operator=(a1 + 2, a2 + 2);
  std::string::operator=(a1 + 3, a2 + 3);
  std::string::operator=(a1 + 4, a2 + 4);
  if (a1 != a2)
  {
    uint64_t data = (uint64_t)a2[5].__r_.__value_.__l.__data_;
    uint64_t size = a2[5].__r_.__value_.__l.__size_;
    sub_100991FDC((uint64_t)&a1[5], data, size, 0xCCCCCCCCCCCCCCCDLL * ((size - data) >> 4));
  }
}

uint64_t sub_10098E79C(uint64_t a1, unsigned __int8 **a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 240))
  {
    uint64_t v3 = *(void *)(a1 + 200);
    uint64_t v4 = *(void *)(a1 + 208);
    if (v3 != v4)
    {
      long long v6 = (std::string *)(a3 + 16);
      uint64_t v7 = (std::string *)(a3 + 40);
      uint64_t v17 = (std::string *)(a3 + 64);
      uint64_t v18 = (std::string *)(a3 + 96);
      uint64_t v19 = (std::string *)(a3 + 120);
      int v20 = (std::string *)(a3 + 144);
      uint64_t v21 = (std::string *)(a3 + 168);
      uint64_t v22 = (std::string *)(a3 + 192);
      char v8 = *((unsigned char *)a2 + 23);
      if (v8 >= 0) {
        uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
      }
      else {
        uint64_t v9 = a2[1];
      }
      if (v8 >= 0) {
        uint64_t v10 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v10 = *a2;
      }
      do
      {
        if (*(unsigned char *)(v3 + 80))
        {
          uint64_t v11 = *(void *)(v3 + 56);
          uint64_t v12 = *(void *)(v3 + 64);
          while (v11 != v12)
          {
            uint64_t v13 = *(unsigned __int8 *)(v11 + 39);
            if ((v13 & 0x80u) == 0) {
              uint64_t v14 = (unsigned __int8 *)*(unsigned __int8 *)(v11 + 39);
            }
            else {
              uint64_t v14 = *(unsigned __int8 **)(v11 + 24);
            }
            if (v14 == v9)
            {
              if ((v13 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v11 + 16), v10, *(void *)(v11 + 24)))
                {
LABEL_26:
                  *(_OWORD *)a3 = *(_OWORD *)v11;
                  std::string::operator=(v6, (const std::string *)(v11 + 16));
                  std::string::operator=(v7, (const std::string *)(v11 + 40));
                  std::string::operator=(v17, (const std::string *)(v11 + 64));
                  *(_DWORD *)(a3 + 88) = *(_DWORD *)(v11 + 88);
                  std::string::operator=(v18, (const std::string *)(v11 + 96));
                  std::string::operator=(v19, (const std::string *)(v11 + 120));
                  std::string::operator=(v20, (const std::string *)(v11 + 144));
                  std::string::operator=(v21, (const std::string *)(v11 + 168));
                  std::string::operator=(v22, (const std::string *)(v11 + 192));
                  return 1;
                }
              }
              else
              {
                if (!*(unsigned char *)(v11 + 39)) {
                  goto LABEL_26;
                }
                uint64_t v15 = 0;
                while (*(unsigned __int8 *)(v11 + v15 + 16) == v10[v15])
                {
                  if (v13 == ++v15) {
                    goto LABEL_26;
                  }
                }
              }
            }
            v11 += 216;
          }
        }
        v3 += 88;
      }
      while (v3 != v4);
    }
  }
  return 0;
}

uint64_t sub_10098E940(uint64_t a1, unsigned __int8 **a2, _OWORD *a3)
{
  if (!*(unsigned char *)(a1 + 240)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 200);
  uint64_t v4 = *(void *)(a1 + 208);
  if (v3 == v4) {
    return 0;
  }
  long long v6 = (std::string *)(a3 + 2);
  uint64_t v7 = (uint64_t)a3 + 56;
  char v8 = *((unsigned char *)a2 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v9 = a2[1];
  }
  if (v8 >= 0) {
    uint64_t v10 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v10 = *a2;
  }
  while (1)
  {
    if (*(unsigned char *)(v3 + 80))
    {
      uint64_t v11 = *(void *)(v3 + 56);
      uint64_t v12 = *(void *)(v3 + 64);
      if (v11 != v12) {
        break;
      }
    }
LABEL_23:
    v3 += 88;
    if (v3 == v4) {
      return 0;
    }
  }
  while (1)
  {
    uint64_t v13 = *(unsigned __int8 *)(v11 + 39);
    if ((v13 & 0x80u) == 0) {
      uint64_t v14 = (unsigned __int8 *)*(unsigned __int8 *)(v11 + 39);
    }
    else {
      uint64_t v14 = *(unsigned __int8 **)(v11 + 24);
    }
    if (v14 != v9) {
      goto LABEL_22;
    }
    if ((v13 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v11 + 39)) {
      goto LABEL_25;
    }
    uint64_t v15 = 0;
    while (*(unsigned __int8 *)(v11 + v15 + 16) == v10[v15])
    {
      if (v13 == ++v15) {
        goto LABEL_25;
      }
    }
LABEL_22:
    v11 += 216;
    if (v11 == v12) {
      goto LABEL_23;
    }
  }
  if (memcmp(*(const void **)(v11 + 16), v10, *(void *)(v11 + 24))) {
    goto LABEL_22;
  }
LABEL_25:
  long long v17 = *(_OWORD *)(v3 + 16);
  *a3 = *(_OWORD *)v3;
  a3[1] = v17;
  std::string::operator=(v6, (const std::string *)(v3 + 32));
  sub_1000C86CC(v7, v3 + 56);
  return 1;
}

uint64_t sub_10098EA6C(uint64_t a1, unsigned __int8 **a2, BOOL *a3)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  *(_OWORD *)std::string __p = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v4 = sub_10098E940(a1, a2, v7);
  if (v4) {
    *a3 = LODWORD(v7[0]) == 0;
  }
  if ((_BYTE)v10)
  {
    long long v6 = (void **)v9 + 1;
    sub_1000C57C8(&v6);
  }
  if (SBYTE7(v9[0]) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_10098EB24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10015A318((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10098EB38@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(unsigned char *)(result + 240))
  {
    uint64_t v3 = *(void *)(result + 200);
    uint64_t v4 = *(void *)(result + 208);
    if (v3 != v4)
    {
      unint64_t v5 = 0;
      do
      {
        if (*(unsigned char *)(v3 + 80))
        {
          uint64_t v6 = *(void *)(v3 + 56);
          for (uint64_t i = *(void *)(v3 + 64); v6 != i; v6 += 216)
          {
            if (*(unsigned char *)(v6 + 89))
            {
              if (v5 >= a2[2])
              {
                double result = sub_100992214(a2, v6, (_OWORD *)(v3 + 16));
                unint64_t v5 = result;
              }
              else
              {
                double result = sub_1000C5AB4(v5, v6);
                *(_OWORD *)(v5 + 216) = *(_OWORD *)(v3 + 16);
                v5 += 232;
                a2[1] = v5;
              }
              a2[1] = v5;
            }
          }
        }
        v3 += 88;
      }
      while (v3 != v4);
    }
  }
  return result;
}

void sub_10098EC14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100992538((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10098EC38(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 368);
  uint64_t v4 = *(void *)(a1 + 376);
  if (v3 == v4) {
    return 0;
  }
  while (1)
  {
    uint64_t v7 = sub_100046F68(v3 + 56, a2);
    if ((void **)(v3 + 64) != v7) {
      break;
    }
    v3 += 80;
    if (v3 == v4) {
      return 0;
    }
  }
  sub_100312ECC(a3, (uint64_t)(v7 + 7));
  return 1;
}

uint64_t sub_10098ECAC(uint64_t a1, uint64_t a2)
{
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_10098EC38(a1, __p, (uint64_t)v7);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (BYTE9(v8)) {
    unsigned __int8 v3 = BYTE8(v8);
  }
  else {
    unsigned __int8 v3 = 0;
  }
  sub_1000C54EC((uint64_t)v7);
  return v3;
}

void sub_10098ED74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

uint64_t sub_10098EDA0(uint64_t a1, uint64_t a2)
{
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_10098EC38(a1, __p, (uint64_t)v7);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v3 = BYTE8(v8);
  sub_1000C54EC((uint64_t)v7);
  return v3;
}

void sub_10098EE5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void sub_10098EE88(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void *)(a1 + 368);
  for (uint64_t i = *(void *)(a1 + 376); v2 != i; v2 += 80)
  {
    unint64_t v5 = sub_100046F68(v2 + 56, a2);
    if ((void **)(v2 + 64) != v5)
    {
      uint64_t v6 = v5;
      if (*((unsigned char *)v5 + 256))
      {
        if (*((char *)v5 + 255) < 0) {
          operator delete(v5[29]);
        }
        *((unsigned char *)v6 + 256) = 0;
      }
    }
  }
}

uint64_t sub_10098EF00(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 368);
  uint64_t v3 = *(void *)(a1 + 376);
  if (v2 == v3) {
    return 0;
  }
  while (1)
  {
    unint64_t v5 = *(void **)(v2 + 56);
    if (v5 != (void *)(v2 + 64)) {
      break;
    }
LABEL_18:
    v2 += 80;
    if (v2 == v3) {
      return 0;
    }
  }
  while (1)
  {
    if (*((unsigned char *)v5 + 225))
    {
      unsigned int v6 = *((unsigned __int8 *)v5 + 224);
      BOOL v7 = v6 > 0x10 || ((1 << v6) & 0x10041) == 0;
      if (v7 && v6 - 128 >= 3 && (!a2 || sub_1008A200C(v6))) {
        return 1;
      }
    }
    long long v8 = (void *)v5[1];
    if (v8)
    {
      do
      {
        long long v9 = v8;
        long long v8 = (void *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        long long v9 = (void *)v5[2];
        BOOL v7 = *v9 == (void)v5;
        unint64_t v5 = v9;
      }
      while (!v7);
    }
    unint64_t v5 = v9;
    if (v9 == (void *)(v2 + 64)) {
      goto LABEL_18;
    }
  }
}

void sub_10098EFE8(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 240))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    uint64_t v3 = *(void *)(a1 + 200);
    uint64_t v4 = *(void *)(a1 + 208);
    if (v3 != v4)
    {
      while ((*(_DWORD *)(v3 + 4) - 1) > 1 || !*(unsigned char *)(v3 + 80))
      {
LABEL_35:
        v3 += 88;
        if (v3 == v4) {
          return;
        }
      }
      uint64_t v5 = *(void *)(v3 + 56);
      uint64_t v6 = *(void *)(v3 + 64);
      while (1)
      {
        if (v5 == v6) {
          goto LABEL_35;
        }
        if (*(char *)(v5 + 39) < 0)
        {
          if (!*(void *)(v5 + 24)) {
            goto LABEL_34;
          }
        }
        else if (!*(unsigned char *)(v5 + 39))
        {
          goto LABEL_34;
        }
        memset(__p, 0, sizeof(__p));
        *(_OWORD *)long long v15 = 0u;
        *(_OWORD *)long long v13 = 0u;
        memset(v14, 0, sizeof(v14));
        *(_OWORD *)long long v11 = 0u;
        long long v12 = 0u;
        if (*(char *)(v5 + 119) < 0)
        {
          sub_10004FC84(v13, *(void **)(v5 + 96), *(void *)(v5 + 104));
        }
        else
        {
          long long v7 = *(_OWORD *)(v5 + 96);
          v14[0] = *(void **)(v5 + 112);
          *(_OWORD *)long long v13 = v7;
        }
        if (*(char *)(v5 + 143) < 0)
        {
          sub_10004FC84(&v14[1], *(void **)(v5 + 120), *(void *)(v5 + 128));
        }
        else
        {
          long long v8 = *(_OWORD *)(v5 + 120);
          v14[3] = *(void **)(v5 + 136);
          *(_OWORD *)&v14[1] = v8;
        }
        if (*(char *)(v5 + 167) < 0)
        {
          sub_10004FC84(v15, *(void **)(v5 + 144), *(void *)(v5 + 152));
        }
        else
        {
          long long v9 = *(_OWORD *)(v5 + 144);
          __p[0] = *(void **)(v5 + 160);
          *(_OWORD *)long long v15 = v9;
        }
        if (*(char *)(v5 + 191) < 0)
        {
          sub_10004FC84(&__p[1], *(void **)(v5 + 168), *(void *)(v5 + 176));
        }
        else
        {
          long long v10 = *(_OWORD *)(v5 + 168);
          __p[3] = *(void **)(v5 + 184);
          *(_OWORD *)&__p[1] = v10;
        }
        sub_1005395D0(a2, (uint64_t)v11);
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v15[0]);
        }
        if (SHIBYTE(v14[3]) < 0) {
          operator delete(v14[1]);
        }
        if (SHIBYTE(v14[0]) < 0) {
          operator delete(v13[0]);
        }
        if (BYTE8(v12))
        {
          if (SBYTE7(v12) < 0) {
            operator delete(v11[0]);
          }
        }
LABEL_34:
        v5 += 216;
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_10098F1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15)
  {
    if (a14 < 0) {
      operator delete(a9);
    }
  }
  sub_10030B640((void ***)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10098F270(uint64_t a1, void **a2, __int16 a3)
{
  uint64_t v3 = *(void *)(a1 + 368);
  uint64_t v4 = *(void *)(a1 + 376);
  if (v3 == v4) {
    return 0;
  }
  while (1)
  {
    long long v7 = sub_100046F68(v3 + 56, a2);
    if ((void **)(v3 + 64) != v7) {
      break;
    }
    v3 += 80;
    if (v3 == v4) {
      return 0;
    }
  }
  *((_WORD *)v7 + 112) = a3 | 0x100;
  return 1;
}

uint64_t sub_10098F2E0(uint64_t result, void **a2)
{
  uint64_t v2 = *(void *)(result + 368);
  for (uint64_t i = *(void *)(result + 376); v2 != i; v2 += 80)
  {
    double result = (uint64_t)sub_100046F68(v2 + 56, a2);
    if (v2 + 64 != result) {
      double result = sub_100CDB2AC(result + 200);
    }
  }
  return result;
}

std::string *sub_10098F340(std::string *result, void **a2, const std::string *a3)
{
  std::string::size_type size = result[15].__r_.__value_.__l.__size_;
  std::string::size_type v4 = result[15].__r_.__value_.__r.__words[2];
  if (size != v4)
  {
    while (1)
    {
      double result = (std::string *)sub_100046F68(size + 56, a2);
      if ((std::string *)(size + 64) != result) {
        break;
      }
      size += 80;
      if (size == v4) {
        return result;
      }
    }
    long long v7 = (std::string *)((char *)result + 176);
    return std::string::operator=(v7, a3);
  }
  return result;
}

uint64_t sub_10098F3C4(uint64_t a1, void **a2, const std::string *a3)
{
  uint64_t v3 = *(void *)(a1 + 368);
  uint64_t v4 = *(void *)(a1 + 376);
  if (v3 == v4) {
    return 0;
  }
  while (1)
  {
    long long v7 = sub_100046F68(v3 + 56, a2);
    if ((void **)(v3 + 64) != v7) {
      break;
    }
    v3 += 80;
    if (v3 == v4) {
      return 0;
    }
  }
  std::string::operator=((std::string *)(v7 + 19), a3);
  return 1;
}

void **sub_10098F438@<X0>(uint64_t a1@<X0>, void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 368);
  uint64_t v5 = *(void *)(a1 + 376);
  if (v4 == v5) {
    goto LABEL_8;
  }
  while (1)
  {
    double result = sub_100046F68(v4 + 56, a2);
    if ((void **)(v4 + 64) != result) {
      break;
    }
    v4 += 80;
    if (v4 == v5) {
      goto LABEL_8;
    }
  }
  if (!*((unsigned char *)result + 352))
  {
LABEL_8:
    return (void **)sub_100058DB0(a3, (char *)&unk_10163F587);
  }
  else if (*((char *)result + 351) < 0)
  {
    long long v9 = result[41];
    unint64_t v10 = (unint64_t)result[42];
    return (void **)sub_10004FC84(a3, v9, v10);
  }
  else
  {
    long long v8 = *(_OWORD *)(result + 41);
    a3[2] = result[43];
    *(_OWORD *)a3 = v8;
  }
  return result;
}

uint64_t sub_10098F510(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    **(unsigned char **)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 23) = 0;
  }
  memset(v10, 0, sizeof(v10));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  uint64_t v5 = sub_10098EC38(a1, __p, (uint64_t)v10);
  uint64_t v6 = v5;
  if ((SHIBYTE(v9) & 0x80000000) == 0)
  {
    if (!v5) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  operator delete(__p[0]);
  if (v6) {
LABEL_11:
  }
    std::string::operator=((std::string *)a3, (const std::string *)&v10[72]);
LABEL_12:
  sub_1000C54EC((uint64_t)v10);
  return v6;
}

void sub_10098F614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

uint64_t sub_10098F640(uint64_t a1, unsigned __int8 **a2, unint64_t a3)
{
  unint64_t v3 = a3;
  v17[0] = -1;
  v17[1] = -1;
  if (*(unsigned char *)(a1 + 240))
  {
    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 208);
    if (v4 != v5)
    {
      char v6 = *((unsigned char *)a2 + 23);
      if (v6 >= 0) {
        long long v7 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
      }
      else {
        long long v7 = a2[1];
      }
      if (v6 >= 0) {
        long long v8 = (unsigned __int8 *)a2;
      }
      else {
        long long v8 = *a2;
      }
      do
      {
        if (*(unsigned char *)(v4 + 80))
        {
          uint64_t v9 = *(void *)(v4 + 56);
          uint64_t v10 = *(void *)(v4 + 64);
          while (v9 != v10)
          {
            uint64_t v11 = *(unsigned __int8 *)(v9 + 39);
            a3 = *(void *)(v9 + 24);
            if ((v11 & 0x80u) == 0) {
              long long v12 = (unsigned __int8 *)*(unsigned __int8 *)(v9 + 39);
            }
            else {
              long long v12 = *(unsigned __int8 **)(v9 + 24);
            }
            if (v12 == v7)
            {
              if ((v11 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v9 + 16), v8, a3))
                {
LABEL_28:
                  ctu::hex((uint64_t *)&v15, (ctu *)(v4 + 16), (const void *)0x10, a3);
                  if (*(char *)(v3 + 23) < 0) {
                    operator delete(*(void **)v3);
                  }
                  *(_OWORD *)unint64_t v3 = v15;
                  *(void *)(v3 + 16) = v16;
                  return 1;
                }
              }
              else
              {
                if (!*(unsigned char *)(v9 + 39)) {
                  goto LABEL_28;
                }
                uint64_t v13 = 0;
                while (*(unsigned __int8 *)(v9 + v13 + 16) == v8[v13])
                {
                  if (v11 == ++v13) {
                    goto LABEL_28;
                  }
                }
              }
            }
            v9 += 216;
          }
        }
        v4 += 88;
      }
      while (v4 != v5);
    }
  }
  ctu::hex((uint64_t *)&v15, (ctu *)v17, (const void *)0x10, a3);
  if (*(char *)(v3 + 23) < 0) {
    operator delete(*(void **)v3);
  }
  uint64_t result = 0;
  *(_OWORD *)unint64_t v3 = v15;
  *(void *)(v3 + 16) = v16;
  return result;
}

uint64_t sub_10098F7E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(a3 + 1) = 1;
  std::string::operator=((std::string *)(a3 + 120), (const std::string *)(a1 + 248));
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  char v6 = sub_10098EC38(a1, __p, (uint64_t)v13);
  char v7 = v6;
  if (SHIBYTE(v12) < 0)
  {
    operator delete(__p[0]);
    if (v7) {
      goto LABEL_6;
    }
LABEL_22:
    uint64_t v9 = 0;
    goto LABEL_23;
  }
  if ((v6 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_6:
  std::string::operator=((std::string *)(a3 + 144), &v13[1]);
  std::string::operator=((std::string *)(a3 + 168), v14);
  std::string::operator=((std::string *)(a3 + 240), &v14[1]);
  std::string::operator=((std::string *)(a3 + 288), (const std::string *)v15);
  sub_100CD6B88((const void **)&v13[0].__r_.__value_.__l.__data_, (uint64_t)v15, (uint64_t)&v31);
  long long v8 = (void **)(a3 + 264);
  if (*(char *)(a3 + 287) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)long long v8 = v31;
  *(void *)(a3 + 280) = v32;
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  if (sub_10098E79C(a1, (unsigned __int8 **)a2, (uint64_t)&v31)) {
    *(unsigned char *)(a3 + 3) = BYTE9(v36);
  }
  if (BYTE9(v16)) {
    *(unsigned char *)a3 = BYTE8(v16);
  }
  if (BYTE8(v18)) {
    std::string::operator=((std::string *)(a3 + 312), (const std::string *)&v17);
  }
  if (BYTE8(v20)) {
    std::string::operator=((std::string *)(a3 + 336), (const std::string *)&v19);
  }
  if (BYTE8(v22)) {
    std::string::operator=((std::string *)(a3 + 360), (const std::string *)&v21);
  }
  if (BYTE8(v24)) {
    std::string::operator=((std::string *)(a3 + 384), (const std::string *)&v23);
  }
  uint64_t v9 = sub_10098F640(a1, (unsigned __int8 **)a2, a3 + 216);
  sub_1000C584C((uint64_t)&v31);
LABEL_23:
  sub_1000C54EC((uint64_t)v13);
  return v9;
}

void sub_10098FA38(_Unwind_Exception *a1, void *__p, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C54EC((uint64_t)va);
  _Unwind_Resume(a1);
}

char *sub_10098FA78@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[240])
  {
    if (result[55] < 0)
    {
      return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 4), *((void *)result + 5));
    }
    else
    {
      *(_OWORD *)a2 = *((_OWORD *)result + 2);
      *(void *)(a2 + 16) = *((void *)result + 6);
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

uint64_t *sub_10098FAB8@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *((unsigned __int8 *)result + 240);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  if (v3)
  {
    uint64_t v4 = result[25];
    uint64_t v5 = result[26];
    while (1)
    {
      if (v4 == v5) {
        return result;
      }
      if (*(unsigned char *)(v4 + 80)) {
        break;
      }
LABEL_13:
      v4 += 88;
    }
    uint64_t v6 = *(void *)(v4 + 56);
    uint64_t v7 = *(void *)(v4 + 64);
    while (1)
    {
      if (v6 == v7) {
        goto LABEL_13;
      }
      if (*(char *)(v6 + 39) < 0) {
        break;
      }
      if (*(unsigned char *)(v6 + 39)) {
        goto LABEL_11;
      }
LABEL_12:
      v6 += 216;
    }
    if (!*(void *)(v6 + 24)) {
      goto LABEL_12;
    }
LABEL_11:
    uint64_t result = sub_100046BAC((uint64_t **)a2, (void **)(v6 + 16), v6 + 16);
    goto LABEL_12;
  }
  return result;
}

void sub_10098FB5C(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10098FB74@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v3 = result[46];
  uint64_t v4 = result[47];
  while (v3 != v4)
  {
    if (*(char *)(v3 + 31) < 0)
    {
      if (!*(void *)(v3 + 16)) {
        goto LABEL_8;
      }
LABEL_7:
      uint64_t result = sub_100046BAC((uint64_t **)a2, (void **)(v3 + 8), v3 + 8);
      goto LABEL_8;
    }
    if (*(unsigned char *)(v3 + 31)) {
      goto LABEL_7;
    }
LABEL_8:
    v3 += 80;
  }
  return result;
}

void sub_10098FBE8(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10098FC00(uint64_t a1@<X0>, unint64_t a2@<X2>, uint64_t a3@<X8>)
{
  int v4 = *(unsigned __int8 *)(a1 + 240);
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)a3 = a3 + 8;
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 200);
    uint64_t v6 = *(void *)(a1 + 208);
    while (v5 != v6)
    {
      if (*(_OWORD *)(v5 + 16) != 0)
      {
        ctu::hex((uint64_t *)__p, (ctu *)(v5 + 16), (const void *)0x10, a2);
        sub_1000EA6A0((uint64_t **)a3, __p, (uint64_t)__p);
        if (v8 < 0) {
          operator delete(__p[0]);
        }
      }
      v5 += 88;
    }
  }
}

void sub_10098FCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005CD2C(v14, *(char **)(v14 + 8));
  _Unwind_Resume(a1);
}

char *sub_10098FCF4@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[240] && result[56])
  {
    if (result[87] < 0)
    {
      return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 8), *((void *)result + 9));
    }
    else
    {
      *(_OWORD *)a2 = *((_OWORD *)result + 4);
      *(void *)(a2 + 16) = *((void *)result + 10);
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

void *sub_10098FD3C@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (void **)(result + 40);
  if (*((char *)result + 343) < 0)
  {
    unint64_t v3 = result[41];
    if (v3) {
      return sub_10004FC84((unsigned char *)a2, *v2, v3);
    }
  }
  else if (*((unsigned char *)result + 343))
  {
    *(_OWORD *)a2 = *(_OWORD *)v2;
    *(void *)(a2 + 16) = result[42];
    return result;
  }
  return sub_100058DB0((void *)a2, "iPhone");
}

void sub_10098FD84(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = a2;
  if (*(unsigned char *)(a1 + 240))
  {
    if (!*(unsigned char *)a1) {
      goto LABEL_19;
    }
    uint64_t v4 = *(unsigned __int8 *)(a1 + 31);
    if ((v4 & 0x80u) == 0) {
      uint64_t v5 = (unsigned __int8 *)*(unsigned __int8 *)(a1 + 31);
    }
    else {
      uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    }
    uint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    int v7 = (char)v6;
    if ((char)v6 < 0) {
      uint64_t v6 = a2[1];
    }
    if (v5 != v6) {
      goto LABEL_19;
    }
    char v8 = (const void **)(a1 + 8);
    if (v7 < 0) {
      a2 = (unsigned __int8 **)*a2;
    }
    if ((v4 & 0x80) != 0)
    {
      uint64_t v9 = (void *)*v8;
      if (memcmp(*v8, a2, *(void *)(a1 + 16)))
      {
LABEL_19:
        uint64_t v10 = *(void *)(a1 + 200);
        uint64_t v11 = *(void *)(a1 + 208);
        while (1)
        {
          if (v10 == v11) {
            goto LABEL_69;
          }
          if (*(unsigned char *)(v10 + 80)) {
            break;
          }
LABEL_68:
          v10 += 88;
        }
        uint64_t v13 = *(void *)(v10 + 56);
        uint64_t v12 = *(void *)(v10 + 64);
        if (v13 == v12)
        {
          uint64_t v12 = *(void *)(v10 + 56);
        }
        else
        {
          char v14 = *((unsigned char *)v2 + 23);
          if (v14 >= 0) {
            long long v15 = (unsigned __int8 *)*((unsigned __int8 *)v2 + 23);
          }
          else {
            long long v15 = v2[1];
          }
          if (v14 >= 0) {
            long long v16 = (unsigned __int8 *)v2;
          }
          else {
            long long v16 = *v2;
          }
          while (1)
          {
            uint64_t v17 = *(unsigned __int8 *)(v13 + 39);
            long long v18 = (v17 & 0x80u) == 0
                ? (unsigned __int8 *)*(unsigned __int8 *)(v13 + 39)
                : *(unsigned __int8 **)(v13 + 24);
            if (v18 == v15)
            {
              if ((v17 & 0x80) == 0)
              {
                if (!*(unsigned char *)(v13 + 39)) {
                  break;
                }
                uint64_t v19 = 0;
                while (*(unsigned __int8 *)(v13 + v19 + 16) == v16[v19])
                {
                  if (v17 == ++v19) {
                    goto LABEL_42;
                  }
                }
                goto LABEL_40;
              }
              if (!memcmp(*(const void **)(v13 + 16), v16, *(void *)(v13 + 24))) {
                break;
              }
            }
LABEL_40:
            v13 += 216;
            if (v13 == v12) {
              goto LABEL_66;
            }
          }
LABEL_42:
          if (v13 == v12)
          {
LABEL_66:
            uint64_t v21 = v12;
            goto LABEL_67;
          }
          uint64_t v20 = v13 + 216;
          if (v13 + 216 != v12)
          {
            uint64_t v21 = v13;
            while (1)
            {
              uint64_t v22 = *(unsigned __int8 *)(v13 + 255);
              if ((v22 & 0x80u) == 0) {
                long long v23 = (unsigned __int8 *)*(unsigned __int8 *)(v13 + 255);
              }
              else {
                long long v23 = *(unsigned __int8 **)(v13 + 240);
              }
              long long v24 = (unsigned __int8 *)*((unsigned __int8 *)v2 + 23);
              int v25 = (char)v24;
              if ((char)v24 < 0) {
                long long v24 = v2[1];
              }
              if (v23 != v24) {
                goto LABEL_61;
              }
              if (v25 >= 0) {
                long long v26 = (unsigned __int8 *)v2;
              }
              else {
                long long v26 = *v2;
              }
              if ((v22 & 0x80) != 0)
              {
                if (memcmp(*(const void **)(v13 + 232), v26, *(void *)(v13 + 240))) {
                  goto LABEL_61;
                }
              }
              else if (*(unsigned char *)(v13 + 255))
              {
                uint64_t v27 = 0;
                while (*(unsigned __int8 *)(v13 + v27 + 232) == v26[v27])
                {
                  if (v22 == ++v27) {
                    goto LABEL_62;
                  }
                }
LABEL_61:
                sub_10032FC84(v21, v20);
                v21 += 216;
              }
LABEL_62:
              v20 += 216;
              v13 += 216;
              if (v20 == v12)
              {
                uint64_t v12 = *(void *)(v10 + 64);
                goto LABEL_67;
              }
            }
          }
        }
        uint64_t v21 = v13;
LABEL_67:
        sub_10032FA2C(v10 + 56, v21, v12);
        goto LABEL_68;
      }
      operator delete(v9);
    }
    else if (*(unsigned char *)(a1 + 31))
    {
      while (*(unsigned __int8 *)v8 == *(unsigned __int8 *)a2)
      {
        char v8 = (const void **)((char *)v8 + 1);
        a2 = (unsigned __int8 **)((char *)a2 + 1);
        if (!--v4) {
          goto LABEL_18;
        }
      }
      goto LABEL_19;
    }
LABEL_18:
    *(unsigned char *)a1 = 0;
    goto LABEL_19;
  }
LABEL_69:
  uint64_t v28 = *(void *)(a1 + 368);
  uint64_t v29 = *(void *)(a1 + 376);
  while (v28 != v29)
  {
    long long v30 = (void ***)(v28 + 56);
    long long v31 = sub_100046F68(v28 + 56, (void **)v2);
    if ((void **)(v28 + 64) != v31)
    {
      long long v32 = (uint64_t *)v31;
      long long v33 = (void **)v31[1];
      if (v33)
      {
        do
        {
          long long v34 = v33;
          long long v33 = (void **)*v33;
        }
        while (v33);
      }
      else
      {
        long long v35 = v31;
        do
        {
          long long v34 = (void **)v35[2];
          BOOL v36 = *v34 == v35;
          long long v35 = v34;
        }
        while (!v36);
      }
      if (*v30 == v31) {
        *long long v30 = v34;
      }
      long long v37 = *(uint64_t **)(v28 + 64);
      --*(void *)(v28 + 72);
      sub_10005EE6C(v37, v32);
      sub_1000C549C((uint64_t)(v32 + 4));
      operator delete(v32);
    }
    v28 += 80;
  }
}

uint64_t sub_100990074@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v125 = 0u;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v124 = *(void *)(a2 + 16);
  }
  char v6 = sub_10098EC38(a1, __p, (uint64_t)&v125);
  char v7 = v6;
  if (SHIBYTE(v124) < 0)
  {
    operator delete(__p[0]);
    if ((v7 & 1) == 0)
    {
LABEL_67:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return sub_1000C54EC((uint64_t)&v125);
    }
  }
  else if ((v6 & 1) == 0)
  {
    goto LABEL_67;
  }
  if (!*(unsigned char *)(a1 + 240) || !BYTE8(v137)) {
    goto LABEL_67;
  }
  uint64_t v164 = 0;
  memset(v163, 0, sizeof(v163));
  long long v161 = 0u;
  long long v162 = 0u;
  long long v160 = 0u;
  if (sub_10098E940(a1, (unsigned __int8 **)a2, &v160))
  {
    uint64_t v159 = 0;
    long long v157 = 0u;
    long long v158 = 0u;
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    long long v152 = 0u;
    memset(v151, 0, sizeof(v151));
    if (sub_10098E79C(a1, (unsigned __int8 **)a2, (uint64_t)v151))
    {
      uint64_t v122 = 0;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      *(_OWORD *)v110 = 0u;
      long long v111 = 0u;
      memset(v109, 0, sizeof(v109));
      long long v108 = 0u;
      sub_10004BD84((uint64_t)&v108);
      char v8 = sub_10004B96C(v109, (uint64_t)"LPA:1", 5);
      LOBYTE(v106[0]) = 36;
      uint64_t v9 = sub_10004B96C(v8, (uint64_t)v106, 1);
      uint64_t v10 = sub_10004B96C(v9, (uint64_t)"TR", 2);
      LOBYTE(v106[0]) = 36;
      uint64_t v11 = sub_10004B96C(v10, (uint64_t)v106, 1);
      uint64_t v12 = sub_10004B96C(v11, (uint64_t)"iccid:", 6);
      int v13 = *(char *)(a2 + 23);
      if (v13 >= 0) {
        char v14 = (void *)a2;
      }
      else {
        char v14 = *(void **)a2;
      }
      if (v13 >= 0) {
        uint64_t v15 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v15 = *(void *)(a2 + 8);
      }
      long long v16 = sub_10004B96C(v12, (uint64_t)v14, v15);
      LOBYTE(v106[0]) = 36;
      uint64_t v17 = sub_10004B96C(v16, (uint64_t)v106, 1);
      long long v18 = sub_10004B96C(v17, (uint64_t)"mcc:", 4);
      if ((SBYTE7(v153) & 0x80u) == 0) {
        uint64_t v19 = &v152;
      }
      else {
        uint64_t v19 = (long long *)v152;
      }
      if ((SBYTE7(v153) & 0x80u) == 0) {
        uint64_t v20 = BYTE7(v153);
      }
      else {
        uint64_t v20 = *((void *)&v152 + 1);
      }
      uint64_t v21 = sub_10004B96C(v18, (uint64_t)v19, v20);
      LOBYTE(v106[0]) = 36;
      uint64_t v22 = sub_10004B96C(v21, (uint64_t)v106, 1);
      long long v23 = sub_10004B96C(v22, (uint64_t)"mnc:", 4);
      if (v154 >= 0) {
        long long v24 = (char *)&v153 + 8;
      }
      else {
        long long v24 = (char *)*((void *)&v153 + 1);
      }
      if (v154 >= 0) {
        uint64_t v25 = HIBYTE(v154);
      }
      else {
        uint64_t v25 = v154;
      }
      long long v26 = sub_10004B96C(v23, (uint64_t)v24, v25);
      LOBYTE(v106[0]) = 36;
      uint64_t v27 = sub_10004B96C(v26, (uint64_t)v106, 1);
      uint64_t v28 = sub_10004B96C(v27, (uint64_t)"gid1:", 5);
      if ((SBYTE7(v156) & 0x80u) == 0) {
        uint64_t v29 = &v155;
      }
      else {
        uint64_t v29 = (long long *)v155;
      }
      if ((SBYTE7(v156) & 0x80u) == 0) {
        uint64_t v30 = BYTE7(v156);
      }
      else {
        uint64_t v30 = *((void *)&v155 + 1);
      }
      long long v31 = sub_10004B96C(v28, (uint64_t)v29, v30);
      LOBYTE(v106[0]) = 36;
      long long v32 = sub_10004B96C(v31, (uint64_t)v106, 1);
      long long v33 = sub_10004B96C(v32, (uint64_t)"gid2:", 5);
      if (v157 >= 0) {
        long long v34 = (char *)&v156 + 8;
      }
      else {
        long long v34 = (char *)*((void *)&v156 + 1);
      }
      if (v157 >= 0) {
        uint64_t v35 = HIBYTE(v157);
      }
      else {
        uint64_t v35 = v157;
      }
      BOOL v36 = sub_10004B96C(v33, (uint64_t)v34, v35);
      LOBYTE(v106[0]) = 36;
      long long v37 = sub_10004B96C(v36, (uint64_t)v106, 1);
      long long v38 = sub_10004B96C(v37, (uint64_t)"imsi:", 5);
      if ((SBYTE7(v143) & 0x80u) == 0) {
        long long v39 = &v142;
      }
      else {
        long long v39 = (long long *)v142;
      }
      if ((SBYTE7(v143) & 0x80u) == 0) {
        uint64_t v40 = BYTE7(v143);
      }
      else {
        uint64_t v40 = *((void *)&v142 + 1);
      }
      long long v41 = sub_10004B96C(v38, (uint64_t)v39, v40);
      LOBYTE(v106[0]) = 36;
      long long v42 = sub_10004B96C(v41, (uint64_t)v106, 1);
      long long v43 = sub_10004B96C(v42, (uint64_t)"token:", 6);
      if ((SBYTE7(v137) & 0x80u) == 0) {
        uint64_t v44 = &v136;
      }
      else {
        uint64_t v44 = (long long *)v136;
      }
      if ((SBYTE7(v137) & 0x80u) == 0) {
        uint64_t v45 = BYTE7(v137);
      }
      else {
        uint64_t v45 = *((void *)&v136 + 1);
      }
      CFDictionaryRef v46 = sub_10004B96C(v43, (uint64_t)v44, v45);
      LOBYTE(v106[0]) = 36;
      CFTypeID v47 = sub_10004B96C(v46, (uint64_t)v106, 1);
      sub_10004B96C(v47, (uint64_t)"active:", 7);
      CFDictionaryRef v48 = (void *)std::ostream::operator<<();
      LOBYTE(v106[0]) = 36;
      CFDictionaryRef v49 = sub_10004B96C(v48, (uint64_t)v106, 1);
      CFTypeID v50 = sub_10004B96C(v49, (uint64_t)"imei:", 5);
      sub_10098FCF4((char *)a1, (uint64_t)v106);
      if ((v107 & 0x80u) == 0) {
        BOOL v51 = v106;
      }
      else {
        BOOL v51 = (void **)v106[0];
      }
      if ((v107 & 0x80u) == 0) {
        uint64_t v52 = v107;
      }
      else {
        uint64_t v52 = (uint64_t)v106[1];
      }
      uint64_t v53 = sub_10004B96C(v50, (uint64_t)v51, v52);
      LOBYTE(v104[0]) = 36;
      CFNumberRef v54 = sub_10004B96C(v53, (uint64_t)v104, 1);
      char v55 = sub_10004B96C(v54, (uint64_t)"eid:", 4);
      ctu::hex((uint64_t *)v104, (ctu *)&v161, (const void *)0x10, v56);
      if ((v105 & 0x80u) == 0) {
        uint64_t v57 = v104;
      }
      else {
        uint64_t v57 = (void **)v104[0];
      }
      if ((v105 & 0x80u) == 0) {
        uint64_t v58 = v105;
      }
      else {
        uint64_t v58 = (uint64_t)v104[1];
      }
      int v59 = sub_10004B96C(v55, (uint64_t)v57, v58);
      LOBYTE(v102[0]) = 36;
      CFStringRef v60 = sub_10004B96C(v59, (uint64_t)v102, 1);
      sub_10004B96C(v60, (uint64_t)"ver:", 4);
      CFStringRef v62 = (void *)std::ostream::operator<<();
      LOBYTE(v102[0]) = 36;
      uint64_t v63 = sub_10004B96C(v62, (uint64_t)v102, 1);
      uint64_t v64 = sub_10004B96C(v63, (uint64_t)"sn:", 3);
      int v65 = *(char *)(a1 + 319);
      if (v65 >= 0) {
        uint64_t v66 = a1 + 296;
      }
      else {
        uint64_t v66 = *(void *)(a1 + 296);
      }
      if (v65 >= 0) {
        uint64_t v67 = *(unsigned __int8 *)(a1 + 319);
      }
      else {
        uint64_t v67 = *(void *)(a1 + 304);
      }
      unsigned int v68 = sub_10004B96C(v64, v66, v67);
      LOBYTE(v102[0]) = 36;
      long long v69 = sub_10004B96C(v68, (uint64_t)v102, 1);
      uint64_t v70 = sub_10004B96C(v69, (uint64_t)"clz:", 4);
      sub_10098FD3C((void *)a1, (uint64_t)v102);
      if ((v103 & 0x80u) == 0) {
        uint64_t v71 = v102;
      }
      else {
        uint64_t v71 = (void **)v102[0];
      }
      if ((v103 & 0x80u) == 0) {
        uint64_t v72 = v103;
      }
      else {
        uint64_t v72 = (uint64_t)v102[1];
      }
      v73 = sub_10004B96C(v70, (uint64_t)v71, v72);
      LOBYTE(v100[0]) = 36;
      long long v74 = sub_10004B96C(v73, (uint64_t)v100, 1);
      std::string v75 = sub_10004B96C(v74, (uint64_t)"name:", 5);
      int v76 = *(char *)(a1 + 271);
      if (v76 >= 0) {
        uint64_t v77 = a1 + 248;
      }
      else {
        uint64_t v77 = *(void *)(a1 + 248);
      }
      if (v76 >= 0) {
        uint64_t v78 = *(unsigned __int8 *)(a1 + 271);
      }
      else {
        uint64_t v78 = *(void *)(a1 + 256);
      }
      std::string v79 = sub_10004B96C(v75, v77, v78);
      LOBYTE(v100[0]) = 36;
      v80 = sub_10004B96C(v79, (uint64_t)v100, 1);
      v81 = sub_10004B96C(v80, (uint64_t)"ids:", 4);
      sub_10098FA78((char *)a1, (uint64_t)v100);
      if ((v101 & 0x80u) == 0) {
        std::string v82 = v100;
      }
      else {
        std::string v82 = (void **)v100[0];
      }
      if ((v101 & 0x80u) == 0) {
        uint64_t v83 = v101;
      }
      else {
        uint64_t v83 = (uint64_t)v100[1];
      }
      int v84 = sub_10004B96C(v81, (uint64_t)v82, v83);
      char v150 = 36;
      v85 = sub_10004B96C(v84, (uint64_t)&v150, 1);
      v86 = sub_10004B96C(v85, (uint64_t)"lbl.txt:", 8);
      if (v127 >= 0) {
        uint64_t v87 = (char *)&v126 + 8;
      }
      else {
        uint64_t v87 = (char *)*((void *)&v126 + 1);
      }
      if (v127 >= 0) {
        uint64_t v88 = HIBYTE(v127);
      }
      else {
        uint64_t v88 = v127;
      }
      unsigned int v89 = sub_10004B96C(v86, (uint64_t)v87, v88);
      char v150 = 36;
      v90 = sub_10004B96C(v89, (uint64_t)&v150, 1);
      v91 = sub_10004B96C(v90, (uint64_t)"lbl.tag:", 8);
      if ((SBYTE7(v129) & 0x80u) == 0) {
        long long v92 = &v128;
      }
      else {
        long long v92 = (long long *)v128;
      }
      if ((SBYTE7(v129) & 0x80u) == 0) {
        uint64_t v93 = BYTE7(v129);
      }
      else {
        uint64_t v93 = *((void *)&v128 + 1);
      }
      v94 = sub_10004B96C(v91, (uint64_t)v92, v93);
      char v150 = 36;
      uint64_t v95 = sub_10004B96C(v94, (uint64_t)&v150, 1);
      CFTypeRef v96 = sub_10004B96C(v95, (uint64_t)"mdn:", 4);
      if ((SBYTE7(v126) & 0x80u) == 0) {
        v97 = &v125;
      }
      else {
        v97 = (long long *)v125;
      }
      if ((SBYTE7(v126) & 0x80u) == 0) {
        uint64_t v98 = BYTE7(v126);
      }
      else {
        uint64_t v98 = *((void *)&v125 + 1);
      }
      sub_10004B96C(v96, (uint64_t)v97, v98);
      if ((char)v101 < 0) {
        operator delete(v100[0]);
      }
      if ((char)v103 < 0) {
        operator delete(v102[0]);
      }
      if ((char)v105 < 0) {
        operator delete(v104[0]);
      }
      if ((char)v107 < 0) {
        operator delete(v106[0]);
      }
      sub_10004BC98((uint64_t)v109 + 8, a3);
      *(void *)((char *)&v109[-1]
      *(void *)&v109[0] = v99;
      if (SHIBYTE(v111) < 0) {
        operator delete(v110[1]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
    }
    else
    {
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
    }
    sub_1000C584C((uint64_t)v151);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  if ((_BYTE)v164)
  {
    *(void *)&long long v108 = (char *)v163 + 8;
    sub_1000C57C8((void ***)&v108);
  }
  if (SBYTE7(v163[0]) < 0) {
    operator delete((void *)v162);
  }
  return sub_1000C54EC((uint64_t)&v125);
}

void sub_100990944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10008248C((uint64_t)&a30);
  sub_1000C584C((uint64_t)&STACK[0x340]);
  sub_10015A318(v70 - 144);
  sub_1000C54EC((uint64_t)&a70);
  _Unwind_Resume(a1);
}

void sub_100990A14(void *a1@<X8>)
{
  memset(v2, 0, sizeof(v2));
  ctu::split_any_copy();
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v3 = (void **)v2;
  sub_100047F64(&v3);
}

void sub_100990B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  *(void *)(v10 - 24) = &a10;
  sub_100047F64((void ***)(v10 - 24));
  _Unwind_Resume(a1);
}

void sub_100990B54(unsigned char *a1@<X8>)
{
  memset(v3, 0, sizeof(v3));
  ctu::split_any_copy();
  *a1 = 0;
  a1[400] = 0;
  v2.__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
  sub_100047F64((void ***)&v2);
}

void sub_100991850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void **a47)
{
  if (SLOBYTE(STACK[0x40F]) < 0) {
    operator delete((void *)STACK[0x3F8]);
  }
  if (SLOBYTE(STACK[0x427]) < 0) {
    operator delete((void *)STACK[0x410]);
  }
  if (SLOBYTE(STACK[0x43F]) < 0) {
    operator delete((void *)STACK[0x428]);
  }
  if (SLOBYTE(STACK[0x457]) < 0) {
    operator delete((void *)STACK[0x440]);
  }
  if (SLOBYTE(STACK[0x46F]) < 0) {
    operator delete((void *)STACK[0x458]);
  }
  if (SLOBYTE(STACK[0x487]) < 0) {
    operator delete((void *)STACK[0x470]);
  }
  if (SLOBYTE(STACK[0x49F]) < 0) {
    operator delete((void *)STACK[0x488]);
  }
  if (SLOBYTE(STACK[0x4B7]) < 0) {
    operator delete((void *)STACK[0x4A0]);
  }
  if (SLOBYTE(STACK[0x4CF]) < 0) {
    operator delete((void *)STACK[0x4B8]);
  }
  if (SLOBYTE(STACK[0x4E7]) < 0) {
    operator delete((void *)STACK[0x4D0]);
  }
  if (SLOBYTE(STACK[0x4FF]) < 0) {
    operator delete((void *)STACK[0x4E8]);
  }
  if (SLOBYTE(STACK[0x517]) < 0) {
    operator delete((void *)STACK[0x500]);
  }
  if (SLOBYTE(STACK[0x52F]) < 0) {
    operator delete((void *)STACK[0x518]);
  }
  if (SLOBYTE(STACK[0x547]) < 0) {
    operator delete((void *)STACK[0x530]);
  }
  if (SLOBYTE(STACK[0x55F]) < 0) {
    operator delete((void *)STACK[0x548]);
  }
  if (SLOBYTE(STACK[0x577]) < 0) {
    operator delete((void *)STACK[0x560]);
  }
  if (SLOBYTE(STACK[0x58F]) < 0) {
    operator delete((void *)STACK[0x578]);
  }
  if (SLOBYTE(STACK[0x5A7]) < 0) {
    operator delete((void *)STACK[0x590]);
  }
  a47 = (void **)&STACK[0x5A8];
  sub_100047F64(&a47);
  _Unwind_Resume(a1);
}

uint64_t sub_100991B10(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 240))
  {
    sub_1003DC1E4(a1, a2);
    cellplan::RemoteDeviceIdentifiers::operator=();
    std::string::operator=((std::string *)(a1 + 168), (const std::string *)(a2 + 168));
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    if (a1 != a2) {
      sub_1003DB294(a1 + 200, *(void *)(a2 + 200), *(void *)(a2 + 208), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 208) - *(void *)(a2 + 200)) >> 3));
    }
    uint64_t v4 = *(void *)(a2 + 224);
    *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 232);
    *(void *)(a1 + 224) = v4;
  }
  else
  {
    sub_100311D64(a1, a2);
    *(unsigned char *)(a1 + 240) = 1;
  }
  return a1;
}

uint64_t sub_100991BC4(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned char *)(result + 216))
  {
    uint64_t result = sub_1000C584C(result);
    *(unsigned char *)(v1 + 216) = 0;
  }
  if (*(unsigned char *)(v1 + 624))
  {
    uint64_t result = sub_1000C54EC(v1 + 224);
    *(unsigned char *)(v1 + 624) = 0;
  }
  if (*(unsigned char *)(v1 + 888))
  {
    uint64_t result = sub_1000C5578(v1 + 632);
    *(unsigned char *)(v1 + 888) = 0;
  }
  *(void *)(v1 + 1040) = -1;
  *(void *)(v1 + 1032) = -1;
  if (*(char *)(v1 + 1071) < 0)
  {
    **(unsigned char **)(v1 + 1048) = 0;
    *(void *)(v1 + 1056) = 0;
  }
  else
  {
    *(unsigned char *)(v1 + 1048) = 0;
    *(unsigned char *)(v1 + 1071) = 0;
  }
  *(void *)(v1 + 1176) = -1;
  *(void *)(v1 + 1168) = -1;
  if (*(char *)(v1 + 1207) < 0)
  {
    **(unsigned char **)(v1 + 1184) = 0;
    *(void *)(v1 + 1192) = 0;
  }
  else
  {
    *(unsigned char *)(v1 + 1184) = 0;
    *(unsigned char *)(v1 + 1207) = 0;
  }
  return result;
}

uint64_t sub_100991C78@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v20 = 0u;
  memset(v18, 0, sizeof(v18));
  long long v17 = 0u;
  sub_10004BD84((uint64_t)&v17);
  uint64_t v4 = sub_10004B96C(v18, (uint64_t)"Source iccid: (", 15);
  int v5 = *(char *)(a1 + 1071);
  if (v5 >= 0) {
    uint64_t v6 = a1 + 1048;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 1048);
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 1071);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 1056);
  }
  char v8 = sub_10004B96C(v4, v6, v7);
  sub_10004B96C(v8, (uint64_t)")", 1);
  uint64_t v9 = sub_10004B96C(v18, (uint64_t)", Target iccid: (", 17);
  int v10 = *(char *)(a1 + 1231);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 1208;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 1208);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 1231);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 1216);
  }
  int v13 = sub_10004B96C(v9, v11, v12);
  sub_10004B96C(v13, (uint64_t)")", 1);
  sub_10004B96C(v18, (uint64_t)", Waiting For TA rsp from source: ", 34);
  std::ostream::operator<<();
  char v14 = sub_10004B96C(v18, (uint64_t)", Physical plan: ", 17);
  *(_DWORD *)((char *)v14 + *(void *)(*v14 - 24) + 8) |= 1u;
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v18 + 8, a2);
  *(void *)((char *)&v18[-1]
  *(void *)&v18[0] = v15;
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100991EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100991F10(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 240) == *(unsigned __int8 *)(a2 + 240))
  {
    if (*(unsigned char *)(a1 + 240))
    {
      sub_1003DC1E4(a1, a2);
      cellplan::RemoteDeviceIdentifiers::operator=();
      std::string::operator=((std::string *)(a1 + 168), (const std::string *)(a2 + 168));
      *(void *)(a1 + 192) = *(void *)(a2 + 192);
      if (a1 != a2) {
        sub_1003DB294(a1 + 200, *(void *)(a2 + 200), *(void *)(a2 + 208), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 208) - *(void *)(a2 + 200)) >> 3));
      }
      uint64_t v4 = *(void *)(a2 + 224);
      *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 232);
      *(void *)(a1 + 224) = v4;
    }
  }
  else if (*(unsigned char *)(a1 + 240))
  {
    sub_1000C5634(a1);
    *(unsigned char *)(a1 + 240) = 0;
  }
  else
  {
    sub_100311D64(a1, a2);
    *(unsigned char *)(a1 + 240) = 1;
  }
}

void sub_100991FDC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(void **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    sub_10099214C((void **)a1);
    if (a4 > 0x333333333333333) {
      sub_10006A748();
    }
    unint64_t v10 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x199999999999999) {
      unint64_t v11 = 0x333333333333333;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100312288((void *)a1, v11);
    uint64_t v12 = sub_1003122DC(v8, a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4) < a4)
  {
    uint64_t v13 = a2 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4);
    sub_1009921B4(a2, v13, (uint64_t)v9);
    uint64_t v12 = sub_1003122DC(v8, v13, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_1009921B4(a2, a3, (uint64_t)v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 80;
      sub_1000C53DC(v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_10099213C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100992144(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_10099214C(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80;
        sub_1000C53DC(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1009921B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      sub_1003083C8(a3, v4);
      v4 += 80;
      a3 += 80;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t sub_100992214(uint64_t *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x34F72C234F72C235 * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x11A7B9611A7B961) {
    sub_1009923C8();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x34F72C234F72C235 * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x8D3DCB08D3DCB0) {
    unint64_t v11 = 0x11A7B9611A7B961;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v19 = a1 + 2;
  if (v11) {
    uint64_t v12 = (char *)sub_1001F9DC8(v9, v11);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v15 = v12;
  uint64_t v16 = &v12[232 * v5];
  uint64_t v17 = (uint64_t)v16;
  long long v18 = &v12[232 * v11];
  sub_1000C5AB4((uint64_t)v16, a2);
  *(_OWORD *)(v16 + 216) = *a3;
  v17 += 232;
  sub_100992350(a1, &v15);
  uint64_t v13 = a1[1];
  sub_1009924E8((uint64_t)&v15);
  return v13;
}

void sub_10099233C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1009924E8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100992350(uint64_t *a1, void *a2)
{
  sub_1009923E0((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void sub_1009923C8()
{
}

__n128 sub_1009923E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 112;
    do
    {
      *(_OWORD *)(v8 - 120) = *(_OWORD *)(a3 - 232);
      long long v9 = *(_OWORD *)(a3 - 216);
      *(void *)(v8 - 88) = *(void *)(a3 - 200);
      *(_OWORD *)(v8 - 104) = v9;
      *(void *)(a3 - 208) = 0;
      *(void *)(a3 - 200) = 0;
      *(void *)(a3 - 216) = 0;
      long long v10 = *(_OWORD *)(a3 - 192);
      *(void *)(v8 - 64) = *(void *)(a3 - 176);
      *(_OWORD *)(v8 - 80) = v10;
      *(void *)(a3 - 184) = 0;
      *(void *)(a3 - 176) = 0;
      *(void *)(a3 - 192) = 0;
      long long v11 = *(_OWORD *)(a3 - 168);
      *(void *)(v8 - 40) = *(void *)(a3 - 152);
      *(_OWORD *)(v8 - 56) = v11;
      *(void *)(a3 - 168) = 0;
      *(void *)(a3 - 160) = 0;
      *(void *)(a3 - 152) = 0;
      *(_DWORD *)(v8 - 32) = *(_DWORD *)(a3 - 144);
      long long v12 = *(_OWORD *)(a3 - 136);
      *(void *)(v8 - 8) = *(void *)(a3 - 120);
      *(_OWORD *)(v8 - 24) = v12;
      *(void *)(a3 - 128) = 0;
      *(void *)(a3 - 120) = 0;
      *(void *)(a3 - 136) = 0;
      long long v13 = *(_OWORD *)(a3 - 112);
      *(void *)(v8 + 16) = *(void *)(a3 - 96);
      *(_OWORD *)uint64_t v8 = v13;
      *(void *)(a3 - 104) = 0;
      *(void *)(a3 - 96) = 0;
      *(void *)(a3 - 112) = 0;
      long long v14 = *(_OWORD *)(a3 - 88);
      *(void *)(v8 + 40) = *(void *)(a3 - 72);
      *(_OWORD *)(v8 + 24) = v14;
      *(void *)(a3 - 80) = 0;
      *(void *)(a3 - 72) = 0;
      *(void *)(a3 - 88) = 0;
      long long v15 = *(_OWORD *)(a3 - 64);
      *(void *)(v8 + 64) = *(void *)(a3 - 48);
      *(_OWORD *)(v8 + 48) = v15;
      *(void *)(a3 - 64) = 0;
      *(void *)(a3 - 56) = 0;
      *(void *)(a3 - 48) = 0;
      long long v16 = *(_OWORD *)(a3 - 40);
      *(void *)(v8 + 88) = *(void *)(a3 - 24);
      *(_OWORD *)(v8 + 72) = v16;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 24) = 0;
      __n128 result = *(__n128 *)(a3 - 16);
      *(__n128 *)(v8 + 96) = result;
      v7 -= 232;
      v8 -= 232;
      a3 -= 232;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t sub_1009924E8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 232;
    sub_1000C584C(i - 232);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100992538(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1000C584C(v4 - 232);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1009925BC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x199999999999999) {
    unint64_t v9 = 0x333333333333333;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    long long v10 = (char *)sub_1001F7E24(v7, v9);
  }
  else {
    long long v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[80 * v4];
  long long v16 = &v10[80 * v9];
  sub_1009926C4((uint64_t)v14, a2);
  long long v15 = v14 + 80;
  sub_1006D3114(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1006D3220((uint64_t)&v13);
  return v11;
}

void sub_1009926B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006D3220((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1009926C4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  sub_100312438((uint64_t *)(a1 + 56), a2 + 56);
  return a1;
}

void sub_100992768(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10099279C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_1000C5AB4(a4 + v7, a2 + v7);
      v7 += 216;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1009927FC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 216;
    do
    {
      sub_1000C584C(v4 + v2);
      v2 -= 216;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100992820(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    long long v10 = (char *)sub_10010C8A4(v7, v9);
  }
  else {
    long long v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[88 * v4];
  long long v16 = &v10[88 * v9];
  sub_1000C5DA8((uint64_t)v14, a2);
  long long v15 = v14 + 88;
  sub_10010C82C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10010C988((uint64_t)&v13);
  return v11;
}

void sub_10099292C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010C988((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100992940(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100312A00((unsigned char *)a1, a2);
  sub_10031203C(v4 + 248, (long long *)(a2 + 248));
  *(void *)(a1 + 392) = *(void *)(a2 + 392);
  *(unsigned char *)(a1 + 400) = 1;
  return a1;
}

void sub_100992988(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 240)) {
    sub_1000C5634(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009929A4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 31);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v6 = *(unsigned __int8 *)(a2 + 31);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a2 + 16);
  }
  if (v5 != v6) {
    return 0;
  }
  unint64_t v8 = (const void **)(a1 + 8);
  if (v7 >= 0) {
    unint64_t v9 = (unsigned __int8 *)(a2 + 8);
  }
  else {
    unint64_t v9 = *(unsigned __int8 **)(a2 + 8);
  }
  if ((v4 & 0x80) != 0)
  {
    if (!memcmp(*v8, v9, *(void *)(a1 + 16))) {
      return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 31))
  {
    while (*(unsigned __int8 *)v8 == *v9)
    {
      unint64_t v8 = (const void **)((char *)v8 + 1);
      ++v9;
      if (!--v4) {
        return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
      }
    }
    return 0;
  }
  return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
}

void sub_100992A6C(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v17 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t object = xpc_int64_create(*a1);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v13 = &v17;
  long long v14 = "telephonyEnabled";
  sub_100035E70((uint64_t)&v13, &object, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (*((char *)a1 + 31) >= 0) {
    int v7 = (const char *)(a1 + 2);
  }
  else {
    int v7 = (const char *)*((void *)a1 + 1);
  }
  xpc_object_t v11 = xpc_string_create(v7);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  long long v13 = &v17;
  long long v14 = "reason";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v9 = xpc_int64_create(a1[8]);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  long long v13 = &v17;
  long long v14 = "wifiCallingEnabled";
  sub_100035E70((uint64_t)&v13, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_object_t v8 = v17;
  *a2 = v17;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_100992C80(uint64_t a1, void **a2)
{
  sub_100058DB0(v20, "");
  LODWORD(__p) = 0;
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(&v17, *(void **)v20, *(unint64_t *)&v20[2]);
    int v4 = (int)__p;
  }
  else
  {
    int v4 = 0;
    long long v17 = *(_OWORD *)v20;
    uint64_t v18 = v21;
  }
  int v5 = 0;
  int v19 = 0;
  *(_DWORD *)a1 = v4;
  xpc_object_t v6 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
  {
    operator delete(*v6);
    int v5 = v19;
  }
  *(_OWORD *)xpc_object_t v6 = v17;
  *(void *)(a1 + 24) = v18;
  HIBYTE(v18) = 0;
  LOBYTE(v17) = 0;
  *(_DWORD *)(a1 + 32) = v5;
  if (SHIBYTE(v21) < 0) {
    operator delete(*(void **)v20);
  }
  int v7 = *a2;
  xpc_object_t object = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    xpc_object_t v8 = object;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t object = v8;
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    std::string __p = &object;
    *(void *)&long long v17 = "telephonyEnabled";
    sub_100048BAC((uint64_t)&__p, v20);
    xpc_type_t type = xpc_get_type(*(xpc_object_t *)v20);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      LODWORD(v13[0]) = *(_DWORD *)a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v13, v20, v10);
      *(_DWORD *)a1 = v13[0];
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)a1 = xpc::dyn_cast_or_default((xpc *)v20, 0, (uint64_t)v10);
    }
    xpc_release(*(xpc_object_t *)v20);
    v13[0] = &object;
    v13[1] = "reason";
    sub_100048BAC((uint64_t)v13, &v14);
    std::string __p = 0;
    long long v17 = 0uLL;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v17) < 0) {
      operator delete(__p);
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)xpc_object_t v6 = *(_OWORD *)v20;
    *(void *)(a1 + 24) = v21;
    xpc_release(v14);
    std::string __p = &object;
    *(void *)&long long v17 = "wifiCallingEnabled";
    sub_100048BAC((uint64_t)&__p, v20);
    xpc_type_t v11 = xpc_get_type(*(xpc_object_t *)v20);
    if (v11 == (xpc_type_t)&_xpc_type_string)
    {
      LODWORD(v13[0]) = *(_DWORD *)(a1 + 32);
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v13, v20, v12);
      *(_DWORD *)(a1 + 32) = v13[0];
    }
    else if (v11 == (xpc_type_t)&_xpc_type_BOOL {
           || v11 == (xpc_type_t)&_xpc_type_int64
    }
           || v11 == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)(a1 + 32) = xpc::dyn_cast_or_default((xpc *)v20, 0, (uint64_t)v12);
    }
    xpc_release(*(xpc_object_t *)v20);
  }
  xpc_release(object);
}

void sub_100992F40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_100992FD8(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 31);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  uint64_t v4 = *(unsigned __int8 *)(a2 + 31);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 16);
  }
  if (v3 != v4) {
    return 0;
  }
  xpc_object_t v6 = (const void **)(a1 + 8);
  xpc_object_t v9 = *(unsigned __int8 **)(a2 + 8);
  int v7 = (unsigned __int8 *)(a2 + 8);
  xpc_object_t v8 = v9;
  if (v5 < 0) {
    int v7 = v8;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, v7, *(void *)(a1 + 16)) == 0;
  }
  if (!*(unsigned char *)(a1 + 31)) {
    return 1;
  }
  uint64_t v10 = v2 - 1;
  do
  {
    int v12 = *(unsigned __int8 *)v6;
    xpc_object_t v6 = (const void **)((char *)v6 + 1);
    int v11 = v12;
    int v14 = *v7++;
    int v13 = v14;
    BOOL v16 = v10-- != 0;
    uint64_t result = v11 == v13;
  }
  while (v11 == v13 && v16);
  return result;
}

void sub_10099308C(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v16 = xpc_int64_create(*a1);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  int v14 = &v18;
  long long v15 = "state";
  sub_100035E70((uint64_t)&v14, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v9 = (const char *)*((void *)a1 + 1);
  xpc_object_t v8 = a1 + 2;
  int v7 = v9;
  if (*((char *)v8 + 23) >= 0) {
    uint64_t v10 = (const char *)v8;
  }
  else {
    uint64_t v10 = v7;
  }
  xpc_object_t v12 = xpc_string_create(v10);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  int v14 = &v18;
  long long v15 = "reason";
  sub_100035E70((uint64_t)&v14, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v11 = v18;
  *a2 = v18;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v18);
}

void sub_100993238(uint64_t a1, void **a2)
{
  sub_100058DB0(v16, "");
  LODWORD(__p) = -1;
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&v14, *(void **)v16, *(unint64_t *)&v16[2]);
    int v4 = (int)__p;
  }
  else
  {
    long long v14 = *(_OWORD *)v16;
    uint64_t v15 = v17;
    int v4 = -1;
  }
  *(_DWORD *)a1 = v4;
  xpc_object_t v5 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)xpc_object_t v5 = v14;
  *(void *)(a1 + 24) = v15;
  HIBYTE(v15) = 0;
  LOBYTE(v14) = 0;
  if (SHIBYTE(v17) < 0) {
    operator delete(*(void **)v16);
  }
  xpc_object_t v6 = *a2;
  xpc_object_t object = v6;
  if (v6 && xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    xpc_object_t v7 = object;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t object = v7;
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    std::string __p = &object;
    *(void *)&long long v14 = "state";
    sub_100048BAC((uint64_t)&__p, v16);
    xpc_type_t type = xpc_get_type(*(xpc_object_t *)v16);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      LODWORD(v10[0]) = *(_DWORD *)a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v10, v16, v9);
      *(_DWORD *)a1 = v10[0];
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)a1 = xpc::dyn_cast_or_default((xpc *)v16, 0, (uint64_t)v9);
    }
    xpc_release(*(xpc_object_t *)v16);
    v10[0] = &object;
    v10[1] = "reason";
    sub_100048BAC((uint64_t)v10, &v11);
    std::string __p = 0;
    long long v14 = 0uLL;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v14) < 0) {
      operator delete(__p);
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = *(_OWORD *)v16;
    *(void *)(a1 + 24) = v17;
    xpc_release(v11);
  }
  xpc_release(object);
}

void sub_100993460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  xpc_release(a13);
  _Unwind_Resume(a1);
}

const void **sub_1009934DC(const void **result, const void *a2, const void *a3)
{
  if (a3)
  {
    sub_10099581C((uint64_t)result, (const void **)&theDict);
    CFDictionarySetValue(theDict, a2, a3);
    return sub_10005717C((const void **)&theDict);
  }
  return result;
}

void sub_10099352C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100993540(uint64_t a1, const void *a2)
{
  ctu::cf_to_xpc((uint64_t *)&object, *(ctu **)(a1 + 8), a2);
  xpc_object_t v3 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  xpc_release(object);
  int v4 = *(_DWORD *)a1;
  xpc_object_t object = v3;
  if (v3)
  {
    xpc_retain(v3);
    xpc_object_t v5 = v3;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t object = v5;
  }
  xpc_object_t v6 = xpc_null_create();
  xpc_object_t v7 = v6;
  sub_1000452AC(v4, &object, &v7);
  xpc_release(v6);
  xpc_release(v5);
  xpc_release(v3);
}

void sub_100993620(_Unwind_Exception *a1)
{
  xpc_release(v3);
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

const void **sub_100993660(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8)
{
  uint64_t v23 = 67;
  long long v24 = 0;
  sub_100993DE0((uint64_t)&v23, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v23, kCTSIMToolkitSession, a2);
  sub_100993858((const void **)&v23, a4);
  if ((a8 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v23, kCTSIMToolkitIcon, a8);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v21 = *(void *)(a3 + 16);
  }
  char v22 = 1;
  sub_100993C18((uint64_t)&v23, kCTSIMToolkitText, (uint64_t)__p);
  if (v22 && SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = (const void **)&kCTSIMToolkitDisplayTextPriorityNormal;
  if (a5) {
    uint64_t v15 = (const void **)&kCTSIMToolkitDisplayTextPriorityHigh;
  }
  sub_1009934DC((const void **)&v23, kCTSIMToolkitDisplayTextPriority, *v15);
  xpc_object_t v16 = (const void **)&kCTSIMToolkitDisplayTextOrderOutBehaviorSendOK;
  if (a7) {
    xpc_object_t v16 = (const void **)&kCTSIMToolkitDisplayTextOrderOutBehaviorClose;
  }
  sub_1009934DC((const void **)&v23, kCTSIMToolkitDisplayTextOrderOutBehavior, *v16);
  uint64_t v17 = (const void **)&kCTSIMToolkitDisplayTextTerminalDelayDisabled;
  if (a6) {
    uint64_t v17 = (const void **)&kCTSIMToolkitDisplayTextTerminalDelayEnabled;
  }
  sub_1009934DC((const void **)&v23, kCTSIMToolkitDisplayTextTerminalDelay, *v17);
  sub_100993540((uint64_t)&v23, v18);
  return sub_10005717C(&v24);
}

void sub_100993824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

const void **sub_100993858(const void **result, uint64_t a2)
{
  if ((a2 & 0xFF00000000) != 0)
  {
    uint64_t v2 = result;
    CFNumberRef v8 = 0;
    double valuePtr = (double)a2 / 10.0;
    CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
    if (v3)
    {
      double v4 = *(double *)&v8;
      CFNumberRef v8 = v3;
      double valuePtr = v4;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v5 = v8;
    CFNumberRef v7 = v8;
    CFNumberRef v8 = 0;
    sub_1000570E8((const void **)&v8);
    CFNumberRef v6 = v5;
    if (v5) {
      CFRetain(v5);
    }
    sub_100994328(v2, kCTSIMToolkitTimeout, (const void **)&v6);
    sub_1000577C4((const void **)&v6);
    return sub_1000570E8((const void **)&v7);
  }
  return result;
}

void sub_100993914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_10099393C(int a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 64);
  BOOL v4 = *(_DWORD *)(a3 + 48) == 1;
  BOOL v5 = *(_DWORD *)(a3 + 52) == 0;
  BOOL v6 = *(_DWORD *)(a3 + 56) == 1;
  uint64_t v7 = a3 + 24;
  if (v3 == -1) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = (unint64_t)&_mh_execute_header & 0xFFFFFFFF00000000 | v3;
  }
  return sub_100993660(a1, a2, v7, v8, v4, v5, v6, 0);
}

const void **sub_10099397C(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, char a9, char a10, char a11, char a12, uint64_t a13)
{
  uint64_t v30 = 68;
  uint64_t v31 = 0;
  sub_100993DE0((uint64_t)&v30, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v30, kCTSIMToolkitSession, a2);
  sub_100993858((const void **)&v30, a5);
  if ((a13 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v30, kCTSIMToolkitIcon, a13);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v28 = *(void *)(a3 + 16);
  }
  char v29 = 1;
  sub_100993C18((uint64_t)&v30, kCTSIMToolkitText, (uint64_t)__p);
  if (v29 && SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  if (a12) {
    CFBooleanRef v20 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v20 = kCFBooleanFalse;
  }
  sub_1009934DC((const void **)&v30, kCTSIMToolkitHelpAvailable, v20);
  if (a11) {
    CFBooleanRef v21 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v21 = kCFBooleanFalse;
  }
  sub_1009934DC((const void **)&v30, kCTSIMToolkitGetInputIsSecret, v21);
  if (a10) {
    CFBooleanRef v22 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v22 = kCFBooleanFalse;
  }
  sub_1009934DC((const void **)&v30, kCTSIMToolkitGetInputIsEditable, v22);
  if (a9) {
    int v23 = 1;
  }
  else {
    int v23 = 2;
  }
  if (a8) {
    int v23 = 0;
  }
  if (v23 == 2)
  {
    long long v24 = (const void **)&kCTSIMToolkitGetInputTypeString;
  }
  else if (v23 == 1)
  {
    long long v24 = (const void **)&kCTSIMToolkitGetInputTypeDigits;
  }
  else
  {
    long long v24 = (const void **)&kCTSIMToolkitGetInputTypeBoolean;
  }
  sub_1009934DC((const void **)&v30, kCTSIMToolkitGetInputType, *v24);
  if (*(unsigned char *)(a4 + 24)) {
    sub_100993C18((uint64_t)&v30, kCTSIMToolkitGetInputDefaultText, a4);
  }
  sub_100993DE0((uint64_t)&v30, kCTSIMToolkitGetInputMaximumLength, a7);
  sub_100993DE0((uint64_t)&v30, kCTSIMToolkitGetInputMinimumLength, a6);
  sub_100993540((uint64_t)&v30, v25);
  return sub_10005717C(&v31);
}

void sub_100993BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

const void **sub_100993C18(uint64_t a1, const void *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 16);
  }
  if (SHIBYTE(v8) < 0)
  {
    sub_10004FC84(__p, v7[0], (unint64_t)v7[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v7;
    uint64_t v12 = v8;
  }
  uint64_t v10 = 0;
  if (SHIBYTE(v12) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v14 = v12;
  }
  uint64_t v15 = 0;
  if (ctu::cf::convert_copy())
  {
    BOOL v5 = v10;
    uint64_t v10 = v15;
    xpc_object_t v16 = v5;
    sub_1000558F4(&v16);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__dst);
  }
  xpc_object_t value = v10;
  uint64_t v10 = 0;
  sub_1000558F4((const void **)&v10);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
  sub_10099581C(a1, (const void **)&__dst);
  CFDictionarySetValue((CFMutableDictionaryRef)__dst, a2, value);
  sub_10005717C((const void **)&__dst);
  return sub_1000558F4((const void **)&value);
}

void sub_100993D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

const void **sub_100993DE0(uint64_t a1, const void *a2, int a3)
{
  CFNumberRef v9 = 0;
  LODWORD(valuePtr) = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v5)
  {
    BOOL v6 = v9;
    CFNumberRef v9 = v5;
    double valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  xpc_object_t value = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  sub_10099581C(a1, (const void **)&valuePtr);
  CFDictionarySetValue(valuePtr, a2, value);
  sub_10005717C((const void **)&valuePtr);
  return sub_1000570E8((const void **)&value);
}

void sub_100993E7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_10005717C((const void **)va1);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100993EAC(int a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 56);
  int v4 = *(_DWORD *)(a3 + 48);
  char v5 = v4 == 2;
  BOOL v6 = v4 == 1;
  char v7 = *(_DWORD *)(a3 + 52) == 1;
  uint64_t v8 = a3 + 24;
  LOBYTE(__p) = 0;
  char v12 = 0;
  if (v3 == -1) {
    unint64_t v9 = 0;
  }
  else {
    unint64_t v9 = (unint64_t)&_mh_execute_header & 0xFFFFFFFF00000000 | v3;
  }
  sub_10099397C(a1, a2, v8, (uint64_t)&__p, v9, 1, 1, v6, v5, 1, 0, v7, 0);
  if (v12)
  {
    if (v11 < 0) {
      operator delete(__p);
    }
  }
}

void sub_100993F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100993F6C(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v17 = 0u;
  BOOL v6 = (void **)(a3 + 80);
  if (*(char *)(a3 + 103) < 0)
  {
    unint64_t v7 = *(void *)(a3 + 88);
    if (v7)
    {
      sub_10004FC84(__dst, *v6, v7);
      goto LABEL_6;
    }
  }
  else if (*(unsigned char *)(a3 + 103))
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v6;
    *(void *)&long long v17 = *(void *)(a3 + 96);
LABEL_6:
    BYTE8(v17) = 1;
  }
  int v8 = *(_DWORD *)(a3 + 48);
  int v9 = *(_DWORD *)(a3 + 56);
  int v10 = *(_DWORD *)(a3 + 60);
  int v11 = *(_DWORD *)(a3 + 64);
  int v12 = *(_DWORD *)(a3 + 68);
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_10099397C(a1, a2, a3 + 24, (uint64_t)__p, 0, v9, v10, 0, v8 == 2, 1, v12 == 0, v11 == 1, 0);
  if (v15 && v14 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v17))
  {
    if (SBYTE7(v17) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_100994098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a17 && a16 < 0) {
    operator delete(__p);
  }
  if (a24)
  {
    if (a23 < 0) {
      operator delete(a18);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1009940DC(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v22 = 69;
  int v23 = 0;
  sub_100993DE0((uint64_t)&v22, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v22, kCTSIMToolkitSession, a2);
  if ((a6 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v22, kCTSIMToolkitIcon, a6);
  }
  int v11 = (const void *)sub_1008DC530(a5);
  sub_1009934DC((const void **)&v22, kCTSIMToolkitPlayTone, v11);
  if (*(unsigned char *)(a3 + 24))
  {
    if (*(char *)(a3 + 23) < 0)
    {
      if (*(void *)(a3 + 8)) {
        goto LABEL_6;
      }
    }
    else if (*(unsigned char *)(a3 + 23))
    {
LABEL_6:
      sub_1000593FC((uint64_t)__p, (long long *)a3);
      if (v21)
      {
        sub_100993C18((uint64_t)&v22, kCTSIMToolkitText, (uint64_t)__p);
        if (v21)
        {
          if (v20 < 0) {
            operator delete(__p[0]);
          }
        }
      }
      goto LABEL_12;
    }
    sub_100993DE0((uint64_t)&v22, kCTSIMToolkitNoDisplay, 1);
  }
LABEL_12:
  if ((a4 & 0xFF00000000) != 0)
  {
    CFNumberRef v24 = 0;
    double valuePtr = (double)a4 / 10.0;
    CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
    if (v13)
    {
      double v14 = *(double *)&v24;
      CFNumberRef v24 = v13;
      double valuePtr = v14;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v15 = v24;
    CFNumberRef v18 = v24;
    CFNumberRef v24 = 0;
    sub_1000570E8((const void **)&v24);
    CFNumberRef v17 = v15;
    if (v15) {
      CFRetain(v15);
    }
    sub_100994328((const void **)&v22, kCTSIMToolkitPlayToneDuration, (const void **)&v17);
    sub_1000577C4((const void **)&v17);
    sub_1000570E8((const void **)&v18);
  }
  sub_100993540((uint64_t)&v22, v12);
  return sub_10005717C(&v23);
}

void sub_1009942CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v20);
  _Unwind_Resume(a1);
}

const void **sub_100994328(const void **result, const void *a2, const void **a3)
{
  if (*a3) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    sub_10099581C((uint64_t)result, (const void **)&theDict);
    CFDictionarySetValue(theDict, a2, *a3);
    return sub_10005717C((const void **)&theDict);
  }
  return result;
}

void sub_100994394(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1009943A8(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v13 = 0u;
  uint64_t v6 = *(unsigned __int8 *)(a3 + 47);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a3 + 32);
  }
  if (v6) {
    sub_100093B44((std::string *)__dst, (const std::string *)(a3 + 24));
  }
  uint64_t v7 = *(void *)(a3 + 56);
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  if (v7 == -1) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = (unint64_t)&_mh_execute_header & 0xFFFFFFFF00000000 | v7;
  }
  sub_1009940DC(a1, a2, (uint64_t)__p, v8, *(_DWORD *)(a3 + 48), 0);
  if (v11 && v10 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v13))
  {
    if (SBYTE7(v13) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_100994474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a22)
  {
    if (a21 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1009944BC(int a1, int a2, long long *a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  uint64_t v21 = 70;
  uint64_t v22 = 0;
  sub_100993DE0((uint64_t)&v21, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v21, kCTSIMToolkitSession, a2);
  if ((a7 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v21, kCTSIMToolkitIcon, a7);
  }
  sub_1000593FC((uint64_t)__p, a3);
  if (v20)
  {
    sub_100993C18((uint64_t)&v21, kCTSIMToolkitText, (uint64_t)__p);
    if (v20)
    {
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  long long v13 = (const void **)&kCFBooleanFalse;
  if (a5) {
    long long v13 = (const void **)&kCFBooleanTrue;
  }
  sub_1009934DC((const void **)&v21, kCTSIMToolkitHelpAvailable, *v13);
  if (a4) {
    BOOL v14 = (a4 & 0xFF00000000) == 0;
  }
  else {
    BOOL v14 = 1;
  }
  CFNumberRef v15 = (const void **)&kCTSIMToolkitDisplayListStylePicker;
  if (!v14) {
    CFNumberRef v15 = (const void **)&kCTSIMToolkitDisplayListStyleMenu;
  }
  sub_1009934DC((const void **)&v21, kCTSIMToolkitDisplayListStyle, *v15);
  sub_100993DE0((uint64_t)&v21, kCTSIMToolkitDisplayListCount, a6);
  sub_100993540((uint64_t)&v21, v16);
  return sub_10005717C(&v22);
}

void sub_100994644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

void sub_100994678(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v13 = 0u;
  uint64_t v6 = *(unsigned __int8 *)(a3 + 79);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a3 + 64);
  }
  if (v6) {
    sub_100093B44((std::string *)__dst, (const std::string *)(a3 + 56));
  }
  int v7 = *(_DWORD *)(a3 + 20);
  int v8 = *(_DWORD *)(a3 + 24);
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_1009944BC(a1, a2, (long long *)__p, (v8 == 2) | ((unint64_t)(v8 == 2) << 32), v7 == 1, -858993459 * ((uint64_t)(*(void *)(a3 + 40) - *(void *)(a3 + 32)) >> 3), 0);
  if (v11 && v10 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v13))
  {
    if (SBYTE7(v13) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_100994764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a22)
  {
    if (a21 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1009947AC(int a1, int a2, long long *a3, uint64_t a4)
{
  uint64_t v12 = 71;
  long long v13 = 0;
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSession, a2);
  if ((a4 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v12, kCTSIMToolkitIcon, a4);
  }
  sub_1000593FC((uint64_t)__p, a3);
  if (v11)
  {
    sub_100993C18((uint64_t)&v12, kCTSIMToolkitText, (uint64_t)__p);
    if (v11)
    {
      if (v10 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  sub_1009934DC((const void **)&v12, kCTSIMToolkitDisplayTextOrderOutBehavior, kCTSIMToolkitDisplayTextOrderOutBehaviorClose);
  sub_100993540((uint64_t)&v12, v7);
  return sub_10005717C(&v13);
}

void sub_1009948B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

void sub_1009948EC(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v11 = 0u;
  char v5 = (void **)(a3 + 192);
  if (*(char *)(a3 + 215) < 0)
  {
    unint64_t v6 = *(void *)(a3 + 200);
    if (v6)
    {
      sub_10004FC84(__dst, *v5, v6);
      goto LABEL_6;
    }
  }
  else if (*(unsigned char *)(a3 + 215))
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v5;
    *(void *)&long long v11 = *(void *)(a3 + 208);
LABEL_6:
    BYTE8(v11) = 1;
  }
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_1009947AC(a1, a2, (long long *)__p, 0);
  if (v9 && v8 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v11))
  {
    if (SBYTE7(v11) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_1009949B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22)
  {
    if (a21 < 0) {
      operator delete(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1009949F4(int a1, int a2, long long *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = 72;
  xpc_object_t v16 = 0;
  sub_100993DE0((uint64_t)&v15, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v15, kCTSIMToolkitSession, a2);
  if ((a4 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v15, kCTSIMToolkitIcon, a4);
  }
  sub_1000593FC((uint64_t)__p, a3);
  if (v14)
  {
    sub_100993C18((uint64_t)&v15, kCTSIMToolkitText, (uint64_t)__p);
    if (v14)
    {
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  uint64_t v9 = *(unsigned __int8 *)(a5 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a5 + 8);
  }
  if (v9) {
    sub_100993C18((uint64_t)&v15, kCTSIMToolkitSentSSString, a5);
  }
  sub_1009934DC((const void **)&v15, kCTSIMToolkitDisplayTextOrderOutBehavior, kCTSIMToolkitDisplayTextOrderOutBehaviorClose);
  sub_100993540((uint64_t)&v15, v10);
  return sub_10005717C(&v16);
}

void sub_100994B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

void sub_100994B70(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v13 = 0u;
  uint64_t v6 = *(unsigned __int8 *)(a3 + 183);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a3 + 168);
  }
  if (v6) {
    sub_100093B44((std::string *)__dst, (const std::string *)(a3 + 160));
  }
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  CSIPhoneNumber::getFullNumber((uint64_t *)v10, (CSIPhoneNumber *)(a3 + 24));
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_1009949F4(a1, a2, (long long *)__p, 0, (uint64_t)v10);
  if (v9 && v8 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
  if (BYTE8(v13))
  {
    if (SBYTE7(v13) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_100994C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  if (a29)
  {
    if (a28 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100994CAC(int a1, int a2, uint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v14 = 73;
  uint64_t v15 = 0;
  sub_100993DE0((uint64_t)&v14, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v14, kCTSIMToolkitSession, a2);
  if ((a5 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v14, kCTSIMToolkitIcon, a5);
  }
  sub_1000593FC((uint64_t)__p, a4);
  if (v13)
  {
    sub_100993C18((uint64_t)&v14, kCTSIMToolkitText, (uint64_t)__p);
    if (v13)
    {
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (*(unsigned char *)(a3 + 24))
  {
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
    {
      if (!*(unsigned char *)(a3 + 23)) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    if (*(void *)(a3 + 8)) {
LABEL_12:
    }
      sub_100993C18((uint64_t)&v14, kCTSIMToolkitSentUSSDString, a3);
  }
LABEL_13:
  sub_1009934DC((const void **)&v14, kCTSIMToolkitDisplayTextOrderOutBehavior, kCTSIMToolkitDisplayTextOrderOutBehaviorClose);
  sub_100993540((uint64_t)&v14, v9);
  return sub_10005717C(&v15);
}

void sub_100994E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

void sub_100994E34(int a1, int a2, uint64_t a3)
{
  long long __dst = 0u;
  long long v32 = 0u;
  uint64_t v6 = (void **)(a3 + 80);
  if (*(char *)(a3 + 103) < 0)
  {
    unint64_t v7 = *(void *)(a3 + 88);
    if (!v7) {
      goto LABEL_7;
    }
    sub_10004FC84(&__dst, *v6, v7);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 103)) {
      goto LABEL_7;
    }
    long long __dst = *(_OWORD *)v6;
    *(void *)&long long v32 = *(void *)(a3 + 96);
  }
  BYTE8(v32) = 1;
LABEL_7:
  long long v29 = 0u;
  long long v30 = 0u;
  char v8 = (void **)(a3 + 104);
  if (*(char *)(a3 + 127) < 0)
  {
    unint64_t v9 = *(void *)(a3 + 112);
    if (!v9) {
      goto LABEL_13;
    }
    sub_10004FC84(&v29, *v8, v9);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 127)) {
      goto LABEL_13;
    }
    long long v29 = *(_OWORD *)v8;
    *(void *)&long long v30 = *(void *)(a3 + 120);
  }
  BYTE8(v30) = 1;
LABEL_13:
  int v10 = *(_DWORD *)(a3 + 48);
  int v11 = *(_DWORD *)(a3 + 52);
  if (v10 == 1) {
    int v12 = 1;
  }
  else {
    int v12 = 2 * (v10 == 2);
  }
  CSIPhoneNumber::CSIPhoneNumber();
  sub_1000593FC((uint64_t)v20, &__dst);
  sub_1000593FC((uint64_t)__p, &v29);
  uint64_t v38 = 74;
  long long v39 = 0;
  sub_100993DE0((uint64_t)&v38, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v38, kCTSIMToolkitSession, a2);
  sub_1000593FC((uint64_t)v35, (long long *)v20);
  if (v37)
  {
    sub_100993C18((uint64_t)&v38, kCTSIMToolkitText, (uint64_t)v35);
    if (v37)
    {
      if (v36 < 0) {
        operator delete(v35[0]);
      }
    }
  }
  switch(v12)
  {
    case 2:
      char v13 = (const void **)&kCTSIMToolkitCallSetUpPriorityHigh;
      goto LABEL_26;
    case 1:
      char v13 = (const void **)&kCTSIMToolkitCallSetUpPriorityMedium;
      goto LABEL_26;
    case 0:
      char v13 = (const void **)&kCTSIMToolkitCallSetUpPriorityLow;
LABEL_26:
      uint64_t v14 = *v13;
      goto LABEL_28;
  }
  uint64_t v14 = 0;
LABEL_28:
  sub_1009934DC((const void **)&v38, kCTSIMToolkitCallSetUpPriority, v14);
  uint64_t v15 = (const void **)&kCFBooleanFalse;
  if (v11 == 1) {
    uint64_t v15 = (const void **)&kCFBooleanTrue;
  }
  sub_1009934DC((const void **)&v38, kCTSIMToolkitCallSetUpRedial, *v15);
  CSIPhoneNumber::getFullNumber((uint64_t *)v33, &v23);
  sub_100993C18((uint64_t)&v38, kCTSIMToolkitCallSetUpPhoneNumber, (uint64_t)v33);
  if (v34 < 0) {
    operator delete(v33[0]);
  }
  if (v19) {
    sub_100993C18((uint64_t)&v38, kCTSIMToolkitCallSetUpInCallText, (uint64_t)__p);
  }
  sub_100993540((uint64_t)&v38, v16);
  sub_10005717C(&v39);
  if (v19 && v18 < 0) {
    operator delete(__p[0]);
  }
  if (v22 && v21 < 0) {
    operator delete(v20[0]);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (v24 < 0) {
    operator delete(*(void **)&v23.var2.__r_.var0);
  }
  if (*((char *)&v23.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v23.var2.__r_.__value_.var0.var1.__data_);
  }
  if (BYTE8(v30) && SBYTE7(v30) < 0) {
    operator delete((void *)v29);
  }
  if (BYTE8(v32))
  {
    if (SBYTE7(v32) < 0) {
      operator delete((void *)__dst);
    }
  }
}

void sub_100995150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(unsigned char *)(v27 - 136))
  {
    if (*(char *)(v27 - 137) < 0) {
      operator delete(*(void **)(v27 - 160));
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100995224(int a1)
{
  uint64_t v3 = 76;
  int v4 = 0;
  sub_100993DE0((uint64_t)&v3, kCTSIMToolkitSimSlot, a1);
  sub_100993540((uint64_t)&v3, v1);
  return sub_10005717C(&v4);
}

void sub_100995280(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

const void **sub_100995294(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = 77;
  char v13 = 0;
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSession, a2);
  if ((a4 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v12, kCTSIMToolkitIcon, a4);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v10 = *(void *)(a3 + 16);
  }
  char v11 = 1;
  sub_100993C18((uint64_t)&v12, kCTSIMToolkitText, (uint64_t)__p);
  if (v11 && SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  sub_100993540((uint64_t)&v12, v7);
  return sub_10005717C(&v13);
}

void sub_10099539C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

const void **sub_1009953D0(int a1, int a2, long long *a3, uint64_t a4)
{
  uint64_t v12 = 78;
  char v13 = 0;
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v12, kCTSIMToolkitSession, a2);
  if ((a4 & 0xFF00000000) != 0) {
    sub_100993DE0((uint64_t)&v12, kCTSIMToolkitIcon, a4);
  }
  sub_1000593FC((uint64_t)__p, a3);
  if (v11)
  {
    sub_100993C18((uint64_t)&v12, kCTSIMToolkitText, (uint64_t)__p);
    if (v11)
    {
      if (v10 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  sub_1009934DC((const void **)&v12, kCTSIMToolkitDisplayTextOrderOutBehavior, kCTSIMToolkitDisplayTextOrderOutBehaviorClose);
  sub_100993540((uint64_t)&v12, v7);
  return sub_10005717C(&v13);
}

void sub_1009954DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10005717C(v15);
  _Unwind_Resume(a1);
}

void sub_100995510(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v10 = 0u;
  uint64_t v5 = *(unsigned __int8 *)(a3 + 71);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 56);
  }
  if (v5) {
    sub_100093B44((std::string *)__dst, (const std::string *)(a3 + 48));
  }
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_1009953D0(a1, a2, (long long *)__p, 0);
  if (v8 && v7 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v10))
  {
    if (SBYTE7(v10) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_1009955B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22)
  {
    if (a21 < 0) {
      operator delete(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1009955FC(int a1, int a2, uint64_t a3)
{
  uint64_t v7 = 79;
  char v8 = 0;
  sub_100993DE0((uint64_t)&v7, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v7, kCTSIMToolkitSession, a2);
  if (*(unsigned char *)(a3 + 24)) {
    sub_100993C18((uint64_t)&v7, kCTSIMToolkitLanguage, a3);
  }
  sub_100993540((uint64_t)&v7, v5);
  return sub_10005717C(&v8);
}

void sub_1009956A0(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

void sub_1009956B4(int a1, int a2, uint64_t a3)
{
  *(_OWORD *)long long __dst = 0u;
  long long v9 = 0u;
  if (*(_DWORD *)(a3 + 20) == 1) {
    sub_100093B44((std::string *)__dst, (const std::string *)(a3 + 24));
  }
  sub_1000593FC((uint64_t)__p, (long long *)__dst);
  sub_1009955FC(a1, a2, (uint64_t)__p);
  if (v7 && v6 < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v9))
  {
    if (SBYTE7(v9) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_10099574C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22)
  {
    if (a21 < 0) {
      operator delete(a16);
    }
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100995790(int a1, int a2)
{
  uint64_t v5 = 86;
  char v6 = 0;
  sub_100993DE0((uint64_t)&v5, kCTSIMToolkitSimSlot, a1);
  sub_100993DE0((uint64_t)&v5, kCTSIMToolkitSession, a2);
  sub_100993540((uint64_t)&v5, v3);
  return sub_10005717C(&v6);
}

void sub_100995808(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

const void **sub_10099581C@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v3 = (const void **)(a1 + 8);
  if (*(void *)(a1 + 8)) {
    int v4 = sub_1000C06D0;
  }
  else {
    int v4 = 0;
  }
  if (!v4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    char v6 = *v3;
    const void *v3 = Mutable;
    char v8 = v6;
    sub_10005717C(&v8);
  }
  return sub_100057240(a2, v3);
}

void *sub_1009958AC(void *a1, int *a2)
{
  int v4 = sub_10004B96C(a1, (uint64_t)"[", 1);
  uint64_t v5 = *a2;
  if (v5 > 7) {
    char v6 = "???";
  }
  else {
    char v6 = off_101A22650[v5];
  }
  size_t v7 = strlen(v6);
  sub_10004B96C(v4, (uint64_t)v6, v7);
  char v8 = sub_10004B96C(a1, (uint64_t)", response_code: ", 17);
  if (*((unsigned char *)a2 + 8)) {
    std::to_string((std::string *)v48, a2[1]);
  }
  else {
    sub_100058DB0(v48, "(null)");
  }
  if (v48[23] >= 0) {
    long long v9 = v48;
  }
  else {
    long long v9 = *(unsigned char **)v48;
  }
  if (v48[23] >= 0) {
    uint64_t v10 = v48[23];
  }
  else {
    uint64_t v10 = *(void *)&v48[8];
  }
  sub_10004B96C(v8, (uint64_t)v9, v10);
  if ((v48[23] & 0x80000000) != 0) {
    operator delete(*(void **)v48);
  }
  char v11 = sub_10004B96C(a1, (uint64_t)", ", 2);
  uint64_t v12 = a2[3];
  if (v12 > 5) {
    char v13 = "???";
  }
  else {
    char v13 = off_101A22690[v12];
  }
  size_t v14 = strlen(v13);
  sub_10004B96C(v11, (uint64_t)v13, v14);
  sub_10004B96C(a1, (uint64_t)", retry_count: ", 15);
  std::ostream::operator<<();
  uint64_t v15 = sub_10004B96C(a1, (uint64_t)", ongoing_for: ", 15);
  uint64_t v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v50 = 0u;
  memset(v48, 0, sizeof(v48));
  sub_10004DE24((uint64_t)v48);
  uint64_t v16 = *(void *)v48;
  uint64_t v17 = *v15;
  *(_DWORD *)&v48[*(void *)(*(void *)v48 - 24) + 8] = *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24) + 8);
  uint64_t v18 = *(void *)(v16 - 24);
  std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(v17 - 24)));
  v47.__locale_ = 0;
  std::ios_base::getloc((const std::ios_base *)&v48[v18]);
  std::ios_base::imbue((std::ios_base *)&v48[v18], &__loc);
  std::locale::~locale(&v43);
  char v19 = *(std::locale **)&v48[v18 + 40];
  if (v19)
  {
    (*((void (**)(std::locale *, std::locale *))v19->__locale_ + 2))(v19, &__loc);
    v62.__locale_ = 0;
    char v20 = v19 + 1;
    std::locale::locale(&v62, v20);
    std::locale::operator=(v20, &__loc);
    std::locale::~locale(&v62);
  }
  std::locale::~locale(&v47);
  std::locale::~locale(&__loc);
  *(void *)&v48[*(void *)(*(void *)v48 - 24) + 16] = *(uint64_t *)((char *)v15 + *(void *)(*v15 - 24) + 16);
  char v21 = (void *)std::ostream::operator<<();
  sub_10004B96C(v21, (uint64_t)"s", 1);
  sub_10004BC98((uint64_t)&v48[8], &v43);
  if ((v45 & 0x80u) == 0) {
    locale = &v43;
  }
  else {
    locale = v43.__locale_;
  }
  if ((v45 & 0x80u) == 0) {
    uint64_t v23 = v45;
  }
  else {
    uint64_t v23 = v44;
  }
  sub_10004B96C(v15, (uint64_t)locale, v23);
  if ((char)v45 < 0) {
    operator delete(v43.__locale_);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  char v24 = sub_10004B96C(a1, (uint64_t)", ", 2);
  uint64_t v25 = a2[8];
  if (v25 > 2) {
    char v26 = "???";
  }
  else {
    char v26 = off_101A226C0[v25];
  }
  size_t v27 = strlen(v26);
  sub_10004B96C(v24, (uint64_t)v26, v27);
  char v28 = sub_10004B96C(a1, (uint64_t)", ", 2);
  uint64_t v29 = a2[9];
  if (v29 > 2) {
    long long v30 = "???";
  }
  else {
    long long v30 = off_101A226D8[v29];
  }
  size_t v31 = strlen(v30);
  sub_10004B96C(v28, (uint64_t)v30, v31);
  long long v32 = sub_10004B96C(a1, (uint64_t)", ", 2);
  uint64_t v33 = a2[10];
  if (v33 > 0x12) {
    char v34 = "???";
  }
  else {
    char v34 = off_101A226F0[v33];
  }
  size_t v35 = strlen(v34);
  sub_10004B96C(v32, (uint64_t)v34, v35);
  char v36 = sub_10004B96C(a1, (uint64_t)", validity: ", 12);
  if (*((unsigned char *)a2 + 48)) {
    std::to_string((std::string *)v48, a2[11]);
  }
  else {
    sub_100058DB0(v48, "(null)");
  }
  if (v48[23] >= 0) {
    char v37 = v48;
  }
  else {
    char v37 = *(unsigned char **)v48;
  }
  if (v48[23] >= 0) {
    uint64_t v38 = v48[23];
  }
  else {
    uint64_t v38 = *(void *)&v48[8];
  }
  sub_10004B96C(v36, (uint64_t)v37, v38);
  if ((v48[23] & 0x80000000) != 0) {
    operator delete(*(void **)v48);
  }
  long long v39 = sub_10004B96C(a1, (uint64_t)", retry_after: ", 15);
  if (*((unsigned char *)a2 + 64)) {
    std::to_string((std::string *)v48, *((void *)a2 + 7));
  }
  else {
    sub_100058DB0(v48, "(null)");
  }
  if (v48[23] >= 0) {
    uint64_t v40 = v48;
  }
  else {
    uint64_t v40 = *(unsigned char **)v48;
  }
  if (v48[23] >= 0) {
    uint64_t v41 = v48[23];
  }
  else {
    uint64_t v41 = *(void *)&v48[8];
  }
  sub_10004B96C(v39, (uint64_t)v40, v41);
  if ((v48[23] & 0x80000000) != 0) {
    operator delete(*(void **)v48);
  }
  sub_10004B96C(a1, (uint64_t)"]", 1);
  return a1;
}

void sub_100995F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::locale a16, std::locale a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100995F94(int *a1@<X0>, char *a2@<X8>)
{
  *(void *)a2 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *(void *)a2 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *(void *)a2 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *(void *)a2 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v42 = xpc_int64_create(*a1);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  string = a2;
  char v20 = "phase";
  sub_100035E70((uint64_t)&string, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  if (*((unsigned char *)a1 + 8))
  {
    xpc_object_t v40 = xpc_int64_create(a1[1]);
    if (!v40) {
      xpc_object_t v40 = xpc_null_create();
    }
    string = a2;
    char v20 = "code";
    sub_100035E70((uint64_t)&string, &v40, &v41);
    xpc_release(v41);
    xpc_object_t v41 = 0;
    xpc_release(v40);
    xpc_object_t v40 = 0;
  }
  xpc_object_t v38 = xpc_int64_create(a1[3]);
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  string = a2;
  char v20 = "transport";
  sub_100035E70((uint64_t)&string, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_object_t v36 = xpc_int64_create(a1[4]);
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  string = a2;
  char v20 = "retry_count";
  sub_100035E70((uint64_t)&string, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_object_t v34 = xpc_int64_create(*((void *)a1 + 3));
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  string = a2;
  char v20 = "time_elapsed";
  sub_100035E70((uint64_t)&string, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_object_t v32 = xpc_int64_create(a1[8]);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  string = a2;
  char v20 = "server";
  sub_100035E70((uint64_t)&string, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_object_t v30 = xpc_int64_create(a1[9]);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  string = a2;
  char v20 = "provisioner";
  sub_100035E70((uint64_t)&string, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v28 = xpc_int64_create(a1[10]);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  string = a2;
  char v20 = "response";
  sub_100035E70((uint64_t)&string, &v28, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  size_t v7 = (const char *)(a1 + 18);
  if (*((char *)a1 + 95) < 0) {
    size_t v7 = *(const char **)v7;
  }
  xpc_object_t v26 = xpc_string_create(v7);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  string = a2;
  char v20 = "PhoneNumberSource";
  sub_100035E70((uint64_t)&string, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (*((unsigned char *)a1 + 48))
  {
    xpc_object_t v24 = xpc_int64_create(a1[11]);
    if (!v24) {
      xpc_object_t v24 = xpc_null_create();
    }
    string = a2;
    char v20 = "xml_validity";
    sub_100035E70((uint64_t)&string, &v24, &v25);
    xpc_release(v25);
    xpc_object_t v25 = 0;
    xpc_release(v24);
    xpc_object_t v24 = 0;
  }
  if (*((unsigned char *)a1 + 64))
  {
    xpc_object_t v22 = xpc_int64_create(*((void *)a1 + 7));
    if (!v22) {
      xpc_object_t v22 = xpc_null_create();
    }
    string = a2;
    char v20 = "retry_after";
    sub_100035E70((uint64_t)&string, &v22, &v23);
    xpc_release(v23);
    xpc_object_t v23 = 0;
    xpc_release(v22);
    xpc_object_t v22 = 0;
  }
  string = 0;
  char v20 = 0;
  uint64_t v21 = 0;
  int v8 = a1[10];
  if (v8 > 11)
  {
    if (v8 == 12)
    {
      long long v9 = "Missing cookie during client auth";
    }
    else
    {
      if (v8 != 15) {
        goto LABEL_49;
      }
      long long v9 = "Certificate verification failed";
    }
  }
  else if (v8)
  {
    if (v8 != 11) {
      goto LABEL_49;
    }
    long long v9 = "Empty client Auth response";
  }
  else
  {
    long long v9 = "Invalid response";
  }
  sub_100058DB0(&string, v9);
LABEL_49:
  if (SHIBYTE(v21) < 0)
  {
    if (v20)
    {
      p_string = string;
      goto LABEL_54;
    }
  }
  else if (HIBYTE(v21))
  {
    p_string = (const char *)&string;
LABEL_54:
    xpc_object_t v17 = xpc_string_create(p_string);
    if (!v17) {
      xpc_object_t v17 = xpc_null_create();
    }
    uint64_t v15 = a2;
    uint64_t v16 = "failure_reason";
    sub_100035E70((uint64_t)&v15, &v17, &v18);
    xpc_release(v18);
    xpc_object_t v18 = 0;
    xpc_release(v17);
    xpc_object_t v17 = 0;
    xpc_object_t v13 = xpc_BOOL_create(0);
    if (!v13) {
      xpc_object_t v13 = xpc_null_create();
    }
    uint64_t v15 = a2;
    uint64_t v16 = "is_successful";
    sub_100035E70((uint64_t)&v15, &v13, &v14);
    xpc_release(v14);
    xpc_object_t v14 = 0;
    xpc_release(v13);
    xpc_object_t v13 = 0;
    goto LABEL_62;
  }
  xpc_object_t v11 = xpc_BOOL_create(1);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  uint64_t v15 = a2;
  uint64_t v16 = "is_successful";
  sub_100035E70((uint64_t)&v15, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
LABEL_62:
  if (SHIBYTE(v21) < 0) {
    operator delete(string);
  }
}

void sub_1009965A0(_Unwind_Exception *a1)
{
  sub_10017143C(v1);
  _Unwind_Resume(a1);
}

uint64_t IMSCallModel::IMSCallModel(uint64_t a1, void *a2, uint64_t *a3, NSObject **a4, void *a5)
{
  uint64_t v10 = *a3;
  if (!*a3) {
    goto LABEL_9;
  }
  if (*(unsigned char *)(v10 + 49) == 1)
  {
    xpc_object_t v13 = "call.CmdDriver.IMS.mdl.T";
    goto LABEL_11;
  }
  if (*(unsigned char *)(v10 + 49))
  {
LABEL_9:
    xpc_object_t v13 = "call.CmdDriver.IMS.mdl";
    goto LABEL_11;
  }
  int v11 = *(_DWORD *)(v10 + 52);
  xpc_object_t v12 = "call.CmdDriver.IMS.mdl";
  if (v11 == 2) {
    xpc_object_t v12 = "call.CmdDriver.IMS.mdl.2";
  }
  if (v11 == 1) {
    xpc_object_t v13 = "call.CmdDriver.IMS.mdl.1";
  }
  else {
    xpc_object_t v13 = v12;
  }
LABEL_11:
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, v13);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  xpc_object_t v14 = *a4;
  *(void *)(a1 + 56) = *a4;
  if (v14) {
    dispatch_retain(v14);
  }
  *(void *)(a1 + 64) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v20, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 72), (const ctu::OsLogLogger *)&v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  v21[0] = off_101999E18;
  v21[1] = sub_100996B24;
  v21[3] = v21;
  *(void *)(a1 + 80) = 0;
  if ((capabilities::ct::supportsGemini(v15) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 80)) {
    operator new();
  }
  sub_10008863C(v21);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)a1 = off_101A22798;
  *(void *)(a1 + 8) = off_101A22A00;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = *a2;
  uint64_t v16 = a2[1];
  *(void *)(a1 + 104) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = *a3;
  uint64_t v17 = a3[1];
  *(void *)(a1 + 120) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 168) = a1 + 168;
  *(void *)(a1 + 176) = a1 + 168;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 1065353216;
  CallOperationContext::CallOperationContext((CallOperationContext *)(a1 + 232));
  *(_WORD *)(a1 + 664) = 0;
  *(_OWORD *)(a1 + 680) = 0u;
  *(void *)(a1 + 672) = a1 + 680;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 696) = a1 + 704;
  *(unsigned char *)(a1 + 728) = 0;
  *(void *)(a1 + 732) = 0x200000002;
  *(unsigned char *)(a1 + 740) = 0;
  *(_DWORD *)(a1 + 744) = 0;
  *(_OWORD *)(a1 + 752) = 0u;
  *(void *)(a1 + 768) = *a5;
  uint64_t v18 = a5[1];
  *(void *)(a1 + 776) = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 784) = 0;
  return a1;
}

void sub_10099699C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_100996B24(int a1)
{
  if ((a1 - 1) > 2) {
    return "call.CmdDriver.IMS.?";
  }
  else {
    return off_101A22D70[a1 - 1];
  }
}

uint64_t IMSCallModel::init(uint64_t a1, long long *a2, long long *a3)
{
  long long v5 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 136);
  *(_OWORD *)(a1 + 128) = v5;
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  int v8 = *(std::__shared_weak_count **)(a1 + 152);
  *(_OWORD *)(a1 + 144) = v7;
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v9);
  *(void *)(a1 + 720) = result;
  return result;
}

void **sub_100996C00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v140 = _os_activity_create((void *)&_mh_execute_header, "Call: Disconnected", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state[0].opaque[1] = 0;
  state[0].opaque[0] = 0;
  os_activity_scope_enter(v140, state);
  os_activity_scope_leave(state);
  int v8 = *(_DWORD *)(a4 + 32);
  uint64_t v9 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v10 = (void *)a2;
    }
    else {
      uint64_t v10 = *(void **)a2;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v11 = a3;
    }
    else {
      uint64_t v11 = *(void *)a3;
    }
    LODWORD(state[0].opaque[0]) = 136315650;
    *(uint64_t *)((char *)state[0].opaque + 4) = (uint64_t)v10;
    WORD2(state[0].opaque[1]) = 2080;
    *(uint64_t *)((char *)&state[0].opaque[1] + 6) = v11;
    HIWORD(state[1].opaque[0]) = 1024;
    LODWORD(state[1].opaque[1]) = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: DISCONNECTED for %s (uuid) with reason %s (%d)", (uint8_t *)state, 0x1Cu);
  }
  uint64_t v193 = 0;
  long long v192 = 0u;
  long long v191 = 0u;
  long long v190 = 0u;
  long long v189 = 0u;
  long long v188 = 0u;
  long long v187 = 0u;
  long long v186 = 0u;
  long long v185 = 0u;
  long long v184 = 0u;
  long long v183 = 0u;
  long long v182 = 0u;
  long long v181 = 0u;
  long long v180 = 0u;
  long long v179 = 0u;
  long long v178 = 0u;
  long long v177 = 0u;
  long long v176 = 0u;
  long long v175 = 0u;
  long long v174 = 0u;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  *(_OWORD *)__src = 0u;
  memset(state, 0, sizeof(state));
  sub_10057F630((uint64_t)state);
  char v12 = sub_100998628(a1, a2, (uint64_t)state);
  xpc_object_t v13 = *(os_log_t **)(a1 + 720);
  xpc_object_t v14 = *v13;
  if (v12)
  {
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a4 + 36)) {
        uint64_t v15 = "true";
      }
      else {
        uint64_t v15 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I IMS call end status sent: %s", buf, 0xCu);
    }
    (*(void (**)(void, os_activity_scope_state_s *, void))(**(void **)(a1 + 128) + 296))(*(void *)(a1 + 128), state, *(unsigned __int8 *)(a4 + 36));
    unsigned int v125 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
    uint64_t v138 = 0;
    uint64_t v137 = 0;
    uint64_t v139 = 0;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 352))(&v137);
    uint64_t v124 = a4;
    __int16 v123 = v8;
    uint64_t v16 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = BYTE5(v173);
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(void *)&buf[10] = 0xFAFAFAFAFAFAFAFBLL * ((v138 - v137) >> 3);
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Disconnecting call is in a mutli party? %d, Size of CallList is what? %lu", buf, 0x12u);
    }
    if (BYTE5(v173))
    {
      uint64_t v17 = v138;
      uint64_t v18 = v137;
      if (v138 != v137 && v138 - v137 == 816)
      {
        do
        {
          *(unsigned char *)(v18 + 85) = 0;
          if (CallInfo::operator!=())
          {
            uint64_t v168 = 0;
            long long v167 = 0u;
            long long v166 = 0u;
            long long v165 = 0u;
            long long v164 = 0u;
            long long v163 = 0u;
            long long v162 = 0u;
            long long v161 = 0u;
            long long v160 = 0u;
            long long v159 = 0u;
            long long v158 = 0u;
            long long v157 = 0u;
            long long v156 = 0u;
            long long v155 = 0u;
            long long v154 = 0u;
            long long v153 = 0u;
            long long v152 = 0u;
            long long v151 = 0u;
            long long v150 = 0u;
            long long v149 = 0u;
            long long v148 = 0u;
            long long v147 = 0u;
            long long v146 = 0u;
            long long v145 = 0u;
            memset(buf, 0, sizeof(buf));
            sub_100245B5C((uint64_t)buf, v18);
            int v19 = DWORD2(v146);
            uint64_t v20 = **(NSObject ***)(a1 + 720);
            BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
            if (v19)
            {
              if (v21)
              {
                long long v135 = *(const void **)buf;
                if (*(void *)buf) {
                  CFRetain(*(CFTypeRef *)buf);
                }
                sub_101328F44((CFUUIDRef *)&v135, (uint64_t)__p);
                if (v142 >= 0) {
                  OsLogContext v22 = __p;
                }
                else {
                  OsLogContext v22 = *(unsigned char **)__p;
                }
                *(_DWORD *)long long v143 = 136315138;
                *(void *)&v143[4] = v22;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Fake Incoming Indication: Held for %s", v143, 0xCu);
                if (v142 < 0) {
                  operator delete(*(void **)__p);
                }
                sub_10012577C(&v135);
              }
              (*(void (**)(void, uint8_t *))(**(void **)(a1 + 128) + 128))(*(void *)(a1 + 128), buf);
            }
            else
            {
              if (v21)
              {
                long long v136 = *(const void **)buf;
                if (*(void *)buf) {
                  CFRetain(*(CFTypeRef *)buf);
                }
                sub_101328F44((CFUUIDRef *)&v136, (uint64_t)__p);
                if (v142 >= 0) {
                  xpc_object_t v23 = __p;
                }
                else {
                  xpc_object_t v23 = *(unsigned char **)__p;
                }
                *(_DWORD *)long long v143 = 136315138;
                *(void *)&v143[4] = v23;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Fake Incoming Indication: ACTIVE for %s", v143, 0xCu);
                if (v142 < 0) {
                  operator delete(*(void **)__p);
                }
                sub_10012577C(&v136);
              }
              (*(void (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 128) + 64))(*(void *)(a1 + 128), buf, 1);
            }
            xpc_object_t v24 = **(NSObject ***)(a1 + 720);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = asString();
              *(_DWORD *)std::string __p = 136315138;
              *(void *)&__p[4] = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Call type of the active call: %s", __p, 0xCu);
            }
            if (BYTE4(v172) == 2)
            {
              uint64_t v26 = *(void *)(a1 + 128);
              *(_DWORD *)std::string __p = 0;
              (*(void (**)(uint64_t, unsigned char *, void))(*(void *)v26 + 320))(v26, __p, v125);
            }
            sub_1002243E8((uint64_t)buf);
          }
          v18 += 408;
        }
        while (v18 != v17);
      }
    }
    xpc_object_t v27 = (uint64_t **)(a1 + 672);
    xpc_object_t v28 = (uint64_t *)sub_100046F68(a1 + 672, (void **)a2);
    __int16 v29 = v8;
    uint64_t v30 = v124;
    if ((uint64_t *)(a1 + 680) != v28)
    {
      xpc_object_t v31 = v28;
      xpc_object_t v32 = (uint64_t *)v28[1];
      if (v32)
      {
        do
        {
          xpc_object_t v33 = v32;
          xpc_object_t v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        xpc_object_t v35 = v28;
        do
        {
          xpc_object_t v33 = (uint64_t *)v35[2];
          BOOL v36 = *v33 == (void)v35;
          xpc_object_t v35 = v33;
        }
        while (!v36);
      }
      if (*v27 == v28) {
        *xpc_object_t v27 = v33;
      }
      --*(void *)(a1 + 688);
      sub_10005EE6C(*(uint64_t **)(a1 + 680), v28);
      sub_1001FEC1C((uint64_t)(v31 + 4));
      operator delete(v31);
    }
    *(void *)std::string __p = 0;
    if (*(char *)(a3 + 23) >= 0) {
      xpc_object_t v37 = (const char *)a3;
    }
    else {
      xpc_object_t v37 = *(const char **)a3;
    }
    CFStringRef v38 = CFStringCreateWithCString(kCFAllocatorDefault, v37, 0x8000100u);
    *(void *)std::string __p = v38;
    if (!v38)
    {
      xpc_object_t v39 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Received kCallStatusDisconnected without a reason string", buf, 2u);
      }
LABEL_158:
      WORD2(v175) = v29;
      (*(void (**)(void, os_activity_scope_state_s *, uint64_t, void))(**(void **)(a1 + 128) + 72))(*(void *)(a1 + 128), state, 1, *(unsigned __int8 *)(v30 + 1));
      uint64_t v78 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v79 = asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v79;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Call type of the disconnected call: %s", buf, 0xCu);
      }
      v80 = (uint64_t *)BYTE4(v172);
      if (BYTE4(v172) == 2)
      {
        uint64_t v81 = *(void *)(a1 + 128);
        *(_DWORD *)std::string buf = 6;
        (*(void (**)(uint64_t, uint8_t *, void))(*(void *)v81 + 320))(v81, buf, v125);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v80, *(Registry **)(a1 + 96));
      uint64_t v83 = ServiceMap;
      if (v84 < 0)
      {
        v85 = (unsigned __int8 *)(v84 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v86 = 5381;
        do
        {
          uint64_t v84 = v86;
          unsigned int v87 = *v85++;
          uint64_t v86 = (33 * v86) ^ v87;
        }
        while (v87);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v84;
      uint64_t v88 = sub_10004D37C(&v83[1].__m_.__sig, (unint64_t *)buf);
      if (v88)
      {
        uint64_t v89 = v88[3];
        v90 = (std::__shared_weak_count *)v88[4];
        if (v90)
        {
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v83);
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v90);
          char v91 = 0;
          if (!v89) {
            goto LABEL_183;
          }
          goto LABEL_171;
        }
      }
      else
      {
        uint64_t v89 = 0;
      }
      std::mutex::unlock(v83);
      v90 = 0;
      char v91 = 1;
      if (!v89) {
        goto LABEL_183;
      }
LABEL_171:
      uint64_t v92 = HIDWORD(v183);
      if (*(unsigned char *)(v30 + 2))
      {
        if (SBYTE7(v171) < 0)
        {
          sub_10004FC84(&__dst, __src[0], (unint64_t)__src[1]);
        }
        else
        {
          long long __dst = *(_OWORD *)__src;
          uint64_t v129 = v171;
        }
        (*(void (**)(uint64_t, uint64_t, long long *, void, uint64_t))(*(void *)v89 + 200))(v89, v92, &__dst, HIDWORD(v173), 1);
        if ((SHIBYTE(v129) & 0x80000000) == 0) {
          goto LABEL_183;
        }
        p_dst = (void **)&__dst;
      }
      else
      {
        if (SBYTE7(v171) < 0)
        {
          sub_10004FC84(&v126, __src[0], (unint64_t)__src[1]);
        }
        else
        {
          long long v126 = *(_OWORD *)__src;
          uint64_t v127 = v171;
        }
        (*(void (**)(uint64_t, uint64_t, long long *, void, void))(*(void *)v89 + 200))(v89, v92, &v126, HIDWORD(v173), 0);
        if ((SHIBYTE(v127) & 0x80000000) == 0) {
          goto LABEL_183;
        }
        p_dst = (void **)&v126;
      }
      operator delete(*p_dst);
LABEL_183:
      if ((v91 & 1) == 0) {
        sub_10004D2C8(v90);
      }
      goto LABEL_185;
    }
    if (CFStringCompare(v38, kIMSCallDisconnectionReasonNoEmergencyCallLocation, 0))
    {
      if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonNetworkError, 0))
      {
        if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonRemoteBusy, 0))
        {
          if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonForbidden, 0))
          {
            if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonMediaTimeout, 0))
            {
              if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonMediaError, 0))
              {
                if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonMediaHeartbeatTimeout, 0))
                {
                  if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonUnknownError))
                  {
                    uint64_t v95 = **(NSObject ***)(a1 + 720);
                    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
                    {
                      if (*(char *)(a2 + 23) >= 0) {
                        CFTypeRef v96 = (void *)a2;
                      }
                      else {
                        CFTypeRef v96 = *(void **)a2;
                      }
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = v96;
                      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to unknown error with call uuid %s", buf, 0xCu);
                    }
                    DWORD2(v175) = 1;
                    goto LABEL_157;
                  }
                  if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonInviteTimeout))
                  {
                    v97 = **(NSObject ***)(a1 + 720);
                    if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to timeout, will be falling back to CS", buf, 2u);
                    }
                    DWORD2(v175) = 84;
                    BYTE12(v175) = 1;
                    uint64_t v98 = *(void *)(a1 + 128);
                    sub_100245B5C((uint64_t)v132, (uint64_t)state);
                    xpc_object_t v99 = v132;
                    (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v98 + 256))(v98, v132, 3);
                    goto LABEL_199;
                  }
                  if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonRequiresCSFB))
                  {
                    uint64_t v100 = **(NSObject ***)(a1 + 720);
                    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to error that requires falling back to CS", buf, 2u);
                    }
                    DWORD2(v175) = 85;
                    BYTE12(v175) = 1;
                    uint64_t v101 = *(void *)(a1 + 128);
                    sub_100245B5C((uint64_t)v131, (uint64_t)state);
                    xpc_object_t v99 = v131;
                    (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v101 + 256))(v101, v131, 4);
                    goto LABEL_199;
                  }
                  if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonLocalSocketError, 0))
                  {
                    if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonSecondaryDeviceAlreadyInUse, 0))
                    {
                      if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonAnsweredElsewhere, 0))
                      {
                        if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonTransferredToOtherDevice, 0))
                        {
                          if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonAccessBarring, 0))
                          {
                            if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonMediaserverCrash, 0))
                            {
                              if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonAudioUnit, 0))
                              {
                                if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonBasebandCrash))
                                {
                                  long long v114 = **(NSObject ***)(a1 + 720);
                                  if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
                                  {
                                    if (*(char *)(a2 + 23) >= 0) {
                                      long long v115 = (void *)a2;
                                    }
                                    else {
                                      long long v115 = *(void **)a2;
                                    }
                                    *(_DWORD *)std::string buf = 136315138;
                                    *(void *)&uint8_t buf[4] = v115;
                                    _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to Baseband Crash, call uuid %s", buf, 0xCu);
                                  }
                                  DWORD2(v175) = 3;
                                  goto LABEL_244;
                                }
                                if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonInvalidRat))
                                {
                                  long long v116 = **(NSObject ***)(a1 + 720);
                                  if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
                                  {
                                    if (*(char *)(a2 + 23) >= 0) {
                                      long long v117 = (void *)a2;
                                    }
                                    else {
                                      long long v117 = *(void **)a2;
                                    }
                                    *(_DWORD *)std::string buf = 136315138;
                                    *(void *)&uint8_t buf[4] = v117;
                                    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to Invalid RAT, call uuid %s", buf, 0xCu);
                                  }
                                  DWORD2(v175) = 100;
                                  BYTE12(v175) = 1;
                                  HIBYTE(v188) = 1;
                                  goto LABEL_251;
                                }
                                if (CFEqual(*(CFStringRef *)__p, kIMSCallDisconnectionReasonRequiresRedial))
                                {
                                  long long v118 = **(NSObject ***)(a1 + 720);
                                  if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
                                  {
                                    if (*(char *)(a2 + 23) >= 0) {
                                      long long v119 = (void *)a2;
                                    }
                                    else {
                                      long long v119 = *(void **)a2;
                                    }
                                    *(_DWORD *)std::string buf = 136315138;
                                    *(void *)&uint8_t buf[4] = v119;
                                    _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to IMS Fallback Requested, call uuid %s", buf, 0xCu);
                                  }
                                  DWORD2(v175) = 85;
                                  BYTE12(v175) = 1;
                                  (*(void (**)(void, os_activity_scope_state_s *, uint64_t))(**(void **)(a1 + 128) + 264))(*(void *)(a1 + 128), state, 3);
                                  __int16 v29 = v123;
                                  goto LABEL_200;
                                }
                                if (CFStringCompare(*(CFStringRef *)__p, kIMSCallDisconnectionReasonRequiresRedialOverLteOnly, 0))
                                {
                                  DWORD2(v175) = 0;
LABEL_244:
                                  BYTE12(v175) = 1;
LABEL_251:
                                  __int16 v29 = v8;
                                  uint64_t v30 = v124;
                                  goto LABEL_158;
                                }
                                long long v120 = **(NSObject ***)(a1 + 720);
                                if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                                {
                                  if (*(char *)(a2 + 23) >= 0) {
                                    long long v121 = (void *)a2;
                                  }
                                  else {
                                    long long v121 = *(void **)a2;
                                  }
                                  *(_DWORD *)std::string buf = 136315138;
                                  *(void *)&uint8_t buf[4] = v121;
                                  _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to reason that requires RedialOverLteOnly, call uuid %s", buf, 0xCu);
                                }
                                DWORD2(v175) = 85;
                                BYTE12(v175) = 1;
                                uint64_t v122 = *(void *)(a1 + 128);
                                sub_100245B5C((uint64_t)v130, (uint64_t)state);
                                __int16 v29 = v123;
                                xpc_object_t v99 = v130;
                                (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v122 + 256))(v122, v130, 10);
LABEL_199:
                                sub_1002243E8((uint64_t)v99);
LABEL_200:
                                WORD2(v175) = v29;
LABEL_185:
                                sub_1000558F4((const void **)__p);
                                *(void *)std::string buf = &v137;
                                sub_1002244D8((void ***)buf);
                                goto LABEL_186;
                              }
                              long long v112 = **(NSObject ***)(a1 + 720);
                              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
                              {
                                if (*(char *)(a2 + 23) >= 0) {
                                  long long v113 = (void *)a2;
                                }
                                else {
                                  long long v113 = *(void **)a2;
                                }
                                *(_DWORD *)std::string buf = 136315138;
                                *(void *)&uint8_t buf[4] = v113;
                                _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to Media Start Failure, call uuid %s", buf, 0xCu);
                              }
                              int v54 = 77;
                            }
                            else
                            {
                              v110 = **(NSObject ***)(a1 + 720);
                              if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                              {
                                if (*(char *)(a2 + 23) >= 0) {
                                  long long v111 = (void *)a2;
                                }
                                else {
                                  long long v111 = *(void **)a2;
                                }
                                *(_DWORD *)std::string buf = 136315138;
                                *(void *)&uint8_t buf[4] = v111;
                                _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to Mediaserver crash, call uuid %s", buf, 0xCu);
                              }
                              int v54 = 76;
                            }
                          }
                          else
                          {
                            long long v108 = **(NSObject ***)(a1 + 720);
                            if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                            {
                              if (*(char *)(a2 + 23) >= 0) {
                                char v109 = (void *)a2;
                              }
                              else {
                                char v109 = *(void **)a2;
                              }
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v109;
                              _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to Access barring, call uuid %s", buf, 0xCu);
                            }
                            int v54 = 26;
                          }
                        }
                        else
                        {
                          v106 = **(NSObject ***)(a1 + 720);
                          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                          {
                            if (*(char *)(a2 + 23) >= 0) {
                              unsigned __int8 v107 = (void *)a2;
                            }
                            else {
                              unsigned __int8 v107 = *(void **)a2;
                            }
                            *(_DWORD *)std::string buf = 136315138;
                            *(void *)&uint8_t buf[4] = v107;
                            _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to the call being transferred to another device %s", buf, 0xCu);
                          }
                          int v54 = 82;
                        }
                      }
                      else
                      {
                        uint64_t v104 = **(NSObject ***)(a1 + 720);
                        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
                        {
                          if (*(char *)(a2 + 23) >= 0) {
                            unsigned __int8 v105 = (void *)a2;
                          }
                          else {
                            unsigned __int8 v105 = *(void **)a2;
                          }
                          *(_DWORD *)std::string buf = 136315138;
                          *(void *)&uint8_t buf[4] = v105;
                          _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to the call being answered on another device %s", buf, 0xCu);
                        }
                        int v54 = 81;
                      }
                    }
                    else
                    {
                      v102 = **(NSObject ***)(a1 + 720);
                      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                      {
                        if (*(char *)(a2 + 23) >= 0) {
                          unsigned __int8 v103 = (void *)a2;
                        }
                        else {
                          unsigned __int8 v103 = *(void **)a2;
                        }
                        *(_DWORD *)std::string buf = 136315138;
                        *(void *)&uint8_t buf[4] = v103;
                        _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due another secondary device already on a call %s", buf, 0xCu);
                      }
                      int v54 = 80;
                    }
                  }
                  else
                  {
                    int v54 = 78;
                  }
                }
                else
                {
                  int v76 = **(NSObject ***)(a1 + 720);
                  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                  {
                    if (*(char *)(a2 + 23) >= 0) {
                      uint64_t v77 = (void *)a2;
                    }
                    else {
                      uint64_t v77 = *(void **)a2;
                    }
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v77;
                    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to media hold heartbeat timeout with call uuid %s", buf, 0xCu);
                  }
                  int v54 = 74;
                }
              }
              else
              {
                long long v74 = **(NSObject ***)(a1 + 720);
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                {
                  if (*(char *)(a2 + 23) >= 0) {
                    std::string v75 = (void *)a2;
                  }
                  else {
                    std::string v75 = *(void **)a2;
                  }
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v75;
                  _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to media error with call uuid %s", buf, 0xCu);
                }
                int v54 = 75;
              }
            }
            else
            {
              uint64_t v72 = **(NSObject ***)(a1 + 720);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(a2 + 23) >= 0) {
                  v73 = (void *)a2;
                }
                else {
                  v73 = *(void **)a2;
                }
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v73;
                _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to media timeout with call uuid %s", buf, 0xCu);
              }
              int v54 = 73;
            }
          }
          else
          {
            uint64_t v70 = **(NSObject ***)(a1 + 720);
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(a2 + 23) >= 0) {
                uint64_t v71 = (void *)a2;
              }
              else {
                uint64_t v71 = *(void **)a2;
              }
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v71;
              _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to rejection from the network (forbidden) with call uuid %s", buf, 0xCu);
            }
            int v54 = 32;
          }
        }
        else
        {
          long long v55 = **(NSObject ***)(a1 + 720);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a2 + 23) >= 0) {
              long long v56 = (void *)a2;
            }
            else {
              long long v56 = *(void **)a2;
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v56;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to remote user busy with call uuid %s", buf, 0xCu);
          }
          int v54 = 28;
        }
      }
      else
      {
        long long v52 = **(NSObject ***)(a1 + 720);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            long long v53 = (void *)a2;
          }
          else {
            long long v53 = *(void **)a2;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v53;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected due to network error with call uuid %s", buf, 0xCu);
        }
        int v54 = 4;
      }
      DWORD2(v175) = v54;
LABEL_157:
      BYTE12(v175) = 1;
      goto LABEL_158;
    }
    xpc_object_t v40 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        xpc_object_t v41 = (void *)a2;
      }
      else {
        xpc_object_t v41 = *(void **)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v41;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Call Disconnected because emergency calls over WiFi not allowed in this location; call uuid %s",
        buf,
        0xCu);
    }
    DWORD2(v175) = 0;
    BYTE12(v175) = 1;
    xpc_object_t v42 = (std::mutex *)Registry::getServiceMap((uint64_t *)1, *(Registry **)(a1 + 96));
    xpc_object_t v43 = v42;
    if (v44 < 0)
    {
      unsigned __int8 v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v46 = 5381;
      do
      {
        uint64_t v44 = v46;
        unsigned int v47 = *v45++;
        uint64_t v46 = (33 * v46) ^ v47;
      }
      while (v47);
    }
    std::mutex::lock(v42);
    *(void *)std::string buf = v44;
    CFDictionaryRef v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)buf);
    if (v48)
    {
      uint64_t v50 = v48[3];
      CFDictionaryRef v49 = (std::__shared_weak_count *)v48[4];
      if (v49)
      {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v43);
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v49);
        char v51 = 0;
        if (!v50)
        {
LABEL_136:
          if ((v51 & 1) == 0) {
            sub_10004D2C8(v49);
          }
          goto LABEL_158;
        }
LABEL_117:
        long long v57 = **(NSObject ***)(a1 + 720);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Displaying a pop-up", buf, 2u);
        }
        *(void *)long long v143 = 0;
        uint64_t v58 = kAlertDialogLocalizationTable;
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v50 + 40))(v143, v50, kAlertDialogLocalizationTable, @"CANCEL", @"Cancel");
        long long v134 = 0;
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v50 + 40))(&v134, v50, v58, @"COUNTRY_DISABLED_WIFI_EMERGENCY_CALL", @"Emergency Call Not Available in This Location");
        long long v133 = 0;
        long long v60 = (std::mutex *)Registry::getServiceMap(v59, *(Registry **)(a1 + 96));
        uint64_t v61 = v60;
        if (v62 < 0)
        {
          uint64_t v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v64 = 5381;
          do
          {
            uint64_t v62 = v64;
            unsigned int v65 = *v63++;
            uint64_t v64 = (33 * v64) ^ v65;
          }
          while (v65);
        }
        std::mutex::lock(v60);
        *(void *)std::string buf = v62;
        uint64_t v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
        if (v66)
        {
          uint64_t v68 = v66[3];
          uint64_t v67 = (std::__shared_weak_count *)v66[4];
          if (v67)
          {
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v61);
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v30 = v124;
            sub_10004D2C8(v67);
            char v69 = 0;
LABEL_133:
            (*(void (**)(uint64_t, const void *, const void *, void))(*(void *)v68 + 32))(v68, v134, v133, *(void *)v143);
            if ((v69 & 1) == 0) {
              sub_10004D2C8(v67);
            }
            sub_1000558F4(&v133);
            sub_1000558F4(&v134);
            sub_1000558F4((const void **)v143);
            goto LABEL_136;
          }
        }
        else
        {
          uint64_t v68 = 0;
        }
        std::mutex::unlock(v61);
        uint64_t v67 = 0;
        char v69 = 1;
        goto LABEL_133;
      }
    }
    else
    {
      uint64_t v50 = 0;
    }
    std::mutex::unlock(v43);
    CFDictionaryRef v49 = 0;
    char v51 = 1;
    if (!v50) {
      goto LABEL_136;
    }
    goto LABEL_117;
  }
  if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      xpc_object_t v34 = (void *)a2;
    }
    else {
      xpc_object_t v34 = *(void **)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Received Disconnect Event with unknown uuid: %s", buf, 0xCu);
  }
LABEL_186:
  sub_1002243E8((uint64_t)state);
  return sub_100687EB8((void **)&v140);
}

void sub_1009984B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *__p, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  sub_1002243E8((uint64_t)va);
  sub_1000558F4((const void **)&STACK[0x570]);
  STACK[0x5A0] = (unint64_t)&STACK[0x550];
  sub_1002244D8((void ***)&STACK[0x5A0]);
  sub_1002243E8((uint64_t)&STACK[0x740]);
  sub_100687EB8((void **)&STACK[0x568]);
  _Unwind_Resume(a1);
}

uint64_t sub_100998628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v16) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v20 = v16;
  }
  CFStringRef v18 = 0;
  if (SHIBYTE(v20) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v24 = v20;
  }
  CFStringRef v21 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v6 = v18;
    CFStringRef v18 = v21;
    CFStringRef v22 = v6;
    sub_1000558F4((const void **)&v22);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(*(void **)buf);
  }
  CFStringRef v7 = v18;
  CFStringRef v17 = v18;
  CFStringRef v18 = 0;
  sub_1000558F4((const void **)&v18);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  CFUUIDRef v8 = CFUUIDCreateFromString(kCFAllocatorDefault, v7);
  __p[0] = v8;
  uint64_t v9 = *(void *)(a1 + 128);
  CFUUIDRef v14 = v8;
  if (v8) {
    CFRetain(v8);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, CFUUIDRef *, uint64_t))(*(void *)v9 + 248))(v9, &v14, a3);
  sub_10012577C((const void **)&v14);
  if ((v10 & 1) == 0)
  {
    uint64_t v11 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        xpc_object_t v13 = (void *)a2;
      }
      else {
        xpc_object_t v13 = *(void **)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received notification with unknown UUID: %s", buf, 0xCu);
    }
  }
  sub_10012577C((const void **)__p);
  sub_1000558F4((const void **)&v17);
  return v10;
}

void sub_100998868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

const void **sub_1009988FC(uint64_t a1, uint64_t a2, void **a3, int a4)
{
  uint64_t v112 = 0;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v91 = 0u;
  memset(v90, 0, sizeof(v90));
  sub_10057F630((uint64_t)v90);
  char v8 = sub_100998628(a1, a2, (uint64_t)v90);
  uint64_t v9 = *(os_log_t **)(a1 + 720);
  uint64_t v10 = *v9;
  if (v8)
  {
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v11 = a2;
      }
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: EMERGENCY SESSION REQUIRED for %s (uuid)", buf, 0xCu);
    }
    DWORD2(v94) = 79;
    BYTE12(v94) = 1;
    char v12 = (uint64_t *)(v91 & 0xFFFFFFFE);
    if (v12 == 2)
    {
      xpc_object_t v13 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I EmergencySessionRequired for emergency call on IMS, redial over CS", buf, 2u);
      }
      uint64_t v14 = *(void *)(a1 + 128);
      sub_100245B5C((uint64_t)v89, (uint64_t)v90);
      (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v14 + 256))(v14, v89, 4);
      sub_1002243E8((uint64_t)v89);
      return sub_1002243E8((uint64_t)v90);
    }
    uint64_t v88 = 0;
    uint64_t v87 = 0;
    uint64_t v16 = (Registry **)(a1 + 96);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(a1 + 96));
    CFStringRef v18 = ServiceMap;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v19;
    xpc_object_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
LABEL_24:
    (*(void (**)(uint64_t))(*(void *)a1 + 256))(a1);
    PersonalityIdFromSlotIdEx();
    (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v25 + 40))(&v87, v25, buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if ((v26 & 1) == 0) {
      sub_10004D2C8(v24);
    }
    int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v87 + 280))(v87);
    xpc_object_t v28 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = *(char *)(a2 + 23);
      uint64_t v30 = *(void *)a2;
      uint64_t v31 = asString();
      int v32 = *((char *)a3 + 23);
      if (v29 >= 0) {
        uint64_t v33 = a2;
      }
      else {
        uint64_t v33 = v30;
      }
      xpc_object_t v34 = "false";
      xpc_object_t v35 = (void **)*a3;
      *(void *)&uint8_t buf[4] = v33;
      if (v27) {
        BOOL v36 = "true";
      }
      else {
        BOOL v36 = "false";
      }
      *(_DWORD *)std::string buf = 136316162;
      if (!a4) {
        xpc_object_t v34 = "true";
      }
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v31;
      if (v32 >= 0) {
        xpc_object_t v37 = a3;
      }
      else {
        xpc_object_t v37 = v35;
      }
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v36;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = v34;
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v37;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I EmergencySessionRequired for call %s. LTE bearer support: %s, Carrier allows undetected emergency on IMS: %s, Emergency contact available: %s, URN: %s", buf, 0x34u);
    }
    int v38 = *(_DWORD *)(a1 + 732);
    if (v38) {
      int v39 = v27;
    }
    else {
      int v39 = 0;
    }
    if (v38 == 2) {
      int v40 = v27;
    }
    else {
      int v40 = 0;
    }
    if (v40 == 1)
    {
      xpc_object_t v41 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        int v42 = *(unsigned __int8 *)(a1 + 740);
        uint64_t v43 = asString();
        uint64_t v44 = "true";
        if (!v42) {
          uint64_t v44 = "false";
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v44;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v43;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I EmergencySessionRequired with unknown LTE bearer support. Airplane Mode: %s, Registration Status: %s", buf, 0x16u);
      }
      if (*(unsigned char *)(a1 + 740)) {
        BOOL v45 = 1;
      }
      else {
        BOOL v45 = *(_DWORD *)(a1 + 744) == 1;
      }
      int v39 = v45;
    }
    memset(&__str, 0, sizeof(__str));
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 128) + 280))(&__str);
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (size < 7) {
      goto LABEL_106;
    }
    std::string::size_type v73 = size;
    unsigned int v47 = (std::mutex *)Registry::getServiceMap((uint64_t *)size, *v16);
    CFDictionaryRef v48 = v47;
    if (v49 < 0)
    {
      uint64_t v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v51 = 5381;
      do
      {
        uint64_t v49 = v51;
        unsigned int v52 = *v50++;
        uint64_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v47);
    *(void *)std::string buf = v49;
    long long v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
    if (v53)
    {
      uint64_t v55 = v53[3];
      int v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v48);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v16 = (Registry **)(a1 + 96);
        sub_10004D2C8(v54);
        char v56 = 0;
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    std::mutex::unlock(v48);
    int v54 = 0;
    char v56 = 1;
LABEL_69:
    int v57 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 16))(v55);
    if ((v56 & 1) == 0) {
      sub_10004D2C8(v54);
    }
    if (!v57) {
      goto LABEL_102;
    }
    memset(&buf[8], 0, 48);
    long long v120 = 0u;
    long long v119 = 0u;
    memset(&v117, 0, sizeof(v117));
    long long v116 = 0u;
    unint64_t v118 = 23;
    qmemcpy(&buf[23], "\tCall", 5);
    qmemcpy(buf, "Telephony", 9);
    buf[47] = 4;
    sub_10003ECB8((std::string *)&buf[48], "Suspicious SIP 380 Emergency Redirect Number", 0x2CuLL);
    std::string::operator=(&v117, &__str);
    unint64_t v118 = v118 & 0xFFFFFFFFFFFFFFE8 | 1;
    uint64_t v58 = (std::mutex *)Registry::getServiceMap((uint64_t *)v118, *v16);
    long long v59 = v58;
    if ((v60 & 0x8000000000000000) != 0)
    {
      uint64_t v61 = (unsigned __int8 *)(v60 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v62 = 5381;
      do
      {
        unint64_t v60 = v62;
        unsigned int v63 = *v61++;
        uint64_t v62 = (33 * v62) ^ v63;
      }
      while (v63);
    }
    std::mutex::lock(v58);
    unint64_t v113 = v60;
    uint64_t v64 = sub_10004D37C(&v59[1].__m_.__sig, &v113);
    if (v64)
    {
      uint64_t v66 = v64[3];
      unsigned int v65 = (std::__shared_weak_count *)v64[4];
      if (v65)
      {
        atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v59);
        atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v65);
        char v67 = 0;
LABEL_80:
        sub_1000DB86C((char *)__dst, (long long *)buf);
        v114[3] = 0;
        (*(void (**)(uint64_t, void **, void *))(*(void *)v66 + 16))(v66, __dst, v114);
        sub_1000DBADC(v114);
        if (v85 < 0) {
          operator delete(__p);
        }
        if (v83 < 0) {
          operator delete(v82);
        }
        if (v81 < 0) {
          operator delete(v80);
        }
        if (v79 < 0) {
          operator delete(v78);
        }
        if (v77 < 0) {
          operator delete(__dst[0]);
        }
        if ((v67 & 1) == 0) {
          sub_10004D2C8(v65);
        }
        if (SBYTE7(v120) < 0) {
          operator delete((void *)v119);
        }
        if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v117.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v116) < 0) {
          operator delete(*(void **)&buf[48]);
        }
        if ((buf[47] & 0x80000000) != 0) {
          operator delete(*(void **)&buf[24]);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
LABEL_102:
        if ((*(unsigned int (**)(uint64_t))(*(void *)v87 + 288))(v87))
        {
          uint64_t v68 = **(NSObject ***)(a1 + 720);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134218240;
            *(void *)&uint8_t buf[4] = v73;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = 6;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I EmergencySessionRequired for suspicious number with %zu > %zu digits", buf, 0x16u);
          }
          (*(void (**)(void, unsigned char *, uint64_t))(**(void **)(a1 + 128) + 304))(*(void *)(a1 + 128), v90, 1);
        }
LABEL_106:
        if (v39)
        {
          (*(void (**)(void, unsigned char *, uint64_t))(**(void **)(a1 + 128) + 264))(*(void *)(a1 + 128), v90, 2);
        }
        else
        {
          if (a4)
          {
            uint64_t v69 = *(void *)(a1 + 128);
            sub_100245B5C((uint64_t)v75, (uint64_t)v90);
            uint64_t v70 = v75;
            (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v69 + 256))(v69, v75, 8);
          }
          else
          {
            LODWORD(v93) = sub_10094F79C(a3);
            uint64_t v71 = *(void *)(a1 + 128);
            sub_100245B5C((uint64_t)v74, (uint64_t)v90);
            uint64_t v70 = v74;
            (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v71 + 256))(v71, v74, 7);
          }
          sub_1002243E8((uint64_t)v70);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (v88) {
          sub_10004D2C8(v88);
        }
        return sub_1002243E8((uint64_t)v90);
      }
    }
    else
    {
      uint64_t v66 = 0;
    }
    std::mutex::unlock(v59);
    unsigned int v65 = 0;
    char v67 = 1;
    goto LABEL_80;
  }
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "EmergencySessionRequired failed: unknown uuid %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v90);
}

void sub_10099938C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  if (SLOBYTE(STACK[0x3D7]) < 0) {
    operator delete((void *)STACK[0x3C0]);
  }
  if (STACK[0x3E0]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x3E0]);
  }
  sub_1002243E8((uint64_t)&STACK[0x580]);
  _Unwind_Resume(a1);
}

const void **sub_1009994AC(uint64_t a1, uint64_t a2)
{
  uint64_t v70 = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v47 = 0u;
  memset(v46, 0, sizeof(v46));
  sub_10057F630((uint64_t)v46);
  char v4 = sub_100998628(a1, a2, (uint64_t)v46);
  long long v5 = *(os_log_t **)(a1 + 720);
  CFStringRef v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = HIDWORD(v50);
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: ACTIVE for %s (callId: %u)", buf, 0x12u);
    }
    if ((sub_100998628(a1, a2, (uint64_t)v46) & 1) == 0)
    {
      char v8 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = HIDWORD(v50);
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received kCallStatusActive with unknown id: %u", buf, 8u);
      }
    }
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 240))(&v43);
    uint64_t v9 = v43;
    uint64_t v10 = v44;
    if (v44 == v43)
    {
      BOOL v14 = 0;
    }
    else
    {
      do
      {
        uint64_t v95 = 0;
        long long v93 = 0u;
        long long v94 = 0u;
        long long v91 = 0u;
        long long v92 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v72 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_100245B5C((uint64_t)buf, v9);
        int v11 = HIDWORD(v75);
        int v12 = HIDWORD(v50);
        sub_1002243E8((uint64_t)buf);
        BOOL v13 = v11 == v12;
        BOOL v14 = v11 == v12;
        if (v13) {
          break;
        }
        v9 += 408;
      }
      while (v9 != v10);
    }
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 216))(&v40);
    uint64_t v16 = v40;
    uint64_t v17 = v41;
    if (v41 == v40)
    {
      BOOL v20 = 0;
    }
    else
    {
      do
      {
        uint64_t v95 = 0;
        long long v93 = 0u;
        long long v94 = 0u;
        long long v91 = 0u;
        long long v92 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v72 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_100245B5C((uint64_t)buf, v16);
        int v18 = HIDWORD(v75);
        int v19 = HIDWORD(v50);
        sub_1002243E8((uint64_t)buf);
        BOOL v13 = v18 == v19;
        BOOL v20 = v18 == v19;
        if (v13) {
          break;
        }
        v16 += 408;
      }
      while (v16 != v17);
    }
    (*(void (**)(void, _OWORD *, uint64_t))(**(void **)(a1 + 128) + 288))(*(void *)(a1 + 128), v46, 1);
    (*(void (**)(void, _OWORD *, uint64_t))(**(void **)(a1 + 128) + 64))(*(void *)(a1 + 128), v46, 1);
    uint64_t v21 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Call type of the active call: %s", buf, 0xCu);
    }
    if (BYTE4(v49) == 2)
    {
      uint64_t v23 = *(void *)(a1 + 128);
      *(_DWORD *)std::string buf = 0;
      uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
      (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v23 + 320))(v23, buf, v24);
    }
    if (v14 || v20) {
      goto LABEL_46;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(v14 | v20), *(Registry **)(a1 + 96));
    char v26 = ServiceMap;
    if (v27 < 0)
    {
      xpc_object_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v27;
    uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      int v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
        if (!v33)
        {
LABEL_44:
          if ((v34 & 1) == 0) {
            sub_10004D2C8(v32);
          }
LABEL_46:
          *(void *)std::string buf = &v40;
          sub_1002244D8((void ***)buf);
          *(void *)std::string buf = &v43;
          sub_1002244D8((void ***)buf);
          return sub_1002243E8((uint64_t)v46);
        }
LABEL_39:
        int v35 = DWORD2(v49);
        uint64_t v36 = HIDWORD(v60);
        if (SBYTE7(v48) < 0)
        {
          sub_10004FC84(__p, (void *)v47, *((unint64_t *)&v47 + 1));
        }
        else
        {
          *(_OWORD *)std::string __p = v47;
          uint64_t v39 = v48;
        }
        (*(void (**)(uint64_t, uint64_t, void **, void, BOOL))(*(void *)v33 + 192))(v33, v36, __p, HIDWORD(v50), v35 == 1);
        if (SHIBYTE(v39) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_44;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    int v32 = 0;
    char v34 = 1;
    if (!v33) {
      goto LABEL_44;
    }
    goto LABEL_39;
  }
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received ACTIVE indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v46);
}

void sub_100999AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if ((v72 & 1) == 0) {
    sub_10004D2C8(v71);
  }
  a71 = (uint64_t)&a13;
  sub_1002244D8((void ***)&a71);
  a71 = (uint64_t)&a16;
  sub_1002244D8((void ***)&a71);
  sub_1002243E8((uint64_t)&a19);
  _Unwind_Resume(a1);
}

const void **sub_100999B44(void **a1, uint64_t a2)
{
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  sub_10057F630((uint64_t)v15);
  if (!sub_100998628((uint64_t)a1, a2, (uint64_t)v15)) {
    goto LABEL_22;
  }
  *(_OWORD *)std::string buf = 0uLL;
  ((void (*)(uint8_t *__return_ptr, void **, uint64_t))(*a1)[59])(buf, a1, a2);
  char v4 = *(const void **)buf;
  if (*(void *)buf)
  {
    {
      long long v5 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
LABEL_5:
        BOOL v6 = 1;
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v5);
        goto LABEL_13;
      }
      BOOL v6 = 1;
    }
    else
    {
      if (v8)
      {
        long long v5 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]) {
          goto LABEL_5;
        }
      }
      BOOL v6 = v8 != 0;
    }
  }
  else
  {
    uint64_t v7 = *a1[90];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v14 = a2;
      }
      else {
        uint64_t v14 = *(void *)a2;
      }
      *(_DWORD *)uint64_t v17 = 136315138;
      uint64_t v18 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "IMS call with uuid %s does not exist!", v17, 0xCu);
    }
    BOOL v6 = 0;
  }
LABEL_13:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v6)
  {
    uint64_t v9 = *a1[90];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: HOLD for %s", buf, 0xCu);
    }
    (*(void (**)(void *, _OWORD *))(*a1[16] + 128))(a1[16], v15);
    return sub_1002243E8((uint64_t)v15);
  }
LABEL_22:
  int v11 = *a1[90];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v13 = a2;
    }
    else {
      uint64_t v13 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received HOLD indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v15);
}

void sub_100999E74(_Unwind_Exception *exception_object)
{
}

const void **sub_100999E90(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  long long v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: TRYING for %s. Ignoring.", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received TRYING indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099A00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void **sub_10099A028(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  long long v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: RINGING (Alerting) for %s", buf, 0xCu);
    }
    (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 48))(*(void *)(a1 + 128), v10);
  }
  else if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received RINGING indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099A1D8(_Unwind_Exception *exception_object)
{
}

const void **sub_10099A1F4(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  long long v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: CONFERENCE for %s", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received CONFERENCE indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099A370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void **sub_10099A38C(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  long long v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: SESSION PROGRESS for %s", buf, 0xCu);
    }
    (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 56))(*(void *)(a1 + 128), v10);
  }
  else if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received SESSION PROGRESS indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099A53C(_Unwind_Exception *exception_object)
{
}

const void **sub_10099A558(uint64_t a1, uint64_t a2)
{
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  memset(v29, 0, sizeof(v29));
  sub_10057F630((uint64_t)v29);
  if (sub_100998628(a1, a2, (uint64_t)v29))
  {
    char v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), HIDWORD(v30));
    long long v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: TEXT STREAM DETECTED for %s", (uint8_t *)&buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 96));
    uint64_t v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16) {
          goto LABEL_13;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16)
    {
LABEL_13:
      uint64_t v18 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N SystemDeterminationManager is not found", (uint8_t *)&buf, 2u);
      }
LABEL_40:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      return sub_1002243E8((uint64_t)v29);
    }
LABEL_22:
    uint64_t v27 = 0;
    xpc_object_t v28 = 0;
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 248))(&buf, a1);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, long long *))(*(void *)v16 + 40))(&v27, v16, &buf);
    if ((char)v44 < 0) {
      operator delete((void *)buf);
    }
    if (v27)
    {
      if ((*(uint64_t (**)(uint64_t))(*(void *)v27 + 88))(v27))
      {
        (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 176))(*(void *)(a1 + 128), v29);
      }
      else
      {
        uint64_t v25 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Carrier does not support TTY over IMS. Ignoring IMS Text Stream Detected indication.", (uint8_t *)&buf, 2u);
        }
      }
    }
    else
    {
      uint64_t v21 = *v4;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 248))(&buf, a1);
        uint64_t v22 = v44;
        if ((v44 & 0x80u) == 0)
        {
          p_long long buf = (const char *)&buf;
        }
        else
        {
          uint64_t v22 = *((void *)&buf + 1);
          p_long long buf = (const char *)buf;
        }
        uint64_t v24 = v22 ? (char *)p_buf : "<invalid>";
        *(_DWORD *)uint64_t v41 = 136315138;
        uint64_t v42 = v24;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N IMS Config can't be found. PersonalityID: [%s]", v41, 0xCu);
        if ((char)v44 < 0) {
          operator delete((void *)buf);
        }
      }
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    goto LABEL_40;
  }
  int v19 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v20 = a2;
    }
    else {
      uint64_t v20 = *(void *)a2;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v20;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Received Text Media Detected Event with unknown uuid: %s", (uint8_t *)&buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v29);
}

void sub_10099A9D0(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va, a3);
  if (a3) {
    sub_10004D2C8(a3);
  }
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_10099AA48(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  sub_10057F630((uint64_t)v13);
  char v6 = sub_100998628(a1, a2, (uint64_t)v13);
  uint64_t v7 = *(os_log_t **)(a1 + 720);
  char v8 = *v7;
  if (v6)
  {
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = "HELD";
      if (a3) {
        uint64_t v9 = "RESUMED";
      }
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      char v26 = v9;
      __int16 v27 = 2080;
      uint64_t v28 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: TEXT MEDIA REMOTE DIRECTION DETECTED (%s) for %s", buf, 0x16u);
    }
    WORD4(v14) = a3 ^ 1 | 0x100;
    (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 192))(*(void *)(a1 + 128), v13);
  }
  else if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v12 = a2;
    }
    else {
      uint64_t v12 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    char v26 = (const char *)v12;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Received Text Media Detected Event with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v13);
}

void sub_10099AC2C(_Unwind_Exception *exception_object)
{
}

const void **sub_10099AC48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 128);
  sub_101328DA4(a2, (CFUUIDRef *)&v6);
  (*(void (**)(uint64_t, uint64_t, const void **, uint64_t))(*(void *)v4 + 200))(v4, 1, &v6, a3);
  return sub_10012577C(&v6);
}

void sub_10099ACBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10099ACD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 128);
  sub_101328DA4(a2, (CFUUIDRef *)&v6);
  (*(void (**)(uint64_t, void, const void **, uint64_t))(*(void *)v4 + 200))(v4, 0, &v6, a3);
  return sub_10012577C(&v6);
}

void sub_10099AD44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10099AD58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 24))();
}

const void **sub_10099AD80(uint64_t a1, uint64_t a2, CFArrayRef *a3)
{
  uint64_t result = (const void **)_os_feature_enabled_impl();
  if (result)
  {
    uint64_t v33 = 0;
    memset(v32, 0, sizeof(v32));
    sub_10057F630((uint64_t)v32);
    if (sub_100998628(a1, a2, (uint64_t)v32))
    {
      CFArrayRef v7 = *a3;
      if (*a3) {
        char v8 = sub_100083F10;
      }
      else {
        char v8 = 0;
      }
      uint64_t v9 = **(NSObject ***)(a1 + 720);
      if (v8)
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v10 = a2;
          }
          else {
            uint64_t v10 = *(void *)a2;
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v10;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v7;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: AUDIO STREAM TOKENS for UUID %s: %@", buf, 0x16u);
          CFArrayRef v7 = *a3;
        }
        memset(buf, 0, sizeof(buf));
        CFIndex Count = CFArrayGetCount(v7);
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            long long v31 = 0;
            CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(*a3, i);
            sub_1000842D0(&v31, &ValueAtIndex);
            if (v31) {
              long long v14 = sub_100081E58;
            }
            else {
              long long v14 = 0;
            }
            if (v14)
            {
              LODWORD(ValueAtIndex) = 0;
              ctu::cf::assign((ctu::cf *)&ValueAtIndex, v31, v13);
              long long v15 = *(char **)&buf[8];
              if (*(void *)&buf[8] >= *(void *)&buf[16])
              {
                long long v17 = *(char **)buf;
                uint64_t v18 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 2;
                unint64_t v19 = v18 + 1;
                if ((unint64_t)(v18 + 1) >> 62) {
                  sub_10006A748();
                }
                uint64_t v20 = *(void *)&buf[16] - *(void *)buf;
                if ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 1 > v19) {
                  unint64_t v19 = v20 >> 1;
                }
                if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v21 = v19;
                }
                if (v21)
                {
                  long long v22 = (char *)sub_10005ECD8((uint64_t)&buf[16], v21);
                  long long v17 = *(char **)buf;
                  long long v15 = *(char **)&buf[8];
                }
                else
                {
                  long long v22 = 0;
                }
                long long v23 = &v22[4 * v18];
                *(_DWORD *)long long v23 = ValueAtIndex;
                long long v16 = v23 + 4;
                while (v15 != v17)
                {
                  int v24 = *((_DWORD *)v15 - 1);
                  v15 -= 4;
                  *((_DWORD *)v23 - 1) = v24;
                  v23 -= 4;
                }
                *(void *)long long buf = v23;
                *(void *)&uint8_t buf[8] = v16;
                *(void *)&uint8_t buf[16] = &v22[4 * v21];
                if (v17) {
                  operator delete(v17);
                }
              }
              else
              {
                **(_DWORD **)&uint8_t buf[8] = ValueAtIndex;
                long long v16 = v15 + 4;
              }
              *(void *)&uint8_t buf[8] = v16;
            }
            sub_1000570E8((const void **)&v31);
          }
        }
        sub_10099B178((uint64_t)&v32[13] + 8, (uint64_t)buf);
        (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 160))(*(void *)(a1 + 128), v32);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        return sub_1002243E8((uint64_t)v32);
      }
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        return sub_1002243E8((uint64_t)v32);
      }
      *(_WORD *)long long buf = 0;
      __int16 v27 = "Received Audio Stream Tokens Event with null tokens";
      uint64_t v28 = v9;
      uint32_t v29 = 2;
    }
    else
    {
      uint64_t v25 = **(NSObject ***)(a1 + 720);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        return sub_1002243E8((uint64_t)v32);
      }
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v26 = a2;
      }
      else {
        uint64_t v26 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v26;
      __int16 v27 = "Received Audio Stream Tokens Event with unknown uuid: %s";
      uint64_t v28 = v25;
      uint32_t v29 = 12;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
    return sub_1002243E8((uint64_t)v32);
  }
  return result;
}

void sub_10099B128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  long long v5 = *(void **)(v3 - 112);
  if (v5)
  {
    *(void *)(v3 - 104) = v5;
    operator delete(v5);
  }
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10099B178(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if (a1 != a2) {
      sub_10008A534((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100245E90((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

const void **sub_10099B1F0(uint64_t a1, uint64_t a2, unsigned int **a3)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  sub_10057F630((uint64_t)v13);
  if (sub_100998628(a1, a2, (uint64_t)v13))
  {
    int v12 = 0;
    ctu::cf::assign((ctu::cf *)&v12, *a3, v6);
    CFArrayRef v7 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v8 = a2;
      }
      else {
        uint64_t v8 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v29 = v8;
      __int16 v30 = 1024;
      int v31 = v12;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: TEXT STREAM TOKEN for UUID %s: %u", buf, 0x12u);
    }
    HIDWORD(v14) = v12;
    LOBYTE(v15) = 1;
    (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 168))(*(void *)(a1 + 128), v13);
  }
  else
  {
    uint64_t v9 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v11 = a2;
      }
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v29 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Received Text Stream Token Event with unknown uuid: %s", buf, 0xCu);
    }
  }
  return sub_1002243E8((uint64_t)v13);
}

void sub_10099B3E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10099B400(void **a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3)
  {
    uint64_t v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    memset(v10, 0, sizeof(v10));
    sub_10057F630((uint64_t)v10);
    if (sub_100998628((uint64_t)a1, a2, (uint64_t)v10))
    {
      long long v5 = *(NSObject **)(*(uint64_t (**)(void *, void))(*a1[10] + 16))(a1[10], HIDWORD(v11));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v6 = a2;
        }
        else {
          uint64_t v6 = *(void *)a2;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v23 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: TEXT MEDIA DEACTIVATED (RTT NEGOTIATION FAILED) for %s", buf, 0xCu);
      }
      (*(void (**)(void *, _OWORD *))(*a1[16] + 184))(a1[16], v10);
    }
    else
    {
      uint64_t v8 = *a1[90];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v9 = a2;
        }
        else {
          uint64_t v9 = *(void *)a2;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v23 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Received Text Media Deactivated event with unknown UUID: %s. Ignoring.", buf, 0xCu);
      }
    }
    sub_1002243E8((uint64_t)v10);
  }
  else
  {
    CFArrayRef v7 = *a1[90];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid UUID. Ignoring Text Media Deactivated event.", (uint8_t *)v10, 2u);
    }
  }
}

void sub_10099B63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void **sub_10099B65C(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  sub_10057F630((uint64_t)v20);
  uint64_t v4 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: PROCEEDING for %s.", buf, 0xCu);
  }
  uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  if (v6)
  {
    uint64_t v8 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)a2;
      if (v7 >= 0) {
        uint64_t v9 = a2;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = HIDWORD(v21);
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Dialing Call with UUID: %s, call uuid: %u", buf, 0x12u);
    }
    if (sub_100998628(a1, a2, (uint64_t)v20))
    {
      unsigned __int8 v10 = *(unsigned char *)(a1 + 160) + 1;
      *(unsigned char *)(a1 + 160) = v10;
      HIDWORD(v21) = v10;
      (*(void (**)(void, _OWORD *))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v20);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 1174405120;
      v18[2] = sub_10099B9E4;
      uint64_t v18[3] = &unk_101A22A78;
      _OWORD v18[4] = a1;
      sub_100245B5C((uint64_t)v19, (uint64_t)v20);
      long long v11 = *(std::__shared_weak_count **)(a1 + 48);
      if (!v11 || (uint64_t v12 = *(void *)(a1 + 40), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
        sub_100088B9C();
      }
      long long v14 = v13;
      long long v15 = *(NSObject **)(a1 + 56);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_1009A3B38;
      uint64_t v43 = &unk_101A22C18;
      uint64_t v45 = v12;
      uint64_t v46 = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      unsigned __int8 v44 = v18;
      dispatch_async(v15, buf);
      if (v46) {
        sub_10004D2C8(v46);
      }
      sub_10004D2C8(v14);
      sub_1002243E8((uint64_t)v19);
    }
    else
    {
      long long v16 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I PROCEEDING for STK call", buf, 2u);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 464))(a1, a2);
    }
  }
  return sub_1002243E8((uint64_t)v20);
}

void sub_10099B9B8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10099B9E4(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 32) + 128) + 24))(*(void *)(*(void *)(a1 + 32) + 128), a1 + 40);
}

uint64_t sub_10099BA18(uint64_t a1, uint64_t a2)
{
  return sub_100245B5C(a1 + 40, a2 + 40);
}

const void **sub_10099BA24(uint64_t a1)
{
  return sub_1002243E8(a1 + 40);
}

void sub_10099BA2C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 184))
  {
    uint64_t v45 = 0;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    uint64_t v4 = *(void *)(a1 + 176) + 16;
    *(_OWORD *)long long buf = 0u;
    sub_100245B5C((uint64_t)buf, v4);
    uint64_t v5 = *(uint64_t **)(a1 + 176);
    uint64_t v6 = *v5;
    *(void *)(v6 + 8) = v5[1];
    *(void *)v5[1] = v6;
    --*(void *)(a1 + 184);
    sub_1002243E8((uint64_t)(v5 + 2));
    operator delete(v5);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a2;
      uint64_t v18 = *(void *)(a2 + 16);
    }
    toUuid();
    block[0] = *(const void **)buf;
    uint64_t v8 = v19;
    long long v19 = 0;
    *(void *)long long buf = v8;
    sub_10012577C(block);
    sub_10012577C(&v19);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
    unsigned __int8 v9 = *(unsigned char *)(a1 + 160) + 1;
    *(unsigned char *)(a1 + 160) = v9;
    HIDWORD(v25) = v9;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 1174405120;
    v15[2] = sub_10099BCE0;
    v15[3] = &unk_101A22AA8;
    v15[4] = a1;
    sub_100245B5C((uint64_t)v16, (uint64_t)buf);
    unsigned __int8 v10 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v10 || (v11 = *(const void **)(a1 + 40), (uint64_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    long long v13 = v12;
    long long v14 = *(NSObject **)(a1 + 56);
    block[0] = _NSConcreteStackBlock;
    block[1] = (const void *)1174405120;
    block[2] = sub_1009A3B38;
    block[3] = &unk_101A22C18;
    block[5] = v11;
    long long v47 = v13;
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    block[4] = v15;
    dispatch_async(v14, block);
    if (v47) {
      sub_10004D2C8(v47);
    }
    sub_10004D2C8(v13);
    sub_1002243E8((uint64_t)v16);
    sub_1002243E8((uint64_t)buf);
  }
  else
  {
    int v7 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "IMSCallModel::handleDialBBCallResponse, the BBDialed call queue is empty", buf, 2u);
    }
  }
}

void sub_10099BCAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1002243E8((uint64_t)&a69);
  _Unwind_Resume(a1);
}

uint64_t sub_10099BCE0(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 32) + 128) + 24))(*(void *)(*(void *)(a1 + 32) + 128), a1 + 40);
}

const void **sub_10099BD14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  sub_10057F630((uint64_t)v16);
  char v6 = sub_100998628(a1, a2, (uint64_t)v16);
  int v7 = *(os_log_t **)(a1 + 720);
  uint64_t v8 = *v7;
  if (v6)
  {
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v9 = "INACTIVE";
      if (a3) {
        unsigned __int8 v9 = "ACTIVE";
      }
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: MEDIA %s for %s", buf, 0x16u);
    }
    uint64_t v46 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_10057F630((uint64_t)buf);
    if (sub_100998628(a1, a2, (uint64_t)buf))
    {
      (*(void (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 128) + 112))(*(void *)(a1 + 128), buf, a3);
    }
    else
    {
      uint64_t v12 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        long long v14 = "false";
        if (a3) {
          long long v14 = "true";
        }
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v15 = a2;
        }
        else {
          uint64_t v15 = *(void *)a2;
        }
        *(_DWORD *)uint64_t v18 = 136315394;
        long long v19 = v14;
        __int16 v20 = 2080;
        uint64_t v21 = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Received call media status %s, with unknown uuid %s", v18, 0x16u);
      }
    }
    sub_1002243E8((uint64_t)buf);
  }
  else if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Received Media Status Event with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v16);
}

void sub_10099BFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1002243E8((uint64_t)&a65);
  sub_1002243E8((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const void **sub_10099C000(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  sub_10057F630((uint64_t)v15);
  if (sub_100998628(a1, a2, (uint64_t)v15))
  {
    char v6 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v8 = a2;
      }
      else {
        uint64_t v8 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: %s RBT for %s", buf, 0x16u);
    }
    uint64_t v45 = 0;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_10057F630((uint64_t)buf);
    if (sub_100998628(a1, a2, (uint64_t)buf))
    {
      (*(void (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 128) + 104))(*(void *)(a1 + 128), buf, a3);
    }
    else
    {
      uint64_t v11 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = asString();
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = *(void *)a2;
        }
        *(_DWORD *)uint64_t v17 = 136315394;
        uint64_t v18 = v13;
        __int16 v19 = 2080;
        uint64_t v20 = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received %s RBT with unknown id: %s", v17, 0x16u);
      }
    }
    sub_1002243E8((uint64_t)buf);
  }
  else
  {
    unsigned __int8 v9 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Received RingbackTone Event with unknown uuid: %s", buf, 0xCu);
    }
  }
  return sub_1002243E8((uint64_t)v15);
}

void sub_10099C2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1002243E8((uint64_t)&a65);
  sub_1002243E8((uint64_t)&a9);
  _Unwind_Resume(a1);
}

const void **sub_10099C2D8(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  uint64_t v5 = **(NSObject ***)(a1 + 720);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  if (v4)
  {
    if (v6)
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v8 = a2;
      }
      else {
        uint64_t v8 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v13 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "-------->IMS Incoming Indication: HOLD FAILED for %s", buf, 0xCu);
    }
    (*(void (**)(void))(**(void **)(a1 + 128) + 152))(*(void *)(a1 + 128));
  }
  else if (v6)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Received HOLD FAILED indication with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099C480(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10099C49C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104))();
}

const void **sub_10099C4C0(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  sub_10057F630((uint64_t)v10);
  char v4 = sub_100998628(a1, a2, (uint64_t)v10);
  uint64_t v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v4)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: ACKNOWLEDGED for uuid: %s", buf, 0xCu);
    }
    (*(void (**)(void, _OWORD *, uint64_t))(**(void **)(a1 + 128) + 288))(*(void *)(a1 + 128), v10, 2);
  }
  else if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Received handleAcknowledgedEvent with unknown uuid: %s", buf, 0xCu);
  }
  return sub_1002243E8((uint64_t)v10);
}

void sub_10099C67C(_Unwind_Exception *exception_object)
{
}

const void **sub_10099C698(void **a1, uint64_t a2)
{
  char v4 = *a1[90];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: MEDIA INITIALIZED for uuid: %s", buf, 0xCu);
  }
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_10057F630((uint64_t)buf);
  if (sub_100998628((uint64_t)a1, a2, (uint64_t)buf))
  {
    (*(void (**)(void *, uint8_t *))(*a1[18] + 40))(a1[18], buf);
    (*(void (**)(void *, uint8_t *))(*a1[16] + 32))(a1[16], buf);
  }
  else
  {
    BOOL v6 = *a1[90];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Media initialized for unknown UUID. Ignoring.", v8, 2u);
    }
  }
  return sub_1002243E8((uint64_t)buf);
}

void sub_10099C854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

unsigned __int8 *sub_10099C870(uint64_t a1, uint64_t a2)
{
  char v4 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(void *)a2;
    }
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: THUMPER CALL %s REGISTERED", (uint8_t *)&v7, 0xCu);
  }
  return sub_1009A3B74(a1 + 192, (unsigned __int8 *)a2, a2);
}

void sub_10099C93C(uint64_t a1, unsigned __int8 *a2)
{
  char v4 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2[23] & 0x80u) == 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(unsigned __int8 **)a2;
    }
    LODWORD(v17) = 136315138;
    *(void *)((char *)&v17 + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: THUMPER CALL %s DEREGISTERED", (uint8_t *)&v17, 0xCu);
  }
  BOOL v6 = (void *)(a1 + 192);
  int v7 = sub_1003DDE88((void *)(a1 + 192), a2);
  if (v7)
  {
    int8x8_t v8 = *(int8x8_t *)(a1 + 200);
    uint64_t v9 = *(void **)v7;
    unint64_t v10 = *((void *)v7 + 1);
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v8);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      if (v10 >= *(void *)&v8) {
        v10 %= *(void *)&v8;
      }
    }
    else
    {
      v10 &= *(void *)&v8 - 1;
    }
    long long v12 = *(unsigned __int8 **)(*v6 + 8 * v10);
    do
    {
      long long v13 = v12;
      long long v12 = *(unsigned __int8 **)v12;
    }
    while (v12 != v7);
    if (v13 == (unsigned __int8 *)(a1 + 208)) {
      goto LABEL_24;
    }
    unint64_t v14 = *((void *)v13 + 1);
    if (v11.u32[0] > 1uLL)
    {
      if (v14 >= *(void *)&v8) {
        v14 %= *(void *)&v8;
      }
    }
    else
    {
      v14 &= *(void *)&v8 - 1;
    }
    if (v14 != v10)
    {
LABEL_24:
      if (v9)
      {
        unint64_t v15 = v9[1];
        if (v11.u32[0] > 1uLL)
        {
          unint64_t v16 = v9[1];
          if (v15 >= *(void *)&v8) {
            unint64_t v16 = v15 % *(void *)&v8;
          }
        }
        else
        {
          unint64_t v16 = v15 & (*(void *)&v8 - 1);
        }
        if (v16 == v10) {
          goto LABEL_28;
        }
      }
      *(void *)(*v6 + 8 * v10) = 0;
      uint64_t v9 = *(void **)v7;
    }
    if (!v9)
    {
LABEL_34:
      *(void *)long long v13 = v9;
      *(void *)int v7 = 0;
      --*(void *)(a1 + 216);
      char v18 = 1;
      *(void *)&long long v17 = 0;
      *((void *)&v17 + 1) = a1 + 208;
      sub_1009A3EB0((uint64_t)&v17 + 8, (void **)v7);
      return;
    }
    unint64_t v15 = v9[1];
LABEL_28:
    if (v11.u32[0] > 1uLL)
    {
      if (v15 >= *(void *)&v8) {
        v15 %= *(void *)&v8;
      }
    }
    else
    {
      v15 &= *(void *)&v8 - 1;
    }
    if (v15 != v10)
    {
      *(void *)(*v6 + 8 * v15) = v13;
      uint64_t v9 = *(void **)v7;
    }
    goto LABEL_34;
  }
}

void **sub_10099CB4C(uint64_t a1, uint64_t a2)
{
  BOOL v6 = _os_activity_create((void *)&_mh_execute_header, "Call: Incoming", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v6, &state);
  os_activity_scope_leave(&state);
  if (a2) {
    operator new();
  }
  char v4 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(state.opaque[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Received INCOMING Indication with a NULL call handle!", (uint8_t *)&state, 2u);
  }
  return sub_100687EB8((void **)&v6);
}

void sub_10099DA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  sub_1000577C4(&a18);
  sub_1002243E8((uint64_t)&a47);
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  sub_10004D2C8(v47);
  sub_10004D2C8(v47);
  sub_100687EB8(&a37);
  _Unwind_Resume(a1);
}

void sub_10099DBF0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v6 = (std::__shared_weak_count *)a3[1];
  uint64_t v121 = *a3;
  uint64_t v122 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)a1 + 312))(a1, &v121, 1, 0);
  if (v122) {
    sub_10004D2C8(v122);
  }
  int v7 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a2 + 8);
    if (*(char *)(a2 + 31) >= 0) {
      uint64_t v8 = a2 + 8;
    }
    uint64_t v9 = *(void *)(a2 + 272);
    if (*(char *)(a2 + 295) >= 0) {
      uint64_t v9 = a2 + 272;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Branded call company name is %s, company image url is %{public}s", buf, 0x16u);
  }
  [(objc_class *)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.BrandedCalling.callreceived" bundleIdentifier:@"com.apple.CommCenter.BrandedCalling" completionHandler:&stru_101A0BE60];
  uint8x8_t v11 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v11 || (long long v12 = *(std::__shared_weak_count **)(a1 + 40), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v14 = v13;
  p_shared_weak_owners = &v13->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  long long v133 = 0u;
  long long v134 = 0u;
  v90[0] = v12;
  v90[1] = v14;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_100245B5C((uint64_t)&v91, a2);
  uint64_t v16 = a3[1];
  *(void *)&long long v120 = *a3;
  *((void *)&v120 + 1) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)&v134 + 1) = 0;
  long long v17 = (char *)operator new(0x1C0uLL);
  *(void *)long long v17 = off_101A22CD0;
  *(_OWORD *)(v17 + 8) = *(_OWORD *)v90;
  v90[0] = 0;
  v90[1] = 0;
  uint64_t v18 = v93;
  *((void *)v17 + 3) = v91;
  long long v19 = v92;
  uint64_t v91 = 0;
  *(void *)&long long v92 = 0;
  *((_OWORD *)v17 + 2) = v19;
  *((void *)v17 + 6) = v18;
  *((void *)&v92 + 1) = 0;
  uint64_t v93 = 0;
  *((void *)v17 + 9) = v95;
  *(_OWORD *)(v17 + 56) = v94;
  long long v94 = 0uLL;
  long long v20 = v96;
  long long v21 = v97;
  long long v22 = v98;
  long long v23 = *(_OWORD *)v99;
  *(void *)(v17 + 141) = *(void *)&v99[13];
  *((_OWORD *)v17 + 7) = v22;
  *((_OWORD *)v17 + 8) = v23;
  *((_OWORD *)v17 + 5) = v20;
  *((_OWORD *)v17 + 6) = v21;
  long long v24 = v100;
  *((void *)v17 + 21) = v101;
  *(_OWORD *)(v17 + 152) = v24;
  uint64_t v95 = 0;
  long long v100 = 0uLL;
  uint64_t v101 = 0;
  *((_DWORD *)v17 + 44) = v102;
  long long v25 = v103;
  *((void *)v17 + 25) = v104;
  *(_OWORD *)(v17 + 184) = v25;
  long long v103 = 0uLL;
  uint64_t v104 = 0;
  long long v26 = v105[0];
  *(_OWORD *)(v17 + 217) = *(_OWORD *)((char *)v105 + 9);
  *((_OWORD *)v17 + 13) = v26;
  v17[240] = 0;
  v17[264] = 0;
  if (v108)
  {
    *((_OWORD *)v17 + 15) = v106;
    *((void *)v17 + 32) = v107;
    uint64_t v107 = 0;
    long long v106 = 0uLL;
    v17[264] = 1;
  }
  v17[288] = v110;
  *((_OWORD *)v17 + 17) = v109;
  uint64_t v27 = v114;
  *((void *)v17 + 39) = v112;
  *(_OWORD *)(v17 + 296) = v111;
  long long v111 = 0uLL;
  *((void *)v17 + 42) = v27;
  *((_OWORD *)v17 + 20) = v113;
  uint64_t v114 = 0;
  uint64_t v112 = 0;
  long long v113 = 0uLL;
  long long v28 = v116;
  *(_OWORD *)(v17 + 344) = v115;
  *(_OWORD *)(v17 + 360) = v28;
  long long v29 = v117;
  long long v30 = v118;
  long long v31 = *(_OWORD *)v119;
  *(void *)(v17 + 421) = *(void *)&v119[13];
  *(_OWORD *)(v17 + 392) = v30;
  *(_OWORD *)(v17 + 408) = v31;
  *(_OWORD *)(v17 + 376) = v29;
  *((_OWORD *)v17 + 27) = v120;
  long long v120 = 0uLL;
  *((void *)&v134 + 1) = v17;
  sub_1002243E8((uint64_t)&v91);
  if (v90[1]) {
    std::__shared_weak_count::__release_weak(v90[1]);
  }
  uint64_t v88 = 0;
  long long v89 = 0;
  long long v33 = (Registry **)(a1 + 96);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(a1 + 96));
  long long v35 = ServiceMap;
  uint64_t v37 = v36;
  if (v36 < 0)
  {
    long long v38 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v39 = 5381;
    do
    {
      uint64_t v37 = v39;
      unsigned int v40 = *v38++;
      uint64_t v39 = (33 * v39) ^ v40;
    }
    while (v40);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v37;
  long long v41 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)buf);
  if (v41)
  {
    uint64_t v43 = v41[3];
    long long v42 = (std::__shared_weak_count *)v41[4];
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v35);
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v42);
      char v44 = 0;
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v43 = 0;
  }
  std::mutex::unlock(v35);
  long long v42 = 0;
  char v44 = 1;
LABEL_27:
  (*(void (**)(uint64_t))(*(void *)a1 + 256))(a1);
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v43 + 40))(&v88, v43, buf);
  if ((buf[23] & 0x80000000) == 0)
  {
    if (v44) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  operator delete(*(void **)buf);
  if ((v44 & 1) == 0) {
LABEL_29:
  }
    sub_10004D2C8(v42);
LABEL_30:
  CFTypeRef v87 = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v88 + 40))(&cf);
  v125[0] = cf;
  if (cf) {
    CFRetain(cf);
  }
  v84[0] = 0;
  *(void *)long long buf = 0;
  sub_100044D6C(buf, v125);
  if (*(void *)buf) {
    uint64_t v45 = sub_100083F10;
  }
  else {
    uint64_t v45 = 0;
  }
  if (v45) {
    sub_100449580((const void **)v84, (const void **)buf);
  }
  sub_100044D00((const void **)buf);
  CFTypeRef v87 = v84[0];
  v84[0] = 0;
  sub_100044D00((const void **)v84);
  sub_1000577C4(v125);
  sub_1000577C4(&cf);
  v84[0] = 0;
  v84[1] = 0;
  uint64_t v85 = 0;
  v82[0] = 0;
  v82[1] = 0;
  uint64_t v83 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v81 = 0;
  uint64_t v46 = *(void *)(a1 + 752);
  if (!v46)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 768) + 80))(buf);
    long long v47 = *(_OWORD *)buf;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    long long v48 = *(std::__shared_weak_count **)(a1 + 760);
    *(_OWORD *)(a1 + 752) = v47;
    if (v48)
    {
      sub_10004D2C8(v48);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    uint64_t v46 = *(void *)(a1 + 752);
  }
  CFTypeRef v79 = v87;
  if (v87) {
    CFRetain(v87);
  }
  uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *, void **, void **, void **))(*(void *)v46 + 16))(v46, a2 + 272, &v79, v84, v82, __p);
  sub_100044D00(&v79);
  if (v49)
  {
    if (*(char *)(a2 + 319) < 0)
    {
      *(void *)(a2 + 304) = 6;
      long long v51 = *(char **)(a2 + 296);
    }
    else
    {
      long long v51 = (char *)(a2 + 296);
      *(unsigned char *)(a2 + 319) = 6;
    }
    strcpy(v51, "/stock");
    *(unsigned char *)(a2 + 332) = 0;
    long long v61 = (std::__shared_weak_count *)a3[1];
    uint64_t v77 = *a3;
    long long v78 = v61;
    if (v61) {
      atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)a1 + 312))(a1, &v77, 1, v49);
    if (v78) {
      sub_10004D2C8(v78);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 128) + 88))(*(void *)(a1 + 128), a2);
    goto LABEL_96;
  }
  uint64_t v130 = 0;
  long long v131 = 0;
  long long v52 = (std::mutex *)Registry::getServiceMap(v50, *v33);
  long long v53 = v52;
  if (v36 < 0)
  {
    long long v54 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v55 = 5381;
    do
    {
      uint64_t v36 = v55;
      unsigned int v56 = *v54++;
      uint64_t v55 = (33 * v55) ^ v56;
    }
    while (v56);
  }
  std::mutex::lock(v52);
  *(void *)long long buf = v36;
  long long v57 = sub_10004D37C(&v53[1].__m_.__sig, (unint64_t *)buf);
  if (v57)
  {
    uint64_t v59 = v57[3];
    long long v58 = (std::__shared_weak_count *)v57[4];
    if (v58)
    {
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v53);
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v58);
      char v60 = 0;
      goto LABEL_63;
    }
  }
  else
  {
    uint64_t v59 = 0;
  }
  std::mutex::unlock(v53);
  long long v58 = 0;
  char v60 = 1;
LABEL_63:
  (*(void (**)(uint64_t))(*(void *)a1 + 256))(a1);
  PersonalityIdFromSlotIdEx();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v59 + 40))(&v130, v59, buf);
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (v60) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  if ((v60 & 1) == 0) {
LABEL_65:
  }
    sub_10004D2C8(v58);
LABEL_66:
  if (v130)
  {
    v125[0] = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v130 + 40))(v125);
    long long v62 = (unint64_t *)v125[0];
    *(void *)long long buf = 1000;
    if (v125[0])
    {
      CFTypeID v63 = CFGetTypeID(v125[0]);
      if (v63 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, v62, v64);
      }
    }
    uint64_t v65 = *(void *)buf;
    sub_1000577C4(v125);
  }
  else
  {
    uint64_t v65 = 1000;
  }
  long long v66 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v65;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I Set branded calling image fetching timeout to %llu", buf, 0xCu);
  }
  long long v67 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v67 || (uint64_t v68 = *(void *)(a1 + 40), (v69 = std::__shared_weak_count::lock(v67)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v70 = v69;
  atomic_fetch_add_explicit(&v69->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v69);
  Registry::getTimerService(&v127, *v33);
  uint64_t v71 = v127;
  sub_100058DB0(v125, "Branded calling image fetching timeout");
  char v72 = *(NSObject **)(a1 + 56);
  dispatch_object_t object = v72;
  if (v72) {
    dispatch_retain(v72);
  }
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  *(void *)&uint8_t buf[16] = sub_1009A3164;
  long long v136 = &unk_101A22AD8;
  uint64_t v137 = v68;
  uint64_t v138 = v70;
  atomic_fetch_add_explicit(&v70->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  aBlocuint64_t k = _Block_copy(buf);
  sub_100118A44(v71, (uint64_t)v125, 1, 1000 * v65, &object, &aBlock);
  uint64_t v73 = v129;
  uint64_t v129 = 0;
  uint64_t v74 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v73;
  if (v74)
  {
    (*(void (**)(uint64_t))(*(void *)v74 + 8))(v74);
    uint64_t v75 = v129;
    uint64_t v129 = 0;
    if (v75) {
      (*(void (**)(uint64_t))(*(void *)v75 + 8))(v75);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v126 < 0) {
    operator delete((void *)v125[0]);
  }
  if (v128) {
    sub_10004D2C8(v128);
  }
  if (v138) {
    std::__shared_weak_count::__release_weak(v138);
  }
  std::__shared_weak_count::__release_weak(v70);
  if (v131) {
    sub_10004D2C8(v131);
  }
  uint64_t v76 = *(void *)(a1 + 752);
  sub_1009A4640((uint64_t)v132, (uint64_t)&v133);
  (*(void (**)(uint64_t, void **, void **, void **, void *))(*(void *)v76 + 24))(v76, v84, v82, __p, v132);
  sub_1009A45BC(v132);
LABEL_96:
  if (SHIBYTE(v81) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v83) < 0) {
    operator delete(v82[0]);
  }
  if (SHIBYTE(v85) < 0) {
    operator delete(v84[0]);
  }
  sub_100044D00(&v87);
  if (v89) {
    sub_10004D2C8(v89);
  }
  sub_1009A45BC(&v133);
  std::__shared_weak_count::__release_weak(v14);
}

void sub_10099E7BC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void **sub_10099E9C0(uint64_t a1, uint64_t a2)
{
  return sub_10099CB4C(a1 - 8, a2);
}

uint64_t sub_10099E9C8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 432);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1002243E8(a1 + 16);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_10099EA0C(uint64_t a1, uint64_t *a2, void **a3)
{
  uint64_t v3 = (void *)*((unsigned __int8 *)a3 + 23);
  int v4 = (char)v3;
  if ((char)v3 < 0) {
    uint64_t v3 = a3[1];
  }
  uint64_t v5 = *(os_log_t **)(a1 + 720);
  BOOL v6 = *v5;
  if (v3)
  {
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v10 = (uint64_t *)*a3;
      if (v4 >= 0) {
        unint64_t v10 = (uint64_t *)a3;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Adding a new IMS call for uuid %s", (uint8_t *)&buf, 0xCu);
    }
    uint8x8_t v11 = *(uint64_t **)(a1 + 680);
    long long v12 = (uint64_t **)(a1 + 680);
    long long v13 = (uint64_t **)(a1 + 680);
    if (!v11) {
      goto LABEL_19;
    }
    long long v12 = (uint64_t **)(a1 + 680);
    while (1)
    {
      while (1)
      {
        long long v13 = (uint64_t **)v11;
        unint64_t v14 = v11 + 4;
        if ((sub_100046FE8(a3, (void **)v11 + 4) & 0x80) == 0) {
          break;
        }
        uint8x8_t v11 = *v13;
        long long v12 = v13;
        if (!*v13) {
          goto LABEL_19;
        }
      }
      if ((sub_100046FE8(v14, a3) & 0x80) == 0) {
        break;
      }
      long long v12 = v13 + 1;
      uint8x8_t v11 = v13[1];
      if (!v11) {
        goto LABEL_19;
      }
    }
    unint64_t v15 = *v12;
    if (!*v12)
    {
LABEL_19:
      uint64_t v43 = 0;
      uint64_t v16 = (uint64_t *)operator new(0x48uLL);
      *(void *)&long long buf = v16;
      *((void *)&buf + 1) = a1 + 680;
      long long v17 = v16 + 4;
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(v17, *a3, (unint64_t)a3[1]);
      }
      else
      {
        *(_OWORD *)long long v17 = *(_OWORD *)a3;
        v16[6] = (uint64_t)a3[2];
      }
      v16[7] = 0;
      v16[8] = 0;
      LOBYTE(v43) = 1;
      *uint64_t v16 = 0;
      v16[1] = 0;
      v16[2] = (uint64_t)v13;
      std::__shared_weak_count *v12 = v16;
      uint64_t v18 = **(void **)(a1 + 672);
      if (v18)
      {
        *(void *)(a1 + 672) = v18;
        uint64_t v16 = *v12;
      }
      sub_100046C90(*(uint64_t **)(a1 + 680), v16);
      ++*(void *)(a1 + 688);
      unint64_t v15 = (uint64_t *)buf;
      *(void *)&long long buf = 0;
      sub_1001FEBC4((uint64_t)&buf);
    }
    uint64_t v20 = *a2;
    long long v19 = (uint64_t *)a2[1];
    if (v19) {
      atomic_fetch_add_explicit(v19 + 1, 1uLL, memory_order_relaxed);
    }
    long long v21 = (std::__shared_weak_count *)v15[8];
    v15[7] = v20;
    v15[8] = (uint64_t)v19;
    if (v21) {
      sub_10004D2C8(v21);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19, *(Registry **)(a1 + 96));
    long long v23 = ServiceMap;
    if (v24 < 0)
    {
      long long v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v24;
    long long v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&buf);
    if (v28)
    {
      uint64_t v30 = v28[3];
      long long v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
        if (!v30)
        {
LABEL_52:
          if ((v31 & 1) == 0) {
            sub_10004D2C8(v29);
          }
          return;
        }
LABEL_38:
        int v32 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 760))(v30);
        xpc_object_t v41 = 0;
        xpc_object_t v33 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v34 = v33;
        if (v33)
        {
          xpc_object_t v41 = v33;
        }
        else
        {
          xpc_object_t v34 = xpc_null_create();
          xpc_object_t v41 = v34;
          if (!v34)
          {
            xpc_object_t v35 = xpc_null_create();
            xpc_object_t v34 = 0;
            goto LABEL_45;
          }
        }
        if (xpc_get_type(v34) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v34);
LABEL_46:
          xpc_release(v34);
          BOOL v36 = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 256))(a1) == v32;
          xpc_object_t v39 = xpc_BOOL_create(v36);
          if (!v39) {
            xpc_object_t v39 = xpc_null_create();
          }
          *(void *)&long long buf = &v41;
          *((void *)&buf + 1) = "data_preferred";
          sub_100035E70((uint64_t)&buf, &v39, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v39);
          xpc_object_t v38 = v41;
          xpc_object_t v39 = 0;
          if (v41) {
            xpc_retain(v41);
          }
          else {
            xpc_object_t v38 = xpc_null_create();
          }
          ims::addCallEndInfo((ims *)&v38, v37);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          xpc_release(v41);
          goto LABEL_52;
        }
        xpc_object_t v35 = xpc_null_create();
LABEL_45:
        xpc_object_t v41 = v35;
        goto LABEL_46;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    long long v29 = 0;
    char v31 = 1;
    if (!v30) {
      goto LABEL_52;
    }
    goto LABEL_38;
  }
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IMSCallModel::addIMSCallForUuid received invalid call uuid", (uint8_t *)&buf, 2u);
  }
}

void sub_10099EE54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, xpc_object_t a12, char a13)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10099EEEC(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: MERGE MEDIA INIT", v4, 2u);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 32))(*(void *)(a1 + 144));
}

uint64_t sub_10099EF7C(uint64_t a1)
{
  return sub_10099EEEC(a1 - 8);
}

const void **sub_10099EF84(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I -------->IMS Incoming Indication: MERGED.", (uint8_t *)v5, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 128);
  memset(v5, 0, sizeof(v5));
  sub_100058DB0(v6, kCallerIdDefaultValue);
  int v7 = 9;
  char v8 = 0;
  int v9 = 1;
  char v10 = 1;
  uint64_t v11 = 0x400000001;
  uint64_t v12 = 2;
  char v13 = 0;
  int v14 = CallInfo::kDefaultCallId;
  char v17 = 0;
  char v18 = 0;
  uint64_t v15 = 0;
  v16[0] = 0;
  *(void *)((char *)v16 + 6) = 0;
  sub_100058DB0(v19, "");
  int v20 = 0;
  sub_100058DB0(v21, "");
  int v22 = 0;
  __int16 v23 = 0;
  int v24 = 0;
  __int16 v25 = 0;
  int v26 = 0;
  char v27 = 0;
  char v28 = 0;
  char v29 = 0;
  char v30 = 0;
  __int16 v31 = 0;
  int v32 = 1;
  char v33 = 0;
  int v34 = 0;
  char v35 = 0;
  char v41 = 0;
  char v42 = 0;
  char v43 = 0;
  char v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  (*(void (**)(uint64_t, _OWORD *))(*(void *)v3 + 136))(v3, v5);
  return sub_1002243E8((uint64_t)v5);
}

void sub_10099F11C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
}

const void **sub_10099F180(uint64_t a1)
{
  return sub_10099EF84(a1 - 8);
}

uint64_t sub_10099F188(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v4 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "-------->IMS Incoming Indication: MERGE FAILED", v4, 2u);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 128) + 144))(*(void *)(a1 + 128), a1 + 232);
}

uint64_t sub_10099F220(uint64_t a1)
{
  return sub_10099F188(a1 - 8);
}

uint64_t sub_10099F228(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v3 = kAmbiguousMultiPartyKey;
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 520))(a1, kAmbiguousMultiPartyKey);
    if (!result) {
      return result;
    }
    uint64_t v5 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Un-setting Ambiguous Multi Party.", v9, 2u);
    }
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 528))(a1, v3, 0);
  }
  else
  {
    BOOL v6 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting Ambiguous Multi Party.", buf, 2u);
    }
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 528))(a1, kAmbiguousMultiPartyKey, 1);
  }
  uint64_t v7 = *(void *)(a1 + 128);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 208))(v7, v8);
}

uint64_t sub_10099F3FC(uint64_t a1, char a2)
{
  return sub_10099F228(a1 - 8, a2);
}

uint64_t sub_10099F404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a4 + 23) >= 0) {
      uint64_t v8 = a4;
    }
    else {
      uint64_t v8 = (uint64_t *)*a4;
    }
    int v12 = 136315138;
    char v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Handling media stack switch complete for %s.", (uint8_t *)&v12, 0xCu);
  }
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 336))(v9, a2, v10);
}

uint64_t sub_10099F53C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return sub_10099F404(a1 - 8, a2, a3, a4);
}

uint64_t sub_10099F544(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  BOOL v6 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    int v11 = 136315394;
    int v12 = v7;
    __int16 v13 = 1024;
    int v14 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I handleUssdData %s %d.", (uint8_t *)&v11, 0x12u);
  }
  uint64_t v8 = *(void *)(a1 + 128);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, void, uint64_t, uint64_t))(*(void *)v8 + 120))(v8, a3, a2, 0, 1, v9);
}

uint64_t sub_10099F680(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return sub_10099F544(a1 - 8, a2, a3);
}

void sub_10099F688(uint64_t a1, uint64_t *a2, int a3)
{
  BOOL v6 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v7;
    __int16 v11 = 1024;
    int v12 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I handleIncomingUSSDError %s %u.", __p, 0x12u);
  }
  uint64_t v8 = *(void *)(a1 + 128);
  sub_100058DB0(__p, "");
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  (*(void (**)(uint64_t, void, unsigned char *, void, void, uint64_t))(*(void *)v8 + 120))(v8, 0, __p, 0, 0, v9);
  if (v13 < 0) {
    operator delete(*(void **)__p);
  }
}

void sub_10099F7E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10099F808(uint64_t a1, uint64_t *a2, int a3)
{
}

void sub_10099F810(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Reset fBasebandCallId = 0x00", v3, 2u);
  }
  *(unsigned char *)(a1 + 160) = 0;
}

void sub_10099F87C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 224);
  sub_1001369F0(a2, *(void *)(a1 + 200));
  for (CFIndex i = *(unsigned __int8 **)(a1 + 208); i; CFIndex i = *(unsigned __int8 **)i)
    sub_1009A3B74(a2, i + 16, (uint64_t)(i + 16));
}

void sub_10099F8DC(_Unwind_Exception *a1)
{
  sub_1004DD39C(v1);
  _Unwind_Resume(a1);
}

std::string *sub_10099F8F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 232;
  sub_100224390((const void **)(a1 + 232), (const void **)a2);
  std::string::operator=((std::string *)(a1 + 240), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 264), (const std::string *)(a2 + 32));
  *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 56);
  long long v5 = *(_OWORD *)(a2 + 88);
  long long v6 = *(_OWORD *)(a2 + 104);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(void *)(v4 + 117) = *(void *)(a2 + 117);
  *(_OWORD *)(a1 + 320) = v5;
  *(_OWORD *)(a1 + 336) = v6;
  *(_OWORD *)(a1 + 304) = v7;
  std::string::operator=((std::string *)(a1 + 360), (const std::string *)(a2 + 128));
  *(_DWORD *)(a1 + 384) = *(_DWORD *)(a2 + 152);
  std::string::operator=((std::string *)(a1 + 392), (const std::string *)(a2 + 160));
  long long v8 = *(_OWORD *)(a2 + 193);
  *(_OWORD *)(a1 + 416) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(v4 + 193) = v8;
  sub_100840CD0(a1 + 448, a2 + 216);
  long long v9 = *(_OWORD *)(a2 + 248);
  *(unsigned char *)(a1 + 496) = *(unsigned char *)(a2 + 264);
  *(_OWORD *)(a1 + 480) = v9;
  std::string::operator=((std::string *)(a1 + 504), (const std::string *)(a2 + 272));
  std::string::operator=((std::string *)(a1 + 528), (const std::string *)(a2 + 296));
  long long v10 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(v4 + 320) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(v4 + 336) = v10;
  long long v12 = *(_OWORD *)(a2 + 368);
  long long v11 = *(_OWORD *)(a2 + 384);
  long long v13 = *(_OWORD *)(a2 + 352);
  *(void *)(v4 + 397) = *(void *)(a2 + 397);
  *(_OWORD *)(v4 + 368) = v12;
  *(_OWORD *)(v4 + 384) = v11;
  *(_OWORD *)(v4 + 352) = v13;

  return std::string::operator=((std::string *)(a1 + 640), (const std::string *)(a2 + 408));
}

uint64_t sub_10099FA0C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 664) = a2;
  return result;
}

uint64_t sub_10099FA14(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 664);
}

uint64_t sub_10099FA1C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 740) = a2;
  return result;
}

uint64_t sub_10099FA24(uint64_t result, int a2)
{
  *(_DWORD *)(result + 744) = a2;
  return result;
}

uint64_t sub_10099FA2C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 740);
}

uint64_t sub_10099FA34(uint64_t result, char a2)
{
  *(unsigned char *)(result + 665) = a2;
  return result;
}

uint64_t sub_10099FA3C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 665);
}

void sub_10099FA44(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  long long v6 = sub_100046F68(a1 + 672, (void **)a2);
  if ((void **)(a1 + 680) == v6)
  {
    long long v8 = **(NSObject ***)(a1 + 720);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        long long v9 = (void *)a2;
      }
      else {
        long long v9 = *(void **)a2;
      }
      int v10 = 136315138;
      long long v11 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to find IMS call object for %s", (uint8_t *)&v10, 0xCu);
    }
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v7 = (atomic_ullong *)v6[8];
    *a3 = v6[7];
    a3[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    }
  }
}

void sub_10099FB3C(void **a1, char *a2, int a3)
{
  int v13 = a3;
  long long v5 = *a1[90];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    long long v6 = a2 + 32;
    if (a2[55] < 0) {
      long long v6 = (void *)*v6;
    }
    CallInfo::toString((uint64_t *)__p, (CallInfo *)a2);
    if (v12 >= 0) {
      long long v7 = __p;
    }
    else {
      long long v7 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Ending call with number: %s %s", buf, 0x16u);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v12 = 0;
  sub_10012A394(&v10, (const void **)a2);
  sub_101328F44((CFUUIDRef *)&v10, (uint64_t)__p);
  sub_10012577C(&v10);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  ((void (*)(unsigned char *__return_ptr, void **, void **))(*a1)[59])(buf, a1, __p);
  if (*(void *)buf)
  {
    (*(void (**)(void, int *))(**(void **)buf + 32))(*(void *)buf, &v13);
  }
  else
  {
    long long v8 = *a1[90];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      long long v9 = __p;
      if (v12 < 0) {
        long long v9 = (void **)__p[0];
      }
      *(_DWORD *)int v14 = 136315138;
      uint64_t v15 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to end the call! IMS call not found for uuid %s", v14, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10099FD58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

void sub_10099FDA0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 672);
  uint64_t v3 = (void *)(a1 + 680);
  if (v2 != (void *)(a1 + 680))
  {
    do
    {
      long long v6 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = v2[7];
        if (*(char *)(v7 + 55) < 0)
        {
          sub_10004FC84(__p, *(void **)(v7 + 32), *(void *)(v7 + 40));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v7 + 32);
          uint64_t v18 = *(void *)(v7 + 48);
        }
        long long v8 = v18 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136315394;
        int v20 = v8;
        __int16 v21 = 1024;
        int v22 = a2;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Handling SRVCC Cancel for call %s reason %d", buf, 0x12u);
        if (SHIBYTE(v18) < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v9 = v2[7];
      if (v9
      {
        long long v11 = (std::__shared_weak_count *)v2[8];
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(void *, BOOL))(*(void *)v10 + 104))(v10, a2 == 1);
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      else
      {
        uint64_t v12 = **(NSObject ***)(a1 + 720);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(v9 + 55) < 0)
          {
            sub_10004FC84(__p, *(void **)(v9 + 32), *(void *)(v9 + 40));
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)(v9 + 32);
            uint64_t v18 = *(void *)(v9 + 48);
          }
          uint64_t v16 = v18 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136315138;
          int v20 = v16;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to convert call %s to a normal call!", buf, 0xCu);
          if (SHIBYTE(v18) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      int v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          int v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          uint64_t v2 = v14;
        }
        while (!v15);
      }
      uint64_t v2 = v14;
    }
    while (v14 != v3);
  }
}

void sub_1009A0060(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A0080(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 688);
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 248))(__p, a1);
    uint64_t v4 = __p[23];
    if (__p[23] >= 0)
    {
      long long v5 = __p;
    }
    else
    {
      uint64_t v4 = *(void *)&__p[8];
      long long v5 = *(const char **)__p;
    }
    long long v6 = v4 ? (char *)v5 : "<invalid>";
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping state for IMSCallModel %s has %ld calls (fCurrentIMSCall)", buf, 0x16u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v7 = *(void **)(a1 + 672);
  if (v7 != (void *)(a1 + 680))
  {
    do
    {
      long long v8 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = v7[7];
        if (*(char *)(v9 + 55) < 0)
        {
          sub_10004FC84(__p, *(void **)(v9 + 32), *(void *)(v9 + 40));
          uint64_t v9 = v7[7];
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v9 + 32);
          *(void *)&__p[16] = *(void *)(v9 + 48);
        }
        if (__p[23] >= 0) {
          int v10 = __p;
        }
        else {
          int v10 = *(unsigned char **)__p;
        }
        if (*(char *)(v9 + 79) < 0)
        {
          sub_10004FC84(buf, *(void **)(v9 + 56), *(void *)(v9 + 64));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)(v9 + 56);
          *(void *)&uint8_t buf[16] = *(void *)(v9 + 72);
        }
        if (buf[23] >= 0) {
          long long v11 = buf;
        }
        else {
          long long v11 = *(unsigned char **)buf;
        }
        *(_DWORD *)int v34 = 136315394;
        char v35 = v10;
        __int16 v36 = 2080;
        long long v37 = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Uuid: %s StackID: %s", v34, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v12 = (void *)v7[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (void *)v7[2];
          BOOL v14 = *v13 == (void)v7;
          uint64_t v7 = v13;
        }
        while (!v14);
      }
      uint64_t v7 = v13;
    }
    while (v13 != (void *)(a1 + 680));
  }
  uint64_t v15 = *(void *)(a1 + 216);
  uint64_t v16 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 134217984;
    *(void *)&__p[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Secondary Device (Thumper) calls: %ld", __p, 0xCu);
  }
  if (v15)
  {
    for (CFIndex i = *(uint64_t **)(a1 + 208); i; CFIndex i = (uint64_t *)*i)
    {
      uint64_t v18 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        long long v19 = i + 2;
        if (*((char *)i + 39) < 0) {
          long long v19 = (uint64_t *)i[2];
        }
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s", __p, 0xCu);
      }
    }
  }
  int v20 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 665)) {
      __int16 v21 = "true";
    }
    else {
      __int16 v21 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I IMS Voice Registered: %s", __p, 0xCu);
    int v20 = **(NSObject ***)(a1 + 720);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 664)) {
      int v22 = "true";
    }
    else {
      int v22 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I PDP Active on IWLAN (Wifi): %s", __p, 0xCu);
    int v20 = **(NSObject ***)(a1 + 720);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string __p = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Call Capabilities:", __p, 2u);
  }
  __int16 v23 = *(void **)(a1 + 696);
  if (v23 != (void *)(a1 + 704))
  {
    do
    {
      int v24 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = *((_DWORD *)v23 + 10);
        uint64_t v26 = v23[4];
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = v26;
        *(_WORD *)&unsigned char __p[12] = 1024;
        *(_DWORD *)&__p[14] = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I \t%s = %d", __p, 0x12u);
      }
      char v27 = (void *)v23[1];
      if (v27)
      {
        do
        {
          char v28 = v27;
          char v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          char v28 = (void *)v23[2];
          BOOL v14 = *v28 == (void)v23;
          __int16 v23 = v28;
        }
        while (!v14);
      }
      __int16 v23 = v28;
    }
    while (v28 != (void *)(a1 + 704));
  }
  char v29 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 740)) {
      char v30 = "true";
    }
    else {
      char v30 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Is In Airplane Mode: %s", __p, 0xCu);
    char v29 = **(NSObject ***)(a1 + 720);
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 752)) {
      __int16 v31 = "true";
    }
    else {
      __int16 v31 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v31;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Has Branded Calling enabled: %s", __p, 0xCu);
    char v29 = **(NSObject ***)(a1 + 720);
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 784)) {
      int v32 = "true";
    }
    else {
      int v32 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v32;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Should show branded calling info: %s", __p, 0xCu);
  }
}

void sub_1009A06E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009A0704@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 120);
  *a2 = *(void *)(result + 112);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1009A0720@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = result[14];
  if (*(char *)(v2 + 47) < 0) {
    return sub_10004FC84((unsigned char *)a2, *(void **)(v2 + 24), *(void *)(v2 + 32));
  }
  long long v3 = *(_OWORD *)(v2 + 24);
  *(void *)(a2 + 16) = *(void *)(v2 + 40);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_1009A074C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 112);
  if (*(unsigned char *)(v1 + 49)) {
    return 1;
  }
  else {
    return *(unsigned int *)(v1 + 52);
  }
}

void sub_1009A0768(void **a1, uint64_t *a2, int a3)
{
  uint64_t v10 = 0;
  long long v11 = 0;
  ((void (*)(uint64_t *__return_ptr))(*a1)[59])(&v10);
  uint64_t v6 = v10;
  uint64_t v7 = *a1[90];
  if (v10)
  {
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (a3)
    {
      if (!v8)
      {
        uint64_t v9 = 2;
        goto LABEL_18;
      }
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      int v13 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Upgrading voice call %s to RTT!", buf, 0xCu);
      uint64_t v9 = 2;
    }
    else
    {
      if (!v8)
      {
        uint64_t v9 = 0;
        goto LABEL_18;
      }
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      int v13 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Downgrading RTT call %s to voice!", buf, 0xCu);
      uint64_t v9 = 0;
    }
    uint64_t v6 = v10;
LABEL_18:
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, v9);
    goto LABEL_19;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    *(_DWORD *)long long buf = 136315138;
    int v13 = a2;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "IMSCallModel::setTTYModeForCall: Failed to find IMS call object for %s", buf, 0xCu);
  }
LABEL_19:
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_1009A094C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A096C(void **a1, uint64_t **a2)
{
  long long v5 = 0;
  uint64_t v6 = 0;
  ((void (*)(uint8_t *__return_ptr))(*a1)[59])(buf);
  sub_1009A0AC8((void **)buf, &v5);
  if (*(void *)&v8[4]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v8[4]);
  }
  if (v5)
  {
    (*(void (**)(void *))(*(void *)v5 + 120))(v5);
  }
  else
  {
    uint64_t v4 = *a1[90];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t **)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)BOOL v8 = a2;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "IMSCallModel::swapCall: Failed to find IMS call object for %s", buf, 0xCu);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1009A0AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009A0AC8@<X0>(void **a1@<X0>, void **a2@<X8>)
{
  uint64_t v2 = a1;
  uint64_t result = *a1;
  if (result
  {
    long long v5 = v2[1];
    *a2 = result;
    a2[1] = v5;
  }
  else
  {
    uint64_t v2 = a2;
  }
  NSObject *v2 = 0;
  v2[1] = 0;
  return result;
}

void sub_1009A0B4C(void **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v7 = 0;
  BOOL v8 = 0;
  ((void (*)(uint64_t *__return_ptr))(*a1)[59])(&v7);
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 80))(v7, a2);
  }
  else
  {
    uint64_t v6 = *a1[90];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a3 + 23) < 0) {
        a3 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v10 = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IMSCallModel::sendDTMFDigits: Failed to find IMS call object for %s", buf, 0xCu);
    }
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1009A0C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A0CA4(void **a1, unsigned __int8 a2, uint64_t *a3)
{
  uint64_t v7 = 0;
  BOOL v8 = 0;
  ((void (*)(uint64_t *__return_ptr))(*a1)[59])(&v7);
  if (v7)
  {
    (*(void (**)(uint64_t, void))(*(void *)v7 + 72))(v7, a2);
  }
  else
  {
    uint64_t v6 = *a1[90];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a3 + 23) < 0) {
        a3 = (uint64_t *)*a3;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v10 = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "IMSCallModel::startDTMFTone: Failed to find IMS call object for %s", buf, 0xCu);
    }
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1009A0DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A0DFC(void **a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  ((void (*)(uint64_t *__return_ptr))(*a1)[59])(&v5);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 88))(v5);
  }
  else
  {
    uint64_t v4 = *a1[90];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      BOOL v8 = a2;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "IMSCallModel::stopDTMFTone: Failed to find IMS call object for %s", buf, 0xCu);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1009A0F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A0F40(void **a1, uint64_t a2)
{
  v19[0] = 0;
  v19[1] = 0;
  uint64_t v20 = 0;
  sub_10012A394(&v18, (const void **)a2);
  sub_101328F44((CFUUIDRef *)&v18, (uint64_t)v19);
  sub_10012577C(&v18);
  uint64_t v4 = *a1[90];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = v19;
    if (v20 < 0) {
      uint64_t v5 = (void **)v19[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Answering waiting call %s", buf, 0xCu);
  }
  uint64_t v16 = 0;
  char v17 = 0;
  ((void (*)(uint64_t *__return_ptr, void **, void **))(*a1)[59])(&v16, a1, v19);
  uint64_t v6 = v16;
  if (v16)
  {
    long long v33 = 0u;
    long long v34 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    *(_OWORD *)int v24 = 0u;
    long long v25 = 0u;
    *(_OWORD *)long long buf = 0u;
    long long v23 = 0u;
    uint64_t v28 = 0x40A7700000000000;
    long long v29 = 0u;
    *(_OWORD *)char v30 = 0u;
    *(_OWORD *)__int16 v31 = 0u;
    memset(v32, 0, sizeof(v32));
    uint64_t v7 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v8 = (os_log_t *)(*(uint64_t (**)(void *, void))(*a1[10] + 16))(a1[10], *(unsigned int *)(a2 + 252));
    uint64_t v9 = *(unsigned __int8 *)(a2 + 151);
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a2 + 136);
    }
    if (v9) {
      std::string::operator=((std::string *)&buf[8], (const std::string *)(a2 + 128));
    }
    int v10 = (*(uint64_t (**)(void *, uint64_t))(*a1[16] + 272))(a1[16], a2);
    long long v11 = *v8;
    BOOL v12 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      if (v12)
      {
        *(_WORD *)__int16 v21 = 0;
        uint64_t v13 = 2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Starting call with RTT mode enabled", v21, 2u);
      }
      else
      {
        uint64_t v13 = 2;
      }
    }
    else
    {
      if (v12)
      {
        *(_WORD *)__int16 v21 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Starting call with RTT mode disabled", v21, 2u);
      }
      uint64_t v13 = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, v13);
    if (v7) {
      sub_10004D2C8(v7);
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v16 + 24))(v16, &buf[8]);
    if ((_BYTE)v34 && SHIBYTE(v33) < 0) {
      operator delete(v32[8]);
    }
    if (SHIBYTE(v32[6]) < 0) {
      operator delete(v32[4]);
    }
    if (SHIBYTE(v32[3]) < 0) {
      operator delete(v32[1]);
    }
    if (SHIBYTE(v32[0]) < 0) {
      operator delete(v31[0]);
    }
    if (SHIBYTE(v30[1]) < 0) {
      operator delete(*((void **)&v29 + 1));
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[1]);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(*(void **)&buf[8]);
    }
  }
  else
  {
    BOOL v14 = *a1[90];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = v19;
      if (v20 < 0) {
        uint64_t v15 = (void **)v19[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to find the call to answer! IMS call not found for uuid %s", buf, 0xCu);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
}

void sub_1009A134C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009A13A8(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4, uint64_t a5, int a6, uint64_t a7, unsigned int a8)
{
  if (a6)
  {
    uint64_t v15 = operator new(0x1A8uLL);
    void *v15 = 0;
    v15[1] = 0;
    sub_100245B5C((uint64_t)(v15 + 2), a3);
    uint64_t v16 = *(void *)(a1 + 168);
    void *v15 = v16;
    v15[1] = a1 + 168;
    *(void *)(v16 + 8) = v15;
    *(void *)(a1 + 168) = v15;
    ++*(void *)(a1 + 184);
  }
  unsigned int v72 = a8;
  int v17 = *(unsigned __int8 *)(a3 + 68);
  int v18 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 128) + 360))(*(void *)(a1 + 128), a3);
  long long v19 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    sub_10012A394(&v75, (const void **)a3);
    printUuid();
    uint64_t v20 = "Wifi";
    if (v17 == 4) {
      uint64_t v20 = "VoLTE";
    }
    if (v85 >= 0) {
      __int16 v21 = &v84;
    }
    else {
      __int16 v21 = (long long *)v84;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    if (v18) {
      int v22 = "an emergency";
    }
    else {
      int v22 = "normal";
    }
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v80 = v22;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Dialing out %s call with uuid %s as %s call.", buf, 0x20u);
    if (SHIBYTE(v85) < 0) {
      operator delete((void *)v84);
    }
    sub_10012577C(&v75);
  }
  if (*(unsigned char *)(a3 + 404))
  {
    *(void *)long long buf = asString();
    sub_1000791C0(a4 + 9, (char **)buf);
  }
  long long v23 = *(const void **)a2;
  if (v18)
  {
    if (v23)
    {
      if (v24)
      {
        long long v25 = v24;
        long long v26 = *(std::__shared_weak_count **)(a2 + 8);
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v71 = v26;
        (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)a1 + 248))(buf, a1);
        long long v27 = **(NSObject ***)(a1 + 720);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = buf[23];
          if ((buf[23] & 0x80u) != 0) {
            uint64_t v28 = *(void *)&buf[8];
          }
          long long v29 = buf;
          if ((buf[23] & 0x80u) != 0) {
            long long v29 = *(uint8_t **)buf;
          }
          if (v28) {
            char v30 = (const char *)v29;
          }
          else {
            char v30 = "<invalid>";
          }
          LODWORD(v84) = 136315138;
          *(void *)((char *)&v84 + 4) = v30;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I dialing out emergency call on personalityId :%s .", (uint8_t *)&v84, 0xCu);
        }
        int v31 = isActive();
        long long v84 = 0uLL;
        uint64_t v85 = 0;
        int v70 = v31;
        if (v31)
        {
          uint64_t v32 = buf[23];
          if ((buf[23] & 0x80u) != 0) {
            uint64_t v32 = *(void *)&buf[8];
          }
          long long v33 = buf;
          if ((buf[23] & 0x80u) != 0) {
            long long v33 = *(uint8_t **)buf;
          }
          if (v32) {
            long long v34 = (char *)v33;
          }
          else {
            long long v34 = "<invalid>";
          }
          sub_100058DB0(&v84, v34);
        }
        if (*(unsigned char *)(a1 + 665))
        {
LABEL_92:
          char v60 = **(NSObject ***)(a1 + 720);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            long long v61 = &v84;
            if (v85 < 0) {
              long long v61 = (long long *)v84;
            }
            int v62 = *(unsigned __int8 *)(a1 + 665);
            *(_DWORD *)uint64_t v81 = 136315650;
            *(void *)&v81[4] = v61;
            *(_WORD *)&v81[12] = 1024;
            *(_DWORD *)&v81[14] = v70;
            __int16 v82 = 1024;
            int v83 = v62;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Carrier identifier in emergency dial: %s. [isSimActive: %d isIMSRegistered: %d]", v81, 0x18u);
          }
          (*(void (**)(void *, uint64_t, long long *, std::string *, uint64_t))(*(void *)v25 + 104))(v25, a7, &v84, a4, a5);
          if (SHIBYTE(v85) < 0) {
            operator delete((void *)v84);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          if (v71)
          {
            sub_10004D2C8(v71);
            long long v39 = v71;
            goto LABEL_102;
          }
          goto LABEL_103;
        }
        if (SHIBYTE(v85) < 0) {
          operator delete((void *)v84);
        }
        long long v84 = 0uLL;
        uint64_t v85 = 0;
        if ((char)buf[23] < 0)
        {
          sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          char v35 = *(uint64_t **)&buf[16];
          uint64_t v77 = *(void *)&buf[16];
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(v35, *(Registry **)(a1 + 96));
        char v43 = ServiceMap;
        if (v44 < 0)
        {
          uint64_t v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v46 = 5381;
          do
          {
            uint64_t v44 = v46;
            unsigned int v47 = *v45++;
            uint64_t v46 = (33 * v46) ^ v47;
          }
          while (v47);
        }
        std::mutex::lock(ServiceMap);
        *(void *)uint64_t v81 = v44;
        long long v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)v81);
        if (v48)
        {
          uint64_t v49 = v48[3];
          long long v50 = (std::__shared_weak_count *)v48[4];
          if (v50)
          {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v43);
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v50);
            char v51 = 0;
            if (!v49) {
              goto LABEL_65;
            }
            goto LABEL_70;
          }
        }
        else
        {
          uint64_t v49 = 0;
        }
        std::mutex::unlock(v43);
        long long v50 = 0;
        char v51 = 1;
        if (!v49)
        {
LABEL_65:
          long long v52 = **(NSObject ***)(a1 + 720);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v81 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "SystemDeterminationManager is NULL!", v81, 2u);
            if (v51)
            {
LABEL_90:
              if (SHIBYTE(v77) < 0) {
                operator delete(__p[0]);
              }
              goto LABEL_92;
            }
          }
          else if (v51)
          {
            goto LABEL_90;
          }
LABEL_89:
          sub_10004D2C8(v50);
          goto LABEL_90;
        }
LABEL_70:
        char v69 = v51;
        uint64_t v68 = v50;
        *(void *)uint64_t v81 = 0;
        *(void *)&v81[8] = 0;
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void **))(*(void *)v49 + 40))(v81, v49, __p);
        uint64_t v53 = *(void *)v81;
        long long v54 = **(NSObject ***)(a1 + 720);
        if (*(void *)v81)
        {
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v55 = (void *)HIBYTE(v77);
            if (v77 < 0) {
              uint64_t v55 = __p[1];
            }
            unsigned int v56 = __p;
            if (v77 < 0) {
              unsigned int v56 = (void **)__p[0];
            }
            if (v55) {
              long long v57 = (const char *)v56;
            }
            else {
              long long v57 = "<invalid>";
            }
            *(_DWORD *)long long v86 = 136315138;
            *(void *)&v86[4] = v57;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Setting IMS prefs on stack config for %s", v86, 0xCu);
            uint64_t v53 = *(void *)v81;
          }
          *(void *)long long v86 = 0;
          (*(void (**)(unsigned char *__return_ptr, uint64_t, void, void))(*(void *)v53 + 24))(v86, v53, v72, 0);
          long long v78 = 0;
          (*(void (**)(const void **__return_ptr))(**(void **)v81 + 24))(&v78);
          long long v58 = *(const void **)v86;
          uint64_t v59 = v78;
          sub_1009A3934(a5 + 8);
          *(void *)(a5 + 8) = v58;
          *(void *)(a5 + 16) = v59;
          if (v58)
          {
            CFRetain(v58);
            uint64_t v59 = *(const void **)(a5 + 16);
          }
          if (v59) {
            CFRetain(v59);
          }
          sub_100057D78(&v78);
          sub_100057D78((const void **)v86);
        }
        else if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          uint64_t v65 = (void *)HIBYTE(v77);
          if (v77 < 0) {
            uint64_t v65 = __p[1];
          }
          long long v66 = __p;
          if (v77 < 0) {
            long long v66 = (void **)__p[0];
          }
          if (v65) {
            long long v67 = (const char *)v66;
          }
          else {
            long long v67 = "<invalid>";
          }
          *(_DWORD *)long long v86 = 136315138;
          *(void *)&v86[4] = v67;
          _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "IMS Call config not found for pid %s", v86, 0xCu);
        }
        if (*(void *)&v81[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v81[8]);
        }
        long long v50 = v68;
        if (v69) {
          goto LABEL_90;
        }
        goto LABEL_89;
      }
    }
    char v40 = **(NSObject ***)(a1 + 720);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_WORD *)long long buf = 0;
    char v41 = "IMSCallModel::dial: Cannot create an emergency ims call object";
LABEL_57:
    _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, buf, 2u);
    goto LABEL_103;
  }
  if (!v23
  {
    char v40 = **(NSObject ***)(a1 + 720);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_103;
    }
    *(_WORD *)long long buf = 0;
    char v41 = "IMSCallModel::dial: Cannot create an ims call object";
    goto LABEL_57;
  }
  long long v37 = v36;
  long long v38 = *(std::__shared_weak_count **)(a2 + 8);
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(buf, "");
  (*(void (**)(void *, uint64_t, std::string *, uint8_t *, void))(*(void *)v37 + 128))(v37, a7, a4, buf, *(unsigned __int8 *)(a3 + 87));
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (v38)
  {
    long long v39 = v38;
LABEL_102:
    sub_10004D2C8(v39);
  }
LABEL_103:
  uint64_t v63 = *(void *)a2;
  CFNumberRef v64 = *(std::__shared_weak_count **)(a2 + 8);
  v74[0] = v63;
  v74[1] = (uint64_t)v64;
  if (v64) {
    atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10012A394(&v73, (const void **)a3);
  sub_101328F44((CFUUIDRef *)&v73, (uint64_t)buf);
  sub_10099EA0C(a1, v74, (void **)buf);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  sub_10012577C(&v73);
  if (v64) {
    sub_10004D2C8(v64);
  }
}

void sub_1009A1D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  sub_100057D78((const void **)(v34 - 128));
  if (a34) {
    sub_10004D2C8(a34);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v34 - 137) < 0) {
    operator delete(*(void **)(v34 - 160));
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a13)
  {
    sub_10004D2C8(a13);
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(a1);
}

void sub_1009A1E74(uint64_t a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 216);
  if (v7)
  {
    if (v7 == 1)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v19 = 0;
      uint64_t v9 = *(void *)(a1 + 208);
      if (*(char *)(v9 + 39) < 0)
      {
        sub_10004FC84(buf, *(void **)(v9 + 16), *(void *)(v9 + 24));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)(v9 + 16);
        uint64_t v19 = *(void *)(v9 + 32);
      }
      BOOL v12 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = buf;
        if (v19 < 0) {
          uint64_t v13 = *(uint8_t **)buf;
        }
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Pulling call %s via replaces header", __p, 0xCu);
      }
      (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)*a2 + 136))(*a2, buf, a4);
    }
    else
    {
      int v10 = **(NSObject ***)(a1 + 720);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Pulling call via replaces header but too many ids, letting IPT pick", buf, 2u);
      }
      uint64_t v11 = *a2;
      sub_100058DB0(buf, "");
      sub_100058DB0(__p, "");
      (*(void (**)(uint64_t, uint8_t *, uint64_t, unsigned char *, void))(*(void *)v11 + 128))(v11, buf, a4, __p, 0);
      if (v21 < 0) {
        operator delete(*(void **)__p);
      }
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v14 = *a2;
  uint64_t v15 = (std::__shared_weak_count *)a2[1];
  v17[0] = v14;
  v17[1] = (uint64_t)v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10012A394(&v16, a3);
  sub_101328F44((CFUUIDRef *)&v16, (uint64_t)buf);
  sub_10099EA0C(a1, v17, (void **)buf);
  if (SHIBYTE(v19) < 0) {
    operator delete(*(void **)buf);
  }
  sub_10012577C(&v16);
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_1009A20DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A2150(void **a1, const void **a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  sub_10012A394(&v7, a2);
  sub_101328F44((CFUUIDRef *)&v7, (uint64_t)__p);
  sub_10012577C(&v7);
  long long v3 = *a1[90];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = __p;
    if (v9 < 0) {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Holding call %s", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  ((void (*)(uint8_t *__return_ptr, void **, void **))(*a1)[59])(v10, a1, __p);
  sub_1009A0AC8((void **)v10, (void **)buf);
  if (*(void *)&v11[4]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v11[4]);
  }
  if (*(void *)buf)
  {
    (*(void (**)(void))(**(void **)buf + 112))(*(void *)buf);
  }
  else
  {
    uint64_t v5 = *a1[90];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = __p;
      if (v9 < 0) {
        uint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)int v10 = 136315138;
      *(void *)uint64_t v11 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to hold the call! IMS call not found for uuid %s", v10, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1009A232C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A236C(void **a1, const void **a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  sub_10012A394(&v7, a2);
  sub_101328F44((CFUUIDRef *)&v7, (uint64_t)__p);
  sub_10012577C(&v7);
  long long v3 = *a1[90];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = __p;
    if (v9 < 0) {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Resuming call %s", buf, 0xCu);
  }
  *(_OWORD *)long long buf = 0uLL;
  ((void (*)(uint8_t *__return_ptr, void **, void **))(*a1)[59])(v10, a1, __p);
  sub_1009A0AC8((void **)v10, (void **)buf);
  if (*(void *)&v11[4]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v11[4]);
  }
  if (*(void *)buf)
  {
    (*(void (**)(void))(**(void **)buf + 120))(*(void *)buf);
  }
  else
  {
    uint64_t v5 = *a1[90];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = __p;
      if (v9 < 0) {
        uint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)int v10 = 136315138;
      *(void *)uint64_t v11 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to resume the call! IMS call not found for uuid %s", v10, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1009A2548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009A2588(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = v4;
  *(void *)(a1 + 120) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v6);
  *(void *)(a1 + 720) = result;
  return result;
}

uint64_t sub_1009A262C(void **a1)
{
  uint64_t v2 = *a1[90];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Filling up default call capabilities", (uint8_t *)__p, 2u);
  }
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kMaxSupportedCallCountKey, 6);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kMaxMultiPartyCallCountKey, 5);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kSwappableKey, 1);
  ((void (*)(void **__return_ptr, void **))(*a1)[31])(__p, a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, (Registry *)a1[12]);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)char v30 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v30);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_13:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_9;
    }
    goto LABEL_14;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_9:
    uint64_t v14 = *a1[90];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v30 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "System Determination Manager is NULL!", v30, 2u);
    }
    uint64_t v15 = 0;
    goto LABEL_28;
  }
LABEL_14:
  *(void *)char v30 = 0;
  int v31 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v12 + 40))(v30, v12, __p);
  if (*(void *)v30)
  {
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)v30 + 40))(&cf);
    uint64_t v15 = (BOOL *)cf;
    buf[0] = 0;
    if (cf)
    {
      CFTypeID v16 = CFGetTypeID(cf);
      if (v16 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v15, v17);
        uint64_t v15 = (BOOL *)(buf[0] != 0);
      }
      else
      {
        uint64_t v15 = 0;
      }
    }
    uint64_t v19 = *a1[90];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = "disabled";
      if (v15) {
        uint64_t v20 = "enabled";
      }
      *(_DWORD *)long long buf = 136315138;
      long long v33 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Conference support: %s", buf, 0xCu);
    }
    sub_1000577C4(&cf);
  }
  else
  {
    int v18 = *a1[90];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      unint64_t v24 = v28;
      if ((v28 & 0x80u) != 0) {
        unint64_t v24 = (unint64_t)__p[1];
      }
      long long v25 = __p;
      if ((v28 & 0x80u) != 0) {
        long long v25 = (void **)__p[0];
      }
      if (v24) {
        long long v26 = (const char *)v25;
      }
      else {
        long long v26 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315138;
      long long v33 = v26;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "IMS Call config not found for pid %s", buf, 0xCu);
    }
    uint64_t v15 = 0;
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
LABEL_28:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  ((void (*)(void **, void, BOOL *))(*a1)[66])(a1, kMergeableKey, v15);
  if ((char)v28 < 0) {
    operator delete(__p[0]);
  }
  ((void (*)(void **, void, void))(*a1)[66])(a1, kAmbiguousMultiPartyKey, 0);
  ((void (*)(void **, void, void))(*a1)[66])(a1, kAmbiguousCallListKey, 0);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kAddCallAllowedKey, 1);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kHoldAllowedKey, 1);
  ((void (*)(void **, void, void))(*a1)[66])(a1, kEndToneInProgressKey, 0);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kEndAndAnswerAllowedKey, 1);
  ((void (*)(void **, void, uint64_t))(*a1)[66])(a1, kIsConferenceSideBarBlockedKey, 1);
  ((void (*)(void **, void, void))(*a1)[66])(a1, kVoicePrivacyKey, 0);
  ((void (*)(void **, void, void))(*a1)[66])(a1, kSendDTMFInBursts, 0);
  char v21 = a1[16];
  uint64_t v22 = ((uint64_t (*)(void **))(*a1)[32])(a1);
  return (*(uint64_t (**)(void *, uint64_t))(*v21 + 208))(v21, v22);
}

void sub_1009A2D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_1009A2DCC(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5 = a2;
  uint64_t v6 = &v5;
  uint64_t result = sub_1003B2574((uint64_t **)(a1 + 696), &v5, (uint64_t)&unk_10144E20E, &v6);
  *((_DWORD *)result + 10) = a3;
  return result;
}

uint64_t sub_1009A2E20(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 704);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void *)(a1 + 704);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      uint64_t v6 = v2;
    }
    else {
      uint64_t v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 != (void *)(a1 + 704) && v3[4] <= a2) {
    return *((unsigned int *)v3 + 10);
  }
  else {
    return 0;
  }
}

uint64_t *sub_1009A2E70@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = (uint64_t *)(a2 + 8);
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v3 = (uint64_t *)result[87];
  unint64_t v4 = result + 88;
  if (v3 != result + 88)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (uint64_t *)(a2 + 8);
    while (1)
    {
      unint64_t v8 = v3[4];
      unsigned int v9 = v2;
      if (v7 == v2) {
        goto LABEL_9;
      }
      int v10 = v6;
      uint64_t v11 = v2;
      if (v6)
      {
        do
        {
          unsigned int v9 = v10;
          int v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v9 = (uint64_t *)v11[2];
          BOOL v12 = *v9 == (void)v11;
          uint64_t v11 = v9;
        }
        while (v12);
      }
      if (v9[4] < v8)
      {
LABEL_9:
        if (v6) {
          char v13 = (uint64_t **)v9;
        }
        else {
          char v13 = (uint64_t **)v2;
        }
        if (v6) {
          uint64_t v14 = (uint64_t **)(v9 + 1);
        }
        else {
          uint64_t v14 = (uint64_t **)v2;
        }
        if (!*v14)
        {
LABEL_25:
          CFBooleanRef v17 = (uint64_t *)operator new(0x30uLL);
          *((_OWORD *)v17 + 2) = *((_OWORD *)v3 + 2);
          uint64_t result = sub_100046C38((uint64_t **)a2, (uint64_t)v13, v14, v17);
          uint64_t v7 = *(uint64_t **)a2;
        }
      }
      else
      {
        uint64_t v14 = (uint64_t **)v2;
        char v13 = (uint64_t **)v2;
        if (!v6) {
          goto LABEL_25;
        }
        uint64_t v15 = v6;
        while (1)
        {
          while (1)
          {
            char v13 = (uint64_t **)v15;
            unint64_t v16 = v15[4];
            if (v16 <= v8) {
              break;
            }
            uint64_t v15 = *v13;
            uint64_t v14 = v13;
            if (!*v13) {
              goto LABEL_25;
            }
          }
          if (v16 >= v8) {
            break;
          }
          uint64_t v15 = v13[1];
          if (!v15)
          {
            uint64_t v14 = v13 + 1;
            goto LABEL_25;
          }
        }
      }
      char v18 = (uint64_t *)v3[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          char v18 = (uint64_t *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (uint64_t *)v3[2];
          BOOL v12 = *v19 == (void)v3;
          uint64_t v3 = v19;
        }
        while (!v12);
      }
      if (v19 == v4) {
        return result;
      }
      uint64_t v6 = (uint64_t *)*v2;
      uint64_t v3 = v19;
    }
  }
  return result;
}

void sub_1009A2FE4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, v2);
  _Unwind_Resume(a1);
}

void sub_1009A2FFC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    uint64_t v8 = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Updating LTE emergency bearer support to: %s", (uint8_t *)&v7, 0xCu);
  }
  *(void *)(a1 + 728) = a2;
  *(_DWORD *)(a1 + 736) = a3;
}

uint64_t sub_1009A30BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 752);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1009A30EC(uint64_t a1, int a2, char a3)
{
  *(unsigned char *)(a1 + 784) = a2;
  if (a2 && (a3 & 1) == 0)
  {
    [(objc_class *)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.BrandedCalling.userenables" bundleIdentifier:@"com.apple.CommCenter.BrandedCalling" completionHandler:&stru_101A0BE60];
  }
}

void sub_1009A3164(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 88);
        *(void *)(v5 + 88) = 0;
        if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
          uint64_t v7 = *(void *)(v5 + 88);
          *(void *)(v5 + 88) = 0;
          if (v7) {
            (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
          }
        }
        uint64_t v8 = *(void *)(v5 + 752);
        if (v8)
        {
          (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
        }
        else
        {
          unsigned int v9 = **(NSObject ***)(v5 + 720);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)int v10 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Branded calling helper is NULL", v10, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009A32A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009A32B4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009A32D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009A32E0(uint64_t a1, uint64_t *a2, BOOL a3, unsigned int a4)
{
  if (*a2)
  {
    xpc_object_t v33 = 0;
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v9 = v8;
    if (v8)
    {
      xpc_object_t v33 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v33 = v9;
      if (!v9)
      {
        xpc_object_t v11 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
LABEL_12:
      xpc_release(v9);
      xpc_object_t v31 = xpc_BOOL_create(a3);
      if (!v31) {
        xpc_object_t v31 = xpc_null_create();
      }
      *(void *)long long buf = &v33;
      *(void *)&uint8_t buf[8] = "is_branded_call";
      sub_100035E70((uint64_t)buf, &v31, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v31);
      xpc_object_t v31 = 0;
      if (a3)
      {
        BOOL v12 = **(NSObject ***)(a1 + 720);
        BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
        if (a4)
        {
          if (v13)
          {
            uint64_t v14 = *a2;
            if (*(char *)(*a2 + 55) < 0)
            {
              sub_10004FC84(buf, *(void **)(v14 + 32), *(void *)(v14 + 40));
            }
            else
            {
              *(_OWORD *)long long buf = *(_OWORD *)(v14 + 32);
              uint64_t v30 = *(void *)(v14 + 48);
            }
            int v16 = SHIBYTE(v30);
            CFBooleanRef v17 = *(uint8_t **)buf;
            uint64_t v18 = asString();
            uint64_t v19 = buf;
            if (v16 < 0) {
              uint64_t v19 = v17;
            }
            *(_DWORD *)uint64_t v34 = 136315394;
            char v35 = v19;
            __int16 v36 = 2080;
            uint64_t v37 = v18;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I branding failed for call %s err %s", v34, 0x16u);
            if (SHIBYTE(v30) < 0) {
              operator delete(*(void **)buf);
            }
          }
          xpc_object_t v25 = xpc_BOOL_create(0);
          if (!v25) {
            xpc_object_t v25 = xpc_null_create();
          }
          *(void *)long long buf = &v33;
          *(void *)&uint8_t buf[8] = "is_image_displayed";
          sub_100035E70((uint64_t)buf, &v25, &v26);
          xpc_release(v26);
          xpc_object_t v26 = 0;
          xpc_release(v25);
          xpc_object_t v25 = 0;
          xpc_object_t v23 = xpc_int64_create(a4);
          if (!v23) {
            xpc_object_t v23 = xpc_null_create();
          }
          *(void *)long long buf = &v33;
          *(void *)&uint8_t buf[8] = "branded_call_failure_reason";
          sub_100035E70((uint64_t)buf, &v23, &v24);
          xpc_release(v24);
          xpc_object_t v24 = 0;
          xpc_release(v23);
          xpc_object_t v23 = 0;
        }
        else
        {
          if (v13)
          {
            uint64_t v15 = *a2;
            if (*(char *)(*a2 + 55) < 0)
            {
              sub_10004FC84(buf, *(void **)(v15 + 32), *(void *)(v15 + 40));
            }
            else
            {
              *(_OWORD *)long long buf = *(_OWORD *)(v15 + 32);
              uint64_t v30 = *(void *)(v15 + 48);
            }
            uint64_t v20 = buf;
            if (v30 < 0) {
              uint64_t v20 = *(uint8_t **)buf;
            }
            *(_DWORD *)uint64_t v34 = 136315138;
            char v35 = v20;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I branding success for call %s", v34, 0xCu);
            if (SHIBYTE(v30) < 0) {
              operator delete(*(void **)buf);
            }
          }
          xpc_object_t v27 = xpc_BOOL_create(1);
          if (!v27) {
            xpc_object_t v27 = xpc_null_create();
          }
          *(void *)long long buf = &v33;
          *(void *)&uint8_t buf[8] = "is_image_displayed";
          sub_100035E70((uint64_t)buf, &v27, &v28);
          xpc_release(v28);
          xpc_object_t v28 = 0;
          xpc_release(v27);
          xpc_object_t v27 = 0;
        }
      }
      xpc_object_t v22 = v33;
      if (v33) {
        xpc_retain(v33);
      }
      else {
        xpc_object_t v22 = xpc_null_create();
      }
      ims::addCallEndInfo((ims *)&v22, v21);
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_release(v33);
      return;
    }
    xpc_object_t v11 = xpc_null_create();
LABEL_11:
    xpc_object_t v33 = v11;
    goto LABEL_12;
  }
  int v10 = **(NSObject ***)(a1 + 720);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "IMS call object is null", buf, 2u);
  }
}

void sub_1009A36CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  xpc_release(*(xpc_object_t *)(v22 - 88));
  _Unwind_Resume(a1);
}

void sub_1009A3788(uint64_t a1)
{
  sub_1009A3984(a1);

  operator delete();
}

uint64_t sub_1009A37CC(uint64_t a1)
{
  return sub_1009A3984(a1 - 8);
}

void sub_1009A37D4(uint64_t a1)
{
  sub_1009A3984(a1 - 8);

  operator delete();
}

void sub_1009A3824(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_1002243E8((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

uint64_t sub_1009A3898(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240) && *(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1009A3934(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_1009A3984(uint64_t a1)
{
  *(void *)a1 = off_101A22798;
  *(void *)(a1 + 8) = off_101A22A00;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 776);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 760);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000346F8(a1 + 696, *(void **)(a1 + 704));
  sub_1001FEC70(*(void **)(a1 + 680));
  if (*(char *)(a1 + 663) < 0) {
    operator delete(*(void **)(a1 + 640));
  }
  sub_1002243E8(a1 + 232);
  sub_1004DD39C(a1 + 192);
  sub_1009A3824((uint64_t *)(a1 + 168));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 152);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 136);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 120);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  *(void *)(a1 + 8) = off_101A679C8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v9 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_100087E88((void *)(a1 + 40));
  return a1;
}

void sub_1009A3B18()
{
}

uint64_t sub_1009A3B2C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 72;
}

uint64_t sub_1009A3B38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1009A3B48(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009A3B64(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

unsigned __int8 *sub_1009A3B74(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = (void *)(a1 + 24);
  unint64_t v7 = sub_100206390(a1 + 24, (uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }
    BOOL v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      for (CFIndex i = *v13; i; CFIndex i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v8)
        {
          if (sub_1000609C0(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v15 >= v9) {
              v15 %= v9;
            }
          }
          else
          {
            v15 &= v9 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  memset(v25, 0, sizeof(v25));
  sub_1009A3E00(a1, v8, a3, v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_1001369F0(a1, v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }
  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v12);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *uint64_t v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v12) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v23 >= v9) {
          v23 %= v9;
        }
      }
      else
      {
        v23 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  CFIndex i = (unsigned __int8 *)v25[0];
  ++*v6;
  return i;
}

void sub_1009A3DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_1009A3EB0((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009A3E00@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  *a4 = 0;
  a4[2] = 0;
  a4[1] = 0;
  unint64_t v8 = a4 + 1;
  unint64_t v9 = operator new(0x28uLL);
  *a4 = v9;
  void *v8 = v7;
  *((unsigned char *)a4 + 16) = 0;
  *unint64_t v9 = 0;
  v9[1] = a2;
  uint64_t result = v9 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    result[2] = *(void *)(a3 + 16);
  }
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_1009A3E94(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1009A3EB0(v2, v3);
  _Unwind_Resume(a1);
}

void sub_1009A3EB0(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_1009A3F14(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009A3F4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009A3F7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1009A3FC0(void *a1)
{
  *a1 = off_101A22CD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[55];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1002243E8((uint64_t)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1009A4020(void *a1)
{
  *a1 = off_101A22CD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[55];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1002243E8((uint64_t)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1009A40A0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x1C0uLL);
  void *v2 = off_101A22CD0;
  sub_1009A42A8(v2 + 1, v1);
  return v2;
}

void sub_1009A40F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1009A4108(uint64_t a1, void *a2)
{
  *a2 = off_101A22CD0;
  return sub_1009A42A8(a2 + 1, (void *)(a1 + 8));
}

void sub_1009A4134(uint64_t a1)
{
}

void sub_1009A413C(void *a1)
{
  sub_1009A4324((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1009A4178(uint64_t a1, uint64_t a2, char *a3)
{
  char v12 = *a3;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    unint64_t v11 = v6;
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v10 = v7;
      if (!v7) {
        goto LABEL_8;
      }
      v9[0] = &v10;
      v9[1] = a2;
      _OWORD v9[2] = a1 + 432;
      v9[3] = &v12;
      uint8_t v9[4] = a1 + 24;
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_1009A437C;
      block[3] = &unk_101A22D40;
      block[4] = v7 + 40;
      block[5] = v9;
      unint64_t v8 = *(NSObject **)(v7 + 56);
      if (*(void *)(v7 + 64)) {
        dispatch_async_and_wait(v8, block);
      }
      else {
        dispatch_sync(v8, block);
      }
      uint64_t v6 = v11;
      if (v11) {
LABEL_8:
      }
        sub_10004D2C8(v6);
    }
  }
}

uint64_t sub_1009A425C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009A429C()
{
}

void *sub_1009A42A8(void *a1, void *a2)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100245B5C((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  uint64_t v5 = a2[54];
  a1[53] = a2[53];
  a1[54] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1009A430C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A4324(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 432);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1002243E8(a1 + 16);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

const void **sub_1009A437C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 40);
  uint64_t v2 = **(NSObject ***)(**v1 + 720);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = v1[1];
    if (*((char *)v3 + 23) < 0) {
      uint64_t v3 = (uint64_t *)*v3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Incoming call branded calling info: company image filepath is %s", buf, 0xCu);
  }
  uint64_t v4 = v1[1];
  uint64_t v5 = *((unsigned __int8 *)v4 + 23);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = v4[1];
  }
  if (v5 == 6)
  {
    if (v6 < 0) {
      uint64_t v4 = (uint64_t *)*v4;
    }
    int v7 = *(_DWORD *)v4;
    int v8 = *((unsigned __int16 *)v4 + 2);
    if (v7 == 1869902639 && v8 == 27491)
    {
      uint64_t v10 = **v1;
      unint64_t v11 = v1[2];
      uint64_t v13 = *v11;
      char v12 = (std::__shared_weak_count *)v11[1];
      uint64_t v15 = v13;
      float v16 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t, void))(*(void *)v10 + 312))(v10, &v15, 1, *(unsigned __int8 *)v1[3]);
      if (v16) {
        sub_10004D2C8(v16);
      }
    }
  }
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_100245B5C((uint64_t)buf, (uint64_t)v1[4]);
  std::string::operator=((std::string *)((char *)v35 + 8), (const std::string *)v1[1]);
  BYTE12(v36) = 0;
  (*(void (**)(void, uint8_t *))(**(void **)(**v1 + 128) + 88))(*(void *)(**v1 + 128), buf);
  return sub_1002243E8((uint64_t)buf);
}

void sub_1009A458C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009A45BC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1009A4640(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1009A46D8(uint64_t a1)
{
  sub_100C62700(a1, "kCPGetSIMSubscriptionStatus", (unint64_t)sub_1009A488C, 3u);
  sub_100C62700(a1, "kCPProbeSIMConnectivity", (unint64_t)sub_1009A4978, 3u);
  sub_100C62700(a1, "kCPCopyRemoteMobileEquipmentInfo", (unint64_t)sub_1009A4B74, 3u);
  sub_100C62700(a1, "kCPGetNumberOfDeletablePlansInstalled", (unint64_t)sub_1009A4CD8, 3u);
  sub_100C62630(a1, "kCPReprovisionSim", (unint64_t)sub_1009A4F24, 3u);
  sub_100C62630(a1, "kCPResetSim", (unint64_t)sub_1009A508C, 3u);
  sub_100C62700(a1, "kCPStandaloneOverrideSelection", (unint64_t)sub_1009A51F4, 0x14u);
  sub_100C62630(a1, "kCPStandaloneOverrideSelectionLegacy", (unint64_t)sub_1009A5508, 3u);
  sub_100C62630(a1, "kCPStandaloneOverrideSelectionReset", (unint64_t)sub_1009A5778, 3u);
  sub_100C62700(a1, "kCPStandaloneGetCacheVinylInfo", (unint64_t)sub_1009A59B8, 0x14u);

  return sub_100C62700(a1, "kCPStandaloneDownloadProfile", (unint64_t)sub_1009A5AA4, 0x14u);
}

void sub_1009A488C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_100058DB0(&v8, "/cc/props/cellular_plan_remotesubscription_info");
  int v6 = *(std::__shared_weak_count **)(a5 + 8);
  int v7 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::RestModule::getPropertyOnce();
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1009A4950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A4978(Registry **a1@<X0>, unint64_t *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  int v6 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      int v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = (unint64_t)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    unint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  unint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_7:
    xpc_object_t v16 = xpc_int64_create(0);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    v15[0] = *a2;
    v15[1] = (unint64_t)"kCPProbeSIMConnectivityStatus";
    sub_100035E70((uint64_t)v15, &v16, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
    goto LABEL_16;
  }
LABEL_12:
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 1174405120;
  v18[2] = sub_1009A6740;
  uint64_t v18[3] = &unk_101A22DB8;
  uint64_t v14 = (std::__shared_weak_count *)a2[1];
  uint8_t v18[4] = *a2;
  long long v19 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v12 + 32))(v12, v18);
  if (v19) {
    sub_10004D2C8(v19);
  }
LABEL_16:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1009A4B4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A4B74(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  sub_100058DB0(&__p, "/cc/props/cellular_plan_remotesubscription_info");
  uint64_t v8 = *a5;
  uint64_t v7 = a5[1];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *a1;
  unsigned int v9 = (std::__shared_weak_count *)a1[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = 0;
  unint64_t v11 = operator new(0x28uLL);
  *unint64_t v11 = off_101A22DF8;
  v11[1] = v8;
  dispatch_object_t v11[2] = v7;
  void v11[3] = v10;
  v11[4] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = v11;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(v14);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
}

void sub_1009A4C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009A4CD8(capabilities::ct *a1, uint64_t a2, uint64_t a3, uint64_t a4, void ***a5)
{
  int v7 = capabilities::ct::cellularPlanDeleteSupportedOnVinylSlotID(a1);
  if (v7)
  {
    int v9 = v7;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)a1);
    unint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v29 = v12;
    xpc_object_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v29);
    if (v16)
    {
      uint64_t v18 = v16[3];
      float v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        if (!v18)
        {
LABEL_22:
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          return;
        }
LABEL_11:
        long long v29 = 0u;
        long long v30 = 0u;
        uint64_t v20 = VinylSlotIdFromInt(v9);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 216))(&v29, v18, v20);
        int valuePtr = 0;
        if (BYTE8(v30))
        {
          uint64_t v21 = v29;
          if ((void)v29 == *((void *)&v29 + 1))
          {
            int v22 = 0;
          }
          else
          {
            int v22 = 0;
            do
            {
              if (!*(unsigned char *)(v21 + 88)) {
                ++v22;
              }
              v21 += 216;
            }
            while (v21 != *((void *)&v29 + 1));
          }
          int valuePtr = v22;
        }
        long long v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
        ctu::cf_to_xpc((uint64_t *)&v25, v27, v23);
        v24[0] = *a5;
        v24[1] = (void **)"kCPNumberOfDeletablePlansInstalled";
        sub_100035E70((uint64_t)v24, &v25, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v25);
        xpc_object_t v25 = 0;
        sub_1000570E8((const void **)&v27);
        if (BYTE8(v30))
        {
          v24[0] = (void **)&v29;
          sub_1000C57C8(v24);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    float v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_22;
    }
    goto LABEL_11;
  }
}

void sub_1009A4ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_1000570E8(&a13);
  if (a18)
  {
    a9 = (void **)&a15;
    sub_1000C57C8(&a9);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_1009A4F24(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v14 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
LABEL_11:
      (*(void (**)(uint64_t))(*(void *)v10 + 40))(v10);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (v10) {
    goto LABEL_11;
  }
LABEL_7:
  sub_1009A6E10();
  uint64_t v12 = qword_101B0E2B8;
  if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v13 = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N no controller to send sim reprovision", v13, 2u);
  }
LABEL_12:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_1009A506C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A508C(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v14 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
LABEL_11:
      (*(void (**)(uint64_t))(*(void *)v10 + 72))(v10);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (v10) {
    goto LABEL_11;
  }
LABEL_7:
  sub_1009A6E10();
  uint64_t v12 = qword_101B0E2B8;
  if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v13 = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N no controller to send debug sim reset", v13, 2u);
  }
LABEL_12:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_1009A51D4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A51F4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  uint64_t v8 = ServiceMap;
  int v9 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      int v9 = (char *)v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_20;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_20:
    sub_1009A6E10();
    char v19 = qword_101B0E2B8;
    if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N no controller to send override selection", (uint8_t *)&__p, 2u);
    }
    xpc_object_t v20 = xpc_BOOL_create(0);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    std::string __p = *(void **)a5;
    long long v27 = "kCPStandaloneOverrideSelectionResult";
    sub_100035E70((uint64_t)&__p, &v20, &v21);
    xpc_release(v21);
    xpc_object_t v21 = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
    if (v16) {
      return;
    }
LABEL_18:
    sub_10004D2C8(v14);
    return;
  }
LABEL_10:
  if (!xpc_dictionary_get_value(*a4, "kCPStandaloneIccid")) {
    goto LABEL_20;
  }
  v22[0] = a4;
  v22[1] = "kCPStandaloneIccid";
  sub_100048BAC((uint64_t)v22, &object);
  std::string __p = 0;
  long long v27 = 0;
  uint64_t v28 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  uint64_t v18 = *(void **)a5;
  uint64_t v17 = *(void *)(a5 + 8);
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  v29[0] = off_101A22E78;
  v29[1] = v18;
  void v29[2] = v17;
  v29[3] = v29;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v15 + 80))(v15, &v24, v29);
  sub_100060644(v29);
  if (v25 < 0) {
    operator delete(v24);
  }
  xpc_release(object);
  if ((v16 & 1) == 0) {
    goto LABEL_18;
  }
}

void sub_1009A5480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1009A5508(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  uint64_t v6 = ServiceMap;
  unsigned int v7 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unsigned int v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  unsigned int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13)
  {
LABEL_16:
    sub_1009A6E10();
    uint64_t v15 = qword_101B0E2B8;
    if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N missing parameter (controller or iccid", (uint8_t *)__p, 2u);
    }
    goto LABEL_18;
  }
LABEL_10:
  if (!xpc_dictionary_get_value(*a4, "kCPStandaloneIccid")) {
    goto LABEL_16;
  }
  v16[0] = a4;
  v16[1] = "kCPStandaloneIccid";
  sub_100048BAC((uint64_t)v16, &object);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v21 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v22[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v13 + 80))(v13, &v18, v22);
  sub_100060644(v22);
  if (v19 < 0) {
    operator delete(v18);
  }
  xpc_release(object);
LABEL_18:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_1009A5700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1009A5778(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  char v2 = ServiceMap;
  uint64_t v3 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = (const char *)v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v3;
  unsigned int v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)__p);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
  if (!v9)
  {
LABEL_7:
    sub_1009A6E10();
    uint64_t v11 = qword_101B0E2B8;
    if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N no controller to reset override selection", (uint8_t *)__p, 2u);
      if (v10) {
        return;
      }
      goto LABEL_14;
    }
LABEL_13:
    if (v10) {
      return;
    }
    goto LABEL_14;
  }
LABEL_12:
  sub_100058DB0(__p, "");
  uint64_t v15 = 0;
  v14[0] = off_1019CC928;
  v14[1] = _Block_copy(&stru_101A22F08);
  uint64_t v15 = v14;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v9 + 80))(v9, __p, v14);
  sub_100060644(v14);
  if ((v13 & 0x80000000) == 0) {
    goto LABEL_13;
  }
  operator delete(__p[0]);
  if (v10) {
    return;
  }
LABEL_14:
  sub_10004D2C8(v8);
}

void sub_1009A5960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A59B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_100058DB0(&v8, "/cc/props/vinyl_info");
  unsigned int v6 = *(std::__shared_weak_count **)(a5 + 8);
  unsigned int v7 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::RestModule::getPropertyOnce();
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1009A5A7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A5AA4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  char v9 = ServiceMap;
  char v10 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
  if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      char v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v18 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v18 = 1;
LABEL_9:
  char v19 = (std::mutex *)Registry::getServiceMap(v17, *a1);
  xpc_object_t v20 = v19;
  uint64_t v21 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    int v22 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = (const char *)v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  __p[0] = (void *)v21;
  char v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)__p);
  if (v25)
  {
    uint64_t v27 = v25[3];
    long long v26 = (std::__shared_weak_count *)v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      char v28 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v20);
  long long v26 = 0;
  char v28 = 1;
LABEL_17:
  if (v16 | v27)
  {
    if (xpc_dictionary_get_value(*a4, "kCPStandaloneProfileServer")
      && xpc_dictionary_get_value(*a4, "kCPStandaloneCsn"))
    {
      int v83 = 0;
      __p[0] = a4;
      __p[1] = "kCPStandaloneProfileServer";
      sub_100048BAC((uint64_t)__p, &v79);
      xpc::bridge((uint64_t *)buf, (xpc *)&v79, v29);
      sub_100056248(&v83, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      xpc_release(v79);
      __int16 v82 = 0;
      __p[0] = a4;
      __p[1] = "kCPStandaloneCsn";
      sub_100048BAC((uint64_t)__p, &v79);
      xpc::bridge((uint64_t *)buf, (xpc *)&v79, v30);
      sub_100056248(&v82, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      xpc_release(v79);
      if (v83) {
        long long v31 = sub_1000810B8;
      }
      else {
        long long v31 = 0;
      }
      if (!v31) {
        goto LABEL_76;
      }
      if (!(v82 ? sub_1000810B8 : 0)) {
        goto LABEL_76;
      }
      long long v86 = 0uLL;
      CFTypeRef v79 = 0;
      long long v80 = 0;
      uint64_t v81 = 0;
      memset(__p, 0, 24);
      ctu::cf::assign();
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      *(void **)&uint8_t buf[16] = __p[2];
      ctu::parse_hex();
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (v80 - (char *)v79 != 16)
      {
        sub_1009A6E10();
        uint64_t v41 = qword_101B0E2B8;
        if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I invalid csn", (uint8_t *)__p, 2u);
        }
        xpc_object_t v49 = xpc_BOOL_create(0);
        if (!v49) {
          xpc_object_t v49 = xpc_null_create();
        }
        __p[0] = *(void **)a5;
        __p[1] = "kCPStandaloneProfileResult";
        sub_100035E70((uint64_t)__p, &v49, &v50);
        xpc_release(v50);
        xpc_object_t v50 = 0;
        xpc_release(v49);
        xpc_object_t v49 = 0;
        goto LABEL_74;
      }
      long long v86 = *v79;
      uint64_t v78 = 0;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      memset(__p, 0, sizeof(__p));
      sub_10030A548((uint64_t)__p);
      memset(buf, 0, 24);
      long long v33 = (capabilities::ct *)ctu::cf::assign();
      long long v34 = *(void **)buf;
      v85[0] = *(void *)&buf[8];
      *(void *)((char *)v85 + 7) = *(void *)&buf[15];
      uint8_t v35 = buf[23];
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      __p[0] = v34;
      __p[1] = (void *)v85[0];
      *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v85 + 7);
      HIBYTE(__p[2]) = v35;
      if (v16)
      {
        sub_1009A6E10();
        long long v36 = qword_101B0E2B8;
        if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I watchController fetches profile", buf, 2u);
        }
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 1174405120;
        v61[2] = sub_1009A72F4;
        v61[3] = &unk_101A22F58;
        long long v37 = *(std::__shared_weak_count **)(a5 + 8);
        v61[4] = *(void *)a5;
        int v62 = v37;
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, long long *, void **, void *))(*(void *)v16 + 88))(v16, &v86, __p, v61);
        long long v38 = v62;
        if (!v62) {
          goto LABEL_73;
        }
      }
      else
      {
        if (!v27) {
          goto LABEL_73;
        }
        if (!capabilities::ct::defaultVinylCardTypeToGSMA(v33))
        {
          sub_1009A6E10();
          uint64_t v44 = qword_101B0E2B8;
          if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I unsupported device", buf, 2u);
          }
          xpc_object_t v51 = xpc_BOOL_create(0);
          if (!v51) {
            xpc_object_t v51 = xpc_null_create();
          }
          *(void *)long long buf = *(void *)a5;
          *(void *)&uint8_t buf[8] = "kCPStandaloneProfileResult";
          sub_100035E70((uint64_t)buf, &v51, &v52);
          xpc_release(v52);
          xpc_object_t v52 = 0;
          xpc_release(v51);
          xpc_object_t v51 = 0;
          goto LABEL_73;
        }
        sub_1009A6E10();
        char v42 = qword_101B0E2B8;
        if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I ipadController fetches profile", buf, 2u);
        }
        sub_100083DA4(&v60, &v83);
        long long v58 = 0;
        uint64_t v59 = 0;
        unsigned int v56 = 0;
        long long v57 = 0;
        v53[0] = _NSConcreteStackBlock;
        v53[1] = 1174405120;
        v53[2] = sub_1009A7430;
        v53[3] = &unk_101A22F88;
        char v43 = *(std::__shared_weak_count **)(a5 + 8);
        v53[4] = *(void *)a5;
        long long v54 = v43;
        uint64_t v55 = 0;
        if (v43) {
          atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, const void **, const void **, const void **, const void **, _BYTE, const void **, const void **, void *))(*(void *)v27 + 272))(v27, 10, 1, 1, 0, &v60, &v59, &v58, &v57, 0, &v56, &v55, v53);
        sub_1000558F4(&v55);
        sub_1000558F4(&v56);
        sub_1000558F4(&v57);
        sub_1000558F4(&v58);
        sub_1000558F4(&v59);
        sub_1000558F4(&v60);
        long long v38 = v54;
        if (!v54)
        {
LABEL_73:
          sub_10030A89C((uint64_t)__p);
LABEL_74:
          if (v79)
          {
            long long v80 = (char *)v79;
            operator delete(v79);
          }
LABEL_76:
          sub_1000558F4(&v82);
          sub_1000558F4(&v83);
          if (v28) {
            goto LABEL_52;
          }
LABEL_51:
          sub_10004D2C8(v26);
          goto LABEL_52;
        }
      }
      sub_10004D2C8(v38);
      goto LABEL_73;
    }
    sub_1009A6E10();
    long long v40 = qword_101B0E2B8;
    if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I missing parameters", (uint8_t *)__p, 2u);
    }
    xpc_object_t v47 = xpc_BOOL_create(0);
    if (!v47) {
      xpc_object_t v47 = xpc_null_create();
    }
    __p[0] = *(void **)a5;
    __p[1] = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)__p, &v47, &v48);
    xpc_release(v48);
    xpc_object_t v48 = 0;
    xpc_release(v47);
    xpc_object_t v47 = 0;
    if ((v28 & 1) == 0) {
      goto LABEL_51;
    }
  }
  else
  {
    sub_1009A6E10();
    long long v39 = qword_101B0E2B8;
    if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#N no controller to download profile", (uint8_t *)__p, 2u);
    }
    xpc_object_t v45 = xpc_BOOL_create(0);
    if (!v45) {
      xpc_object_t v45 = xpc_null_create();
    }
    __p[0] = *(void **)a5;
    __p[1] = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)__p, &v45, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v45);
    xpc_object_t v45 = 0;
    if ((v28 & 1) == 0) {
      goto LABEL_51;
    }
  }
LABEL_52:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1009A6314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,__int16 a39,char a40,char a41,int a42,__int16 a43,char a44,char a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A64E0(uint64_t a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null)
  {
    unsigned int v5 = 0;
  }
  else
  {
    uint64_t v20 = 0;
    *(_OWORD *)std::string __p = 0u;
    long long v19 = 0u;
    *(_OWORD *)uint64_t v16 = 0u;
    long long v17 = 0u;
    *(_OWORD *)char v14 = 0u;
    long long v15 = 0u;
    cellplan::read_rest_value((cellplan *)v14, a2, v4);
    unsigned int v5 = DWORD2(v15);
    if (LOBYTE(__p[0]))
    {
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[1]);
      }
      LOBYTE(__p[0]) = 0;
    }
    if (LOBYTE(v16[0]))
    {
      if (SHIBYTE(v17) < 0) {
        operator delete(v16[1]);
      }
      LOBYTE(v16[0]) = 0;
    }
    if (SBYTE7(v15) < 0) {
      operator delete(v14[0]);
    }
  }
  xpc_object_t v13 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v13 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v13 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_21;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_20:
  xpc_object_t v13 = v8;
LABEL_21:
  xpc_release(v7);
  xpc_object_t v11 = xpc_int64_create(v5);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  v14[0] = &v13;
  v14[1] = "kCTCellularPlanSimSubscriptionStatusKey";
  sub_100035E70((uint64_t)v14, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v9 = v13;
  if (v13) {
    xpc_retain(v13);
  }
  else {
    xpc_object_t v9 = xpc_null_create();
  }
  v14[0] = *(void **)(a1 + 32);
  v14[1] = "kCPSIMSubscriptionStatus";
  sub_10014E03C((uint64_t)v14, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v13);
}

void sub_1009A66EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1009A6740(uint64_t a1, int a2)
{
  uint64_t v3 = (a2 - 1);
  if (v3 < 4) {
    int64_t v4 = v3 + 1;
  }
  else {
    int64_t v4 = 0;
  }
  xpc_object_t v6 = xpc_int64_create(v4);
  if (!v6) {
    xpc_object_t v6 = xpc_null_create();
  }
  v5[0] = *(void *)(a1 + 32);
  v5[1] = "kCPProbeSIMConnectivityStatus";
  sub_100035E70((uint64_t)v5, &v6, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v6);
}

void *sub_1009A67CC(void *a1)
{
  *a1 = off_101A22DF8;
  char v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1009A6824(void *a1)
{
  *a1 = off_101A22DF8;
  char v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_1009A689C(void *a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A22DF8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1009A6910(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A22DF8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009A6960(uint64_t a1)
{
}

void sub_1009A6968(void *a1)
{
  sub_10000ACD0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1009A69A4(uint64_t a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_null) {
    return;
  }
  uint64_t v28 = 0;
  *(_OWORD *)long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)unsigned int v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)int v22 = 0u;
  long long v23 = 0u;
  cellplan::read_rest_value((cellplan *)v22, (cellplan::RemoteSimSubscriptionInfo *)a2, v4);
  xpc_object_t v19 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v19 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v19 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_9;
    }
  }
  if (xpc_get_type(v6) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v7 = xpc_null_create();
LABEL_9:
    xpc_object_t v19 = v7;
    goto LABEL_10;
  }
  xpc_retain(v6);
LABEL_10:
  xpc_release(v6);
  if (LOBYTE(v24[0]))
  {
    if (v25 >= 0) {
      xpc_object_t v8 = (const char *)&v24[1];
    }
    else {
      xpc_object_t v8 = (const char *)v24[1];
    }
    xpc_object_t v17 = xpc_string_create(v8);
    if (!v17) {
      xpc_object_t v17 = xpc_null_create();
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0uLL;
    uint64_t v14 = 0;
    xpc_object_t v15 = &v19;
    uint64_t v16 = __p;
    sub_100035E70((uint64_t)&v15, &v17, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v17);
    xpc_object_t v17 = 0;
  }
  if (LOBYTE(v26[0]))
  {
    if (v27 >= 0) {
      xpc_object_t v9 = (const char *)&v26[1];
    }
    else {
      xpc_object_t v9 = (const char *)v26[1];
    }
    xpc_object_t v11 = xpc_string_create(v9);
    if (!v11) {
      xpc_object_t v11 = xpc_null_create();
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v20;
    uint64_t v14 = v21;
    xpc_object_t v10 = __p;
    if (v21 < 0) {
      xpc_object_t v10 = (void **)v20;
    }
    xpc_object_t v15 = &v19;
    uint64_t v16 = v10;
    sub_100035E70((uint64_t)&v15, &v11, &v12);
    xpc_release(v12);
    xpc_object_t v12 = 0;
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v11);
    xpc_object_t v11 = 0;
  }
  xpc_object_t v15 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  *(void *)&long long v20 = *(void *)(a1 + 8);
  *((void *)&v20 + 1) = "kCPRemoteMobileEquipmentInfo";
  sub_10014E03C((uint64_t)&v20, &v15, __p);
  xpc_release(__p[0]);
  __p[0] = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v19);
  if (LOBYTE(v26[0]))
  {
    if (SHIBYTE(v27) < 0) {
      operator delete(v26[1]);
    }
    LOBYTE(v26[0]) = 0;
  }
  if (LOBYTE(v24[0]))
  {
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[1]);
    }
    LOBYTE(v24[0]) = 0;
  }
  if (SBYTE7(v23) < 0) {
    operator delete(v22[0]);
  }
}

void sub_1009A6CC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, uint64_t a18, xpc_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1009A6DC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009A6E04()
{
}

void sub_1009A6E10()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E2C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0E2C0))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0E2B8, kCtLoggingSystemName, "cp.xpc");
    __cxa_guard_release(&qword_101B0E2C0);
  }
}

void sub_1009A6E90(_Unwind_Exception *a1)
{
}

void *sub_1009A6EA8(void *a1)
{
  *a1 = off_101A22E78;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1009A6EF4(void *a1)
{
  *a1 = off_101A22E78;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1009A6F60(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A22E78;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1009A6FBC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A22E78;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009A6FF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1009A7004(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1009A7044(uint64_t a1, BOOL *a2)
{
  xpc_object_t v4 = xpc_BOOL_create(*a2);
  if (!v4) {
    xpc_object_t v4 = xpc_null_create();
  }
  v3[0] = *(void *)(a1 + 8);
  v3[1] = "kCPStandaloneOverrideSelectionResult";
  sub_100035E70((uint64_t)v3, &v4, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v4);
}

uint64_t sub_1009A70C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009A7108()
{
}

void sub_1009A7118(uint64_t a1, xpc_object_t *a2)
{
  if (xpc_get_type(*a2) != (xpc_type_t)&_xpc_type_null)
  {
    *(void *)long long buf = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10010C4E0((uint64_t *)buf, a2);
    xpc_object_t object = 0;
    xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v5 = v4;
    if (v4)
    {
      xpc_object_t object = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t object = v5;
      if (!v5)
      {
        xpc_object_t v7 = xpc_null_create();
        xpc_object_t v5 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v5);
LABEL_12:
      xpc_release(v5);
      sub_100CD1034((int **)buf, (char *)&object);
      xpc_object_t v9 = object;
      if (object) {
        xpc_retain(object);
      }
      else {
        xpc_object_t v9 = xpc_null_create();
      }
      v8[0] = *(void ***)(a1 + 32);
      v8[1] = (void **)"kCPStandaloneCachedVinylInfoResult";
      sub_10014E03C((uint64_t)v8, &v9, &v10);
      xpc_release(v10);
      xpc_object_t v10 = 0;
      xpc_release(v9);
      xpc_object_t v9 = 0;
      xpc_release(object);
      v8[0] = (void **)buf;
      sub_1000C56F4(v8);
      return;
    }
    xpc_object_t v7 = xpc_null_create();
LABEL_11:
    xpc_object_t object = v7;
    goto LABEL_12;
  }
  sub_1009A6E10();
  xpc_object_t v6 = qword_101B0E2B8;
  if (os_log_type_enabled((os_log_t)qword_101B0E2B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N No vinyl info found", buf, 2u);
  }
}

void sub_1009A72B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, char a15)
{
  a10 = &a15;
  sub_1000C56F4((void ***)&a10);
  _Unwind_Resume(a1);
}

void sub_1009A72F4(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 == 1)
  {
    xpc_object_t v5 = xpc_BOOL_create(a2[1]);
    if (!v5) {
      xpc_object_t v5 = xpc_null_create();
    }
    uint64_t v7 = *(void *)(a1 + 32);
    xpc_object_t v8 = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)&v7, &v5, &v6);
    xpc_release(v6);
    xpc_object_t v6 = 0;
    xpc_release(v5);
  }
  else
  {
    if (v3 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    xpc_object_t object = xpc_BOOL_create(0);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    uint64_t v7 = *(void *)(a1 + 32);
    xpc_object_t v8 = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)&v7, &object, &v10);
    xpc_release(v10);
    xpc_object_t v10 = 0;
    xpc_release(object);
  }
}

void sub_1009A7404(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009A7430(uint64_t a1, int a2)
{
  if (a2)
  {
    xpc_object_t v3 = xpc_BOOL_create(0);
    if (!v3) {
      xpc_object_t v3 = xpc_null_create();
    }
    uint64_t v5 = *(void *)(a1 + 32);
    xpc_object_t v6 = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)&v5, &v3, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v3);
  }
  else
  {
    xpc_object_t v7 = xpc_BOOL_create(1);
    if (!v7) {
      xpc_object_t v7 = xpc_null_create();
    }
    uint64_t v5 = *(void *)(a1 + 32);
    xpc_object_t v6 = "kCPStandaloneProfileResult";
    sub_100035E70((uint64_t)&v5, &v7, &v8);
    xpc_release(v8);
    xpc_object_t v8 = 0;
    xpc_release(v7);
  }
}

uint64_t sub_1009A7518()
{
  return sub_100C624B8((uint64_t)&unk_101B0E2B2, (uint64_t)sub_1009A46D8);
}

void *TetheringAssertion::TetheringAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "tethering");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A23268;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A22FC8;
  return a1;
}

void sub_1009A75D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TetheringAssertion::create()
{
}

void sub_1009A7660()
{
}

uint64_t sub_1009A7684(Registry *a1)
{
  uint64_t v2 = 0;
  xpc_object_t v3 = 0;
  sub_1003BEF68(a1, &v2);
  if (v2) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 448))(v2, 1);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  return 1;
}

void sub_1009A76FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A7714(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  xpc_object_t v4 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v5 = a3;
    }
    else {
      uint64_t v5 = (uint64_t *)*a3;
    }
    int v6 = 136315138;
    xpc_object_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its tethering assertion.", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1009A77C0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 32);
  BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    LOWORD(v4) = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I No more tethering assertion. Taking it down.", (uint8_t *)&v4, 2u);
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  sub_1003BEF68((Registry *)v2, &v4);
  uint64_t v3 = v4;
  if (v4)
  {
    (*(void (**)(uint64_t, void))(*(void *)v4 + 448))(v4, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 8))(v3, 16, 1);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009A78A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *SuspendDormancyAssertion::SuspendDormancyAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "suspend dormancy");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A23320;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A23008;
  return a1;
}

void sub_1009A7960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void SuspendDormancyAssertion::create()
{
}

void sub_1009A79E8()
{
}

uint64_t sub_1009A7A0C@<X0>(uint64_t a1@<X0>, xpc_object_t *a2@<X1>, uint64_t *a3@<X8>)
{
  long long v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 40));
  char v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v7;
  xpc_object_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v21);
  if (v11)
  {
    uint64_t v13 = v11[3];
    xpc_object_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  xpc_object_t v12 = 0;
  char v14 = 1;
LABEL_9:
  xpc_object_t v15 = (capabilities::ct *)(*(void *(**)(void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v13 + 32))(&v23, v13, kCarrier1BundleId, @"DormancyAssertionExpirationPeriodSec", 0, 0);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  uint64_t v16 = v23;
  if (capabilities::ct::dormancyWatchMode(v15)) {
    int v17 = 30;
  }
  else {
    int v17 = 0;
  }
  LODWORD(v21) = v17;
  if (v16)
  {
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v21, (int *)v16, v19);
      int v17 = v21;
    }
  }
  sub_1000577C4((const void **)&v23);
  *(void *)(a1 + 152) = v17;
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_connection && SuspendDormancyAssertion::allow_suspend_dormancy)
  {
    unint64_t v21 = 0;
    int v22 = 0;
    sub_100068A94(&v21);
    if (v21) {
      (*(void (**)(unint64_t, uint64_t))(*(void *)v21 + 288))(v21, 1);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
  }
  return 1;
}

void sub_1009A7C0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A7C48(void *a1, xpc_object_t *a2, uint64_t *a3)
{
  char v6 = a1[4];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = (uint64_t *)*a3;
    }
    LODWORD(v12) = 136315138;
    *(void *)((char *)&v12 + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its suspend dormancy assertion.", (uint8_t *)&v12, 0xCu);
  }
  long long v12 = 0uLL;
  sub_100068A94(&v12);
  if ((void)v12)
  {
    uint64_t v8 = a1[10];
    uint64_t v9 = a1[11];
    if (v8 != v9)
    {
      uint64_t v10 = v8 + 32;
      while (!xpc_equal(*(xpc_object_t *)(v10 - 8), *a2))
      {
        uint64_t v11 = v10 + 16;
        v10 += 48;
        if (v11 == v9) {
          goto LABEL_13;
        }
      }
      (*(void (**)(void, uint64_t *, uint64_t))(*(void *)v12 + 312))(v12, a3, v10);
    }
  }
LABEL_13:
  if (*((void *)&v12 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
  }
}

void sub_1009A7D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A7DB4()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100068A94(&v0);
  if (v0) {
    (*(void (**)(uint64_t, void))(*(void *)v0 + 288))(v0, 0);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1009A7E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *OTAActivationAssertion::OTAActivationAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "ota activation");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A233D8;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A23048;
  return a1;
}

void sub_1009A7EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void OTAActivationAssertion::create()
{
}

void sub_1009A7F6C()
{
}

uint64_t sub_1009A7F90(uint64_t a1)
{
  sub_100DD3B64(a1, &v5);
  uint64_t v2 = v5;
  uint64_t v1 = v6;
  unint64_t v7 = (void **)&v5;
  sub_100047F64(&v7);
  if (v1 == (std::__shared_weak_count *)v2)
  {
    uint64_t v5 = 0;
    char v6 = 0;
    sub_1003BEF68(v3, &v5);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 184))(v5, 1);
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  return 1;
}

void sub_1009A802C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A8044(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v5 = a3;
    }
    else {
      uint64_t v5 = (uint64_t *)*a3;
    }
    int v6 = 136315138;
    unint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its OTA activation assertion.", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1009A80F0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 32);
  BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    LOWORD(v12) = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I No more OTA Activation assertion. Taking it down", (uint8_t *)&v12, 2u);
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_1003BEF68((Registry *)v2, &v15);
  uint64_t v3 = v15;
  if (v15)
  {
    (*(void (**)(uint64_t, void))(*(void *)v15 + 184))(v15, 0);
    subscriber::makeSimSlotRange();
    uint64_t v5 = v12;
    uint64_t v4 = v13;
    if (v12 != v13)
    {
      int v6 = v14;
      while ((v6(*v5) & 1) == 0)
      {
        if (++v5 == v4)
        {
          uint64_t v5 = v4;
          break;
        }
      }
      unint64_t v7 = v13;
      if (v5 != v13)
      {
        uint64_t v8 = v16;
        do
        {
          uint64_t v9 = *v5;
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeID v18 = 0;
          uint64_t v10 = operator new(0x20uLL);
          void *v10 = off_101A23490;
          v10[1] = v3;
          void v10[2] = v8;
          *((_DWORD *)v10 + 6) = v9;
          CFTypeID v18 = v10;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v3 + 600))(v3, v9, 9, v17);
          sub_1000606C8(v17);
          uint64_t v11 = v5 + 1;
          uint64_t v5 = v4;
          if (v11 != v4)
          {
            uint64_t v5 = v11;
            while ((v6(*v5) & 1) == 0)
            {
              if (++v5 == v4)
              {
                uint64_t v5 = v4;
                break;
              }
            }
          }
        }
        while (v5 != v7);
      }
    }
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_1009A8300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, char a14)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void *DataActivationPopupAssertion::DataActivationPopupAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "popup-suppression");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A23510;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A23088;
  return a1;
}

void sub_1009A83F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DataActivationPopupAssertion::create()
{
}

void sub_1009A847C()
{
}

uint64_t sub_1009A84A0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = (uint64_t *)*a3;
    }
    *(_DWORD *)CFNumberRef v19 = 136315138;
    *(void *)&v19[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Add DataActivationPopupAssertion assertion for app %s", v19, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 40));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFNumberRef v19 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v19);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_14:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
LABEL_15:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v16 + 48))(v16, 52, a3);
LABEL_16:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  return 1;
}

void sub_1009A8640(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A8670(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = (uint64_t *)*a3;
    }
    *(_DWORD *)CFTypeID v18 = 136315138;
    *(void *)&uint8_t v18[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Remove DataActivationPopupAssertion assertion for app %s", v18, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 40));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFTypeID v18 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v18);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_14:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
LABEL_15:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v16 + 56))(v16, 52, a3);
LABEL_16:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1009A880C(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A883C(uint64_t a1)
{
  char v1 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I No more DataActivationPopupAssertion assertion. Taking it down", v2, 2u);
  }
}

void *InternetAssertion::InternetAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "internet");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A235C8;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A230C8;
  return a1;
}

void sub_1009A8940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void InternetAssertion::create()
{
}

void sub_1009A89C8()
{
}

void InternetAssertion::getAssertions(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_100058DB0(__p, "internet");
  sub_100C658AC((long long *)__p, (uint64_t)a1);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1009A8A48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009A8A64(Registry *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  sub_1003BEF68(a1, &v4);
  uint64_t v1 = v4;
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 440))(v4, 1);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 16, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 0x8000000, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 1, 0);
    uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 776))(v1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v1 + 176))(v1, v2, 36, 0);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  return 1;
}

void sub_1009A8BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A8BEC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 32);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (*((char *)a3 + 23) >= 0) {
      char v6 = a3;
    }
    else {
      char v6 = (uint64_t *)*a3;
    }
    LODWORD(v8) = 136315138;
    *(void *)((char *)&v8 + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its internet assertion", (uint8_t *)&v8, 0xCu);
  }
  long long v8 = 0uLL;
  sub_1003BEF68((Registry *)v5, &v8);
  uint64_t v7 = v8;
  if ((void)v8)
  {
    (*(void (**)(void, uint64_t, void))(*(void *)v8 + 8))(v8, 16, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v7 + 8))(v7, 0x8000000, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v7 + 8))(v7, 1, 0);
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
}

void sub_1009A8D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_1009A8D68(Registry *a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_1003BEF68(a1, &v3);
  uint64_t v1 = v3;
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 440))(v3, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 16, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 0x8000000, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1 + 8))(v1, 1, 0);
  }
  uint64_t v2 = v4;
  if (v4)
  {
    sub_10004D2C8(v2);
  }
}

void sub_1009A8E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *CTKeepAliveAssertion::CTKeepAliveAssertion(void *a1, void *a2)
{
  sub_100058DB0(__p, "CT Keep Alive");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "pkt", 0);
  *a1 = off_101A23680;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A23108;
  a1[21] = 0;
  a1[22] = 0;
  return a1;
}

void sub_1009A8F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CTKeepAliveAssertion::create()
{
}

void sub_1009A8FD4()
{
}

uint64_t sub_1009A8FF8(uint64_t a1, xpc_connection_t *a2, uint64_t *a3)
{
  if (!*(void *)(a1 + 168))
  {
    *(_OWORD *)&v21[8] = 0u;
    long long v22 = 0u;
    char v6 = *(NSObject **)(a1 + 32);
    os_signpost_id_t v7 = os_signpost_id_generate(v6);
    if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      long long v8 = *(NSObject **)(a1 + 32);
      if (os_signpost_enabled(v8))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_INTERVAL_BEGIN, v7, "CTKeepAliveAssertion", (const char *)&unk_1017DEDA7, buf, 2u);
      }
    }
    *(void *)long long buf = off_101A23738;
    unsigned int v24 = buf;
    *(void *)long long v20 = v7;
    *(void *)unint64_t v21 = os_retain(v6);
    sub_1000336E8((uint64_t)&v21[8], (uint64_t)buf);
    sub_100033A10(buf);
    sub_100058DB0(&__p, "CTKeepAlive");
    v18[0] = *(void *)v20;
    v18[1] = *(void *)v21;
    sub_1000336E8((uint64_t)&v19, (uint64_t)&v21[8]);
    *(void *)long long v20 = 0;
    *(void *)unint64_t v21 = 0;
    sub_100033AF4(&v21[8]);
    Registry::createXpcJetsamAssertion();
    long long v9 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 176);
    *(_OWORD *)(a1 + 168) = v9;
    if (v10)
    {
      sub_10004D2C8(v10);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    sub_1000339DC(v18);
    if (v17 < 0) {
      operator delete(__p);
    }
    sub_1000339DC((uint64_t *)v20);
  }
  uint64_t v11 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    pid_t pid = xpc_connection_get_pid(*a2);
    xpc_connection_t v13 = *a2;
    if (*((char *)a3 + 23) >= 0) {
      char v14 = a3;
    }
    else {
      char v14 = (uint64_t *)*a3;
    }
    *(_DWORD *)long long v20 = 67109634;
    *(_DWORD *)&int v20[4] = pid;
    *(_WORD *)unint64_t v21 = 2048;
    *(void *)&v21[2] = v13;
    *(_WORD *)&v21[10] = 2080;
    *(void *)&v21[12] = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %d(%p) requested CT Keep Alive assertion '%s'", v20, 0x1Cu);
  }
  return 1;
}

void sub_1009A923C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000339DC(&a22);
  _Unwind_Resume(a1);
}

void sub_1009A9288(uint64_t a1, xpc_connection_t *a2, uint64_t *a3)
{
  BOOL v5 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    pid_t pid = xpc_connection_get_pid(*a2);
    xpc_connection_t v7 = *a2;
    if (*((char *)a3 + 23) >= 0) {
      long long v8 = a3;
    }
    else {
      long long v8 = (uint64_t *)*a3;
    }
    v9[0] = 67109634;
    v9[1] = pid;
    __int16 v10 = 2048;
    xpc_connection_t v11 = v7;
    __int16 v12 = 2080;
    xpc_connection_t v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %d(%p) released its CT Keep Alive assertion '%s'", (uint8_t *)v9, 0x1Cu);
  }
}

void sub_1009A9364(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  a1[21] = 0;
  a1[22] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[4];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I All CT Keep Alive assertions released", v4, 2u);
  }
}

void sub_1009A93DC(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A9418(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A9454(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A9490(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A94CC(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

uint64_t sub_1009A9504(void *a1)
{
  *a1 = off_101A23108;
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100DD1644((uint64_t)a1);
}

void sub_1009A9560(void *a1)
{
  *a1 = off_101A23108;
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100DD1644((uint64_t)a1);

  operator delete();
}

void sub_1009A95D4(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A960C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009A968C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A96C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009A9700(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009A9730(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009A9778(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A97B0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009A9830(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A986C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009A98A4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009A98D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009A991C(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A9954(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009A99D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A9A10(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009A9A48(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009A9A78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1009A9ABC(void *a1)
{
  *a1 = off_101A23490;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1009A9B08(void *a1)
{
  *a1 = off_101A23490;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1009A9B74(uint64_t a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A23490;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 6) = *(_DWORD *)(a1 + 24);
  return result;
}

uint64_t sub_1009A9BD8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A23490;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
  return result;
}

void sub_1009A9C18(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1009A9C28(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1009A9C68(uint64_t a1, long long *a2)
{
  long long v7 = *a2;
  *(_OWORD *)long long v8 = *(long long *)((char *)a2 + 24);
  uint64_t v9 = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *(_OWORD *)std::string __p = a2[3];
  uint64_t v11 = *((void *)a2 + 8);
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  long long v12 = a2[5];
  uint64_t v2 = *((void *)a2 + 13);
  uint64_t v13 = *((void *)a2 + 12);
  uint64_t v14 = v2;
  a2[5] = 0u;
  a2[6] = 0u;
  long long v15 = a2[7];
  *((void *)a2 + 14) = 0;
  *((void *)a2 + 15) = 0;
  uint64_t v3 = (void *)a2 + 17;
  uint64_t v4 = (void *)*((void *)a2 + 17);
  uint64_t v16 = (void **)*((void *)a2 + 16);
  char v17 = v4;
  if (*((void *)a2 + 18))
  {
    _OWORD v4[2] = &v17;
    *((void *)a2 + 16) = v3;
    void *v3 = 0;
    *((void *)a2 + 18) = 0;
  }
  else
  {
    uint64_t v16 = &v17;
  }
  if (DWORD1(v7))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 24);
    sub_100058DB0(v19, "OTA Activation assertion released");
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, void, void))(*(void *)v5 + 80))(v5, v6, 512, 0, v19, 0, 0);
    if (v20 < 0) {
      operator delete(v19[0]);
    }
  }
  sub_10005D9E0((uint64_t)&v16, v17);
  sub_10005DBA4(&v12);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
}

void sub_1009A9DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  if (*(char *)(v34 - 33) < 0) {
    operator delete(*(void **)(v34 - 56));
  }
  sub_10005D9E0(v33, a32);
  sub_10005DBA4(v32);
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009A9E40(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1009A9E80()
{
}

void sub_1009A9E90(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009A9EC8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009A9F48(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009A9F84(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009A9FBC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009A9FEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009AA034(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009AA06C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009AA0EC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009AA128(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009AA160(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009AA190(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009AA1D8(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_1009AA210(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009AA290(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009AA2CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009AA304(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009AA334(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009AA37C()
{
}

void *sub_1009AA390()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A23738;
  return result;
}

void sub_1009AA3C8(uint64_t a1, void *a2)
{
  *a2 = off_101A23738;
}

void sub_1009AA3F0(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CTKeepAliveAssertion", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1009AA468(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009AA4A8()
{
}

void sub_1009AA4BC(const std::string **a1@<X5>, void *a2@<X8>)
{
  os_signpost_id_t v3 = *a1;
  if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t size = v3->__r_.__value_.__l.__size_;
    if (size)
    {
      uint64_t v5 = (const std::string *)v3->__r_.__value_.__r.__words[0];
LABEL_6:
      if (size >= 3)
      {
        uint64_t v6 = (char *)v5 + size;
        long long v7 = (std::string *)v5;
        while (1)
        {
          long long v8 = (char *)memchr(v7, 58, size - 2);
          if (!v8) {
            goto LABEL_21;
          }
          if (*(_WORD *)v8 == 12090 && v8[2] == 47) {
            break;
          }
          long long v7 = (std::string *)(v8 + 1);
          uint64_t size = v6 - (char *)v7;
          if (v6 - (char *)v7 < 3) {
            goto LABEL_21;
          }
        }
        if (v8 != v6 && v8 - (char *)v5 != -1)
        {
          std::string::basic_string(&v12, v3, v8 - (char *)v5 + 3, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v13);
          __int16 v10 = (std::string *)*a1;
          if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v10->__r_.__value_.__l.__data_);
          }
          long long v11 = *(_OWORD *)&v12.__r_.__value_.__l.__data_;
          v10->__r_.__value_.__r.__words[2] = v12.__r_.__value_.__r.__words[2];
          *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
        }
      }
LABEL_21:
      operator new();
    }
  }
  else
  {
    uint64_t size = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&(*a1)->__r_.__value_.__s + 23))
    {
      uint64_t v5 = *a1;
      goto LABEL_6;
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1009AAA64(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[7], v1, (dispatch_function_t)sub_1009B4B9C);
  __cxa_rethrow();
}

void sub_1009AAA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object, std::__shared_weak_count *a14, std::__shared_weak_count *a15, dispatch_object_t object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22)
{
  __cxa_end_catch();
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

const void **sub_1009AACDC(uint64_t a1)
{
  if (*(char *)(a1 + 623) < 0)
  {
    **(unsigned char **)(a1 + 600) = 0;
    *(void *)(a1 + 608) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 600) = 0;
    *(unsigned char *)(a1 + 623) = 0;
  }
  *(void *)(a1 + 640) = *(void *)(a1 + 632);
  *(void *)(a1 + 664) = *(void *)(a1 + 656);
  if (*(char *)(a1 + 703) < 0)
  {
    **(unsigned char **)(a1 + 680) = 0;
    *(void *)(a1 + 688) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 680) = 0;
    *(unsigned char *)(a1 + 703) = 0;
  }
  *(void *)(a1 + 920) = *(void *)(a1 + 912);
  *(void *)(a1 + 944) = *(void *)(a1 + 936);
  sub_1009AB2A4((void *)(a1 + 960));
  *(void *)(a1 + 1304) = *(void *)(a1 + 1296);
  uint64_t v2 = *(void ***)(a1 + 1328);
  os_signpost_id_t v3 = *(void ***)(a1 + 1320);
  while (v2 != v3)
  {
    v2 -= 4;
    long long v8 = v2;
    sub_10016A9A4(&v8);
  }
  *(void *)(a1 + 1328) = v3;
  *(void *)(a1 + 1352) = *(void *)(a1 + 1344);
  *(unsigned char *)(a1 + 624) = 2;
  *(unsigned char *)(a1 + 161) = 0;
  uint64_t v4 = *(void *)(a1 + 272);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 280);
    *(void *)(a1 + 272) = 0;
    *(void *)(a1 + 280) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  *(unsigned char *)(a1 + 1368) = 0;
  *(void *)(a1 + 1384) = *(void *)(a1 + 1376);
  *(unsigned char *)(a1 + 1400) = 0;
  uint64_t v6 = *(void ***)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  long long v8 = v6;
  return sub_100044D00((const void **)&v8);
}

uint64_t sub_1009AAE18(uint64_t a1)
{
  uint64_t v2 = a1 + 96;
  os_signpost_id_t v3 = *(void **)(a1 + 312);
  if (v3)
  {
    *(void *)(a1 + 320) = v3;
    operator delete(v3);
  }
  sub_1000C584C(v2);
  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 48);
  if (v5)
  {
    *(void *)(a1 + 56) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    *(void *)(a1 + 32) = v6;
    operator delete(v6);
  }
  long long v7 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v7;
    operator delete(v7);
  }
  return a1;
}

uint64_t sub_1009AAE98(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  os_signpost_id_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_1009AAEEC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(char *)(a1 + 207) < 0) {
      operator delete(*(void **)(a1 + 184));
    }
    *(unsigned char *)(a1 + 176) = 0;
  }
  if (*(unsigned char *)(a1 + 160)) {
    *(unsigned char *)(a1 + 160) = 0;
  }
  if (*(unsigned char *)(a1 + 144)) {
    *(unsigned char *)(a1 + 144) = 0;
  }
  if (*(unsigned char *)(a1 + 128)) {
    *(unsigned char *)(a1 + 128) = 0;
  }
  if (*(unsigned char *)(a1 + 112)) {
    *(unsigned char *)(a1 + 112) = 0;
  }
  if (*(unsigned char *)(a1 + 96)) {
    *(unsigned char *)(a1 + 96) = 0;
  }
  if (*(unsigned char *)(a1 + 80)) {
    *(unsigned char *)(a1 + 80) = 0;
  }
  if (*(unsigned char *)(a1 + 64)) {
    *(unsigned char *)(a1 + 64) = 0;
  }
  if (*(unsigned char *)(a1 + 48)) {
    *(unsigned char *)(a1 + 48) = 0;
  }
  if (*(unsigned char *)(a1 + 32)) {
    *(unsigned char *)(a1 + 32) = 0;
  }
  if (*(unsigned char *)(a1 + 16)) {
    *(unsigned char *)(a1 + 16) = 0;
  }
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

uint64_t sub_1009AAFB0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 1376);
  if (v2)
  {
    *(void *)(a1 + 1384) = v2;
    operator delete(v2);
  }
  os_signpost_id_t v3 = *(void **)(a1 + 1344);
  if (v3)
  {
    *(void *)(a1 + 1352) = v3;
    operator delete(v3);
  }
  long long v27 = (void **)(a1 + 1320);
  sub_1009B49F8(&v27);
  uint64_t v4 = *(void **)(a1 + 1296);
  if (v4)
  {
    *(void *)(a1 + 1304) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 1272);
  if (v5)
  {
    *(void *)(a1 + 1280) = v5;
    operator delete(v5);
  }
  sub_1000C584C(a1 + 1056);
  uint64_t v6 = *(void **)(a1 + 1032);
  if (v6)
  {
    *(void *)(a1 + 1040) = v6;
    operator delete(v6);
  }
  long long v7 = *(void **)(a1 + 1008);
  if (v7)
  {
    *(void *)(a1 + 1016) = v7;
    operator delete(v7);
  }
  long long v8 = *(void **)(a1 + 984);
  if (v8)
  {
    *(void *)(a1 + 992) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(void **)(a1 + 960);
  if (v9)
  {
    *(void *)(a1 + 968) = v9;
    operator delete(v9);
  }
  __int16 v10 = *(void **)(a1 + 936);
  if (v10)
  {
    *(void *)(a1 + 944) = v10;
    operator delete(v10);
  }
  long long v11 = *(void **)(a1 + 912);
  if (v11)
  {
    *(void *)(a1 + 920) = v11;
    operator delete(v11);
  }
  sub_1009B4A6C(a1 + 704);
  if (*(char *)(a1 + 703) < 0) {
    operator delete(*(void **)(a1 + 680));
  }
  std::string v12 = *(void **)(a1 + 656);
  if (v12)
  {
    *(void *)(a1 + 664) = v12;
    operator delete(v12);
  }
  long long v13 = *(void **)(a1 + 632);
  if (v13)
  {
    *(void *)(a1 + 640) = v13;
    operator delete(v13);
  }
  if (*(char *)(a1 + 623) < 0) {
    operator delete(*(void **)(a1 + 600));
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 592);
  if (v14) {
    sub_10004D2C8(v14);
  }
  long long v15 = *(std::__shared_weak_count **)(a1 + 576);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 544);
  if (v16) {
    sub_10004D2C8(v16);
  }
  char v17 = *(std::__shared_weak_count **)(a1 + 512);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (*(unsigned char *)(a1 + 464))
  {
    if (*(char *)(a1 + 495) < 0) {
      operator delete(*(void **)(a1 + 472));
    }
    *(unsigned char *)(a1 + 464) = 0;
  }
  if (*(unsigned char *)(a1 + 448)) {
    *(unsigned char *)(a1 + 448) = 0;
  }
  if (*(unsigned char *)(a1 + 432)) {
    *(unsigned char *)(a1 + 432) = 0;
  }
  if (*(unsigned char *)(a1 + 416)) {
    *(unsigned char *)(a1 + 416) = 0;
  }
  if (*(unsigned char *)(a1 + 400)) {
    *(unsigned char *)(a1 + 400) = 0;
  }
  if (*(unsigned char *)(a1 + 384)) {
    *(unsigned char *)(a1 + 384) = 0;
  }
  if (*(unsigned char *)(a1 + 368)) {
    *(unsigned char *)(a1 + 368) = 0;
  }
  if (*(unsigned char *)(a1 + 352)) {
    *(unsigned char *)(a1 + 352) = 0;
  }
  if (*(unsigned char *)(a1 + 336)) {
    *(unsigned char *)(a1 + 336) = 0;
  }
  if (*(unsigned char *)(a1 + 320)) {
    *(unsigned char *)(a1 + 320) = 0;
  }
  if (*(unsigned char *)(a1 + 304)) {
    *(unsigned char *)(a1 + 304) = 0;
  }
  if (*(unsigned char *)(a1 + 288)) {
    *(unsigned char *)(a1 + 288) = 0;
  }
  CFTypeID v18 = *(std::__shared_weak_count **)(a1 + 280);
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v19 = *(const void **)(a1 + 264);
  if (v19) {
    _Block_release(v19);
  }
  char v20 = *(const void **)(a1 + 256);
  if (v20) {
    _Block_release(v20);
  }
  if (*(unsigned char *)(a1 + 248))
  {
    long long v27 = (void **)(a1 + 224);
    sub_1000C57C8(&v27);
  }
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  unint64_t v21 = *(std::__shared_weak_count **)(a1 + 144);
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v22 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v22) {
    sub_1007A8468(a1 + 128, v22);
  }
  uint64_t v23 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v23) {
    sub_1009B58C0(v23);
  }
  unsigned int v24 = *(std::__shared_weak_count **)(a1 + 112);
  if (v24) {
    sub_10004D2C8(v24);
  }
  long long v25 = *(std::__shared_weak_count **)(a1 + 96);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_10132A164(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_100087E88((void *)(a1 + 40));
  return a1;
}

void sub_1009AB26C(uint64_t a1)
{
  sub_1009AAFB0(a1);

  operator delete();
}

uint64_t sub_1009AB2A4(void *a1)
{
  a1[1] = *a1;
  a1[4] = a1[3];
  a1[7] = a1[6];
  a1[10] = a1[9];
  memset(v3, 0, 92);
  memset(&v3[6], 0, 112);
  uint64_t v4 = 0;
  sub_10032FC84((uint64_t)(a1 + 12), (uint64_t)v3);
  uint64_t result = sub_1000C584C((uint64_t)v3);
  a1[40] = a1[39];
  return result;
}

void sub_1009AB35C(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  if (!*(unsigned char *)(a1 + 153))
  {
    long long v7 = *a3;
    *(_OWORD *)(a1 + 184) = a3[1];
    *(_OWORD *)(a1 + 168) = v7;
    std::string::operator=((std::string *)(a1 + 200), (const std::string *)(a3 + 2));
    sub_1000C86CC(a1 + 224, (uint64_t)a3 + 56);
    if (!*(void *)(a1 + 104))
    {
      uint64_t v12 = *a2;
      uint64_t v11 = a2[1];
      if (v11) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
      }
      long long v13 = *(std::__shared_weak_count **)(a1 + 112);
      *(void *)(a1 + 104) = v12;
      *(void *)(a1 + 112) = v11;
      if (v13) {
        sub_10004D2C8(v13);
      }
      *(unsigned char *)(a1 + 152) = 0;
      (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 88) + 40))(&v14);
      sub_10132A314(a1, &v14);
      sub_100044D00(&v14);
      operator new();
    }
    if (!*(unsigned char *)(a1 + 153) && *(unsigned char *)(a1 + 152))
    {
      long long v8 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        sCardSerialNumberAsString();
        uint64_t v9 = v16 >= 0 ? buf : *(uint8_t **)buf;
        *(_DWORD *)char v17 = 136315138;
        CFTypeID v18 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Resuming installation procedure for %s", v17, 0xCu);
        if (v16 < 0) {
          operator delete(*(void **)buf);
        }
      }
      if (*(void *)(a1 + 136))
      {
        __int16 v10 = *(std::__shared_weak_count **)(a1 + 144);
        *(void *)(a1 + 136) = 0;
        *(void *)(a1 + 144) = 0;
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      *(unsigned char *)(a1 + 152) = 0;
      sub_1009B4BDC(*(void *)(a1 + 120), (uint64_t)buf, 1);
    }
  }
}

void sub_1009AB6A0()
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  std::__shared_weak_count::__release_weak(v1);
  os_signpost_id_t v3 = *(std::__shared_weak_count **)(v0 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  std::__shared_weak_count::__release_weak(v1);
  std::__shared_weak_count::__release_weak(v1);
  operator delete();
}

uint64_t sub_1009AB738(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 153);
}

BOOL sub_1009AB740(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 153) && *(unsigned char *)(a1 + 152) != 0;
}

uint64_t sub_1009AB760(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [-] Install has been paused; will resume on trigger later",
      buf,
      2u);
  }
  *(unsigned char *)(a1 + 152) = 1;
  return sub_1009BAAC4(*(void *)(a1 + 120), (uint64_t)&v4, 1);
}

void sub_1009AB7DC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 153))
  {
    uint64_t v2 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cancelling install procedure", buf, 2u);
    }
    uint64_t v3 = *(void *)(a1 + 120);
    if (v3)
    {
      v4[0] = 1;
      int v5 = 0;
      sub_1009BAD84(v3, (uint64_t)v4, 1);
    }
    else
    {
      sub_1009AB880(a1, 1, 0, 0);
    }
  }
}

void sub_1009AB880(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!*(unsigned char *)(a1 + 153))
  {
    uint64_t v5 = *(void *)(a1 + 264);
    if (v5)
    {
      switch((int)a2)
      {
        case 0:
        case 2:
        case 9:
          __int16 v10 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = "";
            if (a4) {
              uint64_t v11 = " [Force Receipts!]";
            }
            LODWORD(buf[0]) = 136315138;
            *(void *)((char *)buf + 4) = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [X] Vinyl install operation failed; giving up.%s",
              (uint8_t *)buf,
              0xCu);
            uint64_t v5 = *(void *)(a1 + 264);
          }
          *(unsigned char *)(a1 + 153) = 1;
          sub_1009B4934(v5, a2, a4, a1 + 168);
          break;
        case 1:
          long long v13 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = "";
            if (a4) {
              uint64_t v14 = " [Force Receipts!]";
            }
            LODWORD(buf[0]) = 136315138;
            *(void *)((char *)buf + 4) = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [X] Vinyl install operation intentionally cancelled.%s", (uint8_t *)buf, 0xCu);
            uint64_t v5 = *(void *)(a1 + 264);
          }
          *(unsigned char *)(a1 + 153) = 1;
          sub_1009B4934(v5, 1u, a4, a1 + 168);
          break;
        case 3:
        case 4:
          uint64_t v12 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [-] Install has been paused; will resume on trigger",
              (uint8_t *)buf,
              2u);
            uint64_t v5 = *(void *)(a1 + 264);
          }
          *(unsigned char *)(a1 + 152) = 1;
          LOBYTE(buf[0]) = 0;
          (*(void (**)(uint64_t, uint64_t, uint64_t, _OWORD *))(v5 + 16))(v5, a2, 1, buf);
          sub_1000C60A0(buf);
          break;
        case 5:
        case 6:
        case 7:
        case 8:
          uint64_t v9 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 67109120;
            DWORD1(buf[0]) = a2;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [X] Vinyl install operation failed: %d", (uint8_t *)buf, 8u);
            uint64_t v5 = *(void *)(a1 + 264);
          }
          *(unsigned char *)(a1 + 153) = 1;
          sub_1009B4870(v5, a2, 0, a1 + 168);
          break;
        case 10:
          long long v15 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [X] Vinyl install operation succeeded", (uint8_t *)buf, 2u);
            uint64_t v5 = *(void *)(a1 + 264);
          }
          *(unsigned char *)(a1 + 153) = 1;
          sub_1009B4870(v5, 0xAu, 0, a1 + 168);
          break;
        default:
          break;
      }
      if (!*(unsigned char *)(a1 + 160) || *(unsigned char *)(a1 + 153))
      {
        uint64_t v16 = CTStopwatch::sample((CTStopwatch *)(a1 + 504));
        if (*(unsigned char *)(a1 + 288))
        {
          if (v17) {
            *(void *)(a1 + 296) = v16;
          }
          else {
            *(unsigned char *)(a1 + 288) = 0;
          }
        }
        else if (v17)
        {
          *(void *)(a1 + 296) = v16;
          *(unsigned char *)(a1 + 288) = 1;
        }
        (*(void (**)(_OWORD *__return_ptr))(**(void **)(a1 + 88) + 72))(buf);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)&buf[0]);
        char v20 = ServiceMap;
        if (v21 < 0)
        {
          uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v23 = 5381;
          do
          {
            uint64_t v21 = v23;
            unsigned int v24 = *v22++;
            uint64_t v23 = (33 * v23) ^ v24;
          }
          while (v24);
        }
        std::mutex::lock(ServiceMap);
        uint64_t v53 = (Registry *)v21;
        long long v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v53);
        if (v25)
        {
          uint64_t v27 = v25[3];
          long long v26 = (std::__shared_weak_count *)v25[4];
          if (v26)
          {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v20);
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v26);
            char v28 = 0;
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v27 = 0;
        }
        std::mutex::unlock(v20);
        long long v26 = 0;
        char v28 = 1;
LABEL_40:
        *(unsigned char *)(a1 + 499) = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 72))(v27);
        *(unsigned char *)(a1 + 498) = 1;
        if ((v28 & 1) == 0) {
          sub_10004D2C8(v26);
        }
        if (*((void *)&buf[0] + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf[0] + 1));
        }
        sub_1004F0164(*(unsigned int *)(a1 + 80), a2);
        (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 88) + 72))(&v53);
        if (a2 == 4) {
          goto LABEL_128;
        }
        int64_t v30 = *(int *)(a1 + 80);
        long long v31 = (std::mutex *)Registry::getServiceMap(v29, v53);
        long long v32 = v31;
        if (v33 < 0)
        {
          uint64_t v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v35 = 5381;
          do
          {
            uint64_t v33 = v35;
            unsigned int v36 = *v34++;
            uint64_t v35 = (33 * v35) ^ v36;
          }
          while (v36);
        }
        std::mutex::lock(v31);
        *(void *)&buf[0] = v33;
        long long v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)buf);
        if (v37)
        {
          uint64_t v39 = v37[3];
          long long v38 = (std::__shared_weak_count *)v37[4];
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v32);
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v38);
            char v40 = 0;
            if (!v39) {
              goto LABEL_51;
            }
            goto LABEL_55;
          }
        }
        else
        {
          uint64_t v39 = 0;
        }
        std::mutex::unlock(v32);
        long long v38 = 0;
        char v40 = 1;
        if (!v39)
        {
LABEL_51:
          uint64_t v41 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send End.", (uint8_t *)buf, 2u);
          }
LABEL_126:
          if ((v40 & 1) == 0) {
            sub_10004D2C8(v38);
          }
LABEL_128:
          if (v54) {
            sub_10004D2C8(v54);
          }
          if (*(unsigned char *)(a1 + 153))
          {
            xpc_object_t v51 = *(const void **)(a1 + 264);
            *(void *)(a1 + 264) = 0;
            if (v51) {
              _Block_release(v51);
            }
            xpc_object_t v52 = *(const void **)(a1 + 256);
            *(void *)(a1 + 256) = 0;
            if (v52) {
              _Block_release(v52);
            }
            sub_1009AACDC(a1);
          }
          return;
        }
LABEL_55:
        xpc_object_t v83 = 0;
        xpc_object_t v42 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v43 = v42;
        if (v42)
        {
          xpc_object_t v83 = v42;
        }
        else
        {
          xpc_object_t v43 = xpc_null_create();
          xpc_object_t v83 = v43;
          if (!v43)
          {
            xpc_object_t v44 = xpc_null_create();
            xpc_object_t v43 = 0;
            goto LABEL_62;
          }
        }
        if (xpc_get_type(v43) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v43);
          goto LABEL_63;
        }
        xpc_object_t v44 = xpc_null_create();
LABEL_62:
        xpc_object_t v83 = v44;
LABEL_63:
        xpc_release(v43);
        if (a2 > 0xA) {
          int64_t v45 = 0;
        }
        else {
          int64_t v45 = *(void *)&asc_10151CBF0[8 * (char)a2];
        }
        xpc_object_t v81 = xpc_int64_create(v45);
        if (!v81) {
          xpc_object_t v81 = xpc_null_create();
        }
        *(void *)&buf[0] = &v83;
        *((void *)&buf[0] + 1) = "result";
        sub_100035E70((uint64_t)buf, &v81, &v82);
        xpc_release(v82);
        xpc_object_t v82 = 0;
        xpc_release(v81);
        xpc_object_t v81 = 0;
        xpc_object_t v79 = xpc_int64_create(v30);
        if (!v79) {
          xpc_object_t v79 = xpc_null_create();
        }
        *(void *)&buf[0] = &v83;
        *((void *)&buf[0] + 1) = "sid";
        sub_100035E70((uint64_t)buf, &v79, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v79);
        xpc_object_t v79 = 0;
        xpc_object_t v77 = xpc_int64_create(a3);
        if (!v77) {
          xpc_object_t v77 = xpc_null_create();
        }
        *(void *)&buf[0] = &v83;
        *((void *)&buf[0] + 1) = "sub_result";
        sub_100035E70((uint64_t)buf, &v77, &v78);
        xpc_release(v78);
        xpc_object_t v78 = 0;
        xpc_release(v77);
        xpc_object_t v77 = 0;
        uint64_t v46 = *(uint64_t **)(a1 + 568);
        if (*((char *)v46 + 23) < 0)
        {
          if (!v46[1])
          {
LABEL_80:
            if (*(unsigned char *)(a1 + 352))
            {
              xpc_object_t v73 = xpc_int64_create(*(unsigned int *)(a1 + 360));
              if (!v73) {
                xpc_object_t v73 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "time_get_euicc_challenge_ms";
              sub_100035E70((uint64_t)buf, &v73, &v74);
              xpc_release(v74);
              xpc_object_t v74 = 0;
              xpc_release(v73);
              xpc_object_t v73 = 0;
            }
            if (*(unsigned char *)(a1 + 368))
            {
              xpc_object_t v71 = xpc_int64_create(*(unsigned int *)(a1 + 376));
              if (!v71) {
                xpc_object_t v71 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "time_init_auth_ms";
              sub_100035E70((uint64_t)buf, &v71, &v72);
              xpc_release(v72);
              xpc_object_t v72 = 0;
              xpc_release(v71);
              xpc_object_t v71 = 0;
            }
            if (*(unsigned char *)(a1 + 384))
            {
              xpc_object_t v69 = xpc_int64_create(*(unsigned int *)(a1 + 392));
              if (!v69) {
                xpc_object_t v69 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "time_auth_server_ms";
              sub_100035E70((uint64_t)buf, &v69, &v70);
              xpc_release(v70);
              xpc_object_t v70 = 0;
              xpc_release(v69);
              xpc_object_t v69 = 0;
            }
            if (*(unsigned char *)(a1 + 400))
            {
              xpc_object_t v67 = xpc_int64_create(*(unsigned int *)(a1 + 408));
              if (!v67) {
                xpc_object_t v67 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "time_auth_client_ms";
              sub_100035E70((uint64_t)buf, &v67, &v68);
              xpc_release(v68);
              xpc_object_t v68 = 0;
              xpc_release(v67);
              xpc_object_t v67 = 0;
            }
            if (*(unsigned char *)(a1 + 416))
            {
              xpc_object_t v65 = xpc_int64_create(*(unsigned int *)(a1 + 424));
              if (!v65) {
                xpc_object_t v65 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "time_prepare_download_ms";
              sub_100035E70((uint64_t)buf, &v65, &v66);
              xpc_release(v66);
              xpc_object_t v66 = 0;
              xpc_release(v65);
              xpc_object_t v65 = 0;
            }
            if (*(unsigned char *)(a1 + 464))
            {
              xpc_object_t v47 = (const char *)(a1 + 472);
              if (*(char *)(a1 + 495) < 0) {
                xpc_object_t v47 = *(const char **)v47;
              }
              xpc_object_t v63 = xpc_string_create(v47);
              if (!v63) {
                xpc_object_t v63 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "carrier_name";
              sub_100035E70((uint64_t)buf, &v63, &v64);
              xpc_release(v64);
              xpc_object_t v64 = 0;
              xpc_release(v63);
              xpc_object_t v63 = 0;
            }
            if (*(unsigned char *)(a1 + 496))
            {
              xpc_object_t v48 = (const char *)asString();
              xpc_object_t v61 = xpc_string_create(v48);
              if (!v61) {
                xpc_object_t v61 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "proposal_modified";
              sub_100035E70((uint64_t)buf, &v61, &v62);
              xpc_release(v62);
              xpc_object_t v62 = 0;
              xpc_release(v61);
              xpc_object_t v61 = 0;
            }
            if (*(unsigned char *)(a1 + 498))
            {
              xpc_object_t v59 = xpc_BOOL_create(*(unsigned char *)(a1 + 499));
              if (!v59) {
                xpc_object_t v59 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "is_green_tea_capable";
              sub_100035E70((uint64_t)buf, &v59, &v60);
              xpc_release(v60);
              xpc_object_t v60 = 0;
              xpc_release(v59);
              xpc_object_t v59 = 0;
            }
            if (*(unsigned char *)(a1 + 500))
            {
              xpc_object_t v49 = (const char *)asString();
              xpc_object_t v57 = xpc_string_create(v49);
              if (!v57) {
                xpc_object_t v57 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "modified_proposal_acceptance";
              sub_100035E70((uint64_t)buf, &v57, &v58);
              xpc_release(v58);
              xpc_object_t v58 = 0;
              xpc_release(v57);
              xpc_object_t v57 = 0;
            }
            if (*(unsigned char *)(*(void *)(a1 + 568) + 187))
            {
              xpc_object_t v50 = (const char *)asString();
              xpc_object_t v55 = xpc_string_create(v50);
              if (!v55) {
                xpc_object_t v55 = xpc_null_create();
              }
              *(void *)&buf[0] = &v83;
              *((void *)&buf[0] + 1) = "reason_code";
              sub_100035E70((uint64_t)buf, &v55, &v56);
              xpc_release(v56);
              xpc_object_t v56 = 0;
              xpc_release(v55);
              xpc_object_t v55 = 0;
            }
            *(void *)&buf[0] = v83;
            if (v83) {
              xpc_retain(v83);
            }
            else {
              *(void *)&buf[0] = xpc_null_create();
            }
            (*(void (**)(uint64_t, const char *, _OWORD *))(*(void *)v39 + 16))(v39, "commCenterVinylInstallDetails", buf);
            xpc_release(*(xpc_object_t *)&buf[0]);
            *(void *)&buf[0] = 0;
            xpc_release(v83);
            goto LABEL_126;
          }
          uint64_t v46 = (uint64_t *)*v46;
        }
        else if (!*((unsigned char *)v46 + 23))
        {
          goto LABEL_80;
        }
        xpc_object_t v75 = xpc_string_create((const char *)v46);
        if (!v75) {
          xpc_object_t v75 = xpc_null_create();
        }
        *(void *)&buf[0] = &v83;
        *((void *)&buf[0] + 1) = "server";
        sub_100035E70((uint64_t)buf, &v75, &v76);
        xpc_release(v76);
        xpc_object_t v76 = 0;
        xpc_release(v75);
        xpc_object_t v75 = 0;
        goto LABEL_80;
      }
    }
  }
}

void sub_1009AC438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009AC608(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 153))
  {
    uint64_t v2 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cancelling install procedure with failure", buf, 2u);
    }
    uint64_t v3 = *(void *)(a1 + 120);
    if (v3)
    {
      v4[0] = 0;
      int v5 = 0;
      sub_1009BAD84(v3, (uint64_t)v4, 1);
    }
    else
    {
      sub_1009AB880(a1, 0, 0, 0);
    }
  }
}

uint64_t sub_1009AC6A8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 153) && !*(unsigned char *)(a1 + 152)) {
    return sub_1009AB760(a1);
  }
  return a1;
}

BOOL sub_1009AC6C0(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 153) && *(unsigned char *)(a1 + 154) != 0;
}

void sub_1009AC6E0(uint64_t a1, int a2)
{
  char v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [?] User Consent Response: %s", (uint8_t *)&v9, 0xCu);
  }
  *(unsigned char *)(a1 + 163) = a2;
  *(unsigned char *)(a1 + 162) = 1;
  if (a2 == 2)
  {
    int v5 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      uint64_t v6 = "#I [?] User Cancelled";
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, 2u);
    }
  }
  else
  {
    if (a2) {
      return;
    }
    if (*(unsigned char *)(a1 + 1147))
    {
      int v5 = *(NSObject **)(a1 + 72);
      goto LABEL_12;
    }
    int v5 = *(NSObject **)(a1 + 72);
    if (*(unsigned char *)(a1 + 1146))
    {
LABEL_12:
      BOOL v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      char v7 = 0;
      if (v8)
      {
        LOWORD(v9) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [?] PPR User Rejected", (uint8_t *)&v9, 2u);
        char v7 = 0;
      }
      goto LABEL_14;
    }
    if (os_log_type_enabled(*(os_log_t *)(a1 + 72), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      uint64_t v6 = "#I [?] General Consent Rejected";
      goto LABEL_9;
    }
  }
  char v7 = 1;
LABEL_14:
  *(unsigned char *)(a1 + 624) = v7;
}

void sub_1009AC874(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 153))
  {
    uint64_t v2 = "done";
  }
  else if (*(unsigned char *)(a1 + 152))
  {
    uint64_t v2 = "paused";
  }
  else
  {
    uint64_t v2 = "running";
  }
  uint64_t v3 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    char v4 = (void *)(a1 + 600);
    if (*(char *)(a1 + 623) < 0) {
      char v4 = (void *)*v4;
    }
    int v5 = *(uint64_t **)(a1 + 568);
    uint64_t v6 = v5;
    if (*((char *)v5 + 23) < 0) {
      uint64_t v6 = (uint64_t *)*v5;
    }
    char v7 = v5 + 6;
    if (*((char *)v5 + 71) < 0) {
      char v7 = (void *)*v7;
    }
    if (*((unsigned char *)v5 + 120))
    {
      BOOL v8 = "";
    }
    else
    {
      BOOL v8 = (const char *)(v5 + 9);
      if (*((char *)v5 + 95) < 0) {
        BOOL v8 = *(const char **)v8;
      }
    }
    uint64_t v9 = v5[13] - v5[12];
    int v10 = *((unsigned __int8 *)v5 + 122);
    int v11 = *((unsigned __int8 *)v5 + 123);
    if (*(unsigned char *)(a1 + 162))
    {
      uint64_t v12 = (const char *)asString();
      int v5 = *(uint64_t **)(a1 + 568);
    }
    else
    {
      uint64_t v12 = "";
    }
    long long v13 = v5 + 24;
    if (*((char *)v5 + 215) < 0) {
      long long v13 = (void *)*v13;
    }
    uint64_t v14 = v5 + 27;
    if (*((char *)v5 + 239) < 0) {
      uint64_t v14 = (void *)*v14;
    }
    int v15 = 136317698;
    uint64_t v16 = v2;
    __int16 v17 = 2080;
    CFTypeID v18 = v4;
    __int16 v19 = 2080;
    char v20 = v6;
    __int16 v21 = 2080;
    uint64_t v22 = v7;
    __int16 v23 = 2080;
    unsigned int v24 = v8;
    __int16 v25 = 2048;
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 3);
    __int16 v27 = 1024;
    int v28 = v10;
    __int16 v29 = 1024;
    int v30 = v11;
    __int16 v31 = 2080;
    long long v32 = v12;
    __int16 v33 = 2080;
    uint64_t v34 = v13;
    __int16 v35 = 2080;
    unsigned int v36 = v14;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I TapeInstallOperation: {\n\t\t\tstate: %s\n\t\t\ttransactionId: [%s]\n\t\t\tsmdpserver: [%s]\n\t\t\tmatchingId: [%s]\n\t\t\tconfirmationCode: [%s]\n\t\t\t%lu iccid prefixes\n\t\t\tforceUserConsent: [%d]\n\t\t\tneedEligibilityCheck: [%d]\n\t\t\tuserConsent: [%s]\n\t\t\tInstallReplaceType: [%s]\n\t\t\tIccidToDelete: [%s]\n\t\t\t}", (uint8_t *)&v15, 0x68u);
  }
}

uint64_t sub_1009ACA74(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 664);
  uint64_t v3 = *(void *)(a1 + 656);
  unint64_t v4 = v2 - v3;
  if (v2 == v3) {
    return 4;
  }
  int v6 = *(char *)(v3 + 2);
  if (v6 == -127)
  {
    char v7 = *(unsigned char *)(v3 + 3);
    unsigned int v8 = 4;
  }
  else
  {
    if (v6 < 0) {
      return 6;
    }
    unsigned int v8 = 3;
    char v7 = *(unsigned char *)(v3 + 2);
  }
  if (v4 <= v8) {
    return 3;
  }
  int v10 = *(unsigned __int8 **)(a1 + 664);
  uint64_t v11 = v8;
  while (1)
  {
    signed int v12 = v8 + 1;
    int v13 = *(unsigned __int8 *)(v3 + v8 + 1);
    signed int v14 = v8 + 2;
    if ((*(unsigned char *)(v3 + v11) & 0x1F) == a2) {
      break;
    }
    unsigned int v8 = v14 + v13;
    uint64_t v11 = v8;
    if (v4 <= v8) {
      return 3;
    }
  }
  int v15 = (unsigned __int8 *)(v3 + v14);
  if ((unint64_t)v15 >= v2) {
    return 5;
  }
  uint64_t v16 = qword_101B0E3A8 - qword_101B0E3A0;
  if (qword_101B0E3A8 == qword_101B0E3A0) {
    goto LABEL_23;
  }
  if ((uint64_t)(v2 - (void)v15) >= v16)
  {
    uint64_t v17 = v2 - v16 + 1;
    if ((unsigned __int8 *)v17 != v15)
    {
      while (*v15 != *(unsigned __int8 *)qword_101B0E3A0)
      {
LABEL_20:
        if (++v15 == (unsigned __int8 *)v17) {
          goto LABEL_24;
        }
      }
      CFTypeID v18 = v15 + 1;
      __int16 v19 = (unsigned __int8 *)(qword_101B0E3A0 + 1);
      while (v19 != (unsigned __int8 *)qword_101B0E3A8)
      {
        int v21 = *v18++;
        int v20 = v21;
        int v22 = *v19++;
        if (v20 != v22) {
          goto LABEL_20;
        }
      }
LABEL_23:
      int v10 = v15;
    }
  }
LABEL_24:
  if ((unsigned __int8 *)v2 == v10) {
    return 5;
  }
  *(unsigned char *)(a1 + 1368) = 1;
  __int16 v23 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v36[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Updating EuiccInfo1", (uint8_t *)v36, 2u);
    uint64_t v3 = *(void *)(a1 + 656);
    uint64_t v16 = qword_101B0E3A8 - qword_101B0E3A0;
  }
  if (v16 << 32)
  {
    unsigned int v24 = (char *)v10;
    __int16 v25 = &v10[(int)v16];
    unint64_t v26 = *(unsigned char **)(a1 + 664);
    int64_t v27 = v26 - v25;
    if (v26 != v25)
    {
      memmove(v24, v25, v26 - v25);
      uint64_t v3 = *(void *)(a1 + 656);
    }
    *(void *)(a1 + 664) = &v24[v27];
  }
  *(unsigned char *)(v3 + v12) = v13 - v16;
  char v28 = v7 - v16;
  uint64_t v29 = *(void *)(a1 + 656);
  if (v6 == -127)
  {
    *(unsigned char *)(v29 + 3) = v28;
    uint64_t v30 = *(void *)(a1 + 656);
    int v32 = *(char *)(v30 + 3);
    __int16 v31 = (unsigned char *)(v30 + 3);
    if ((v32 & 0x80000000) == 0)
    {
      uint64_t v33 = *(void *)(a1 + 656) + 2;
      uint64_t v34 = *(unsigned char **)(a1 + 664);
      int64_t v35 = v34 - v31;
      if (v34 != v31) {
        memmove((void *)(*(void *)(a1 + 656) + 2), v31, v34 - v31);
      }
      *(void *)(a1 + 664) = v33 + v35;
    }
  }
  else
  {
    *(unsigned char *)(v29 + 2) = v28;
  }
  if (*(unsigned char *)(*(void *)(a1 + 656) + v12)) {
    return 1;
  }
  else {
    return 2;
  }
}

void sub_1009ACCD0(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      char v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 304))
        {
          if (v9) {
            *(void *)(v5 + 312) = v8;
          }
          else {
            *(unsigned char *)(v5 + 304) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 312) = v8;
          *(unsigned char *)(v5 + 304) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009ACE90;
        v15[3] = &unk_101A23860;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (signed int v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        signed int v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        int v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            CFTypeID v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009ACE74(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009ACE90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 != 2)
  {
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    unint64_t v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [1a] Responded with %lu bytes", buf, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          xpc_object_t v43 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v43);
        }
        uint64_t v46 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v46);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeInfo1Rsp");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        int64_t v45 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v45);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    if (v2 + 656 != a1 + 48) {
      sub_10006E4A8((void *)(v2 + 656), *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
    }
    memset(buf, 0, sizeof(buf));
    std::string __p = 0;
    xpc_object_t v50 = 0;
    uint64_t v51 = 0;
    uint64_t v20 = *(void *)(v2 + 568);
    if (*(unsigned char *)(v20 + 185)
      && *(unsigned char *)(v20 + 184)
      && !sub_10074D7E0((uint64_t *)(v2 + 656), (uint64_t)buf, (unint64_t *)&__p))
    {
      *(unsigned char *)(v2 + 1368) = 0;
      int v35 = sub_1009ACA74(v2, 9);
      int v36 = sub_1009ACA74(v2, 10);
      if (v35 == 2 && v36 == 2)
      {
        long long v37 = *(NSObject **)(v2 + 72);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v47) = 0;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I [1a] Empty PKID List; Aborting",
            (uint8_t *)&v47,
            2u);
        }
        *(_WORD *)(v2 + 496) = 513;
        uint64_t v38 = *(void *)(v2 + 120);
        LOBYTE(v47) = 9;
        HIDWORD(v47) = 24;
        sub_1009BAD84(v38, (uint64_t)&v47, 1);
        goto LABEL_46;
      }
      if (*(unsigned char *)(v2 + 1368)
        && sub_10074D7E0((uint64_t *)(v2 + 656), (uint64_t)buf, (unint64_t *)&__p))
      {
        uint64_t v39 = *(NSObject **)(v2 + 72);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v47) = 0;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I [1a] Invalid EuiccInfo1; Aborting",
            (uint8_t *)&v47,
            2u);
        }
        *(_WORD *)(v2 + 496) = 769;
        uint64_t v40 = *(void *)(v2 + 120);
        LOBYTE(v47) = 9;
        HIDWORD(v47) = 0;
        sub_1009BAD84(v40, (uint64_t)&v47, 1);
        goto LABEL_46;
      }
      __int16 v34 = 1;
      goto LABEL_40;
    }
    (*(void (**)(Registry **__return_ptr))(**(void **)(v2 + 88) + 72))(&v47);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21, v47);
    __int16 v23 = ServiceMap;
    if ((v24 & 0x8000000000000000) != 0)
    {
      __int16 v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        unint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v52 = v24;
    char v28 = sub_10004D37C(&v23[1].__m_.__sig, &v52);
    if (v28)
    {
      uint64_t v30 = v28[3];
      uint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
LABEL_33:
        int v32 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v30 + 72))(v30);
        if (!v32)
        {
          if ((v31 & 1) == 0) {
            sub_10004D2C8(v29);
          }
          if (v48) {
            sub_10004D2C8(v48);
          }
          goto LABEL_45;
        }
        int v33 = capabilities::ct::supportsRegulatoryRestriction(v32);
        if ((v31 & 1) == 0) {
          sub_10004D2C8(v29);
        }
        if (v48) {
          sub_10004D2C8(v48);
        }
        if (!v33)
        {
LABEL_45:
          std::string::operator=((std::string *)(v2 + 680), *(const std::string **)(v2 + 568));
          sub_1009BB984(*(void *)(v2 + 120), (uint64_t)&v47, 1);
LABEL_46:
          if (__p)
          {
            xpc_object_t v50 = __p;
            operator delete(__p);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          return;
        }
        __int16 v34 = 257;
LABEL_40:
        *(_WORD *)(v2 + 496) = v34;
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    uint64_t v29 = 0;
    char v31 = 1;
    goto LABEL_33;
  }
  if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
  {
    *(_DWORD *)(v2 + 156) = v10 + 1;
    uint64_t v11 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      int v13 = *(_DWORD *)(v2 + 156);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [1a] Failed with temporary error %s; paused (will be retry #%d)",
        buf,
        0x12u);
    }
    sub_1009AB760(v2);
  }
  else
  {
    signed int v14 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[1a] Failed with final error %s; Aborting",
        buf,
        0xCu);
    }
    uint64_t v15 = *(void *)(v2 + 120);
    buf[0] = 0;
    *(_DWORD *)&uint8_t buf[4] = 0;
    sub_1009BAD84(v15, (uint64_t)buf, 1);
    int v16 = *(unsigned __int8 *)(a1 + 40);
    if (v16 != 2)
    {
      if (v16 == 1)
      {
        uint64_t v41 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v41);
      }
      xpc_object_t v44 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v44);
    }
    if (*(unsigned char *)(a1 + 48) == 2)
    {
      int v17 = *(_DWORD *)(v2 + 80);
      int v18 = *(unsigned __int8 *)(a1 + 49);
      int v19 = *(unsigned __int8 *)(a1 + 50);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_1004F09E8;
      long long v54 = &unk_1019DB198;
      int v55 = v17;
      int v56 = 4;
      int v57 = v18;
      int v58 = v19;
      sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
}

void sub_1009AD570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009AD618(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009AD634(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009AD644(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 320))
        {
          if (v9) {
            *(void *)(v5 + 328) = v8;
          }
          else {
            *(unsigned char *)(v5 + 320) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 328) = v8;
          *(unsigned char *)(v5 + 320) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009AD804;
        v15[3] = &unk_101A238C0;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (uint64_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        signed int v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        uint64_t v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            int v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009AD7E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009AD804(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      uint64_t v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)char v31 = 136315394;
        *(void *)&v31[4] = v12;
        *(_WORD *)&v31[12] = 1024;
        *(_DWORD *)&v31[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [1b] Temporary error %s; paused (will be retry #%d)",
          v31,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      uint64_t v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)char v31 = 136315138;
        *(void *)&v31[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[1b] Final error %s; Aborting",
          v31,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v31[0] = 0;
      *(_DWORD *)&v31[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v31, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        char v28 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v28);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)char v31 = _NSConcreteStackBlock;
        *(void *)&v31[8] = 0x40000000;
        *(void *)&v31[16] = sub_1004F09E8;
        int v32 = &unk_1019DB198;
        int v33 = v18;
        int v34 = 20;
        int v35 = v19;
        int v36 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v26 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v26);
    }
    unint64_t v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)char v31 = 134217984;
      *(void *)&v31[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [1b] Responded with %lu bytes", v31, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          unsigned int v27 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v27);
        }
        uint64_t v30 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v30);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeRulesAuthTable");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_10074C354((void *)(a1 + 48));
    char v22 = v21;
    if (v21)
    {
      __int16 v23 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v24 = sub_100746C7C(v22);
        *(_DWORD *)char v31 = 136315138;
        *(void *)&v31[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I [1b] Failed, PPRs will be disallowed (%s)", v31, 0xCu);
      }
    }
    return sub_1009BBD04(*(void *)(v2 + 120), (uint64_t)v31, 1);
  }
  return result;
}

void sub_1009ADC68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009ADC9C(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 336))
        {
          if (v9) {
            *(void *)(v5 + 344) = v8;
          }
          else {
            *(unsigned char *)(v5 + 336) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 344) = v8;
          *(unsigned char *)(v5 + 336) = 1;
        }
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 1174405120;
        void v16[2] = sub_1009ADE84;
        uint64_t v16[3] = &unk_101A23920;
        int v16[4] = v5;
        memset(&v16[5], 0, 34);
        int v10 = *a2;
        if (v10 == 2)
        {
          LOBYTE(v16[5]) = 2;
          *(_WORD *)((char *)&v16[5] + 1) = *(_WORD *)(a2 + 1);
          BYTE3(v16[5]) = a2[3];
        }
        else if (v10 == 1)
        {
          LOBYTE(v16[5]) = 1;
          *(_OWORD *)((char *)&v16[5] + 1) = *(_OWORD *)(a2 + 1);
          *(_OWORD *)((char *)&v16[7] + 1) = *(_OWORD *)(a2 + 17);
          BYTE1(v16[9]) = a2[33];
        }
        uint64_t v11 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v11 || (uint64_t v12 = *(void *)(v5 + 40), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
          sub_100088B9C();
        }
        signed int v14 = v13;
        uint64_t v15 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v12;
        int v18 = v14;
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v16;
        dispatch_async(v15, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v14);
        LOBYTE(v16[5]) = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009ADE6C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009ADE84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  if (v2 != 2)
  {
    if (v2 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    long long v3 = *(_OWORD *)(a1 + 41);
    char v4 = *(unsigned char *)(a1 + 73);
    *(_OWORD *)(v1 + 888) = *(_OWORD *)(a1 + 57);
    *(unsigned char *)(v1 + 904) = v4;
    *(_OWORD *)(v1 + 872) = v3;
    *(_DWORD *)(v1 + 890) = 0;
    *(_WORD *)(v1 + 894) = 0;
    if ((*(unsigned int (**)(void))(**(void **)(v1 + 88) + 88))(*(void *)(v1 + 88)))
    {
      uint64_t v5 = *(NSObject **)(v1 + 72);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [1c] Remove 5G Capabilities", buf, 2u);
      }
      *(unsigned char *)(v1 + 904) = 0;
      *(void *)(v1 + 896) = 0;
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 88) + 72))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)buf);
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v9;
    int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
    if (v13)
    {
      uint64_t v15 = v13[3];
      signed int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_23:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v15)
        {
          (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v15 + 64))(__p, v15);
          ctu::parse_hex();
          unint64_t v24 = *(void **)(v1 + 848);
          if (v24)
          {
            *(void *)(v1 + 856) = v24;
            operator delete(v24);
            *(void *)(v1 + 848) = 0;
            *(void *)(v1 + 856) = 0;
            *(void *)(v1 + 864) = 0;
          }
          *(_OWORD *)(v1 + 848) = *(_OWORD *)buf;
          *(void *)(v1 + 864) = *(void *)&buf[16];
          memset(buf, 0, sizeof(buf));
          if (v27 < 0) {
            operator delete(__p[0]);
          }
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        return sub_1009BC048(*(void *)(v1 + 120), (uint64_t)buf, 1);
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    signed int v14 = 0;
    char v16 = 1;
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 41) == 3 && (int v17 = *(_DWORD *)(v1 + 156), v17 <= 2))
  {
    *(_DWORD *)(v1 + 156) = v17 + 1;
    int v18 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = asString();
      int v20 = *(_DWORD *)(v1 + 156);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [1c] Temporary error %s; paused (will be retry #%d)",
        buf,
        0x12u);
    }
    return sub_1009AB760(v1);
  }
  else
  {
    char v22 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[1c] Final error %s; Aborting",
        buf,
        0xCu);
    }
    uint64_t v23 = *(void *)(v1 + 120);
    buf[0] = 0;
    *(_DWORD *)&uint8_t buf[4] = 0;
    return sub_1009BAD84(v23, (uint64_t)buf, 1);
  }
}

void sub_1009AE22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  __cxa_free_exception(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_1009AE294(uint64_t result, uint64_t a2)
{
  *(_WORD *)(result + 72) = 0;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  int v2 = *(unsigned __int8 *)(a2 + 40);
  if (v2 == 2)
  {
    *(unsigned char *)(result + 40) = 2;
    __int16 v5 = *(_WORD *)(a2 + 41);
    *(unsigned char *)(result + 43) = *(unsigned char *)(a2 + 43);
    *(_WORD *)(result + 41) = v5;
  }
  else if (v2 == 1)
  {
    *(unsigned char *)(result + 40) = 1;
    long long v3 = *(_OWORD *)(a2 + 41);
    long long v4 = *(_OWORD *)(a2 + 57);
    *(unsigned char *)(result + 73) = *(unsigned char *)(a2 + 73);
    *(_OWORD *)(result + 57) = v4;
    *(_OWORD *)(result + 41) = v3;
  }
  return result;
}

uint64_t sub_1009AE2F0(uint64_t result)
{
  *(unsigned char *)(result + 40) = 0;
  return result;
}

void sub_1009AE2F8(void *a1, unsigned __int8 *a2)
{
  long long v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 352))
        {
          if (v9) {
            *(void *)(v5 + 360) = v8;
          }
          else {
            *(unsigned char *)(v5 + 352) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 360) = v8;
          *(unsigned char *)(v5 + 352) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009AE4B8;
        v15[3] = &unk_101A23980;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (unsigned int v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        signed int v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        int v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            int v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009AE49C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009AE4B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      uint64_t v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)char v31 = 136315394;
        *(void *)&v31[4] = v12;
        *(_WORD *)&v31[12] = 1024;
        *(_DWORD *)&v31[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [2] Failed with temporary error %s; paused (will be retry #%d)",
          v31,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      uint64_t v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)char v31 = 136315138;
        *(void *)&v31[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[2] Failed with final error %s; aborting",
          v31,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v31[0] = 0;
      *(_DWORD *)&v31[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v31, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        char v28 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v28);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)char v31 = _NSConcreteStackBlock;
        *(void *)&v31[8] = 0x40000000;
        *(void *)&v31[16] = sub_1004F09E8;
        int v32 = &unk_1019DB198;
        int v33 = v18;
        int v34 = 3;
        int v35 = v19;
        int v36 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v26 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v26);
    }
    long long v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)char v31 = 134217984;
      *(void *)&v31[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [2] Responded with %lu bytes", v31, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          char v27 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v27);
        }
        uint64_t v30 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v30);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeChallengeRsp");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_10074DF20((void *)(a1 + 48), (void *)(v2 + 632));
    if (v21)
    {
      char v22 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        unint64_t v24 = sub_100746C7C(v21);
        *(_DWORD *)char v31 = 136315138;
        *(void *)&v31[4] = v24;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[2] Failed; Aborting (%s)", v31, 0xCu);
      }
      uint64_t v23 = *(void *)(v2 + 120);
      v31[0] = 0;
      *(_DWORD *)&v31[4] = v21;
      return sub_1009BAD84(v23, (uint64_t)v31, 1);
    }
    else
    {
      return sub_1009BC38C(*(void *)(v2 + 120), (uint64_t)v31, 1);
    }
  }
  return result;
}

void sub_1009AE93C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009AE970(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5])
      {
LABEL_49:
        sub_10004D2C8(v7);
        return;
      }
      uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
      if (*(unsigned char *)(v5 + 368))
      {
        if (v9) {
          *(void *)(v5 + 376) = v8;
        }
        else {
          *(unsigned char *)(v5 + 368) = 0;
        }
      }
      else if (v9)
      {
        *(void *)(v5 + 376) = v8;
        *(unsigned char *)(v5 + 368) = 1;
      }
      int v10 = (NSObject **)(v5 + 72);
      std::string __p = 0;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      int v11 = sub_10132A828(v5, (os_log_t *)(v5 + 72), a2, 200, 0, (uint64_t)&__p);
      uint8_t v12 = v11;
      if (v11 != 10)
      {
        uint64_t v14 = *(void *)(v5 + 120);
        int v15 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
        buf[0] = v12;
        LODWORD(v41) = v15;
        sub_1009BAD84(v14, (uint64_t)buf, 1);
        goto LABEL_47;
      }
      uint64_t v13 = *(void *)(v5 + 128);
      if (v13) {
        sub_100EE8BC8(v13, "TapeInitAuthRsp");
      }
      else {
        *(void *)(v5 + 128) = 0;
      }
      uint64_t v16 = (unsigned __int8 **)(v5 + 704);
      unsigned int v17 = sub_1007474C4(&__p, v5 + 600, v5 + 704);
      if (v17)
      {
        int v18 = *v10;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          int v34 = sub_100746C54(v17);
          *(_DWORD *)long long buf = 136315138;
          uint64_t v41 = v34;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "[3] Failure (%s); Aborting",
            buf,
            0xCu);
        }
        if (*(unsigned char *)(v5 + 1368) && (v17 & 0xFD) == 0x18)
        {
          *(_WORD *)(v5 + 500) = 513;
          uint64_t v19 = *(void *)(v5 + 120);
          buf[0] = 9;
          LODWORD(v41) = v17;
          sub_1009BAD84(v19, (uint64_t)buf, 1);
        }
        else
        {
          *(_WORD *)(v5 + 500) = 1;
          uint64_t v28 = *(void *)(v5 + 120);
          buf[0] = 0;
          LODWORD(v41) = v17;
          sub_1009BAD84(v28, (uint64_t)buf, 1);
        }
        goto LABEL_47;
      }
      int v20 = *(unsigned __int8 **)(v5 + 568);
      signed __int8 v21 = v20[23];
      if (v21 >= 0) {
        uint64_t v22 = v20[23];
      }
      else {
        uint64_t v22 = *((void *)v20 + 1);
      }
      uint64_t v23 = *(unsigned __int8 *)(v5 + 727);
      int v24 = (char)v23;
      if ((v23 & 0x80u) != 0) {
        uint64_t v23 = *(void *)(v5 + 712);
      }
      if (v22 != v23) {
        goto LABEL_37;
      }
      if (v24 >= 0) {
        __int16 v25 = (unsigned __int8 *)(v5 + 704);
      }
      else {
        __int16 v25 = *v16;
      }
      if ((v20[23] & 0x80) != 0)
      {
        char v31 = *(unsigned __int8 **)v20;
        if (memcmp(*(const void **)v20, v25, *((void *)v20 + 1)))
        {
          uint64_t v29 = *v10;
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            goto LABEL_38;
          }
          int v20 = v31;
          goto LABEL_53;
        }
      }
      else if (v20[23])
      {
        uint64_t v26 = *(unsigned __int8 **)(v5 + 568);
        uint64_t v27 = v20[23];
        while (*v26 == *v25)
        {
          ++v26;
          ++v25;
          if (!--v27) {
            goto LABEL_42;
          }
        }
LABEL_37:
        uint64_t v29 = *v10;
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
LABEL_38:
          *(_WORD *)(v5 + 500) = 513;
          uint64_t v30 = *(void *)(v5 + 120);
          buf[0] = 0;
          LODWORD(v41) = 0;
          sub_1009BAD84(v30, (uint64_t)buf, 1);
LABEL_47:
          if (__p)
          {
            uint64_t v38 = __p;
            operator delete(__p);
          }
          goto LABEL_49;
        }
        if (v21 < 0) {
          int v20 = *(unsigned __int8 **)v20;
        }
LABEL_53:
        if (v24 < 0) {
          uint64_t v16 = (unsigned __int8 **)*v16;
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v41 = (const char *)v20;
        __int16 v42 = 2080;
        xpc_object_t v43 = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "[3] Failure Server Mismatch (%s) - [%s]; Aborting",
          buf,
          0x16u);
        goto LABEL_38;
      }
LABEL_42:
      if (v20[185]
        && v20[184]
        && (int v32 = *(const void **)(v5 + 776),
            size_t v33 = *(void *)(v5 + 784) - (void)v32,
            v33 == qword_101B0E3A8 - qword_101B0E3A0)
        && !memcmp(v32, (const void *)qword_101B0E3A0, v33))
      {
        int v35 = *v10;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "[3] GSMA PKID detected from Server; Aborting",
            buf,
            2u);
        }
        *(_WORD *)(v5 + 500) = 769;
        uint64_t v36 = *(void *)(v5 + 120);
        buf[0] = 9;
        LODWORD(v41) = 24;
        sub_1009BAD84(v36, (uint64_t)buf, 1);
      }
      else
      {
        *(_WORD *)(v5 + 500) = 257;
        sub_1009BC754(*(void *)(v5 + 120), (uint64_t)buf, 1);
      }
      goto LABEL_47;
    }
  }
}

void sub_1009AEDAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1009AEDF4(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 384))
        {
          if (v9) {
            *(void *)(v5 + 392) = v8;
          }
          else {
            *(unsigned char *)(v5 + 384) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 392) = v8;
          *(unsigned char *)(v5 + 384) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009AEFB4;
        v15[3] = &unk_101A23A10;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (uint8_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        uint64_t v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        int v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            int v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009AEF98(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009AEFB4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      uint64_t v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)int v34 = 136315394;
        *(void *)&uint8_t v34[4] = v12;
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [4] Temporary error %s; paused (will be retry #%d)",
          v34,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      int v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[4] Final error %s; aborting",
          v34,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v34, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)int v34 = _NSConcreteStackBlock;
        *(void *)&v34[8] = 0x40000000;
        *(void *)&v34[16] = sub_1004F09E8;
        int v35 = &unk_1019DB198;
        int v36 = v18;
        int v37 = 11;
        int v38 = v19;
        int v39 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v27 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v27);
    }
    long long v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)int v34 = 134217984;
      *(void *)&uint8_t v34[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [4] Responded with %lu bytes", v34, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          uint64_t v28 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v28);
        }
        int v32 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v32);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeAuthServerRsp");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        char v31 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v31);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_10074EB90(a1 + 48);
    if (v21)
    {
      uint64_t v22 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        __int16 v25 = sub_100746C7C(v21);
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[4] Failure (%s); Aborting", v34, 0xCu);
      }
      uint64_t v23 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = v21;
      return sub_1009BAD84(v23, (uint64_t)v34, 1);
    }
    else
    {
      int v24 = *(unsigned __int8 *)(a1 + 40);
      if (v24 != 1)
      {
        if (v24 == 2)
        {
          uint64_t v30 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v30);
        }
        size_t v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
      }
      if (v2 + 912 != a1 + 48) {
        sub_10006E4A8((void *)(v2 + 912), *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      }
      return sub_1009BCA98(*(void *)(v2 + 120), (uint64_t)v34, 1);
    }
  }
  return result;
}

void sub_1009AF4C4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009AF500(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5])
      {
LABEL_141:
        sub_10004D2C8(v7);
        return;
      }
      uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
      if (*(unsigned char *)(v5 + 400))
      {
        if (v9) {
          *(void *)(v5 + 408) = v8;
        }
        else {
          *(unsigned char *)(v5 + 400) = 0;
        }
      }
      else if (v9)
      {
        *(void *)(v5 + 408) = v8;
        *(unsigned char *)(v5 + 400) = 1;
      }
      int v10 = (os_log_t *)(v5 + 72);
      std::string __p = 0;
      xpc_object_t v75 = 0;
      uint64_t v76 = 0;
      int v11 = sub_10132A828(v5, (os_log_t *)(v5 + 72), a2, 200, 0, (uint64_t)&__p);
      uint8_t v12 = v11;
      if (v11 != 10)
      {
        uint64_t v14 = *(void *)(v5 + 120);
        int v15 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
        buf[0] = v12;
        *(_DWORD *)&uint8_t buf[4] = v15;
        sub_1009BAD84(v14, (uint64_t)buf, 1);
        goto LABEL_139;
      }
      uint64_t v13 = *(void *)(v5 + 128);
      if (v13) {
        sub_100EE8BC8(v13, "TapeAuthClientRsp");
      }
      else {
        *(void *)(v5 + 128) = 0;
      }
      unsigned int v16 = sub_10074A064(&__p, *(void *)(v5 + 568) + 72, (unsigned __int8 *)(v5 + 600), (void *)(v5 + 960));
      unsigned int v17 = v16;
      if (v16 > 0x1B) {
        goto LABEL_29;
      }
      if (((1 << v16) & 0x8024200) != 0)
      {
        int v18 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [5] No profile eligible.", buf, 2u);
        }
        uint64_t v19 = *(void *)(v5 + 568);
        uint64_t v20 = *(unsigned __int8 *)(v19 + 215);
        int v21 = (char)v20;
        if ((v20 & 0x80u) != 0) {
          uint64_t v20 = *(void *)(v19 + 200);
        }
        if (v20 != 4) {
          goto LABEL_25;
        }
        int v24 = *(_DWORD **)(v19 + 192);
        uint64_t v22 = (_DWORD *)(v19 + 192);
        uint64_t v23 = v24;
        if (v21 < 0) {
          uint64_t v22 = v23;
        }
        if (*v22 != 825241653)
        {
LABEL_25:
          sub_1009BCDDC(*(void *)(v5 + 120), (uint64_t)buf, 1);
          goto LABEL_139;
        }
        uint64_t v28 = *v10;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          int v55 = sub_100746C54(v17);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v55;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "[5] Install and Replace Failure (%s); Aborting",
            buf,
            0xCu);
        }
LABEL_37:
        uint64_t v27 = *(void *)(v5 + 120);
        buf[0] = 0;
        *(_DWORD *)&uint8_t buf[4] = v17;
        sub_1009BAD84(v27, (uint64_t)buf, 1);
LABEL_139:
        if (__p)
        {
          xpc_object_t v75 = __p;
          operator delete(__p);
        }
        goto LABEL_141;
      }
      if (v16 == 6)
      {
        __int16 v25 = *v10;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I [5] Invalid Profile Policy Id", buf, 2u);
        }
        *(unsigned char *)(v5 + 624) = 3;
        sub_1009BD120(*(void *)(v5 + 120), (uint64_t)buf, 1);
        goto LABEL_139;
      }
      if (v16 == 21)
      {
        *(unsigned char *)(*(void *)(v5 + 568) + 120) = 1;
      }
      else
      {
LABEL_29:
        if (v16)
        {
          uint64_t v26 = *v10;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            long long v54 = sub_100746C54(v17);
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v54;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "[5] Failure (%s); Aborting",
              buf,
              0xCu);
          }
          goto LABEL_37;
        }
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v80 = 0;
      if (*(char *)(v5 + 1095) < 0)
      {
        sub_10004FC84(buf, *(void **)(v5 + 1072), *(void *)(v5 + 1080));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)(v5 + 1072);
        uint64_t v80 = *(void *)(v5 + 1088);
      }
      if (*(char *)(v5 + 1143) < 0) {
        uint64_t v29 = *(void *)(v5 + 1128);
      }
      else {
        uint64_t v29 = *(unsigned __int8 *)(v5 + 1143);
      }
      if (v29) {
        sub_10032AFC0((unsigned char *)(v5 + 464), (const std::string *)(v5 + 1120));
      }
      int v30 = *(unsigned __int8 *)(v5 + 248);
      if (!*(unsigned char *)(v5 + 248)) {
        goto LABEL_116;
      }
      uint64_t v32 = *(void *)(v5 + 224);
      uint64_t v31 = *(void *)(v5 + 232);
      uint64_t v33 = v32;
      if (v32 != v31)
      {
        if (v80 >= 0) {
          uint64_t v34 = HIBYTE(v80);
        }
        else {
          uint64_t v34 = *(void *)&buf[8];
        }
        if (v80 >= 0) {
          int v35 = buf;
        }
        else {
          int v35 = *(uint8_t **)buf;
        }
        uint64_t v33 = *(void *)(v5 + 224);
        do
        {
          uint64_t v36 = *(unsigned __int8 *)(v33 + 39);
          if ((v36 & 0x80u) == 0) {
            uint64_t v37 = *(unsigned __int8 *)(v33 + 39);
          }
          else {
            uint64_t v37 = *(void *)(v33 + 24);
          }
          if (v37 == v34)
          {
            if ((v36 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v33 + 16), v35, *(void *)(v33 + 24))) {
                goto LABEL_69;
              }
            }
            else
            {
              if (!*(unsigned char *)(v33 + 39)) {
                goto LABEL_69;
              }
              uint64_t v38 = 0;
              while (*(unsigned __int8 *)(v33 + v38 + 16) == v35[v38])
              {
                if (v36 == ++v38) {
                  goto LABEL_69;
                }
              }
            }
          }
          v33 += 216;
        }
        while (v33 != v31);
        goto LABEL_101;
      }
LABEL_69:
      if (v33 == v31)
      {
LABEL_101:
        uint64_t v58 = v31;
        if (v32 != v31)
        {
          uint64_t v59 = v32;
          while (*(unsigned char *)(v59 + 88))
          {
            v59 += 216;
            if (v59 == v31) {
              goto LABEL_112;
            }
          }
          if (v59 != v31 && *(unsigned char *)(v5 + 1147))
          {
            xpc_object_t v60 = *v10;
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)xpc_object_t v77 = 0;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [5] PPR1 not allowed when Operational Profile has already been installed - Cancelling session", v77, 2u);
            }
            *(unsigned char *)(v5 + 624) = 3;
            sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v77, 1);
            goto LABEL_137;
          }
          do
          {
LABEL_112:
            if (*(unsigned char *)(v32 + 88))
            {
              uint64_t v58 = v32;
              goto LABEL_115;
            }
            v32 += 216;
          }
          while (v32 != v31);
          uint64_t v58 = v31;
        }
LABEL_115:
        int v30 = v58 != v31;
LABEL_116:
        if (!*(unsigned char *)(v5 + 1144) || ((*(unsigned char *)(*(void *)(v5 + 568) + 124) != 0) & ~v30) != 0)
        {
          if ((sub_10074D288((long long ***)(v5 + 1320), v5 + 1056, (_WORD *)(v5 + 162)) & 1) == 0)
          {
            xpc_object_t v69 = *v10;
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)xpc_object_t v77 = 0;
              _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I [5] PPR not valid", v77, 2u);
            }
            if (*(unsigned char *)(v5 + 162)) {
              char v70 = 0;
            }
            else {
              char v70 = 3;
            }
            *(unsigned char *)(v5 + 624) = v70;
            sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v77, 1);
            goto LABEL_137;
          }
          uint64_t v62 = *(void *)(v5 + 568);
          xpc_object_t v63 = *(const void ***)(v62 + 96);
          xpc_object_t v64 = *(const void ***)(v62 + 104);
          if (v63 != v64)
          {
            xpc_object_t v65 = sub_1009AFED8(v63, v64, (uint64_t)buf);
            uint64_t v66 = *(void *)(v5 + 568);
            if (*(const void ***)(v66 + 104) == v65)
            {
              if (*(char *)(v66 + 71) < 0) {
                uint64_t v71 = *(void *)(v66 + 56);
              }
              else {
                uint64_t v71 = *(unsigned __int8 *)(v66 + 71);
              }
              if (v71)
              {
                xpc_object_t v72 = *v10;
                if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)xpc_object_t v77 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I [5] No match prefix but has matching id", v77, 2u);
                }
                uint64_t v73 = *(void *)(v5 + 120);
                v77[0] = 8;
                LODWORD(v78) = 0;
                sub_1009BAD84(v73, (uint64_t)v77, 1);
                goto LABEL_137;
              }
            }
            else
            {
              xpc_object_t v67 = *v10;
              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)xpc_object_t v77 = 0;
                _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I [5] Profile to be installed matches prefix", v77, 2u);
              }
              *(unsigned char *)(v5 + 160) = 1;
            }
          }
          if (!*(unsigned char *)(v5 + 162))
          {
            uint64_t v68 = *(void *)(v5 + 256);
            if (v68) {
              (*(void (**)(uint64_t, uint64_t))(v68 + 16))(v68, v5 + 1056);
            }
          }
          sub_1009BD77C(*(void *)(v5 + 120), (uint64_t)v77, 1);
        }
        else
        {
          xpc_object_t v61 = *v10;
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)xpc_object_t v77 = 0;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I [5] Provisioning Profile not supported or installed already", v77, 2u);
          }
          *(unsigned char *)(v5 + 624) = 127;
          sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v77, 1);
        }
LABEL_137:
        if (SHIBYTE(v80) < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_139;
      }
      uint64_t v39 = *(void *)(v5 + 568);
      uint64_t v40 = *(unsigned __int8 *)(v39 + 215);
      int v41 = (char)v40;
      if ((v40 & 0x80u) != 0) {
        uint64_t v40 = *(void *)(v39 + 200);
      }
      if (v40 != 4 || (v41 >= 0 ? (__int16 v42 = (_DWORD *)(v39 + 192)) : (__int16 v42 = *(_DWORD **)(v39 + 192)), *v42 != 825241653))
      {
        xpc_object_t v43 = *v10;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)xpc_object_t v77 = 134217984;
          unint64_t v78 = 0x84BDA12F684BDA13 * ((v31 - v32) >> 3);
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [5] Profile has already been installed - aborting: %lu", v77, 0xCu);
        }
        uint64_t v44 = *(void *)(v5 + 120);
        v77[0] = 0;
        LODWORD(v78) = 0;
        sub_1009BAD84(v44, (uint64_t)v77, 1);
        goto LABEL_137;
      }
      uint64_t v45 = HIBYTE(v80);
      if (v80 >= 0) {
        uint64_t v46 = HIBYTE(v80);
      }
      else {
        uint64_t v46 = *(void *)&buf[8];
      }
      uint64_t v47 = *(unsigned __int8 *)(v39 + 239);
      int v48 = (char)v47;
      if ((v47 & 0x80u) != 0) {
        uint64_t v47 = *(void *)(v39 + 224);
      }
      if (v46 == v47)
      {
        uint64_t v51 = *(unsigned __int8 **)(v39 + 216);
        xpc_object_t v49 = (unsigned __int8 *)(v39 + 216);
        xpc_object_t v50 = v51;
        if (v48 >= 0) {
          unint64_t v52 = v49;
        }
        else {
          unint64_t v52 = v50;
        }
        if ((v80 & 0x8000000000000000) == 0)
        {
          if (HIBYTE(v80))
          {
            uint64_t v53 = buf;
            while (*v53 == *v52)
            {
              ++v53;
              ++v52;
              if (!--v45) {
                goto LABEL_99;
              }
            }
            goto LABEL_96;
          }
          goto LABEL_99;
        }
        if (!memcmp(*(const void **)buf, v52, *(size_t *)&buf[8]))
        {
LABEL_99:
          int v57 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)xpc_object_t v77 = 0;
            _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I [5] Install Replace mode detected; Continuing",
              v77,
              2u);
            uint64_t v32 = *(void *)(v5 + 224);
            uint64_t v31 = *(void *)(v5 + 232);
          }
          goto LABEL_101;
        }
      }
LABEL_96:
      int v56 = *v10;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)xpc_object_t v77 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "[5] Iccid to install and replace does not match the metadata iccid; Cancelling session",
          v77,
          2u);
      }
      *(unsigned char *)(v5 + 624) = 4;
      sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v77, 1);
      goto LABEL_137;
    }
  }
}

void sub_1009AFE54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a10) {
    operator delete(a10);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

const void **sub_1009AFED8(const void **a1, const void **a2, uint64_t a3)
{
  int v3 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      int v6 = *((char *)v3 + 23);
      if (v6 >= 0) {
        unint64_t v7 = *((unsigned __int8 *)v3 + 23);
      }
      else {
        unint64_t v7 = (unint64_t)v3[1];
      }
      if (*(char *)(a3 + 23) < 0)
      {
        if (v7 == -1) {
LABEL_51:
        }
          sub_1000C14D8();
        char v9 = *(const void **)a3;
        if (*(void *)(a3 + 8) >= v7) {
          size_t v8 = v7;
        }
        else {
          size_t v8 = *(void *)(a3 + 8);
        }
      }
      else
      {
        if (v7 == -1) {
          goto LABEL_51;
        }
        if (*(unsigned __int8 *)(a3 + 23) >= v7) {
          size_t v8 = v7;
        }
        else {
          size_t v8 = *(unsigned __int8 *)(a3 + 23);
        }
        char v9 = (const void *)a3;
      }
      if (v6 >= 0) {
        int v10 = v3;
      }
      else {
        int v10 = *v3;
      }
      if (!memcmp(v9, v10, v8) && v8 == v7) {
        return v3;
      }
      sub_100CD7084(a3, (uint64_t)__p);
      uint64_t v12 = *((unsigned __int8 *)v3 + 23);
      if ((v12 & 0x80u) == 0) {
        uint64_t v13 = (void *)*((unsigned __int8 *)v3 + 23);
      }
      else {
        uint64_t v13 = (void *)v3[1];
      }
      unint64_t v14 = v25;
      int v15 = (char)v25;
      if ((v25 & 0x80u) != 0) {
        unint64_t v14 = (unint64_t)__p[1];
      }
      if (v13 == (void *)v14)
      {
        if ((v25 & 0x80u) == 0) {
          unsigned int v16 = __p;
        }
        else {
          unsigned int v16 = (void **)__p[0];
        }
        if ((v12 & 0x80) != 0)
        {
          BOOL v21 = memcmp(*v3, v16, (size_t)v3[1]) == 0;
        }
        else
        {
          if (!*((unsigned char *)v3 + 23))
          {
            BOOL v21 = 1;
            if (((char)v25 & 0x80000000) == 0) {
              goto LABEL_45;
            }
LABEL_44:
            operator delete(__p[0]);
            goto LABEL_45;
          }
          uint64_t v17 = 0;
          uint64_t v18 = v12 - 1;
          do
          {
            int v19 = *((unsigned __int8 *)v3 + v17);
            int v20 = *((unsigned __int8 *)v16 + v17);
            BOOL v21 = v19 == v20;
          }
          while (v19 == v20 && v18 != v17++);
        }
        if (v15 < 0) {
          goto LABEL_44;
        }
      }
      else
      {
        BOOL v21 = 0;
        if ((char)v25 < 0) {
          goto LABEL_44;
        }
      }
LABEL_45:
      if (v21) {
        return v3;
      }
      v3 += 3;
      if (v3 == a2) {
        return a2;
      }
    }
  }
  return v3;
}

void sub_1009B005C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        int v6 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Aborting, consent timer expired", buf, 2u);
        }
        unint64_t v7 = *(std::__shared_weak_count **)(v3 + 144);
        *(void *)(v3 + 136) = 0;
        *(void *)(v3 + 144) = 0;
        if (v7) {
          sub_10004D2C8(v7);
        }
        *(_WORD *)(v3 + 162) = 769;
        *(unsigned char *)(v3 + 624) = 2;
        if (!*(unsigned char *)(v3 + 153) && *(unsigned char *)(v3 + 152))
        {
          *(unsigned char *)(v3 + 152) = 0;
          sub_1009B4BDC(*(void *)(v3 + 120), (uint64_t)&v8, 1);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009B0154(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009B0168(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      unint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B02EC;
        v13[3] = &unk_101A23AD0;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        char v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint64_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        uint64_t v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B02D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B02EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      int v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)uint64_t v31 = 136315394;
        *(void *)&v31[4] = v12;
        *(_WORD *)&v31[12] = 1024;
        *(_DWORD *)&v31[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [11] Temporary error %s; paused (will be retry #%d)",
          v31,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      int v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v31 = 136315138;
        *(void *)&v31[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[11] Final error %s; aborting",
          v31,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v31[0] = 0;
      *(_DWORD *)&v31[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v31, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v28 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v28);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)uint64_t v31 = _NSConcreteStackBlock;
        *(void *)&v31[8] = 0x40000000;
        *(void *)&v31[16] = sub_1004F09E8;
        uint64_t v32 = &unk_1019DB198;
        int v33 = v18;
        int v34 = 17;
        int v35 = v19;
        int v36 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v26 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v26);
    }
    long long v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)uint64_t v31 = 134217984;
      *(void *)&v31[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [11] Responded with %lu bytes", v31, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          uint64_t v27 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v27);
        }
        int v30 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v30);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeResetEuiccMemory");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_100753368(a1 + 48);
    if (v21)
    {
      uint64_t v22 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        int v24 = sub_100746C7C(v21);
        *(_DWORD *)uint64_t v31 = 136315138;
        *(void *)&v31[4] = v24;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[11] Failure (%s) - Aborting", v31, 0xCu);
      }
      uint64_t v23 = *(void *)(v2 + 120);
      v31[0] = 0;
      *(_DWORD *)&v31[4] = v21;
      return sub_1009BAD84(v23, (uint64_t)v31, 1);
    }
    else
    {
      return sub_1009BDB24(*(void *)(v2 + 120), (uint64_t)v31, 1);
    }
  }
  return result;
}

void sub_1009B076C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009B07A0(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 416))
        {
          if (v9) {
            *(void *)(v5 + 424) = v8;
          }
          else {
            *(unsigned char *)(v5 + 416) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 424) = v8;
          *(unsigned char *)(v5 + 416) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009B0960;
        v15[3] = &unk_101A23B30;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (uint64_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        unint64_t v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        int v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            int v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B0944(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B0960(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      uint64_t v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)int v34 = 136315394;
        *(void *)&uint8_t v34[4] = v12;
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [6] Temporary error %s; paused (will be retry #%d)",
          v34,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      int v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[6] Final error %s; aborting",
          v34,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v34, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)int v34 = _NSConcreteStackBlock;
        *(void *)&v34[8] = 0x40000000;
        *(void *)&v34[16] = sub_1004F09E8;
        int v35 = &unk_1019DB198;
        int v36 = v18;
        int v37 = 5;
        int v38 = v19;
        int v39 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v27 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v27);
    }
    long long v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)int v34 = 134217984;
      *(void *)&uint8_t v34[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [6] Responded with %lu bytes", v34, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          uint64_t v28 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v28);
        }
        uint64_t v32 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v32);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapePrepareDownloadRsp");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        uint64_t v31 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v31);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_10074F4C8(a1 + 48);
    if (v21)
    {
      uint64_t v22 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v25 = sub_100746C7C(v21);
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[6] Failure (%s) - Aborting", v34, 0xCu);
      }
      uint64_t v23 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = v21;
      return sub_1009BAD84(v23, (uint64_t)v34, 1);
    }
    else
    {
      int v24 = *(unsigned __int8 *)(a1 + 40);
      if (v24 != 1)
      {
        if (v24 == 2)
        {
          int v30 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v30);
        }
        int v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
      }
      if (v2 + 936 != a1 + 48) {
        sub_10006E4A8((void *)(v2 + 936), *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      }
      return sub_1009BDE68(*(void *)(v2 + 120), (uint64_t)v34, 1);
    }
  }
  return result;
}

void sub_1009B0E70(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009B0EAC(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5])
      {
LABEL_56:
        sub_10004D2C8(v7);
        return;
      }
      uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
      if (*(unsigned char *)(v5 + 432))
      {
        if (v9) {
          *(void *)(v5 + 440) = v8;
        }
        else {
          *(unsigned char *)(v5 + 432) = 0;
        }
      }
      else if (v9)
      {
        *(void *)(v5 + 440) = v8;
        *(unsigned char *)(v5 + 432) = 1;
      }
      int v10 = (NSObject **)(v5 + 72);
      int v36 = 0;
      int v37 = 0;
      uint64_t v38 = 0;
      int v11 = sub_10132A828(v5, (os_log_t *)(v5 + 72), a2, 200, 0, (uint64_t)&v36);
      uint8_t v12 = v11;
      if (v11 != 10)
      {
        uint64_t v14 = *(void *)(v5 + 120);
        int v15 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
        buf[0] = v12;
        *(_DWORD *)&uint8_t buf[4] = v15;
        sub_1009BAD84(v14, (uint64_t)buf, 1);
LABEL_54:
        if (v36)
        {
          int v37 = v36;
          operator delete(v36);
        }
        goto LABEL_56;
      }
      uint64_t v13 = *(void *)(v5 + 128);
      if (v13) {
        sub_100EE8BC8(v13, "TapeGetBoundProfileRsp");
      }
      else {
        *(void *)(v5 + 128) = 0;
      }
      unsigned int v16 = sub_10074AB34(&v36, (unsigned __int8 *)(v5 + 600), v5 + 1296);
      unsigned int v17 = v16;
      if (v16)
      {
        if (v16 == 30)
        {
          if (!*(unsigned char *)(v5 + 161))
          {
            uint64_t v27 = *v10;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = "kTransactionIdUnknown";
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "[7] Failure (%s) - Re-attempt install without consent", buf, 0xCu);
            }
            *(unsigned char *)(v5 + 161) = 1;
            *(_WORD *)(*(void *)(v5 + 568) + 122) = 0;
            if (*(char *)(v5 + 623) < 0)
            {
              **(unsigned char **)(v5 + 600) = 0;
              *(void *)(v5 + 608) = 0;
            }
            else
            {
              *(unsigned char *)(v5 + 600) = 0;
              *(unsigned char *)(v5 + 623) = 0;
            }
            *(void *)(v5 + 920) = *(void *)(v5 + 912);
            *(void *)(v5 + 944) = *(void *)(v5 + 936);
            sub_1009AB2A4((void *)(v5 + 960));
            sub_1009BC38C(*(void *)(v5 + 120), (uint64_t)buf, 1);
            goto LABEL_54;
          }
        }
        else if (v16 == 6)
        {
          int v18 = *v10;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "[7] Failure (InvalidProfilePolicy) - Cancelling session", buf, 2u);
          }
          *(unsigned char *)(v5 + 624) = 3;
          sub_1009BD120(*(void *)(v5 + 120), (uint64_t)buf, 1);
          goto LABEL_54;
        }
        int v19 = *v10;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = sub_100746C54(v17);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "[7] Failure (%s) - Aborting", buf, 0xCu);
        }
        uint64_t v20 = *(void *)(v5 + 128);
        if (v20) {
          sub_100EE8BC8(v20, "TapeGetBoundProfileRsp");
        }
        else {
          *(void *)(v5 + 128) = 0;
        }
        uint64_t v25 = *(void *)(v5 + 120);
        buf[0] = 0;
        *(_DWORD *)&uint8_t buf[4] = v17;
        sub_1009BAD84(v25, (uint64_t)buf, 1);
        goto LABEL_54;
      }
      *(_OWORD *)unint64_t v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)long long buf = 0u;
      v34[0] = 0;
      v34[1] = 0;
      uint64_t v35 = 0;
      std::string __p = 0;
      uint64_t v32 = 0;
      int v21 = *(const void **)(v5 + 1296);
      uint64_t v22 = *(void *)(v5 + 1304);
      uint64_t v33 = 0;
      sub_10005C928(&__p, v21, v22, v22 - (void)v21);
      int v23 = sub_10074FA50(&__p, (uint64_t)v34);
      if (__p)
      {
        uint64_t v32 = __p;
        operator delete(__p);
      }
      if ((v23 & 1) == 0)
      {
        uint64_t v26 = *v10;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int v30 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "[7] Cannot decode Bound Profile Package", v30, 2u);
        }
        *(unsigned char *)(v5 + 624) = 5;
        sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v30, 1);
        goto LABEL_47;
      }
      if (TapeProfileMetadata::operator!=())
      {
        if (__PAIR64__(BYTE11(v44), BYTE10(v44)) != __PAIR64__(*(unsigned __int8 *)(v5 + 1147), *(unsigned __int8 *)(v5 + 1146)))
        {
          uint64_t v28 = *v10;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)int v30 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "[7] Metadata mismatch [PPR IDs]", v30, 2u);
          }
          *(unsigned char *)(v5 + 624) = 3;
          sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v30, 1);
          goto LABEL_47;
        }
        int v24 = *v10;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int v30 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "[7] Metadata mismatch [Other]", v30, 2u);
        }
      }
      sub_1009BE1AC(*(void *)(v5 + 120), (uint64_t)v30, 1);
LABEL_47:
      if (SHIBYTE(v35) < 0) {
        operator delete(v34[0]);
      }
      if (v52[1])
      {
        *(void **)&long long v53 = v52[1];
        operator delete(v52[1]);
      }
      sub_1000C584C((uint64_t)buf);
      goto LABEL_54;
    }
  }
}

void sub_1009B13D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100799860((uint64_t)&a22);
  if (a19) {
    operator delete(a19);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_1009B1458(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B15DC;
        v13[3] = &unk_101A23BC0;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        uint64_t v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint8_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B15C4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B15DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [7a] Validating the disableTapeProfile", (uint8_t *)&v9, 2u);
  }
  if (*(unsigned char *)(a1 + 40) != 1)
  {
    uint64_t v7 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[7a] Disable profile driver failed; Cancelling session",
        (uint8_t *)&v9,
        2u);
    }
    goto LABEL_7;
  }
  int v4 = sub_1007519C8(a1 + 48, 1);
  uint64_t v5 = *(NSObject **)(v2 + 72);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = sub_100746C7C(v4);
      int v9 = 136315138;
      int v10 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[7a] Disable profile failed: %s; Cancelling session",
        (uint8_t *)&v9,
        0xCu);
    }
LABEL_7:
    *(unsigned char *)(v2 + 624) = 5;
    return sub_1009BD120(*(void *)(v2 + 120), (uint64_t)&v9, 1);
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [7a] Disable profile response validation success", (uint8_t *)&v9, 2u);
  }
  *(unsigned char *)(v2 + 1400) = 1;
  return sub_1009BE65C(*(void *)(v2 + 120), (uint64_t)&v9, 1);
}

void sub_1009B17B4(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B1938;
        v13[3] = &unk_101A23C20;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        uint64_t v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint8_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B1920(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B1938(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [7b] Validating the deleteTapeProfile", (uint8_t *)&v9, 2u);
  }
  if (*(unsigned char *)(a1 + 40) != 1)
  {
    uint64_t v7 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[7b] Delete profile driver failed; Cancelling session",
        (uint8_t *)&v9,
        2u);
    }
    goto LABEL_7;
  }
  int v4 = sub_1007519C8(a1 + 48, 2);
  uint64_t v5 = *(NSObject **)(v2 + 72);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = sub_100746C7C(v4);
      int v9 = 136315138;
      int v10 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[7b] Delete profile response validation failed: %s; Cancelling session",
        (uint8_t *)&v9,
        0xCu);
    }
LABEL_7:
    *(unsigned char *)(v2 + 624) = 5;
    return sub_1009BD120(*(void *)(v2 + 120), (uint64_t)&v9, 1);
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [7b] Delete profile response validation success", (uint8_t *)&v9, 2u);
  }
  return sub_1009BE9A0(*(void *)(v2 + 120), (uint64_t)&v9, 1);
}

void sub_1009B1B08(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B1C8C;
        v13[3] = &unk_101A23C80;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        uint64_t v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint8_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B1C74(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009B1C8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  if (v2 == 1)
  {
    int v11 = 0;
    uint8_t v12 = 0;
    uint64_t v13 = 0;
    sub_10005C928(&v11, *(const void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
    memset(v10, 0, sizeof(v10));
    int v3 = sub_100751D1C((uint64_t *)&v11);
    if (v3)
    {
      if (v3 == 9)
      {
        int v4 = *(NSObject **)(v1 + 72);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[7c] List Notification failed; Cancelling session",
            buf,
            2u);
        }
      }
      else
      {
        int v6 = *(NSObject **)(v1 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "[7c] List notification response failure; Cancelling session",
            buf,
            2u);
        }
        uint64_t v7 = *(void *)(v1 + 128);
        if (v7) {
          sub_100EE8BC8(v7, "ListNotificationRsp");
        }
        else {
          *(void *)(v1 + 128) = 0;
        }
      }
      *(unsigned char *)(v1 + 624) = 5;
      sub_1009BD120(*(void *)(v1 + 120), (uint64_t)buf, 1);
    }
    else
    {
      uint64_t v8 = *(NSObject **)(v1 + 72);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [7c] Empty notification list; skipping delete notification",
          buf,
          2u);
      }
      sub_1009BE1AC(*(void *)(v1 + 120), (uint64_t)buf, 1);
    }
    *(void *)long long buf = v10;
    sub_10079AAD4((void ***)buf);
    if (v11)
    {
      uint8_t v12 = v11;
      operator delete(v11);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      if (v2 != 2)
      {
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[7c] List notification failed with final error %s; Cancelling session",
        buf,
        0xCu);
    }
    *(unsigned char *)(v1 + 624) = 5;
    sub_1009BD120(*(void *)(v1 + 120), (uint64_t)buf, 1);
  }
}

void sub_1009B21D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char *a26)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  a26 = &a20;
  sub_10079AAD4((void ***)&a26);
  if (a23)
  {
    a24 = (uint64_t)a23;
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

void sub_1009B2248(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B23CC;
        v13[3] = &unk_101A23CE0;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        uint64_t v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint8_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B23B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B23CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 != 1)
  {
    uint64_t v9 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (v3 != 2) {
        goto LABEL_22;
      }
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "[7d] Notification deletion failed with final error %s; Cancelling session",
        __p,
        0xCu);
    }
    goto LABEL_7;
  }
  uint64_t v4 = *(void *)(v2 + 128);
  if (v4)
  {
    sub_100EE8BC8(v4, "[7d] DeleteNotificationRsp");
    int v5 = *(unsigned __int8 *)(a1 + 40);
    if (v5 != 1)
    {
      if (v5 == 2)
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(exception);
        uint64_t v8 = &ctu::ResultIsError::~ResultIsError;
        goto LABEL_23;
      }
LABEL_22:
      exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      uint64_t v8 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_23:
      __cxa_throw(exception, v7, (void (*)(void *))v8);
    }
  }
  else
  {
    *(void *)(v2 + 128) = 0;
  }
  int v11 = sub_1007530DC(a1 + 48);
  uint8_t v12 = *(NSObject **)(v2 + 72);
  if (v11)
  {
    if (os_log_type_enabled(*(os_log_t *)(v2 + 72), OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[7d] Decoding failed; Cancelling session",
        __p,
        2u);
    }
LABEL_7:
    *(unsigned char *)(v2 + 624) = 5;
    return sub_1009BD120(*(void *)(v2 + 120), (uint64_t)__p, 1);
  }
  if (os_log_type_enabled(*(os_log_t *)(v2 + 72), OS_LOG_TYPE_DEFAULT))
  {
    ctu::hex();
    if (v15 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [7d] Notification SEQ # = %s deleted", buf, 0xCu);
    if (v15 < 0) {
      operator delete(*(void **)__p);
    }
  }
  return sub_1009BF028(*(void *)(v2 + 120), (uint64_t)__p, 1);
}

void sub_1009B2638(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009B265C(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B27E0;
        v13[3] = &unk_101A23D40;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        uint64_t v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        uint8_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            unsigned int v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B27C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B27E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [12] Validating the enableTapeProfile", (uint8_t *)&v9, 2u);
  }
  if (*(unsigned char *)(a1 + 40) == 1)
  {
    int v4 = sub_1007519C8(a1 + 48, 0);
    int v5 = *(NSObject **)(v2 + 72);
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = sub_100746C7C(v4);
        int v9 = 136315138;
        int v10 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[12] Enable profile failed: %s", (uint8_t *)&v9, 0xCu);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [12] Enable profile response validation success", (uint8_t *)&v9, 2u);
    }
  }
  else
  {
    int v6 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "[12] Enable profile driver failed", (uint8_t *)&v9, 2u);
    }
  }
  return sub_1009BF36C(*(void *)(v2 + 120), (uint64_t)&v9, 1);
}

void sub_1009B29A0(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = CTStopwatch::stop((CTStopwatch *)(v5 + 536));
        if (*(unsigned char *)(v5 + 448))
        {
          if (v9) {
            *(void *)(v5 + 456) = v8;
          }
          else {
            *(unsigned char *)(v5 + 448) = 0;
          }
        }
        else if (v9)
        {
          *(void *)(v5 + 456) = v8;
          *(unsigned char *)(v5 + 448) = 1;
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        unint64_t v15[2] = sub_1009B2B60;
        v15[3] = &unk_101A23DA0;
        v15[4] = v5;
        sub_1007A816C((uint64_t)v16, a2);
        int v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v10 || (v11 = *(void *)(v5 + 40), (uint8_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        uint64_t v14 = *(NSObject **)(v5 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v11;
        uint64_t v20 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10004D2C8(v13);
        if (v16[0] == 1)
        {
          if (__p)
          {
            int v18 = __p;
            operator delete(__p);
          }
        }
        v16[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B2B44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B2B60(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      uint64_t v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = v12;
        *(_WORD *)&unsigned char __p[12] = 1024;
        *(_DWORD *)&__p[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [8] Temporary error %s; paused (will be retry #%d)",
          __p,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      char v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[8] Final error %s; aborting",
          __p,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 88);
      __p[0] = 0;
      LOBYTE(v39) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v16 + 32))(v16, __p);
      if ((_BYTE)v39 && *(void *)__p)
      {
        *(void *)&__p[8] = *(void *)__p;
        operator delete(*(void **)__p);
      }
      *(unsigned char *)(v2 + 624) = 1;
      uint64_t result = sub_1009BD120(*(void *)(v2 + 120), (uint64_t)__p, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v35 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v35);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)std::string __p = _NSConcreteStackBlock;
        *(void *)&__p[8] = 0x40000000;
        *(void *)&__p[16] = sub_1004F09E8;
        int v39 = &unk_1019DB198;
        int v40 = v18;
        int v41 = 6;
        int v42 = v19;
        int v43 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
    }
    int v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)std::string __p = 134217984;
      *(void *)&__p[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [8] Responded with %lu bytes", __p, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          int v34 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v34);
        }
        int v37 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v37);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeProfileInstallResult");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          char v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        int v36 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v36);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_100750204(a1 + 48);
    int v22 = v21;
    if (v21 == 19)
    {
      uint64_t v26 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [8] Insufficient memory", __p, 2u);
      }
      uint64_t v27 = *(void *)(v2 + 120);
      __p[0] = 5;
      *(_DWORD *)&__p[4] = 0;
      return sub_1009BAD84(v27, (uint64_t)__p, 1);
    }
    else if (v21 == 18)
    {
      int v24 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [8] Profile alredy exists", __p, 2u);
      }
      uint64_t v25 = *(void *)(v2 + 120);
      __p[0] = 6;
      *(_DWORD *)&__p[4] = 0;
      return sub_1009BAD84(v25, (uint64_t)__p, 1);
    }
    else if (v21)
    {
      uint64_t v28 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        uint64_t v31 = sub_100746C7C(v22);
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v31;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "[8] Installation failure: %s", __p, 0xCu);
      }
      uint64_t v29 = *(void *)(v2 + 88);
      __p[0] = 0;
      LOBYTE(v39) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 32))(v29, __p);
      if ((_BYTE)v39 && *(void *)__p)
      {
        *(void *)&__p[8] = *(void *)__p;
        operator delete(*(void **)__p);
      }
      uint64_t v30 = *(void *)(v2 + 120);
      __p[0] = 0;
      *(_DWORD *)&__p[4] = v22;
      return sub_1009BAD84(v30, (uint64_t)__p, 1);
    }
    else
    {
      uint64_t v23 = *(void *)(v2 + 88);
      __p[0] = 0;
      LOBYTE(v39) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v23 + 32))(v23, __p);
      if ((_BYTE)v39 && *(void *)__p)
      {
        *(void *)&__p[8] = *(void *)__p;
        operator delete(*(void **)__p);
      }
      return sub_1009BF734(*(void *)(v2 + 120), (uint64_t)__p, 1);
    }
  }
  return result;
}

void sub_1009B318C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (a12)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1009B31E8(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B336C;
        v13[3] = &unk_101A23E00;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        int v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v11 = v10;
        uint64_t v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B3354(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B336C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 1)
  {
    uint64_t v4 = *(void *)(v2 + 128);
    if (v4)
    {
      sub_100EE8BC8(v4, "CardProfiles");
      int v5 = *(unsigned __int8 *)(a1 + 40);
      int v18 = 0;
      uint64_t v19 = 0;
      int v20 = 0;
      if (v5 != 1)
      {
        if (v5 == 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v7 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
        }
        else
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v7 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        }
        __cxa_throw(exception, v8, (void (*)(void *))v7);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
      int v18 = 0;
      uint64_t v19 = 0;
      int v20 = 0;
    }
    int v13 = sub_10074B41C((uint64_t *)(a1 + 48));
    uint64_t v14 = *(NSObject **)(v2 + 72);
    if (v13)
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = sub_100746C7C(v13);
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[9] Failure (%s)", buf, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = 0x84BDA12F684BDA13 * ((v19 - (uint64_t)v18) >> 3);
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Decoded %lu profiles from baseband", buf, 0xCu);
      }
      sub_1008793A4(v2 + 224, (uint64_t)&v18);
    }
    *(void *)long long buf = &v18;
    sub_1000C57C8((void ***)buf);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "[0] Result failed", (uint8_t *)&v18, 2u);
      int v3 = *(unsigned __int8 *)(a1 + 40);
    }
    if (v3 != 2)
    {
      if (v3 == 1)
      {
        uint64_t v16 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v16);
      }
      int v17 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v17);
    }
    if (*(unsigned char *)(a1 + 48) == 2)
    {
      int v10 = *(_DWORD *)(v2 + 80);
      int v11 = *(unsigned __int8 *)(a1 + 49);
      int v12 = *(unsigned __int8 *)(a1 + 50);
      int v18 = _NSConcreteStackBlock;
      uint64_t v19 = 0x40000000;
      int v20 = sub_1004F09E8;
      int v21 = &unk_1019DB198;
      int v22 = v10;
      int v23 = 13;
      int v24 = v11;
      int v25 = v12;
      sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
  return sub_1009BFB1C(*(void *)(v2 + 120), (uint64_t)&v18, 1);
}

void sub_1009B36A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t *a15)
{
  __cxa_free_exception(v15);
  a15 = &a9;
  sub_1000C57C8((void ***)&a15);
  _Unwind_Resume(a1);
}

void sub_1009B36F0(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B3874;
        v13[3] = &unk_101A23E60;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        int v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        int v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B385C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009B3874(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v10 = *(_DWORD *)(v2 + 156), v10 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v10 + 1;
      int v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        int v13 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)int v34 = 136315394;
        *(void *)&uint8_t v34[4] = v12;
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [10] Temporary error %s; paused (will be retry #%d)",
          v34,
          0x12u);
      }
      return sub_1009AB760(v2);
    }
    else
    {
      char v15 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[10] Final error %s; aborting",
          v34,
          0xCu);
      }
      uint64_t v16 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = 0;
      uint64_t result = sub_1009BAD84(v16, (uint64_t)v34, 1);
      int v17 = *(unsigned __int8 *)(a1 + 40);
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v18 = *(_DWORD *)(v2 + 80);
        int v19 = *(unsigned __int8 *)(a1 + 49);
        int v20 = *(unsigned __int8 *)(a1 + 50);
        *(void *)int v34 = _NSConcreteStackBlock;
        *(void *)&v34[8] = 0x40000000;
        *(void *)&v34[16] = sub_1004F09E8;
        uint64_t v35 = &unk_1019DB198;
        int v36 = v18;
        int v37 = 12;
        int v38 = v19;
        int v39 = v20;
        return sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v27 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v27);
    }
    uint64_t v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)int v34 = 134217984;
      *(void *)&uint8_t v34[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [10] Tape Data created with %lu bytes", v34, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          uint64_t v28 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v28);
        }
        uint64_t v32 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v32);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "TapeCancelSessionRsp");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v9);
        }
        uint64_t v31 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v31);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
    }
    int v21 = sub_1007508EC(a1 + 48);
    if (v21)
    {
      int v22 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        int v25 = sub_100746C7C(v21);
        *(_DWORD *)int v34 = 136315138;
        *(void *)&uint8_t v34[4] = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[10] Failure (%s) - Aborting", v34, 0xCu);
      }
      uint64_t v23 = *(void *)(v2 + 120);
      v34[0] = 0;
      *(_DWORD *)&uint8_t v34[4] = v21;
      return sub_1009BAD84(v23, (uint64_t)v34, 1);
    }
    else
    {
      int v24 = *(unsigned __int8 *)(a1 + 40);
      if (v24 != 1)
      {
        if (v24 == 2)
        {
          uint64_t v30 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v30);
        }
        uint64_t v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
      }
      if (v2 + 1344 != a1 + 48) {
        sub_10006E4A8((void *)(v2 + 1344), *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
      }
      return sub_1009BFED0(*(void *)(v2 + 120), (uint64_t)v34, 1);
    }
  }
  return result;
}

void sub_1009B3D84(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1009B3DC0(void *a1, void *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        std::string __p = 0;
        int v19 = 0;
        uint64_t v20 = 0;
        int v8 = sub_10132A828(v5, (os_log_t *)(v5 + 72), a2, 200, 0, (uint64_t)&__p);
        uint8_t v9 = v8;
        if (v8 == 10)
        {
          uint64_t v10 = *(void *)(v5 + 128);
          if (v10) {
            sub_100EE8BC8(v10, "TapeCancelSessionServerRsp");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          unsigned int v13 = sub_10074B070(&__p);
          if (v13)
          {
            uint64_t v14 = *(NSObject **)(v5 + 72);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            {
              int v17 = sub_100746C54(v13);
              *(_DWORD *)long long buf = 136315138;
              int v22 = v17;
              _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[11] Decoding Failure: (%s) - continuing", buf, 0xCu);
            }
          }
          int v15 = *(unsigned __int8 *)(v5 + 624);
          uint64_t v16 = *(void *)(v5 + 120);
          if (v15 == 3)
          {
            buf[0] = 7;
            LODWORD(v22) = 3;
          }
          else
          {
            buf[0] = 0;
            LODWORD(v22) = v15;
          }
          sub_1009BAD84(v16, (uint64_t)buf, 1);
        }
        else
        {
          uint64_t v11 = *(void *)(v5 + 120);
          int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
          buf[0] = v9;
          LODWORD(v22) = v12;
          sub_1009BAD84(v11, (uint64_t)buf, 1);
        }
        if (__p)
        {
          int v19 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B3FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1009B3FD8(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        void v13[2] = sub_1009B415C;
        v13[3] = &unk_101A23EF0;
        v13[4] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        int v8 = (std::__shared_weak_count *)v5[6];
        if (!v8 || (uint64_t v9 = v5[5], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v11 = v10;
        int v12 = v5[7];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1009BBCC8;
        block[3] = &unk_101A24298;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009B4144(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009B415C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 2)
  {
    if (*(unsigned char *)(a1 + 48) == 3 && (int v12 = *(_DWORD *)(v2 + 156), v12 <= 2))
    {
      *(_DWORD *)(v2 + 156) = v12 + 1;
      unsigned int v13 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        int v15 = *(_DWORD *)(v2 + 156);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v14;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [1+] Temporary error %s; paused (will be retry #%d)",
          buf,
          0x12u);
      }
      sub_1009AB760(v2);
    }
    else
    {
      uint64_t v16 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[1+] Final error %s; clearing & aborting",
          buf,
          0xCu);
      }
      uint64_t v17 = *(void *)(v2 + 88);
      buf[0] = 0;
      LOBYTE(v37) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v17 + 32))(v17, buf);
      if ((_BYTE)v37 && *(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      uint64_t v18 = *(void *)(v2 + 120);
      buf[0] = 0;
      *(_DWORD *)&uint8_t buf[4] = 0;
      sub_1009BAD84(v18, (uint64_t)buf, 1);
      int v19 = *(unsigned __int8 *)(a1 + 40);
      if (v19 != 2)
      {
        if (v19 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v31 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v31);
      }
      if (*(unsigned char *)(a1 + 48) == 2)
      {
        int v20 = *(_DWORD *)(v2 + 80);
        int v21 = *(unsigned __int8 *)(a1 + 49);
        int v22 = *(unsigned __int8 *)(a1 + 50);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_1004F09E8;
        int v37 = &unk_1019DB198;
        int v38 = v20;
        int v39 = 21;
        int v40 = v21;
        int v41 = v22;
        sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v29 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v29);
    }
    uint64_t v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56) - *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [1+] Get Session Data with %lu bytes", buf, 0xCu);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      if (v6 != 1)
      {
        if (v6 == 2)
        {
          uint64_t v30 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(v30);
        }
        uint64_t v32 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v32);
      }
    }
    uint64_t v7 = *(void *)(v2 + 128);
    if (v7)
    {
      sub_100EE8BC8(v7, "GetSessionData");
      int v8 = *(unsigned __int8 *)(a1 + 40);
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      if (v8 != 1)
      {
        if (v8 == 2)
        {
          uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v10 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(v9);
        }
        else
        {
          uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v10 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(v9);
        }
        __cxa_throw(v9, v11, (void (*)(void *))v10);
      }
    }
    else
    {
      *(void *)(v2 + 128) = 0;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
    }
    if (sub_1007537AC(a1 + 48))
    {
      int v25 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[1+] Cannot find transaction id; clearing & aborting",
          buf,
          2u);
      }
      uint64_t v26 = *(void *)(v2 + 88);
      buf[0] = 0;
      LOBYTE(v37) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v26 + 32))(v26, buf);
      if ((_BYTE)v37 && *(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }
    else
    {
      uint64_t v23 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "[1+] Failed to decode; clearing & aborting",
          buf,
          2u);
      }
      uint64_t v24 = *(void *)(v2 + 88);
      buf[0] = 0;
      LOBYTE(v37) = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v24 + 32))(v24, buf);
      if ((_BYTE)v37 && *(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }
    uint64_t v27 = *(void *)(v2 + 120);
    buf[0] = 0;
    *(_DWORD *)&uint8_t buf[4] = 0;
    sub_1009BAD84(v27, (uint64_t)buf, 1);
    *(void *)long long buf = &v33;
    sub_100047F64((void ***)buf);
  }
}

void sub_1009B47C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *__p, uint64_t a14, uint64_t a15, char a16)
{
  std::string __p = &a10;
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

unsigned char *sub_1009B4870(uint64_t a1, unsigned __int8 a2, char a3, uint64_t a4)
{
  BOOL v6 = a3 != 0;
  sub_1000C5DA8((uint64_t)&v9, a4);
  v8[0] = 1;
  (*(void (**)(uint64_t, void, BOOL, char *))(a1 + 16))(a1, a2, v6, v8);
  return sub_1000C60A0(v8);
}

void sub_1009B4918(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C60A0(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_1009B4934(uint64_t a1, unsigned __int8 a2, char a3, uint64_t a4)
{
  BOOL v6 = a3 != 0;
  sub_1000C5DA8((uint64_t)&v9, a4);
  v8[0] = 1;
  (*(void (**)(uint64_t, void, BOOL, char *))(a1 + 16))(a1, a2, v6, v8);
  return sub_1000C60A0(v8);
}

void sub_1009B49DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C60A0(va);
  _Unwind_Resume(a1);
}

void sub_1009B49F8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 4;
        BOOL v6 = v4;
        sub_10016A9A4(&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1009B4A6C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  int v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 48);
  if (v5)
  {
    *(void *)(a1 + 56) = v5;
    operator delete(v5);
  }
  BOOL v6 = *(void **)(a1 + 24);
  if (v6)
  {
    *(void *)(a1 + 32) = v6;
    operator delete(v6);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1009B4B04(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009B4B3C(uint64_t a1)
{
}

uint64_t sub_1009B4B58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009B4B9C(uint64_t result)
{
  if (result)
  {
    sub_1009AAFB0(result);
    operator delete();
  }
  return result;
}

uint64_t sub_1009B4BDC(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 31))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009B4D54(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5"
                                        "RetryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5RetryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009B4E60(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t *sub_1009B4E94(uint64_t *result)
{
  if (result[9])
  {
    uint64_t v1 = result;
    uint64_t v2 = (int64x2_t *)(result + 4);
    do
    {
      memset(v6, 0, sizeof(v6));
      uint64_t v3 = *(void *)(v1[5] + (((unint64_t)v1[8] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v1[8] & 0x7F);
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3)
      {
        *(void *)&v6[0] = *(void *)v3;
        if (v4)
        {
          long long v5 = *(_OWORD *)(v3 + 8);
          *((void *)&v6[1] + 1) = *(void *)(v3 + 24);
          *(_OWORD *)((char *)v6 + 8) = v5;
        }
        else
        {
          (*(void (**)(uint64_t, char *, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(v3 + 8, (char *)v6 + 8, 0);
        }
      }
      sub_1000983B4(v2);
      sub_100098420(v6);
      uint64_t result = sub_100098288((uint64_t *)v6);
    }
    while (v1[9]);
  }
  return result;
}

void sub_1009B4F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1009B4F6C()
{
  return 0;
}

uint64_t sub_1009B4F74(uint64_t a1, int a2, int a3)
{
  if (a3 != 21) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 21;
  (*(void (**)(void))(**(void **)(a1 + 8) + 176))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 21;
  return 1;
}

uint64_t sub_1009B4FF4(uint64_t a1, int a2, int a3)
{
  if (a3 != 19) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 19;
  (*(void (**)(void))(**(void **)(a1 + 8) + 152))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 19;
  return 1;
}

uint64_t sub_1009B5074(uint64_t a1, int a2, int a3)
{
  if (a3 != 18) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 18;
  (*(void (**)(void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 18;
  return 1;
}

uint64_t sub_1009B50F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 17) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 17;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009B5174(uint64_t a1, int a2, int a3)
{
  if (a3 != 16) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 16;
  (*(void (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 16;
  return 1;
}

uint64_t sub_1009B51F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 11) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 11;
  (*(void (**)(void))(**(void **)(a1 + 8) + 96))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 11;
  return 1;
}

uint64_t sub_1009B5274(uint64_t a1, int a2, int a3)
{
  if (a3 != 10) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 10;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009B52F8(uint64_t a1, int a2, int a3)
{
  if (a3 != 9) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 9;
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 9;
  return 1;
}

uint64_t sub_1009B5378(uint64_t a1, int a2, int a3)
{
  if (a3 != 8) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 208))(*(void *)(a1 + 8)))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 8;
    (*(void (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
    *(_DWORD *)(v5 + 24) = 8;
  }
  else if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 224))(*(void *)(a1 + 8)))
  {
    uint64_t v6 = a1 + 4 * a2;
    *(_DWORD *)(v6 + 24) = 8;
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    *(_DWORD *)(v6 + 24) = 9;
  }
  else
  {
    int v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 216))(*(void *)(a1 + 8));
    uint64_t v8 = a1 + 4 * a2;
    *(_DWORD *)(v8 + 24) = 8;
    uint64_t v9 = (int *)(v8 + 24);
    uint64_t v10 = **(void **)(a1 + 8);
    if (v7)
    {
      (*(void (**)(void))(v10 + 88))();
      int v11 = 10;
    }
    else
    {
      (*(void (**)(void))(v10 + 160))();
      int v11 = 17;
    }
    *uint64_t v9 = v11;
  }
  return 1;
}

uint64_t sub_1009B553C(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 7;
  (*(void (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 7;
  return 1;
}

uint64_t sub_1009B55BC(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 6;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009B5640(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 5;
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 5;
  return 1;
}

uint64_t sub_1009B56C0(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 4;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009B5740(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 3;
  (*(void (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 3;
  return 1;
}

uint64_t sub_1009B57C0(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 2;
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 2;
  return 1;
}

uint64_t sub_1009B5840(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 1;
  (*(void (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 1;
  return 1;
}

void sub_1009B58C0(uint64_t a1)
{
  sub_1000B3D68((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void sub_1009B591C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009B5954(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009B5984(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1009B59C8(void *a1)
{
  *a1 = off_101A24100;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1009B5A14(void *a1)
{
  *a1 = off_101A24100;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1009B5A80(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = operator new(3uLL);
          *(_WORD *)uint64_t v6 = 8383;
          _OWORD v6[2] = 0;
          int v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [1a] Sending to SIM", (uint8_t *)v14, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v8 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v8 || (uint64_t v9 = *(void *)(v5 + 40), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
            sub_100088B9C();
          }
          int v11 = v10;
          p_shared_weak_owners = &v10->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v10);
          uint64_t v17 = 0;
          uint64_t v18 = 0;
          std::string __p = 0;
          sub_10005C928(&__p, v6, (uint64_t)(v6 + 3), 3uLL);
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 1174405120;
          std::string v14[2] = sub_1009ACCD0;
          void v14[3] = &unk_101A23890;
          uint8_t v14[4] = v5;
          v14[5] = v9;
          int v15 = v11;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::getTapeEuiccInfo();
          if (__p)
          {
            uint64_t v17 = __p;
            operator delete(__p);
          }
          if (v15) {
            std::__shared_weak_count::__release_weak(v15);
          }
          std::__shared_weak_count::__release_weak(v11);
          operator delete(v6);
        }
        else
        {
          unsigned int v13 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [1a] Paused", (uint8_t *)v14, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B5CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v19);
  operator delete(v18);
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_1009B5D0C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [1b] Sending to SIM", (uint8_t *)v13, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          int v7 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v7 || (v8 = *(void *)(v5 + 40), (uint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v10 = v9;
          p_shared_weak_owners = &v9->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 1174405120;
          void v13[2] = sub_1009AD644;
          v13[3] = &unk_101A238F0;
          v13[4] = v5;
          void v13[5] = v8;
          uint64_t v14 = v10;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeGetRulesAuthTable();
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          int v12 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [1b] Paused", (uint8_t *)v13, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B5EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1009B5EF4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [1c] Sending to baseband", (uint8_t *)v13, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          int v7 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v7 || (v8 = *(void *)(v5 + 40), (uint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v10 = v9;
          p_shared_weak_owners = &v9->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 1174405120;
          void v13[2] = sub_1009ADC9C;
          v13[3] = &unk_101A23950;
          v13[4] = v5;
          void v13[5] = v8;
          uint64_t v14 = v10;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeGetDeviceCapabilities();
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          int v12 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [1c] Paused", (uint8_t *)v13, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B60A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1009B60D8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = operator new(3uLL);
          *(_WORD *)uint64_t v6 = 11967;
          _OWORD v6[2] = 0;
          int v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [2] Sending to SIM", (uint8_t *)v14, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v8 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v8 || (uint64_t v9 = *(void *)(v5 + 40), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
            sub_100088B9C();
          }
          int v11 = v10;
          p_shared_weak_owners = &v10->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v10);
          uint64_t v17 = 0;
          uint64_t v18 = 0;
          std::string __p = 0;
          sub_10005C928(&__p, v6, (uint64_t)(v6 + 3), 3uLL);
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 1174405120;
          std::string v14[2] = sub_1009AE2F8;
          void v14[3] = &unk_101A239B0;
          uint8_t v14[4] = v5;
          v14[5] = v9;
          int v15 = v11;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::getTapeEuiccChallenge();
          if (__p)
          {
            uint64_t v17 = __p;
            operator delete(__p);
          }
          if (v15) {
            std::__shared_weak_count::__release_weak(v15);
          }
          std::__shared_weak_count::__release_weak(v11);
          operator delete(v6);
        }
        else
        {
          unsigned int v13 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [2] Paused", (uint8_t *)v14, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B6308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v19);
  operator delete(v18);
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_1009B6364(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        int v37 = 0;
        int v38 = 0;
        uint64_t v39 = 0;
        if (sub_100747164(v5 + 632, (uint64_t)&v37))
        {
          uint64_t v6 = *(void *)(v5 + 128);
          if (v6) {
            sub_100EE8BC8(v6, "TapeInitAuthReq");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          uint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [3] Starting", buf, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          sub_10132A1C0(v5, &v34);
          (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 88) + 72))(&v32);
          long long v33 = v32;
          long long v32 = 0uLL;
          std::operator+<char>();
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 280);
          uint64_t v30 = *(void *)(v5 + 272);
          uint64_t v31 = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10132A438((Registry **)&v33, "/gsma/rsp2/es9plus/initiateAuthentication", (uint64_t)buf, (uint64_t)&v37, (void *)(v5 + 56), (uint64_t)&v34, __p, &v30);
          long long v11 = *(_OWORD *)__p;
          __p[0] = 0;
          __p[1] = 0;
          int v12 = *(std::__shared_weak_count **)(v5 + 280);
          *(_OWORD *)(v5 + 272) = v11;
          if (v12)
          {
            sub_10004D2C8(v12);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(*(void **)buf);
          }
          if (*((void *)&v33 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
          }
          if (*((void *)&v32 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
          }
          uint64_t v13 = *(void *)(v5 + 272);
          sub_100062740((const void **)buf, (const void **)(v5 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v13 + 72))(v13, *(void *)buf);
          sub_100044D00((const void **)buf);
          (*(void (**)(void, Block_layout *))(**(void **)(v5 + 272) + 240))(*(void *)(v5 + 272), &stru_101AB2198);
          uint64_t v14 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v14 || (v15 = *(void *)(v5 + 40), (uint64_t v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v17 = v16;
          p_shared_weak_owners = &v16->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          uint64_t v19 = *(void *)(v5 + 272);
          *(void *)long long buf = _NSConcreteStackBlock;
          uint64_t v24 = 1174405120;
          int v25 = sub_1009AE970;
          uint64_t v26 = &unk_101A239E0;
          uint64_t v27 = v5;
          uint64_t v28 = v15;
          uint64_t v29 = v17;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v19 + 16))(v19, buf);
          uint64_t v20 = *(void *)(v5 + 272);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v20 + 40))(v20, __p);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
          if (v29) {
            std::__shared_weak_count::__release_weak(v29);
          }
          std::__shared_weak_count::__release_weak(v17);
          sub_10010C0E0((uint64_t)&v34, v35);
        }
        else
        {
          int v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [3] Failed to encode request; Aborting",
              buf,
              2u);
          }
          uint64_t v8 = *(void *)(v5 + 120);
          buf[0] = 0;
          *(_DWORD *)&uint8_t buf[4] = 0;
          sub_1009BAD84(v8, (uint64_t)buf, 1);
        }
        if (v37)
        {
          int v38 = v37;
          operator delete(v37);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B6778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  std::__shared_weak_count::__release_weak(v33);
  sub_10010C0E0(v34 - 112, *(void **)(v34 - 104));
  uint64_t v36 = *(void **)(v34 - 88);
  if (v36)
  {
    *(void *)(v34 - 80) = v36;
    operator delete(v36);
  }
  sub_10004D2C8(v32);
  _Unwind_Resume(a1);
}

void sub_1009B684C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          int v21 = 0;
          char v22 = 0;
          uint64_t v23 = 0;
          std::string::operator=((std::string *)(v5 + 824), (const std::string *)(*(void *)(v5 + 568) + 48));
          if (sub_10074E1A8(v5 + 704, &v21))
          {
            uint64_t v6 = *(void *)(v5 + 128);
            if (v6) {
              sub_100EE8BC8(v6, "TapeAuthServerReq");
            }
            else {
              *(void *)(v5 + 128) = 0;
            }
            uint64_t v10 = *(NSObject **)(v5 + 72);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v16[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [4] Sending to SIM", (uint8_t *)v16, 2u);
            }
            CTStopwatch::start((CTStopwatch *)(v5 + 536));
            long long v11 = *(std::__shared_weak_count **)(v5 + 48);
            if (!v11 || (uint64_t v12 = *(void *)(v5 + 40), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v14 = v13;
            p_shared_weak_owners = &v13->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v13);
            uint64_t v19 = 0;
            uint64_t v20 = 0;
            std::string __p = 0;
            sub_10005C928(&__p, v21, (uint64_t)v22, v22 - (unsigned char *)v21);
            v16[0] = _NSConcreteStackBlock;
            v16[1] = 1174405120;
            void v16[2] = sub_1009AEDF4;
            uint64_t v16[3] = &unk_101A23A40;
            int v16[4] = v5;
            v16[5] = v12;
            uint64_t v17 = v14;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            VinylCommandDriver::tapeAuthenticateServer();
            if (__p)
            {
              uint64_t v19 = __p;
              operator delete(__p);
            }
            if (v17) {
              std::__shared_weak_count::__release_weak(v17);
            }
            std::__shared_weak_count::__release_weak(v14);
          }
          else
          {
            int v7 = *(NSObject **)(v5 + 72);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v16[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[4] Cannot encode request; Aborting",
                (uint8_t *)v16,
                2u);
            }
            uint64_t v8 = *(void *)(v5 + 120);
            LOBYTE(v16[0]) = 0;
            HIDWORD(v16[0]) = 0;
            sub_1009BAD84(v8, (uint64_t)v16, 1);
          }
          if (v21)
          {
            char v22 = v21;
            operator delete(v21);
          }
        }
        else
        {
          uint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v16[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [4] Paused", (uint8_t *)v16, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B6AFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v22);
  if (a20) {
    operator delete(a20);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1009B6B5C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        int v37 = 0;
        int v38 = 0;
        uint64_t v39 = 0;
        if (sub_1007483B0((uint64_t *)(v5 + 600), v5 + 912, (uint64_t)&v37))
        {
          uint64_t v6 = *(void *)(v5 + 128);
          if (v6) {
            sub_100EE8BC8(v6, "TapeAuthClientReq");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          uint64_t v9 = *(NSObject **)(v5 + 72);
          *(unsigned char *)(v5 + 162) = 0;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [5] Starting", buf, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          sub_10132A1C0(v5, &v34);
          (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 88) + 72))(&v32);
          long long v33 = v32;
          long long v32 = 0uLL;
          std::operator+<char>();
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 280);
          uint64_t v30 = *(void *)(v5 + 272);
          uint64_t v31 = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10132A438((Registry **)&v33, "/gsma/rsp2/es9plus/authenticateClient", (uint64_t)buf, (uint64_t)&v37, (void *)(v5 + 56), (uint64_t)&v34, __p, &v30);
          long long v11 = *(_OWORD *)__p;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v12 = *(std::__shared_weak_count **)(v5 + 280);
          *(_OWORD *)(v5 + 272) = v11;
          if (v12)
          {
            sub_10004D2C8(v12);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(*(void **)buf);
          }
          if (*((void *)&v33 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
          }
          if (*((void *)&v32 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
          }
          uint64_t v13 = *(void *)(v5 + 272);
          sub_100062740((const void **)buf, (const void **)(v5 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v13 + 72))(v13, *(void *)buf);
          sub_100044D00((const void **)buf);
          (*(void (**)(void, Block_layout *))(**(void **)(v5 + 272) + 240))(*(void *)(v5 + 272), &stru_101AB2198);
          uint64_t v14 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v14 || (v15 = *(void *)(v5 + 40), (uint64_t v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v17 = v16;
          p_shared_weak_owners = &v16->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          uint64_t v19 = *(void *)(v5 + 272);
          *(void *)long long buf = _NSConcreteStackBlock;
          uint64_t v24 = 1174405120;
          int v25 = sub_1009AF500;
          uint64_t v26 = &unk_101A23A70;
          uint64_t v27 = v5;
          uint64_t v28 = v15;
          uint64_t v29 = v17;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v19 + 16))(v19, buf);
          uint64_t v20 = *(void *)(v5 + 272);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v20 + 40))(v20, __p);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
          if (v29) {
            std::__shared_weak_count::__release_weak(v29);
          }
          std::__shared_weak_count::__release_weak(v17);
          sub_10010C0E0((uint64_t)&v34, v35);
        }
        else
        {
          int v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [5] Failed to encode request; Aborting",
              buf,
              2u);
          }
          uint64_t v8 = *(void *)(v5 + 120);
          buf[0] = 0;
          *(_DWORD *)&uint8_t buf[4] = 0;
          sub_1009BAD84(v8, (uint64_t)buf, 1);
        }
        if (v37)
        {
          int v38 = v37;
          operator delete(v37);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B6F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  std::__shared_weak_count::__release_weak(v33);
  sub_10010C0E0(v34 - 112, *(void **)(v34 - 104));
  uint64_t v36 = *(void **)(v34 - 88);
  if (v36)
  {
    *(void *)(v34 - 80) = v36;
    operator delete(v36);
  }
  sub_10004D2C8(v32);
  _Unwind_Resume(a1);
}

void sub_1009B704C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (!v5) {
    goto LABEL_32;
  }
  if (!*(unsigned char *)(v5 + 162))
  {
LABEL_11:
    int v7 = *(NSObject **)(v5 + 72);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [?] User consent requested", (uint8_t *)v15, 2u);
    }
    sub_1009AB760(v5);
    uint64_t v8 = *(std::__shared_weak_count **)(v5 + 48);
    if (!v8 || (uint64_t v9 = *(void *)(v5 + 40), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
      sub_100088B9C();
    }
    long long v11 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    (*(void (**)(Registry **__return_ptr))(**(void **)(v5 + 88) + 72))(&v21);
    Registry::getTimerService(&v23, v21);
    uint64_t v12 = v23;
    sub_100058DB0(__p, "TapeInstallOperation");
    uint64_t v13 = *(NSObject **)(v5 + 56);
    dispatch_object_t object = v13;
    if (v13) {
      dispatch_retain(v13);
    }
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 1174405120;
    unint64_t v15[2] = sub_1009B005C;
    v15[3] = &unk_101A23AA0;
    v15[4] = v5;
    void v15[5] = v9;
    uint64_t v16 = v11;
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    aBlocuint64_t k = _Block_copy(v15);
    sub_100118A44(v12, (uint64_t)__p, 1, 240000000, &object, &aBlock);
    sub_1004DC2E0((void *)(v5 + 136), &v25);
    uint64_t v14 = v25;
    uint64_t v25 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v16) {
      std::__shared_weak_count::__release_weak(v16);
    }
    std::__shared_weak_count::__release_weak(v11);
    goto LABEL_32;
  }
  uint64_t v6 = *(void *)(v5 + 568);
  if (!*(unsigned char *)(v6 + 120)) {
    goto LABEL_32;
  }
  if (*(char *)(v6 + 95) < 0)
  {
    if (*(void *)(v6 + 80)) {
      goto LABEL_32;
    }
    goto LABEL_11;
  }
  if (!*(unsigned char *)(v6 + 95)) {
    goto LABEL_11;
  }
LABEL_32:

  sub_10004D2C8(v4);
}

void sub_1009B72E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v28 = *(void *)(v26 - 56);
  *(void *)(v26 - 56) = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v26 - 64);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v26 - 80);
  if (v30) {
    sub_10004D2C8(v30);
  }
  std::__shared_weak_count::__release_weak(v25);
  sub_10004D2C8(v24);
  _Unwind_Resume(a1);
}

void sub_1009B73B0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [11] Sending to SIM", (uint8_t *)v13, 2u);
          }
          int v7 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v7 || (v8 = *(void *)(v5 + 40), (uint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v10 = v9;
          p_shared_weak_owners = &v9->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 1174405120;
          void v13[2] = sub_1009B0168;
          v13[3] = &unk_101A23B00;
          v13[4] = v5;
          void v13[5] = v8;
          uint64_t v14 = v10;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeResetMemory();
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          uint64_t v12 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [11] Paused", (uint8_t *)v13, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B7560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1009B7590(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    if (!*(unsigned char *)(v5 + 153) && *(unsigned char *)(v5 + 152))
    {
      int v7 = *(NSObject **)(v5 + 72);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v19[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [6] Paused", (uint8_t *)v19, 2u);
      }
      goto LABEL_31;
    }
    if (*(void *)(v5 + 1008) != *(void *)(v5 + 1016))
    {
LABEL_6:
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      if (sub_10074F130((char **)(v5 + 960), &v24))
      {
        uint64_t v6 = *(void *)(v5 + 128);
        if (v6) {
          sub_100EE8BC8(v6, "TapePrepareDownloadReq");
        }
        else {
          *(void *)(v5 + 128) = 0;
        }
        long long v11 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v19[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [6] Sending to SIM", (uint8_t *)v19, 2u);
        }
        CTStopwatch::start((CTStopwatch *)(v5 + 536));
        *(unsigned char *)(v5 + 154) = 0;
        uint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v12 || (v13 = *(void *)(v5 + 40), (uint64_t v14 = std::__shared_weak_count::lock(v12)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v15 = v14;
        p_shared_weak_owners = &v14->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v22 = 0;
        uint64_t v23 = 0;
        std::string __p = 0;
        sub_10005C928(&__p, v24, (uint64_t)v25, v25 - (unsigned char *)v24);
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 1174405120;
        void v19[2] = sub_1009B07A0;
        void v19[3] = &unk_101A23B60;
        v19[4] = v5;
        v19[5] = v13;
        char v20 = v15;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        VinylCommandDriver::tapePrepareDownload();
        if (__p)
        {
          char v22 = __p;
          operator delete(__p);
        }
        if (v20) {
          std::__shared_weak_count::__release_weak(v20);
        }
        std::__shared_weak_count::__release_weak(v15);
      }
      else
      {
        uint64_t v8 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "[6] Cannot encode request; aborting",
            (uint8_t *)v19,
            2u);
        }
        uint64_t v9 = *(void *)(v5 + 120);
        LOBYTE(v19[0]) = 0;
        HIDWORD(v19[0]) = 0;
        sub_1009BAD84(v9, (uint64_t)v19, 1);
      }
      if (v24)
      {
        uint64_t v25 = v24;
        operator delete(v24);
      }
      goto LABEL_31;
    }
    uint64_t v10 = *(void *)(v5 + 568);
    if (*(char *)(v10 + 95) < 0)
    {
      if (!*(void *)(v10 + 80)) {
        goto LABEL_6;
      }
    }
    else if (!*(unsigned char *)(v10 + 95))
    {
      goto LABEL_6;
    }
    if ((sub_10074A770(v5 + 600, (const void **)(v10 + 72), v5 + 960) & 1) == 0)
    {
      uint64_t v17 = *(NSObject **)(v5 + 72);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v19[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "[6] Failed to hash the confirmation code; aborting",
          (uint8_t *)v19,
          2u);
      }
      uint64_t v18 = *(void *)(v5 + 120);
      LOBYTE(v19[0]) = 0;
      HIDWORD(v19[0]) = 0;
      sub_1009BAD84(v18, (uint64_t)v19, 1);
      goto LABEL_31;
    }
    goto LABEL_6;
  }
LABEL_31:

  sub_10004D2C8(v4);
}

void sub_1009B78D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1009B7940(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        int v37 = 0;
        int v38 = 0;
        uint64_t v39 = 0;
        if (sub_10074A97C((uint64_t *)(v5 + 600), v5 + 936, (uint64_t)&v37))
        {
          uint64_t v6 = *(void *)(v5 + 128);
          if (v6) {
            sub_100EE8BC8(v6, "TapeGetBoundProfile");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          uint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [7] Starting", buf, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          sub_10132A1C0(v5, &v34);
          (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 88) + 72))(&v32);
          long long v33 = v32;
          long long v32 = 0uLL;
          std::operator+<char>();
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 280);
          uint64_t v30 = *(void *)(v5 + 272);
          uint64_t v31 = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10132A438((Registry **)&v33, "/gsma/rsp2/es9plus/getBoundProfilePackage", (uint64_t)buf, (uint64_t)&v37, (void *)(v5 + 56), (uint64_t)&v34, __p, &v30);
          long long v11 = *(_OWORD *)__p;
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v12 = *(std::__shared_weak_count **)(v5 + 280);
          *(_OWORD *)(v5 + 272) = v11;
          if (v12)
          {
            sub_10004D2C8(v12);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(*(void **)buf);
          }
          if (*((void *)&v33 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
          }
          if (*((void *)&v32 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
          }
          uint64_t v13 = *(void *)(v5 + 272);
          sub_100062740((const void **)buf, (const void **)(v5 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v13 + 72))(v13, *(void *)buf);
          sub_100044D00((const void **)buf);
          (*(void (**)(void, Block_layout *))(**(void **)(v5 + 272) + 240))(*(void *)(v5 + 272), &stru_101AB2198);
          uint64_t v14 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v14 || (v15 = *(void *)(v5 + 40), (uint64_t v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v17 = v16;
          p_shared_weak_owners = &v16->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          uint64_t v19 = *(void *)(v5 + 272);
          *(void *)long long buf = _NSConcreteStackBlock;
          uint64_t v24 = 1174405120;
          uint64_t v25 = sub_1009B0EAC;
          uint64_t v26 = &unk_101A23B90;
          uint64_t v27 = v5;
          uint64_t v28 = v15;
          uint64_t v29 = v17;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v19 + 16))(v19, buf);
          uint64_t v20 = *(void *)(v5 + 272);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v20 + 40))(v20, __p);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
          if (v29) {
            std::__shared_weak_count::__release_weak(v29);
          }
          std::__shared_weak_count::__release_weak(v17);
          sub_10010C0E0((uint64_t)&v34, v35);
        }
        else
        {
          int v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [7] Failed to encode request - aborting", buf, 2u);
          }
          uint64_t v8 = *(void *)(v5 + 120);
          buf[0] = 0;
          *(_DWORD *)&uint8_t buf[4] = 0;
          sub_1009BAD84(v8, (uint64_t)buf, 1);
        }
        if (v37)
        {
          int v38 = v37;
          operator delete(v37);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B7D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  std::__shared_weak_count::__release_weak(v33);
  sub_10010C0E0(v34 - 112, *(void **)(v34 - 104));
  uint64_t v36 = *(void **)(v34 - 88);
  if (v36)
  {
    *(void *)(v34 - 80) = v36;
    operator delete(v36);
  }
  sub_10004D2C8(v32);
  _Unwind_Resume(a1);
}

void sub_1009B7E2C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(v5 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [7a] Starting", buf, 2u);
    }
    uint64_t v7 = *(void *)(v5 + 568);
    uint64_t v8 = (void **)(v7 + 216);
    if (*(char *)(v7 + 239) < 0)
    {
      unint64_t v9 = *(void *)(v7 + 224);
      if (v9)
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v34 = 0;
        sub_10004FC84(buf, *v8, v9);
LABEL_12:
        uint64_t v10 = *(void *)(v5 + 224);
        uint64_t v11 = *(void *)(v5 + 232);
        if (v10 == v11)
        {
LABEL_32:
          uint64_t v17 = *(NSObject **)(v5 + 72);
          if (v10 != v11)
          {
            if (os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35) = 0;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [7a] Iccid to disable found", (uint8_t *)&v35, 2u);
              uint64_t v17 = *(NSObject **)(v5 + 72);
            }
            int v18 = *(unsigned __int8 *)(v10 + 89);
            BOOL v19 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
            if (v18)
            {
              if (v19)
              {
                LOWORD(v35) = 0;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [7a] Encoding Disable profile", (uint8_t *)&v35, 2u);
              }
              long long v35 = 0uLL;
              uint64_t v36 = 0;
              BOOL v20 = sub_1007513C0((uint64_t)buf, 0, 0, (uint64_t)&v35);
              int v21 = *(NSObject **)(v5 + 72);
              if (v20)
              {
                if (os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long v32 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I [7a] Disabling profile", v32, 2u);
                }
                char v22 = *(std::__shared_weak_count **)(v5 + 48);
                if (!v22 || (uint64_t v23 = std::__shared_weak_count::lock(v22)) == 0) {
                  sub_100088B9C();
                }
                uint64_t v24 = v23;
                p_shared_weak_owners = &v23->__shared_weak_owners_;
                atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v23);
                uint64_t v30 = 0;
                uint64_t v31 = 0;
                std::string __p = 0;
                sub_10005C928(&__p, (const void *)v35, *((uint64_t *)&v35 + 1), *((void *)&v35 + 1) - v35);
                atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                VinylCommandDriver::disableTapeProfile();
                if (__p)
                {
                  uint64_t v30 = __p;
                  operator delete(__p);
                }
                std::__shared_weak_count::__release_weak(v24);
                std::__shared_weak_count::__release_weak(v24);
              }
              else
              {
                if (os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long v32 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "[7a] encodeTapeProfileSelectReq error; Cancelling session",
                    v32,
                    2u);
                }
                *(unsigned char *)(v5 + 624) = 5;
                sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v32, 1);
              }
              if ((void)v35)
              {
                *((void *)&v35 + 1) = v35;
                operator delete((void *)v35);
              }
            }
            else
            {
              if (v19)
              {
                LOWORD(v35) = 0;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [7a] Profile already disabled", (uint8_t *)&v35, 2u);
              }
              sub_1009BE65C(*(void *)(v5 + 120), (uint64_t)&v35, 1);
            }
LABEL_62:
            if (SHIBYTE(v34) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_64;
          }
        }
        else
        {
          if (v34 >= 0) {
            uint64_t v12 = HIBYTE(v34);
          }
          else {
            uint64_t v12 = *(void *)&buf[8];
          }
          if (v34 >= 0) {
            uint64_t v13 = buf;
          }
          else {
            uint64_t v13 = *(uint8_t **)buf;
          }
          do
          {
            uint64_t v14 = *(unsigned __int8 *)(v10 + 39);
            if ((v14 & 0x80u) == 0) {
              uint64_t v15 = *(unsigned __int8 *)(v10 + 39);
            }
            else {
              uint64_t v15 = *(void *)(v10 + 24);
            }
            if (v15 == v12)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v10 + 16), v13, *(void *)(v10 + 24))) {
                  goto LABEL_32;
                }
              }
              else
              {
                if (!*(unsigned char *)(v10 + 39)) {
                  goto LABEL_32;
                }
                uint64_t v16 = 0;
                while (*(unsigned __int8 *)(v10 + v16 + 16) == v13[v16])
                {
                  if (v14 == ++v16) {
                    goto LABEL_32;
                  }
                }
              }
            }
            v10 += 216;
          }
          while (v10 != v11);
          uint64_t v17 = *(NSObject **)(v5 + 72);
        }
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = *(void *)(v5 + 568);
          uint64_t v28 = (void *)(v27 + 216);
          if (*(char *)(v27 + 239) < 0) {
            uint64_t v28 = (void *)*v28;
          }
          LODWORD(v35) = 136315138;
          *(void *)((char *)&v35 + 4) = v28;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [7a] Iccid = %s does not exist, will go through normal install without disable and delete flow", (uint8_t *)&v35, 0xCu);
        }
        sub_1009BE1AC(*(void *)(v5 + 120), (uint64_t)&v35, 1);
        goto LABEL_62;
      }
    }
    else if (*(unsigned char *)(v7 + 239))
    {
      *(_OWORD *)long long buf = *(_OWORD *)v8;
      uint64_t v34 = *(void *)(v7 + 232);
      goto LABEL_12;
    }
    uint64_t v26 = *(NSObject **)(v5 + 72);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [7a] Iccid to disable is empty, will go through normal install without disable and delete flow", buf, 2u);
    }
    sub_1009BE1AC(*(void *)(v5 + 120), (uint64_t)buf, 1);
  }
LABEL_64:

  sub_10004D2C8(v4);
}

void sub_1009B834C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v27);
  uint64_t v30 = *(void **)(v28 - 96);
  if (v30)
  {
    *(void *)(v28 - 88) = v30;
    operator delete(v30);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_10004D2C8(v26);
  _Unwind_Resume(a1);
}

void sub_1009B83D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(v5 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [12] Starting", buf, 2u);
    }
    uint64_t v7 = *(void *)(v5 + 568);
    uint64_t v8 = (void **)(v7 + 216);
    if (*(char *)(v7 + 239) < 0)
    {
      unint64_t v9 = *(void *)(v7 + 224);
      if (v9)
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v34 = 0;
        sub_10004FC84(buf, *v8, v9);
LABEL_12:
        uint64_t v10 = *(void *)(v5 + 224);
        uint64_t v11 = *(void *)(v5 + 232);
        if (v10 == v11)
        {
LABEL_32:
          uint64_t v17 = *(NSObject **)(v5 + 72);
          if (v10 != v11)
          {
            int v18 = *(unsigned __int8 *)(v10 + 89);
            BOOL v19 = os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_DEFAULT);
            if (!v18)
            {
              if (v19)
              {
                LOWORD(v35) = 0;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [12] Encoding Enable profile", (uint8_t *)&v35, 2u);
              }
              long long v35 = 0uLL;
              uint64_t v36 = 0;
              BOOL v23 = sub_1007513C0((uint64_t)buf, 1, 0, (uint64_t)&v35);
              uint64_t v24 = *(NSObject **)(v5 + 72);
              if (v23)
              {
                if (os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long v32 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [12] Enabling profile", v32, 2u);
                }
                uint64_t v25 = *(std::__shared_weak_count **)(v5 + 48);
                if (!v25 || (uint64_t v26 = std::__shared_weak_count::lock(v25)) == 0) {
                  sub_100088B9C();
                }
                uint64_t v27 = v26;
                p_shared_weak_owners = &v26->__shared_weak_owners_;
                atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v26);
                uint64_t v30 = 0;
                uint64_t v31 = 0;
                std::string __p = 0;
                sub_10005C928(&__p, (const void *)v35, *((uint64_t *)&v35 + 1), *((void *)&v35 + 1) - v35);
                atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                VinylCommandDriver::enableTapeProfile();
                if (__p)
                {
                  uint64_t v30 = __p;
                  operator delete(__p);
                }
                std::__shared_weak_count::__release_weak(v27);
                std::__shared_weak_count::__release_weak(v27);
              }
              else
              {
                if (os_log_type_enabled(*(os_log_t *)(v5 + 72), OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long v32 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "[12] encodeTapeProfileSelectReq error", v32, 2u);
                }
                sub_1009BF36C(*(void *)(v5 + 120), (uint64_t)v32, 1);
              }
              if ((void)v35)
              {
                *((void *)&v35 + 1) = v35;
                operator delete((void *)v35);
              }
              goto LABEL_60;
            }
            if (v19)
            {
              LOWORD(v35) = 0;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [12] Profile already enabled", (uint8_t *)&v35, 2u);
            }
LABEL_36:
            sub_1009BF36C(*(void *)(v5 + 120), (uint64_t)&v35, 1);
LABEL_60:
            if (SHIBYTE(v34) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_62;
          }
        }
        else
        {
          if (v34 >= 0) {
            uint64_t v12 = HIBYTE(v34);
          }
          else {
            uint64_t v12 = *(void *)&buf[8];
          }
          if (v34 >= 0) {
            uint64_t v13 = buf;
          }
          else {
            uint64_t v13 = *(uint8_t **)buf;
          }
          do
          {
            uint64_t v14 = *(unsigned __int8 *)(v10 + 39);
            if ((v14 & 0x80u) == 0) {
              uint64_t v15 = *(unsigned __int8 *)(v10 + 39);
            }
            else {
              uint64_t v15 = *(void *)(v10 + 24);
            }
            if (v15 == v12)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v10 + 16), v13, *(void *)(v10 + 24))) {
                  goto LABEL_32;
                }
              }
              else
              {
                if (!*(unsigned char *)(v10 + 39)) {
                  goto LABEL_32;
                }
                uint64_t v16 = 0;
                while (*(unsigned __int8 *)(v10 + v16 + 16) == v13[v16])
                {
                  if (v14 == ++v16) {
                    goto LABEL_32;
                  }
                }
              }
            }
            v10 += 216;
          }
          while (v10 != v11);
          uint64_t v17 = *(NSObject **)(v5 + 72);
        }
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *(void *)(v5 + 568);
          char v22 = (void *)(v21 + 216);
          if (*(char *)(v21 + 239) < 0) {
            char v22 = (void *)*v22;
          }
          LODWORD(v35) = 136315138;
          *(void *)((char *)&v35 + 4) = v22;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [12] Iccid = %s does not exist, will not enable", (uint8_t *)&v35, 0xCu);
        }
        goto LABEL_36;
      }
    }
    else if (*(unsigned char *)(v7 + 239))
    {
      *(_OWORD *)long long buf = *(_OWORD *)v8;
      uint64_t v34 = *(void *)(v7 + 232);
      goto LABEL_12;
    }
    BOOL v20 = *(NSObject **)(v5 + 72);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [12] Iccid to enable is empty, skipping profile eanble", buf, 2u);
    }
    sub_1009BF36C(*(void *)(v5 + 120), (uint64_t)buf, 1);
  }
LABEL_62:

  sub_10004D2C8(v4);
}

void sub_1009B88A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v27);
  uint64_t v30 = *(void **)(v28 - 96);
  if (v30)
  {
    *(void *)(v28 - 88) = v30;
    operator delete(v30);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_10004D2C8(v26);
  _Unwind_Resume(a1);
}

void sub_1009B892C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        uint64_t v6 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v15[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [7b] Starting", (uint8_t *)v15, 2u);
          uint64_t v6 = *(NSObject **)(v5 + 72);
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v15[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [7b] Encoding delete profile", (uint8_t *)v15, 2u);
        }
        char v22 = 0;
        BOOL v23 = 0;
        uint64_t v24 = 0;
        uint64_t v7 = *(void *)(v5 + 568);
        if (*(char *)(v7 + 239) < 0)
        {
          sub_10004FC84(__p, *(void **)(v7 + 216), *(void *)(v7 + 224));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v7 + 216);
          uint64_t v21 = *(void *)(v7 + 232);
        }
        BOOL v8 = sub_10075180C((uint64_t)__p, (uint64_t)&v22);
        if (SHIBYTE(v21) < 0) {
          operator delete(__p[0]);
        }
        unint64_t v9 = *(NSObject **)(v5 + 72);
        if (v8)
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [7b] Deleting profile", (uint8_t *)v15, 2u);
          }
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v10 || (v11 = *(void *)(v5 + 40), (uint64_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v13 = v12;
          p_shared_weak_owners = &v12->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
          int v18 = 0;
          uint64_t v19 = 0;
          uint64_t v17 = 0;
          sub_10005C928(&v17, v22, (uint64_t)v23, v23 - (unsigned char *)v22);
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 1174405120;
          unint64_t v15[2] = sub_1009B17B4;
          v15[3] = &unk_101A23C50;
          v15[4] = v5;
          void v15[5] = v11;
          uint64_t v16 = v13;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::deleteTapeProfile();
          if (v17)
          {
            int v18 = v17;
            operator delete(v17);
          }
          if (v16) {
            std::__shared_weak_count::__release_weak(v16);
          }
          std::__shared_weak_count::__release_weak(v13);
        }
        else
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v15[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "[7b] encodeTapeDeleteProfileReq error; Cancelling session",
              (uint8_t *)v15,
              2u);
          }
          *(unsigned char *)(v5 + 624) = 5;
          sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v15, 1);
        }
        if (v22)
        {
          BOOL v23 = v22;
          operator delete(v22);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B8C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v27 = *(void **)(v25 - 88);
  if (v27)
  {
    *(void *)(v25 - 80) = v27;
    operator delete(v27);
  }
  sub_10004D2C8(v24);
  _Unwind_Resume(a1);
}

void sub_1009B8C7C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void **)(a1 + 8);
      if (v5)
      {
        uint64_t v6 = v5[9];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v12[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [7c] Starting", (uint8_t *)v12, 2u);
        }
        uint64_t v7 = (std::__shared_weak_count *)v5[6];
        if (!v7 || (v8 = v5[5], (unint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        p_shared_weak_owners = &v9->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 1174405120;
        v12[2] = sub_1009B1B08;
        v12[3] = &unk_101A23CB0;
        v12[4] = v5;
        v12[5] = v8;
        uint64_t v13 = v10;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        VinylCommandDriver::tapeListNotifications();
        if (v13) {
          std::__shared_weak_count::__release_weak(v13);
        }
        std::__shared_weak_count::__release_weak(v10);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B8DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_1009B8E0C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        uint64_t v6 = *(NSObject **)(v5 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v13[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [7d] Starting", (uint8_t *)v13, 2u);
        }
        uint64_t v7 = *(std::__shared_weak_count **)(v5 + 48);
        if (!v7 || (v8 = *(void *)(v5 + 40), (unint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        int v18 = 0;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        if (sub_100752FBC((char **)(v5 + 1376), (uint64_t)&v18))
        {
          uint64_t v11 = *(void *)(v5 + 128);
          if (v11) {
            sub_100EE8BC8(v11, "DeleteNotificationReq");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          std::string __p = 0;
          sub_10005C928(&__p, v18, (uint64_t)v19, v19 - (unsigned char *)v18);
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 1174405120;
          void v13[2] = sub_1009B2248;
          v13[3] = &unk_101A23D10;
          v13[4] = v5;
          void v13[5] = v8;
          uint64_t v14 = v10;
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeDeleteNotification();
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        else
        {
          uint64_t v12 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v13[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[7d] Could not encode; Cancelling session",
              (uint8_t *)v13,
              2u);
          }
          *(unsigned char *)(v5 + 624) = 5;
          sub_1009BD120(*(void *)(v5 + 120), (uint64_t)v13, 1);
        }
        if (v18)
        {
          uint64_t v19 = v18;
          operator delete(v18);
        }
        std::__shared_weak_count::__release_weak(v10);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B904C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  char v22 = *(void **)(v20 - 72);
  if (v22)
  {
    *(void *)(v20 - 64) = v22;
    operator delete(v22);
  }
  std::__shared_weak_count::__release_weak(v19);
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_1009B90A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          if (!*(unsigned char *)(*(void *)(v5 + 568) + 121))
          {
            uint64_t v8 = *(void *)(v5 + 88);
            std::string __p = 0;
            uint64_t v16 = 0;
            uint64_t v17 = 0;
            sub_10005C928(&__p, *(const void **)(v5 + 1296), *(void *)(v5 + 1304), *(void *)(v5 + 1304) - *(void *)(v5 + 1296));
            LOBYTE(v18) = 1;
            (*(void (**)(uint64_t, void **))(*(void *)v8 + 32))(v8, &__p);
            if ((_BYTE)v18)
            {
              if (__p)
              {
                uint64_t v16 = (uint64_t)__p;
                operator delete(__p);
              }
            }
          }
          uint64_t v6 = *(void *)(v5 + 128);
          if (v6) {
            sub_100EE8BC8(v6, "TapeBoundProfile");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          unint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [8] Sending package to SIM", (uint8_t *)&__p, 2u);
          }
          CTStopwatch::start((CTStopwatch *)(v5 + 536));
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v10 || (v11 = *(void *)(v5 + 40), (uint64_t v12 = std::__shared_weak_count::lock(v10)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v13 = v12;
          p_shared_weak_owners = &v12->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
          BOOL v23 = 0;
          uint64_t v24 = 0;
          char v22 = 0;
          sub_10005C928(&v22, *(const void **)(v5 + 1296), *(void *)(v5 + 1304), *(void *)(v5 + 1304) - *(void *)(v5 + 1296));
          std::string __p = _NSConcreteStackBlock;
          uint64_t v16 = 1174405120;
          uint64_t v17 = sub_1009B29A0;
          int v18 = &unk_101A23DD0;
          uint64_t v19 = v5;
          uint64_t v20 = v11;
          uint64_t v21 = v13;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeLoadBoundProfilePackage();
          if (v22)
          {
            BOOL v23 = v22;
            operator delete(v22);
          }
          if (v21) {
            std::__shared_weak_count::__release_weak(v21);
          }
          std::__shared_weak_count::__release_weak(v13);
        }
        else
        {
          uint64_t v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [8] Paused", (uint8_t *)&__p, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B9344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *a16, uint64_t a17)
{
  if (a12)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_1009B93AC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v6 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [9] Listing profiles", (uint8_t *)v14, 2u);
          }
          uint64_t v7 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v7 || (v8 = *(void *)(v5 + 40), (unint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v10 = v9;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          int v12 = capabilities::ct::supportsHydra(v11);
          sub_10074B368(&v19, v12);
          uint64_t v17 = 0;
          uint64_t v18 = 0;
          std::string __p = 0;
          sub_10005C928(&__p, v19, (uint64_t)v20, v20 - (unsigned char *)v19);
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 1174405120;
          std::string v14[2] = sub_1009B31E8;
          void v14[3] = &unk_101A23E30;
          uint8_t v14[4] = v5;
          v14[5] = v8;
          uint64_t v15 = v10;
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          VinylCommandDriver::tapeListProfilesInfo();
          if (__p)
          {
            uint64_t v17 = __p;
            operator delete(__p);
          }
          if (v15) {
            std::__shared_weak_count::__release_weak(v15);
          }
          if (v19)
          {
            uint64_t v20 = v19;
            operator delete(v19);
          }
          std::__shared_weak_count::__release_weak(v10);
        }
        else
        {
          uint64_t v13 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [9] Paused", (uint8_t *)v14, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B95C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  char v22 = *(void **)(v20 - 72);
  if (v22)
  {
    *(void *)(v20 - 64) = v22;
    operator delete(v22);
  }
  std::__shared_weak_count::__release_weak(v19);
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_1009B9618(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          if (sub_100750718(v5 + 600, *(unsigned char *)(v5 + 624), (uint64_t)&v20))
          {
            uint64_t v6 = *(void *)(v5 + 128);
            if (v6) {
              sub_100EE8BC8(v6, "TapeCancelSessionReq");
            }
            else {
              *(void *)(v5 + 128) = 0;
            }
            uint64_t v10 = *(NSObject **)(v5 + 72);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v11 = asString();
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [10] Sending to SIM - reason: %s", (uint8_t *)&buf, 0xCu);
            }
            int v12 = *(std::__shared_weak_count **)(v5 + 48);
            if (!v12 || (v13 = *(void *)(v5 + 40), (uint64_t v14 = std::__shared_weak_count::lock(v12)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v15 = v14;
            p_shared_weak_owners = &v14->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v14);
            uint64_t v18 = 0;
            uint64_t v19 = 0;
            std::string __p = 0;
            sub_10005C928(&__p, v20, (uint64_t)v21, v21 - (unsigned char *)v20);
            *(void *)&long long buf = _NSConcreteStackBlock;
            *((void *)&buf + 1) = 1174405120;
            uint64_t v24 = sub_1009B36F0;
            uint64_t v25 = &unk_101A23E90;
            uint64_t v26 = v5;
            uint64_t v27 = v13;
            uint64_t v28 = v15;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            VinylCommandDriver::tapeCancelSession();
            if (__p)
            {
              uint64_t v18 = __p;
              operator delete(__p);
            }
            if (v28) {
              std::__shared_weak_count::__release_weak(v28);
            }
            std::__shared_weak_count::__release_weak(v15);
          }
          else
          {
            uint64_t v7 = *(NSObject **)(v5 + 72);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[10] Cannot encode request; aborting",
                (uint8_t *)&buf,
                2u);
            }
            uint64_t v8 = *(void *)(v5 + 120);
            LOBYTE(buf) = 0;
            DWORD1(buf) = 0;
            sub_1009BAD84(v8, (uint64_t)&buf, 1);
          }
          if (v20)
          {
            uint64_t v21 = v20;
            operator delete(v20);
          }
        }
        else
        {
          unint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [10] Paused", (uint8_t *)&buf, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B990C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1009B9970(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        int v37 = 0;
        int v38 = 0;
        uint64_t v39 = 0;
        if (sub_10074AEB8((uint64_t *)(v5 + 600), v5 + 1344, (uint64_t)&v37))
        {
          uint64_t v6 = *(void *)(v5 + 128);
          if (v6) {
            sub_100EE8BC8(v6, "TapeCancelSessionServerReq");
          }
          else {
            *(void *)(v5 + 128) = 0;
          }
          unint64_t v9 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [11] Starting", buf, 2u);
          }
          uint64_t v34 = 0;
          long long v35 = 0;
          uint64_t v36 = 0;
          sub_10132A1C0(v5, &v34);
          (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 88) + 72))(&v32);
          long long v33 = v32;
          long long v32 = 0uLL;
          std::operator+<char>();
          uint64_t v10 = *(std::__shared_weak_count **)(v5 + 280);
          uint64_t v30 = *(void *)(v5 + 272);
          uint64_t v31 = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10132A438((Registry **)&v33, "/gsma/rsp2/es9plus/cancelSession", (uint64_t)buf, (uint64_t)&v37, (void *)(v5 + 56), (uint64_t)&v34, __p, &v30);
          long long v11 = *(_OWORD *)__p;
          __p[0] = 0;
          __p[1] = 0;
          int v12 = *(std::__shared_weak_count **)(v5 + 280);
          *(_OWORD *)(v5 + 272) = v11;
          if (v12)
          {
            sub_10004D2C8(v12);
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(*(void **)buf);
          }
          if (*((void *)&v33 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
          }
          if (*((void *)&v32 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
          }
          uint64_t v13 = *(void *)(v5 + 272);
          sub_100062740((const void **)buf, (const void **)(v5 + 32));
          (*(void (**)(uint64_t, void))(*(void *)v13 + 72))(v13, *(void *)buf);
          sub_100044D00((const void **)buf);
          (*(void (**)(void, Block_layout *))(**(void **)(v5 + 272) + 240))(*(void *)(v5 + 272), &stru_101AB2198);
          uint64_t v14 = *(std::__shared_weak_count **)(v5 + 48);
          if (!v14 || (v15 = *(void *)(v5 + 40), (uint64_t v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v17 = v16;
          p_shared_weak_owners = &v16->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          uint64_t v19 = *(void *)(v5 + 272);
          *(void *)long long buf = _NSConcreteStackBlock;
          uint64_t v24 = 1174405120;
          uint64_t v25 = sub_1009B3DC0;
          uint64_t v26 = &unk_101A23EC0;
          uint64_t v27 = v5;
          uint64_t v28 = v15;
          uint64_t v29 = v17;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v19 + 16))(v19, buf);
          uint64_t v20 = *(void *)(v5 + 272);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, void **))(*(void *)v20 + 40))(v20, __p);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
          if (v29) {
            std::__shared_weak_count::__release_weak(v29);
          }
          std::__shared_weak_count::__release_weak(v17);
          sub_10010C0E0((uint64_t)&v34, v35);
        }
        else
        {
          uint64_t v7 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [11] Failed to encode request - aborting", buf, 2u);
          }
          uint64_t v8 = *(void *)(v5 + 120);
          buf[0] = 0;
          *(_DWORD *)&uint8_t buf[4] = 0;
          sub_1009BAD84(v8, (uint64_t)buf, 1);
        }
        if (v37)
        {
          int v38 = v37;
          operator delete(v37);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009B9D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  std::__shared_weak_count::__release_weak(v33);
  sub_10010C0E0(v34 - 112, *(void **)(v34 - 104));
  uint64_t v36 = *(void **)(v34 - 88);
  if (v36)
  {
    *(void *)(v34 - 80) = v36;
    operator delete(v36);
  }
  sub_10004D2C8(v32);
  _Unwind_Resume(a1);
}

void sub_1009B9E54(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 153) || !*(unsigned char *)(v5 + 152))
        {
          *(_OWORD *)int v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v34 = 0u;
          long long v35 = 0u;
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          *(_OWORD *)long long buf = 0u;
          (*(void (**)(void, uint64_t))(**(void **)(v5 + 88) + 24))(*(void *)(v5 + 88), v5 + 1296);
          std::string __p = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          sub_10005C928(&__p, *(const void **)(v5 + 1296), *(void *)(v5 + 1304), *(void *)(v5 + 1304) - *(void *)(v5 + 1296));
          char v6 = sub_10074FA50(&__p, v5 + 600);
          if (__p)
          {
            uint64_t v25 = __p;
            operator delete(__p);
          }
          uint64_t v7 = *(NSObject **)(v5 + 72);
          BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
          if (v6)
          {
            if (v8)
            {
              LOWORD(v17) = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [1+] Sending to SIM", (uint8_t *)&v17, 2u);
            }
            unint64_t v9 = *(std::__shared_weak_count **)(v5 + 48);
            if (!v9 || (uint64_t v10 = *(void *)(v5 + 40), (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
              sub_100088B9C();
            }
            int v12 = v11;
            p_shared_weak_owners = &v11->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v11);
            uint64_t v17 = _NSConcreteStackBlock;
            uint64_t v18 = 1174405120;
            uint64_t v19 = sub_1009B3FD8;
            uint64_t v20 = &unk_101A23F20;
            uint64_t v21 = v5;
            uint64_t v22 = v10;
            BOOL v23 = v12;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            VinylCommandDriver::getSessionData();
            if (v23) {
              std::__shared_weak_count::__release_weak(v23);
            }
            std::__shared_weak_count::__release_weak(v12);
          }
          else
          {
            if (v8)
            {
              LOWORD(v17) = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [1+] Bad profile package; clearing",
                (uint8_t *)&v17,
                2u);
            }
            uint64_t v14 = *(void *)(v5 + 88);
            LOBYTE(v17) = 0;
            LOBYTE(v20) = 0;
            (*(void (**)(uint64_t, void **))(*(void *)v14 + 32))(v14, &v17);
            if ((_BYTE)v20 && v17)
            {
              uint64_t v18 = (uint64_t)v17;
              operator delete(v17);
            }
            uint64_t v15 = *(void *)(v5 + 120);
            LOBYTE(v17) = 0;
            HIDWORD(v17) = 0;
            sub_1009BAD84(v15, (uint64_t)&v17, 1);
          }
          if (v40[1])
          {
            *(void **)&long long v41 = v40[1];
            operator delete(v40[1]);
          }
          sub_1000C584C((uint64_t)buf);
        }
        else
        {
          uint64_t v16 = *(NSObject **)(v5 + 72);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [1+] Paused", buf, 2u);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009BA194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v20);
  sub_100799860((uint64_t)&a19);
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_1009BA208(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        sub_1009AB880(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1009BA298(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1009BA2AC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    BOOL v5 = *(unsigned __int8 *)(*(void *)(v4 + 568) + 121) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  sub_10004D2C8(v3);
  return v5;
}

BOOL sub_1009BA30C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    BOOL v5 = *(unsigned __int8 *)(v4 + 160) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  sub_10004D2C8(v3);
  return v5;
}

BOOL sub_1009BA368(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    goto LABEL_20;
  }
  if (*(unsigned char *)(v4 + 1147)) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(unsigned char *)(v4 + 1146) != 0;
  }
  uint64_t v7 = *(void *)(v4 + 568);
  uint64_t v8 = *(unsigned __int8 *)(v7 + 215);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(v7 + 200);
  }
  if (v8 == 4 && (v9 >= 0 ? (uint64_t v10 = (_DWORD *)(v7 + 192)) : (uint64_t v10 = *(_DWORD **)(v7 + 192)), *v10 == 825241653)
    || *(unsigned char *)(v4 + 162)
    && ((v11 = *(unsigned __int8 *)(v4 + 163), v11 <= 3) ? (BOOL v12 = v11 == 1) : (BOOL v12 = 1),
        !v12
     || !*(unsigned char *)(v7 + 120)
     || (*(char *)(v7 + 95) < 0 ? (uint64_t v14 = *(void *)(v7 + 80)) : (uint64_t v14 = *(unsigned __int8 *)(v7 + 95)), v14)))
  {
LABEL_20:
    BOOL v6 = 0;
  }
  else
  {
    if (*(unsigned char *)(v7 + 122)) {
      BOOL v5 = 1;
    }
    BOOL v6 = v5
      || *(unsigned char *)(v7 + 120)
      && (*(char *)(v7 + 95) < 0 ? (uint64_t v15 = *(void *)(v7 + 80)) : (uint64_t v15 = *(unsigned __int8 *)(v7 + 95)), !v15)
      || *(unsigned __int8 *)(v7 + 123) != 0;
  }
  sub_10004D2C8(v3);
  return v6;
}

BOOL sub_1009BA494(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 162))
        {
          BOOL v6 = *(unsigned __int8 *)(v5 + 163) == 1;
LABEL_10:
          sub_10004D2C8(v4);
          return v6;
        }
        uint64_t v7 = *(NSObject **)(v5 + 72);
        BOOL v6 = 0;
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_10;
        }
        *(_WORD *)int v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Consent has not been received yet - This is bad", v9, 2u);
      }
      BOOL v6 = 0;
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t sub_1009BA550(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    goto LABEL_20;
  }
  unsigned int v5 = *(unsigned __int8 *)(v4 + 248);
  if (*(unsigned char *)(v4 + 248))
  {
    uint64_t v6 = *(void *)(v4 + 224);
    uint64_t v7 = *(void *)(v4 + 232);
    if (v6 == v7)
    {
      unsigned int v5 = 0;
    }
    else
    {
      uint64_t v8 = v6 + 216;
      do
      {
        unsigned int v5 = *(unsigned char *)(v8 - 128) == 0;
        if (*(unsigned char *)(v8 - 128)) {
          BOOL v9 = v8 == v7;
        }
        else {
          BOOL v9 = 1;
        }
        v8 += 216;
      }
      while (!v9);
    }
  }
  if (*(unsigned char *)(v4 + 162) && *(unsigned char *)(v4 + 163) == 1)
  {
    if (*(unsigned char *)(v4 + 1147)) {
      uint64_t v10 = v5;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  else
  {
LABEL_20:
    uint64_t v10 = 0;
  }
  sub_10004D2C8(v3);
  return v10;
}

BOOL sub_1009BA5F8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)(v4 + 568);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 215);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(v5 + 200);
  }
  if (v6 == 4)
  {
    uint64_t v10 = *(_DWORD **)(v5 + 192);
    uint64_t v8 = (_DWORD *)(v5 + 192);
    BOOL v9 = v10;
    if (v7 < 0) {
      uint64_t v8 = v9;
    }
    BOOL v11 = *v8 == 825241653;
  }
  else
  {
LABEL_11:
    BOOL v11 = 0;
  }
  sub_10004D2C8(v3);
  return v11;
}

BOOL sub_1009BA688(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *(void *)(v4 + 568);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 215);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(v5 + 200);
  }
  if (v6 != 4) {
    goto LABEL_10;
  }
  uint64_t v10 = *(_DWORD **)(v5 + 192);
  uint64_t v8 = (_DWORD *)(v5 + 192);
  BOOL v9 = v10;
  if (v7 < 0) {
    uint64_t v8 = v9;
  }
  if (*v8 == 825241653) {
    BOOL v11 = *(unsigned __int8 *)(v4 + 1400) != 0;
  }
  else {
LABEL_10:
  }
    BOOL v11 = 0;
  sub_10004D2C8(v3);
  return v11;
}

uint64_t sub_1009BA724(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 55))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BA89C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5"
                                        "StartEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5StartEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BA9A8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BA9DC()
{
  return 0;
}

uint64_t sub_1009BA9E4(uint64_t a1, int a2, int a3)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 0;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 176))();
    int v9 = 21;
  }
  else
  {
    (*(void (**)(void))(v8 + 16))();
    int v9 = 1;
  }
  *std::exception v7 = v9;
  return 1;
}

uint64_t sub_1009BAAC4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 79))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BAC3C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5"
                                        "PauseEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5PauseEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BAD48(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BAD7C()
{
  return 0;
}

uint64_t sub_1009BAD84(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 103))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BAF00(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5"
                                        "AbortEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_5AbortEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BB014(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[32];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BB048()
{
  return 0;
}

uint64_t sub_1009BB050(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 22) {
    __assert_rtn("execute", "state_machine.hpp", 800, "state == (current_state)");
  }
  return 1;
}

uint64_t sub_1009BB08C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 21) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 21;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB11C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 18) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 18;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB1AC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 17) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 17;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB23C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 16) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 16;
  (*(void (**)(void, void, void, uint64_t))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 1);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB2CC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 11) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 11;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB35C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 10) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 10;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB3EC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 9) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 9;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB47C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 8) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 8;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB50C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 7;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB59C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 6;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB62C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB6BC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 4;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB74C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB7DC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 2;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB86C(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 1;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB8FC(uint64_t a1, int a2, int a3, unsigned __int8 *a4)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 0;
  (*(void (**)(void, void, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *a4, *((unsigned int *)a4 + 1), 0);
  *(_DWORD *)(v4 + 24) = 22;
  return 1;
}

uint64_t sub_1009BB984(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 127))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BBAFC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "5es10bEuiccInfo1EhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_15es10bEuiccInfo1EhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BBC08(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BBC3C()
{
  return 0;
}

uint64_t sub_1009BBC44(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 1;
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 2;
  return 1;
}

uint64_t sub_1009BBCC8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1009BBCD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009BBCF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1009BBD04(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 151))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BBE7C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "9es10bRulesAuthTableEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_19es10bRulesAuthTableEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BBF88(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BBFBC()
{
  return 0;
}

uint64_t sub_1009BBFC4(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 2;
  (*(void (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 3;
  return 1;
}

uint64_t sub_1009BC048(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 175))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BC1C0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "0bbDeviceCapabilitiesEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_20bbDeviceCapabilitiesEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BC2CC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BC300()
{
  return 0;
}

uint64_t sub_1009BC308(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 3;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009BC38C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 199))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BC504(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "9es10bEuiccChallengeEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_19es10bEuiccChallengeEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BC610(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BC644()
{
  return 0;
}

uint64_t sub_1009BC64C(uint64_t a1, int a2, int a3)
{
  if (a3 != 11) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 11;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009BC6D0(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 4;
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 5;
  return 1;
}

uint64_t sub_1009BC754(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 223))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BC8CC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "5es9InitiateAuthenticationEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_25es9InitiateAuthenticationEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BC9D8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BCA0C()
{
  return 0;
}

uint64_t sub_1009BCA14(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 5;
  (*(void (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 6;
  return 1;
}

uint64_t sub_1009BCA98(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 247))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BCC10(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "3es10bAuthenticateServerEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_23es10bAuthenticateServerEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BCD1C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BCD50()
{
  return 0;
}

uint64_t sub_1009BCD58(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 6;
  (*(void (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 7;
  return 1;
}

uint64_t sub_1009BCDDC(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 271))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BCF54(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "4NoMoreProfilesEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_14NoMoreProfilesEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BD060(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BD094()
{
  return 0;
}

uint64_t sub_1009BD09C(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 7;
  (*(void (**)(void))(**(void **)(a1 + 8) + 152))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 19;
  return 1;
}

uint64_t sub_1009BD120(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 295))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BD298(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "8es10bCancelSessionEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_18es10bCancelSessionEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BD3A4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BD3D8()
{
  return 0;
}

uint64_t sub_1009BD3E0(uint64_t a1, int a2, int a3)
{
  if (a3 != 16) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 16;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD464(uint64_t a1, int a2, int a3)
{
  if (a3 != 15) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 15;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD4E8(uint64_t a1, int a2, int a3)
{
  if (a3 != 14) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 14;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD56C(uint64_t a1, int a2, int a3)
{
  if (a3 != 13) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 13;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD5F0(uint64_t a1, int a2, int a3)
{
  if (a3 != 12) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 12;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD674(uint64_t a1, int a2, int a3)
{
  if (a3 != 11) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 11;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD6F8(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 7;
  (*(void (**)(void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 17;
  return 1;
}

uint64_t sub_1009BD77C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 319))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BD8F4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "1es9AuthenticateClientEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_21es9AuthenticateClientEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BDA00(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BDA34()
{
  return 0;
}

uint64_t sub_1009BDA3C(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 208))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 7;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 72))();
    int v9 = 8;
  }
  else
  {
    (*(void (**)(void))(v8 + 88))();
    int v9 = 10;
  }
  *std::exception v7 = v9;
  return 1;
}

uint64_t sub_1009BDB24(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 343))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BDC9C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "6es10bResetMemoryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_16es10bResetMemoryEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BDDA8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BDDDC()
{
  return 0;
}

uint64_t sub_1009BDDE4(uint64_t a1, int a2, int a3)
{
  if (a3 != 9) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 9;
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 4;
  return 1;
}

uint64_t sub_1009BDE68(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 367))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BDFE0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "0es10bPrepareDownloadEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_20es10bPrepareDownloadEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BE0EC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BE120()
{
  return 0;
}

uint64_t sub_1009BE128(uint64_t a1, int a2, int a3)
{
  if (a3 != 10) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 10;
  (*(void (**)(void))(**(void **)(a1 + 8) + 96))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 11;
  return 1;
}

uint64_t sub_1009BE1AC(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 391))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BE324(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "2es9BoundProfilePackageEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_22es9BoundProfilePackageEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BE430(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BE464()
{
  return 0;
}

uint64_t sub_1009BE46C(uint64_t a1, int a2, int a3)
{
  if (a3 != 14) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 14;
  (*(void (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 16;
  return 1;
}

uint64_t sub_1009BE4F0(uint64_t a1, int a2, int a3)
{
  if (a3 != 12) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 12;
  (*(void (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 16;
  return 1;
}

uint64_t sub_1009BE574(uint64_t a1, int a2, int a3)
{
  if (a3 != 11) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 232))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 11;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 104))();
    int v9 = 12;
  }
  else
  {
    (*(void (**)(void))(v8 + 144))();
    int v9 = 16;
  }
  *std::exception v7 = v9;
  return 1;
}

uint64_t sub_1009BE65C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 415))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BE7D4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "9es10cDisableProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_19es10cDisableProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BE8E0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BE914()
{
  return 0;
}

uint64_t sub_1009BE91C(uint64_t a1, int a2, int a3)
{
  if (a3 != 12) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 12;
  (*(void (**)(void))(**(void **)(a1 + 8) + 120))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 13;
  return 1;
}

uint64_t sub_1009BE9A0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 439))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BEB18(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "8es10cDeleteProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_18es10cDeleteProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BEC24(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BEC58()
{
  return 0;
}

uint64_t sub_1009BEC60(uint64_t a1, int a2, int a3)
{
  if (a3 != 13) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 13;
  (*(void (**)(void))(**(void **)(a1 + 8) + 128))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 14;
  return 1;
}

uint64_t sub_1009BECE4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 463))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BEE5C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "1es10bListNotificationEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_21es10bListNotificationEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BEF68(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BEF9C()
{
  return 0;
}

uint64_t sub_1009BEFA4(uint64_t a1, int a2, int a3)
{
  if (a3 != 14) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 14;
  (*(void (**)(void))(**(void **)(a1 + 8) + 136))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 15;
  return 1;
}

uint64_t sub_1009BF028(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0E2C8 + *(_DWORD *)(a1 + 24) + 487))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BF1A0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_3"
                                        "1es10bRemoveNotificationFromListEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_31es10bRemoveNotificationFromListEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BF2AC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BF2E0()
{
  return 0;
}

uint64_t sub_1009BF2E8(uint64_t a1, int a2, int a3)
{
  if (a3 != 15) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 15;
  (*(void (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 16;
  return 1;
}

uint64_t sub_1009BF36C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0F2B8 + *(_DWORD *)(a1 + 24) + 1))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BF4E0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "8es10cEnableProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_18es10cEnableProfileEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BF5EC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BF620()
{
  return 0;
}

uint64_t sub_1009BF628(uint64_t a1, int a2, int a3)
{
  if (a3 != 20) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 20;
  (*(void (**)(void, uint64_t, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), 10, 0, 0);
  *(_DWORD *)(v3 + 24) = 22;
  return 1;
}

uint64_t sub_1009BF6B8()
{
  return 0;
}

uint64_t sub_1009BF6C0(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 16) {
    __assert_rtn("execute", "state_machine.hpp", 773, "state == (current_state)");
  }
  (*(void (**)(void, uint64_t, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), 4, 0, 0);
  return 1;
}

uint64_t sub_1009BF734(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0F2B8 + *(_DWORD *)(a1 + 24) + 49))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BF8AC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "5es10bProfileInstallResultEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_25es10bProfileInstallResultEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BF9B8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BF9EC()
{
  return 0;
}

uint64_t sub_1009BF9F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 16) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 200))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 16;
  std::exception v7 = (int *)(v6 + 24);
  (*(void (**)(void, uint64_t, void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), 3, 0, 0);
  *std::exception v7 = 16;
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 152))();
    int v9 = 19;
  }
  else
  {
    (*(void (**)(void))(v8 + 40))();
    int v9 = 4;
  }
  *std::exception v7 = v9;
  return 1;
}

uint64_t sub_1009BFB1C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0F2B8 + *(_DWORD *)(a1 + 24) + 73))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009BFC94(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_2"
                                        "0es10cProfileInfoListEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_20es10cProfileInfoListEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009BFDA0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009BFDD4()
{
  return 0;
}

uint64_t sub_1009BFDDC(uint64_t a1, int a2, int a3)
{
  if (a3 != 19) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 240))(*(void *)(a1 + 8));
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 24) = 19;
  std::exception v7 = (int *)(v6 + 24);
  uint64_t v8 = **(void **)(a1 + 8);
  if (v5)
  {
    (*(void (**)(void))(v8 + 112))();
    int v9 = 20;
  }
  else
  {
    (*(void (**)(void))(v8 + 184))();
    int v9 = 22;
  }
  *std::exception v7 = v9;
  return 1;
}

uint64_t sub_1009BFED0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0F2B8 + *(_DWORD *)(a1 + 24) + 97))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009C0048(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "6es9CancelSessionEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_16es9CancelSessionEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009C0154(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009C0188()
{
  return 0;
}

uint64_t sub_1009C0190(uint64_t a1, int a2, int a3)
{
  if (a3 != 17) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 17;
  (*(void (**)(void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 18;
  return 1;
}

uint64_t sub_1009C0214(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*((uint64_t (**)(uint64_t, void))&unk_101B0F2B8 + *(_DWORD *)(a1 + 24) + 121))(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_1009B4E94((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1009C038C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_1"
                                        "6bbGetSessionDataEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN16tape_install_fsm19TapeInstallFrontFSMENS_9parameter5void_ESB_SB_SB_EERKNS8_16bbGetSessionDataEhEENS0_5list3INS0_5valueIPSC_EENSI_ISD_EENSI_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1009C0498(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1009C04CC()
{
  return 0;
}

uint64_t sub_1009C04D4(uint64_t a1, int a2, int a3)
{
  if (a3 != 21) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 24) = 21;
  (*(void (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));
  *(_DWORD *)(v3 + 24) = 16;
  return 1;
}

void sub_1009C0558()
{
  if ((byte_101B0E2D0 & 1) == 0)
  {
    byte_101B0E2D0 = 1;
    qword_101B0E470 = (uint64_t)sub_1009B4F6C;
    qword_101B0E460 = (uint64_t)sub_1009B4F6C;
    qword_101B0E430 = (uint64_t)sub_1009B4F6C;
    unk_101B0E438 = sub_1009B4F6C;
    qword_101B0E420 = (uint64_t)sub_1009B4F6C;
    unk_101B0E428 = sub_1009B4F6C;
    qword_101B0E3C0 = (uint64_t)sub_1009B4F6C;
    qword_101B0E468 = (uint64_t)sub_1009B4F74;
    qword_101B0E458 = (uint64_t)sub_1009B4FF4;
    qword_101B0E450 = (uint64_t)sub_1009B5074;
    qword_101B0E448 = (uint64_t)sub_1009B50F4;
    qword_101B0E440 = (uint64_t)sub_1009B5174;
    qword_101B0E418 = (uint64_t)sub_1009B51F4;
    qword_101B0E410 = (uint64_t)sub_1009B5274;
    qword_101B0E408 = (uint64_t)sub_1009B52F8;
    qword_101B0E400 = (uint64_t)sub_1009B5378;
    qword_101B0E3F8 = (uint64_t)sub_1009B553C;
    qword_101B0E3F0 = (uint64_t)sub_1009B55BC;
    qword_101B0E3E8 = (uint64_t)sub_1009B5640;
    qword_101B0E3E0 = (uint64_t)sub_1009B56C0;
    qword_101B0E3D8 = (uint64_t)sub_1009B5740;
    qword_101B0E3D0 = (uint64_t)sub_1009B57C0;
    qword_101B0E3C8 = (uint64_t)sub_1009B5840;
  }
}

void sub_1009C0698()
{
  if ((byte_101B0E2D8 & 1) == 0)
  {
    byte_101B0E2D8 = 1;
    qword_101B0E530 = (uint64_t)sub_1009BA9DC;
    qword_101B0E528 = (uint64_t)sub_1009BA9DC;
    qword_101B0E520 = (uint64_t)sub_1009BA9DC;
    qword_101B0E518 = (uint64_t)sub_1009BA9DC;
    qword_101B0E510 = (uint64_t)sub_1009BA9DC;
    qword_101B0E508 = (uint64_t)sub_1009BA9DC;
    qword_101B0E500 = (uint64_t)sub_1009BA9DC;
    qword_101B0E4F8 = (uint64_t)sub_1009BA9DC;
    qword_101B0E4F0 = (uint64_t)sub_1009BA9DC;
    qword_101B0E4E8 = (uint64_t)sub_1009BA9DC;
    qword_101B0E4E0 = (uint64_t)sub_1009BA9DC;
    qword_101B0E4D0 = (uint64_t)sub_1009BA9DC;
    unk_101B0E4D8 = sub_1009BA9DC;
    qword_101B0E4C0 = (uint64_t)sub_1009BA9DC;
    unk_101B0E4C8 = sub_1009BA9DC;
    qword_101B0E4B0 = (uint64_t)sub_1009BA9DC;
    unk_101B0E4B8 = sub_1009BA9DC;
    qword_101B0E4A0 = (uint64_t)sub_1009BA9DC;
    unk_101B0E4A8 = sub_1009BA9DC;
    qword_101B0E490 = (uint64_t)sub_1009BA9DC;
    unk_101B0E498 = sub_1009BA9DC;
    qword_101B0E488 = (uint64_t)sub_1009BA9DC;
    qword_101B0E480 = (uint64_t)sub_1009BA9E4;
  }
}

void sub_1009C0718()
{
  if ((byte_101B0E2E0 & 1) == 0)
  {
    byte_101B0E2E0 = 1;
    qword_101B0E5F0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5E8 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5E0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5D8 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5D0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5C8 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5C0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5B8 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5B0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5A8 = (uint64_t)sub_1009BAD7C;
    qword_101B0E5A0 = (uint64_t)sub_1009BAD7C;
    qword_101B0E598 = (uint64_t)sub_1009BAD7C;
    qword_101B0E590 = (uint64_t)sub_1009BAD7C;
    qword_101B0E588 = (uint64_t)sub_1009BAD7C;
    qword_101B0E580 = (uint64_t)sub_1009BAD7C;
    qword_101B0E578 = (uint64_t)sub_1009BAD7C;
    qword_101B0E570 = (uint64_t)sub_1009BAD7C;
    qword_101B0E568 = (uint64_t)sub_1009BAD7C;
    qword_101B0E560 = (uint64_t)sub_1009BAD7C;
    qword_101B0E558 = (uint64_t)sub_1009BAD7C;
    qword_101B0E550 = (uint64_t)sub_1009BAD7C;
    qword_101B0E548 = (uint64_t)sub_1009BAD7C;
    qword_101B0E540 = (uint64_t)sub_1009BAD7C;
  }
}

void sub_1009C07A0()
{
  if ((byte_101B0E2E8 & 1) == 0)
  {
    byte_101B0E2E8 = 1;
    qword_101B0E6A0 = (uint64_t)sub_1009BB048;
    qword_101B0E698 = (uint64_t)sub_1009BB048;
    qword_101B0E678 = (uint64_t)sub_1009BB048;
    qword_101B0E670 = (uint64_t)sub_1009BB048;
    qword_101B0E668 = (uint64_t)sub_1009BB048;
    qword_101B0E660 = (uint64_t)sub_1009BB048;
    qword_101B0E6B0 = (uint64_t)sub_1009BB050;
    qword_101B0E6A8 = (uint64_t)sub_1009BB08C;
    qword_101B0E690 = (uint64_t)sub_1009BB11C;
    qword_101B0E688 = (uint64_t)sub_1009BB1AC;
    qword_101B0E680 = (uint64_t)sub_1009BB23C;
    qword_101B0E658 = (uint64_t)sub_1009BB2CC;
    qword_101B0E650 = (uint64_t)sub_1009BB35C;
    qword_101B0E648 = (uint64_t)sub_1009BB3EC;
    qword_101B0E640 = (uint64_t)sub_1009BB47C;
    qword_101B0E638 = (uint64_t)sub_1009BB50C;
    qword_101B0E630 = (uint64_t)sub_1009BB59C;
    qword_101B0E628 = (uint64_t)sub_1009BB62C;
    qword_101B0E620 = (uint64_t)sub_1009BB6BC;
    qword_101B0E618 = (uint64_t)sub_1009BB74C;
    qword_101B0E610 = (uint64_t)sub_1009BB7DC;
    qword_101B0E608 = (uint64_t)sub_1009BB86C;
    qword_101B0E600 = (uint64_t)sub_1009BB8FC;
  }
}

void sub_1009C08F4()
{
  if ((byte_101B0E2F0 & 1) == 0)
  {
    byte_101B0E2F0 = 1;
    qword_101B0E770 = (uint64_t)sub_1009BBC3C;
    qword_101B0E768 = (uint64_t)sub_1009BBC3C;
    qword_101B0E760 = (uint64_t)sub_1009BBC3C;
    qword_101B0E758 = (uint64_t)sub_1009BBC3C;
    qword_101B0E750 = (uint64_t)sub_1009BBC3C;
    qword_101B0E748 = (uint64_t)sub_1009BBC3C;
    qword_101B0E740 = (uint64_t)sub_1009BBC3C;
    qword_101B0E738 = (uint64_t)sub_1009BBC3C;
    qword_101B0E730 = (uint64_t)sub_1009BBC3C;
    qword_101B0E728 = (uint64_t)sub_1009BBC3C;
    qword_101B0E720 = (uint64_t)sub_1009BBC3C;
    qword_101B0E718 = (uint64_t)sub_1009BBC3C;
    qword_101B0E710 = (uint64_t)sub_1009BBC3C;
    qword_101B0E708 = (uint64_t)sub_1009BBC3C;
    qword_101B0E700 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6F8 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6F0 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6E8 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6E0 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6D8 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6D0 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6C0 = (uint64_t)sub_1009BBC3C;
    qword_101B0E6C8 = (uint64_t)sub_1009BBC44;
  }
}

void sub_1009C0988()
{
  if ((byte_101B0E2F8 & 1) == 0)
  {
    byte_101B0E2F8 = 1;
    qword_101B0E830 = (uint64_t)sub_1009BBFBC;
    qword_101B0E828 = (uint64_t)sub_1009BBFBC;
    qword_101B0E820 = (uint64_t)sub_1009BBFBC;
    qword_101B0E818 = (uint64_t)sub_1009BBFBC;
    qword_101B0E810 = (uint64_t)sub_1009BBFBC;
    qword_101B0E808 = (uint64_t)sub_1009BBFBC;
    qword_101B0E800 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7F8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7F0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7E8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7E0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7D8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7D0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7C8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7C0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7B8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7B0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7A8 = (uint64_t)sub_1009BBFBC;
    qword_101B0E7A0 = (uint64_t)sub_1009BBFBC;
    qword_101B0E798 = (uint64_t)sub_1009BBFBC;
    qword_101B0E788 = (uint64_t)sub_1009BBFBC;
    qword_101B0E780 = (uint64_t)sub_1009BBFBC;
    qword_101B0E790 = (uint64_t)sub_1009BBFC4;
  }
}

void sub_1009C0A1C()
{
  if ((byte_101B0E300 & 1) == 0)
  {
    byte_101B0E300 = 1;
    qword_101B0E8F0 = (uint64_t)sub_1009BC300;
    qword_101B0E8E8 = (uint64_t)sub_1009BC300;
    qword_101B0E8E0 = (uint64_t)sub_1009BC300;
    qword_101B0E8D8 = (uint64_t)sub_1009BC300;
    qword_101B0E8D0 = (uint64_t)sub_1009BC300;
    qword_101B0E8C8 = (uint64_t)sub_1009BC300;
    qword_101B0E8C0 = (uint64_t)sub_1009BC300;
    qword_101B0E8B8 = (uint64_t)sub_1009BC300;
    qword_101B0E8B0 = (uint64_t)sub_1009BC300;
    qword_101B0E8A8 = (uint64_t)sub_1009BC300;
    qword_101B0E8A0 = (uint64_t)sub_1009BC300;
    qword_101B0E898 = (uint64_t)sub_1009BC300;
    qword_101B0E890 = (uint64_t)sub_1009BC300;
    qword_101B0E888 = (uint64_t)sub_1009BC300;
    qword_101B0E880 = (uint64_t)sub_1009BC300;
    qword_101B0E878 = (uint64_t)sub_1009BC300;
    qword_101B0E870 = (uint64_t)sub_1009BC300;
    qword_101B0E868 = (uint64_t)sub_1009BC300;
    qword_101B0E860 = (uint64_t)sub_1009BC300;
    qword_101B0E850 = (uint64_t)sub_1009BC300;
    qword_101B0E848 = (uint64_t)sub_1009BC300;
    qword_101B0E840 = (uint64_t)sub_1009BC300;
    qword_101B0E858 = (uint64_t)sub_1009BC308;
  }
}

void sub_1009C0AB0()
{
  if ((byte_101B0E308 & 1) == 0)
  {
    byte_101B0E308 = 1;
    qword_101B0E9B0 = (uint64_t)sub_1009BC644;
    qword_101B0E9A8 = (uint64_t)sub_1009BC644;
    qword_101B0E9A0 = (uint64_t)sub_1009BC644;
    qword_101B0E998 = (uint64_t)sub_1009BC644;
    qword_101B0E990 = (uint64_t)sub_1009BC644;
    qword_101B0E988 = (uint64_t)sub_1009BC644;
    qword_101B0E980 = (uint64_t)sub_1009BC644;
    qword_101B0E978 = (uint64_t)sub_1009BC644;
    qword_101B0E970 = (uint64_t)sub_1009BC644;
    qword_101B0E968 = (uint64_t)sub_1009BC644;
    qword_101B0E960 = (uint64_t)sub_1009BC644;
    qword_101B0E950 = (uint64_t)sub_1009BC644;
    qword_101B0E948 = (uint64_t)sub_1009BC644;
    qword_101B0E940 = (uint64_t)sub_1009BC644;
    qword_101B0E938 = (uint64_t)sub_1009BC644;
    qword_101B0E930 = (uint64_t)sub_1009BC644;
    qword_101B0E928 = (uint64_t)sub_1009BC644;
    qword_101B0E918 = (uint64_t)sub_1009BC644;
    qword_101B0E910 = (uint64_t)sub_1009BC644;
    qword_101B0E908 = (uint64_t)sub_1009BC644;
    qword_101B0E900 = (uint64_t)sub_1009BC644;
    qword_101B0E958 = (uint64_t)sub_1009BC64C;
    qword_101B0E920 = (uint64_t)sub_1009BC6D0;
  }
}

void sub_1009C0B50()
{
  if ((byte_101B0E310 & 1) == 0)
  {
    byte_101B0E310 = 1;
    qword_101B0EA70 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA68 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA60 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA58 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA50 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA48 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA40 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA38 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA30 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA28 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA20 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA18 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA10 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA08 = (uint64_t)sub_1009BCA0C;
    qword_101B0EA00 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9F8 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9F0 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9E0 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9D8 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9D0 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9C8 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9C0 = (uint64_t)sub_1009BCA0C;
    qword_101B0E9E8 = (uint64_t)sub_1009BCA14;
  }
}

void sub_1009C0BE4()
{
  if ((byte_101B0E318 & 1) == 0)
  {
    byte_101B0E318 = 1;
    qword_101B0EB30 = (uint64_t)sub_1009BCD50;
    qword_101B0EB28 = (uint64_t)sub_1009BCD50;
    qword_101B0EB20 = (uint64_t)sub_1009BCD50;
    qword_101B0EB18 = (uint64_t)sub_1009BCD50;
    qword_101B0EB10 = (uint64_t)sub_1009BCD50;
    qword_101B0EB08 = (uint64_t)sub_1009BCD50;
    qword_101B0EB00 = (uint64_t)sub_1009BCD50;
    qword_101B0EAF8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAF0 = (uint64_t)sub_1009BCD50;
    qword_101B0EAE8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAE0 = (uint64_t)sub_1009BCD50;
    qword_101B0EAD8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAD0 = (uint64_t)sub_1009BCD50;
    qword_101B0EAC8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAC0 = (uint64_t)sub_1009BCD50;
    qword_101B0EAB8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAA8 = (uint64_t)sub_1009BCD50;
    qword_101B0EAA0 = (uint64_t)sub_1009BCD50;
    qword_101B0EA98 = (uint64_t)sub_1009BCD50;
    qword_101B0EA90 = (uint64_t)sub_1009BCD50;
    qword_101B0EA88 = (uint64_t)sub_1009BCD50;
    qword_101B0EA80 = (uint64_t)sub_1009BCD50;
    qword_101B0EAB0 = (uint64_t)sub_1009BCD58;
  }
}

void sub_1009C0C78()
{
  if ((byte_101B0E320 & 1) == 0)
  {
    byte_101B0E320 = 1;
    qword_101B0EBF0 = (uint64_t)sub_1009BD094;
    qword_101B0EBE8 = (uint64_t)sub_1009BD094;
    qword_101B0EBE0 = (uint64_t)sub_1009BD094;
    qword_101B0EBD8 = (uint64_t)sub_1009BD094;
    qword_101B0EBD0 = (uint64_t)sub_1009BD094;
    qword_101B0EBC8 = (uint64_t)sub_1009BD094;
    qword_101B0EBC0 = (uint64_t)sub_1009BD094;
    qword_101B0EBB8 = (uint64_t)sub_1009BD094;
    qword_101B0EBB0 = (uint64_t)sub_1009BD094;
    qword_101B0EBA8 = (uint64_t)sub_1009BD094;
    qword_101B0EBA0 = (uint64_t)sub_1009BD094;
    qword_101B0EB98 = (uint64_t)sub_1009BD094;
    qword_101B0EB90 = (uint64_t)sub_1009BD094;
    qword_101B0EB88 = (uint64_t)sub_1009BD094;
    qword_101B0EB80 = (uint64_t)sub_1009BD094;
    qword_101B0EB70 = (uint64_t)sub_1009BD094;
    qword_101B0EB68 = (uint64_t)sub_1009BD094;
    qword_101B0EB60 = (uint64_t)sub_1009BD094;
    qword_101B0EB58 = (uint64_t)sub_1009BD094;
    qword_101B0EB50 = (uint64_t)sub_1009BD094;
    qword_101B0EB48 = (uint64_t)sub_1009BD094;
    qword_101B0EB40 = (uint64_t)sub_1009BD094;
    qword_101B0EB78 = (uint64_t)sub_1009BD09C;
  }
}

void sub_1009C0D0C()
{
  if ((byte_101B0E328 & 1) == 0)
  {
    byte_101B0E328 = 1;
    qword_101B0ECB0 = (uint64_t)sub_1009BD3D8;
    qword_101B0ECA8 = (uint64_t)sub_1009BD3D8;
    qword_101B0ECA0 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC98 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC90 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC88 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC50 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC48 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC40 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC30 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC28 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC20 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC18 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC10 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC08 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC00 = (uint64_t)sub_1009BD3D8;
    qword_101B0EC80 = (uint64_t)sub_1009BD3E0;
    qword_101B0EC78 = (uint64_t)sub_1009BD464;
    qword_101B0EC70 = (uint64_t)sub_1009BD4E8;
    qword_101B0EC68 = (uint64_t)sub_1009BD56C;
    qword_101B0EC60 = (uint64_t)sub_1009BD5F0;
    qword_101B0EC58 = (uint64_t)sub_1009BD674;
    qword_101B0EC38 = (uint64_t)sub_1009BD6F8;
  }
}

void sub_1009C0DE8()
{
  if ((byte_101B0E330 & 1) == 0)
  {
    byte_101B0E330 = 1;
    qword_101B0ED70 = (uint64_t)sub_1009BDA34;
    qword_101B0ED68 = (uint64_t)sub_1009BDA34;
    qword_101B0ED60 = (uint64_t)sub_1009BDA34;
    qword_101B0ED58 = (uint64_t)sub_1009BDA34;
    qword_101B0ED50 = (uint64_t)sub_1009BDA34;
    qword_101B0ED48 = (uint64_t)sub_1009BDA34;
    qword_101B0ED40 = (uint64_t)sub_1009BDA34;
    qword_101B0ED38 = (uint64_t)sub_1009BDA34;
    qword_101B0ED30 = (uint64_t)sub_1009BDA34;
    qword_101B0ED28 = (uint64_t)sub_1009BDA34;
    qword_101B0ED20 = (uint64_t)sub_1009BDA34;
    qword_101B0ED18 = (uint64_t)sub_1009BDA34;
    qword_101B0ED10 = (uint64_t)sub_1009BDA34;
    qword_101B0ED08 = (uint64_t)sub_1009BDA34;
    qword_101B0ED00 = (uint64_t)sub_1009BDA34;
    qword_101B0ECF0 = (uint64_t)sub_1009BDA34;
    qword_101B0ECE8 = (uint64_t)sub_1009BDA34;
    qword_101B0ECE0 = (uint64_t)sub_1009BDA34;
    qword_101B0ECD8 = (uint64_t)sub_1009BDA34;
    qword_101B0ECD0 = (uint64_t)sub_1009BDA34;
    qword_101B0ECC8 = (uint64_t)sub_1009BDA34;
    qword_101B0ECC0 = (uint64_t)sub_1009BDA34;
    qword_101B0ECF8 = (uint64_t)sub_1009BDA3C;
  }
}

void sub_1009C0E7C()
{
  if ((byte_101B0E338 & 1) == 0)
  {
    byte_101B0E338 = 1;
    qword_101B0EE30 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE28 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE20 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE18 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE10 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE08 = (uint64_t)sub_1009BDDDC;
    qword_101B0EE00 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDF8 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDF0 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDE8 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDE0 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDD8 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDD0 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDC0 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDB8 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDB0 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDA8 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDA0 = (uint64_t)sub_1009BDDDC;
    qword_101B0ED98 = (uint64_t)sub_1009BDDDC;
    qword_101B0ED90 = (uint64_t)sub_1009BDDDC;
    qword_101B0ED88 = (uint64_t)sub_1009BDDDC;
    qword_101B0ED80 = (uint64_t)sub_1009BDDDC;
    qword_101B0EDC8 = (uint64_t)sub_1009BDDE4;
  }
}

void sub_1009C0F10()
{
  if ((byte_101B0E340 & 1) == 0)
  {
    byte_101B0E340 = 1;
    qword_101B0EEF0 = (uint64_t)sub_1009BE120;
    qword_101B0EEE8 = (uint64_t)sub_1009BE120;
    qword_101B0EEE0 = (uint64_t)sub_1009BE120;
    qword_101B0EED8 = (uint64_t)sub_1009BE120;
    qword_101B0EED0 = (uint64_t)sub_1009BE120;
    qword_101B0EEC8 = (uint64_t)sub_1009BE120;
    qword_101B0EEC0 = (uint64_t)sub_1009BE120;
    qword_101B0EEB8 = (uint64_t)sub_1009BE120;
    qword_101B0EEB0 = (uint64_t)sub_1009BE120;
    qword_101B0EEA8 = (uint64_t)sub_1009BE120;
    qword_101B0EEA0 = (uint64_t)sub_1009BE120;
    qword_101B0EE98 = (uint64_t)sub_1009BE120;
    qword_101B0EE88 = (uint64_t)sub_1009BE120;
    qword_101B0EE80 = (uint64_t)sub_1009BE120;
    qword_101B0EE78 = (uint64_t)sub_1009BE120;
    qword_101B0EE70 = (uint64_t)sub_1009BE120;
    qword_101B0EE68 = (uint64_t)sub_1009BE120;
    qword_101B0EE60 = (uint64_t)sub_1009BE120;
    qword_101B0EE58 = (uint64_t)sub_1009BE120;
    qword_101B0EE50 = (uint64_t)sub_1009BE120;
    qword_101B0EE48 = (uint64_t)sub_1009BE120;
    qword_101B0EE40 = (uint64_t)sub_1009BE120;
    qword_101B0EE90 = (uint64_t)sub_1009BE128;
  }
}

void sub_1009C0FA4()
{
  if ((byte_101B0E348 & 1) == 0)
  {
    byte_101B0E348 = 1;
    qword_101B0EFB0 = (uint64_t)sub_1009BE464;
    qword_101B0EFA8 = (uint64_t)sub_1009BE464;
    qword_101B0EFA0 = (uint64_t)sub_1009BE464;
    qword_101B0EF98 = (uint64_t)sub_1009BE464;
    qword_101B0EF90 = (uint64_t)sub_1009BE464;
    qword_101B0EF88 = (uint64_t)sub_1009BE464;
    qword_101B0EF80 = (uint64_t)sub_1009BE464;
    qword_101B0EF78 = (uint64_t)sub_1009BE464;
    qword_101B0EF68 = (uint64_t)sub_1009BE464;
    qword_101B0EF50 = (uint64_t)sub_1009BE464;
    qword_101B0EF48 = (uint64_t)sub_1009BE464;
    qword_101B0EF40 = (uint64_t)sub_1009BE464;
    qword_101B0EF38 = (uint64_t)sub_1009BE464;
    qword_101B0EF30 = (uint64_t)sub_1009BE464;
    qword_101B0EF28 = (uint64_t)sub_1009BE464;
    qword_101B0EF20 = (uint64_t)sub_1009BE464;
    qword_101B0EF18 = (uint64_t)sub_1009BE464;
    qword_101B0EF10 = (uint64_t)sub_1009BE464;
    qword_101B0EF08 = (uint64_t)sub_1009BE464;
    qword_101B0EF00 = (uint64_t)sub_1009BE464;
    qword_101B0EF70 = (uint64_t)sub_1009BE46C;
    qword_101B0EF60 = (uint64_t)sub_1009BE4F0;
    qword_101B0EF58 = (uint64_t)sub_1009BE574;
  }
}

void sub_1009C1050()
{
  if ((byte_101B0E350 & 1) == 0)
  {
    byte_101B0E350 = 1;
    qword_101B0F070 = (uint64_t)sub_1009BE914;
    qword_101B0F068 = (uint64_t)sub_1009BE914;
    qword_101B0F060 = (uint64_t)sub_1009BE914;
    qword_101B0F058 = (uint64_t)sub_1009BE914;
    qword_101B0F050 = (uint64_t)sub_1009BE914;
    qword_101B0F048 = (uint64_t)sub_1009BE914;
    qword_101B0F040 = (uint64_t)sub_1009BE914;
    qword_101B0F038 = (uint64_t)sub_1009BE914;
    qword_101B0F030 = (uint64_t)sub_1009BE914;
    qword_101B0F028 = (uint64_t)sub_1009BE914;
    qword_101B0F018 = (uint64_t)sub_1009BE914;
    qword_101B0F010 = (uint64_t)sub_1009BE914;
    qword_101B0F008 = (uint64_t)sub_1009BE914;
    qword_101B0F000 = (uint64_t)sub_1009BE914;
    qword_101B0EFF8 = (uint64_t)sub_1009BE914;
    qword_101B0EFF0 = (uint64_t)sub_1009BE914;
    qword_101B0EFE8 = (uint64_t)sub_1009BE914;
    qword_101B0EFE0 = (uint64_t)sub_1009BE914;
    qword_101B0EFD8 = (uint64_t)sub_1009BE914;
    qword_101B0EFD0 = (uint64_t)sub_1009BE914;
    qword_101B0EFC8 = (uint64_t)sub_1009BE914;
    qword_101B0EFC0 = (uint64_t)sub_1009BE914;
    qword_101B0F020 = (uint64_t)sub_1009BE91C;
  }
}

void sub_1009C10E4()
{
  if ((byte_101B0E358 & 1) == 0)
  {
    byte_101B0E358 = 1;
    qword_101B0F130 = (uint64_t)sub_1009BEC58;
    qword_101B0F128 = (uint64_t)sub_1009BEC58;
    qword_101B0F120 = (uint64_t)sub_1009BEC58;
    qword_101B0F118 = (uint64_t)sub_1009BEC58;
    qword_101B0F110 = (uint64_t)sub_1009BEC58;
    qword_101B0F108 = (uint64_t)sub_1009BEC58;
    qword_101B0F100 = (uint64_t)sub_1009BEC58;
    qword_101B0F0F8 = (uint64_t)sub_1009BEC58;
    qword_101B0F0F0 = (uint64_t)sub_1009BEC58;
    qword_101B0F0E0 = (uint64_t)sub_1009BEC58;
    qword_101B0F0D8 = (uint64_t)sub_1009BEC58;
    qword_101B0F0D0 = (uint64_t)sub_1009BEC58;
    qword_101B0F0C8 = (uint64_t)sub_1009BEC58;
    qword_101B0F0C0 = (uint64_t)sub_1009BEC58;
    qword_101B0F0B8 = (uint64_t)sub_1009BEC58;
    qword_101B0F0B0 = (uint64_t)sub_1009BEC58;
    qword_101B0F0A8 = (uint64_t)sub_1009BEC58;
    qword_101B0F0A0 = (uint64_t)sub_1009BEC58;
    qword_101B0F098 = (uint64_t)sub_1009BEC58;
    qword_101B0F090 = (uint64_t)sub_1009BEC58;
    qword_101B0F088 = (uint64_t)sub_1009BEC58;
    qword_101B0F080 = (uint64_t)sub_1009BEC58;
    qword_101B0F0E8 = (uint64_t)sub_1009BEC60;
  }
}

void sub_1009C1178()
{
  if ((byte_101B0E360 & 1) == 0)
  {
    byte_101B0E360 = 1;
    qword_101B0F1F0 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1E8 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1E0 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1D8 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1D0 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1C8 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1C0 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1B8 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1A8 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1A0 = (uint64_t)sub_1009BEF9C;
    qword_101B0F198 = (uint64_t)sub_1009BEF9C;
    qword_101B0F190 = (uint64_t)sub_1009BEF9C;
    qword_101B0F188 = (uint64_t)sub_1009BEF9C;
    qword_101B0F180 = (uint64_t)sub_1009BEF9C;
    qword_101B0F178 = (uint64_t)sub_1009BEF9C;
    qword_101B0F170 = (uint64_t)sub_1009BEF9C;
    qword_101B0F168 = (uint64_t)sub_1009BEF9C;
    qword_101B0F160 = (uint64_t)sub_1009BEF9C;
    qword_101B0F158 = (uint64_t)sub_1009BEF9C;
    qword_101B0F150 = (uint64_t)sub_1009BEF9C;
    qword_101B0F148 = (uint64_t)sub_1009BEF9C;
    qword_101B0F140 = (uint64_t)sub_1009BEF9C;
    qword_101B0F1B0 = (uint64_t)sub_1009BEFA4;
  }
}

void sub_1009C120C()
{
  if ((byte_101B0E368 & 1) == 0)
  {
    byte_101B0E368 = 1;
    qword_101B0F2B0 = (uint64_t)sub_1009BF2E0;
    qword_101B0F2A8 = (uint64_t)sub_1009BF2E0;
    qword_101B0F2A0 = (uint64_t)sub_1009BF2E0;
    qword_101B0F298 = (uint64_t)sub_1009BF2E0;
    qword_101B0F290 = (uint64_t)sub_1009BF2E0;
    qword_101B0F288 = (uint64_t)sub_1009BF2E0;
    qword_101B0F280 = (uint64_t)sub_1009BF2E0;
    qword_101B0F270 = (uint64_t)sub_1009BF2E0;
    qword_101B0F268 = (uint64_t)sub_1009BF2E0;
    qword_101B0F260 = (uint64_t)sub_1009BF2E0;
    qword_101B0F258 = (uint64_t)sub_1009BF2E0;
    qword_101B0F250 = (uint64_t)sub_1009BF2E0;
    qword_101B0F248 = (uint64_t)sub_1009BF2E0;
    qword_101B0F240 = (uint64_t)sub_1009BF2E0;
    qword_101B0F238 = (uint64_t)sub_1009BF2E0;
    qword_101B0F230 = (uint64_t)sub_1009BF2E0;
    qword_101B0F228 = (uint64_t)sub_1009BF2E0;
    qword_101B0F220 = (uint64_t)sub_1009BF2E0;
    qword_101B0F218 = (uint64_t)sub_1009BF2E0;
    qword_101B0F210 = (uint64_t)sub_1009BF2E0;
    qword_101B0F208 = (uint64_t)sub_1009BF2E0;
    qword_101B0F200 = (uint64_t)sub_1009BF2E0;
    qword_101B0F278 = (uint64_t)sub_1009BF2E8;
  }
}

void sub_1009C12A0()
{
  if ((byte_101B0E370 & 1) == 0)
  {
    byte_101B0E370 = 1;
    qword_101B0F368 = (uint64_t)sub_1009BF620;
    unk_101B0F370 = sub_1009BF620;
    qword_101B0F350 = (uint64_t)sub_1009BF620;
    unk_101B0F358 = sub_1009BF620;
    qword_101B0F340 = (uint64_t)sub_1009BF620;
    unk_101B0F348 = sub_1009BF620;
    qword_101B0F330 = (uint64_t)sub_1009BF620;
    unk_101B0F338 = sub_1009BF620;
    qword_101B0F320 = (uint64_t)sub_1009BF620;
    unk_101B0F328 = sub_1009BF620;
    qword_101B0F310 = (uint64_t)sub_1009BF620;
    unk_101B0F318 = sub_1009BF620;
    qword_101B0F300 = (uint64_t)sub_1009BF620;
    unk_101B0F308 = sub_1009BF620;
    qword_101B0F2F0 = (uint64_t)sub_1009BF620;
    unk_101B0F2F8 = sub_1009BF620;
    qword_101B0F2E0 = (uint64_t)sub_1009BF620;
    unk_101B0F2E8 = sub_1009BF620;
    qword_101B0F2D0 = (uint64_t)sub_1009BF620;
    unk_101B0F2D8 = sub_1009BF620;
    qword_101B0F2C0 = (uint64_t)sub_1009BF620;
    *(void *)algn_101B0F2C8 = sub_1009BF620;
    qword_101B0F360 = (uint64_t)sub_1009BF628;
  }
}

void sub_1009C1308()
{
  if ((byte_101B0E378 & 1) == 0)
  {
    byte_101B0E378 = 1;
    qword_101B0F428 = (uint64_t)sub_1009BF6B8;
    unk_101B0F430 = sub_1009BF6B8;
    qword_101B0F418 = (uint64_t)sub_1009BF6B8;
    unk_101B0F420 = sub_1009BF6B8;
    qword_101B0F408 = (uint64_t)sub_1009BF6B8;
    unk_101B0F410 = sub_1009BF6B8;
    qword_101B0F3F0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3F8 = sub_1009BF6B8;
    qword_101B0F3E0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3E8 = sub_1009BF6B8;
    qword_101B0F3D0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3D8 = sub_1009BF6B8;
    qword_101B0F3C0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3C8 = sub_1009BF6B8;
    qword_101B0F3B0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3B8 = sub_1009BF6B8;
    qword_101B0F3A0 = (uint64_t)sub_1009BF6B8;
    unk_101B0F3A8 = sub_1009BF6B8;
    qword_101B0F390 = (uint64_t)sub_1009BF6B8;
    unk_101B0F398 = sub_1009BF6B8;
    qword_101B0F380 = (uint64_t)sub_1009BF6B8;
    *(void *)algn_101B0F388 = sub_1009BF6B8;
    qword_101B0F400 = (uint64_t)sub_1009BF6C0;
  }
}

void sub_1009C1370()
{
  if ((byte_101B0E380 & 1) == 0)
  {
    byte_101B0E380 = 1;
    qword_101B0F4E8 = (uint64_t)sub_1009BF9EC;
    unk_101B0F4F0 = sub_1009BF9EC;
    qword_101B0F4D8 = (uint64_t)sub_1009BF9EC;
    unk_101B0F4E0 = sub_1009BF9EC;
    qword_101B0F4C8 = (uint64_t)sub_1009BF9EC;
    unk_101B0F4D0 = sub_1009BF9EC;
    qword_101B0F4B0 = (uint64_t)sub_1009BF9EC;
    unk_101B0F4B8 = sub_1009BF9EC;
    qword_101B0F4A0 = (uint64_t)sub_1009BF9EC;
    unk_101B0F4A8 = sub_1009BF9EC;
    qword_101B0F490 = (uint64_t)sub_1009BF9EC;
    unk_101B0F498 = sub_1009BF9EC;
    qword_101B0F480 = (uint64_t)sub_1009BF9EC;
    unk_101B0F488 = sub_1009BF9EC;
    qword_101B0F470 = (uint64_t)sub_1009BF9EC;
    unk_101B0F478 = sub_1009BF9EC;
    qword_101B0F460 = (uint64_t)sub_1009BF9EC;
    unk_101B0F468 = sub_1009BF9EC;
    qword_101B0F450 = (uint64_t)sub_1009BF9EC;
    unk_101B0F458 = sub_1009BF9EC;
    qword_101B0F440 = (uint64_t)sub_1009BF9EC;
    *(void *)algn_101B0F448 = sub_1009BF9EC;
    qword_101B0F4C0 = (uint64_t)sub_1009BF9F4;
  }
}

void sub_1009C13D8()
{
  if ((byte_101B0E388 & 1) == 0)
  {
    byte_101B0E388 = 1;
    qword_101B0F5A8 = (uint64_t)sub_1009BFDD4;
    unk_101B0F5B0 = sub_1009BFDD4;
    qword_101B0F5A0 = (uint64_t)sub_1009BFDD4;
    qword_101B0F588 = (uint64_t)sub_1009BFDD4;
    unk_101B0F590 = sub_1009BFDD4;
    qword_101B0F578 = (uint64_t)sub_1009BFDD4;
    unk_101B0F580 = sub_1009BFDD4;
    qword_101B0F568 = (uint64_t)sub_1009BFDD4;
    unk_101B0F570 = sub_1009BFDD4;
    qword_101B0F558 = (uint64_t)sub_1009BFDD4;
    unk_101B0F560 = sub_1009BFDD4;
    qword_101B0F548 = (uint64_t)sub_1009BFDD4;
    unk_101B0F550 = sub_1009BFDD4;
    qword_101B0F538 = (uint64_t)sub_1009BFDD4;
    unk_101B0F540 = sub_1009BFDD4;
    qword_101B0F528 = (uint64_t)sub_1009BFDD4;
    unk_101B0F530 = sub_1009BFDD4;
    qword_101B0F518 = (uint64_t)sub_1009BFDD4;
    unk_101B0F520 = sub_1009BFDD4;
    qword_101B0F508 = (uint64_t)sub_1009BFDD4;
    unk_101B0F510 = sub_1009BFDD4;
    qword_101B0F500 = (uint64_t)sub_1009BFDD4;
    qword_101B0F598 = (uint64_t)sub_1009BFDDC;
  }
}

void sub_1009C1444()
{
  if ((byte_101B0E390 & 1) == 0)
  {
    byte_101B0E390 = 1;
    qword_101B0F668 = (uint64_t)sub_1009C0188;
    unk_101B0F670 = sub_1009C0188;
    qword_101B0F658 = (uint64_t)sub_1009C0188;
    unk_101B0F660 = sub_1009C0188;
    qword_101B0F650 = (uint64_t)sub_1009C0188;
    qword_101B0F638 = (uint64_t)sub_1009C0188;
    unk_101B0F640 = sub_1009C0188;
    qword_101B0F628 = (uint64_t)sub_1009C0188;
    unk_101B0F630 = sub_1009C0188;
    qword_101B0F618 = (uint64_t)sub_1009C0188;
    unk_101B0F620 = sub_1009C0188;
    qword_101B0F608 = (uint64_t)sub_1009C0188;
    unk_101B0F610 = sub_1009C0188;
    qword_101B0F5F8 = (uint64_t)sub_1009C0188;
    unk_101B0F600 = sub_1009C0188;
    qword_101B0F5E8 = (uint64_t)sub_1009C0188;
    unk_101B0F5F0 = sub_1009C0188;
    qword_101B0F5D8 = (uint64_t)sub_1009C0188;
    unk_101B0F5E0 = sub_1009C0188;
    qword_101B0F5C8 = (uint64_t)sub_1009C0188;
    unk_101B0F5D0 = sub_1009C0188;
    qword_101B0F5C0 = (uint64_t)sub_1009C0188;
    qword_101B0F648 = (uint64_t)sub_1009C0190;
  }
}

void sub_1009C14B0()
{
  if ((byte_101B0E398 & 1) == 0)
  {
    byte_101B0E398 = 1;
    qword_101B0F730 = (uint64_t)sub_1009C04CC;
    qword_101B0F718 = (uint64_t)sub_1009C04CC;
    unk_101B0F720 = sub_1009C04CC;
    qword_101B0F708 = (uint64_t)sub_1009C04CC;
    unk_101B0F710 = sub_1009C04CC;
    qword_101B0F6F8 = (uint64_t)sub_1009C04CC;
    unk_101B0F700 = sub_1009C04CC;
    qword_101B0F6E8 = (uint64_t)sub_1009C04CC;
    unk_101B0F6F0 = sub_1009C04CC;
    qword_101B0F6D8 = (uint64_t)sub_1009C04CC;
    unk_101B0F6E0 = sub_1009C04CC;
    qword_101B0F6C8 = (uint64_t)sub_1009C04CC;
    unk_101B0F6D0 = sub_1009C04CC;
    qword_101B0F6B8 = (uint64_t)sub_1009C04CC;
    unk_101B0F6C0 = sub_1009C04CC;
    qword_101B0F6A8 = (uint64_t)sub_1009C04CC;
    unk_101B0F6B0 = sub_1009C04CC;
    qword_101B0F698 = (uint64_t)sub_1009C04CC;
    unk_101B0F6A0 = sub_1009C04CC;
    qword_101B0F688 = (uint64_t)sub_1009C04CC;
    unk_101B0F690 = sub_1009C04CC;
    qword_101B0F680 = (uint64_t)sub_1009C04CC;
    qword_101B0F728 = (uint64_t)sub_1009C04D4;
  }
}

uint64_t sub_1009C151C()
{
  qword_101B0E3A0 = 0;
  qword_101B0E3A8 = 0;
  qword_101B0E3B0 = 0;
  uint64_t v0 = (char *)operator new(0x16uLL);
  qword_101B0E3A8 = (uint64_t)(v0 + 22);
  qword_101B0E3B0 = (uint64_t)(v0 + 22);
  *(_OWORD *)uint64_t v0 = xmmword_10151B030;
  *(void *)(v0 + 14) = 0xFBEB5B795ED2E632;
  qword_101B0E3A0 = (uint64_t)v0;

  return __cxa_atexit((void (*)(void *))sub_1007D9B0C, &qword_101B0E3A0, (void *)&_mh_execute_header);
}

void sub_1009C15A0(DNSResolverFactoryInterface *a1)
{
  *(void *)a1 = off_101A24558;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  DNSResolverFactoryInterface::~DNSResolverFactoryInterface(a1);
}

void sub_1009C1600(DNSResolverFactoryInterface *a1)
{
  sub_1009C15A0(a1);

  operator delete();
}

void sub_1009C1638()
{
  uint64_t v0 = operator new(0x28uLL);
  v0[1] = 0;
  *uint64_t v0 = off_101A24710;
  v0[2] = 0;
  v0[4] = 0;
  operator new();
}

void sub_1009C18F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    dispatch_barrier_async_f(v14[3], v14, (dispatch_function_t)sub_1009C30D0);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void DNSResolver::resolve(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  uint64_t v16 = ServiceMap;
  if ((v17 & 0x8000000000000000) != 0)
  {
    uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      unint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v17;
  uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, &v27);
  if (v21)
  {
    uint64_t v23 = v21[3];
    uint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      if (!v23) {
        goto LABEL_15;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v16);
  uint64_t v22 = 0;
  char v24 = 1;
  if (!v23)
  {
LABEL_15:
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    *a8 = 0;
    a8[1] = 0;
    return;
  }
LABEL_10:
  *a8 = 0;
  a8[1] = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 16))(v23, a4);
  uint64_t v25 = *a8;
  if (!*a8)
  {
    uint64_t v26 = (std::__shared_weak_count *)a8[1];
    if (v26) {
      sub_10004D2C8(v26);
    }
    goto LABEL_15;
  }
  sub_10016D1C4((uint64_t)v28, a3);
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t, uint64_t))(*(void *)v25 + 24))(v25, a2, v28, a5, a6, a7);
  sub_10016D140(v28);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
}

void sub_1009C1BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10016D140((uint64_t *)va);
  uint64_t v8 = *(std::__shared_weak_count **)(v4 + 8);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_1009C1C10(DNSResolverInterface *a1@<X0>, uint64_t *a2@<X8>)
{
  *(void *)a1 = off_101A24580;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *((Registry **)a1 + 6));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v18 = (void **)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v18);
  if (!v9)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    BOOL v11 = 0;
    char v12 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v9[3];
  BOOL v11 = (std::__shared_weak_count *)v9[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v12 = 0;
  if (v10)
  {
LABEL_10:
    uint64_t v13 = (*(uint64_t (**)(DNSResolverInterface *))(*(void *)a1 + 16))(a1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 32))(v10, v13);
  }
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  uint64_t v14 = *((void *)a1 + 8);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 40))(v14);
  }
  uint64_t v15 = *((void *)a1 + 28);
  *((void *)a1 + 28) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  sub_10016D140((void *)a1 + 21);
  uint64_t v18 = (void **)((char *)a1 + 144);
  sub_100047F64(&v18);
  if (*((char *)a1 + 143) < 0) {
    operator delete(*((void **)a1 + 15));
  }
  if (*((char *)a1 + 103) < 0) {
    operator delete(*((void **)a1 + 10));
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)a1 + 9);
  if (v16) {
    sub_10004D2C8(v16);
  }
  unint64_t v17 = (std::__shared_weak_count *)*((void *)a1 + 7);
  if (v17) {
    sub_10004D2C8(v17);
  }
  ctu::OsLogLogger::~OsLogLogger((DNSResolverInterface *)((char *)a1 + 40));
  sub_100087E88((void *)a1 + 1);
  DNSResolverInterface::~DNSResolverInterface(a1);
}

void sub_1009C1E38(DNSResolverInterface *a1@<X0>, uint64_t *a2@<X8>)
{
  sub_1009C1C10(a1, a2);

  operator delete();
}

void sub_1009C1E74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)char v12 = *(_OWORD *)a2;
    v12[2] = *(void **)(a2 + 16);
  }
  sub_10016D1C4((uint64_t)v13, a3);
  v13[4] = a4;
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    __p[2] = *(void **)(a5 + 16);
  }
  int v15 = a6;
  BOOL v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (v11)
  {
    if (std::__shared_weak_count::lock(v11)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1009C20B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2)
  {
    sub_10016D140(v18);
    if (*(char *)(v17 + 31) < 0) {
      operator delete(*v19);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009C2128(uint64_t a1)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64)))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v3) {
      return result;
    }
    uint64_t v5 = (const char **)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      uint64_t v5 = (const char **)*v5;
    }
    int v21 = 136315138;
    uint64_t v22 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DNS resolution of %s is already ongoing", (uint8_t *)&v21, 0xCu);
    return 0;
  }
  char v6 = (const char **)(a1 + 120);
  if ((*(char *)(a1 + 143) & 0x80000000) == 0)
  {
    uint64_t v7 = (const char *)(a1 + 120);
    if (!*(unsigned char *)(a1 + 143)) {
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v8 = if_nametoindex(v7);
    goto LABEL_13;
  }
  if (*(void *)(a1 + 128))
  {
    uint64_t v7 = *v6;
    goto LABEL_11;
  }
LABEL_12:
  uint64_t v8 = 0;
LABEL_13:
  *(void *)(a1 + 208) = 0;
  sub_100047FB8((uint64_t *)(a1 + 144));
  int v9 = (const char **)(a1 + 80);
  uint64_t v10 = (char *)(a1 + 80);
  if (*(char *)(a1 + 103) < 0) {
    uint64_t v10 = (char *)*v9;
  }
  int v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), 0x10000, v8, 3, v10, sub_1009C2494, a1);
  if (v11)
  {
    int v12 = v11;
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 103) < 0) {
        int v9 = (const char **)*v9;
      }
      if (*(char *)(a1 + 143) < 0) {
        char v6 = (const char **)*v6;
      }
      int v21 = 136315906;
      uint64_t v22 = v9;
      __int16 v23 = 2080;
      char v24 = v6;
      __int16 v25 = 1024;
      int v26 = v8;
      __int16 v27 = 1024;
      LODWORD(v28) = v12;
      uint64_t v14 = "Failed to start name resolution for %s over interface %s (%u) with error: %d";
      int v15 = v13;
      uint32_t v16 = 34;
LABEL_38:
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v21, v16);
      goto LABEL_24;
    }
    goto LABEL_24;
  }
  int v17 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), *(void *)(a1 + 24));
  uint64_t v18 = *(NSObject **)(a1 + 40);
  if (v17)
  {
    int v19 = v17;
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 143) < 0) {
        char v6 = (const char **)*v6;
      }
      int v21 = 136315394;
      uint64_t v22 = v6;
      __int16 v23 = 1024;
      LODWORD(v24) = v19;
      uint64_t v14 = "Failed to assign dispatch queue for name resolution of %s, error: %d";
      int v15 = v18;
      uint32_t v16 = 18;
      goto LABEL_38;
    }
LABEL_24:
    uint64_t result = *(void *)(a1 + 64);
    if (!result) {
      return result;
    }
    (*(void (**)(uint64_t))(*(void *)result + 40))(result);
    return 0;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 103) < 0) {
      int v9 = (const char **)*v9;
    }
    if (*(char *)(a1 + 143) < 0) {
      char v6 = (const char **)*v6;
    }
    uint64_t v20 = *(void *)(a1 + 216);
    int v21 = 136315906;
    uint64_t v22 = v9;
    __int16 v23 = 2080;
    char v24 = v6;
    __int16 v25 = 1024;
    int v26 = v8;
    __int16 v27 = 2048;
    uint64_t v28 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I start resolving domain name %s over interface %s (%u), attempt #%lu", (uint8_t *)&v21, 0x26u);
  }
  return 1;
}

void sub_1009C2494(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a8)
  {
    if (qword_101B13908)
    {
      uint64_t v13 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B13908);
      if (v13)
      {
        uint64_t v14 = v13;
        if (DNSResolverService::fDNSResolverServiceWeak)
        {
          uint64_t v15 = 0;
          uint32_t v16 = 0;
          (*(void (**)(uint64_t *__return_ptr))(*(void *)DNSResolverService::fDNSResolverServiceWeak + 24))(&v15);
          if (v15) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, a1, a2, a4, a5, a6);
          }
          if (v16) {
            sub_10004D2C8(v16);
          }
        }
        sub_10004D2C8(v14);
      }
    }
  }
}

void sub_1009C2594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1009C25BC(uint64_t a1, uint64_t a2, char a3, int a4, uint64_t a5, unsigned __int8 *a6)
{
  if (!a4 && a6)
  {
    memset(v57, 0, sizeof(v57));
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v57);
    int v11 = a6[1];
    if (v11 == 2)
    {
      CSIPacketAddress::setIPv4Address((CSIPacketAddress *)v57, *((_DWORD *)a6 + 1));
      uint64_t v12 = 1;
    }
    else if (v11 == 30)
    {
      CSIPacketAddress::setIPv6Address((CSIPacketAddress *)v57, a6 + 8, *a6);
      uint64_t v12 = 2;
    }
    else
    {
      uint64_t v12 = 0;
    }
    long long v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      CSIPacketAddress::operator std::string();
      long long v30 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)uint64_t v58 = 136315394;
      *(void *)&v58[4] = a5;
      *(_WORD *)&v58[12] = 2080;
      *(void *)&v58[14] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Resolved address for name %s: %s", v58, 0x16u);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    if ((CSIPacketAddress::isZeroIP((CSIPacketAddress *)v57) & 1) == 0
      && (CSIPacketAddress::isLinkLocal((CSIPacketAddress *)v57) & 1) == 0)
    {
      *(void *)(a1 + 208) |= v12;
      CSIPacketAddress::operator std::string();
      unint64_t v31 = *(void *)(a1 + 160);
      unint64_t v32 = *(void *)(a1 + 152);
      if (v32 >= v31)
      {
        uint64_t v36 = *(void *)(a1 + 144);
        unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v32 - v36) >> 3);
        unint64_t v38 = v37 + 1;
        if (v37 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - v36) >> 3);
        if (2 * v39 > v38) {
          unint64_t v38 = 2 * v39;
        }
        if (v39 >= 0x555555555555555) {
          unint64_t v40 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v40 = v38;
        }
        uint64_t v61 = a1 + 160;
        if (v40) {
          long long v41 = (char *)sub_10004812C(a1 + 160, v40);
        }
        else {
          long long v41 = 0;
        }
        int v42 = &v41[24 * v37];
        *(void *)long long buf = v41;
        *(void *)&uint8_t buf[8] = v42;
        xpc_object_t v60 = &v41[24 * v40];
        long long v43 = *(_OWORD *)v58;
        *((void *)v42 + 2) = *(void *)&v58[16];
        *(_OWORD *)int v42 = v43;
        memset(v58, 0, 24);
        *(void *)&uint8_t buf[16] = v42 + 24;
        sub_100048204((uint64_t *)(a1 + 144), buf);
        uint64_t v44 = *(void *)(a1 + 152);
        sub_100048174((uint64_t)buf);
        int v45 = (char)v58[23];
        *(void *)(a1 + 152) = v44;
        if (v45 < 0) {
          operator delete(*(void **)v58);
        }
      }
      else
      {
        long long v33 = *(_OWORD *)v58;
        *(void *)(v32 + 16) = *(void *)&v58[16];
        *(_OWORD *)unint64_t v32 = v33;
        *(void *)(a1 + 152) = v32 + 24;
      }
    }
LABEL_66:
    if ((a3 & 1) == 0)
    {
      uint64_t v46 = *(void *)(a1 + 200);
      if (v46 ? (v46 & ~*(void *)(a1 + 208)) == 0 : *(void *)(a1 + 208) & 3)
      {
        uint64_t v48 = *(void *)(a1 + 64);
        if (v48) {
          (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
        }
        uint64_t v49 = *(void *)(a1 + 192);
        if (!v49) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v49 + 48))(v49, a1 + 144);
        return 1;
      }
    }
    return 0;
  }
  if (a4 == -65568)
  {
    uint64_t v13 = *(void *)(a1 + 208);
    if (v13)
    {
      if (v13)
      {
        long long v35 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#N Resolving IPv6 for name %s timed out.", buf, 0xCu);
          uint64_t v13 = *(void *)(a1 + 208);
        }
        uint64_t v15 = v13 | 2;
      }
      else
      {
        if ((v13 & 2) == 0) {
          goto LABEL_66;
        }
        uint64_t v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Resolving IPv4 for name %s timed out.", buf, 0xCu);
          uint64_t v13 = *(void *)(a1 + 208);
        }
        uint64_t v15 = v13 | 1;
      }
      *(void *)(a1 + 208) = v15;
      goto LABEL_66;
    }
  }
  uint32_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = a5;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Failed to resolve name %s with error %d.", buf, 0x12u);
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v17 = *(void *)(a1 + 64);
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 40))(v17);
    }
    unint64_t v18 = *(void *)(a1 + 216) + 1;
    *(void *)(a1 + 216) = v18;
    if (v18 >= *(void *)(a1 + 112))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v34 = *(void *)(a1 + 192);
      if (!v34) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v34 + 48))(v34, buf);
      v57[0] = (void **)buf;
      sub_100047F64(v57);
    }
    else
    {
      int v19 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v19 || (uint64_t v20 = *(void *)(a1 + 8), (v21 = std::__shared_weak_count::lock(v19)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v22 = v21;
      atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 48));
      uint64_t v23 = *(void *)buf;
      sub_100058DB0(__p, "DNSResolverRetryTimer");
      uint64_t v24 = *(void *)(a1 + 216);
      __int16 v25 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v25;
      if (v25) {
        dispatch_retain(v25);
      }
      v51[0] = _NSConcreteStackBlock;
      v51[1] = 1174405120;
      v51[2] = sub_1009C2D04;
      v51[3] = &unk_101A245B0;
      v51[4] = v20;
      unint64_t v52 = v22;
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlocuint64_t k = _Block_copy(v51);
      sub_100118A44(v23, (uint64_t)__p, 1, 1000000 * v24, &object, &aBlock);
      int v26 = v57[0];
      v57[0] = 0;
      uint64_t v27 = *(void *)(a1 + 224);
      *(void *)(a1 + 224) = v26;
      if (v27)
      {
        (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
        uint64_t v28 = v57[0];
        v57[0] = 0;
        if (v28) {
          (*((void (**)(void **))*v28 + 1))(v28);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v56 < 0) {
        operator delete(__p[0]);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v52) {
        std::__shared_weak_count::__release_weak(v52);
      }
      std::__shared_weak_count::__release_weak(v22);
    }
    return 1;
  }
  return 0;
}

void sub_1009C2C40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *aBlock, dispatch_object_t object, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009C2D04(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    BOOL v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (sub_1009C2128(v5) & 1) == 0)
      {
        memset(v7, 0, sizeof(v7));
        uint64_t v6 = *(void *)(v5 + 192);
        if (!v6) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, void *))(*(void *)v6 + 48))(v6, v7);
        uint64_t v8 = (void **)v7;
        sub_100047F64(&v8);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1009C2DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100047F64(&a12);
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1009C2DD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009C2DF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009C2E04(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v4 = (void *)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    uint64_t v5 = *(void *)(a1 + 64);
    uint64_t v6 = (void *)(a1 + 120);
    if (*(char *)(a1 + 143) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v7 = *(void *)(a1 + 112);
    *(_DWORD *)long long buf = 134219010;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v5;
    *(_WORD *)&unsigned char buf[22] = 2082;
    uint64_t v17 = v4;
    __int16 v18 = 2082;
    int v19 = v6;
    __int16 v20 = 2048;
    uint64_t v21 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \tDNSResolver: %p, service=%p, fqdn=%{public}s, if=%{public}s max_tries=%lu, addresses={", buf, 0x34u);
  }
  uint64_t v8 = *(long long **)(a1 + 144);
  for (i = *(long long **)(a1 + 152); v8 != i; uint64_t v8 = (long long *)((char *)v8 + 24))
  {
    memset(buf, 0, sizeof(buf));
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(buf, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *(void *)&uint8_t buf[16] = *((void *)v8 + 2);
      *(_OWORD *)long long buf = v10;
    }
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v12 = buf;
      }
      else {
        uint64_t v12 = *(uint8_t **)buf;
      }
      *(_DWORD *)uint64_t v14 = 136446210;
      uint64_t v15 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I \t\t%{public}s", v14, 0xCu);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I \t}", buf, 2u);
  }
}

void sub_1009C3038(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009C3070(uint64_t a1)
{
}

uint64_t sub_1009C308C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009C30D0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1009C30FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A24710;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009C311C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A24710;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009C3170(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t *sub_1009C3198(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v31 = a1;
  uint64_t v32 = v1;
  uint64_t v2 = *(void *)v1;
  sub_10016D1C4((uint64_t)v34, v1 + 32);
  uint64_t v3 = (const void **)(v1 + 8);
  if (!v35)
  {
    uint64_t v17 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_50;
    }
    if (*(char *)(v1 + 31) >= 0) {
      uint64_t v18 = v1 + 8;
    }
    else {
      uint64_t v18 = *(void *)(v1 + 8);
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    int v19 = "#I No Callback provided for name %s, cannot do DNS resolve.";
    goto LABEL_24;
  }
  uint64_t v4 = *(void *)(v2 + 64);
  if (!v4)
  {
    __int16 v20 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_48;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v21 = "#N dns service is not initialized.";
    goto LABEL_46;
  }
  uint64_t v5 = *(void *)(v1 + 64);
  uint64_t v6 = *(unsigned int *)(v1 + 96);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v4 + 32))(v4))
  {
LABEL_39:
    uint64_t v29 = *(unsigned __int8 *)(v1 + 31);
    if ((v29 & 0x80u) != 0) {
      uint64_t v29 = *(void *)(v1 + 16);
    }
    if (v29)
    {
      std::string::operator=((std::string *)(v2 + 80), (const std::string *)(v1 + 8));
      *(void *)(v2 + 112) = v5;
      sub_10016D1C4((uint64_t)buf, (uint64_t)v34);
      sub_1009C3620(buf, (void *)(v2 + 168));
      sub_10016D140(buf);
      std::string::operator=((std::string *)(v2 + 120), (const std::string *)(v1 + 72));
      *(void *)(v2 + 200) = v6;
      *(void *)(v2 + 216) = 0;
      if (sub_1009C2128(v2)) {
        goto LABEL_50;
      }
      goto LABEL_48;
    }
    __int16 v20 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_48;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v21 = "#N cannot resolve empty domain name.";
LABEL_46:
    uint64_t v27 = v20;
    uint32_t v28 = 2;
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v21, buf, v28);
    goto LABEL_48;
  }
  uint64_t v7 = (const void **)(v2 + 80);
  char v8 = *(unsigned char *)(v2 + 103);
  uint64_t v9 = *(void *)(v2 + 88);
  if (v8 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(v2 + 103);
  }
  else {
    uint64_t v10 = *(void *)(v2 + 88);
  }
  uint64_t v11 = *(unsigned __int8 *)(v1 + 31);
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(v1 + 16);
  }
  if (v10 == v11)
  {
    if (v12 >= 0) {
      uint64_t v13 = (unsigned __int8 *)(v1 + 8);
    }
    else {
      uint64_t v13 = (unsigned __int8 *)*v3;
    }
    if ((*(unsigned char *)(v2 + 103) & 0x80) != 0)
    {
      int v22 = memcmp(*v7, v13, *(void *)(v2 + 88));
      uint64_t v7 = (const void **)(v2 + 80);
      uint64_t v10 = v9;
      if (v22) {
        goto LABEL_28;
      }
    }
    else if (*(unsigned char *)(v2 + 103))
    {
      uint64_t v14 = v13;
      uint64_t v15 = (unsigned __int8 *)(v2 + 80);
      uint64_t v16 = *(unsigned __int8 *)(v2 + 103);
      while (*v15 == *v14)
      {
        ++v15;
        ++v14;
        if (!--v16) {
          goto LABEL_35;
        }
      }
      goto LABEL_28;
    }
LABEL_35:
    uint64_t v17 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_50;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    int v19 = "#I dns resolving of %s is already ongoing.";
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
    goto LABEL_50;
  }
LABEL_28:
  uint64_t v23 = v7;
  uint64_t v24 = *(NSObject **)(v2 + 40);
  BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
  if (!v10)
  {
    if (v25)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I dns service is initialized", buf, 2u);
    }
    goto LABEL_39;
  }
  if (v25)
  {
    if (v8 < 0) {
      uint64_t v23 = (const void **)*v23;
    }
    int v26 = *v3;
    if (v12 >= 0) {
      int v26 = (const void *)(v1 + 8);
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v26;
    uint64_t v21 = "#I a dns resolving of %s is already ongoing, cannot resolve %s the meantime.";
    uint64_t v27 = v24;
    uint32_t v28 = 22;
    goto LABEL_47;
  }
LABEL_48:
  memset(buf, 0, 24);
  if (!v35) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v35 + 48))(v35, buf);
  long long v33 = buf;
  sub_100047F64((void ***)&v33);
LABEL_50:
  sub_10016D140(v34);
  sub_1009C35B0(&v32);
  return sub_100046B58((uint64_t *)&v31);
}

void sub_1009C356C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  a12 = (void **)&a17;
  sub_100047F64(&a12);
  sub_10016D140(&a13);
  sub_1009C35B0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009C35B0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    sub_10016D140((void *)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void *sub_1009C3620(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1009C3888(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1009C3894(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_DWORD *)(a1 + 200)) {
      uint64_t v3 = "MT";
    }
    else {
      uint64_t v3 = "MO";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s SMS Message details:", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 452);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Teleservice ID:\t%d", buf, 8u);
  }
  unsigned int v5 = *(_DWORD *)(a1 + 204);
  if (v5 > 2) {
    uint64_t v6 = "Unknown";
  }
  else {
    uint64_t v6 = off_101A24970[v5];
  }
  uint64_t v7 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)uint64_t v46 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Basic Msg Type:\t%s (%d)", buf, 0x12u);
  }
  if (*(unsigned char *)(a1 + 432))
  {
    char v8 = *(NSObject **)(a1 + 192);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Message is concatenated", buf, 2u);
      char v8 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(a1 + 436);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Reference:\t\t%d", buf, 8u);
      char v8 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(a1 + 444);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sequence Num:\t%d", buf, 8u);
      char v8 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)(a1 + 440);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Max Segments:\t%d", buf, 8u);
    }
  }
  int v12 = *(_DWORD *)(a1 + 200);
  if ((v12 - 1) <= 1)
  {
    uint64_t v13 = *(NSObject **)(a1 + 192);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int MessageID = sms::Model::getMessageID((sms::Model *)a1);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = MessageID;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Message ID:\t%d", buf, 8u);
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CSIPhoneNumber::getFormatted((uint64_t *)buf, (CSIPhoneNumber *)(a1 + 216));
      if ((v48 & 0x8000) == 0) {
        uint64_t v15 = buf;
      }
      else {
        uint64_t v15 = *(unsigned char **)buf;
      }
      int v43 = 136315138;
      v44[0] = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Sender:\t\t%s", (uint8_t *)&v43, 0xCu);
      if (SBYTE1(v48) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 404);
      int v17 = *(_DWORD *)(a1 + 400);
      int v18 = *(_DWORD *)(a1 + 396);
      int v19 = *(_DWORD *)(a1 + 384);
      int v20 = *(_DWORD *)(a1 + 388);
      int v21 = *(_DWORD *)(a1 + 392);
      int v22 = *(_DWORD *)(a1 + 408);
      if (*(unsigned char *)(a1 + 412)) {
        uint64_t v23 = "yes";
      }
      else {
        uint64_t v23 = "no";
      }
      *(_DWORD *)long long buf = 67110914;
      *(_DWORD *)&uint8_t buf[4] = v16;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v17;
      *(_WORD *)uint64_t v46 = 1024;
      *(_DWORD *)&_OWORD v46[2] = v18;
      __int16 v47 = 1024;
      int v48 = v19;
      __int16 v49 = 1024;
      int v50 = v20;
      __int16 v51 = 1024;
      int v52 = v21;
      __int16 v53 = 1024;
      int v54 = v22;
      __int16 v55 = 2080;
      char v56 = v23;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I MC Timestamp:\tY:%d M:%02d D:%02d @ %02d:%02d:%02d (Offset:%d, DST:%s)", buf, 0x36u);
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = CSIDateToSeconds();
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v24;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I MC Timestamp:\t%d", buf, 8u);
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = *(_DWORD *)(a1 + 448);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I DisplayMode:\t%d", buf, 8u);
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v26;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Source Port:\t%d", buf, 8u);
      uint64_t v13 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Dest Port:\t\t%d", buf, 8u);
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 248))(a1) == 2)
    {
      uint32_t v28 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        int v29 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 424))(a1);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Service Category:\t%u", buf, 8u);
      }
    }
    if (*(unsigned char *)(a1 + 97))
    {
      long long v30 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Message is a voicemail indication", buf, 2u);
        long long v30 = *(NSObject **)(a1 + 192);
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(a1 + 98)) {
          unint64_t v31 = "yes";
        }
        else {
          unint64_t v31 = "no";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I VM Waiting:\t\t%s", buf, 0xCu);
        long long v30 = *(NSObject **)(a1 + 192);
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(a1 + 99)) {
          uint64_t v32 = "yes";
        }
        else {
          uint64_t v32 = "no";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I VM Count Avail:\t%s", buf, 0xCu);
        long long v30 = *(NSObject **)(a1 + 192);
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = *(_DWORD *)(a1 + 100);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v33;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I VM Count:\t\t%d", buf, 8u);
      }
    }
    int v12 = *(_DWORD *)(a1 + 200);
  }
  if (!v12)
  {
    if (*(_DWORD *)(a1 + 36) == 2)
    {
      uint64_t v34 = *(NSObject **)(a1 + 192);
      if (*(_DWORD *)(a1 + 40) != 2 || !os_log_type_enabled(*(os_log_t *)(a1 + 192), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_70;
      }
      int v35 = sms::Model::getMessageID((sms::Model *)a1);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Message ID:          %d", buf, 8u);
    }
    uint64_t v34 = *(NSObject **)(a1 + 192);
LABEL_70:
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = (void *)(a1 + 160);
      if (*(char *)(a1 + 183) < 0) {
        uint64_t v36 = (void *)*v36;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Destination:\t%s", buf, 0xCu);
      uint64_t v34 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 456)) {
        unint64_t v37 = "yes";
      }
      else {
        unint64_t v37 = "no";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v37;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I MoreMessages:\t%s", buf, 0xCu);
      uint64_t v34 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = *(_DWORD *)(a1 + 460);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v38;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Validity:\t\t%d", buf, 8u);
    }
  }
  unint64_t v39 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    int v40 = *(_DWORD *)(a1 + 376);
    C2KSmsPdu::asString();
    if ((v48 & 0x8000) == 0) {
      long long v41 = buf;
    }
    else {
      long long v41 = *(unsigned char **)buf;
    }
    int v43 = 67109378;
    LODWORD(v44[0]) = v40;
    WORD2(v44[0]) = 2080;
    *(void *)((char *)v44 + 6) = v41;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Msg Encoding:\t%d (%s)", (uint8_t *)&v43, 0x12u);
    if (SBYTE1(v48) < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v39 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 375) < 0) {
      uint64_t v42 = *(void *)(a1 + 360);
    }
    else {
      LODWORD(v42) = *(unsigned __int8 *)(a1 + 375);
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v42;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Body Length:\t%d", buf, 8u);
  }
}

uint64_t sub_1009C4290(uint64_t a1, int a2, void *a3, C2KSmsPduDecoder **a4, int a5)
{
  int v9 = (std::__shared_weak_count *)a3[1];
  v14[0] = *a3;
  v14[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 MsgID = C2KSmsPduDecoder::getMsgID(*a4);
  sms::Model::Model(a1, a2, v14, 2, 0, MsgID);
  if (v9) {
    sub_10004D2C8(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 192), "com.apple.telephony", "msg.c2k.mdl");
  *(void *)a1 = off_101A24760;
  *(_DWORD *)(a1 + 200) = 1;
  *(_DWORD *)(a1 + 204) = C2KSmsPduDecoder::getBasicMsgType(*a4);
  *(_DWORD *)(a1 + 208) = C2KSmsPduDecoder::getMsgIdentifierType(*a4);
  *(_DWORD *)(a1 + 212) = C2KSmsPduDecoder::getServiceCategory(*a4);
  C2KSmsPduDecoder::getOriginatingAddr(*a4);
  C2KSmsPduDecoder::getMsgBody(*a4);
  *(_DWORD *)(a1 + 376) = C2KSmsPduDecoder::getMsgEncoding(*a4);
  C2KSmsPduDecoder::getMCTimeStamp(*a4);
  *(unsigned char *)(a1 + 432) = C2KSmsPduDecoder::isConcatenated(*a4);
  *(_DWORD *)(a1 + 436) = C2KSmsPduDecoder::getConcatenationReference(*a4);
  *(_DWORD *)(a1 + 440) = C2KSmsPduDecoder::getConcatenationMaxSegments(*a4);
  *(_DWORD *)(a1 + 444) = C2KSmsPduDecoder::getConcatenationSequenceNumber(*a4);
  *(_DWORD *)(a1 + 448) = C2KSmsPduDecoder::getMsgDisplayMode(*a4);
  *(_DWORD *)(a1 + 452) = C2KSmsPduDecoder::getTeleserviceID(*a4);
  *(unsigned char *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 460) = -1;
  *(unsigned char *)(a1 + 464) = 1;
  *(_DWORD *)(a1 + 468) = C2KSmsPduDecoder::getLanguageIndicator(*a4);
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  uint64_t DestinationPort = C2KSmsPduDecoder::getDestinationPort(*a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, DestinationPort);
  uint64_t SourcePort = C2KSmsPduDecoder::getSourcePort(*a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, SourcePort);
  *(unsigned char *)(a1 + 97) = C2KSmsPduDecoder::isVoiceMailIndication(*a4);
  *(unsigned char *)(a1 + 98) = C2KSmsPduDecoder::isVoiceMailWaiting(*a4);
  *(unsigned char *)(a1 + 99) = C2KSmsPduDecoder::isVoiceMailCountAvailable(*a4);
  *(_DWORD *)(a1 + 100) = C2KSmsPduDecoder::getVoiceMailCount(*a4);
  *(_DWORD *)(a1 + 136) = C2KSmsPduDecoder::getPartialSurrogates(*a4);
  *(unsigned char *)(a1 + 32) = *((unsigned char *)*a4 + 1048);
  if (a5) {
    *(void *)(a1 + 36) = 0x200000002;
  }
  return a1;
}

void sub_1009C44F8(_Unwind_Exception *a1)
{
  sub_1009C7264(v5);
  if (*(char *)(v1 + 375) < 0) {
    operator delete(*v4);
  }
  sub_100087E24(v3);
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_1009C456C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009C456C(uint64_t a1)
{
  *(void *)a1 = off_101999B40;
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_1009C45E8(uint64_t a1, int a2, void *a3)
{
  int v4 = (std::__shared_weak_count *)a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    sms::Model::Model(a1, a2, v6, 2, 0, 0);
    sub_10004D2C8(v4);
  }
  else
  {
    sms::Model::Model(a1, a2, v6, 2, 0, 0);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 192), "com.apple.telephony", "msg.c2k.mdl");
  *(void *)a1 = off_101A24760;
  *(_OWORD *)(a1 + 200) = xmmword_10151CE80;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 216));
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 376) = 11;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 405) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(unsigned char *)(a1 + 432) = 0;
  *(_OWORD *)(a1 + 436) = xmmword_10151CE90;
  *(_DWORD *)(a1 + 452) = 4243;
  *(unsigned char *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 460) = -1;
  *(unsigned char *)(a1 + 464) = 1;
  *(_DWORD *)(a1 + 516) = 0;
  *(_OWORD *)(a1 + 468) = 0u;
  *(_OWORD *)(a1 + 484) = 0u;
  *(_OWORD *)(a1 + 500) = 0u;
  return a1;
}

void sub_1009C4724(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_1009C456C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009C4748(uint64_t a1)
{
  *(void *)a1 = off_101A24760;
  sub_1009C7264(a1 + 472);
  if (*(char *)(a1 + 375) < 0) {
    operator delete(*(void **)(a1 + 352));
  }
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  if (*(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 192));

  return sub_1009C456C(a1);
}

void sub_1009C47FC(uint64_t a1)
{
  sub_1009C4748(a1);

  operator delete();
}

void sub_1009C4834(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2)
  {
    uint64_t v3 = (std::string *)(a1 + 160);
    std::string::operator=(v3, (const std::string *)a2);
  }
  else
  {
    int v4 = *(NSObject **)(a1 + 192);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid argument while setting destination address", v5, 2u);
    }
  }
}

uint64_t sub_1009C48D4(uint64_t a1)
{
  return a1 + 160;
}

void *sub_1009C48DC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1009C73DC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  char v8 = (void *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  void *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  uint64_t result = sub_10005C928(v8, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  ++a1[5];
  return result;
}

void sub_1009C4990(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  if (v4)
  {
    v59[0] = 0;
    v59[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v59);
    int v7 = *(char *)(a2 + 23);
    if (v7 >= 0) {
      char v8 = (const char *)a2;
    }
    else {
      char v8 = *(const char **)a2;
    }
    if (v7 >= 0) {
      unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      unint64_t v9 = *(void *)(a2 + 8);
    }
    ctu::TextConverter::setSource((ctu::TextConverter *)v59, v8, v9);
    ctu::TextConverter::pushConversion();
    BOOL v11 = sub_1009C520C(a1, v10);
    *(void *)CFMutableDictionaryRef theDict = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(a1 + 16));
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v15;
    int v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      int v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_20:
        (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, __CFString *, void, void))(*(void *)v21 + 96))(&Value, v21, *(unsigned int *)(a1 + 8), 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
        sub_10004EFE4(theDict, &Value);
        sub_1000577C4(&Value);
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        if (*(void *)theDict) {
          int v24 = sub_100080778;
        }
        else {
          int v24 = 0;
        }
        if (v24)
        {
          *(void *)long long buf = 0;
          CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)theDict, @"SupportsEMS");
          sub_1000057AC(buf, &Value);
          if (*(void *)buf) {
            int v26 = sub_100084B4C;
          }
          else {
            int v26 = 0;
          }
          BOOL v27 = 1;
          if (v26)
          {
            LOBYTE(Value) = 1;
            ctu::cf::assign((ctu::cf *)&Value, *(BOOL **)buf, v25);
            BOOL v27 = (_BYTE)Value != 0;
          }
          sub_100062778((const void **)buf);
        }
        else
        {
          BOOL v27 = 1;
        }
        sub_100057D78((const void **)theDict);
        int v29 = 0;
        switch(a3)
        {
          case 0:
            if (v11) {
              goto LABEL_71;
            }
            if (!v27) {
              goto LABEL_46;
            }
            goto LABEL_95;
          case 1:
            goto LABEL_95;
          case 4:
            goto LABEL_97;
          case 8:
            int v31 = *(char *)(a2 + 23);
            if (v31 >= 0) {
              uint64_t v32 = (ctu::TextConverter *)a2;
            }
            else {
              uint64_t v32 = *(ctu::TextConverter **)a2;
            }
            if (v31 >= 0) {
              int v33 = (const char *)*(unsigned __int8 *)(a2 + 23);
            }
            else {
              int v33 = *(const char **)(a2 + 8);
            }
            if ((unint64_t)ctu::TextConverter::countCharactersInUtf8Message(v32, v33, v28) < 0xA1) {
              goto LABEL_46;
            }
            int v38 = *(NSObject **)(a1 + 192);
            BOOL v42 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
            if (v11)
            {
              if (!v42) {
                goto LABEL_71;
              }
              C2KSmsPdu::asString();
              if (v58 >= 0) {
                int v43 = (BOOL *)buf;
              }
              else {
                int v43 = *(BOOL **)buf;
              }
              *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
              *(void *)&theDict[4] = v43;
              long long v41 = "#I Carrier supports %s concatenated messages";
LABEL_69:
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v41, theDict, 0xCu);
              if (v58 < 0) {
                operator delete(*(void **)buf);
              }
LABEL_71:
              ctu::TextConverter::pushConversion();
              ctu::TextConverter::readChars((uint64_t *)&v53, (ctu::TextConverter *)v59, 0x7FFFFFFFuLL);
              if (v54 < 0) {
                operator delete(v53);
              }
              if (!ctu::TextConverter::exceptionOccurred((ctu::TextConverter *)v59))
              {
                int v29 = 9;
                goto LABEL_97;
              }
              uint64_t v44 = *(NSObject **)(a1 + 192);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
              {
                C2KSmsPdu::asString();
                int v45 = v58 >= 0 ? buf : *(uint8_t **)buf;
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v45;
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Failed to convert to Gsm7, using %s", theDict, 0xCu);
                if (v58 < 0) {
                  operator delete(*(void **)buf);
                }
              }
LABEL_96:
              int v29 = 4;
LABEL_97:
              *(_DWORD *)(a1 + 376) = v29;
              __int16 v49 = *(NSObject **)(a1 + 192);
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                C2KSmsPdu::asString();
                if (v58 >= 0) {
                  int v50 = (BOOL *)buf;
                }
                else {
                  int v50 = *(BOOL **)buf;
                }
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v50;
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I C2KModel::setBody() fEncoding = %s", theDict, 0xCu);
                if (v58 < 0) {
                  operator delete(*(void **)buf);
                }
              }
LABEL_103:
              std::string::operator=((std::string *)(a1 + 352), (const std::string *)a2);
              ctu::TextConverter::~TextConverter((ctu::TextConverter *)v59);
              return;
            }
            if (v27)
            {
              if (v42)
              {
                C2KSmsPdu::asString();
                if (v58 >= 0) {
                  uint64_t v46 = (BOOL *)buf;
                }
                else {
                  uint64_t v46 = *(BOOL **)buf;
                }
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v46;
                __int16 v47 = "#I Using %s";
LABEL_93:
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v47, theDict, 0xCu);
                if (v58 < 0) {
                  operator delete(*(void **)buf);
                }
              }
            }
            else
            {
              if (v42)
              {
                C2KSmsPdu::asString();
                __int16 v51 = v58 >= 0 ? buf : *(uint8_t **)buf;
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v51;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Carrier doesn't support EMS going to attempt %s", theDict, 0xCu);
                if (v58 < 0) {
                  operator delete(*(void **)buf);
                }
              }
LABEL_46:
              ctu::TextConverter::pushConversion();
              ctu::TextConverter::readChars((uint64_t *)&__p, (ctu::TextConverter *)v59, 0x7FFFFFFFuLL);
              if (v56 < 0) {
                operator delete(__p);
              }
              if (!ctu::TextConverter::exceptionOccurred((ctu::TextConverter *)v59))
              {
                int v29 = 2;
                goto LABEL_97;
              }
              uint64_t v34 = *(NSObject **)(a1 + 192);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Failed to convert to 7BitAscii", buf, 2u);
              }
              ctu::TextConverter::popConversion((ctu::TextConverter *)v59);
              int v35 = *(char *)(a2 + 23);
              if (v35 >= 0) {
                uint64_t v36 = (const char *)a2;
              }
              else {
                uint64_t v36 = *(const char **)a2;
              }
              if (v35 >= 0) {
                unint64_t v37 = *(unsigned __int8 *)(a2 + 23);
              }
              else {
                unint64_t v37 = *(void *)(a2 + 8);
              }
              ctu::TextConverter::setSource((ctu::TextConverter *)v59, v36, v37);
              int v38 = *(NSObject **)(a1 + 192);
              BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
              if (v11)
              {
                if (!v39) {
                  goto LABEL_71;
                }
                C2KSmsPdu::asString();
                if (v58 >= 0) {
                  int v40 = (BOOL *)buf;
                }
                else {
                  int v40 = *(BOOL **)buf;
                }
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v40;
                long long v41 = "#I Attempting to fall back to %s";
                goto LABEL_69;
              }
              if (v39)
              {
                C2KSmsPdu::asString();
                if (v58 >= 0) {
                  int v48 = (BOOL *)buf;
                }
                else {
                  int v48 = *(BOOL **)buf;
                }
                *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
                *(void *)&theDict[4] = v48;
                __int16 v47 = "#I Falling back to %s";
                goto LABEL_93;
              }
            }
LABEL_95:
            ctu::TextConverter::pushConversion();
            goto LABEL_96;
          default:
            long long v30 = *(NSObject **)(a1 + 192);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              C2KSmsPdu::asString();
              int v52 = v58 >= 0 ? buf : *(uint8_t **)buf;
              *(_DWORD *)CFMutableDictionaryRef theDict = 136315138;
              *(void *)&theDict[4] = v52;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "C2KModel::setBody() attempted unsupported encoding: %s", theDict, 0xCu);
              if (v58 < 0) {
                operator delete(*(void **)buf);
              }
            }
            *(_DWORD *)(a1 + 376) = 11;
            goto LABEL_103;
        }
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    int v20 = 0;
    char v22 = 1;
    goto LABEL_20;
  }
  uint64_t v23 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid data provided, ignoring ::setBody() call", buf, 2u);
  }
}

void sub_1009C5150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  _Unwind_Resume(a1);
}

BOOL sub_1009C520C@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 16));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v21);
  if (v9)
  {
    uint64_t v11 = v9[3];
    int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  int v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, __CFString *, void, void))(*(void *)v11 + 96))(&v19, v11, *(unsigned int *)(a1 + 8), 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
  sub_10004EFE4(&theDict, &v19);
  sub_1000577C4(&v19);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (theDict) {
    uint64_t v13 = sub_100080778;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13
    && (Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"UnsupportedEncodings"), (CFArrayRef v15 = Value) != 0)
    && (CFTypeID v16 = CFGetTypeID(Value), v16 == CFArrayGetTypeID()))
  {
    v22.length = CFArrayGetCount(v15);
    v22.location = 0;
    BOOL v17 = CFArrayContainsValue(v15, v22, @"7bitGSM") == 0;
  }
  else
  {
    BOOL v17 = 1;
  }
  sub_100057D78((const void **)&theDict);
  return v17;
}

void sub_1009C53D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

std::string *sub_1009C540C(std::string *a1, const std::string *a2)
{
  uint64_t result = std::string::operator=(a1 + 3, a2);
  a1[2].__r_.__value_.__s.__data_[16] = 1;
  return result;
}

void sub_1009C543C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

char *sub_1009C5448@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[375] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 44), *((void *)result + 45));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 22);
  *(void *)(a2 + 16) = *((void *)result + 46);
  return result;
}

uint64_t sub_1009C5474(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 376);
  if (v1 > 9) {
    return 8;
  }
  else {
    return dword_10151CEE4[v1];
  }
}

void sub_1009C5498(uint64_t a1, int *a2, int *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 192);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!a2 || !a3)
  {
    if (!v7) {
      return;
    }
    *(_DWORD *)std::string __p = 134218240;
    *(void *)&__p[4] = a2;
    *(_WORD *)&unsigned char __p[12] = 2048;
    BOOL v27 = a3;
    uint64_t v14 = "#I Invalid paramaters, encodeSize: %p, splitThreshold: %p";
    CFArrayRef v15 = v6;
    uint32_t v16 = 22;
    goto LABEL_37;
  }
  if (v7)
  {
    C2KSmsPdu::asString();
    unsigned int v8 = v28 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)long long buf = 136315138;
    long long v30 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I getSizeInEncodedCharactersAndSplitThreshold: using encoding: %s", buf, 0xCu);
    if (v28 < 0) {
      operator delete(*(void **)__p);
    }
  }
  int v9 = sub_100795578((Registry **)(a1 + 16), *(unsigned int *)(a1 + 8));
  int v11 = *(_DWORD *)(a1 + 376);
  int v12 = v9;
  switch(v11)
  {
    case 0:
      if (*(char *)(a1 + 375) < 0) {
        uint64_t v17 = *(void *)(a1 + 360);
      }
      else {
        LODWORD(v17) = *(unsigned __int8 *)(a1 + 375);
      }
      *a2 = v17;
      int v21 = 134;
      *a3 = 134;
      goto LABEL_30;
    case 2:
    case 9:
      if (*(char *)(a1 + 375) < 0) {
        uint64_t v13 = *(void *)(a1 + 360);
      }
      else {
        LODWORD(v13) = *(unsigned __int8 *)(a1 + 375);
      }
      *a2 = v13;
      int v21 = 160;
      *a3 = 160;
      if (!v9) {
        goto LABEL_30;
      }
      double v22 = (double)v9 * 8.0 / 7.0;
      break;
    case 4:
      if (*(char *)(a1 + 375) < 0)
      {
        int v19 = *(ctu::TextConverter **)(a1 + 352);
        int v20 = *(const char **)(a1 + 360);
      }
      else
      {
        int v19 = (ctu::TextConverter *)(a1 + 352);
        int v20 = (const char *)*(unsigned __int8 *)(a1 + 375);
      }
      *a2 = ctu::TextConverter::countCharactersInUtf8Message(v19, v20, v10);
      int v21 = 70;
      *a3 = 70;
      if (!v12) {
        goto LABEL_30;
      }
      double v22 = (double)v12 * 0.5;
      break;
    default:
      unsigned int v18 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string __p = 67109120;
        *(_DWORD *)&__p[4] = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Don't know how to calculate character count / split threshold for encoding %d", __p, 8u);
      }
      *a3 = 0;
      *a2 = 0;
      return;
  }
  int v12 = vcvtpd_s64_f64(v22);
LABEL_30:
  if (*a2 > v21) {
    *(unsigned char *)(a1 + 432) = 1;
  }
  if (v12 >= 1 && v21 > v12)
  {
    *a3 = v12;
    int v21 = v12;
  }
  uint64_t v23 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = *a2;
    int v25 = *(_DWORD *)(a1 + 376);
    *(_DWORD *)std::string __p = 67109632;
    *(_DWORD *)&__p[4] = v24;
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&__p[10] = v21;
    LOWORD(v27) = 1024;
    *(_DWORD *)((char *)&v27 + 2) = v25;
    uint64_t v14 = "#I C2KModel: Message size: %d split threshold: %d for encoding: %d";
    CFArrayRef v15 = v23;
    uint32_t v16 = 20;
LABEL_37:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, __p, v16);
  }
}

BOOL sub_1009C57B8(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = 0;
  (*(void (**)(uint64_t, char *, uint64_t *))(*(void *)a1 + 216))(a1, (char *)&v12 + 4, &v12);
  unsigned int v4 = *(_DWORD *)(a1 + 376);
  switch(v4)
  {
    case 0u:
      unsigned int v5 = HIDWORD(v12);
      goto LABEL_7;
    case 2u:
    case 9u:
      unsigned int v5 = vcvtpd_s64_f64((double)SHIDWORD(v12) * 7.0 * 0.125);
      goto LABEL_7;
    case 4u:
      unsigned int v5 = 2 * HIDWORD(v12);
LABEL_7:
      if ((int)v5 >= 141)
      {
        if (v5 % 0x86) {
          unsigned int v8 = v5 % 0x86 + 6;
        }
        else {
          unsigned int v8 = 0;
        }
        unsigned int v5 = v8 + 140 * (v5 / 0x86);
      }
      BOOL v7 = v5 > a2;
      int v9 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v10 = "sms";
        *(_DWORD *)long long buf = 67109634;
        unsigned int v14 = v5;
        if (v5 > a2) {
          unint64_t v10 = "mms";
        }
        __int16 v15 = 1024;
        unsigned int v16 = a2;
        __int16 v17 = 2080;
        unsigned int v18 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I C2KModel: Message size: %d bytes  SMS sent as MMS threshold: %d bytes. Message sent as %s", buf, 0x18u);
      }
      break;
    default:
      uint64_t v6 = *(NSObject **)(a1 + 192);
      BOOL v7 = 0;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        unsigned int v14 = v4;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Warning: Don't know how to check encoding %d for encoded body size in bytes", buf, 8u);
        BOOL v7 = 0;
      }
      break;
  }
  return v7;
}

uint64_t sub_1009C59DC()
{
  return 0;
}

uint64_t sub_1009C59E4()
{
  return 5;
}

BOOL sub_1009C59EC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 448) == 0;
}

uint64_t sub_1009C59FC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 204) == 1) {
    return 2;
  }
  else {
    return *(unsigned int *)(a1 + 200);
  }
}

uint64_t *sub_1009C5A18@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 200) == 1) {
    return CSIPhoneNumber::getFullNumber(a2, (CSIPhoneNumber *)(a1 + 216));
  }
  char v3 = (char *)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    char v3 = *(char **)v3;
  }
  return sub_100058DB0(a2, v3);
}

uint64_t sub_1009C5A48()
{
  return 0;
}

uint64_t sub_1009C5A50()
{
  return 0;
}

void sub_1009C5A58(CSIPhoneNumber *a1@<X8>)
{
}

uint64_t sub_1009C5A6C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 460);
}

uint64_t sub_1009C5A74(uint64_t result, int a2)
{
  *(_DWORD *)(result + 460) = a2;
  return result;
}

double sub_1009C5A7C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 200) == 1)
  {
    long long v3 = *(_OWORD *)(a1 + 400);
    *a2 = *(_OWORD *)(a1 + 384);
    a2[1] = v3;
    long long v4 = *(_OWORD *)(a1 + 416);
    a2[2] = v4;
  }
  else
  {
    unsigned int v5 = *(NSObject **)(a1 + 192);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "C2KModel::getTimestamp() called on non-MT message, returning empty date", v7, 2u);
    }
    *(void *)&long long v4 = 0;
    a2[1] = 0u;
    a2[2] = 0u;
    *a2 = 0u;
  }
  return *(double *)&v4;
}

uint64_t sub_1009C5B10(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 432);
}

uint64_t sub_1009C5B18(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a2 = a1[109];
  *a3 = a1[111];
  *a4 = a1[110];
  return 1;
}

uint64_t sub_1009C5B38()
{
  return 0;
}

uint64_t sub_1009C5B40()
{
  return 0;
}

uint64_t sub_1009C5B48()
{
  return 0;
}

uint64_t sub_1009C5B50()
{
  return 0;
}

uint64_t sub_1009C5B58()
{
  return 0;
}

uint64_t sub_1009C5B60()
{
  return 0;
}

uint64_t sub_1009C5B68()
{
  return 0;
}

void sub_1009C5B70(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_1009C5B78(uint64_t a1)
{
  return *(unsigned int *)(a1 + 212);
}

uint64_t sub_1009C5B80(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 468) - 1;
  if (v1 > 6) {
    return 25;
  }
  else {
    return dword_10151CF0C[v1];
  }
}

uint64_t sub_1009C5BA8(sms::Model *a1)
{
  unsigned __int16 v1 = word_101B0F738++;
  return sms::Model::setMessageID(a1, v1);
}

uint64_t sub_1009C5BBC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 64))
  {
    v10[0] = 0;
    v10[1] = 0;
    sub_100202130(v10);
  }
  if (*(char *)(a1 + 95) < 0)
  {
    uint64_t v2 = *(char **)(a1 + 72);
    size_t v3 = *(void *)(a1 + 80);
  }
  else
  {
    uint64_t v2 = (char *)(a1 + 72);
    size_t v3 = *(unsigned __int8 *)(a1 + 95);
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v12 = 0;
  sub_1007DC9C0((char *)buf, v2, &v2[v3], v3);
  uint64_t v4 = *(void *)(a1 + 488);
  uint64_t v5 = *(void *)(a1 + 480);
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = *(void *)(a1 + 512) + *(void *)(a1 + 504);
  if (v6 == v7)
  {
    sub_1009C73DC((void *)(a1 + 472));
    uint64_t v5 = *(void *)(a1 + 480);
    unint64_t v7 = *(void *)(a1 + 512) + *(void *)(a1 + 504);
  }
  unsigned int v8 = (void *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  void *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  *(_OWORD *)unsigned int v8 = *(_OWORD *)buf;
  v8[2] = v12;
  ++*(void *)(a1 + 512);
  return 0;
}

void sub_1009C6864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42,void *a43,uint64_t a44)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)&a23);
  std::string __p = &a35;
  sub_100047F64((void ***)&__p);
  if (a38)
  {
    a39 = (uint64_t)a38;
    operator delete(a38);
  }
  if (a42) {
    sub_10004D2C8(a42);
  }
  _Unwind_Resume(a1);
}

void sub_1009C6A00()
{
  v0[0] = 0;
  v0[1] = 0;
  sub_100202130(v0);
}

void sub_1009C7098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  unsigned int v18 = *(void **)(v16 - 88);
  if (v18)
  {
    *(void *)(v16 - 80) = v18;
    operator delete(v18);
  }
  int v19 = *(void **)(v16 - 128);
  if (v19)
  {
    *(void *)(v16 - 120) = v19;
    operator delete(v19);
  }
  int v20 = *(std::__shared_weak_count **)(v16 - 96);
  if (v20) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009C7130(uint64_t a1)
{
  return *(void *)(a1 + 512);
}

void *sub_1009C7138@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (result[64])
  {
    unint64_t v2 = *(void *)(result[60] + 8 * (result[63] / 0xAAuLL)) + 24 * (result[63] % 0xAAuLL);
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    return sub_10005C928(a2, *(const void **)v2, *(void *)(v2 + 8), *(void *)(v2 + 8) - *(void *)v2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return result;
}

void sub_1009C7190(uint64_t a1)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1))
  {
    unint64_t v2 = *(void *)(a1 + 504);
    uint64_t v3 = *(void *)(*(void *)(a1 + 480) + 8 * (v2 / 0xAA));
    uint64_t v4 = *(void **)(v3 + 24 * (v2 % 0xAA));
    if (v4)
    {
      *(void *)(v3 + 24 * (v2 % 0xAA) + 8) = v4;
      operator delete(v4);
      unint64_t v2 = *(void *)(a1 + 504);
    }
    uint64_t v5 = *(void *)(a1 + 512) - 1;
    unint64_t v6 = v2 + 1;
    *(void *)(a1 + 504) = v6;
    *(void *)(a1 + 512) = v5;
    if (v6 >= 0x154)
    {
      operator delete(**(void ***)(a1 + 480));
      *(void *)(a1 + 480) += 8;
      *(void *)(a1 + 504) -= 170;
    }
  }
}

uint64_t sub_1009C725C()
{
  return 0;
}

uint64_t sub_1009C7264(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    unint64_t v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        unint64_t v10 = *(void **)v8;
        if (*(void *)v8)
        {
          *(void *)(v8 + 8) = v10;
          operator delete(v10);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v11 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v11;
          unint64_t v8 = v11;
        }
      }
      while (v8 != v9);
      unint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *uint64_t v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 85;
    goto LABEL_16;
  }
  if (v13 == 2)
  {
    uint64_t v14 = 170;
LABEL_16:
    *(void *)(a1 + 32) = v14;
  }
  if (v2 != v3)
  {
    do
    {
      __int16 v15 = *v2++;
      operator delete(v15);
    }
    while (v2 != v3);
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(a1 + 16);
    if (v16 != v17) {
      *(void *)(a1 + 16) = v16 + ((v17 - v16 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1009C73DC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    a1[4] = v4;
    unint64_t v5 = (void *)a1[1];
    unint64_t v6 = (char *)a1[2];
    uint64_t v9 = *v5;
    unint64_t v7 = (char *)(v5 + 1);
    uint64_t v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3]) {
      goto LABEL_41;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v38 = 1;
      }
      else {
        unint64_t v38 = (uint64_t)&v6[-*a1] >> 2;
      }
      BOOL v39 = (char *)sub_100048350(v38);
      int v40 = &v39[8 * (v38 >> 2)];
      BOOL v42 = &v39[8 * v41];
      int v43 = (uint64_t *)a1[1];
      unint64_t v6 = v40;
      uint64_t v44 = a1[2] - (void)v43;
      if (v44)
      {
        unint64_t v6 = &v40[v44 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v45 = 8 * (v44 >> 3);
        uint64_t v46 = &v39[8 * (v38 >> 2)];
        do
        {
          uint64_t v47 = *v43++;
          *(void *)uint64_t v46 = v47;
          v46 += 8;
          v45 -= 8;
        }
        while (v45);
      }
      goto LABEL_29;
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    BOOL v12 = v10 >> 3 < -1;
    uint64_t v13 = (v10 >> 3) + 2;
    if (v12) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v11 + 1;
    }
    uint64_t v15 = -(v14 >> 1);
    uint64_t v16 = v14 >> 1;
    uint64_t v17 = &v7[-8 * v16];
    int64_t v18 = v6 - v7;
    if (v6 != v7)
    {
      memmove(&v7[-8 * v16], v7, v6 - v7);
      unint64_t v7 = (char *)a1[1];
    }
    unint64_t v6 = &v17[v18];
    a1[1] = &v7[8 * v15];
    a1[2] = &v17[v18];
    goto LABEL_41;
  }
  int v20 = (char *)a1[2];
  int v19 = (char *)a1[3];
  int v21 = (char *)*a1;
  double v22 = (char *)a1[1];
  unint64_t v23 = (v20 - v22) >> 3;
  uint64_t v24 = (uint64_t)&v19[-*a1];
  if (v23 < v24 >> 3)
  {
    int v25 = operator new(0xFF0uLL);
    int v26 = v25;
    if (v19 != v20)
    {
      *(void *)int v20 = v25;
LABEL_42:
      a1[2] += 8;
      return;
    }
    if (v22 == v21)
    {
      if (v20 == v22) {
        unint64_t v49 = 1;
      }
      else {
        unint64_t v49 = (v19 - v22) >> 2;
      }
      uint64_t v50 = 2 * v49;
      __int16 v51 = (char *)sub_100048350(v49);
      double v22 = &v51[(v50 + 6) & 0xFFFFFFFFFFFFFFF8];
      __int16 v53 = (uint64_t *)a1[1];
      char v54 = v22;
      uint64_t v55 = a1[2] - (void)v53;
      if (v55)
      {
        char v54 = &v22[v55 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v56 = 8 * (v55 >> 3);
        int v57 = &v51[(v50 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v58 = *v53++;
          *(void *)int v57 = v58;
          v57 += 8;
          v56 -= 8;
        }
        while (v56);
      }
      uint64_t v59 = (char *)*a1;
      *a1 = v51;
      a1[1] = v22;
      a1[2] = v54;
      a1[3] = &v51[8 * v52];
      if (v59)
      {
        operator delete(v59);
        double v22 = (char *)a1[1];
      }
    }
    *((void *)v22 - 1) = v26;
    unint64_t v7 = (char *)a1[1];
    unint64_t v6 = (char *)a1[2];
    a1[1] = v7 - 8;
    uint64_t v8 = *((void *)v7 - 1);
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_41:
      *(void *)unint64_t v6 = v8;
      goto LABEL_42;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v82 = 1;
      }
      else {
        unint64_t v82 = (uint64_t)&v6[-*a1] >> 2;
      }
      BOOL v39 = (char *)sub_100048350(v82);
      int v40 = &v39[8 * (v82 >> 2)];
      BOOL v42 = &v39[8 * v83];
      long long v84 = (uint64_t *)a1[1];
      unint64_t v6 = v40;
      uint64_t v85 = a1[2] - (void)v84;
      if (v85)
      {
        unint64_t v6 = &v40[v85 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v86 = 8 * (v85 >> 3);
        CFTypeRef v87 = &v39[8 * (v82 >> 2)];
        do
        {
          uint64_t v88 = *v84++;
          *(void *)CFTypeRef v87 = v88;
          v87 += 8;
          v86 -= 8;
        }
        while (v86);
      }
LABEL_29:
      int v48 = (char *)*a1;
      *a1 = v39;
      a1[1] = v40;
      a1[2] = v6;
      a1[3] = v42;
      if (v48)
      {
        operator delete(v48);
        unint64_t v6 = (char *)a1[2];
      }
      goto LABEL_41;
    }
    goto LABEL_5;
  }
  uint64_t v27 = v24 >> 2;
  if (v19 == v21) {
    unint64_t v28 = 1;
  }
  else {
    unint64_t v28 = v27;
  }
  int v29 = (char *)sub_100048350(v28);
  uint64_t v31 = v30;
  uint64_t v32 = operator new(0xFF0uLL);
  int v33 = &v29[8 * v23];
  uint64_t v34 = &v29[8 * v31];
  if (v23 == v31)
  {
    uint64_t v35 = 8 * v23;
    if (v20 - v22 < 1)
    {
      uint64_t v60 = v35 >> 2;
      if (v20 == v22) {
        unint64_t v61 = 1;
      }
      else {
        unint64_t v61 = v60;
      }
      uint64_t v62 = (char *)sub_100048350(v61);
      int v33 = &v62[8 * (v61 >> 2)];
      uint64_t v34 = &v62[8 * v63];
      if (v29) {
        operator delete(v29);
      }
      int v29 = v62;
    }
    else
    {
      uint64_t v36 = v35 >> 3;
      if (v36 >= -1) {
        unint64_t v37 = v36 + 1;
      }
      else {
        unint64_t v37 = v36 + 2;
      }
      v33 -= 8 * (v37 >> 1);
    }
  }
  *(void *)int v33 = v32;
  xpc_object_t v64 = v33 + 8;
  for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
  {
    if (v33 == v29)
    {
      if (v64 >= v34)
      {
        if (v34 == v29) {
          unint64_t v70 = 1;
        }
        else {
          unint64_t v70 = (v34 - v29) >> 2;
        }
        uint64_t v71 = (char *)sub_100048350(v70);
        uint64_t v73 = v71;
        int v33 = &v71[(2 * v70 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v75 = v64 - v29;
        BOOL v74 = v64 == v29;
        xpc_object_t v64 = v33;
        if (!v74)
        {
          xpc_object_t v64 = &v33[v75 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v76 = 8 * (v75 >> 3);
          xpc_object_t v77 = v33;
          unint64_t v78 = (uint64_t *)v29;
          do
          {
            uint64_t v79 = *v78++;
            *(void *)xpc_object_t v77 = v79;
            v77 += 8;
            v76 -= 8;
          }
          while (v76);
        }
        uint64_t v34 = &v71[8 * v72];
        if (v29) {
          operator delete(v29);
        }
        int v29 = v73;
      }
      else
      {
        uint64_t v66 = (v34 - v64) >> 3;
        if (v66 >= -1) {
          uint64_t v67 = v66 + 1;
        }
        else {
          uint64_t v67 = v66 + 2;
        }
        uint64_t v68 = v67 >> 1;
        int v33 = &v29[8 * (v67 >> 1)];
        xpc_object_t v69 = v29;
        if (v64 != v29)
        {
          memmove(v33, v29, v64 - v29);
          xpc_object_t v69 = v64;
        }
        xpc_object_t v64 = &v69[8 * v68];
      }
    }
    uint64_t v80 = *(void *)(i - 8);
    *((void *)v33 - 1) = v80;
    v33 -= 8;
  }
  xpc_object_t v81 = (char *)*a1;
  *a1 = v29;
  a1[1] = v33;
  a1[2] = v64;
  a1[3] = v34;
  if (v81)
  {
    operator delete(v81);
  }
}

void sub_1009C7810(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1009C783C(Registry *a1)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  sub_1003BEF68(a1, &v5);
  uint64_t v2 = v5;
  if (v5)
  {
    sub_100058DB0(__p, "Carrier Entitlement Query");
    (*(void (**)(uint64_t, Registry *, uint64_t, uint64_t, void **, void, void))(*(void *)v2 + 80))(v2, a1, 0x8000, 1, __p, 0, 0);
    if (v4 < 0) {
      operator delete(__p[0]);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1009C78E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void stewie::AnchorStorage::create(int **a1, os_log_t *a2)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  char v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Creating anchors [", buf, 2u);
  }
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  double v22 = &v23;
  uint64_t v5 = *a1;
  if (*a1 != a1[1])
  {
    float64x2_t v19 = (float64x2_t)vdupq_n_s64(0x4066800000000000uLL);
    float64x2_t v20 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
    do
    {
      float32x2_t v6 = *(float32x2_t *)(v5 + 1);
      float v7 = *((float *)v5 + 3);
      unsigned int v8 = *v5;
      uint64_t v9 = (char *)operator new(0x38uLL);
      double v10 = v7;
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *((_DWORD *)v9 + 6) = v8;
      uint64_t v11 = (unsigned int *)(v9 + 24);
      *(void *)uint64_t v9 = off_101A24A10;
      float64x2_t v21 = vdivq_f64(vmulq_f64(vcvtq_f64_f32(v6), v20), v19);
      *((float64x2_t *)v9 + 2) = v21;
      *((double *)v9 + 6) = v10;
      BOOL v12 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109888;
        *(_DWORD *)unint64_t v28 = v8;
        *(_WORD *)&void v28[4] = 2048;
        *(double *)&v28[6] = 180.0 * v21.f64[0] / 3.14159265;
        __int16 v29 = 2048;
        double v30 = vmuld_lane_f64(180.0, v21, 1) / 3.14159265;
        __int16 v31 = 2048;
        double v32 = v10;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Created anchor with id: %d, location: [%.6f, %.6f, %.6f]", buf, 0x26u);
        unsigned int v8 = *v11;
      }
      uint64_t v13 = v23;
      uint64_t v14 = &v23;
      uint64_t v15 = &v23;
      if (v23)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v15 = (uint64_t **)v13;
            unsigned int v16 = *((_DWORD *)v13 + 8);
            if (v16 <= v8) {
              break;
            }
            uint64_t v13 = *v15;
            uint64_t v14 = v15;
            if (!*v15) {
              goto LABEL_14;
            }
          }
          if (v16 >= v8) {
            break;
          }
          uint64_t v13 = v15[1];
          if (!v13)
          {
            uint64_t v14 = v15 + 1;
            goto LABEL_14;
          }
        }
        sub_10004D2C8((std::__shared_weak_count *)v9);
      }
      else
      {
LABEL_14:
        uint64_t v17 = operator new(0x38uLL);
        v17[8] = v8;
        *((void *)v17 + 5) = v11;
        *((void *)v17 + 6) = v9;
        *(void *)uint64_t v17 = 0;
        *((void *)v17 + 1) = 0;
        *((void *)v17 + 2) = v15;
        *uint64_t v14 = (uint64_t *)v17;
        if (*v22)
        {
          double v22 = (uint64_t **)*v22;
          uint64_t v17 = *v14;
        }
        sub_100046C90(v23, (uint64_t *)v17);
        ++v24;
      }
      v5 += 4;
    }
    while (v5 != a1[1]);
  }
  int64_t v18 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)unint64_t v28 = v24;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I ], created %zu anchors", buf, 0xCu);
  }
  stewie::Anchors::create();
}

void sub_1009C7D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(a1);
}

void sub_1009C7DD4(uint64_t a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v5 = *(NSObject **)(a1 + 8);
  unint64_t v61 = (os_log_t *)(a1 + 8);
  if (*a2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I anchorageAtLocation - selecting anchors", buf, 2u);
    }
    uint64_t v68 = 0;
    xpc_object_t v69 = 0;
    uint64_t v67 = 0;
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v9 = *(void **)(v8 + 16);
    if (v9 == (void *)(v8 + 24))
    {
      int64x2_t v65 = 0uLL;
      v66[0] = 0;
    }
    else
    {
      uint64_t v59 = a4;
      do
      {
        CLClientGetDistanceCoordinates();
        double v11 = v10;
        if (v10 < *(double *)(a1 + 32))
        {
          BOOL v12 = *v61;
          if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = *(_DWORD *)v9[5];
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Selected anchors with id %d", buf, 8u);
          }
          uint64_t v15 = v9[5];
          uint64_t v14 = v9[6];
          unsigned int v16 = v68;
          if (v68 >= v69)
          {
            int64_t v18 = v67;
            unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v68 - v67) >> 3);
            unint64_t v20 = v19 + 1;
            if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_10006A748();
            }
            if (0x5555555555555556 * ((v69 - v67) >> 3) > v20) {
              unint64_t v20 = 0x5555555555555556 * ((v69 - v67) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v69 - v67) >> 3) >= 0x555555555555555) {
              unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v21 = v20;
            }
            if (v21 > 0xAAAAAAAAAAAAAAALL) {
              sub_10006A7CC();
            }
            uint64_t v22 = (char *)operator new(24 * v21);
            unint64_t v23 = &v22[8 * ((v68 - v67) >> 3)];
            *(double *)unint64_t v23 = v11;
            *((void *)v23 + 1) = v15;
            *((void *)v23 + 2) = v14;
            if (v14)
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
              unsigned int v16 = v68;
            }
            uint64_t v17 = v23 + 24;
            if (v16 == v18)
            {
              uint64_t v67 = &v22[24 * v19];
              uint64_t v68 = v23 + 24;
              xpc_object_t v69 = &v22[24 * v21];
            }
            else
            {
              do
              {
                uint64_t v24 = *((void *)v16 - 3);
                v16 -= 24;
                *((void *)v23 - 3) = v24;
                v23 -= 24;
                *(_OWORD *)(v23 + 8) = *(_OWORD *)(v16 + 8);
                *((void *)v16 + 1) = 0;
                *((void *)v16 + 2) = 0;
              }
              while (v16 != v18);
              int64_t v18 = v67;
              uint64_t v25 = v68;
              uint64_t v67 = v23;
              uint64_t v68 = v17;
              xpc_object_t v69 = &v22[24 * v21];
              while (v25 != v18)
              {
                uint64_t v26 = (std::__shared_weak_count *)*((void *)v25 - 1);
                if (v26) {
                  sub_10004D2C8(v26);
                }
                v25 -= 24;
              }
            }
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            *(double *)uint64_t v68 = v11;
            *((void *)v16 + 1) = v15;
            *((void *)v16 + 2) = v14;
            if (v14) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v17 = v16 + 24;
          }
          uint64_t v68 = v17;
        }
        uint64_t v27 = (void *)v9[1];
        if (v27)
        {
          do
          {
            unint64_t v28 = v27;
            uint64_t v27 = (void *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            unint64_t v28 = (void *)v9[2];
            BOOL v29 = *v28 == (void)v9;
            uint64_t v9 = v28;
          }
          while (!v29);
        }
        uint64_t v9 = v28;
      }
      while (v28 != (void *)(*(void *)(a1 + 16) + 24));
      __int16 v31 = v67;
      double v30 = v68;
      int64x2_t v65 = 0uLL;
      v66[0] = 0;
      if (v68 == v67)
      {
        a4 = v59;
      }
      else
      {
        unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((v68 - v67) >> 3);
        a4 = v59;
        if (v32 >> 60) {
          sub_10006A748();
        }
        uint64_t v72 = v66;
        int v33 = (char *)sub_1009C886C(v32);
        uint64_t v35 = (void *)v65.i64[1];
        uint64_t v36 = (void *)v65.i64[0];
        if (v65.i64[1] == v65.i64[0])
        {
          int64x2_t v39 = vdupq_n_s64(v65.u64[1]);
          unint64_t v37 = v33;
        }
        else
        {
          unint64_t v37 = v33;
          do
          {
            long long v38 = *((_OWORD *)v35 - 1);
            v35 -= 2;
            *((_OWORD *)v37 - 1) = v38;
            v37 -= 16;
            void *v35 = 0;
            v35[1] = 0;
          }
          while (v35 != v36);
          int64x2_t v39 = v65;
        }
        v65.i64[0] = (uint64_t)v37;
        v65.i64[1] = (uint64_t)v33;
        *(int64x2_t *)&uint8_t buf[8] = v39;
        uint64_t v40 = v66[0];
        v66[0] = &v33[16 * v34];
        uint64_t v71 = v40;
        *(void *)long long buf = v39.i64[0];
        sub_10019E528((uint64_t)buf);
        __int16 v31 = v67;
        double v30 = v68;
      }
      if (v31 != v30)
      {
        uint64_t v41 = (void *)v65.i64[1];
        do
        {
          if ((unint64_t)v41 >= v66[0])
          {
            uint64_t v43 = ((uint64_t)v41 - v65.i64[0]) >> 4;
            if ((unint64_t)(v43 + 1) >> 60) {
              sub_10006A748();
            }
            unint64_t v44 = (v66[0] - v65.i64[0]) >> 3;
            if (v44 <= v43 + 1) {
              unint64_t v44 = v43 + 1;
            }
            if (v66[0] - v65.i64[0] >= 0x7FFFFFFFFFFFFFF0uLL) {
              unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v45 = v44;
            }
            uint64_t v72 = v66;
            uint64_t v46 = (char *)sub_1009C886C(v45);
            int v48 = &v46[16 * v43];
            long long v49 = *(_OWORD *)(v31 + 8);
            *(_OWORD *)int v48 = v49;
            if (*((void *)&v49 + 1)) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v49 + 1) + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v50 = (void *)v65.i64[1];
            __int16 v51 = (void *)v65.i64[0];
            if (v65.i64[1] == v65.i64[0])
            {
              int64x2_t v54 = vdupq_n_s64(v65.u64[1]);
              uint64_t v52 = &v46[16 * v43];
            }
            else
            {
              uint64_t v52 = &v46[16 * v43];
              do
              {
                long long v53 = *((_OWORD *)v50 - 1);
                v50 -= 2;
                *((_OWORD *)v52 - 1) = v53;
                v52 -= 16;
                *uint64_t v50 = 0;
                v50[1] = 0;
              }
              while (v50 != v51);
              int64x2_t v54 = v65;
            }
            uint64_t v41 = v48 + 16;
            v65.i64[0] = (uint64_t)v52;
            v65.i64[1] = (uint64_t)(v48 + 16);
            *(int64x2_t *)&uint8_t buf[8] = v54;
            uint64_t v55 = v66[0];
            v66[0] = &v46[16 * v47];
            uint64_t v71 = v55;
            *(void *)long long buf = v54.i64[0];
            sub_10019E528((uint64_t)buf);
          }
          else
          {
            void *v41 = *((void *)v31 + 1);
            uint64_t v42 = *((void *)v31 + 2);
            v41[1] = v42;
            if (v42) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
            }
            v41 += 2;
          }
          v65.i64[1] = (uint64_t)v41;
          v31 += 24;
        }
        while (v31 != v68);
      }
    }
    uint64_t v56 = *v61;
    if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = (v65.i64[1] - v65.i64[0]) >> 4;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Selected %zu anchors for location", buf, 0xCu);
    }
    int v57 = (std::__shared_weak_count *)a2[1];
    uint64_t v63 = *a2;
    xpc_object_t v64 = v57;
    if (v57) {
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v58 = *(std::__shared_weak_count **)(a3 + 8);
    uint64_t v62 = v58;
    if (v58) {
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    stewie::AnchorageAtLocation::create(&v63, v61, a4);
    if (v62) {
      sub_10004D2C8(v62);
    }
    if (v64) {
      sub_10004D2C8(v64);
    }
    *(void *)long long buf = &v65;
    sub_10005CBF0((void ***)buf);
    *(void *)long long buf = &v67;
    sub_1009C88A4((void ***)buf);
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "targetInstantAtLocationCacheFactory required", buf, 2u);
    }
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1009C83EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void ***a28)
{
  a28 = &a21;
  sub_10005CBF0((void ***)&a28);
  a21 = (void **)&a25;
  sub_1009C88A4(&a21);
  _Unwind_Resume(a1);
}

void sub_1009C844C(void *a1)
{
  uint64_t v2 = a1[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************", buf, 2u);
    uint64_t v2 = a1[1];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * AnchorStorage state *", buf, 2u);
    uint64_t v2 = a1[1];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************", buf, 2u);
    uint64_t v2 = a1[1];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    *(_DWORD *)long long buf = 134217984;
    *(void *)uint64_t v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Distance threshold: %.2f", buf, 0xCu);
    uint64_t v2 = a1[1];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Anchors [", buf, 2u);
  }
  uint64_t v4 = a1[2];
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 != (void *)(v4 + 24))
  {
    do
    {
      float32x2_t v6 = a1[1];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        float v7 = (double *)v5[5];
        int v8 = *(_DWORD *)v7;
        double v9 = v7[1] * 180.0 / 3.14159265;
        double v10 = v7[2] * 180.0;
        uint64_t v11 = *((void *)v7 + 3);
        *(_DWORD *)long long buf = 67109889;
        *(_DWORD *)uint64_t v17 = v8;
        *(_WORD *)&uint8_t v17[4] = 2049;
        *(double *)&v17[6] = v9;
        __int16 v18 = 2049;
        double v19 = v10 / 3.14159265;
        __int16 v20 = 2049;
        uint64_t v21 = v11;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d]      id: %d, location: [%{private}.6f, %{private}.6f, %{private}.6f]", buf, 0x26u);
      }
      BOOL v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          BOOL v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (void *)v5[2];
          BOOL v14 = *v13 == (void)v5;
          uint64_t v5 = v13;
        }
        while (!v14);
      }
      uint64_t v5 = v13;
    }
    while (v13 != (void *)(a1[2] + 24));
  }
  uint64_t v15 = a1[1];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] ]", buf, 2u);
  }
}

void *sub_1009C8728(void *a1)
{
  *a1 = off_101A24998;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_1009C877C(void *a1)
{
  *a1 = off_101A24998;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_1009C87F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A24A10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009C8810(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A24A10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1009C886C(unint64_t a1)
{
  if (a1 >> 60) {
    sub_10006A7CC();
  }
  return operator new(16 * a1);
}

void sub_1009C88A4(void ***a1)
{
  unsigned __int16 v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        float32x2_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6) {
          sub_10004D2C8(v6);
        }
        v4 -= 24;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1009C8930(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009C8968(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009C8998(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

const char *sub_1009C89DC(int a1)
{
  if ((a1 - 1) > 2) {
    return "msg.sms.ctr.?";
  }
  else {
    return off_101A28DA0[a1 - 1];
  }
}

void *sub_1009C8A04(uint64_t a1)
{
  sub_10026CF54(a1 + 32, *(void **)(a1 + 40));

  return sub_1009ED094((void *)a1);
}

void sub_1009C8A44(uint64_t a1, unsigned int a2)
{
  unsigned int v25 = a2;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (*(void *)(a1 + 2624)
    && (*(void *)long long buf = &v25,
        *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v25, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270)))
  {
    uint64_t v4 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Emergency Sms is pending.", buf, 2u);
    }
    uint64_t v5 = *(void *)(a1 + 112);
    if (v5 && (*(unsigned int (**)(uint64_t, void))(*(void *)v5 + 40))(v5, v25))
    {
      *(void *)long long buf = &v25;
      float32x2_t v6 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v25, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
      uint64_t v8 = *(void *)(a1 + 112);
      uint64_t v7 = *(void *)(a1 + 120);
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      double v9 = (std::__shared_weak_count *)v6[4];
      void v6[3] = v8;
      v6[4] = v7;
      if (v9) {
        sub_10004D2C8(v9);
      }
      double v10 = *v3;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v11 = "#I Using Baseband Command Driver";
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
      }
    }
    else
    {
      *(void *)long long buf = &v25;
      BOOL v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v25, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v13 = *(void *)(a1 + 136);
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v15 = (std::__shared_weak_count *)v12[4];
      v12[3] = v14;
      v12[4] = v13;
      if (v15) {
        sub_10004D2C8(v15);
      }
      double v10 = *v3;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v11 = "#I Using IMS Command Driver";
        goto LABEL_36;
      }
    }
  }
  else if (sub_1009C8DB8(a1))
  {
    *(void *)long long buf = &v25;
    unsigned int v16 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v25, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
    uint64_t v18 = *(void *)(a1 + 128);
    uint64_t v17 = *(void *)(a1 + 136);
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    double v19 = (std::__shared_weak_count *)v16[4];
    uint64_t v16[3] = v18;
    int v16[4] = v17;
    if (v19) {
      sub_10004D2C8(v19);
    }
    double v10 = *v3;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I Using IMS Command Driver";
      goto LABEL_36;
    }
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 112);
    if (!v20 || !(*(unsigned int (**)(uint64_t, void))(*(void *)v20 + 40))(v20, v25))
    {
      double v10 = *v3;
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I Active Command Driver not set!";
      goto LABEL_36;
    }
    *(void *)long long buf = &v25;
    uint64_t v21 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v25, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
    uint64_t v23 = *(void *)(a1 + 112);
    uint64_t v22 = *(void *)(a1 + 120);
    if (v22) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v24 = (std::__shared_weak_count *)v21[4];
    void v21[3] = v23;
    void v21[4] = v22;
    if (v24) {
      sub_10004D2C8(v24);
    }
    double v10 = *v3;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I Using Baseband Command Driver";
      goto LABEL_36;
    }
  }
}

uint64_t sub_1009C8DB8(uint64_t a1)
{
  if (!subscriber::isValidSimSlot()) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 40);

  return v3();
}

uint64_t sub_1009C8E34(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x10uLL);
  uint64_t v23 = v4 + 2;
  uint64_t v24 = v4 + 2;
  *uint64_t v4 = @"SMSSettings";
  v4[1] = @"UseWifiForEmergencyText";
  std::string __p = v4;
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 80));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    double v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v14 = v13[3];
    uint64_t v15 = (std::__shared_weak_count *)v13[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v16 = 1;
  if (!v14)
  {
LABEL_7:
    uint64_t v17 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Invalid carrier interface", buf, 2u);
    }
    LODWORD(v18) = 0;
    if (v16) {
      goto LABEL_19;
    }
LABEL_18:
    sub_10004D2C8(v15);
    goto LABEL_19;
  }
LABEL_13:
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, void **, const CFBooleanRef, void))(*(void *)v14 + 104))(buf, v14, a2, 1, &__p, kCFBooleanFalse, 0);
  uint64_t v18 = *(BOOL **)buf;
  char v25 = 0;
  if (*(void *)buf)
  {
    CFTypeID v19 = CFGetTypeID(*(CFTypeRef *)buf);
    if (v19 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v25, v18, v20);
      LODWORD(v18) = v25 != 0;
    }
    else
    {
      LODWORD(v18) = 0;
    }
  }
  sub_1000577C4((const void **)buf);
  if ((v16 & 1) == 0) {
    goto LABEL_18;
  }
LABEL_19:
  if (__p)
  {
    uint64_t v23 = __p;
    operator delete(__p);
  }
  if (v14) {
    return v18;
  }
  else {
    return 1;
  }
}

void sub_1009C906C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009C90B4(void *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4)
{
  if (!a3) {
    goto LABEL_14;
  }
  if (*(unsigned char *)(a3 + 149))
  {
    if (a4) {
      atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(unsigned int *)(a3 + 8);
    int v15 = *(_DWORD *)(a3 + 8);
    if (*(_DWORD *)(a3 + 36) == 2 && *(_DWORD *)(a3 + 40) == 2) {
      goto LABEL_23;
    }
    int v9 = sub_1009C8E34(a2, v8);
    if (*(_DWORD *)(a3 + 36) == 2)
    {
      int v10 = *(_DWORD *)(a3 + 40);
      if (v9)
      {
        if (v10 == 2) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      if (v10 == 2)
      {
        char v16 = &v15;
        if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a2 + 2544), &v15, (uint64_t)&unk_10144E20E, &v16)[5] + 270)) {
          goto LABEL_23;
        }
      }
    }
    else if (v9)
    {
      goto LABEL_22;
    }
    char v16 = &v15;
    if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a2 + 2544), &v15, (uint64_t)&unk_10144E20E, &v16)[5] + 261))
    {
LABEL_23:
      uint64_t v14 = *(void *)(a2 + 128);
      uint64_t v13 = *(void *)(a2 + 136);
      goto LABEL_24;
    }
LABEL_22:
    uint64_t v14 = *(void *)(a2 + 112);
    uint64_t v13 = *(void *)(a2 + 120);
LABEL_24:
    *a1 = v14;
    a1[1] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    if (a4)
    {
      sub_10004D2C8(a4);
    }
    return;
  }
  if (*(_DWORD *)(a3 + 36) == 2 && *(_DWORD *)(a3 + 40) == 2)
  {
    uint64_t v12 = *(void *)(a2 + 128);
    uint64_t v11 = *(void *)(a2 + 136);
  }
  else
  {
LABEL_14:
    uint64_t v12 = *(void *)(a2 + 112);
    uint64_t v11 = *(void *)(a2 + 120);
  }
  *a1 = v12;
  a1[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1009C9248(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sms::Controller::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1009C9BE8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ctu::OsLogLogger *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  sub_10008863C((void *)(v25 - 128));
  operator delete();
}

void sub_1009C9C14()
{
  unsigned __int16 v1 = *(std::__shared_weak_count **)(v0 - 120);
  if (v1) {
    sub_10004D2C8(v1);
  }
  JUMPOUT(0x1009CA024);
}

void sub_1009C9C98(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_1009ED824);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1009C9CCC()
{
}

void sub_1009C9CDC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1009C9CEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, atomic_uint **a16, ctu::OsLogLogger *a17, void *a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,void **a24)
{
  sub_1000346F8(v28, *(void **)(v24 + 2440));
  sub_1009C8A04(v24 + 2376);
  EmergencyMode::~EmergencyMode(v26);
  sub_100703778(v24 + 2328, *(char **)(v24 + 2336));
  sub_1000346F8(v24 + 2304, *(void **)(v24 + 2312));
  sub_1000886C0(v24 + 2272, *(char **)(v24 + 2280));
  sub_100417F2C(v24 + 2216);
  sub_100417F2C(v24 + 2160);
  sub_100417F2C(v24 + 2104);
  sub_1000346F8(a9, *(void **)(v24 + 2088));
  sub_100136194(a10);
  sub_100136194(a11);
  sub_10003FB28(a13, *(void **)(v24 + 464));
  sub_100087ED0(v24 + 432, *(void **)(v24 + 440));
  sub_1000886C0(v24 + 408, *(char **)(v24 + 416));
  a24 = (void **)(v24 + 384);
  sub_10008A88C(&a24);
  sub_100087F94(v24 + 360, *(void **)(v24 + 368));
  sub_100087F94(v24 + 336, *(void **)(v24 + 344));
  sub_1000346F8(v24 + 312, *(void **)(v24 + 320));
  sub_1000346F8(v24 + 288, *(void **)(v24 + 296));
  sub_1000346F8(a14, *(void **)(v24 + 272));
  sub_1000346F8(a15, *(void **)(v24 + 240));
  sub_10005CD2C(v27, *(char **)(v24 + 216));
  if (*(char *)(v24 + 199) < 0) {
    operator delete(*a12);
  }
  BOOL v29 = *(std::__shared_weak_count **)(v24 + 152);
  if (v29) {
    sub_10004D2C8(v29);
  }
  double v30 = *(std::__shared_weak_count **)(v24 + 136);
  if (v30) {
    sub_10004D2C8(v30);
  }
  __int16 v31 = *(std::__shared_weak_count **)(v24 + 120);
  if (v31) {
    sub_10004D2C8(v31);
  }
  unint64_t v32 = *(std::__shared_weak_count **)(v24 + 104);
  if (v32) {
    sub_10004D2C8(v32);
  }
  int v33 = *(std::__shared_weak_count **)(v24 + 88);
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_100160A84(a16);
  uint64_t v34 = *(void *)(v24 + 48);
  *(void *)(v24 + 48) = 0;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
  }
  SmsControllerInterface::~SmsControllerInterface((SmsControllerInterface *)v24);
  ctu::OsLogLogger::~OsLogLogger(a17);
  sub_100087E88(a18);
  if (a21)
  {
    sub_10004D2C8(a21);
    if (!v25) {
LABEL_20:
    }
      operator delete();
  }
  else if (!v25)
  {
    goto LABEL_20;
  }
  dispatch_release(v25);
  goto LABEL_20;
}

void sub_1009C9CF4()
{
}

void sub_1009C9CFC()
{
}

void sub_1009C9D04()
{
}

void sub_1009C9D0C()
{
}

void sub_1009C9D14()
{
}

void sub_1009C9D1C()
{
}

void sub_1009C9D24()
{
}

void sub_1009C9D2C()
{
}

void sub_1009C9D34(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object,dispatch_object_t a23)
{
  if (object) {
    dispatch_release(object);
  }
  if (a23) {
    dispatch_release(a23);
  }
  if (*(char *)(v23 - 105) < 0) {
    operator delete(*(void **)(v23 - 128));
  }
  JUMPOUT(0x1009C9F48);
}

void sub_1009C9D64()
{
}

void sub_1009C9DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v18 - 128));
  if (v16) {
    dispatch_release(v16);
  }
  JUMPOUT(0x1009C9FC8);
}

void sub_1009C9DE8()
{
  sub_1000346F8(v1, *(void **)(v0 + 2488));
  sub_1000346F8(v2, *(void **)(v0 + 2464));
  JUMPOUT(0x1009C9E04);
}

void sub_1009CA020()
{
  sub_10004D2C8(v0);
  JUMPOUT(0x1009CA02CLL);
}

void sub_1009CA034(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_1009CA12C(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  unsigned int v10 = a2;
  v9[0] = a1;
  v9[1] = &v10;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      uint64_t v5 = v10;
      block[0] = &v10;
      float32x2_t v6 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v10, (uint64_t)&unk_10144E20E, block);
      sub_1009CAE18(a3, a1, v5, *((_DWORD *)v6[5] + 55));
      return;
    }
    BOOL v7 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  dispatch_object_t v11[2] = sub_1009EE550;
  void v11[3] = &unk_101A25200;
  v11[4] = a1 + 8;
  void v11[5] = v9;
  uint64_t v12 = v11;
  uint64_t v8 = *(NSObject **)(a1 + 24);
  *a3 = 0;
  a3[1] = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = (_DWORD *)0x40000000;
  if (v7)
  {
    uint64_t v14 = sub_1009EE5C0;
    int v15 = &unk_101A25220;
    char v16 = a3;
    uint64_t v17 = &v12;
    dispatch_sync(v8, block);
  }
  else
  {
    uint64_t v14 = sub_1009EE628;
    int v15 = &unk_101A25240;
    char v16 = a3;
    uint64_t v17 = &v12;
    dispatch_async_and_wait(v8, block);
  }
}

uint64_t sub_1009CA2D8@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  int v22 = a2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 80));
  float32x2_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v23 = (int *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v23);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_22;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  char v3 = (_BYTE)v12 + 8;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13) {
    goto LABEL_22;
  }
LABEL_10:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13)) {
    goto LABEL_22;
  }
  uint64_t v15 = *(void *)(a1 + 344);
  if (!v15) {
    goto LABEL_22;
  }
  uint64_t v16 = a1 + 344;
  do
  {
    int v17 = *(_DWORD *)(v15 + 32);
    BOOL v18 = v17 < v22;
    if (v17 >= v22) {
      CFTypeID v19 = (uint64_t *)v15;
    }
    else {
      CFTypeID v19 = (uint64_t *)(v15 + 8);
    }
    if (!v18) {
      uint64_t v16 = v15;
    }
    uint64_t v15 = *v19;
  }
  while (*v19);
  if (v16 == a1 + 344 || v22 < *(_DWORD *)(v16 + 32) || *(unsigned char *)(v16 + 41) == 2)
  {
LABEL_22:
    int v20 = 1;
    if (v14) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  int v20 = 0;
  char v3 = *(unsigned char *)(a1 + 2720) != 0;
  if ((v14 & 1) == 0) {
LABEL_23:
  }
    sub_10004D2C8(v12);
LABEL_24:
  if (v20)
  {
    uint64_t v23 = &v22;
    char v3 = *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v22, (uint64_t)&unk_10144E20E, &v23)[5] + 40) != 0;
  }
  return v3 & 1;
}

void sub_1009CA494(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009CA4B0(uint64_t a1, unsigned int a2)
{
  unsigned int v22 = a2;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    if (sub_1009CA780((uint64_t **)a1, a2)) {
      return 1;
    }
    *(void *)long long buf = &v22;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 41)) {
      BOOL v5 = *(_DWORD *)(a1 + 2360) != 3;
    }
    else {
      BOOL v5 = 0;
    }
    float32x2_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v22);
    uint64_t v7 = v6;
    int v8 = *(unsigned __int8 *)(a1 + 200);
    if (*(unsigned char *)(a1 + 200) || *(unsigned char *)(a1 + 260))
    {
      os_log_t v9 = *v6;
      uint64_t result = os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v20 = "true";
      if (v8) {
        uint64_t v21 = "true";
      }
      else {
        uint64_t v21 = "false";
      }
      if (!*(unsigned char *)(a1 + 260)) {
        int v20 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      __int16 v24 = 2080;
      uint64_t v25 = v20;
      int v17 = "Cannot compose SMS [airplane: %s, in-reset: %s]";
      BOOL v18 = v9;
      uint32_t v19 = 22;
LABEL_33:
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
      return 0;
    }
    if (sub_100529568())
    {
      unsigned int v10 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SMS composition during lockdown", buf, 2u);
      }
      return 1;
    }
    if (!v5)
    {
      *(void *)long long buf = &v22;
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
           + 269))
        return 1;
    }
    uint64_t v11 = *v7;
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(void *)long long buf = &v22;
      uint64_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      if (*((unsigned char *)v12[5] + 269)) {
        uint64_t v13 = "true";
      }
      else {
        uint64_t v13 = "false";
      }
      if (v5) {
        char v14 = "true";
      }
      else {
        char v14 = "false";
      }
      int v15 = sub_1009CA2D8(a1, v22, (uint64_t *)*((unsigned __int8 *)v12[5] + 269));
      *(_DWORD *)long long buf = 136315650;
      if (v15) {
        uint64_t v16 = "true";
      }
      else {
        uint64_t v16 = "false";
      }
      *(void *)&uint8_t buf[4] = v13;
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      __int16 v26 = 2080;
      uint64_t v27 = v16;
      int v17 = "Cannot compose SMS [ready: %s, ecbm for text: %s, bb activated: %s]";
      BOOL v18 = v11;
      uint32_t v19 = 32;
      goto LABEL_33;
    }
  }
  return result;
}

uint64_t sub_1009CA780(uint64_t **a1, unsigned int a2)
{
  unsigned int v6 = a2;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v7 = &v6;
    if (*((unsigned char *)sub_1001B0B78(a1 + 318, (int *)&v6, (uint64_t)&unk_10144E20E, &v7)[5] + 41)) {
      return 0;
    }
    uint64_t v7 = &v6;
    uint64_t v4 = sub_1001B0B78(a1 + 318, (int *)&v6, (uint64_t)&unk_10144E20E, &v7);
    if (!*((unsigned char *)v4[5] + 42))
    {
      return 0;
    }
    else if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v4) {
           && ((unsigned int (*)(uint64_t **, void))(*a1)[53])(a1, v6))
    }
    {
      return sub_1009CA2D8((uint64_t)a1, v6, v5);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void sub_1009CA87C(uint64_t a1, unsigned int a2)
{
  unsigned int v72 = a2;
  char v3 = (Registry **)(a1 + 80);
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *v3);
  unsigned int v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&__p);
  if (!v11)
  {
    uint64_t v12 = 0;
    goto LABEL_9;
  }
  uint64_t v12 = v11[3];
  uint64_t v13 = (std::__shared_weak_count *)v11[4];
  if (!v13)
  {
LABEL_9:
    std::mutex::unlock(v6);
    uint64_t v66 = 0;
    char v14 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v66 = v13;
  sub_10004D2C8(v13);
  char v14 = 0;
LABEL_10:
  int v15 = (uint64_t **)(a1 + 2544);
  std::string __p = &v72;
  uint64_t v16 = sub_1001B0B78(v15, (int *)&v72, (uint64_t)&unk_10144E20E, (_DWORD **)&__p);
  v16[5][44] = v16[5][43];
  int v17 = operator new(0x18uLL);
  char v67 = v14;
  unint64_t v70 = v17 + 3;
  uint64_t v71 = (char *)(v17 + 3);
  *(_OWORD *)int v17 = *(_OWORD *)off_1019C4430;
  uint64_t v17[2] = @"SMSCPreferenceOrder";
  CFArrayRef theArray = 0;
  std::string __p = v17;
  (*(void (**)(unsigned int **__return_ptr, uint64_t, void, uint64_t, void **, void, void))(*(void *)v12 + 104))(&v73, v12, v72, 1, &__p, 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)&v73);
  sub_1000577C4((const void **)&v73);
  if (theArray) {
    BOOL v18 = sub_100083F10;
  }
  else {
    BOOL v18 = 0;
  }
  if (v18)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        unsigned int v22 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v23 = CFGetTypeID(ValueAtIndex);
          if (v23 == CFStringGetTypeID())
          {
            if (CFEqual(v22, @"PSI_SMSC"))
            {
              uint64_t v73 = &v72;
              __int16 v24 = sub_1001B0B78(v15, (int *)&v72, (uint64_t)&unk_10144E20E, &v73)[5];
              __int16 v26 = (unsigned char *)v24[44];
              unint64_t v25 = v24[45];
              if ((unint64_t)v26 >= v25)
              {
                unint64_t v28 = v24[43];
                BOOL v29 = &v26[-v28];
                uint64_t v30 = (uint64_t)&v26[-v28 + 1];
                if (v30 < 0) {
                  sub_10006A748();
                }
                unint64_t v31 = v25 - v28;
                if (2 * v31 > v30) {
                  uint64_t v30 = 2 * v31;
                }
                if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v32 = v30;
                }
                if (v32) {
                  int v33 = (char *)operator new(v32);
                }
                else {
                  int v33 = 0;
                }
                uint64_t v34 = &v29[(void)v33];
                uint64_t v35 = &v29[(void)v33];
                unsigned char *v35 = 0;
                uint64_t v27 = v35 + 1;
                if (v26 != (unsigned char *)v28)
                {
                  uint64_t v36 = &v26[~v28];
                  do
                  {
                    char v37 = *--v26;
                    (v36--)[(void)v33] = v37;
                  }
                  while (v26 != (unsigned char *)v28);
                  uint64_t v34 = v33;
                }
                v24[43] = (uint64_t)v34;
                v24[44] = (uint64_t)v27;
                v24[45] = (uint64_t)&v33[v32];
                if (v28) {
                  operator delete((void *)v28);
                }
              }
              else
              {
                *__int16 v26 = 0;
                uint64_t v27 = v26 + 1;
              }
              v24[44] = (uint64_t)v27;
            }
            if (CFEqual(v22, @"SMSC"))
            {
              uint64_t v73 = &v72;
              long long v38 = sub_1001B0B78(v15, (int *)&v72, (uint64_t)&unk_10144E20E, &v73)[5];
              uint64_t v40 = (unsigned char *)v38[44];
              unint64_t v39 = v38[45];
              if ((unint64_t)v40 >= v39)
              {
                unint64_t v42 = v38[43];
                uint64_t v43 = &v40[-v42];
                uint64_t v44 = (uint64_t)&v40[-v42 + 1];
                if (v44 < 0) {
                  sub_10006A748();
                }
                unint64_t v45 = v39 - v42;
                if (2 * v45 > v44) {
                  uint64_t v44 = 2 * v45;
                }
                if (v45 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v46 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v46 = v44;
                }
                if (v46) {
                  uint64_t v47 = (char *)operator new(v46);
                }
                else {
                  uint64_t v47 = 0;
                }
                int v48 = &v43[(void)v47];
                long long v49 = &v43[(void)v47];
                *long long v49 = 1;
                uint64_t v41 = v49 + 1;
                if (v40 != (unsigned char *)v42)
                {
                  uint64_t v50 = &v40[~v42];
                  do
                  {
                    char v51 = *--v40;
                    (v50--)[(void)v47] = v51;
                  }
                  while (v40 != (unsigned char *)v42);
                  int v48 = v47;
                }
                v38[43] = (uint64_t)v48;
                v38[44] = (uint64_t)v41;
                v38[45] = (uint64_t)&v47[v46];
                if (v42) {
                  operator delete((void *)v42);
                }
              }
              else
              {
                *uint64_t v40 = 1;
                uint64_t v41 = v40 + 1;
              }
              v38[44] = (uint64_t)v41;
            }
            if (CFEqual(v22, @"CarrierBundle"))
            {
              uint64_t v73 = &v72;
              uint64_t v52 = sub_1001B0B78(v15, (int *)&v72, (uint64_t)&unk_10144E20E, &v73)[5];
              int64x2_t v54 = (unsigned char *)v52[44];
              unint64_t v53 = v52[45];
              if ((unint64_t)v54 >= v53)
              {
                unint64_t v56 = v52[43];
                int v57 = &v54[-v56];
                uint64_t v58 = (uint64_t)&v54[-v56 + 1];
                if (v58 < 0) {
                  sub_10006A748();
                }
                unint64_t v59 = v53 - v56;
                if (2 * v59 > v58) {
                  uint64_t v58 = 2 * v59;
                }
                if (v59 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v60 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v60 = v58;
                }
                if (v60) {
                  unint64_t v61 = (char *)operator new(v60);
                }
                else {
                  unint64_t v61 = 0;
                }
                uint64_t v62 = &v57[(void)v61];
                uint64_t v63 = &v57[(void)v61];
                unsigned char *v63 = 2;
                uint64_t v55 = v63 + 1;
                if (v54 != (unsigned char *)v56)
                {
                  xpc_object_t v64 = &v54[~v56];
                  do
                  {
                    char v65 = *--v54;
                    (v64--)[(void)v61] = v65;
                  }
                  while (v54 != (unsigned char *)v56);
                  uint64_t v62 = v61;
                }
                v52[43] = (uint64_t)v62;
                v52[44] = (uint64_t)v55;
                v52[45] = (uint64_t)&v61[v60];
                if (v56) {
                  operator delete((void *)v56);
                }
              }
              else
              {
                unsigned char *v54 = 2;
                uint64_t v55 = v54 + 1;
              }
              v52[44] = (uint64_t)v55;
            }
          }
        }
      }
    }
  }
  sub_100044D00((const void **)&theArray);
  if (__p)
  {
    unint64_t v70 = __p;
    operator delete(__p);
  }
  if ((v67 & 1) == 0) {
    sub_10004D2C8(v66);
  }
}

void sub_1009CAD9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, char a11, const void *a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1009CAE18(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v5 = a3;
  int v40 = a3;
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  *a1 = 0;
  a1[1] = 0;
  if (sub_1009CA4B0(a2, v5))
  {
    if (a4 == 1)
    {
      uint64_t v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Composing SMS message using GsmModel", buf, 2u);
      }
      operator new();
    }
    if (a4 == 2)
    {
      uint64_t v9 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Composing SMS message using C2KModel", buf, 2u);
      }
      operator new();
    }
    uint64_t v12 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = sms::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid encoder :- %s", buf, 0xCu);
    }
    uint64_t v13 = (_DWORD *)*a1;
    if (*a1)
    {
      char v14 = (std::__shared_weak_count *)a1[1];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LODWORD(v41) = v13[2];
      if (subscriber::isValidSimSlot())
      {
        int v15 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), v41);
        *(void *)long long buf = &v41;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a2 + 2544), (int *)&v41, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 42))
        {
          if ((sub_1009DBCA8(a2, v41) & 1) == 0)
          {
            v13[9] = 2;
            *(void *)long long buf = &v41;
            uint64_t v16 = sub_1001B0B78((uint64_t **)(a2 + 2544), (int *)&v41, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][3];
            uint64_t v17 = *(void *)(a2 + 128);
            int v18 = v16 == v17 ? 2 : 1;
            v13[10] = v18;
            uint32_t v19 = *v15;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              int v20 = "IMS over Baseband";
              if (v16 == v17) {
                int v20 = "IMS over AP";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = "IMS Transport";
              __int16 v46 = 2080;
              uint64_t v47 = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I SMS Transport Type:%s, Transport Mode:%s", buf, 0x16u);
            }
          }
        }
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
      uint64_t v21 = (_DWORD *)*a1;
      if (*a1)
      {
        if (v21[9] == 2)
        {
          unsigned int v22 = (uint64_t *)v21[10];
          if (v22 == 2)
          {
            ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)(a2 + 80));
            __int16 v24 = ServiceMap;
            if (v25 < 0)
            {
              __int16 v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v27 = 5381;
              do
              {
                uint64_t v25 = v27;
                unsigned int v28 = *v26++;
                uint64_t v27 = (33 * v27) ^ v28;
              }
              while (v28);
            }
            std::mutex::lock(ServiceMap);
            *(void *)long long buf = v25;
            BOOL v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
            if (!v29)
            {
              std::mutex::unlock(v24);
              return;
            }
            uint64_t v31 = v29[3];
            uint64_t v30 = (std::__shared_weak_count *)v29[4];
            if (v30)
            {
              atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v24);
              atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v30);
              if (!v31)
              {
                size_t v32 = v30;
LABEL_62:
                sub_10004D2C8(v32);
                return;
              }
            }
            else
            {
              std::mutex::unlock(v24);
              if (!v31) {
                return;
              }
            }
            PersonalityIdFromSlotId();
            (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v31 + 40))(&v41, v31, buf);
            (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v41 + 40))(&cf);
            uint64_t v34 = (BOOL *)cf;
            char v44 = 0;
            if (cf)
            {
              CFTypeID v35 = CFGetTypeID(cf);
              if (v35 == CFBooleanGetTypeID())
              {
                ctu::cf::assign((ctu::cf *)&v44, v34, v36);
                LODWORD(v34) = v44 != 0;
              }
              else
              {
                LODWORD(v34) = 0;
              }
            }
            sub_1000577C4(&cf);
            if (v42) {
              sub_10004D2C8(v42);
            }
            if (v48 < 0) {
              operator delete(*(void **)buf);
            }
            if (v30)
            {
              sub_10004D2C8(v30);
              if ((v34 & 1) == 0) {
                return;
              }
            }
            else if (!v34)
            {
              return;
            }
            char v37 = *v8;
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I IMS/AP Test Mode enabled - Attempt SMS over CS", buf, 2u);
            }
            *(void *)long long buf = &v40;
            if (*((_DWORD *)sub_1001B0B78((uint64_t **)(a2 + 2544), &v40, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                 + 66) == 7)
            {
              long long v38 = *(NSObject **)(a2 + 40);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "IMS/AP Test Mode & LTE cannot co-exist. Fail SMS", buf, 2u);
              }
              size_t v32 = (std::__shared_weak_count *)a1[1];
              *a1 = 0;
              a1[1] = 0;
              if (v32) {
                goto LABEL_62;
              }
            }
            else
            {
              unint64_t v39 = (_DWORD *)*a1;
              v39[9] = 0;
              v39[10] = 0;
            }
          }
        }
      }
    }
    else
    {
      int v33 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid message shared_ptr, exiting", buf, 2u);
      }
    }
  }
  else
  {
    unsigned int v10 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MO-SMS not allowed", buf, 2u);
    }
  }
}

void sub_1009CB5C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v22 + 8);
  if (v25) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009CB68C(uint64_t a1, uint64_t a2)
{
  sub_1009EE690(&v2, a2);
}

void sub_1009CB6D4(uint64_t a1, uint64_t a2)
{
  sub_1009EE7E0(&v2, a2);
}

void sub_1009CB71C(uint64_t a1, uint64_t a2)
{
  unsigned int v36 = a2;
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 80));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_9;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_10:
  if (v14)
  {
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v14 + 96))(&cf, v14, v36, 1, @"EnableSMSReplyAddress", kCFBooleanFalse, 0);
    uint64_t v16 = (BOOL *)cf;
    buf[0] = 0;
    if (cf)
    {
      CFTypeID v17 = CFGetTypeID(cf);
      if (v17 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, v16, v18);
      }
    }
    uint8_t v19 = buf[0];
    *(void *)long long buf = &v36;
    *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v36, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 72) = v19;
    sub_1000577C4(&cf);
  }
  else
  {
    int v20 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get carrierSettings, userReplyAddress set to false.", buf, 2u);
    }
    *(void *)long long buf = &v36;
    *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v36, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 72) = 0;
  }
  uint64_t v21 = *v4;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef cf = &v36;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v36, (uint64_t)&unk_10144E20E, (_DWORD **)&cf)[5] + 72)) {
      uint64_t v22 = "";
    }
    else {
      uint64_t v22 = " not";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Carrier does%s use Reply Address", buf, 0xCu);
  }
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v14 + 96))(&cf, v14, v36, 1, @"EnableSMSReplyAddress", kCFBooleanFalse, 0);
  CFTypeID v23 = (BOOL *)cf;
  buf[0] = 0;
  if (cf)
  {
    CFTypeID v24 = CFGetTypeID(cf);
    if (v24 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v23, v25);
      LOBYTE(v23) = buf[0];
    }
    else
    {
      LOBYTE(v23) = 0;
    }
  }
  __int16 v26 = (uint64_t **)(a1 + 2544);
  *(void *)long long buf = &v36;
  *((unsigned char *)sub_1001B0B78(v26, (int *)&v36, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 72) = (_BYTE)v23;
  sub_1000577C4(&cf);
  uint64_t v27 = operator new(0x10uLL);
  CFTypeRef v34 = v27 + 2;
  CFTypeID v35 = v27 + 2;
  *uint64_t v27 = @"com.apple.voicemail.imap";
  v27[1] = @"BeaconServiceCenter";
  CFTypeRef cf = v27;
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, CFTypeRef *, void, void))(*(void *)v14 + 104))(&v32, v14, v36, 1, &cf, 0, 0);
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  uint64_t v28 = *(void *)buf;
  v37[0] = *(void *)&buf[8];
  *(void *)((char *)v37 + 7) = *(void *)&buf[15];
  uint8_t v29 = buf[23];
  *(void *)long long buf = &v36;
  uint64_t v30 = sub_1001B0B78(v26, (int *)&v36, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
  if (*((char *)v30 + 391) < 0) {
    operator delete((void *)v30[46]);
  }
  uint64_t v31 = v37[0];
  v30[46] = v28;
  v30[47] = v31;
  *(uint64_t *)((char *)v30 + 383) = *(void *)((char *)v37 + 7);
  *((unsigned char *)v30 + 391) = v29;
  sub_1000577C4(&v32);
  if (cf)
  {
    CFTypeRef v34 = cf;
    operator delete((void *)cf);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1009CBBD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009CBC68(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1009CBD7C;
  v4[3] = &unk_101A24CC0;
  unsigned char v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  char v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_1009CBD7C(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 168) = *(unsigned char *)(result + 40);
  return result;
}

void sub_1009CBD8C(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1009CBEA0;
  v4[3] = &unk_101A24CE0;
  unsigned char v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  char v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_1009CBEA0(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 160) = *(unsigned char *)(result + 40);
  return result;
}

BOOL sub_1009CBEB0(uint64_t a1)
{
  uint64_t v6 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v2 = *(unsigned __int8 *)(a1 + 160);
      return v2 != 0;
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  _OWORD v7[2] = sub_1009EE96C;
  void v7[3] = &unk_101A25388;
  v7[4] = a1 + 8;
  v7[5] = &v6;
  uint64_t v8 = v7;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  unsigned __int8 v14 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v3)
  {
    uint64_t v10 = sub_10005A304;
    unsigned int v11 = &unk_101A253A8;
    uint64_t v12 = &v14;
    uint64_t v13 = &v8;
    dispatch_sync(v4, block);
  }
  else
  {
    uint64_t v10 = sub_10005B068;
    unsigned int v11 = &unk_101A253C8;
    uint64_t v12 = &v14;
    uint64_t v13 = &v8;
    dispatch_async_and_wait(v4, block);
  }
  int v2 = v14;
  return v2 != 0;
}

uint64_t **sub_1009CC01C(uint64_t a1, uint64_t a2)
{
  int v7 = a2;
  int v3 = sub_100795740(a2, (Registry **)(a1 + 80));
  if (v3 <= 520)
  {
    if (v3 == 513)
    {
      uint64_t v8 = &v7;
      uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
      char v5 = result + 5;
      int v6 = 3;
      goto LABEL_12;
    }
    if (v3 == 519)
    {
      uint64_t v8 = &v7;
      uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
      char v5 = result + 5;
      int v6 = 6;
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v8 = &v7;
    uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
    char v5 = result + 5;
    int v6 = 8;
    goto LABEL_12;
  }
  if (v3 == 521)
  {
    uint64_t v8 = &v7;
    uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
    char v5 = result + 5;
    int v6 = 5;
    goto LABEL_12;
  }
  if (v3 != 2368 && v3 != 1058) {
    goto LABEL_11;
  }
  uint64_t v8 = &v7;
  uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
  char v5 = result + 5;
  int v6 = 2;
LABEL_12:
  *((_DWORD *)*v5 + 11) = v6;
  return result;
}

void sub_1009CC17C(uint64_t a1, char a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1009CC294;
  v5[3] = &unk_101A24D00;
  uint64_t v5[4] = a1;
  int v6 = a3;
  char v7 = a2;
  uint64_t v10 = 0;
  unsigned int v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_1009CC294(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(unsigned char *)(a1 + 44);
  int v4 = *(_DWORD *)(a1 + 40);
  char v5 = &v4;
  *((unsigned char *)sub_1001B0B78((uint64_t **)(v2 + 2544), &v4, (uint64_t)&unk_10144E20E, &v5)[5] + 260) = v3;
  sub_1009CC30C(v2, *(_DWORD *)(a1 + 40));
}

void sub_1009CC30C(uint64_t a1, unsigned int a2)
{
  unsigned int v10 = a2;
  if (subscriber::isValidSimSlot())
  {
    char v3 = (uint64_t **)(a1 + 2544);
    *(void *)long long buf = &v10;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261) == 1)
    {
      BOOL v4 = 1;
    }
    else
    {
      *(void *)long long buf = &v10;
      BOOL v4 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]+ 261) == 3;
    }
    char v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v10);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v4) {
        int v6 = "";
      }
      else {
        int v6 = "not ";
      }
      *(void *)long long buf = &v10;
      if (*((unsigned char *)sub_1001B0B78(v3, (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 260)) {
        char v7 = "";
      }
      else {
        char v7 = "not ";
      }
      *(void *)long long buf = &v10;
      if (sub_1001B0B78(v3, (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][3]) {
        uint64_t v8 = "not ";
      }
      else {
        uint64_t v8 = "";
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v12 = 2080;
      uint64_t v13 = v7;
      __int16 v14 = 2080;
      char v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I SMS is %sready, Reading SMS from sim is %senabled, fTransport is %snull", buf, 0x20u);
    }
    if (v4)
    {
      *(void *)long long buf = &v10;
      if (*((unsigned char *)sub_1001B0B78(v3, (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 260))
      {
        *(void *)long long buf = &v10;
        if (sub_1001B0B78(v3, (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][3])
        {
          *(void *)long long buf = &v10;
          uint64_t v9 = sub_1001B0B78(v3, (int *)&v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v9[5][3] + 72))(v9[5][3], v10, 1);
        }
      }
    }
  }
}

uint64_t sub_1009CC5BC(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  unsigned int v10 = a4;
  unsigned int v11 = a2;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = a3;
  v9[3] = &v10;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      uint64_t result = subscriber::isValidSimSlot();
      if (result) {
        return sub_1009CD4A8(a1, v11, a3, v10);
      }
      return result;
    }
    BOOL v7 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1009EE97C;
  v12[3] = &unk_101A253E8;
  v12[4] = a1 + 8;
  v12[5] = v9;
  uint64_t v13 = v12;
  uint64_t v8 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v7)
  {
    char v15 = sub_10005A304;
    uint64_t v16 = &unk_101A253A8;
    CFTypeID v17 = &v19;
    CFBooleanRef v18 = &v13;
    dispatch_sync(v8, block);
  }
  else
  {
    char v15 = sub_10005B068;
    uint64_t v16 = &unk_101A253C8;
    CFTypeID v17 = &v19;
    CFBooleanRef v18 = &v13;
    dispatch_async_and_wait(v8, block);
  }
  return v19 != 0;
}

void sub_1009CC75C(uint64_t a1, int a2, uint64_t a3)
{
  unsigned char v4[4] = a1;
  int v5 = a2;
  sub_1009EE9E0((uint64_t)v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_1009CC8F0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1009CC910(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v14 = a2;
  if (*(void *)(a3 + 24))
  {
    if (subscriber::isValidSimSlot())
    {
      *(void *)long long buf = &v14;
      int v6 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v14, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      sub_10082FE4C((uint64_t)v6[5], v11);
      sub_1009CCADC(*(void *)(a3 + 24), (uint64_t)v11, 0);
      BOOL v7 = (char *)v11[1];
      uint64_t v8 = v11;
    }
    else
    {
      unsigned int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid slot while reading Emergency Address...", buf, 2u);
      }
      v13[0] = 0;
      v13[1] = 0;
      __int16 v12 = v13;
      sub_1009CCADC(*(void *)(a3 + 24), (uint64_t)&v12, 0x1600000001);
      BOOL v7 = (char *)v13[0];
      uint64_t v8 = (uint64_t *)&v12;
    }
    sub_10005CD2C((uint64_t)v8, v7);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid callback while reading Emergency Address...", buf, 2u);
    }
  }
}

void sub_1009CCAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, char *a14)
{
}

uint64_t sub_1009CCADC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, a2, &v4);
}

BOOL sms::Controller::isEmergencyTextNumberForSlot_sync(uint64_t a1, int a2, uint64_t a3)
{
  int v9 = a2;
  if (*(char *)(a3 + 23) < 0)
  {
    if (*(void *)(a3 + 8)) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!*(unsigned char *)(a3 + 23)) {
    return 0;
  }
LABEL_3:
  BOOL v7 = 0;
  v8[0] = 0;
  v8[1] = 0;
  unsigned int v10 = &v9;
  uint64_t v4 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v9, (uint64_t)&unk_10144E20E, &v10);
  sub_10082FE4C((uint64_t)v4[5], (uint64_t *)&v7);
  LOBYTE(v10) = 0;
  BOOL v5 = v8 != sub_1000D85D4(v7, v8, (unsigned __int8 **)a3);
  sub_10005CD2C((uint64_t)&v7, v8[0]);
  return v5;
}

void sub_1009CCBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

BOOL sub_1009CCC00(uint64_t a1, int a2, long long *a3)
{
  int v11 = a2;
  v10[0] = a1;
  v10[1] = &v11;
  void v10[2] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v5 = v11;
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(&block, *(void **)a3, *((void *)a3 + 1));
      }
      else
      {
        blocuint64_t k = *a3;
        char v15 = (uint64_t (*)(uint64_t))*((void *)a3 + 2);
      }
      BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, v5, (uint64_t)&block);
      if (SHIBYTE(v15) < 0) {
        operator delete((void *)block);
      }
      return isEmergencyTextNumberForSlot_sync;
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1009EEBB0;
  v12[3] = &unk_101A25408;
  v12[4] = a1 + 8;
  v12[5] = v10;
  uint64_t v13 = v12;
  BOOL v7 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  *(void *)&blocuint64_t k = _NSConcreteStackBlock;
  *((void *)&block + 1) = 0x40000000;
  if (v6)
  {
    char v15 = sub_10005A304;
    uint64_t v16 = &unk_101A253A8;
    CFTypeID v17 = &v19;
    CFBooleanRef v18 = &v13;
    dispatch_sync(v7, &block);
  }
  else
  {
    char v15 = sub_10005B068;
    uint64_t v16 = &unk_101A253C8;
    CFTypeID v17 = &v19;
    CFBooleanRef v18 = &v13;
    dispatch_async_and_wait(v7, &block);
  }
  return v19 != 0;
}

void sub_1009CCDD4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_1009CCDF8(uint64_t a1, int a2, uint64_t a3)
{
  unsigned char v4[4] = a1;
  int v5 = a2;
  sub_1009EEC50((uint64_t)v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_1009CCF8C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1009CCFAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, a2, &v4);
}

void sub_1009CCFFC(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sms::Controller::getDynamicMessageModes_sync(a1, v8, a3);
      return;
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_1009EEFF4;
  v9[3] = &unk_101A25428;
  void v9[4] = a1 + 8;
  void v9[5] = v7;
  unsigned int v10 = v9;
  BOOL v6 = *(NSObject **)(a1 + 24);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    __int16 v12 = sub_1009EF004;
    uint64_t v13 = &unk_101A25448;
    int v14 = a3;
    char v15 = &v10;
    dispatch_sync(v6, block);
  }
  else
  {
    __int16 v12 = sub_1009EF070;
    uint64_t v13 = &unk_101A25468;
    int v14 = a3;
    char v15 = &v10;
    dispatch_async_and_wait(v6, block);
  }
}

void sub_1009CD178(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    if (subscriber::isValidSimSlot())
    {
      int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 240))(a1, a2);
      BOOL v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = "false";
        if (v6) {
          int v8 = "true";
        }
        int v11 = 136315138;
        __int16 v12 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SMSReadyStatus %s ", (uint8_t *)&v11, 0xCu);
      }
      sub_1009CD34C(*(void *)(a3 + 24), v6, 0);
    }
    else
    {
      uint64_t v10 = *(void *)(a3 + 24);
      sub_1009CD34C(v10, 0, 0x1600000001);
    }
  }
  else
  {
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid callback while reading SMS ready status...", (uint8_t *)&v11, 2u);
    }
  }
}

uint64_t sub_1009CD34C(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = a3;
  char v4 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)a1 + 48))(a1, &v4, &v5);
}

void sub_1009CD3A4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v12 = a2;
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  v9[0] = a1;
  v9[1] = &v12;
  void v9[2] = a3;
  v9[3] = &v11;
  void v9[4] = &v10;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      if (subscriber::isValidSimSlot()) {
        sub_1009CD630(a1, v12, a3, v11, v10);
      }
      return;
    }
    BOOL v7 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_1009EF0DC;
  block[3] = &unk_101A25488;
  block[4] = a1 + 8;
  block[5] = v9;
  int v8 = *(NSObject **)(a1 + 24);
  if (v7) {
    dispatch_sync(v8, block);
  }
  else {
    dispatch_async_and_wait(v8, block);
  }
}

uint64_t sub_1009CD4A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v17 = a2;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int v8 = (uint64_t **)(a1 + 2544);
  *(void *)long long buf = &v17;
  int v9 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v17, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  sub_1009CAE18(&v15, a1, a2, *((_DWORD *)v9[5] + 55));
  uint64_t v10 = v15;
  if (v15)
  {
    *(void *)long long buf = &v17;
    uint64_t v11 = sub_1001B0B78(v8, &v17, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v10 + 136))(v10, a3, *((unsigned int *)v11[5] + 11));
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 208))(v15, a4);
  }
  else
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "encodedMessageBodyExceedsSizeInBytes outgoing message is invalid", buf, 2u);
    }
    uint64_t v12 = 0;
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  return v12;
}

void sub_1009CD618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009CD630(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v17 = a2;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v10 = (uint64_t **)(a1 + 2544);
  *(void *)long long buf = &v17;
  uint64_t v11 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v17, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  sub_1009CAE18(&v15, a1, a2, *((_DWORD *)v11[5] + 55));
  uint64_t v12 = v15;
  if (v15)
  {
    *(void *)long long buf = &v17;
    uint64_t v13 = sub_1001B0B78(v10, &v17, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 136))(v12, a3, *((unsigned int *)v13[5] + 11));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 216))(v15, a4, a5);
  }
  else
  {
    int v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "getMessageSizeInEncodedCharactersAndSplitThreshold_sync outgoing message is invalid", buf, 2u);
    }
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_1009CD7A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009CD7BC(unint64_t a1, void **a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  v3[0] = a1;
  v3[1] = 0uLL;
  sub_1009ED118((void *)v3 + 1, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_1009CD8E4(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, (void *)(a1 + 8));
  operator new();
}

void *sub_1009CD9D8(void *result, long long *a2)
{
  char v3 = (char **)result;
  char v4 = result + 2;
  unint64_t v5 = result[2];
  int v6 = (void *)result[1];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v9 = ((uint64_t)v6 - *result) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v11 = v5 - *result;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    CFBooleanRef v25 = v4;
    uint64_t v13 = (char *)sub_1009C886C(v12);
    uint64_t v15 = &v13[16 * v9];
    long long v16 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v16 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v16 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int v8 = v15 + 16;
    CFBooleanRef v18 = *v3;
    int v17 = v3[1];
    if (v17 == *v3)
    {
      int64x2_t v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v15 - 1) = v19;
        v15 -= 16;
        *(void *)int v17 = 0;
        *((void *)v17 + 1) = 0;
      }
      while (v17 != v18);
      int64x2_t v20 = *(int64x2_t *)v3;
    }
    NSObject *v3 = v15;
    v3[1] = v8;
    int64x2_t v23 = v20;
    uint64_t v21 = v3[2];
    _OWORD v3[2] = &v13[16 * v14];
    CFTypeID v24 = v21;
    uint64_t v22 = v20.i64[0];
    uint64_t result = (void *)sub_10019E528((uint64_t)&v22);
  }
  else
  {
    *int v6 = *(void *)a2;
    uint64_t v7 = *((void *)a2 + 1);
    v6[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    int v8 = (char *)(v6 + 2);
  }
  v3[1] = v8;
  return result;
}

void sub_1009CDB04(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v65 = 0;
  if (a2 == a3) {
    goto LABEL_87;
  }
  char v4 = a3;
  unint64_t v5 = a2;
  char v50 = 0;
  int v6 = (Registry **)(a1 + 80);
  uint64_t v7 = (os_log_t *)(a1 + 40);
  char v48 = (uint64_t **)(a1 + 2544);
  uint64_t v47 = (Registry **)(a1 + 80);
  do
  {
    uint64_t v9 = *v5;
    int v8 = (std::__shared_weak_count *)v5[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v65 = *(_DWORD *)(v9 + 152);
    if (subscriber::isValidSimSlot())
    {
      unint64_t v10 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v65);
      uint64_t v63 = 0;
      xpc_object_t v64 = 0;
      sGetSubscriberSimInterface();
      if (v63)
      {
        int v11 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v63 + 232))(v63, v65, 31);
      }
      else
      {
        unint64_t v12 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to get SubscriberSimController", buf, 2u);
        }
        int v11 = 0;
      }
      if ((sub_1009CA4B0(a1, v65) & 1) == 0)
      {
        uint64_t v15 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Sending SMS not allowed", buf, 2u);
        }
        uint64_t v16 = *(void *)(v9 + 136);
        *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)(v9 + 96);
        *(_DWORD *)&uint8_t buf[8] = v65;
        *(_DWORD *)long long buf = 1;
        *(_OWORD *)&unsigned char buf[12] = 0uLL;
        (*(void (**)(uint64_t, Registry **, uint8_t *))(*(void *)v16 + 16))(v16, v6, buf);
        goto LABEL_56;
      }
      char v13 = *(unsigned char *)(v9 + 87);
      if (v13 < 0) {
        uint64_t v14 = *(void *)(v9 + 72);
      }
      else {
        uint64_t v14 = *(unsigned __int8 *)(v9 + 87);
      }
      int v17 = (void **)(v9 + 64);
      if (v14)
      {
        CFBooleanRef v18 = *v10;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          if (v13 < 0) {
            int v17 = (void **)*v17;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v17;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I SMS Service Center Address set to :- %s", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v66 = &v65;
        long long v19 = sub_1001B0B78(v48, (int *)&v65, (uint64_t)&unk_10144E20E, &v66);
        CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)(v19[5] + 10));
        if (*(char *)(v9 + 87) < 0) {
          operator delete(*v17);
        }
        *(_OWORD *)int v17 = *(_OWORD *)buf;
        *(void *)(v9 + 80) = *(void *)&buf[16];
      }
      char v4 = a3;
      if (sub_1009C8DB8(a1))
      {
        ServiceMap = (std::mutex *)Registry::getServiceMap(v20, *v6);
        uint64_t v22 = ServiceMap;
        if (v23 < 0)
        {
          CFTypeID v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v25 = 5381;
          do
          {
            uint64_t v23 = v25;
            unsigned int v26 = *v24++;
            uint64_t v25 = (33 * v25) ^ v26;
          }
          while (v26);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v23;
        uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
        if (!v27)
        {
          std::mutex::unlock(v22);
          goto LABEL_46;
        }
        uint64_t v28 = v27[3];
        uint8_t v29 = (std::__shared_weak_count *)v27[4];
        if (v29)
        {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v22);
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          int v6 = v47;
          sub_10004D2C8(v29);
          if (v28) {
            int v30 = v11;
          }
          else {
            int v30 = 0;
          }
          sub_10004D2C8(v29);
          BOOL v31 = v30 == 1;
          char v4 = a3;
          if (!v31) {
            goto LABEL_46;
          }
LABEL_42:
          uint64_t v61 = v9;
          uint64_t v62 = v8;
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 464))(a1, &v61);
          int v33 = v62;
          if (!v62) {
            goto LABEL_50;
          }
LABEL_49:
          sub_10004D2C8(v33);
LABEL_50:
          int v34 = v65;
          if (*(char *)(v9 + 63) < 0)
          {
            sub_10004FC84(__p, *(void **)(v9 + 40), *(void *)(v9 + 48));
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)(v9 + 40);
            uint64_t v59 = *(void *)(v9 + 56);
          }
          BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, v34, (uint64_t)__p);
          if (SHIBYTE(v59) < 0) {
            operator delete(__p[0]);
          }
          v50 |= isEmergencyTextNumberForSlot_sync;
LABEL_56:
          if (v64) {
            sub_10004D2C8(v64);
          }
          goto LABEL_58;
        }
        std::mutex::unlock(v22);
        if (v28) {
          char v32 = v11;
        }
        else {
          char v32 = 0;
        }
        char v4 = a3;
        if (v32) {
          goto LABEL_42;
        }
      }
LABEL_46:
      *(void *)&long long v60 = v9;
      *((void *)&v60 + 1) = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1009CE3AC(a1, &v60);
      int v33 = v8;
      if (!v8) {
        goto LABEL_50;
      }
      goto LABEL_49;
    }
LABEL_58:
    if (v8) {
      sub_10004D2C8(v8);
    }
    v5 += 2;
  }
  while (v5 != v4);
  if ((v50 & 1) == 0 || *(_DWORD *)(a1 + 2360) != 2)
  {
LABEL_87:
    sub_1009CFB7C(a1);
    return;
  }
  *(void *)long long buf = &v65;
  if (*((unsigned char *)sub_1001B0B78(v48, (int *)&v65, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 42))
  {
    *(void *)long long buf = &v65;
    if (!*((unsigned char *)sub_1001B0B78(v48, (int *)&v65, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270))
    {
      __int16 v46 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Transport available for Emergency Text", buf, 2u);
      }
      goto LABEL_87;
    }
  }
  unsigned int v36 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Waiting for a better transport for emergency text.", buf, 2u);
  }
  char v37 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v37 || (uint64_t v38 = *(void *)(a1 + 8), (v39 = std::__shared_weak_count::lock(v37)) == 0)) {
    sub_100088B9C();
  }
  int v40 = v39;
  atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v39);
  Registry::getTimerService((uint64_t *)buf, *v6);
  uint64_t v41 = *(void *)buf;
  sub_100058DB0(v56, "SMS Hold timer");
  unint64_t v42 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v42;
  if (v42) {
    dispatch_retain(v42);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_1009CE424;
  aBlock[3] = &unk_101A24D20;
  aBlock[4] = a1;
  aBlock[5] = v38;
  uint64_t v52 = v40;
  atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  unsigned int v53 = v65;
  int64x2_t v54 = _Block_copy(aBlock);
  sub_100118A44(v41, (uint64_t)v56, 0, 5000000, &object, &v54);
  uint64_t v43 = v63;
  uint64_t v63 = 0;
  uint64_t v44 = *(void *)(a1 + 2624);
  *(void *)(a1 + 2624) = v43;
  if (v44)
  {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
    uint64_t v45 = v63;
    uint64_t v63 = 0;
    if (v45) {
      (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
    }
  }
  if (v54) {
    _Block_release(v54);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v57 < 0) {
    operator delete(v56[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  std::__shared_weak_count::__release_weak(v40);
}

void sub_1009CE29C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,void *aBlock,dispatch_object_t object,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009CE3AC(uint64_t a1, long long *a2)
{
  int v3 = *(_DWORD *)(a1 + 164);
  uint64_t v4 = *(void *)a2;
  *(_DWORD *)(v4 + 88) = v3;
  *(_DWORD *)(a1 + 164) = v3 + 1;
  int v7 = *(_DWORD *)(v4 + 152);
  int v8 = &v7;
  unint64_t v5 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, &v8);
  return sub_1009CD9D8(v5[5] + 61, a2);
}

void sub_1009CE424(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      unint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(void *)(v3 + 2624);
        *(void *)(v3 + 2624) = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        if (sub_1009CE4FC(v3, *(_DWORD *)(a1 + 56))) {
          sub_1009CE5E4(v3);
        }
        else {
          sub_1009CE628(v3, *(_DWORD *)(a1 + 56));
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009CE4E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1009CE4FC(uint64_t a1, int a2)
{
  int v10 = a2;
  uint64_t v3 = (uint64_t **)(a1 + 2544);
  int v11 = &v10;
  uint64_t v4 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v10, (uint64_t)&unk_10144E20E, &v11);
  if (v4[5][61] == v4[5][62] || !*(void *)(a1 + 96)) {
    return 1;
  }
  int v11 = &v10;
  unint64_t v5 = (uint64_t *)sub_1001B0B78(v3, &v10, (uint64_t)&unk_10144E20E, &v11)[5][61];
  uint64_t v7 = *v5;
  uint64_t v6 = (std::__shared_weak_count *)v5[1];
  if (!v6) {
    return *(_DWORD *)(v7 + 88) != *(_DWORD *)(*(void *)(a1 + 96) + 104);
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v8 = *(_DWORD *)(v7 + 88) != *(_DWORD *)(*(void *)(a1 + 96) + 104);
  sub_10004D2C8(v6);
  return v8;
}

void sub_1009CE5E4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_1009CFB7C(a1);
}

void sub_1009CE628(uint64_t a1, int a2)
{
  int v135 = a2;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v135;
  uint64_t v4 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v135, (uint64_t)&unk_10144E20E, &buf);
  if (v4[5][61] != v4[5][62])
  {
    unint64_t v5 = *(sms::Model **)(a1 + 96);
    if (v5)
    {
      os_log_t v6 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        int MessageID = sms::Model::getMessageID(v5);
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = MessageID;
        BOOL v8 = "#I Message sending in progress: [ID: %hu]";
        uint64_t v9 = v6;
        uint32_t v10 = 8;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, v10);
        return;
      }
      return;
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v135;
    uint64_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v135, (uint64_t)&unk_10144E20E, &buf)[5][61];
    uint64_t v14 = *(unsigned int ***)v12;
    char v13 = *(std::__shared_weak_count **)(v12 + 8);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v134 = *((_DWORD *)v14 + 38);
    if ((subscriber::isValidSimSlot() & 1) == 0) {
      goto LABEL_204;
    }
    uint64_t v121 = (Registry **)(a1 + 80);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v134;
    int v15 = *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v134, (uint64_t)&unk_10144E20E, &buf)[5] + 55);
    if (!sub_100529568()
      || (buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v134,
          *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v134, (uint64_t)&unk_10144E20E, &buf)[5] + 55)))
    {
LABEL_13:
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v134;
      if (!*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v134, (uint64_t)&unk_10144E20E, &buf)[5] + 55))
      {
        if (!sub_1009CFC3C(a1, v134))
        {
          *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
          sub_1002598D0(&buf, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
          Registry::getTimerService((uint64_t *)v136, *v121);
          uint64_t v29 = *(void *)v136;
          sub_100058DB0(__p, "SMS encoder wait");
          int v30 = *(NSObject **)(a1 + 24);
          dispatch_object_t object = v30;
          if (v30) {
            dispatch_retain(v30);
          }
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 1174405120;
          aBlock[2] = sub_1009CFE08;
          aBlock[3] = &unk_101A24D50;
          uint64_t size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
          aBlock[4] = a1;
          long long v125 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          if (buf.__r_.__value_.__l.__size_) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 16), 1uLL, memory_order_relaxed);
          }
          int v126 = v134;
          uint64_t v127 = _Block_copy(aBlock);
          sub_100118A44(v29, (uint64_t)__p, 0, 5000000, &object, &v127);
          *(void *)uint64_t v138 = &v134;
          char v32 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v134, (uint64_t)&unk_10144E20E, (_DWORD **)v138)[5];
          uint64_t v33 = v131;
          uint64_t v131 = 0;
          uint64_t v34 = v32[37];
          v32[37] = v33;
          if (v34)
          {
            (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
            uint64_t v35 = v131;
            uint64_t v131 = 0;
            if (v35) {
              (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
            }
          }
          if (v127) {
            _Block_release(v127);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v130 < 0) {
            operator delete(__p[0]);
          }
          if (*(void *)&v136[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v136[8]);
          }
          unsigned int v36 = *v3;
          if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v136 = 0;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Current encoder is unknown, waiting for encoder to become available", v136, 2u);
          }
          if (*((void *)&v125 + 1)) {
            std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v125 + 1));
          }
          if (size) {
            std::__shared_weak_count::__release_weak(size);
          }
          goto LABEL_204;
        }
        os_log_t v22 = *v3;
        if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          uint64_t v23 = "#I Rat change timer is already running";
          CFTypeID v24 = v22;
          uint32_t v25 = 2;
LABEL_30:
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&buf, v25);
        }
LABEL_204:
        if (v13) {
          sub_10004D2C8(v13);
        }
        return;
      }
LABEL_14:
      if (*((_DWORD *)v14 + 30)) {
        int v16 = *((_DWORD *)v14 + 30);
      }
      else {
        int v16 = v15;
      }
      sub_1009CAE18(&buf, a1, *((unsigned int *)v14 + 38), v16);
      long long v17 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
      CFBooleanRef v18 = *(std::__shared_weak_count **)(a1 + 104);
      *(_OWORD *)(a1 + 96) = v17;
      if (v18)
      {
        sub_10004D2C8(v18);
        if (buf.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
        }
        uint64_t v19 = *(void *)(a1 + 96);
        if (v19)
        {
LABEL_21:
          if (*((_DWORD *)v14 + 32) == 2 && *(_DWORD *)(v19 + 40) != 2)
          {
            long long v49 = *v3;
            if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Can't send the message since assigned transport is not IMS over AP", (uint8_t *)&buf, 2u);
            }
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
            sub_1009D0128(a1, v134, 3, (long long *)&buf);
            goto LABEL_204;
          }
          if ((*(unsigned int (**)(unsigned int *))(*(void *)v14[17] + 24))(v14[17]) == 2) {
            (*(void (**)(void, uint64_t))(**(void **)(a1 + 96) + 104))(*(void *)(a1 + 96), 1);
          }
          uint64_t v20 = *(void *)(a1 + 96);
          uint64_t v21 = v14 + 2;
          if (*((unsigned char *)v14 + 116)) {
            (*(void (**)(uint64_t, unsigned int **, void))(*(void *)v20 + 136))(v20, v21, *((unsigned int *)v14 + 25));
          }
          else {
            (*(void (**)(uint64_t, unsigned int **))(*(void *)v20 + 144))(v20, v21);
          }
          long long v120 = (unsigned __int8 *)(v14 + 5);
          (*(void (**)(void))(**(void **)(a1 + 96) + 120))(*(void *)(a1 + 96));
          if (*((char *)v14 + 87) < 0) {
            char v37 = v14[9];
          }
          else {
            char v37 = (unsigned int *)*((unsigned __int8 *)v14 + 87);
          }
          if (v37)
          {
            uint64_t v38 = *(void *)(a1 + 96);
            CSIPhoneNumber::CSIPhoneNumber();
            (*(void (**)(uint64_t, std::string *))(*(void *)v38 + 296))(v38, &buf);
            if (v146 < 0) {
              operator delete(v145);
            }
            if (v144 < 0) {
              operator delete(v143);
            }
            if (v142 < 0) {
              operator delete(v141);
            }
            if (v140 < 0) {
              operator delete((void *)buf.__r_.__value_.__l.__size_);
            }
          }
          if (*((_DWORD *)v14 + 28) != -1) {
            (*(void (**)(void))(**(void **)(a1 + 96) + 304))(*(void *)(a1 + 96));
          }
          int v39 = *((_DWORD *)v14 + 31);
          uint64_t v40 = *(void *)(a1 + 96);
          if (v39)
          {
            *(_DWORD *)(v40 + 36) = v39;
            uint64_t v41 = *v3;
            if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v42 = "Default Transport";
              if (v39 == 1) {
                unint64_t v42 = "Signaling Transport";
              }
              if (v39 == 2) {
                unint64_t v42 = "IMS Transport";
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Overriding transport to %s", (uint8_t *)&buf, 0xCu);
              uint64_t v40 = *(void *)(a1 + 96);
            }
          }
          *(_DWORD *)(v40 + 104) = *((_DWORD *)v14 + 22);
          int v43 = *((unsigned __int8 *)v14 + 117);
          *(unsigned char *)(v40 + 54) = v43;
          if (v43) {
            sms::Model::setMessageID((sms::Model *)v40, *((_WORD *)v14 + 52));
          }
          int v44 = *((unsigned __int8 *)v14 + 116);
          LODWORD(v131) = v134;
          uint64_t v45 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
          __int16 v46 = v45;
          uint64_t v47 = *(void *)(a1 + 96);
          int v48 = *(_DWORD *)(v47 + 48);
          if (v48 != 1)
          {
            if (v48 == 2)
            {
              (*(void (**)(std::string *__return_ptr, void))(*(void *)v47 + 256))(&buf, *(void *)(a1 + 96));
              std::string::operator=((std::string *)(v47 + 112), &buf);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              long long v60 = *v45;
              if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Unable to determine the message type", (uint8_t *)&buf, 2u);
              }
            }
            goto LABEL_172;
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v121, *v121);
          char v51 = ServiceMap;
          if ((v52 & 0x8000000000000000) != 0)
          {
            unsigned int v53 = (unsigned __int8 *)(v52 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v54 = 5381;
            do
            {
              std::string::size_type v52 = v54;
              unsigned int v55 = *v53++;
              uint64_t v54 = (33 * v54) ^ v55;
            }
            while (v55);
          }
          std::mutex::lock(ServiceMap);
          buf.__r_.__value_.__r.__words[0] = v52;
          unint64_t v56 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)&buf);
          int v118 = v44;
          if (v56)
          {
            uint64_t v58 = v56[3];
            char v57 = (std::__shared_weak_count *)v56[4];
            if (v57)
            {
              atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v51);
              atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v57);
              char v59 = 0;
              goto LABEL_107;
            }
          }
          else
          {
            uint64_t v58 = 0;
          }
          std::mutex::unlock(v51);
          char v57 = 0;
          char v59 = 1;
LABEL_107:
          if (v58)
          {
            memset(v136, 0, sizeof(v136));
            PersonalityIdFromSlotId();
            (*(void (**)(uint8_t *__return_ptr, uint64_t, std::string *))(*(void *)v58 + 40))(v136, v58, &buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            uint64_t v65 = *(void *)v136;
            if (*(void *)v136)
            {
              sub_100058DB0(&buf, "addressSmsToRecipient");
              int v66 = (*(uint64_t (**)(uint64_t, std::string *, void))(*(void *)v65 + 64))(v65, &buf, 0);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              if (*(void *)&v136[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&v136[8]);
              }
              if (v66)
              {
                uint64_t v67 = *(void *)(a1 + 96);
                goto LABEL_123;
              }
            }
            else
            {
              uint64_t v68 = *v46;
              if (os_log_type_enabled(*v46, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "Unable to determine the imsConfigRef", (uint8_t *)&buf, 2u);
              }
              if (*(void *)&v136[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&v136[8]);
              }
            }
          }
          if (!v118)
          {
            uint64_t v67 = *(void *)(a1 + 96);
            if (*(unsigned char *)(v67 + 96))
            {
LABEL_123:
              (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v67 + 256))(&buf, v67);
              std::string::operator=((std::string *)(v67 + 112), &buf);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
LABEL_170:
              if ((v59 & 1) == 0) {
                sub_10004D2C8(v57);
              }
LABEL_172:
              long long v98 = *(_DWORD **)(a1 + 96);
              if (v98[12] == 1 && *v14)
              {
                (*(void (**)(_DWORD *, void))(*(void *)v98 + 56))(v98, **v14);
                (*(void (**)(void, void))(**(void **)(a1 + 96) + 72))(*(void *)(a1 + 96), (*v14)[1]);
                (*(void (**)(void, void))(**(void **)(a1 + 96) + 80))(*(void *)(a1 + 96), *((unsigned __int8 *)*v14 + 8));
                long long v98 = *(_DWORD **)(a1 + 96);
              }
              v98[38] = *((_DWORD *)v14 + 2);
              int v99 = (*(uint64_t (**)(_DWORD *))(*(void *)v98 + 152))(v98);
              if (v99)
              {
                long long v100 = *v3;
                if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v101 = sms::asString();
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v101;
                  _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I Failed to compose the SMS: %s", (uint8_t *)&buf, 0xCu);
                }
                int v102 = *(sms::Model **)(a1 + 96);
                if (v102)
                {
                  unsigned int v103 = v134;
                  int TransportType = sms::Model::getTransportType(v102);
                  sms::Controller::submitSMSSendEndMetric(a1, v103, TransportType, *((_DWORD *)v14 + 2), v120, 5u, 2);
                }
                else
                {
                  char v108 = *v3;
                  if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "Failed to submit SMS send end metric. Invalid msg.", (uint8_t *)&buf, 2u);
                  }
                }
                if (v99 == 3) {
                  int v109 = 16;
                }
                else {
                  int v109 = 43;
                }
                if (v99 == 4) {
                  int v109 = 48;
                }
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)&_mh_execute_header;
                LODWORD(buf.__r_.__value_.__l.__data_) = v109;
                HIDWORD(buf.__r_.__value_.__r.__words[1]) = 5;
                sub_1009D0128(a1, v134, 1, (long long *)&buf);
                goto LABEL_204;
              }
              int v105 = *((_DWORD *)v14 + 2);
              if (v105 == 4)
              {
                char v110 = *v3;
                if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I AML SMS detected: Skipping emergency mode extension", (uint8_t *)&buf, 2u);
                }
                goto LABEL_203;
              }
              if (v105 == 3)
              {
                Registry::getTimerService((uint64_t *)&buf, *v121);
                uint64_t v106 = (**(uint64_t (***)(std::string::size_type))buf.__r_.__value_.__l.__data_)(buf.__r_.__value_.__r.__words[0]);
                *(void *)long long v136 = &v134;
                uint64_t v107 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v134, (uint64_t)&unk_10144E20E, (_DWORD **)v136)[5];
                if (!*((unsigned char *)v107 + 600)) {
                  *((unsigned char *)v107 + 600) = 1;
                }
                v107[74] = v106;
                if (buf.__r_.__value_.__l.__size_) {
                  sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
                }
LABEL_203:
                sub_1009D0860(a1);
                goto LABEL_204;
              }
              int v111 = v134;
              if (*((char *)v14 + 63) < 0)
              {
                sub_10004FC84(v122, v14[5], (unint64_t)v14[6]);
              }
              else
              {
                *(_OWORD *)uint64_t v122 = *(_OWORD *)v120;
                __int16 v123 = v14[7];
              }
              BOOL v112 = sub_1009D0318(a1, v111, (char *)v122);
              if (SHIBYTE(v123) < 0) {
                operator delete(v122[0]);
              }
              if (!v112 || (isActive() & 1) != 0) {
                goto LABEL_203;
              }
              long long v113 = *v3;
              if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v114 = asString();
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v114;
                uint64_t v23 = "#I Waiting for emergency mode ready..[%s]";
                CFTypeID v24 = v113;
                uint32_t v25 = 12;
                goto LABEL_30;
              }
              goto LABEL_204;
            }
          }
          *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf.__r_.__value_.__l.__size_;
          *(void *)long long v136 = &v131;
          long long v117 = v57;
          xpc_object_t v69 = (uint64_t *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v131, (uint64_t)&unk_10144E20E, (_DWORD **)v136)[5][61];
          uint64_t v70 = *v69;
          uint64_t v71 = (std::__shared_weak_count *)v69[1];
          if (v71) {
            atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          long long v119 = v71;
          char v116 = v59;
          if (*(_DWORD *)(v70 + 8) == 2)
          {
            *(void *)long long v136 = &v131;
            unsigned int v72 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v131, (uint64_t)&unk_10144E20E, (_DWORD **)v136)[5];
            if (*((char *)v72 + 391) < 0 ? v72[47] : *((unsigned __int8 *)v72 + 391))
            {
              *(void *)long long v136 = &v131;
              BOOL v74 = v46;
              uint64_t v75 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v131, (uint64_t)&unk_10144E20E, (_DWORD **)v136)[5];
              v136[0] = 2;
              uint64_t v76 = sub_1009F0034((uint64_t **)&buf, 2u, v136);
              std::string::operator=((std::string *)(v76 + 5), (const std::string *)(v75 + 46));
              __int16 v46 = v74;
            }
          }
          long long v115 = v46;
          uint64_t v77 = *(void *)(a1 + 416);
          if (v77)
          {
            uint64_t v78 = a1 + 416;
            do
            {
              int v79 = *(_DWORD *)(v77 + 32);
              BOOL v80 = v79 < (int)v131;
              if (v79 >= (int)v131) {
                xpc_object_t v81 = (uint64_t *)v77;
              }
              else {
                xpc_object_t v81 = (uint64_t *)(v77 + 8);
              }
              if (!v80) {
                uint64_t v78 = v77;
              }
              uint64_t v77 = *v81;
            }
            while (*v81);
            if (v78 != a1 + 416 && (int)v131 >= *(_DWORD *)(v78 + 32))
            {
              if (*(char *)(v78 + 63) < 0 ? *(void *)(v78 + 48) : *(unsigned __int8 *)(v78 + 63))
              {
                v136[0] = 0;
                uint64_t v83 = sub_1009F0034((uint64_t **)&buf, 0, v136);
                std::string::operator=((std::string *)(v83 + 5), (const std::string *)(v78 + 40));
              }
            }
          }
          *(void *)uint64_t v138 = &v131;
          long long v84 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v131, (uint64_t)&unk_10144E20E, (_DWORD **)v138);
          CSIPhoneNumber::getFullNumber((uint64_t *)v136, (CSIPhoneNumber *)(v84[5] + 10));
          if (SHIBYTE(v137) < 0)
          {
            uint64_t v85 = *(void *)&v136[8];
            operator delete(*(void **)v136);
            if (!v85)
            {
LABEL_155:
              memset(v136, 0, sizeof(v136));
              uint64_t v137 = 0;
              sub_1009CFCA8((char **)v136, a1, v131);
              long long v90 = *(void **)v136;
              long long v89 = *(uint8_t **)&v136[8];
              if (*(void *)v136 == *(void *)&v136[8])
              {
LABEL_162:
                uint64_t v95 = *v115;
                if (os_log_type_enabled(*v115, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)uint64_t v138 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "Unable to determine destination address for IMS over SMS", v138, 2u);
                }
              }
              else
              {
                uint64_t v91 = *(uint8_t **)v136;
                while (1)
                {
                  v138[0] = *v91;
                  unsigned __int8 v92 = v138[0];
                  uint64_t v93 = sub_1009F0034((uint64_t **)&buf, v138[0], v138);
                  if (*((char *)v93 + 63) < 0 ? v93[6] : (uint64_t *)*((unsigned __int8 *)v93 + 63)) {
                    break;
                  }
                  if (++v91 == v89) {
                    goto LABEL_162;
                  }
                }
                uint64_t v96 = *(void *)(a1 + 96);
                long long v97 = sub_1009F0034((uint64_t **)&buf, v92, v138);
                std::string::operator=((std::string *)(v96 + 112), (const std::string *)(v97 + 5));
              }
              if (v90) {
                operator delete(v90);
              }
              char v57 = v117;
              if (v119) {
                sub_10004D2C8(v119);
              }
              sub_10026D080((char *)buf.__r_.__value_.__l.__size_);
              char v59 = v116;
              goto LABEL_170;
            }
          }
          else if (!HIBYTE(v137))
          {
            goto LABEL_155;
          }
          *(void *)uint64_t v138 = &v131;
          uint64_t v86 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v131, (uint64_t)&unk_10144E20E, (_DWORD **)v138);
          CSIPhoneNumber::getFullNumber((uint64_t *)v136, (CSIPhoneNumber *)(v86[5] + 10));
          v138[0] = 1;
          CFTypeRef v87 = sub_1009F0034((uint64_t **)&buf, 1u, v138);
          uint64_t v88 = v87 + 5;
          if (*((char *)v87 + 63) < 0) {
            operator delete(*v88);
          }
          *(_OWORD *)uint64_t v88 = *(_OWORD *)v136;
          v88[2] = v137;
          goto LABEL_155;
        }
      }
      else
      {
        uint64_t v19 = v17;
        if ((void)v17) {
          goto LABEL_21;
        }
      }
      unsigned int v26 = *v3;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = sms::asString();
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Failed to compose the SMS with encoder: %s", (uint8_t *)&buf, 0xCu);
      }
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
      sub_1009D0128(a1, v134, 1, (long long *)&buf);
      goto LABEL_204;
    }
    int v28 = v134;
    if (*((char *)v14 + 63) < 0)
    {
      sub_10004FC84(__dst, v14[5], (unint64_t)v14[6]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v14 + 5);
      long long v133 = v14[7];
    }
    BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, v28, (uint64_t)__dst);
    BOOL v62 = isEmergencyTextNumberForSlot_sync;
    if (SHIBYTE(v133) < 0)
    {
      operator delete(__dst[0]);
      if (!v62) {
        goto LABEL_13;
      }
    }
    else if (!isEmergencyTextNumberForSlot_sync)
    {
      goto LABEL_13;
    }
    uint64_t v63 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = sms::asString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v64;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I Using %s encoder in lockdown", (uint8_t *)&buf, 0xCu);
    }
    int v15 = 1;
    goto LABEL_14;
  }
  os_log_t v11 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    BOOL v8 = "#I No pending SMS messages";
    uint64_t v9 = v11;
    uint32_t v10 = 2;
    goto LABEL_7;
  }
}

void sub_1009CF8FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,uint64_t a30,void *aBlock,dispatch_object_t object,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (v52) {
    sub_10004D2C8(v52);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009CFB50(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009CFB6C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009CFB7C(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v2 = v4;
  if (v4 != v5)
  {
    while ((v6(*v2) & 1) == 0)
    {
      if (++v2 == v5)
      {
        uint64_t v2 = v5;
        break;
      }
    }
LABEL_5:
    while (v2 != v5)
    {
      uint64_t v3 = v2 + 1;
      sub_1009CE628(a1, *v2);
      uint64_t v2 = v5;
      if (v3 != v5)
      {
        uint64_t v2 = v3;
        while ((v6(*v2) & 1) == 0)
        {
          if (++v2 == v5)
          {
            uint64_t v2 = v5;
            goto LABEL_5;
          }
        }
      }
    }
  }
}

uint64_t sub_1009CFC3C(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    unint64_t v5 = &v4;
    return sub_1001B0B78((uint64_t **)(a1 + 2544), &v4, (uint64_t)&unk_10144E20E, &v5)[5][37] != 0;
  }
  return result;
}

char *sub_1009CFCA8(char **a1, uint64_t a2, int a3)
{
  int v14 = a3;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  int v15 = &v14;
  int v4 = sub_1001B0B78((uint64_t **)(a2 + 2544), &v14, (uint64_t)&unk_10144E20E, &v15)[5];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  os_log_t v6 = (unsigned char *)v4[43];
  unint64_t v5 = (unsigned char *)v4[44];
  size_t v7 = v5 - v6;
  if (v5 == v6)
  {
    uint64_t v9 = a1 + 1;
    unint64_t v11 = (unint64_t)a1[2];
    if (v11 < 2)
    {
LABEL_7:
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= 2) {
        uint64_t v12 = 2;
      }
      if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v13 = v12;
      }
      sub_1009ED1D8(a1, v13);
      uint64_t result = *v9;
      goto LABEL_14;
    }
    uint64_t result = 0;
  }
  else
  {
    sub_1009ED1D8(a1, v5 - v6);
    uint64_t v9 = a1 + 1;
    BOOL v8 = a1[1];
    memmove(v8, v6, v7);
    uint64_t result = &v8[v7];
    a1[1] = &v8[v7];
    if (*a1 != &v8[v7]) {
      return result;
    }
    unint64_t v11 = (unint64_t)a1[2];
    if (v11 - (unint64_t)result < 2)
    {
      if (v8)
      {
        operator delete(result);
        unint64_t v11 = 0;
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
      }
      goto LABEL_7;
    }
  }
LABEL_14:
  *(_WORD *)uint64_t result = 256;
  result += 2;
  *uint64_t v9 = result;
  return result;
}

void sub_1009CFDD8(_Unwind_Exception *exception_object)
{
  int v4 = *v1;
  if (*v1)
  {
    void *v2 = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009CFE08(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      unint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        int v7 = *(_DWORD *)(a1 + 56);
        os_log_t v6 = (_DWORD *)(a1 + 56);
        if (sub_1009CFC3C(v3, v7))
        {
          uint64_t v12 = v6;
          BOOL v8 = sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, &v12)[5];
          uint64_t v9 = v8[37];
          v8[37] = 0;
          if (v9) {
            (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
          }
          uint32_t v10 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)unint64_t v11 = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I RAT change timer expiry. Purging MO messages.", v11, 2u);
          }
          sub_1009CFF20(v3, 0);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009CFF0C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009CFF20(uint64_t a1, char a2)
{
  uint64_t v4 = a1 + 80;
  subscriber::makeSimSlotRange();
  os_log_t v6 = v28;
  unint64_t v5 = v29;
  if (v28 != v29)
  {
    while ((v30(*v6) & 1) == 0)
    {
      if (++v6 == v29)
      {
        os_log_t v6 = v29;
        break;
      }
    }
    uint64_t v19 = v29;
    if (v6 != v29)
    {
      int v7 = (uint64_t **)(a1 + 2544);
      long long v17 = v7;
      CFBooleanRef v18 = v30;
      do
      {
        int v27 = 0;
        int v27 = *v6;
        uint64_t v20 = &v27;
        BOOL v8 = sub_1001B0B78(v7, &v27, (uint64_t)&unk_10144E20E, &v20)[5];
        uint64_t v9 = (uint64_t *)v8[61];
        uint32_t v10 = (uint64_t *)v8[62];
        while (v9 != v10)
        {
          uint64_t v11 = *v9;
          uint64_t v12 = (std::__shared_weak_count *)v9[1];
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          char v25 = 0;
          __int16 v24 = 0;
          uint64_t v13 = *(void *)(v11 + 136);
          int v14 = *(_DWORD *)(v11 + 152);
          HIDWORD(v20) = *(_DWORD *)(v11 + 96);
          int v21 = v14;
          LODWORD(v20) = 1;
          uint64_t v22 = 43;
          char v23 = a2;
          int v26 = 5;
          (*(void (**)(uint64_t, uint64_t, int **))(*(void *)v13 + 16))(v13, v4, &v20);
          if (v12) {
            sub_10004D2C8(v12);
          }
          v9 += 2;
        }
        uint64_t v20 = &v27;
        int v7 = v17;
        int v15 = sub_1001B0B78(v17, &v27, (uint64_t)&unk_10144E20E, &v20);
        sub_10019E028(v15[5] + 61);
        int v16 = v6 + 1;
        os_log_t v6 = v5;
        if (v16 != v5)
        {
          os_log_t v6 = v16;
          while ((v18(*v6) & 1) == 0)
          {
            if (++v6 == v5)
            {
              os_log_t v6 = v5;
              break;
            }
          }
        }
      }
      while (v6 != v19);
    }
  }
}

void sub_1009D0110(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009D0128(uint64_t a1, int a2, int a3, long long *a4)
{
  int v25 = a2;
  int v7 = (uint64_t **)(a1 + 2544);
  uint64_t v22 = &v25;
  BOOL v8 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v25, (uint64_t)&unk_10144E20E, &v22);
  if (v8[5][62] != v8[5][61])
  {
    uint64_t v22 = &v25;
    uint64_t v9 = (uint64_t *)sub_1001B0B78(v7, &v25, (uint64_t)&unk_10144E20E, &v22)[5][61];
    uint64_t v10 = *v9;
    uint64_t v11 = (std::__shared_weak_count *)v9[1];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = *(void *)(v10 + 136);
    HIDWORD(v22) = *(_DWORD *)(v10 + 96);
    int v23 = v25;
    LODWORD(v22) = a3;
    long long v24 = *a4;
    (*(void (**)(uint64_t, uint64_t, int **))(*(void *)v12 + 16))(v12, a1 + 80, &v22);
    uint64_t v22 = &v25;
    uint64_t v13 = sub_1001B0B78(v7, &v25, (uint64_t)&unk_10144E20E, &v22)[5];
    uint64_t v22 = &v25;
    uint64_t v14 = sub_1001B0B78(v7, &v25, (uint64_t)&unk_10144E20E, &v22)[5][61];
    uint64_t v15 = v14 + 16;
    uint64_t v16 = v13[62];
    if (v14 + 16 != v16)
    {
      do
      {
        long long v17 = *(_OWORD *)v15;
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
        CFBooleanRef v18 = *(std::__shared_weak_count **)(v15 - 8);
        *(_OWORD *)(v15 - 16) = v17;
        if (v18) {
          sub_10004D2C8(v18);
        }
        v15 += 16;
      }
      while (v15 != v16);
      uint64_t v14 = v15 - 16;
      uint64_t v15 = v13[62];
    }
    while (v15 != v14)
    {
      uint64_t v19 = *(std::__shared_weak_count **)(v15 - 8);
      if (v19) {
        sub_10004D2C8(v19);
      }
      v15 -= 16;
    }
    v13[62] = v14;
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  uint64_t v20 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  if (v20) {
    sub_10004D2C8(v20);
  }
  return sub_1009CFB7C(a1);
}

void sub_1009D02F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009D0318(uint64_t a1, int a2, char *a3)
{
  int v44 = a2;
  os_log_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (a3[23] < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v43 = *((void *)a3 + 2);
  }
  BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, a2, (uint64_t)__p);
  BOOL v8 = isEmergencyTextNumberForSlot_sync;
  if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    if (isEmergencyTextNumberForSlot_sync) {
      goto LABEL_6;
    }
LABEL_10:
    os_log_t v10 = *v6;
    BOOL v11 = 0;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
      return v11;
    }
    if (a3[23] < 0) {
      a3 = *(char **)a3;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a3;
    uint64_t v12 = "#I Emergency Text: %s is not an emergency number";
    uint64_t v13 = v10;
    uint32_t v14 = 12;
    goto LABEL_14;
  }
  operator delete(__p[0]);
  if (!v8) {
    goto LABEL_10;
  }
LABEL_6:
  if (sub_100529568())
  {
    uint64_t v9 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Emergency Text: Bypassing home country check", buf, 2u);
    }
    goto LABEL_27;
  }
  uint64_t v15 = *(void *)(a1 + 2312);
  if (v15)
  {
    uint64_t v16 = a1 + 2312;
    do
    {
      int v17 = *(_DWORD *)(v15 + 28);
      BOOL v18 = v17 < v44;
      if (v17 >= v44) {
        uint64_t v19 = (uint64_t *)v15;
      }
      else {
        uint64_t v19 = (uint64_t *)(v15 + 8);
      }
      if (!v18) {
        uint64_t v16 = v15;
      }
      uint64_t v15 = *v19;
    }
    while (*v19);
    if (v16 != a1 + 2312 && v44 >= *(_DWORD *)(v16 + 28))
    {
      if (*(unsigned char *)(v16 + 32)) {
        goto LABEL_27;
      }
      os_log_t v39 = *v6;
      BOOL v11 = 0;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        return v11;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v12 = "#I Emergency Text: Not in home country.";
      uint64_t v13 = v39;
      uint32_t v14 = 2;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      return 0;
    }
  }
  uint64_t v20 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Emergency Text: Failed to determine if in home country", buf, 2u);
  }
LABEL_27:
  uint64_t v21 = *(void *)(a1 + 96);
  if (*(_DWORD *)(v21 + 36) == 2 && (uint64_t v21 = *(unsigned int *)(v21 + 40), v21 == 2))
  {
    *(void *)std::string buf = &v44;
    uint64_t v22 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v44, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    uint64_t v21 = *((unsigned __int8 *)v22[5] + 270);
    if (*((unsigned char *)v22[5] + 270))
    {
      uint64_t v23 = 2;
    }
    else
    {
      *(void *)std::string buf = &v44;
      uint64_t v40 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v44, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      uint64_t v21 = 3;
      if (*((_DWORD *)v40[5] + 66) == 10) {
        uint64_t v23 = 4;
      }
      else {
        uint64_t v23 = 3;
      }
    }
  }
  else
  {
    uint64_t v23 = 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v21, *(Registry **)(a1 + 80));
  int v25 = ServiceMap;
  if (v26 < 0)
  {
    int v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v26;
  int v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
  if (!v30)
  {
    uint64_t v32 = 0;
    goto LABEL_39;
  }
  uint64_t v32 = v30[3];
  BOOL v31 = (std::__shared_weak_count *)v30[4];
  if (!v31)
  {
LABEL_39:
    std::mutex::unlock(v25);
    BOOL v31 = 0;
    char v33 = 1;
    goto LABEL_40;
  }
  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v25);
  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v31);
  char v33 = 0;
LABEL_40:
  BOOL v11 = v32 != 0;
  uint64_t v34 = *v6;
  if (v32)
  {
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = a3;
      if (a3[23] < 0) {
        uint64_t v35 = *(void **)a3;
      }
      uint64_t v36 = EmCallTypeAsString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v35;
      __int16 v46 = 2080;
      uint64_t v47 = v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Emergency dest addr: %s Call Type: %s", buf, 0x16u);
    }
    uint64_t v37 = *(void *)(a1 + 96);
    if (a3[23] < 0) {
      sub_10004FC84(&v41, *(void **)a3, *((void *)a3 + 1));
    }
    else {
      std::string v41 = *(std::string *)a3;
    }
    *(unsigned char *)(v37 + 149) = 1;
    std::string::operator=((std::string *)(v37 + 160), &v41);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v41.__r_.__value_.__l.__data_);
    }
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v32 + 64))(v32, v44, v23);
  }
  else if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Failed to get Emergency Manager Interface...", buf, 2u);
  }
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  return v11;
}

void sub_1009D07FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009D0860(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  if (!v1) {
    return;
  }
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009C90B4(&v24, a1, v1, v3);
  if (v3) {
    sub_10004D2C8(v3);
  }
  (*(void (**)(void))(**(void **)(a1 + 96) + 360))(*(void *)(a1 + 96));
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 96) + 8);
  (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 96) + 192))(&__p);
  if ((v23 & 0x80u) == 0) {
    __int16 v5 = v23;
  }
  else {
    __int16 v5 = v22;
  }
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 176))(*(void *)(a1 + 96));
  int TransportType = sms::Model::getTransportType(*(sms::Model **)(a1 + 96));
  BOOL v8 = *(_DWORD **)(a1 + 96);
  int v9 = v8[38];
  os_log_t v10 = (unsigned __int8 *)(*(uint64_t (**)(_DWORD *))(*(void *)v8 + 128))(v8);
  sms::Controller::submitSMSSendStartMetric(a1, v4, v5, v6, TransportType, v9, v10);
  if ((char)v23 < 0) {
    operator delete(__p);
  }
  uint64_t v11 = v24;
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 104);
  uint64_t v19 = *(void *)(a1 + 96);
  uint64_t v20 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v26 = v4;
  std::string __p = &v26;
  uint64_t v13 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v26, (uint64_t)&unk_10144E20E, (_DWORD **)&__p);
  if (v13[5][61] == v13[5][62])
  {
    BOOL v18 = 0;
    goto LABEL_21;
  }
  std::string __p = &v26;
  uint32_t v14 = (uint64_t *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v26, (uint64_t)&unk_10144E20E, (_DWORD **)&__p)[5][61];
  uint64_t v15 = *v14;
  uint64_t v16 = (std::__shared_weak_count *)v14[1];
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!*(unsigned char *)(v15 + 92))
  {
    std::string __p = &v26;
    int v17 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v26, (uint64_t)&unk_10144E20E, (_DWORD **)&__p);
    if ((unint64_t)(v17[5][62] - v17[5][61]) <= 0x10)
    {
      BOOL v18 = (unint64_t)(*(uint64_t (**)(void))(**(void **)(a1 + 96) + 176))(*(void *)(a1 + 96)) > 1;
      if (!v16) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }
  }
  BOOL v18 = 1;
  if (v16) {
LABEL_19:
  }
    sub_10004D2C8(v16);
LABEL_21:
  (*(void (**)(uint64_t, uint64_t *, BOOL))(*(void *)v11 + 56))(v11, &v19, v18);
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_1009D0B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009D0BF0(uint64_t a1)
{
  unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 96) + 8);
  int v7 = &v6;
  int v2 = *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v6, (uint64_t)&unk_10144E20E, &v7)[5] + 55);
  uint64_t v3 = *(_DWORD **)(a1 + 96);
  if (v2 == v3[12] || ((*(uint64_t (**)(_DWORD *))(*(void *)v3 + 328))(v3) & 1) != 0)
  {
    sub_1009D0860(a1);
  }
  else
  {
    unsigned int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Resetting current message, encoders changed", v5, 2u);
    }
    sub_1009CE5E4(a1);
  }
}

BOOL sub_1009D0D0C(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      block[0] = &v8;
      int v3 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v8, (uint64_t)&unk_10144E20E, block)[5] + 42);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_1009F00E8;
  v9[3] = &unk_101A25570;
  void v9[4] = a1 + 8;
  void v9[5] = v7;
  os_log_t v10 = v9;
  __int16 v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = (_DWORD *)0x40000000;
  if (v4)
  {
    uint64_t v12 = sub_10005A304;
    uint64_t v13 = &unk_101A253A8;
    uint32_t v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    uint64_t v12 = sub_10005B068;
    uint64_t v13 = &unk_101A253C8;
    uint32_t v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

void sub_1009D0EAC(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    uint64_t v4 = sub_1009ED218(a3, *(long long **)(a1 + 8), a2);
    for (uint64_t i = *(void *)(a1 + 8); i != v4; i -= 16)
    {
      unsigned int v6 = *(std::__shared_weak_count **)(i - 8);
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
    *(void *)(a1 + 8) = v4;
  }
}

void sub_1009D0F20(uint64_t a1, unsigned int **a2)
{
  long long v230 = 0uLL;
  uint64_t v231 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 192))(&v230);
  unsigned int v229 = (*a2)[2];
  uint64_t v4 = (Registry **)(a1 + 80);
  if ((subscriber::isValidSimSlot() & 1) == 0) {
    goto LABEL_49;
  }
  __int16 v5 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v229);
  unsigned int v6 = (os_log_t *)v5;
  int v8 = *a2;
  int v7 = (std::__shared_weak_count *)a2[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(&buf, 0, 24);
  capabilities::ct::getSupportedMTSMSTypes((uint64_t *)&buf.var0, v5);
  if (*(_DWORD *)(a1 + 2604) == 1)
  {
    int v9 = *(_DWORD **)&buf.var0;
    if (buf.var2.__r_.__value_.var0.var1.__size_ == *(void *)&buf.var0)
    {
      if (buf.var2.__r_.__value_.var0.var1.__size_)
      {
        buf.var2.__r_.__value_.var0.var1.__data_ = (char *)buf.var2.__r_.__value_.var0.var1.__size_;
        operator delete((void *)buf.var2.__r_.__value_.var0.var1.__size_);
      }
      int v9 = operator new(4uLL);
      *(void *)&buf.var0 = v9;
      buf.var2.__r_.__value_.var0.var1.__size_ = (unint64_t)(v9 + 1);
    }
    *int v9 = 0;
    uint64_t data = (char *)(v9 + 1);
    buf.var2.__r_.__value_.var0.var1.__data_ = data;
  }
  else
  {
    uint64_t data = buf.var2.__r_.__value_.var0.var1.__data_;
  }
  uint64_t v11 = *(char **)&buf.var0;
  uint64_t v12 = data;
  if (*(char **)&buf.var0 != data)
  {
    uint64_t v13 = *(char **)&buf.var0;
    while (*(_DWORD *)v13)
    {
      v13 += 4;
      if (v13 == data)
      {
        uint64_t v13 = data;
        break;
      }
    }
    if (v13 != data) {
      goto LABEL_30;
    }
    do
    {
      if (*(_DWORD *)v11 == 2)
      {
        uint64_t v12 = v11;
        goto LABEL_22;
      }
      v11 += 4;
    }
    while (v11 != data);
    uint64_t v12 = data;
  }
LABEL_22:
  if (v12 != data)
  {
    *(void *)&long long v240 = v8;
    *((void *)&v240 + 1) = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v14 = sub_1009D5DA0(a1, (uint64_t *)&v240);
    if (v7) {
      sub_10004D2C8(v7);
    }
    if (v14) {
      goto LABEL_30;
    }
  }
  if ((*(unsigned int (**)(unsigned int *))(*(void *)v8 + 248))(v8) == 2
    || *(double *)(a1 + 2712) != 0.0)
  {
LABEL_30:
    char v15 = 1;
    goto LABEL_31;
  }
  __int16 v46 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8[2]);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v219) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "MT SMS type not handled...", (uint8_t *)&v219, 2u);
  }
  char v15 = 0;
LABEL_31:
  if (*(void *)&buf.var0)
  {
    buf.var2.__r_.__value_.var0.var1.__data_ = *(char **)&buf.var0;
    operator delete(*(void **)&buf.var0);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  if ((v15 & 1) == 0)
  {
    uint64_t v19 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    LOWORD(buf.var0) = 0;
    uint64_t v20 = "#I MT SMS of this type not supported...";
    goto LABEL_48;
  }
  uint64_t v16 = HIBYTE(v231);
  if (v231 < 0) {
    uint64_t v16 = *((void *)&v230 + 1);
  }
  if (v16) {
    goto LABEL_39;
  }
  uint64_t v22 = v229;
  unsigned __int8 v23 = *v4;
  *(void *)&long long v240 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(0, v23);
  int v25 = ServiceMap;
  if (v26 < 0)
  {
    int v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&buf.var0 = v26;
  int v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&buf);
  if (v30)
  {
    uint64_t v32 = v30[3];
    BOOL v31 = (std::__shared_weak_count *)v30[4];
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v31);
      char v33 = 0;
      goto LABEL_85;
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  std::mutex::unlock(v25);
  BOOL v31 = 0;
  char v33 = 1;
LABEL_85:
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v32 + 96))(&v219, v32, v22, 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
  sub_10004EFE4(&v240, (CFTypeRef *)&v219);
  sub_1000577C4((const void **)&v219);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  if ((void)v240) {
    uint64_t v47 = sub_100080778;
  }
  else {
    uint64_t v47 = 0;
  }
  if (v47)
  {
    *(void *)&buf.var0 = 0;
    *(void *)&long long v219 = CFDictionaryGetValue((CFDictionaryRef)v240, @"ShowEmptySMS");
    sub_1000057AC(&buf, (CFTypeRef *)&v219);
    LOBYTE(v219) = 1;
    ctu::cf::assign((ctu::cf *)&v219, *(BOOL **)&buf.var0, v48);
    int v49 = v219;
    sub_100062778((const void **)&buf);
    sub_100057D78((const void **)&v240);
    if (!v49)
    {
      uint64_t v19 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      LOWORD(buf.var0) = 0;
      uint64_t v20 = "#I SMS body is empty";
LABEL_48:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, 2u);
      goto LABEL_49;
    }
  }
  else
  {
    sub_100057D78((const void **)&v240);
  }
LABEL_39:
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 248))() == 2)
  {
    int v17 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Handling as Cell Broadcast SMS", (uint8_t *)&buf, 2u);
    }
    BOOL v18 = (std::__shared_weak_count *)a2[1];
    v227 = *a2;
    v228 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sms::Controller::handleCellBroadcast_sync(a1, (uint64_t)&v227);
    if (v228) {
      sub_10004D2C8(v228);
    }
    goto LABEL_49;
  }
  uint64_t v21 = *a2;
  if ((*a2)[12] == 2 && v21[52] == 4)
  {
    uint64_t v19 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    LOWORD(buf.var0) = 0;
    uint64_t v20 = "#I Dropping delivery ackowlegdement message";
    goto LABEL_48;
  }
  if ((*(unsigned int (**)(unsigned int *))(*(void *)v21 + 16))(v21))
  {
    uint64_t v34 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
    uint64_t v35 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
    uint64_t v36 = (*(uint64_t (**)(void))(*(void *)*a2 + 40))();
    uint64_t v37 = v36;
    uint64_t v38 = *a2;
    if ((*a2)[9] == 2)
    {
      uint64_t v38 = (unsigned int *)v38[10];
      if (v38 == 2)
      {
        uint64_t v39 = *(void *)(a1 + 112);
        uint64_t v40 = v229;
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 0x40000000;
        aBlock[2] = sub_1009E7CC8;
        aBlock[3] = &unk_101A24F10;
        aBlock[4] = a1;
        void aBlock[5] = v6;
        char v224 = v34;
        char v225 = v35;
        unsigned int v222 = v229;
        int v223 = v36;
        v226 = _Block_copy(aBlock);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **))(*(void *)v39 + 144))(v39, v40, v34, v37, &v226);
        if (v226) {
          _Block_release(v226);
        }
LABEL_107:
        int v60 = v229;
        (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
          __int16 v61 = buf.var2.__r_.__value_.var0.var0.__data_[15];
        }
        else {
          __int16 v61 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
        }
        *(void *)&long long v240 = &v229;
        BOOL v62 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
        uint64_t v64 = *v62;
        uint64_t v63 = v62[1];
        int TransportType = sms::Model::getTransportType((sms::Model *)*a2);
        sms::Controller::submitSMSReceivedMetric(a1, v60, v61, (v63 - v64) >> 4, 1u, TransportType, 0);
        if ((buf.var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
          goto LABEL_49;
        }
        int v66 = *(void **)&buf.var0;
LABEL_333:
        operator delete(v66);
        goto LABEL_49;
      }
    }
    char v50 = (std::mutex *)Registry::getServiceMap((uint64_t *)v38, *v4);
    char v51 = v50;
    if (v52 < 0)
    {
      unsigned int v53 = (unsigned __int8 *)(v52 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v54 = 5381;
      do
      {
        uint64_t v52 = v54;
        unsigned int v55 = *v53++;
        uint64_t v54 = (33 * v54) ^ v55;
      }
      while (v55);
    }
    std::mutex::lock(v50);
    *(void *)&buf.var0 = v52;
    unint64_t v56 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)&buf);
    if (v56)
    {
      uint64_t v58 = v56[3];
      char v57 = (std::__shared_weak_count *)v56[4];
      if (v57)
      {
        atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v51);
        atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v57);
        char v59 = 0;
LABEL_103:
        if (v58) {
          (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v58 + 16))(v58, v229, v34, v35, v37, 1);
        }
        if ((v59 & 1) == 0) {
          sub_10004D2C8(v57);
        }
        goto LABEL_107;
      }
    }
    else
    {
      uint64_t v58 = 0;
    }
    std::mutex::unlock(v51);
    char v57 = 0;
    char v59 = 1;
    goto LABEL_103;
  }
  long long v219 = 0uLL;
  uint64_t v220 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 256))(&v219);
  *(void *)v239 = 0;
  if (v220 >= 0) {
    std::string v41 = (const UInt8 *)&v219;
  }
  else {
    std::string v41 = (const UInt8 *)v219;
  }
  if (v220 >= 0) {
    CFIndex v42 = HIBYTE(v220);
  }
  else {
    CFIndex v42 = *((void *)&v219 + 1);
  }
  *(void *)v239 = CFStringCreateWithBytesNoCopy(0, v41, v42, 0x8000100u, 0, kCFAllocatorNull);
  if (*(void *)v239) {
    uint64_t v43 = sub_1000810B8;
  }
  else {
    uint64_t v43 = 0;
  }
  if (!v43)
  {
    int v44 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      uint64_t v138 = v220 >= 0 ? (ctu *)&v219 : (ctu *)v219;
      uint64_t v139 = v220 >= 0 ? (const void *)HIBYTE(v220) : (const void *)*((void *)&v219 + 1);
      ctu::hex((uint64_t *)&buf.var0, v138, v139, v45);
      char v140 = buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &buf : *(CSIPhoneNumber **)&buf.var0;
      LODWORD(v240) = 136315138;
      *(void *)((char *)&v240 + 4) = v140;
      _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Detected non UTF-8 address string: %s", (uint8_t *)&v240, 0xCu);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
    }
    if (SHIBYTE(v220) < 0)
    {
      *(unsigned char *)long long v219 = 0;
      *((void *)&v219 + 1) = 0;
    }
    else
    {
      LOBYTE(v219) = 0;
      HIBYTE(v220) = 0;
    }
  }
  sub_1000558F4((const void **)v239);
  uint64_t v67 = v229;
  (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 320))(&buf);
  time_t v202 = sub_100795B00(v67, (Registry **)(a1 + 80), (uint64_t)&buf);
  xpc_object_t v69 = (std::mutex *)Registry::getServiceMap(v68, *v4);
  uint64_t v70 = v69;
  if (v71 < 0)
  {
    unsigned int v72 = (unsigned __int8 *)(v71 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v73 = 5381;
    do
    {
      uint64_t v71 = v73;
      unsigned int v74 = *v72++;
      uint64_t v73 = (33 * v73) ^ v74;
    }
    while (v74);
  }
  std::mutex::lock(v69);
  *(void *)&buf.var0 = v71;
  uint64_t v75 = sub_10004D37C(&v70[1].__m_.__sig, (unint64_t *)&buf);
  if (v75)
  {
    uint64_t v77 = v75[3];
    uint64_t v76 = (std::__shared_weak_count *)v75[4];
    if (v76)
    {
      atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v70);
      atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v76);
      char v78 = 0;
      goto LABEL_121;
    }
  }
  else
  {
    uint64_t v77 = 0;
  }
  std::mutex::unlock(v70);
  uint64_t v76 = 0;
  char v78 = 1;
LABEL_121:
  if (v77)
  {
    int v79 = (std::__shared_weak_count *)a2[1];
    v217 = (sms::Model *)*a2;
    v218 = v79;
    if (v79) {
      atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v80 = (**(uint64_t (***)(uint64_t, sms::Model **))v77)(v77, &v217);
    if (v218)
    {
      sub_10004D2C8(v218);
      if (v80)
      {
LABEL_126:
        xpc_object_t v81 = *v6;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I Handling as Terminal Registration response...", (uint8_t *)&buf, 2u);
        }
        int v82 = v229;
        (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
          __int16 v83 = buf.var2.__r_.__value_.var0.var0.__data_[15];
        }
        else {
          __int16 v83 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
        }
        *(void *)&long long v240 = &v229;
        long long v84 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
        uint64_t v86 = *v84;
        uint64_t v85 = v84[1];
        int v87 = sms::Model::getTransportType((sms::Model *)*a2);
        sms::Controller::submitSMSReceivedMetric(a1, v82, v83, (v85 - v86) >> 4, 3u, v87, 0);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
          operator delete(*(void **)&buf.var0);
        }
        uint64_t v88 = (std::__shared_weak_count *)a2[1];
        v215 = (sms::Model *)*a2;
        v216 = v88;
        if (v88) {
          atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, sms::Model **))(*(void *)v77 + 8))(v77, &v215);
        if (v216) {
          sub_10004D2C8(v216);
        }
        goto LABEL_329;
      }
    }
    else if (v80)
    {
      goto LABEL_126;
    }
  }
  uint64_t v89 = (*a2)[2];
  if (subscriber::isValidSimSlot())
  {
    memset(&buf, 0, 24);
    sms::Controller::getDynamicMessageModes_sync(a1, v89, (uint64_t *)&buf.var0);
    long long v90 = *(char **)&buf.var0;
    if (*(char **)&buf.var0 != buf.var2.__r_.__value_.var0.var1.__data_)
    {
      while (*(_DWORD *)v90 != 1)
      {
        v90 += 4;
        if (v90 == buf.var2.__r_.__value_.var0.var1.__data_)
        {
          long long v90 = buf.var2.__r_.__value_.var0.var1.__data_;
          break;
        }
      }
    }
    if (v90 == buf.var2.__r_.__value_.var0.var1.__data_) {
      goto LABEL_169;
    }
    sub_1007958D8(v89, (Registry **)(a1 + 80), (uint64_t *)&v240);
    if (v220 >= 0) {
      uint64_t v91 = HIBYTE(v220);
    }
    else {
      uint64_t v91 = *((void *)&v219 + 1);
    }
    uint64_t v92 = HIBYTE(v241);
    int v93 = SHIBYTE(v241);
    if (v241 < 0) {
      uint64_t v92 = *((void *)&v240 + 1);
    }
    if (v91 == v92)
    {
      if (v241 >= 0) {
        long long v94 = &v240;
      }
      else {
        long long v94 = (long long *)v240;
      }
      if (v220 < 0)
      {
        BOOL v103 = memcmp((const void *)v219, v94, *((size_t *)&v219 + 1)) == 0;
      }
      else if (HIBYTE(v220))
      {
        uint64_t v95 = HIBYTE(v220) - 1;
        uint64_t v96 = &v219;
        do
        {
          int v98 = *(unsigned __int8 *)v96;
          uint64_t v96 = (long long *)((char *)v96 + 1);
          int v97 = v98;
          int v100 = *(unsigned __int8 *)v94;
          long long v94 = (long long *)((char *)v94 + 1);
          int v99 = v100;
          BOOL v102 = v95-- != 0;
          BOOL v103 = v97 == v99;
        }
        while (v97 == v99 && v102);
      }
      else
      {
        BOOL v103 = 1;
      }
    }
    else
    {
      BOOL v103 = 0;
    }
    if (v93 < 0) {
      operator delete((void *)v240);
    }
    if (!v103)
    {
LABEL_169:
      int v104 = 0;
    }
    else
    {
      (*(void (**)(void, uint64_t, long long *, time_t))(**(void **)(a1 + 2528) + 80))(*(void *)(a1 + 2528), v89, &v230, v202);
      int v104 = 1;
    }
    if (*(void *)&buf.var0)
    {
      buf.var2.__r_.__value_.var0.var1.__data_ = *(char **)&buf.var0;
      operator delete(*(void **)&buf.var0);
    }
    if (v104)
    {
      int v105 = *v6;
      if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "#I Handling SMS as MMS", (uint8_t *)&buf, 2u);
      }
      int v106 = v229;
      (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        __int16 v107 = buf.var2.__r_.__value_.var0.var0.__data_[15];
      }
      else {
        __int16 v107 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
      }
      *(void *)&long long v240 = &v229;
      char v108 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
      uint64_t v110 = *v108;
      uint64_t v109 = v108[1];
      int v111 = sms::Model::getTransportType((sms::Model *)*a2);
      sms::Controller::submitSMSReceivedMetric(a1, v106, v107, (v109 - v110) >> 4, 8u, v111, 0);
      goto LABEL_194;
    }
  }
  unsigned int v214 = 0;
  unsigned int v214 = (*(uint64_t (**)(void))(*(void *)*a2 + 64))();
  int v112 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
  if (!(v214 | v112))
  {
    (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
    sub_100795CC4((uint64_t)&buf, &v214);
    if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      operator delete(*(void **)&buf.var0);
    }
  }
  char v201 = v78;
  (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 320))(&buf);
  time_t v113 = sub_100795A94((uint64_t)&buf);
  uint64_t v114 = v214;
  int v115 = v229;
  if (!(v214 | v112))
  {
    char v78 = v201;
    if (sub_1009E8EE4(a1, v229))
    {
      uint64_t v124 = *v6;
      if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "#I PNR SMS auto detected", (uint8_t *)&buf, 2u);
      }
      int v125 = v229;
      int v126 = (*(uint64_t (**)(void))(*(void *)*a2 + 200))();
      sub_1009E7EE8(a1, v125, (uint64_t *)&v230, 5497, v113, v126);
      int v127 = v229;
      (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        __int16 v128 = buf.var2.__r_.__value_.var0.var0.__data_[15];
      }
      else {
        __int16 v128 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
      }
      *(void *)&long long v240 = &v229;
      uint64_t v129 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
      uint64_t v131 = *v129;
      uint64_t v130 = v129[1];
      int v132 = sms::Model::getTransportType((sms::Model *)*a2);
      sms::Controller::submitSMSReceivedMetric(a1, v127, v128, (v130 - v131) >> 4, 2u, v132, 0);
      goto LABEL_194;
    }
    uint64_t v133 = (*a2)[2];
    int v134 = (*(uint64_t (**)(unsigned int *))(*(void *)*a2 + 344))(*a2);
    if (sub_1009E90D4(a1, v133, (uint64_t)&v230, (unsigned __int8 *)&v219, v134))
    {
      int v135 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_329;
      }
      LOWORD(buf.var0) = 0;
      long long v136 = "#I VVM Indicator filtered";
LABEL_205:
      _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, v136, (uint8_t *)&buf, 2u);
      goto LABEL_329;
    }
    if (!sub_1009E9AB8(a1, v229, (uint64_t)&v219))
    {
      int v135 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_329;
      }
      LOWORD(buf.var0) = 0;
      long long v136 = "#I Filtering out, SMS not allowed on unsupported devices";
      goto LABEL_205;
    }
    if ((*(unsigned int (**)(void))(*(void *)*a2 + 224))())
    {
      int v135 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_329;
      }
      LOWORD(buf.var0) = 0;
      long long v136 = "#I Not handling a Type-0 SMS";
      goto LABEL_205;
    }
    v213 = 0;
    if (v231 >= 0) {
      long long v141 = (const __CFString **)&v230;
    }
    else {
      long long v141 = (const __CFString **)v230;
    }
    *(void *)v239 = 0;
    *(void *)&long long v240 = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&v240, v141, (const char *)0x8000100, kCFAllocatorDefault, v137))
    {
      uint64_t v142 = *(void *)v239;
      *(void *)v239 = v240;
      *(void *)&buf.var0 = v142;
      sub_1000558F4((const void **)&buf);
    }
    v213 = *(const void **)v239;
    *(void *)v239 = 0;
    sub_1000558F4((const void **)v239);
    if (v213) {
      long long v143 = sub_1000810B8;
    }
    else {
      long long v143 = 0;
    }
    if (!v143)
    {
      long long v145 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "#I Failed to convert SMS body to utf8 string, bailing out", (uint8_t *)&buf, 2u);
      }
      if (SHIBYTE(v231) < 0)
      {
        size_t v146 = *((void *)&v230 + 1);
        long long v147 = (char *)v230;
      }
      else
      {
        size_t v146 = HIBYTE(v231);
        long long v147 = (char *)&v230;
      }
      memset(&buf, 0, 24);
      sub_10014BD54((char *)&buf, v147, &v147[v146], v146);
      long long v240 = 0uLL;
      uint64_t v241 = 0;
      sub_1009D7F94((uint64_t *)&v240, (uint64_t)&buf);
      long long v154 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v155 = HIBYTE(v241);
        long long v156 = &v240;
        if (v241 < 0)
        {
          uint64_t v155 = *((void *)&v240 + 1);
          long long v156 = (long long *)v240;
        }
        *(_DWORD *)v239 = 136315394;
        *(void *)&v239[4] = v156;
        *(_WORD *)&v239[12] = 2048;
        *(void *)&v239[14] = v155;
        _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "#I pdu = %s len = %lu ", v239, 0x16u);
      }
      if (SHIBYTE(v241) < 0) {
        operator delete((void *)v240);
      }
      if (*(void *)&buf.var0)
      {
        buf.var2.__r_.__value_.var0.var1.__data_ = *(char **)&buf.var0;
        operator delete(*(void **)&buf.var0);
      }
      goto LABEL_328;
    }
    if (*(unsigned char *)(a1 + 160))
    {
      (*(void (**)(void, void, long long *, long long *))(**(void **)(a1 + 2528) + 32))(*(void *)(a1 + 2528), v229, &v230, &v219);
      char v144 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "#I Handling as test SMS", (uint8_t *)&buf, 2u);
      }
      goto LABEL_328;
    }
    long long v240 = 0uLL;
    sub_1008FB518(*v4, (uint64_t *)&v240);
    uint64_t v148 = v240;
    if ((void)v240)
    {
      uint64_t v149 = v229;
      *(void *)v239 = @"SMSSettings";
      *(void *)&v239[8] = @"ShowClass0SMSInLockScreen";
      sub_100367E88(&buf, v239, 2uLL);
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, CSIPhoneNumber *, const CFBooleanRef, void))(*(void *)v148 + 104))(&cf, v148, v149, 2, &buf, kCFBooleanFalse, 0);
      long long v150 = (BOOL *)cf;
      LOBYTE(v212[0]) = 0;
      if (cf)
      {
        CFTypeID v151 = CFGetTypeID(cf);
        if (v151 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)v212, v150, v152);
        }
      }
      BOOL v153 = LOBYTE(v212[0]) != 0;
      sub_1000577C4(&cf);
      if (*(void *)&buf.var0)
      {
        buf.var2.__r_.__value_.var0.var1.__data_ = *(char **)&buf.var0;
        operator delete(*(void **)&buf.var0);
      }
    }
    else
    {
      long long v157 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.var0) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_ERROR, "Invalid carrier interface while reading flash sms settings", (uint8_t *)&buf, 2u);
      }
      BOOL v153 = 0;
    }
    if (*((void *)&v240 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v240 + 1));
    }
    if ((*(unsigned int (**)(void))(*(void *)*a2 + 240))())
    {
      if (v153 || !*(unsigned char *)(a1 + 2373))
      {
        long long v159 = *v6;
        if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I Handling as Class 0 SMS", (uint8_t *)&buf, 2u);
        }
        (*(void (**)(void, void, long long *, long long *))(**(void **)(a1 + 2528) + 40))(*(void *)(a1 + 2528), v229, &v230, &v219);
        int v160 = v229;
        (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
          __int16 v161 = buf.var2.__r_.__value_.var0.var0.__data_[15];
        }
        else {
          __int16 v161 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
        }
        *(void *)&long long v240 = &v229;
        long long v162 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
        uint64_t v164 = *v162;
        uint64_t v163 = v162[1];
        int v165 = sms::Model::getTransportType((sms::Model *)*a2);
        sms::Controller::submitSMSReceivedMetric(a1, v160, v161, (v163 - v164) >> 4, 9u, v165, 0);
        if ((buf.var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
          goto LABEL_327;
        }
        long long v166 = *(void **)&buf.var0;
        goto LABEL_326;
      }
      long long v158 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        buf.var0 = 136315394;
        *(void *)&buf.var1 = "false";
        WORD2(buf.var2.__r_.__value_.var0.var1.__data_) = 2080;
        *(char **)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 6) = "Locked";
        _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I Class 0 SMS treated as regular SMS [bundle: %s, screen: %s]", (uint8_t *)&buf, 0x16u);
      }
    }
    unsigned int v198 = (*(uint64_t (**)(unsigned int *))(*(void *)*a2 + 272))(*a2);
    *(_DWORD *)((char *)v212 + 3) = 0;
    v212[0] = 0;
    if ((*(unsigned int (**)(unsigned int *))(*(void *)*a2 + 280))(*a2))
    {
      uint64_t v238 = 0;
      long long v236 = 0u;
      long long v237 = 0u;
      long long v234 = 0u;
      long long v235 = 0u;
      long long v233 = 0u;
      memset(&buf, 0, sizeof(buf));
      (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 288))(&buf);
      CSIPhoneNumber::getFullNumber((uint64_t *)&v240, &buf);
      v197 = (void *)*((void *)&v240 + 1);
      __src = (void *)v240;
      v212[0] = v241;
      *(_DWORD *)((char *)v212 + 3) = *(_DWORD *)((char *)&v241 + 3);
      char v200 = HIBYTE(v241);
      sub_100087E24((uint64_t)&buf);
    }
    else
    {
      __src = 0;
      v197 = 0;
      char v200 = 0;
    }
    double v167 = *(double *)(a1 + 2712);
    uint64_t v168 = *v6;
    BOOL v169 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
    if (v167 == 0.0)
    {
      if (v169)
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "#I Handling as regular SMS", (uint8_t *)&buf, 2u);
      }
      int v180 = v229;
      (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        __int16 v181 = buf.var2.__r_.__value_.var0.var0.__data_[15];
      }
      else {
        __int16 v181 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
      }
      *(void *)&long long v240 = &v229;
      long long v182 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
      uint64_t v184 = *v182;
      uint64_t v183 = v182[1];
      int v185 = sms::Model::getTransportType((sms::Model *)*a2);
      sms::Controller::submitSMSReceivedMetric(a1, v180, v181, (v183 - v184) >> 4, 4u, v185, 0);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
    }
    else
    {
      if (v169)
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "#I Handling as emergency SMS", (uint8_t *)&buf, 2u);
      }
      memset(&buf, 0, 24);
      *(void *)&long long v240 = &v229;
      v170 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240);
      sub_10082FE4C((uint64_t)v170[5], (uint64_t *)&buf.var0);
      LOBYTE(v240) = 0;
      if (&buf.var2 == (basic_string<char, std::char_traits<char>, std::allocator<char>> *)sub_1000D85D4(*(void **)&buf.var0, &buf.var2.__r_.__value_.var0.var1.__data_, (unsigned __int8 **)&v219))
      {
        *(void *)&long long v240 = &v229;
        long long v171 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240);
        sub_100046BAC((uint64_t **)v171[5] + 67, (void **)&v219, (uint64_t)&v219);
        long long v172 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          long long v173 = &v219;
          if (v220 < 0) {
            long long v173 = (long long *)v219;
          }
          LODWORD(v240) = 136315138;
          *(void *)((char *)&v240 + 4) = v173;
          _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "#I Emergency Text: Added %s to the list of emergency numbers", (uint8_t *)&v240, 0xCu);
        }
      }
      int v196 = v229;
      (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 192))(&v240);
      if (v241 >= 0) {
        __int16 v174 = HIBYTE(v241);
      }
      else {
        __int16 v174 = WORD4(v240);
      }
      *(void *)v239 = &v229;
      long long v175 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)v239)[5];
      uint64_t v176 = *v175;
      uint64_t v177 = v175[1];
      int v178 = sms::Model::getTransportType((sms::Model *)*a2);
      BOOL v179 = sub_10001D294((unsigned __int8 *)&v219, (unsigned __int8 *)(a1 + 176));
      sms::Controller::submitSMSReceivedMetric(a1, v196, v174, (v177 - v176) >> 4, 6u, v178, v179);
      if (SHIBYTE(v241) < 0) {
        operator delete((void *)v240);
      }
      sub_10005CD2C((uint64_t)&buf, buf.var2.__r_.__value_.var0.var1.__data_);
    }
    uint64_t v186 = *(void *)(a1 + 2512);
    if (v186)
    {
      uint64_t v187 = a1 + 2512;
      do
      {
        signed int v188 = *(_DWORD *)(v186 + 28);
        BOOL v189 = v188 < (int)v229;
        if (v188 >= (int)v229) {
          long long v190 = (uint64_t *)v186;
        }
        else {
          long long v190 = (uint64_t *)(v186 + 8);
        }
        if (!v189) {
          uint64_t v187 = v186;
        }
        uint64_t v186 = *v190;
      }
      while (*v190);
      if (v187 != a1 + 2512 && (signed int)v229 >= *(_DWORD *)(v187 + 28))
      {
        long long v191 = sub_10012EF5C(a1 + 2504, (int *)&v229);
        long long v192 = (uint64_t *)*(unsigned __int8 *)v191;
        if (*(unsigned char *)v191)
        {
          *(void *)v239 = 0;
          *(void *)&v239[8] = 0;
          sub_1009E9F8C(*v4, v239, v192);
          CFTypeRef cf = 0;
          v211 = 0;
          if (*(void *)v239)
          {
            (*(void (**)(CFTypeRef *__return_ptr))(**(void **)v239 + 16))(&cf);
            if (cf) {
              sub_100562588();
            }
          }
          uint64_t v193 = *v6;
          if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.var0) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_ERROR, "Failed to find lazuli manager...", (uint8_t *)&buf, 2u);
          }
          if (v211) {
            sub_10004D2C8(v211);
          }
          if (*(void *)&v239[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v239[8]);
          }
        }
      }
    }
    uint64_t v194 = *(void *)(a1 + 2528);
    uint64_t v195 = v229;
    if (SHIBYTE(v220) < 0)
    {
      sub_10004FC84(__dst, (void *)v219, *((unint64_t *)&v219 + 1));
    }
    else
    {
      *(_OWORD *)long long __dst = v219;
      uint64_t v209 = v220;
    }
    if (SHIBYTE(v231) < 0)
    {
      sub_10004FC84(v206, (void *)v230, *((unint64_t *)&v230 + 1));
    }
    else
    {
      *(_OWORD *)v206 = v230;
      uint64_t v207 = v231;
    }
    if (v200 < 0)
    {
      sub_10004FC84(v203, __src, (unint64_t)v197);
    }
    else
    {
      v203[0] = __src;
      v203[1] = v197;
      *(_DWORD *)v204 = v212[0];
      *(_DWORD *)&v204[3] = *(_DWORD *)((char *)v212 + 3);
      char v205 = v200;
    }
    (*(void (**)(uint64_t, uint64_t, void **, void **, void **, time_t, time_t, void, _BYTE))(*(void *)v194 + 72))(v194, v195, __dst, v206, v203, v202, v202, v198, *((unsigned char *)*a2 + 184));
    if (v205 < 0) {
      operator delete(v203[0]);
    }
    if (SHIBYTE(v207) < 0) {
      operator delete(v206[0]);
    }
    if (SHIBYTE(v209) < 0) {
      operator delete(__dst[0]);
    }
    if ((v200 & 0x80) == 0) {
      goto LABEL_327;
    }
    long long v166 = __src;
LABEL_326:
    operator delete(v166);
LABEL_327:
    char v78 = v201;
LABEL_328:
    sub_1000558F4(&v213);
    goto LABEL_329;
  }
  int v116 = (*(uint64_t (**)(void))(*(void *)*a2 + 200))();
  unsigned int v117 = sub_1009E7EE8(a1, v115, (uint64_t *)&v230, v114, v113, v116);
  int v118 = v229;
  char v78 = v201;
  (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)*a2 + 192))(&buf);
  if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
    __int16 v119 = buf.var2.__r_.__value_.var0.var0.__data_[15];
  }
  else {
    __int16 v119 = *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_;
  }
  *(void *)&long long v240 = &v229;
  long long v120 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v229, (uint64_t)&unk_10144E20E, (_DWORD **)&v240)[5];
  uint64_t v122 = *v120;
  uint64_t v121 = v120[1];
  int v123 = sms::Model::getTransportType((sms::Model *)*a2);
  sms::Controller::submitSMSReceivedMetric(a1, v118, v119, (v121 - v122) >> 4, v117, v123);
LABEL_194:
  if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
    operator delete(*(void **)&buf.var0);
  }
LABEL_329:
  if ((v78 & 1) == 0) {
    sub_10004D2C8(v76);
  }
  if (SHIBYTE(v220) < 0)
  {
    int v66 = (void *)v219;
    goto LABEL_333;
  }
LABEL_49:
  if (SHIBYTE(v231) < 0) {
    operator delete((void *)v230);
  }
}

void sub_1009D304C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, char a14, __int16 a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,uint64_t a32,const void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *aBlock,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,void *__p)
{
  if (a68 < 0) {
    operator delete(__p);
  }
  if (a31) {
    sub_10004D2C8(a31);
  }
  uint64_t v71 = *(std::__shared_weak_count **)(v69 - 168);
  if (v71) {
    sub_10004D2C8(v71);
  }
  if (a14 < 0) {
    operator delete(a13);
  }
  sub_1000558F4(&a33);
  if ((a16 & 1) == 0) {
    sub_10004D2C8(v68);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a62 < 0) {
    operator delete(a57);
  }
  _Unwind_Resume(a1);
}

void sub_1009D343C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1009ED218((long long *)(a2 + 16), *(long long **)(a1 + 8), a2);
  for (uint64_t i = *(void *)(a1 + 8); i != v3; i -= 16)
  {
    __int16 v5 = *(std::__shared_weak_count **)(i - 8);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  *(void *)(a1 + 8) = v3;
}

void sub_1009D34A0(uint64_t a1, int a2)
{
  unsigned int v17 = a2;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (sub_1009CE4FC(a1, a2))
  {
    __int16 v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I handleSegmentSent, current message was purged", buf, 2u);
    }
    sub_1009CE5E4(a1);
  }
  else
  {
    *(void *)CSIPhoneNumber buf = &v17;
    unsigned int v6 = (uint64_t *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v17, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][61];
    uint64_t v8 = *v6;
    int v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8 && (int v9 = *(sms::Model **)(a1 + 96)) != 0)
    {
      unsigned int v10 = v17;
      int TransportType = sms::Model::getTransportType(v9);
      sms::Controller::submitSMSSendEndMetric(a1, v10, TransportType, *(_DWORD *)(v8 + 8), (unsigned __int8 *)(v8 + 40), 0, 0);
    }
    else
    {
      uint64_t v12 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CSIPhoneNumber buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to submit send end metric. Invalid pending message.", buf, 2u);
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 96) + 160))(*(void *)(a1 + 96));
    uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 176))(*(void *)(a1 + 96));
    uint64_t v14 = v17;
    unsigned int v15 = sub_1009DD3A0(a1, v17);
    sub_1009DCDFC(a1, v14, v15, 1);
    if (v13)
    {
      uint64_t v16 = *v4;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CSIPhoneNumber buf = 134217984;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I handleSegmentSent - Num segments remaining = %lu", buf, 0xCu);
      }
      *(unsigned char *)(*(void *)(a1 + 96) + 54) = 0;
      sub_1009D0860(a1);
    }
    else
    {
      *(void *)CSIPhoneNumber buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      sub_1009D0128(a1, v17, 0, (long long *)buf);
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
}

void sub_1009D3744(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009D376C(uint64_t a1, uint64_t a2)
{
  if (sms::Model::getTransportType(*(sms::Model **)(a1 + 96)) != 2) {
    return 2;
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v4 = *(uint64_t **)(a1 + 2552);
  if (!v4) {
LABEL_8:
  }
    sub_1000C14F0("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v5 = *((_DWORD *)v4 + 8);
      if (v5 <= (int)a2) {
        break;
      }
      uint64_t v4 = (uint64_t *)*v4;
      if (!v4) {
        goto LABEL_8;
      }
    }
    if (v5 >= (int)a2) {
      break;
    }
    uint64_t v4 = (uint64_t *)v4[1];
    if (!v4) {
      goto LABEL_8;
    }
  }
  if (!*(unsigned char *)(v4[5] + 42)) {
    return 2;
  }
  unsigned int v6 = (uint64_t *)operator new(0x18uLL);
  uint64_t v24 = v6 + 3;
  int v25 = v6 + 3;
  *(_OWORD *)unsigned int v6 = *(_OWORD *)off_1019C4448;
  void v6[2] = @"MaxRetries";
  std::string __p = v6;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6 + 3, *(Registry **)(a1 + 80));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&cf);
  if (!v13)
  {
    std::mutex::unlock(v8);
    goto LABEL_19;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
    std::mutex::unlock(v8);
    if (v15) {
      goto LABEL_21;
    }
LABEL_19:
    uint64_t v16 = 2;
    goto LABEL_34;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  if (!v15)
  {
    uint64_t v16 = 2;
    goto LABEL_33;
  }
LABEL_21:
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v15 + 104))(&cf, v15, a2, 1, &__p, 0, 0);
  unsigned int v17 = (unsigned __int8 *)cf;
  if (cf) {
    BOOL v18 = sub_100080934;
  }
  else {
    BOOL v18 = 0;
  }
  if (v18)
  {
    unsigned __int8 v26 = 2;
    if (cf && (CFTypeID v19 = CFGetTypeID(cf), v19 == CFNumberGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)&v26, v17, v20);
      unsigned int v21 = v26;
    }
    else
    {
      unsigned int v21 = 2;
    }
    if (v21 >= 2) {
      uint64_t v16 = 2;
    }
    else {
      uint64_t v16 = v21;
    }
    sub_1000577C4(&cf);
    if (!v14) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  sub_1000577C4(&cf);
  uint64_t v16 = 2;
  if (v14) {
LABEL_33:
  }
    sub_10004D2C8(v14);
LABEL_34:
  if (__p)
  {
    uint64_t v24 = __p;
    operator delete(__p);
  }
  return v16;
}

void sub_1009D39E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000577C4(&a14);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009D3A28(uint64_t a1, uint64_t a2, long long *a3)
{
  unsigned int v171 = a2;
  unsigned int v6 = (Registry **)(a1 + 80);
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  int v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (sub_1009CE4FC(a1, a2))
  {
    uint64_t v8 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Current message was purged", buf, 2u);
    }
    sub_1009CE5E4(a1);
    return;
  }
  *(void *)CSIPhoneNumber buf = &v171;
  long long v157 = (uint64_t **)(a1 + 2544);
  uint64_t v9 = (uint64_t *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v171, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][61];
  unsigned int v10 = (std::__shared_weak_count *)v9[1];
  uint64_t v162 = *v9;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v170 = *a3;
  int v160 = v10;
  __int16 v161 = v7;
  if (HIDWORD(v170) != 3)
  {
    int v24 = 0;
    goto LABEL_81;
  }
  int v158 = BYTE8(v170);
  uint64_t v11 = v171;
  CFStringRef SmsTypeBundleReference = (const __CFString *)getSmsTypeBundleReference();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *v6);
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    unsigned int v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CSIPhoneNumber buf = v16;
  CFNumberRef v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (!v20)
  {
    std::mutex::unlock(v15);
    int v23 = BYTE8(v170);
    goto LABEL_75;
  }
  CFDictionaryRef v21 = (const __CFDictionary *)v20[3];
  uint64_t v22 = (std::__shared_weak_count *)v20[4];
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v15);
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
    int v23 = BYTE8(v170);
    if (!v21) {
      goto LABEL_74;
    }
    CFDictionaryRef theDict = v21;
    long long v173 = v22;
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    std::mutex::unlock(v15);
    int v23 = BYTE8(v170);
    if (!v21) {
      goto LABEL_75;
    }
    CFDictionaryRef theDict = v21;
    long long v173 = 0;
  }
  int v25 = sub_10079776C(v11, &theDict, SmsTypeBundleReference, v170);
  if (v173) {
    sub_10004D2C8(v173);
  }
  *(void *)&long long v177 = v21;
  *((void *)&v177 + 1) = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v26 = sub_1007977E8(v11, &v177, SmsTypeBundleReference, v170);
  if (*((void *)&v177 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v177 + 1));
  }
  int v27 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
  uint64_t v28 = *(void *)(a1 + 2440);
  if (!v28) {
    goto LABEL_36;
  }
  uint64_t v29 = a1 + 2440;
  do
  {
    int v30 = *(_DWORD *)(v28 + 28);
    BOOL v31 = v30 < (int)v11;
    if (v30 >= (int)v11) {
      uint64_t v32 = (uint64_t *)v28;
    }
    else {
      uint64_t v32 = (uint64_t *)(v28 + 8);
    }
    if (!v31) {
      uint64_t v29 = v28;
    }
    uint64_t v28 = *v32;
  }
  while (*v32);
  if (v29 != a1 + 2440 && *(_DWORD *)(v29 + 28) <= (int)v11) {
    BOOL v33 = *(_DWORD *)(v29 + 32) == 4;
  }
  else {
LABEL_36:
  }
    BOOL v33 = 0;
  uint64_t v34 = *(void *)(a1 + 2464);
  if (!v34) {
    goto LABEL_47;
  }
  uint64_t v35 = a1 + 2464;
  do
  {
    int v36 = *(_DWORD *)(v34 + 28);
    BOOL v37 = v36 < (int)v11;
    if (v36 >= (int)v11) {
      uint64_t v38 = (uint64_t *)v34;
    }
    else {
      uint64_t v38 = (uint64_t *)(v34 + 8);
    }
    if (!v37) {
      uint64_t v35 = v34;
    }
    uint64_t v34 = *v38;
  }
  while (*v38);
  if (v35 != a1 + 2464 && *(_DWORD *)(v35 + 28) <= (int)v11)
  {
    int v50 = *(unsigned __int8 *)(v35 + 32);
    if (v50) {
      int v40 = 1;
    }
    else {
      int v40 = v33;
    }
    int v39 = 2 * v50;
  }
  else
  {
LABEL_47:
    int v39 = 0;
    int v40 = v33;
  }
  int v41 = v40 ^ 1;
  if (v33) {
    int v42 = 4;
  }
  else {
    int v42 = 0;
  }
  int v43 = v39 | v41 | v42;
  if (!BYTE8(v170) && v25)
  {
    int v44 = v43 & v25;
    BYTE8(v170) = v44 != 0;
    if (v44)
    {
      unint64_t v45 = *v27;
      if (os_log_type_enabled(*v27, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v46 = @"?";
        if (SmsTypeBundleReference) {
          CFStringRef v46 = SmsTypeBundleReference;
        }
        *(_DWORD *)CSIPhoneNumber buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v170;
        *(_WORD *)&uint8_t buf[8] = 2112;
        *(void *)&buf[10] = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I RP-Error %d now being considered fatal for sms type: %@", buf, 0x12u);
      }
      goto LABEL_66;
    }
    int v23 = 0;
LABEL_73:
    if (!v22) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }
  int v23 = BYTE8(v170);
  if (!BYTE8(v170)) {
    goto LABEL_73;
  }
  int v23 = BYTE8(v170);
  if (!v26) {
    goto LABEL_73;
  }
  int v47 = v43 & v26;
  BYTE8(v170) = v47 == 0;
  if (!v47)
  {
LABEL_66:
    int v23 = 1;
    goto LABEL_73;
  }
  CFBooleanRef v48 = *v27;
  int v23 = 0;
  if (!os_log_type_enabled(*v27, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_73;
  }
  CFStringRef v49 = @"?";
  if (SmsTypeBundleReference) {
    CFStringRef v49 = SmsTypeBundleReference;
  }
  *(_DWORD *)CSIPhoneNumber buf = 67109378;
  *(_DWORD *)&uint8_t buf[4] = v170;
  *(_WORD *)&uint8_t buf[8] = 2114;
  *(void *)&buf[10] = v49;
  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I RP-Error %d now being considered non-fatal for sms type: %{public}@", buf, 0x12u);
  int v23 = 0;
  if (!v22)
  {
    int v24 = 0;
LABEL_80:
    int v7 = v161;
    goto LABEL_81;
  }
LABEL_74:
  sub_10004D2C8(v22);
LABEL_75:
  int v24 = 0;
  if (v158) {
    goto LABEL_80;
  }
  int v7 = v161;
  if (v23)
  {
    char v51 = *v161;
    if (os_log_type_enabled(*v161, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I RP-Error custom updated to fatal - bailing out", buf, 2u);
    }
    int v24 = 1;
  }
LABEL_81:
  uint64_t v52 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v54 = sms::asString();
    unsigned int v55 = "true";
    *(_DWORD *)CSIPhoneNumber buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v170;
    *(_WORD *)&uint8_t buf[8] = 1024;
    if (!BYTE8(v170)) {
      unsigned int v55 = "false";
    }
    *(_DWORD *)&buf[10] = DWORD1(v170);
    *(_WORD *)&unsigned char buf[14] = 2080;
    *(void *)&uint8_t buf[16] = v55;
    *(_WORD *)BOOL v179 = 2080;
    *(void *)&v179[2] = v54;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I SMS Send Error error1: %d, error2: %d, fatal: %s, group: %s", buf, 0x22u);
    int v7 = v161;
  }
  unint64_t v56 = *(sms::Model **)(a1 + 96);
  if (v56)
  {
    unsigned int v57 = v171;
    int TransportType = sms::Model::getTransportType(v56);
    sms::Controller::submitSMSSendEndMetric(a1, v57, TransportType, *(_DWORD *)(v162 + 8), (unsigned __int8 *)(v162 + 40), HIDWORD(v170), v170);
  }
  uint64_t v59 = v171;
  int v60 = *v6;
  CFDictionaryRef theDict = 0;
  __int16 v61 = (std::mutex *)Registry::getServiceMap(v53, v60);
  BOOL v62 = v61;
  uint64_t v64 = v63;
  if (v63 < 0)
  {
    uint64_t v65 = (unsigned __int8 *)(v63 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v66 = 5381;
    do
    {
      uint64_t v64 = v66;
      unsigned int v67 = *v65++;
      uint64_t v66 = (33 * v66) ^ v67;
    }
    while (v67);
  }
  std::mutex::lock(v61);
  *(void *)CSIPhoneNumber buf = v64;
  uint64_t v68 = sub_10004D37C(&v62[1].__m_.__sig, (unint64_t *)buf);
  if (!v68)
  {
    uint64_t v70 = 0;
LABEL_95:
    std::mutex::unlock(v62);
    uint64_t v69 = 0;
    char v71 = 1;
    if (!v70) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }
  uint64_t v70 = v68[3];
  uint64_t v69 = (std::__shared_weak_count *)v68[4];
  if (!v69) {
    goto LABEL_95;
  }
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v62);
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  int v7 = v161;
  sub_10004D2C8(v69);
  char v71 = 0;
  if (v70)
  {
LABEL_96:
    (*(void (**)(BOOL **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v70 + 80))(&v176, v70, v59, 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
    sub_10004EFE4(&v177, (CFTypeRef *)&v176);
    *(void *)CSIPhoneNumber buf = theDict;
    CFDictionaryRef theDict = (CFDictionaryRef)v177;
    *(void *)&long long v177 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v177);
    sub_1000577C4((const void **)&v176);
  }
LABEL_97:
  if ((v71 & 1) == 0) {
    sub_10004D2C8(v69);
  }
  if (theDict) {
    unsigned int v72 = sub_100080778;
  }
  else {
    unsigned int v72 = 0;
  }
  uint64_t v73 = v160;
  if (!v72)
  {
LABEL_110:
    sub_100057D78((const void **)&theDict);
    int v76 = sub_1009D376C(a1, v171);
    *(unsigned char *)(v162 + 117) = 1;
    CFDictionaryRef theDict = 0;
    long long v173 = 0;
    uint64_t v77 = *(void *)(a1 + 96);
    char v78 = *(std::__shared_weak_count **)(a1 + 104);
    if (v78) {
      atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1009C90B4(&theDict, a1, v77, v78);
    if (v78) {
      sub_10004D2C8(v78);
    }
    if (v24)
    {
      int v79 = BYTE8(v170);
LABEL_150:
      if (!v79)
      {
        int v106 = *(_DWORD *)(v162 + 108);
        if (v106 < v76)
        {
          *(_DWORD *)(v162 + 108) = v106 + 1;
          *(_WORD *)(v162 + 104) = sms::Model::getMessageID(*(sms::Model **)(a1 + 96));
          __int16 v107 = *(unsigned char **)(a1 + 96);
          v107[54] = *(unsigned char *)(v162 + 117);
          (*(void (**)(unsigned char *))(*(void *)v107 + 152))(v107);
          char v108 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            int v109 = *(_DWORD *)(v162 + 108);
            *(_DWORD *)CSIPhoneNumber buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v109;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v76;
            _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I re-sending segment (retry %d of max %d)", buf, 0xEu);
          }
          uint64_t v110 = *(void *)(*(void *)(a1 + 96) + 56);
          if (v110)
          {
            *(void *)CSIPhoneNumber buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            sub_1002598D0(buf, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
            Registry::getTimerService((uint64_t *)&v177, *v6);
            uint64_t v111 = v177;
            sub_100058DB0(__p, "SMS retry wait");
            int v112 = *(NSObject **)(a1 + 24);
            dispatch_object_t object = v112;
            if (v112) {
              dispatch_retain(v112);
            }
            aBlock[0] = _NSConcreteStackBlock;
            aBlock[1] = 1174405120;
            aBlock[2] = sub_1009D5470;
            aBlock[3] = &unk_101A24D80;
            time_t v113 = *(std::__shared_weak_count **)&buf[8];
            aBlock[4] = a1;
            void aBlock[5] = *(void *)buf;
            uint64_t v164 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
            }
            unsigned int v165 = v171;
            long long v166 = _Block_copy(aBlock);
            sub_100118A44(v111, (uint64_t)__p, 0, 1000000 * v110, &object, &v166);
            uint64_t v176 = (BOOL *)&v171;
            uint64_t v114 = sub_1001B0B78(v157, (int *)&v171, (uint64_t)&unk_10144E20E, (_DWORD **)&v176)[5];
            uint64_t v115 = (uint64_t)v175;
            long long v175 = 0;
            uint64_t v116 = v114[38];
            v114[38] = v115;
            if (v116)
            {
              (*(void (**)(uint64_t))(*(void *)v116 + 8))(v116);
              unsigned int v117 = v175;
              long long v175 = 0;
              if (v117) {
                (*(void (**)(const void *))(*(void *)v117 + 8))(v117);
              }
            }
            if (v166) {
              _Block_release(v166);
            }
            if (object) {
              dispatch_release(object);
            }
            if (v169 < 0) {
              operator delete(__p[0]);
            }
            if (*((void *)&v177 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v177 + 1));
            }
            int v118 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v177) = 134217984;
              *(void *)((char *)&v177 + 4) = v110;
              _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I Delaying by %llu seconds", (uint8_t *)&v177, 0xCu);
            }
            if (v164) {
              std::__shared_weak_count::__release_weak(v164);
            }
            if (v113) {
              std::__shared_weak_count::__release_weak(v113);
            }
          }
          else
          {
            sub_1009D0BF0(a1);
          }
LABEL_194:
          if (v173) {
            sub_10004D2C8(v173);
          }
          goto LABEL_196;
        }
      }
      (*(void (**)(CFDictionaryRef, void))(*(void *)theDict + 64))(theDict, v171);
      __int16 v119 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
      {
        int v136 = *(_DWORD *)(v162 + 108);
        if (v79) {
          CFAllocatorRef v137 = "true";
        }
        else {
          CFAllocatorRef v137 = "false";
        }
        if (*(unsigned char *)(*(void *)(a1 + 96) + 44)) {
          uint64_t v138 = "true";
        }
        else {
          uint64_t v138 = "false";
        }
        *(_DWORD *)CSIPhoneNumber buf = 136316162;
        *(void *)&uint8_t buf[4] = v137;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&unsigned char buf[14] = v170;
        *(_WORD *)&unsigned char buf[18] = 1024;
        *(_DWORD *)&buf[20] = DWORD1(v170);
        *(_WORD *)BOOL v179 = 1024;
        *(_DWORD *)&v179[2] = v136;
        *(_WORD *)&v179[6] = 2080;
        *(void *)&v179[8] = v138;
        _os_log_error_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "Segment failed permanently [fatal: %s, error1: %d, error2: %d, retries:%d, sent over IMS: %s]", buf, 0x28u);
      }
      uint64_t v121 = (std::mutex *)Registry::getServiceMap(v120, *v6);
      uint64_t v122 = v121;
      if (v123 < 0)
      {
        uint64_t v124 = (unsigned __int8 *)(v123 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v125 = 5381;
        do
        {
          uint64_t v123 = v125;
          unsigned int v126 = *v124++;
          uint64_t v125 = (33 * v125) ^ v126;
        }
        while (v126);
      }
      std::mutex::lock(v121);
      *(void *)CSIPhoneNumber buf = v123;
      int v127 = sub_10004D37C(&v122[1].__m_.__sig, (unint64_t *)buf);
      if (v127)
      {
        uint64_t v129 = v127[3];
        __int16 v128 = (std::__shared_weak_count *)v127[4];
        if (v128)
        {
          atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v122);
          atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
          int v7 = v161;
          sub_10004D2C8(v128);
          char v130 = 0;
          if (!v129) {
            goto LABEL_183;
          }
          goto LABEL_187;
        }
      }
      else
      {
        uint64_t v129 = 0;
      }
      std::mutex::unlock(v122);
      __int16 v128 = 0;
      char v130 = 1;
      if (!v129)
      {
LABEL_183:
        uint64_t v131 = *v7;
        if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "Failed to get Emergency Manager Interface...", buf, 2u);
        }
LABEL_191:
        if ((v130 & 1) == 0) {
          sub_10004D2C8(v128);
        }
        uint64_t v133 = v171;
        unsigned int v134 = sub_1009DD3A0(a1, v171);
        sub_1009DCDFC(a1, v133, v134, 1);
        sub_1009D0128(a1, v171, 2, &v170);
        goto LABEL_194;
      }
LABEL_187:
      if (*(unsigned char *)(*(void *)(a1 + 96) + 149))
      {
        int v132 = *v7;
        if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#I Emergency Text Cancelling Emergency Mode...", buf, 2u);
        }
        (*(void (**)(uint64_t))(*(void *)v129 + 72))(v129);
      }
      goto LABEL_191;
    }
    if (v160) {
      atomic_fetch_add_explicit(&v160->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned __int8 v80 = BYTE8(v170);
    unsigned int v174 = *(_DWORD *)(v162 + 152);
    uint64_t v81 = v174;
    int v82 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v174);
    if (sms::Model::getTransportType(*(sms::Model **)(a1 + 96)) != 2) {
      goto LABEL_139;
    }
    if (!*(unsigned char *)(*(void *)(v162 + 136) + 24))
    {
      os_log_t v85 = *v82;
      BOOL v86 = 0;
      if (!os_log_type_enabled(*v82, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_140;
      }
      *(_WORD *)CSIPhoneNumber buf = 0;
      int v87 = "#I Fallback not supported for delegate";
      goto LABEL_137;
    }
    int v83 = sub_1009D376C(a1, v81);
    long long v84 = (uint64_t *)*(unsigned int *)(v162 + 108);
    if ((int)v84 < v83 && (BYTE8(v170) & 1) == 0)
    {
      os_log_t v85 = *v82;
      BOOL v86 = 0;
      if (!os_log_type_enabled(*v82, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_140;
      }
      *(_WORD *)CSIPhoneNumber buf = 0;
      int v87 = "#I Continuing on IMS transport";
LABEL_137:
      int v99 = v85;
      uint32_t v100 = 2;
      goto LABEL_138;
    }
    if (!sub_1009DF288(*v6, v81, v84))
    {
      os_log_t v85 = *v82;
      BOOL v86 = 0;
      if (!os_log_type_enabled(*v82, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_140;
      }
      *(_WORD *)CSIPhoneNumber buf = 0;
      int v87 = "#I Transport fallback not supported";
      goto LABEL_137;
    }
    uint64_t v88 = *(void *)(a1 + 96);
    int v89 = *(_DWORD *)(v88 + 40);
    if (v89 != 2)
    {
      uint64_t v139 = *v82;
      if (os_log_type_enabled(*v82, OS_LOG_TYPE_DEFAULT))
      {
        char v140 = "Invalid Mode";
        if (v89 == 1) {
          char v140 = "IMS over Baseband";
        }
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        *(void *)&uint8_t buf[4] = v140;
        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "#I IMS over %s. Falling back to CS", buf, 0xCu);
      }
      BOOL v86 = 1;
      goto LABEL_140;
    }
    long long v90 = (std::mutex *)Registry::getServiceMap((uint64_t *)v88, *v6);
    uint64_t v91 = v90;
    if (v63 < 0)
    {
      uint64_t v92 = (unsigned __int8 *)(v63 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v93 = 5381;
      do
      {
        uint64_t v63 = v93;
        unsigned int v94 = *v92++;
        uint64_t v93 = (33 * v93) ^ v94;
      }
      while (v94);
    }
    std::mutex::lock(v90);
    *(void *)CSIPhoneNumber buf = v63;
    uint64_t v95 = sub_10004D37C(&v91[1].__m_.__sig, (unint64_t *)buf);
    if (v95)
    {
      uint64_t v97 = v95[3];
      uint64_t v96 = (std::__shared_weak_count *)v95[4];
      long long v159 = v96;
      if (v96)
      {
        uint64_t v156 = v95[3];
        BOOL v86 = 1;
        atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v91);
        atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v96);
        uint64_t v98 = v156;
        if (!v156)
        {
LABEL_233:
          sub_10004D2C8(v96);
          goto LABEL_234;
        }
LABEL_218:
        *(void *)&long long v177 = 0;
        long long v141 = operator new(8uLL);
        *(void *)CSIPhoneNumber buf = v141;
        *long long v141 = @"IMSConfig";
        *(void *)&uint8_t buf[8] = v141 + 1;
        *(void *)&uint8_t buf[16] = v141 + 1;
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v98 + 104))(&v177, v98, v81, 1, buf, 0, 0);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        uint64_t v176 = 0;
        uint64_t v142 = operator new(0x18uLL);
        *(void *)&uint8_t buf[8] = v142 + 3;
        *(void *)&uint8_t buf[16] = v142 + 3;
        *(_OWORD *)uint64_t v142 = *(_OWORD *)off_101A24FB0;
        v142[2] = @"allowCSFBInVolteMode";
        *(void *)CSIPhoneNumber buf = v142;
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v98 + 104))(&v175, v98, v81, 1, buf, 0, 0);
        sub_1000057AC(&v176, &v175);
        sub_1000577C4(&v175);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        if (v176) {
          char v144 = sub_100084B4C;
        }
        else {
          char v144 = 0;
        }
        if (v144)
        {
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, v176, v143);
          int v145 = buf[0];
          BOOL v86 = buf[0] != 0;
          size_t v146 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v81);
          if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
          {
            long long v147 = "false";
            if (v145) {
              long long v147 = "true";
            }
            *(_DWORD *)CSIPhoneNumber buf = 136315138;
            *(void *)&uint8_t buf[4] = v147;
            _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I Carrier pref for csfb: %s", buf, 0xCu);
          }
          uint64_t v96 = v159;
        }
        else
        {
          BOOL v86 = 1;
        }
        sub_100062778((const void **)&v176);
        sub_1000577C4((const void **)&v177);
        if (!v96) {
          goto LABEL_234;
        }
        goto LABEL_233;
      }
      std::mutex::unlock(v91);
      uint64_t v98 = v97;
      if (v97) {
        goto LABEL_218;
      }
    }
    else
    {
      std::mutex::unlock(v91);
    }
    BOOL v86 = 1;
LABEL_234:
    *(void *)CSIPhoneNumber buf = &v174;
    sub_1001B0B78(v157, (int *)&v174, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    int v148 = isImsTechBasedRat();
    uint64_t v149 = *v82;
    BOOL v150 = os_log_type_enabled(*v82, OS_LOG_TYPE_DEFAULT);
    if (!v148)
    {
      if (!v150) {
        goto LABEL_139;
      }
      *(void *)CSIPhoneNumber buf = &v174;
      sub_1001B0B78(v157, (int *)&v174, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      uint64_t v152 = asString();
      int v153 = sms::Model::getTransportType(*(sms::Model **)(a1 + 96));
      long long v154 = "Default Transport";
      if (v153 == 1) {
        long long v154 = "Signaling Transport";
      }
      if (v153 == 2) {
        long long v154 = "IMS Transport";
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      *(void *)&uint8_t buf[4] = v152;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v154;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)BOOL v179 = "true";
      if (v86) {
        uint64_t v155 = "true";
      }
      else {
        uint64_t v155 = "false";
      }
      *(_WORD *)&v179[8] = 2080;
      *(void *)&v179[10] = v155;
      int v87 = "#I No Fallback to CS - rat: %s, transport: %s, supports fallback: %s, supports csfb: %s";
      int v99 = v149;
      uint32_t v100 = 42;
LABEL_138:
      _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, v87, buf, v100);
LABEL_139:
      BOOL v86 = 0;
      goto LABEL_140;
    }
    if (v150)
    {
      CFTypeID v151 = "false";
      if (v86) {
        CFTypeID v151 = "true";
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v151;
      _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I Fallback to CS: %s", buf, 0xCu);
    }
LABEL_140:
    int v79 = v80;
    uint64_t v73 = v160;
    if (v160)
    {
      sub_10004D2C8(v160);
      if (!v86) {
        goto LABEL_150;
      }
    }
    else if (!v86)
    {
      goto LABEL_150;
    }
    uint64_t v101 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "#I IMS send failed, attempting to go over signaling", buf, 2u);
    }
    (*(void (**)(CFDictionaryRef, void))(*(void *)theDict + 64))(theDict, v171);
    int v102 = sub_1009D51F8(*(Registry **)(a1 + 80), v171, *(unsigned int *)(*(void *)(a1 + 96) + 48), *(uint64_t **)(a1 + 96));
    if (v102)
    {
      *(void *)CSIPhoneNumber buf = &v171;
      BOOL v103 = (void *)sub_1001B0B78(v157, (int *)&v171, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][61];
      int v104 = (_DWORD *)*v103;
      int v105 = (std::__shared_weak_count *)v103[1];
      if (v105) {
        atomic_fetch_add_explicit(&v105->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v104[27] = 0;
      v104[30] = v102;
      v104[31] = 1;
      sub_1009CE5E4(a1);
      if (v105) {
        sub_10004D2C8(v105);
      }
    }
    else
    {
      int v135 = *v7;
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CSIPhoneNumber buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "#I Unknown encoder while falling back to signaling", buf, 2u);
      }
      sub_1009D0128(a1, v171, 1, &v170);
    }
    goto LABEL_194;
  }
  *(void *)CSIPhoneNumber buf = 0;
  *(void *)&long long v177 = CFDictionaryGetValue(theDict, @"IgnoreDuplicateSMSSendError");
  sub_1000057AC(buf, (CFTypeRef *)&v177);
  LOBYTE(v177) = 0;
  ctu::cf::assign((ctu::cf *)&v177, *(BOOL **)buf, v74);
  if (!(_BYTE)v177 || gsmToCsiErrorWithCode() != 43 || DWORD1(v170) != 197)
  {
    sub_100062778((const void **)buf);
    goto LABEL_110;
  }
  sub_100062778((const void **)buf);
  sub_100057D78((const void **)&theDict);
  uint64_t v75 = *v7;
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CSIPhoneNumber buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v170;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = 197;
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I Ignoring SMS send error (%d, %d)", buf, 0xEu);
  }
  (*(void (**)(uint64_t, void))(*(void *)a1 + 40))(a1, v171);
LABEL_196:
  if (v73) {
    sub_10004D2C8(v73);
  }
}

void sub_1009D4F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,void *aBlock,dispatch_object_t object,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,std::__shared_weak_count *a36)
{
  sub_100062778((const void **)(v36 - 184));
  sub_1000577C4((const void **)(v36 - 176));
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (a36) {
    sub_10004D2C8(a36);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009D51F8@<X0>(Registry *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, a1);
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  CFDictionaryRef v27 = (CFDictionaryRef)v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v27);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_22;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_22;
  }
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v14 + 80))(&v24, v14, a2, 2, sms::Model::sSMSCarrierBundleDict, 0, 0);
  sub_10004EFE4(&Value, &v24);
  CFDictionaryRef v16 = theDict;
  CFDictionaryRef theDict = Value;
  CFDictionaryRef v27 = v16;
  CFDictionaryRef Value = 0;
  sub_100057D78((const void **)&v27);
  sub_100057D78((const void **)&Value);
  sub_1000577C4(&v24);
  if (theDict) {
    unsigned int v17 = sub_100080778;
  }
  else {
    unsigned int v17 = 0;
  }
  if (v17)
  {
    CFDictionaryRef v27 = 0;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"MessageFormat");
    sub_10004EFE4(&v27, (CFTypeRef *)&Value);
    if (v27) {
      uint64_t v18 = sub_100080778;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v18)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v27, @"SignalingFormat");
      sub_1000842D0(&v23, (CFTypeRef *)&Value);
      unint64_t v21 = sub_1009EB734(v23, v19, v20);
      sub_1000570E8((const void **)&v23);
      if (HIDWORD(v21)) {
        a3 = v21;
      }
      else {
        a3 = a3;
      }
    }
    sub_100057D78((const void **)&v27);
  }
LABEL_22:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  sub_100057D78((const void **)&theDict);
  return a3;
}

void sub_1009D5410(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, const void *);
  sub_1000570E8((const void **)va);
  sub_100057D78((const void **)va2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1009D5470(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5])
      {
        unsigned int v6 = a1 + 7;
        uint64_t v9 = v6;
        uint64_t v7 = sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, &v9)[5];
        uint64_t v8 = v7[38];
        v7[38] = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
        if (sub_1009CE4FC(v3, *v6)) {
          sub_1009CE5E4(v3);
        }
        else {
          sub_1009D0BF0(v3);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009D5544(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1009D5558(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1009D58D4(a1, v7);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1009F03B8;
  v8[3] = &unk_101A25680;
  void v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  int v5 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    unsigned int v11 = sub_10005A304;
    unsigned int v12 = &unk_101A253A8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    unsigned int v11 = sub_10005B068;
    unsigned int v12 = &unk_101A253C8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

void sub_1009D56D8(uint64_t a1, uint64_t a2)
{
  v8[0] = a1;
  v8[1] = a2;
  if (!*(void *)(a1 + 32))
  {
    BOOL v6 = 1;
    goto LABEL_9;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v6 = *(void *)(a1 + 32) == 0;
LABEL_9:
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unsigned int v11 = sub_1009F03C8;
    unsigned int v12 = &unk_101A256A0;
    uint64_t v13 = a1 + 8;
    uint64_t v14 = v8;
    int v7 = *(NSObject **)(a1 + 24);
    if (v6) {
      dispatch_sync(v7, &block);
    }
    else {
      dispatch_async_and_wait(v7, &block);
    }
    return;
  }
  BOOL v4 = *(sms::Model **)a2;
  int v5 = *(std::__shared_weak_count **)(a2 + 8);
  blocuint64_t k = (void **)v4;
  uint64_t v10 = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009D57E0(a1, (sms::Model **)&block);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009D57C8(void *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_1009D57E0(uint64_t a1, sms::Model **a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    unsigned int v5 = *((_DWORD *)v3 + 2);
    int TransportType = sms::Model::getTransportType(v3);
    int v7 = *a2;
    int v8 = *((_DWORD *)*a2 + 38);
    uint64_t v9 = (unsigned __int8 *)(*(uint64_t (**)(sms::Model *))(*(void *)v7 + 128))(v7);
    sms::Controller::submitSMSSendEndMetric(a1, v5, TransportType, v8, v9, 5u, 6);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11[0] = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid model object", (uint8_t *)v11, 2u);
    }
  }
}

BOOL sub_1009D58D4(uint64_t a1, int a2)
{
  unsigned int v5 = 0;
  BOOL v6 = 0;
  uint64_t v7 = 0;
  sms::Controller::getDynamicMessageModes_sync(a1, a2, (uint64_t *)&v5);
  int v2 = v5;
  if (v5 != v6)
  {
    while (*v2 != 1)
    {
      if (++v2 == v6)
      {
        int v2 = v6;
        break;
      }
    }
    if (v2 != v6)
    {
      BOOL v3 = 0;
      if (!v5) {
        return v3;
      }
      goto LABEL_13;
    }
    int v2 = v5;
    while (*v2 != 2)
    {
      if (++v2 == v6)
      {
        int v2 = v6;
        break;
      }
    }
  }
  BOOL v3 = v2 == v6;
  if (v5)
  {
LABEL_13:
    BOOL v6 = v5;
    operator delete(v5);
  }
  return v3;
}

void sms::Controller::getDynamicMessageModes_sync(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  int v51 = a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  capabilities::ct::getSupportedMessageModes(a3, (capabilities::ct *)a1);
  int v5 = *(_DWORD *)(a1 + 2604);
  BOOL v6 = v5 == 1;
  uint64_t v52 = &v51;
  uint64_t v7 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v51, (uint64_t)&unk_10144E20E, &v52);
  sub_10082FE4C((uint64_t)v7[5], &v48);
  if (v50)
  {
    double v8 = *(double *)(a1 + 2712);
    sub_10005CD2C((uint64_t)&v48, v49);
    if (v8 != 0.0)
    {
      uint64_t v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v48) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Prevent detach timer is active. Alowing MO/MT SMS", (uint8_t *)&v48, 2u);
      }
      BOOL v6 = 1;
    }
  }
  else
  {
    sub_10005CD2C((uint64_t)&v48, v49);
  }
  uint64_t v10 = (char *)*a3;
  unsigned int v11 = (char *)a3[1];
  unsigned int v12 = (char *)*a3;
  if ((char *)*a3 != v11)
  {
    while (*(_DWORD *)v12)
    {
      v12 += 4;
      if (v12 == v11)
      {
        unsigned int v12 = (char *)a3[1];
        break;
      }
    }
  }
  BOOL v13 = v12 == v11;
  char v14 = !v6;
  if (!v13) {
    char v14 = 1;
  }
  if ((v14 & 1) == 0)
  {
    unint64_t v15 = a3[2];
    if ((unint64_t)v11 >= v15)
    {
      uint64_t v17 = (v11 - v10) >> 2;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v19 = v15 - (void)v10;
      if (v19 >> 1 > v18) {
        unint64_t v18 = v19 >> 1;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        unint64_t v21 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v20);
        uint64_t v10 = (char *)*a3;
        unsigned int v11 = (char *)a3[1];
      }
      else
      {
        unint64_t v21 = 0;
      }
      uint64_t v22 = &v21[4 * v17];
      int v23 = &v21[4 * v20];
      *(_DWORD *)uint64_t v22 = 0;
      CFDictionaryRef v16 = v22 + 4;
      while (v11 != v10)
      {
        int v24 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v22 - 1) = v24;
        v22 -= 4;
      }
      *a3 = (uint64_t)v22;
      a3[1] = (uint64_t)v16;
      a3[2] = (uint64_t)v23;
      if (v10)
      {
        operator delete(v10);
        uint64_t v10 = (char *)*a3;
      }
      else
      {
        uint64_t v10 = v22;
      }
    }
    else
    {
      *(_DWORD *)unsigned int v11 = 0;
      CFDictionaryRef v16 = v11 + 4;
    }
    a3[1] = (uint64_t)v16;
    unsigned int v11 = v16;
  }
  int v25 = v11;
  if (v10 != v11)
  {
    int v25 = v10;
    while (*(_DWORD *)v25 != 1)
    {
      v25 += 4;
      if (v25 == v11)
      {
        int v25 = v11;
        break;
      }
    }
  }
  BOOL v13 = v25 == v11;
  char v26 = !v6;
  if (!v13) {
    char v26 = 1;
  }
  if ((v26 & 1) == 0)
  {
    unint64_t v27 = a3[2];
    if ((unint64_t)v11 >= v27)
    {
      uint64_t v29 = (v11 - v10) >> 2;
      unint64_t v30 = v29 + 1;
      if ((unint64_t)(v29 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v31 = v27 - (void)v10;
      if (v31 >> 1 > v30) {
        unint64_t v30 = v31 >> 1;
      }
      if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v30;
      }
      if (v32)
      {
        BOOL v33 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v32);
        uint64_t v10 = (char *)*a3;
        unsigned int v11 = (char *)a3[1];
      }
      else
      {
        BOOL v33 = 0;
      }
      uint64_t v34 = &v33[4 * v29];
      uint64_t v35 = &v33[4 * v32];
      *(_DWORD *)uint64_t v34 = 1;
      uint64_t v28 = v34 + 4;
      while (v11 != v10)
      {
        int v36 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v34 - 1) = v36;
        v34 -= 4;
      }
      *a3 = (uint64_t)v34;
      a3[1] = (uint64_t)v28;
      a3[2] = (uint64_t)v35;
      if (v10)
      {
        operator delete(v10);
        uint64_t v10 = (char *)*a3;
      }
      else
      {
        uint64_t v10 = v34;
      }
    }
    else
    {
      *(_DWORD *)unsigned int v11 = 1;
      uint64_t v28 = v11 + 4;
    }
    a3[1] = (uint64_t)v28;
    unsigned int v11 = v28;
  }
  BOOL v37 = v11;
  if (v10 != v11)
  {
    BOOL v37 = v10;
    while (*(_DWORD *)v37 != 3)
    {
      v37 += 4;
      if (v37 == v11)
      {
        BOOL v37 = v11;
        break;
      }
    }
  }
  if (v5 == 1 && v37 == v11)
  {
    unint64_t v38 = a3[2];
    if ((unint64_t)v11 >= v38)
    {
      uint64_t v40 = (v11 - v10) >> 2;
      unint64_t v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v42 = v38 - (void)v10;
      if (v42 >> 1 > v41) {
        unint64_t v41 = v42 >> 1;
      }
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v43 = v41;
      }
      if (v43)
      {
        int v44 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v43);
        uint64_t v10 = (char *)*a3;
        unsigned int v11 = (char *)a3[1];
      }
      else
      {
        int v44 = 0;
      }
      unint64_t v45 = &v44[4 * v40];
      CFStringRef v46 = &v44[4 * v43];
      *(_DWORD *)unint64_t v45 = 3;
      int v39 = v45 + 4;
      while (v11 != v10)
      {
        int v47 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v45 - 1) = v47;
        v45 -= 4;
      }
      *a3 = (uint64_t)v45;
      a3[1] = (uint64_t)v39;
      a3[2] = (uint64_t)v46;
      if (v10) {
        operator delete(v10);
      }
    }
    else
    {
      *(_DWORD *)unsigned int v11 = 3;
      int v39 = v11 + 4;
    }
    a3[1] = (uint64_t)v39;
  }
}

void sub_1009D5D78(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009D5DA0(uint64_t a1, uint64_t *a2)
{
  int v22 = (*(uint64_t (**)(void))(*(void *)*a2 + 64))();
  int v4 = (*(uint64_t (**)(void))(*(void *)*a2 + 48))();
  if (!(v22 | v4))
  {
    (*(void (**)(void **__return_ptr))(*(void *)*a2 + 192))(__p);
    sub_100795CC4((uint64_t)__p, &v22);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  int v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*a2 + 8));
  BOOL v6 = v5;
  if (v22 == 7275 || v22 == 2948 && v4 == 7275)
  {
    uint64_t v7 = *v5;
    if (!os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    LOWORD(__p[0]) = 0;
    double v8 = "#I SUPL INIT SMS detected..";
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)__p, 2u);
    return 1;
  }
  if (v22 == 2948)
  {
    uint64_t v10 = *a2;
    int v11 = *(_DWORD *)(*a2 + 8);
    (*(void (**)(void **__return_ptr))(*(void *)v10 + 192))(v17);
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 2528) + 136))(v15);
    if ((v18 & 0x80u) == 0) {
      unsigned int v12 = v17;
    }
    else {
      unsigned int v12 = (void **)v17[0];
    }
    if ((v18 & 0x80u) == 0) {
      uint64_t v13 = v18;
    }
    else {
      uint64_t v13 = (uint64_t)v17[1];
    }
    sub_100364CFC(v11, (uint64_t)v12, v13, (const void **)v15, (uint64_t)__p);
    int v14 = v21;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    if ((char)v18 < 0) {
      operator delete(v17[0]);
    }
    if (!v14)
    {
      uint64_t v7 = *v6;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      LOWORD(__p[0]) = 0;
      double v8 = "#I SUPL wap push detected...";
      goto LABEL_9;
    }
  }
  return 0;
}

void sub_1009D6010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009D6058(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (!*(void *)(a4 + 24))
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)CSIPhoneNumber buf = 0;
    char v20 = "Failed to get driver callback while handling decoded SMS";
    goto LABEL_21;
  }
  uint64_t v8 = CTParser::kDecodedStatusKey;
  uint64_t v9 = (xpc_object_t *)(*a2 + 8);
  if (!xpc_dictionary_get_value(*v9, CTParser::kDecodedStatusKey))
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)CSIPhoneNumber buf = 0;
    char v20 = "Decoding status missing";
LABEL_21:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
    return;
  }
  *(void *)CSIPhoneNumber buf = v9;
  *(void *)&uint8_t buf[8] = v8;
  sub_100048BAC((uint64_t)buf, object);
  char v11 = xpc::dyn_cast_or_default((xpc *)object, 0, v10);
  xpc_release(object[0]);
  uint64_t v37 = 0;
  unint64_t v38 = 0;
  if (v11)
  {
    uint64_t v12 = *a3;
    int v13 = *(_DWORD *)(*a3 + 8);
    if (v13 == 2)
    {
      uint64_t v25 = *a2;
      char v26 = operator new(0x30uLL);
      v26[1] = 0;
      v26[2] = 0;
      *char v26 = off_101A26088;
      C2KSmsPduDecoderSerialized::C2KSmsPduDecoderSerialized((C2KSmsPduDecoderSerialized *)(v26 + 3));
      size_t length = 0;
      if (data)
      {
        CFStringRef v49 = 0;
        uint64_t v50 = 0;
        uint64_t v48 = 0;
        sub_1001E7940(&v48, data, (uint64_t)data + length, length);
        memset(&v47, 0, sizeof(v47));
        sub_10012CD04(&v47, (char *)v48, v49, v49 - (unsigned char *)v48);
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        *(_OWORD *)CSIPhoneNumber buf = 0u;
        sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))buf, &v47, 8);
        uint64_t v46 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        *(_OWORD *)dispatch_object_t object = 0u;
        sub_1009F063C((boost::archive::detail::basic_iarchive *)object, (uint64_t *)buf);
        sub_1009ECD64();
        boost::archive::detail::basic_iarchive::load_object((boost::archive::detail::basic_iarchive *)object, (uint64_t)(v26 + 3), (const boost::archive::detail::basic_iserializer *)qword_101B0FA88);
        boost::archive::detail::basic_iarchive::~basic_iarchive((boost::archive::detail::basic_iarchive *)object);
        boost::archive::basic_text_iprimitive<std::istream>::~basic_text_iprimitive((uint64_t)&v41 + 8);
        if (SBYTE7(v60) < 0) {
          operator delete(__p[0]);
        }
        std::streambuf::~streambuf();
        std::istream::~istream();
        std::ios::~ios();
        if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v47.__r_.__value_.__l.__data_);
        }
        if (v48)
        {
          CFStringRef v49 = (char *)v48;
          operator delete(v48);
        }
      }
      uint64_t v28 = v26[5];
      if (v28) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
      }
      operator new();
    }
    if (v13 == 1)
    {
      uint64_t v14 = *a2;
      unint64_t v15 = operator new(0x30uLL);
      v15[1] = 0;
      unint64_t v15[2] = 0;
      void *v15 = off_101A256D0;
      SmsPduDecoderSerialized::SmsPduDecoderSerialized((SmsPduDecoderSerialized *)(v15 + 3));
      size_t length = 0;
      if (v16)
      {
        CFStringRef v49 = 0;
        uint64_t v50 = 0;
        uint64_t v48 = 0;
        sub_1001E7940(&v48, v16, (uint64_t)v16 + length, length);
        memset(&v47, 0, sizeof(v47));
        sub_10012CD04(&v47, (char *)v48, v49, v49 - (unsigned char *)v48);
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        *(_OWORD *)CSIPhoneNumber buf = 0u;
        sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))buf, &v47, 8);
        uint64_t v46 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        *(_OWORD *)dispatch_object_t object = 0u;
        sub_1009F063C((boost::archive::detail::basic_iarchive *)object, (uint64_t *)buf);
        sub_1009EC0A4();
        boost::archive::detail::basic_iarchive::load_object((boost::archive::detail::basic_iarchive *)object, (uint64_t)(v15 + 3), (const boost::archive::detail::basic_iserializer *)qword_101B0F9C8);
        boost::archive::detail::basic_iarchive::~basic_iarchive((boost::archive::detail::basic_iarchive *)object);
        boost::archive::basic_text_iprimitive<std::istream>::~basic_text_iprimitive((uint64_t)&v41 + 8);
        if (SBYTE7(v60) < 0) {
          operator delete(__p[0]);
        }
        std::streambuf::~streambuf();
        std::istream::~istream();
        std::ios::~ios();
        if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v47.__r_.__value_.__l.__data_);
        }
        if (v48)
        {
          CFStringRef v49 = (char *)v48;
          operator delete(v48);
        }
      }
      unsigned __int8 v18 = (SmsPduDecoder *)v15[4];
      uint64_t v17 = v15[5];
      if (v17) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
      }
      if (SmsPduDecoder::getClass(v18) == 2) {
        SmsPduDecoder::GetSimDownloadFlag(v18);
      }
      SmsPduDecoder::isVoiceMailIndication(v18);
      operator new();
    }
    uint64_t v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = sms::asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Unhandled SMS decoding response: %s", buf, 0xCu);
      uint64_t v12 = *a3;
    }
    int v23 = (std::__shared_weak_count *)a3[1];
    v33[0] = v12;
    v33[1] = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v31 = v37;
    unint64_t v32 = v38;
    sub_1009F0454((uint64_t)v52, a4);
    sub_1009D6E1C(a1, (uint64_t)v33, 2u, (uint64_t)&v31, (uint64_t)v52);
    sub_1009F04EC(v52);
    int v24 = v32;
    if (!v32) {
      goto LABEL_28;
    }
  }
  else
  {
    unsigned __int8 v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Decoding 3GPP SMS failed", buf, 2u);
    }
    uint64_t v22 = *a3;
    int v23 = (std::__shared_weak_count *)a3[1];
    v36[0] = v22;
    v36[1] = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v34 = v37;
    uint64_t v35 = v38;
    sub_1009F0454((uint64_t)v53, a4);
    sub_1009D6E1C(a1, (uint64_t)v36, 2u, (uint64_t)&v34, (uint64_t)v53);
    sub_1009F04EC(v53);
    int v24 = v35;
    if (!v35) {
      goto LABEL_28;
    }
  }
  sub_10004D2C8(v24);
LABEL_28:
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
}

void sub_1009D69C0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,xpc_object_t object,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x217]) < 0) {
    operator delete((void *)STACK[0x200]);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  std::ios::~ios();
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a50) {
    operator delete(a50);
  }
  if (a2 != 3 && a2 != 2)
  {
    sub_10004D2C8(v68);
    if (a28) {
      sub_10004D2C8(a28);
    }
    _Unwind_Resume(a1);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1009D66B8);
}

void sub_1009D6E1C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)a4)
  {
    char v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to decode message", buf, 2u);
    }
    return;
  }
  uint64_t v10 = *(unsigned int *)(*(void *)a4 + 8);
  int v36 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v10);
  if (*(_DWORD *)(*(void *)a2 + 4) == 2) {
    uint64_t v11 = a1 + 128;
  }
  else {
    uint64_t v11 = a1 + 112;
  }
  uint64_t v12 = *(std::__shared_weak_count **)(v11 + 8);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a3 > 8 || ((1 << a3) & 0x1B2) == 0)
  {
    int v23 = *v36;
    if (os_log_type_enabled(*v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Parsing failed. SMS to be handled by driver.", buf, 2u);
    }
    goto LABEL_37;
  }
  if (*(void *)a4)
  {
    uint64_t v13 = *(unsigned int *)(*(void *)a4 + 8);
    uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
    if ((*(unsigned int (**)(void))(**(void **)a4 + 248))() != 1) {
      goto LABEL_30;
    }
    if (a3 == 5)
    {
      uint64_t v16 = *(void *)(*(void *)a2 + 16);
      uint64_t v15 = *(void *)(*(void *)a2 + 24);
      int TransportType = sms::Model::getTransportType(*(sms::Model **)a4);
      sms::Controller::submitSMSReceivedMetric(a1, v10, (__int16)(v15 - v16), 0, 0xAu, TransportType, 0);
      a3 = 5;
      goto LABEL_13;
    }
    if (*(double *)(a1 + 2712) == 0.0)
    {
      int v24 = *(std::__shared_weak_count **)(a4 + 8);
      *(void *)CSIPhoneNumber buf = *(void *)a4;
      long long v41 = v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v25 = sub_1009D5DA0(a1, (uint64_t *)buf);
      if (v24)
      {
        char v35 = v25;
        sub_10004D2C8(v24);
        char v25 = v35;
      }
      if ((v25 & 1) == 0)
      {
        BOOL v32 = sub_1009D58D4(a1, v13);
        if (v32)
        {
          BOOL v33 = *v14;
          if (os_log_type_enabled(*v14, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long v42 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Discarding MT SMS as its not allowed on this device", v42, 2u);
          }
          a3 = 8;
        }
        else
        {
          if (a3 != 7 || *(_DWORD *)(*(void *)a4 + 36) == 2 && *(_DWORD *)(*(void *)a4 + 40) == 2) {
            goto LABEL_30;
          }
          if (capabilities::ct::supportsVoicemailIndicationInCS((capabilities::ct *)v32))
          {
            uint64_t v34 = *v14;
            if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long v42 = 0;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Handling voicemail indications in CS path", v42, 2u);
            }
            goto LABEL_30;
          }
          a3 = 7;
        }
LABEL_13:
        unsigned __int8 v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v10);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          uint64_t v19 = "#I SMS handled by driver...";
LABEL_41:
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
          goto LABEL_46;
        }
        goto LABEL_46;
      }
    }
    else
    {
      unsigned __int8 v21 = *v14;
      if (os_log_type_enabled(*v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v42 = 0;
        uint64_t v22 = "Emergency Text received...";
        goto LABEL_24;
      }
    }
  }
  else
  {
    unsigned __int8 v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v42 = 0;
      uint64_t v22 = "Invalid message...";
LABEL_24:
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v22, v42, 2u);
    }
  }
LABEL_30:
  if (*(unsigned char *)(a1 + 168) && (*(unsigned int (**)(void))(**(void **)a4 + 232))())
  {
    char v26 = *v36;
    if (os_log_type_enabled(*v36, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Dropping the SMS since device memory is full and its not a class 0 SMS", buf, 2u);
    }
    unint64_t v27 = *(std::__shared_weak_count **)(a4 + 8);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    if (v27) {
      sub_10004D2C8(v27);
    }
    a3 = 1;
LABEL_37:
    (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
    goto LABEL_46;
  }
  if (!*(unsigned char *)(*(void *)a2 + 41))
  {
    uint64_t v28 = *(std::__shared_weak_count **)(a4 + 8);
    unint64_t v38 = *(sms::Model **)a4;
    int v39 = v28;
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, sms::Model **))(*(void *)a1 + 24))(a1, &v38);
    if (v39) {
      sub_10004D2C8(v39);
    }
    goto LABEL_46;
  }
  unsigned __int8 v18 = *v36;
  if (os_log_type_enabled(*v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    uint64_t v19 = "#I Waiting for Ack completion";
    goto LABEL_41;
  }
LABEL_46:
  uint64_t v29 = *(void *)(a5 + 24);
  if (v29)
  {
    uint64_t v30 = *(std::__shared_weak_count **)(a4 + 8);
    uint64_t v37 = v30;
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v29 = *(void *)(a5 + 24);
    }
    sub_1009D7440(v29, a3);
    if (v37)
    {
      sub_10004D2C8(v37);
      if (!v12) {
        return;
      }
      goto LABEL_54;
    }
LABEL_53:
    if (!v12) {
      return;
    }
    goto LABEL_54;
  }
  uint64_t v31 = *v36;
  if (!os_log_type_enabled(*v36, OS_LOG_TYPE_ERROR)) {
    goto LABEL_53;
  }
  *(_WORD *)CSIPhoneNumber buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "No driver callback specified", buf, 2u);
  if (v12) {
LABEL_54:
  }
    sub_10004D2C8(v12);
}

void sub_1009D73F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009D7440(uint64_t a1, int a2)
{
  int v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_1009D7490(uint64_t a1, const sms::MTSmsDetails *a2, uint64_t a3)
{
  BOOL v6 = (Registry **)(a1 + 80);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v7 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)a2);
    uint64_t v8 = (std::__shared_weak_count *)operator new(0x48uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A26CD0;
    uint64_t v9 = (uint64_t)&v8[1];
    sms::MTSmsDetails::MTSmsDetails((sms::MTSmsDetails *)&v8[1], a2);
    unsigned int v10 = *((_DWORD *)a2 + 2);
    if (!v10)
    {
      char v35 = *v7;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I 3GPP SMS Unknown message format", (uint8_t *)&__p, 2u);
      }
      uint64_t v36 = *(void *)(a3 + 24);
      if (v36) {
        sub_1009D7440(v36, 6);
      }
      goto LABEL_83;
    }
    if (v10 == 1)
    {
      std::string __p = 0;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      sub_1009D7F94((uint64_t *)&__p, (uint64_t)a2 + 16);
      int v23 = *v7;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        p_p = &__p;
        if (v79 < 0) {
          p_p = __p;
        }
        *(_DWORD *)CSIPhoneNumber buf = 136642819;
        *(void *)&uint8_t buf[4] = p_p;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I 3GPP SMS PDU decoder: (as hex str): [%{sensitive}s]", buf, 0xCu);
      }
      *(_OWORD *)CSIPhoneNumber buf = 0uLL;
      sub_1009F6BF8(buf);
      uint64_t v25 = *(void *)buf;
      sub_1009D8038(*(uint64_t *)buf, v9, v8);
      char v26 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v26 || (unint64_t v27 = *(std::__shared_weak_count **)(a1 + 8), (v28 = std::__shared_weak_count::lock(v26)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v29 = v28;
      p_shared_weak_owners = &v28->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      uint64_t v31 = *(void *)(a1 + 2728);
      BOOL v32 = *(std::__shared_weak_count **)&buf[8];
      uint64_t v71 = v25;
      unsigned int v72 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      v82[0] = v27;
      v82[1] = v29;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      *(void *)&long long v83 = v8 + 1;
      *((void *)&v83 + 1) = v8;
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_1009F0454((uint64_t)v84, a3);
      BOOL v86 = 0;
      BOOL v33 = (char *)operator new(0x48uLL);
      *(void *)BOOL v33 = off_101A27058;
      long long v34 = v83;
      *(_OWORD *)(v33 + 8) = *(_OWORD *)v82;
      v82[0] = 0;
      v82[1] = 0;
      *(_OWORD *)(v33 + 24) = v34;
      long long v83 = 0uLL;
      sub_1009F7AD8((uint64_t)(v33 + 40), (uint64_t)v84);
      BOOL v86 = v33;
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v31 + 24))(v31, &v71, v85);
      sub_1009F7C34(v85);
      sub_1009F04EC(v84);
      if (*((void *)&v83 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v83 + 1));
      }
      if (v82[1]) {
        std::__shared_weak_count::__release_weak(v82[1]);
      }
      if (v72) {
        sub_10004D2C8(v72);
      }
      std::__shared_weak_count::__release_weak(v29);
      if (v32) {
        sub_10004D2C8(v32);
      }
      if (SHIBYTE(v79) < 0) {
        operator delete(__p);
      }
      goto LABEL_83;
    }
    if (v10 != 2)
    {
      uint64_t v37 = *v7;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Unhandled incoming PDU", (uint8_t *)&__p, 2u);
      }
      goto LABEL_83;
    }
    long long v68 = v7;
    xpc_object_t object = xpc_null_create();
    long long v70 = v8;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *v6);
    uint64_t v13 = ServiceMap;
    uint64_t v15 = (void *)v14;
    if (v14 < 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = (void *)v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    std::string __p = v15;
    uint64_t v19 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&__p);
    if (v19)
    {
      uint64_t v21 = v19[3];
      char v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v67 = 0;
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v13);
    char v20 = 0;
    uint64_t v22 = 1;
    char v67 = 1;
LABEL_37:
    long long v66 = v20;
    if (!v21)
    {
      std::string v47 = v68;
      uint64_t v48 = *v68;
      uint64_t v8 = v70;
      if (os_log_type_enabled(*v68, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Failed to get Carrier iface while parsing Raw bytes", (uint8_t *)&__p, 2u);
      }
      CFStringRef v49 = object;
LABEL_56:
      if ((v67 & 1) == 0) {
        sub_10004D2C8(v66);
      }
      std::string __p = 0;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      sub_1009D7F94((uint64_t *)&__p, (uint64_t)a2 + 16);
      uint64_t v52 = *v47;
      if (os_log_type_enabled(*v47, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v53 = &__p;
        if (v79 < 0) {
          unsigned int v53 = __p;
        }
        *(_DWORD *)CSIPhoneNumber buf = 136642819;
        *(void *)&uint8_t buf[4] = v53;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I 3GPP2 SMS PDU decoder: (as hex str): [%{sensitive}s]", buf, 0xCu);
      }
      uint64_t v75 = 0;
      int v76 = 0;
      sub_1009F6BF8(&v75);
      sub_1009D8038(v75, v9, v8);
      if (xpc_get_type(v49) != (xpc_type_t)&_xpc_type_dictionary) {
        goto LABEL_68;
      }
      uint64_t v54 = v75;
      uint64_t v55 = CTParser::kSmsBundleSettingsKey;
      if (v49)
      {
        xpc_retain(v49);
        xpc_object_t v80 = v49;
        xpc_object_t v56 = v49;
      }
      else
      {
        xpc_object_t v56 = xpc_null_create();
        xpc_object_t v80 = v56;
        if (!v56)
        {
          xpc_object_t v56 = 0;
          xpc_object_t v80 = xpc_null_create();
          goto LABEL_67;
        }
      }
      xpc_retain(v56);
LABEL_67:
      *(void *)CSIPhoneNumber buf = v54 + 8;
      *(void *)&uint8_t buf[8] = v55;
      sub_100035E70((uint64_t)buf, &v80, &v81);
      xpc_release(v81);
      xpc_object_t v81 = 0;
      xpc_release(v80);
      xpc_release(v56);
LABEL_68:
      long long v57 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v57 || (v58 = *(void *)(a1 + 8), (uint64_t v59 = std::__shared_weak_count::lock(v57)) == 0)) {
        sub_100088B9C();
      }
      long long v60 = v59;
      long long v61 = &v59->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v59->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v59);
      uint64_t v62 = *(void *)(a1 + 2728);
      long long v63 = v76;
      uint64_t v73 = v75;
      CFBooleanRef v74 = v76;
      if (v76) {
        atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v87 = v58;
      *((void *)&v87 + 1) = v60;
      atomic_fetch_add_explicit(v61, 1uLL, memory_order_relaxed);
      *(void *)&long long v88 = v9;
      *((void *)&v88 + 1) = v8;
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_1009F0454((uint64_t)v89, a3);
      uint64_t v91 = 0;
      long long v64 = (char *)operator new(0x48uLL);
      *(void *)long long v64 = off_101A26FC8;
      long long v65 = v88;
      *(_OWORD *)(v64 + 8) = v87;
      long long v87 = 0uLL;
      *(_OWORD *)(v64 + 24) = v65;
      long long v88 = 0uLL;
      sub_1009F7AD8((uint64_t)(v64 + 40), (uint64_t)v89);
      uint64_t v91 = v64;
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v62 + 24))(v62, &v73, v90);
      sub_1009F7C34(v90);
      sub_1009F04EC(v89);
      if (*((void *)&v88 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v88 + 1));
      }
      if (*((void *)&v87 + 1)) {
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v87 + 1));
      }
      if (v74) {
        sub_10004D2C8(v74);
      }
      std::__shared_weak_count::__release_weak(v60);
      if (v63) {
        sub_10004D2C8(v63);
      }
      if (SHIBYTE(v79) < 0) {
        operator delete(__p);
      }
      xpc_release(v49);
LABEL_83:
      sub_10004D2C8(v8);
      return;
    }
    *(void *)CSIPhoneNumber buf = 0;
    uint64_t v8 = v70;
    unint64_t v38 = (std::mutex *)Registry::getServiceMap((uint64_t *)v22, *v6);
    int v39 = v38;
    if (v14 < 0)
    {
      long long v40 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v41 = 5381;
      do
      {
        uint64_t v14 = v41;
        unsigned int v42 = *v40++;
        uint64_t v41 = (33 * v41) ^ v42;
      }
      while (v42);
    }
    std::mutex::lock(v38);
    std::string __p = (void *)v14;
    long long v43 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)&__p);
    if (v43)
    {
      uint64_t v44 = v43[3];
      long long v45 = (std::__shared_weak_count *)v43[4];
      if (v45)
      {
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v39);
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v45);
        char v46 = 0;
LABEL_49:
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v44 + 80))(&v75, v44, *(unsigned int *)a2, 1, @"SMSSettings", 0, 0);
        sub_10004EFE4(buf, (CFTypeRef *)&v75);
        sub_1000577C4((const void **)&v75);
        if ((v46 & 1) == 0) {
          sub_10004D2C8(v45);
        }
        ctu::cf_to_xpc((uint64_t *)&__p, *(ctu **)buf, v50);
        CFStringRef v49 = __p;
        std::string v47 = v68;
        if (__p && xpc_get_type(__p) == (xpc_type_t)&_xpc_type_dictionary) {
          xpc_retain(v49);
        }
        else {
          CFStringRef v49 = xpc_null_create();
        }
        xpc_object_t v51 = xpc_null_create();
        xpc_release(object);
        xpc_release(v51);
        xpc_release(__p);
        sub_100057D78((const void **)buf);
        goto LABEL_56;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    std::mutex::unlock(v39);
    long long v45 = 0;
    char v46 = 1;
    goto LABEL_49;
  }
}

void sub_1009D7D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,std::__shared_weak_count *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1009D7F94(uint64_t *a1, uint64_t a2)
{
  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  else
  {
    v4[0] = 0;
    v4[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v4);
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::setSource((ctu::TextConverter *)v4, *(const char **)a2, *(void *)(a2 + 8) - *(void *)a2);
    ctu::TextConverter::readChars(a1, (ctu::TextConverter *)v4, 0x7FFFFFFFuLL);
    ctu::TextConverter::~TextConverter((ctu::TextConverter *)v4);
  }
}

void sub_1009D8024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1009D8038(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  MTSmsDetailsSerialized::MTSmsDetailsSerialized();
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  boost::archive::text_oarchive_impl<boost::archive::text_oarchive>::text_oarchive_impl((boost::archive::detail::basic_oarchive *)v14, v16, 0);
  *(void *)&v14[0] = &off_101A26D70;
  boost::archive::basic_text_oarchive<boost::archive::text_oarchive>::init((boost::archive *)v14);
  sub_1009ECFC8();
  boost::archive::detail::basic_oarchive::save_object((unsigned int **)v14, (unint64_t)v7, (const boost::archive::detail::basic_oserializer *)qword_101B0FAB8);
  uint64_t v11 = 0;
  size_t v12 = 0;
  uint64_t v13 = 0;
  sub_10004BC98((uint64_t)&v16[1], &v11);
  if (SHIBYTE(v13) < 0)
  {
    int v5 = (char *)v11;
    size_t v4 = v12;
  }
  else
  {
    size_t v4 = HIBYTE(v13);
    int v5 = (char *)&v11;
  }
  std::string __p = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10014BD54((char *)&__p, v5, &v5[v4], v4);
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v11);
  }
  boost::archive::detail::basic_oarchive::~basic_oarchive((boost::archive::detail::basic_oarchive *)v14);
  boost::archive::basic_text_oprimitive<std::ostream>::~basic_text_oprimitive((uint64_t)v15);
  if (SHIBYTE(v18) < 0) {
    operator delete(*((void **)&v17 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  MTSmsDetailsSerialized::~MTSmsDetailsSerialized((MTSmsDetailsSerialized *)v7);
  if (a3) {
    sub_10004D2C8(a3);
  }
}

void sub_1009D82B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  boost::archive::detail::basic_oarchive::~basic_oarchive((boost::archive::detail::basic_oarchive *)&a24);
  boost::archive::basic_text_oprimitive<std::ostream>::~basic_text_oprimitive((uint64_t)&a30);
  sub_1000C937C((uint64_t)&a40);
  if (a2 == 2 || a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1009D8288);
  }
  MTSmsDetailsSerialized::~MTSmsDetailsSerialized((MTSmsDetailsSerialized *)&a12);
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

void *sub_1009D8374(void *a1)
{
  sub_1009F04EC(a1 + 4);
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[1];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1009D83B8(uint64_t a1, unsigned int **a2)
{
  int v3 = (*(uint64_t (**)(unsigned int *))(*(void *)*a2 + 328))(*a2);
  size_t v4 = *a2;
  if (!v3)
  {
    long long v27 = a2[1];
    v180[0] = v4;
    v180[1] = v27;
    if (v27) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v27 + 1, 1uLL, memory_order_relaxed);
    }
    sub_1009D0F20(a1, v180);
    if (v27)
    {
      sub_10004D2C8((std::__shared_weak_count *)v27);
    }
    return;
  }
  if ((*(unsigned int (**)(unsigned int *))(*(void *)v4 + 248))(v4) != 2) {
    goto LABEL_31;
  }
  (*(void (**)(std::string *__return_ptr))(*(void *)*a2 + 416))(&buf);
  std::string::size_type v5 = buf.__r_.__value_.__r.__words[0];
  if (buf.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  if (!v5)
  {
LABEL_31:
    long long v28 = *a2;
    uint64_t v29 = (std::__shared_weak_count *)a2[1];
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v183[0] = -1;
    LODWORD(v181[0]) = 0;
    LODWORD(v193) = 0;
    LODWORD(v190) = v28[2];
    uint64_t v30 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v190);
    uint64_t v176 = (uint64_t *)(a1 + 80);
    if ((subscriber::isValidSimSlot() & 1) == 0) {
      goto LABEL_123;
    }
    int v178 = v30;
    unsigned int v174 = v29;
    if ((*(unsigned int (**)(unsigned int *))(*(void *)v28 + 248))(v28) != 2) {
      goto LABEL_83;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v176, (Registry *)*v176);
    BOOL v32 = ServiceMap;
    if ((v33 & 0x8000000000000000) != 0)
    {
      long long v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v35 = 5381;
      do
      {
        std::string::size_type v33 = v35;
        unsigned int v36 = *v34++;
        uint64_t v35 = (33 * v35) ^ v36;
      }
      while (v36);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v33;
    uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)&buf);
    if (v37)
    {
      uint64_t v39 = v37[3];
      unint64_t v38 = (std::__shared_weak_count *)v37[4];
      if (v38)
      {
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v32);
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v38);
        char v40 = 0;
LABEL_45:
        uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 88))(v39);
        if ((v40 & 1) == 0) {
          sub_10004D2C8(v38);
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
        long long v45 = (uint64_t *)*sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v190, (uint64_t)&unk_10144E20E, &buf)[5];
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
        uint64_t v46 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v190, (uint64_t)&unk_10144E20E, &buf)[5][1];
        uint64_t v47 = v190;
        uint64_t v48 = *(void *)(a1 + 2568);
        CFStringRef v49 = *(std::__shared_weak_count **)(a1 + 2576);
        if (v49)
        {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unsigned int v171 = (uint64_t **)(a1 + 2544);
        long long v172 = v49;
        if (v45 == (uint64_t *)v46) {
          goto LABEL_79;
        }
        uint64_t v50 = v46;
        while (1)
        {
          uint64_t v51 = *v45;
          uint64_t v52 = (std::__shared_weak_count *)v45[1];
          if (v52) {
            atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (!*(_DWORD *)(v51 + 184)
            || (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v48 + 192))(v48, v47, v44))
          {
            break;
          }
          char v53 = 1;
          if (v52) {
            goto LABEL_56;
          }
LABEL_57:
          if (v53)
          {
            if (v45 != (uint64_t *)v46)
            {
              uint64_t v54 = v45 + 2;
              if (v45 + 2 != (uint64_t *)v46)
              {
                uint64_t v50 = (uint64_t)v45;
                while (1)
                {
                  uint64_t v55 = *v54;
                  xpc_object_t v56 = (std::__shared_weak_count *)v54[1];
                  if (v56) {
                    atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (*(_DWORD *)(v55 + 184)
                    && !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v48 + 192))(v48, v47, v44))
                  {
                    break;
                  }
                  char v57 = 0;
                  if (v56) {
                    goto LABEL_70;
                  }
LABEL_71:
                  if ((v57 & 1) == 0)
                  {
                    long long v58 = *(_OWORD *)v54;
                    uint64_t *v54 = 0;
                    v54[1] = 0;
                    uint64_t v59 = *(std::__shared_weak_count **)(v50 + 8);
                    *(_OWORD *)uint64_t v50 = v58;
                    if (v59) {
                      sub_10004D2C8(v59);
                    }
                    v50 += 16;
                  }
                  v54 += 2;
                  if (v54 == (uint64_t *)v46) {
                    goto LABEL_80;
                  }
                }
                char v57 = 1;
                if (!v56) {
                  goto LABEL_71;
                }
LABEL_70:
                sub_10004D2C8(v56);
                goto LABEL_71;
              }
LABEL_79:
              uint64_t v50 = (uint64_t)v45;
            }
LABEL_80:
            if (v172)
            {
              sub_10004D2C8(v172);
              sub_10004D2C8(v172);
            }
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
            uint64_t v29 = v174;
            long long v60 = sub_1001B0B78(v171, (int *)&v190, (uint64_t)&unk_10144E20E, &buf)[5];
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
            long long v61 = sub_1001B0B78(v171, (int *)&v190, (uint64_t)&unk_10144E20E, &buf);
            sub_1009D0EAC((uint64_t)v60, v50, (long long *)v61[5][1]);
            uint64_t v30 = v178;
LABEL_83:
            (*(void (**)(unsigned int *, int *, void **, uint64_t *))(*(void *)v28 + 336))(v28, v183, v181, &v193);
            uint64_t v62 = *v30;
            if (os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(buf.__r_.__value_.__r.__words[0]) = v181[0];
              _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I Received concatenated message segment (index %d)", (uint8_t *)&buf, 8u);
            }
            unsigned int v63 = 0;
            long long v64 = (uint64_t **)(a1 + 2544);
            while (1)
            {
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
              long long v65 = sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &buf);
              unint64_t v66 = v63;
              if (v63 >= (unint64_t)((v65[5][1] - *v65[5]) >> 4)) {
                goto LABEL_100;
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
              char v67 = sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &buf);
              if (*(_DWORD *)(*(void *)(*v67[5] + 16 * v63) + 4) == v183[0])
              {
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
                sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &buf);
                (*(void (**)(std::string *__return_ptr, unsigned int *))(*(void *)v28 + 256))(&__p, v28);
                CSIPhoneNumber::CSIPhoneNumber();
                int v68 = CSIPhoneNumber::operator==();
                if (v204 < 0) {
                  operator delete(*(void **)&v203[24]);
                }
                if ((v203[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v203);
                }
                if (v201 < 0) {
                  operator delete(v200[0]);
                }
                if (v199 < 0) {
                  operator delete((void *)buf.__r_.__value_.__l.__size_);
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                if (v68) {
                  break;
                }
              }
              ++v63;
            }
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
            long long v69 = (int **)(*sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &buf)[5] + 16 * v63);
            uint64_t v71 = *v69;
            long long v70 = (std::__shared_weak_count *)v69[1];
            if (v70) {
              atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unsigned int v72 = v70;
            if (!v71) {
LABEL_100:
            }
              operator new();
            int v74 = (int)v181[0];
            if (SLODWORD(v181[0]) >= v71[2])
            {
              os_log_t v78 = *v30;
              if (!os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_121;
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(buf.__r_.__value_.__r.__words[0]) = v74;
              uint64_t v79 = "#I Warning: Discarding out of bounds segment (index %d)";
            }
            else
            {
              uint64_t v75 = *((void *)v71 + 20) + 32 * SLODWORD(v181[0]);
              uint64_t v76 = *(unsigned __int8 *)(v75 + 23);
              if ((v76 & 0x80u) != 0) {
                uint64_t v76 = *(void *)(v75 + 8);
              }
              if (!v76 && !(*(unsigned __int16 *)(v75 + 24) | *(unsigned __int16 *)(v75 + 26)))
              {
                if (!LODWORD(v181[0]))
                {
                  v71[3] = (*(uint64_t (**)(unsigned int *))(*(void *)v28 + 48))(v28);
                  v71[4] = (*(uint64_t (**)(unsigned int *))(*(void *)v28 + 64))(v28);
                }
                long long v173 = v70;
                (*(void (**)(std::string *__return_ptr, unsigned int *))(*(void *)v28 + 192))(&__p, v28);
                int v77 = (*(uint64_t (**)(unsigned int *))(*(void *)v28 + 96))(v28);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
                }
                else {
                  std::string buf = __p;
                }
                int v198 = v77;
                uint64_t v108 = *((void *)v71 + 20) + 32 * SLODWORD(v181[0]);
                if (*(char *)(v108 + 23) < 0) {
                  operator delete(*(void **)v108);
                }
                long long v109 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(void *)(v108 + 16) = *((void *)&buf.__r_.__value_.__l + 2);
                *(_OWORD *)uint64_t v108 = v109;
                *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
                buf.__r_.__value_.__s.__data_[0] = 0;
                *(_DWORD *)(v108 + 24) = v198;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                ++*v71;
                if ((*(unsigned int (**)(unsigned int *))(*(void *)v28 + 248))(v28) != 2)
                {
                  v71[46] = 0;
                  goto LABEL_214;
                }
                uint64_t v110 = (std::mutex *)Registry::getServiceMap(v176, (Registry *)*v176);
                uint64_t v111 = v110;
                if ((v112 & 0x8000000000000000) != 0)
                {
                  time_t v113 = (unsigned __int8 *)(v112 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v114 = 5381;
                  do
                  {
                    std::string::size_type v112 = v114;
                    unsigned int v115 = *v113++;
                    uint64_t v114 = (33 * v114) ^ v115;
                  }
                  while (v115);
                }
                std::mutex::lock(v110);
                buf.__r_.__value_.__r.__words[0] = v112;
                uint64_t v116 = sub_10004D37C(&v111[1].__m_.__sig, (unint64_t *)&buf);
                if (v116)
                {
                  uint64_t v118 = v116[3];
                  unsigned int v117 = (std::__shared_weak_count *)v116[4];
                  if (v117)
                  {
                    atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v111);
                    atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v117);
                    char v119 = 0;
LABEL_212:
                    v71[46] = (*(uint64_t (**)(uint64_t))(*(void *)v118 + 88))(v118);
                    uint64_t v30 = v178;
                    if ((v119 & 1) == 0) {
                      sub_10004D2C8(v117);
                    }
LABEL_214:
                    int v137 = *v71;
                    int v138 = v71[2];
                    uint64_t v139 = *v30;
                    BOOL v140 = os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT);
                    if (v137 == v138)
                    {
                      if (v140)
                      {
                        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "#I All segments for this message have arrived, reassembling...", (uint8_t *)&buf, 2u);
                      }
                      memset(&__p, 0, sizeof(__p));
                      if (v71[2] >= 1)
                      {
                        uint64_t v141 = 0;
                        int v142 = 0;
                        uint64_t v143 = *((void *)v71 + 20);
                        uint64_t v144 = 23;
                        do
                        {
                          int v145 = *v178;
                          if (os_log_type_enabled(*v178, OS_LOG_TYPE_DEFAULT))
                          {
                            if (*(char *)(v143 + v144) < 0) {
                              std::string::size_type v146 = *(void *)(v143 + v144 - 15);
                            }
                            else {
                              std::string::size_type v146 = *(unsigned __int8 *)(v143 + v144);
                            }
                            LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
                            HIDWORD(buf.__r_.__value_.__r.__words[0]) = v141;
                            LOWORD(buf.__r_.__value_.__r.__words[1]) = 2048;
                            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v146;
                            _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "#I Adding Part %d : size: %ld", (uint8_t *)&buf, 0x12u);
                            uint64_t v143 = *((void *)v71 + 20);
                          }
                          if (v142)
                          {
                            int v147 = *(unsigned __int16 *)(v143 + v144 + 3);
                            if (*(_WORD *)(v143 + v144 + 3))
                            {
                              int v148 = *v178;
                              if (os_log_type_enabled(*v178, OS_LOG_TYPE_DEFAULT))
                              {
                                LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
                                HIDWORD(buf.__r_.__value_.__r.__words[0]) = v142;
                                LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
                                *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v147;
                                _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#I Appending boundary split surrogate (high: %x low: %x) to message body", (uint8_t *)&buf, 0xEu);
                              }
                              memset(&buf, 0, sizeof(buf));
                              ctu::hex((uint64_t *)&buf, (ctu *)(v147 | (v142 << 16)), v149);
                              unint64_t v186 = 0;
                              unint64_t v187 = 0;
                              ctu::TextConverter::TextConverter((ctu::TextConverter *)&v186);
                              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                p_std::string buf = &buf;
                              }
                              else {
                                p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                              }
                              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                              }
                              else {
                                std::string::size_type size = buf.__r_.__value_.__l.__size_;
                              }
                              ctu::TextConverter::setSource((ctu::TextConverter *)&v186, (const char *)p_buf, size);
                              ctu::TextConverter::pushConversion();
                              ctu::TextConverter::pushConversion();
                              ctu::TextConverter::pushConversion();
                              ctu::TextConverter::readChars((uint64_t *)&__dst, (ctu::TextConverter *)&v186, 0x7FFFFFFFuLL);
                              ctu::TextConverter::~TextConverter((ctu::TextConverter *)&v186);
                              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(buf.__r_.__value_.__l.__data_);
                              }
                              if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                p_dst = &__dst;
                              }
                              else {
                                p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
                              }
                              if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                std::string::size_type v153 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                              }
                              else {
                                std::string::size_type v153 = __dst.__r_.__value_.__l.__size_;
                              }
                              std::string::append(&__p, (const std::string::value_type *)p_dst, v153);
                              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__dst.__r_.__value_.__l.__data_);
                              }
                              uint64_t v143 = *((void *)v71 + 20);
                            }
                            int v154 = *(char *)(v143 + v144);
                            if (v154 >= 0) {
                              uint64_t v155 = (const std::string::value_type *)(v143 + v144 - 23);
                            }
                            else {
                              uint64_t v155 = *(const std::string::value_type **)(v143 + v144 - 23);
                            }
                            if (v154 >= 0) {
                              std::string::size_type v156 = *(unsigned __int8 *)(v143 + v144);
                            }
                            else {
                              std::string::size_type v156 = *(void *)(v143 + v144 - 15);
                            }
                          }
                          else
                          {
                            int v157 = *(char *)(v143 + v144);
                            if (v157 >= 0) {
                              uint64_t v155 = (const std::string::value_type *)(v143 + v144 - 23);
                            }
                            else {
                              uint64_t v155 = *(const std::string::value_type **)(v143 + v144 - 23);
                            }
                            if (v157 >= 0) {
                              std::string::size_type v156 = *(unsigned __int8 *)(v143 + v144);
                            }
                            else {
                              std::string::size_type v156 = *(void *)(v143 + v144 - 15);
                            }
                          }
                          std::string::append(&__p, v155, v156);
                          uint64_t v143 = *((void *)v71 + 20);
                          int v142 = *(unsigned __int16 *)(v143 + v144 + 1);
                          ++v141;
                          v144 += 32;
                        }
                        while (v141 < v71[2]);
                      }
                      int v158 = *v178;
                      if (os_log_type_enabled(*v178, OS_LOG_TYPE_DEFAULT))
                      {
                        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                        _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I Concatenated message successfully reassembled", (uint8_t *)&buf, 2u);
                      }
                      uint64_t v29 = v174;
                      if ((*(unsigned int (**)(unsigned int *))(*(void *)v28 + 200))(v28) == 4) {
                        uint64_t v159 = 4;
                      }
                      else {
                        uint64_t v159 = 8;
                      }
                      (*(void (**)(unsigned int *, std::string *, uint64_t))(*(void *)v28 + 136))(v28, &__p, v159);
                      (*(void (**)(unsigned int *, void))(*(void *)v28 + 56))(v28, v71[3]);
                      (*(void (**)(unsigned int *, void))(*(void *)v28 + 72))(v28, v71[4]);
                      int v160 = *v178;
                      if (os_log_type_enabled(*v178, OS_LOG_TYPE_DEFAULT))
                      {
                        (*(void (**)(std::string *__return_ptr, unsigned int *))(*(void *)v28 + 192))(&buf, v28);
                        std::string::size_type v161 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                        std::string::size_type v162 = buf.__r_.__value_.__l.__size_;
                        int v163 = (*(uint64_t (**)(unsigned int *))(*(void *)v28 + 200))(v28);
                        std::string::size_type v164 = (v161 & 0x80u) == 0 ? v161 : v162;
                        LODWORD(__dst.__r_.__value_.__l.__data_) = 134218240;
                        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v164;
                        WORD2(__dst.__r_.__value_.__r.__words[1]) = 1024;
                        *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = v163;
                        _os_log_impl((void *)&_mh_execute_header, v160, OS_LOG_TYPE_DEFAULT, "#I Full Message Length: %lu (final encoding: %u)", (uint8_t *)&__dst, 0x12u);
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(buf.__r_.__value_.__l.__data_);
                        }
                      }
                      (*(void (**)(unsigned int *))(*(void *)v28 + 360))(v28);
                      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
                      buf.__r_.__value_.__l.__size_ = (std::string::size_type)v174;
                      if (v174) {
                        atomic_fetch_add_explicit(&v174->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      sub_1009D0F20(a1, (unsigned int **)&buf);
                      if (v174) {
                        sub_10004D2C8(v174);
                      }
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
                      unsigned int v165 = sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &__dst);
                      if (v66 >= (v165[5][1] - *v165[5]) >> 4)
                      {
                        uint64_t v168 = *v178;
                        unsigned int v72 = v173;
                        if (os_log_type_enabled(*v178, OS_LOG_TYPE_DEFAULT))
                        {
                          LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
                          _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "#I reassembleConcatenatedPdu - index to erase not within bounds of partial messages, leaving partials untouched", (uint8_t *)&__dst, 2u);
                        }
                      }
                      else
                      {
                        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
                        long long v166 = sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &__dst)[5];
                        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v190;
                        double v167 = sub_1001B0B78(v64, (int *)&v190, (uint64_t)&unk_10144E20E, &__dst);
                        sub_1009D343C((uint64_t)v166, *v167[5] + 16 * v66);
                        unsigned int v72 = v173;
                      }
                      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__p.__r_.__value_.__l.__data_);
                      }
LABEL_121:
                      if (v72) {
                        sub_10004D2C8(v72);
                      }
LABEL_123:
                      if (!v29) {
                        return;
                      }
                      int v82 = v29;
                      goto LABEL_164;
                    }
                    if (!v140) {
                      goto LABEL_121;
                    }
                    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
                    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v137;
                    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
                    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v138;
                    uint64_t v79 = "#I Now have %d out of %d segments for this message";
                    xpc_object_t v80 = v139;
                    uint32_t v81 = 14;
LABEL_120:
                    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, v79, (uint8_t *)&buf, v81);
                    goto LABEL_121;
                  }
                }
                else
                {
                  uint64_t v118 = 0;
                }
                std::mutex::unlock(v111);
                unsigned int v117 = 0;
                char v119 = 1;
                goto LABEL_212;
              }
              os_log_t v78 = *v30;
              if (!os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_121;
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(buf.__r_.__value_.__r.__words[0]) = v74;
              uint64_t v79 = "#I Warning: Received duplicate segment (index %d), ignoring";
            }
            xpc_object_t v80 = v78;
            uint32_t v81 = 8;
            goto LABEL_120;
          }
          v45 += 2;
          if (v45 == (uint64_t *)v46) {
            goto LABEL_80;
          }
        }
        char v53 = 0;
        if (!v52) {
          goto LABEL_57;
        }
LABEL_56:
        sub_10004D2C8(v52);
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v39 = 0;
    }
    std::mutex::unlock(v32);
    unint64_t v38 = 0;
    char v40 = 1;
    goto LABEL_45;
  }
  BOOL v6 = *a2;
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v193 = 0;
  uint64_t v194 = 0;
  long long v175 = v7;
  (*(void (**)(uint64_t *__return_ptr, unsigned int *))(*(void *)v6 + 416))(&v193, v6);
  unsigned int v192 = v6[2];
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v9 = v193;
  long long v170 = v8;
  uint64_t v10 = *v8;
  BOOL v11 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    char v169 = v6;
    if (v11)
    {
      int v12 = *(_DWORD *)(v9 + 80);
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v12 >> 4;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v12 & 0xF;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I concatenated CB message (part %d/%d)", (uint8_t *)&buf, 0xEu);
    }
    unsigned int v13 = 0;
    uint64_t v14 = (uint64_t **)(a1 + 2544);
    long long v177 = (uint64_t **)(a1 + 2544);
    while (1)
    {
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      uint64_t v15 = sub_1001B0B78(v14, (int *)&v192, (uint64_t)&unk_10144E20E, &__p);
      uint64_t v16 = v13;
      if (v13 >= (unint64_t)((v15[5][35] - v15[5][34]) >> 4))
      {
        uint64_t v73 = 0;
        goto LABEL_137;
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      unsigned int v17 = **(_DWORD **)(sub_1001B0B78(v14, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v13);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      unsigned int v18 = *(_DWORD *)(*(void *)(sub_1001B0B78(v14, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v13)
                      + 4);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      unsigned int v19 = *(_DWORD *)(*(void *)(sub_1001B0B78(v14, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v16)
                      + 8);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      unsigned int v20 = *(_DWORD *)(*(void *)(sub_1001B0B78(v14, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v16)
                      + 12);
      int v21 = *(_DWORD *)(v193 + 72);
      int v22 = *(_DWORD *)(v193 + 144);
      uint64_t v190 = v193;
      long long v191 = v194;
      if (v194) {
        atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
      long long v23 = sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5];
      MCC::MCC((MCC *)&buf, (const MCC *)(v23 + 49));
      MCC::MCC((MCC *)v200, (const MCC *)(v23 + 53));
      *(_OWORD *)v203 = *(_OWORD *)(v23 + 57);
      *(_OWORD *)&v203[9] = *(_OWORD *)((char *)v23 + 465);
      int v24 = sub_100144E50((uint64_t)&v190, (uint64_t)&buf);
      int v25 = *(_DWORD *)(v193 + 148);
      if (v202 < 0) {
        operator delete(v200[1]);
      }
      if (v199 < 0) {
        operator delete((void *)buf.__r_.__value_.__l.__size_);
      }
      if (v191) {
        sub_10004D2C8(v191);
      }
      unint64_t v186 = __PAIR64__(v18, v17);
      unint64_t v187 = __PAIR64__(v20, v19);
      uint64_t v188 = 0;
      int v189 = 0;
      v183[0] = v21;
      v183[1] = v22;
      v183[2] = v24;
      v183[3] = v25;
      uint64_t v184 = 0;
      int v185 = 0;
      int v26 = sub_1001454C4((int *)&v186, v183);
      uint64_t v7 = v175;
      uint64_t v14 = (uint64_t **)(a1 + 2544);
      if (v26 == 1)
      {
        (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
        long long v83 = *v170;
        if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "#I Received replacement CB message, discarding incomplete", (uint8_t *)&__p, 2u);
        }
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
        long long v84 = sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5];
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
        uint64_t v85 = sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v16;
        uint64_t v86 = sub_1009ED218((long long *)(v85 + 16), (long long *)v84[35], v85);
        for (uint64_t i = v84[35]; i != v86; i -= 16)
        {
          long long v88 = *(std::__shared_weak_count **)(i - 8);
          if (v88) {
            sub_10004D2C8(v88);
          }
        }
        uint64_t v73 = 0;
        v84[35] = v86;
LABEL_137:
        uint64_t v92 = *v170;
        if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I First sequence of concatenated CB message", (uint8_t *)&__p, 2u);
        }
        if ((*(unsigned char *)(v193 + 80) & 0xF) != 0) {
          operator new();
        }
        (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
        unsigned int v94 = *v170;
        if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I invalid CB PDU: concatenated element count is 0", (uint8_t *)&__p, 2u);
        }
        uint64_t v95 = v73;
        uint64_t v7 = v175;
        goto LABEL_158;
      }
      if (v26 == -1) {
        break;
      }
      if (v26 == -2)
      {
        int v89 = *v170;
        if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#I Found partial CB message", (uint8_t *)&__p, 2u);
        }
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v192;
        long long v90 = (uint64_t *)(sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &__p)[5][34] + 16 * v16);
        uint64_t v91 = *v90;
        uint64_t v73 = (std::__shared_weak_count *)v90[1];
        if (v73) {
          atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v91) {
          goto LABEL_137;
        }
        unsigned int v96 = *(_DWORD *)(v193 + 80) >> 4;
        if (v96 > *(_DWORD *)(v91 + 16))
        {
          (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
          os_log_t v97 = *v170;
          if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
            uint64_t v98 = "#I Concatenated cbs segment address out of bounds, discarding";
            int v99 = v97;
            uint32_t v100 = 2;
            goto LABEL_155;
          }
          goto LABEL_156;
        }
        int v101 = v96 - 1;
        uint64_t v102 = *(void *)(v91 + 24);
        uint64_t v103 = v102 + 24 * v101;
        uint64_t v104 = *(unsigned __int8 *)(v103 + 23);
        uint64_t v105 = *(void *)(v103 + 8);
        if ((v104 & 0x80u) == 0) {
          uint64_t v105 = v104;
        }
        if (v105)
        {
          (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
          os_log_t v106 = *v170;
          if (os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT))
          {
            int v107 = *(_DWORD *)(v193 + 80) >> 4;
            LODWORD(__dst.__r_.__value_.__l.__data_) = 67109120;
            HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v107;
            uint64_t v98 = "#I Received duplicated cbs part %d";
            int v99 = v106;
            uint32_t v100 = 8;
LABEL_155:
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, v98, (uint8_t *)&__dst, v100);
          }
LABEL_156:
          uint64_t v7 = v175;
        }
        else
        {
          if (*(char *)(v193 + 111) < 0)
          {
            sub_10004FC84(&__dst, *(void **)(v193 + 88), *(void *)(v193 + 96));
            uint64_t v102 = *(void *)(v91 + 24);
            int v101 = (*(_DWORD *)(v193 + 80) >> 4) - 1;
          }
          else
          {
            std::string __dst = *(std::string *)(v193 + 88);
          }
          uint64_t v120 = v102 + 24 * v101;
          if (*(char *)(v120 + 23) < 0) {
            operator delete(*(void **)v120);
          }
          long long v121 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          *(void *)(v120 + 16) = *((void *)&__dst.__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v120 = v121;
          int v122 = *(_DWORD *)(v91 + 16);
          int v123 = *(_DWORD *)(v91 + 20) + 1;
          *(_DWORD *)(v91 + 20) = v123;
          uint64_t v124 = *v170;
          BOOL v125 = os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT);
          if (v123 == v122)
          {
            if (v125)
            {
              LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "#I cbs message is complete", (uint8_t *)&__dst, 2u);
            }
            memset(&__dst, 0, sizeof(__dst));
            if (*(_DWORD *)(v91 + 16))
            {
              uint64_t v126 = 0;
              unint64_t v127 = 0;
              do
              {
                uint64_t v128 = *(void *)(v91 + 24) + v126;
                int v129 = *(char *)(v128 + 23);
                if (v129 >= 0) {
                  char v130 = (const std::string::value_type *)(*(void *)(v91 + 24) + v126);
                }
                else {
                  char v130 = *(const std::string::value_type **)v128;
                }
                if (v129 >= 0) {
                  std::string::size_type v131 = *(unsigned __int8 *)(v128 + 23);
                }
                else {
                  std::string::size_type v131 = *(void *)(v128 + 8);
                }
                std::string::append(&__dst, v130, v131);
                ++v127;
                v126 += 24;
              }
              while (v127 < *(unsigned int *)(v91 + 16));
            }
            (*(void (**)(unsigned int *, std::string *, uint64_t))(*(void *)v169 + 136))(v169, &__dst, 8);
            (*(void (**)(unsigned int *))(*(void *)v169 + 360))(v169);
            v181[0] = v169;
            v181[1] = v175;
            if (v175) {
              atomic_fetch_add_explicit(&v175->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            sub_1009D0F20(a1, (unsigned int **)v181);
            if (v175) {
              sub_10004D2C8(v175);
            }
            uint64_t v195 = (int *)&v192;
            int v132 = sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &v195)[5];
            uint64_t v195 = (int *)&v192;
            uint64_t v133 = sub_1001B0B78(v177, (int *)&v192, (uint64_t)&unk_10144E20E, &v195)[5][34] + 16 * v16;
            uint64_t v134 = sub_1009ED218((long long *)(v133 + 16), (long long *)v132[35], v133);
            for (uint64_t j = v132[35]; j != v134; j -= 16)
            {
              int v136 = *(std::__shared_weak_count **)(j - 8);
              if (v136) {
                sub_10004D2C8(v136);
              }
            }
            v132[35] = v134;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
          }
          else if (v125)
          {
            LODWORD(__dst.__r_.__value_.__l.__data_) = 67109376;
            HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v123;
            LOWORD(__dst.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[1] + 2) = v122;
            _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "#I cbs message have %d out of %d parts of this message", (uint8_t *)&__dst, 0xEu);
          }
        }
        uint64_t v95 = v73;
LABEL_158:
        if (v95) {
          sub_10004D2C8(v95);
        }
        goto LABEL_160;
      }
      unsigned int v13 = v16 + 1;
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
    os_log_t v93 = *v170;
    if (!os_log_type_enabled(*v170, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_160;
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    uint64_t v41 = "#I Old CB message, discarding";
    p_p = &__p;
    long long v43 = v93;
  }
  else
  {
    if (!v11) {
      goto LABEL_160;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v41 = "#I CB PDU Decoder is invalid";
    p_p = &buf;
    long long v43 = v10;
  }
  _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)p_p, 2u);
LABEL_160:
  if (v194) {
    sub_10004D2C8(v194);
  }
  if (v7)
  {
    int v82 = v7;
LABEL_164:
    sub_10004D2C8(v82);
  }
}

void sub_1009DA840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *__p,void *a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1009DAB70(uint64_t a1, uint64_t a2, int a3)
{
  if (subscriber::isValidSimSlot())
  {
    BOOL v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (a3)
    {
      if (!v7) {
        return;
      }
      __int16 v11 = 0;
      uint64_t v8 = "#I SMS Driver is ready";
      uint64_t v9 = (uint8_t *)&v11;
    }
    else
    {
      if (!v7) {
        return;
      }
      __int16 v10 = 0;
      uint64_t v8 = "#I SMS Driver is not ready";
      uint64_t v9 = (uint8_t *)&v10;
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, v9, 2u);
  }
}

BOOL sub_1009DAC40(uint64_t a1)
{
  uint64_t v6 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      BOOL v2 = *(double *)(a1 + 2712) == 0.0;
      return !v2;
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_1009F80EC;
  void v7[3] = &unk_101A270C8;
  v7[4] = a1 + 8;
  v7[5] = &v6;
  uint64_t v8 = v7;
  size_t v4 = *(NSObject **)(a1 + 24);
  char v14 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v3)
  {
    __int16 v10 = sub_10005A304;
    __int16 v11 = &unk_101A253A8;
    int v12 = &v14;
    unsigned int v13 = &v8;
    dispatch_sync(v4, block);
  }
  else
  {
    __int16 v10 = sub_10005B068;
    __int16 v11 = &unk_101A253C8;
    int v12 = &v14;
    unsigned int v13 = &v8;
    dispatch_async_and_wait(v4, block);
  }
  BOOL v2 = v14 == 0;
  return !v2;
}

void sub_1009DADB0(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 248) == a2[2])
  {
    BOOL v3 = *(void **)(a1 + 232);
    if (v3 == (void *)(a1 + 240)) {
      return;
    }
    size_t v4 = (void *)*a2;
    while (1)
    {
      BOOL v5 = *((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8);
      if (!v5) {
        break;
      }
      uint64_t v6 = (void *)v3[1];
      BOOL v7 = v3;
      if (v6)
      {
        do
        {
          BOOL v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v3 = (void *)v7[2];
          BOOL v5 = *v3 == (void)v7;
          BOOL v7 = v3;
        }
        while (!v5);
      }
      uint64_t v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v4[2];
          BOOL v5 = *v9 == (void)v4;
          size_t v4 = v9;
        }
        while (!v5);
      }
      size_t v4 = v9;
      if (v3 == (void *)(a1 + 240)) {
        return;
      }
    }
  }
  subscriber::makeSimSlotRange();
  __int16 v10 = v12;
  if (v12 != v13)
  {
    while ((v14(*v10) & 1) == 0)
    {
      if (++v10 == v13)
      {
        __int16 v10 = v13;
        break;
      }
    }
LABEL_25:
    while (v10 != v13)
    {
      __int16 v11 = v10 + 1;
      sub_1009DAF14((void **)a1, *v10);
      __int16 v10 = v13;
      if (v11 != v13)
      {
        __int16 v10 = v11;
        while ((v14(*v10) & 1) == 0)
        {
          if (++v10 == v13)
          {
            __int16 v10 = v13;
            goto LABEL_25;
          }
        }
      }
    }
  }
}

void sub_1009DAF14(void **a1, unsigned int a2)
{
  unsigned int v53 = a2;
  BOOL v3 = (Registry **)(a1 + 10);
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  *(void *)long long v58 = &v53;
  int v4 = *((_DWORD *)sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5] + 55);
  BOOL v5 = (os_log_t *)(*(uint64_t (**)(void *, void))(*a1[6] + 16))(a1[6], v53);
  *(void *)long long v58 = &v53;
  if (*((unsigned char *)sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5] + 42)
    && (sub_1009DBCA8((uint64_t)a1, v53) & 1) == 0)
  {
    uint64_t v23 = v53;
    int v24 = *v3;
    CFDictionaryRef theDict = 0;
    CFDictionaryRef v54 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v24);
    int v26 = ServiceMap;
    if (v27 < 0)
    {
      long long v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v58 = v27;
    uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)v58);
    if (v31)
    {
      uint64_t v33 = v31[3];
      BOOL v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
        if (!v33) {
          goto LABEL_29;
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    BOOL v32 = 0;
    char v34 = 1;
    if (!v33)
    {
LABEL_29:
      if ((v34 & 1) == 0) {
        sub_10004D2C8(v32);
      }
      sub_100057D78((const void **)&theDict);
      if (v54) {
        uint64_t v37 = sub_100080778;
      }
      else {
        uint64_t v37 = 0;
      }
      if (v37)
      {
        CFDictionaryRef theDict = (CFDictionaryRef)CFDictionaryGetValue(v54, @"PacketFormat");
        sub_1000842D0(v58, (CFTypeRef *)&theDict);
        unint64_t v8 = sub_1009EB734(*(int **)v58, v38, v39);
        sub_1000570E8((const void **)v58);
        if (!HIDWORD(v8)) {
          LODWORD(v8) = 1;
        }
      }
      else
      {
        LODWORD(v8) = 1;
      }
      sub_100057D78((const void **)&v54);
      *(void *)long long v58 = &v53;
      char v40 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58);
      goto LABEL_57;
    }
LABEL_24:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v33 + 96))(&v55, v33, v23, 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
    sub_10004EFE4(&Value, &v55);
    CFDictionaryRef v35 = theDict;
    CFDictionaryRef theDict = (CFDictionaryRef)Value;
    *(void *)long long v58 = v35;
    CFDictionaryRef Value = 0;
    sub_100057D78((const void **)v58);
    sub_100057D78((const void **)&Value);
    sub_1000577C4(&v55);
    if (theDict) {
      unsigned int v36 = sub_100080778;
    }
    else {
      unsigned int v36 = 0;
    }
    if (v36)
    {
      CFDictionaryRef Value = (int *)CFDictionaryGetValue(theDict, @"MessageFormat");
      *(void *)long long v58 = 0;
      sub_10004EFE4(v58, (CFTypeRef *)&Value);
      CFDictionaryRef v54 = *(CFDictionaryRef *)v58;
      *(void *)long long v58 = 0;
      sub_100057D78((const void **)v58);
    }
    goto LABEL_29;
  }
  *(void *)long long v58 = &v53;
  if ((sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5][27] & 8) != 0)
  {
    *(void *)long long v58 = &v53;
    int v22 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58) + 5;
    LODWORD(v8) = 2;
  }
  else
  {
    *(void *)long long v58 = &v53;
    if ((sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5][27] & 4) == 0)
    {
      *(void *)long long v58 = &v53;
      BOOL v7 = (uint64_t *)*((unsigned __int8 *)sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5]
                      + 216);
      if ((v7 & 0xE0) == 0)
      {
        *(void *)long long v58 = &v53;
        char v40 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58);
        LODWORD(v8) = 0;
LABEL_57:
        int v22 = v40 + 5;
        goto LABEL_58;
      }
      LODWORD(v8) = sub_1009D51F8(*v3, v53, 1, v7);
      uint64_t v9 = v53;
      __int16 v10 = *v3;
      CFDictionaryRef theDict = 0;
      int v12 = (std::mutex *)Registry::getServiceMap(v11, v10);
      unsigned int v13 = v12;
      if (v14 < 0)
      {
        uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          uint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(v12);
      *(void *)long long v58 = v14;
      unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v58);
      if (v18)
      {
        uint64_t v20 = v18[3];
        unsigned int v19 = (std::__shared_weak_count *)v18[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          char v21 = 0;
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v20 = 0;
      }
      std::mutex::unlock(v13);
      unsigned int v19 = 0;
      char v21 = 1;
LABEL_42:
      if (v20)
      {
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v20 + 80))(&v55, v20, v9, 2, sms::Model::sSMSCarrierBundleDict, 0, 0);
        sub_10004EFE4(&Value, &v55);
        CFDictionaryRef v41 = theDict;
        CFDictionaryRef theDict = (CFDictionaryRef)Value;
        *(void *)long long v58 = v41;
        CFDictionaryRef Value = 0;
        sub_100057D78((const void **)v58);
        sub_100057D78((const void **)&Value);
        sub_1000577C4(&v55);
        if (theDict ? sub_100080778 : 0)
        {
          *(void *)long long v58 = 0;
          CFDictionaryRef Value = (int *)CFDictionaryGetValue(theDict, @"MessageFormat");
          sub_10004EFE4(v58, (CFTypeRef *)&Value);
          if (*(void *)v58) {
            long long v43 = sub_100080778;
          }
          else {
            long long v43 = 0;
          }
          if (v43)
          {
            uint64_t v55 = CFDictionaryGetValue(*(CFDictionaryRef *)v58, @"CSFBFormat");
            sub_1000842D0(&Value, &v55);
            unint64_t v46 = sub_1009EB734(Value, v44, v45);
            sub_1000570E8((const void **)&Value);
            if (HIDWORD(v46)) {
              LODWORD(v8) = v46;
            }
          }
          sub_100057D78((const void **)v58);
        }
      }
      if ((v21 & 1) == 0) {
        sub_10004D2C8(v19);
      }
      sub_100057D78((const void **)&theDict);
      *(void *)long long v58 = &v53;
      char v40 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58);
      goto LABEL_57;
    }
    *(void *)long long v58 = &v53;
    int v22 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58) + 5;
    LODWORD(v8) = 1;
  }
LABEL_58:
  *((_DWORD *)*v22 + 55) = v8;
  *(void *)long long v58 = &v53;
  if (v4 != *((_DWORD *)sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5] + 55))
  {
    uint64_t v47 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)long long v58 = &v53;
      sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58);
      uint64_t v48 = sms::asString();
      *(_DWORD *)long long v58 = 136315138;
      *(void *)&v58[4] = v48;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Using %s Encoder", v58, 0xCu);
    }
    (*(void (**)(void *))(*a1[316] + 128))(a1[316]);
    sub_1009DC120((uint64_t)a1, v53);
  }
  if (!v4)
  {
    *(void *)long long v58 = &v53;
    if (*((_DWORD *)sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5] + 55))
    {
      CFStringRef v49 = *v5;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)long long v58 = &v53;
        sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58);
        uint64_t v50 = sms::asString();
        *(_DWORD *)long long v58 = 136315138;
        *(void *)&v58[4] = v50;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Now have valid encoder %s, sending pending messages", v58, 0xCu);
      }
      *(void *)long long v58 = &v53;
      uint64_t v51 = sub_1001B0B78(a1 + 318, (int *)&v53, (uint64_t)&unk_10144E20E, (_DWORD **)v58)[5];
      uint64_t v52 = v51[37];
      v51[37] = 0;
      if (v52) {
        (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
      }
      sub_1009CE628((uint64_t)a1, v53);
    }
  }
}

void sub_1009DB788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  unint64_t v8 = va_arg(va1, const void *);
  va_copy(va2, va1);
  __int16 v10 = va_arg(va2, const void *);
  sub_1000570E8((const void **)va);
  sub_100057D78((const void **)va2);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1009DB854(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0 && *(unsigned char *)(a1 + 200))
  {
    BOOL v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Purging MO messages due to airplane mode", v4, 2u);
    }
    sub_1009CFF20(a1, 1);
  }
}

void sub_1009DB8D4(void **a1)
{
  subscriber::makeSimSlotRange();
  BOOL v2 = v4;
  if (v4 != v5)
  {
    while ((v6(*v2) & 1) == 0)
    {
      if (++v2 == v5)
      {
        BOOL v2 = v5;
        break;
      }
    }
LABEL_5:
    while (v2 != v5)
    {
      BOOL v3 = v2 + 1;
      sub_1009DAF14(a1, *v2);
      BOOL v2 = v5;
      if (v3 != v5)
      {
        BOOL v2 = v3;
        while ((v6(*v2) & 1) == 0)
        {
          if (++v2 == v5)
          {
            BOOL v2 = v5;
            goto LABEL_5;
          }
        }
      }
    }
  }
}

void sub_1009DB994(uint64_t a1, uint64_t a2)
{
  subscriber::makeSimSlotRange();
  BOOL v5 = v32;
  int v4 = v33;
  if (v32 != v33)
  {
    char v6 = v34;
    while ((v34(*v5) & 1) == 0)
    {
      if (++v5 == v33)
      {
        BOOL v5 = v33;
        break;
      }
    }
    BOOL v7 = v33;
    if (v5 != v33)
    {
      unint64_t v8 = (uint64_t **)(a2 + 8);
      long long v28 = (uint64_t **)(a1 + 2544);
      while (1)
      {
        int v31 = 0;
        int v31 = *v5;
        uint64_t v9 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
        uint64_t v29 = 0;
        v30[0] = 0;
        v30[1] = 0;
        sub_1009F8104(&v29, a1 + 432);
        __int16 v10 = v30[0];
        if (!v30[0]) {
          goto LABEL_34;
        }
        int v11 = v31;
        int v12 = v30;
        unsigned int v13 = v30[0];
        do
        {
          uint64_t v14 = v13;
          uint64_t v15 = v12;
          int v16 = *((_DWORD *)v13 + 8);
          if (v16 >= v31) {
            int v12 = (uint64_t **)v13;
          }
          else {
            ++v13;
          }
          unsigned int v13 = (uint64_t *)*v13;
        }
        while (v13);
        if (v12 == v30) {
          goto LABEL_34;
        }
        if (v16 < v31) {
          uint64_t v14 = (uint64_t *)v15;
        }
        if (v31 < *((_DWORD *)v14 + 8)) {
          goto LABEL_34;
        }
        if (!*v8) {
          goto LABEL_30;
        }
        unsigned int v17 = v8;
        unsigned int v18 = *v8;
        do
        {
          int v19 = *((_DWORD *)v18 + 8);
          BOOL v20 = v19 < v31;
          if (v19 >= v31) {
            char v21 = (uint64_t **)v18;
          }
          else {
            char v21 = (uint64_t **)(v18 + 1);
          }
          if (!v20) {
            unsigned int v17 = (uint64_t **)v18;
          }
          unsigned int v18 = *v21;
        }
        while (*v21);
        if (v17 == v8 || v31 < *((_DWORD *)v17 + 8)) {
          goto LABEL_30;
        }
        sub_1000389F8(*v8, v31);
        sub_1000389F8(v30[0], v31);
        if (rest::operator!=()) {
          break;
        }
LABEL_34:
        sub_100087ED0((uint64_t)&v29, v30[0]);
        uint64_t v27 = v5 + 1;
        BOOL v5 = v4;
        if (v27 != v4)
        {
          BOOL v5 = v27;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == v4)
            {
              BOOL v5 = v4;
              break;
            }
          }
        }
        if (v5 == v7) {
          return;
        }
      }
      __int16 v10 = v30[0];
      int v11 = v31;
LABEL_30:
      int v22 = (const std::string *)sub_1000389F8(v10, v11);
      *(void *)std::string buf = &v31;
      uint64_t v23 = sub_1001B0B78(v28, &v31, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      std::string::operator=((std::string *)v23[5] + 2, v22);
      int v24 = *v9;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        CFDictionaryRef v35 = &v31;
        int v25 = sub_1001B0B78(v28, &v31, (uint64_t)&unk_10144E20E, &v35)[5];
        int v26 = v25 + 6;
        if (*((char *)v25 + 71) < 0) {
          int v26 = (void *)*v26;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Phone number updated:%s", buf, 0xCu);
      }
      goto LABEL_34;
    }
  }
}

void sub_1009DBC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_1009DBCA8(uint64_t a1, uint64_t a2)
{
  int v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v5 = (Registry **)(a1 + 80);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    uint64_t v15 = *v4;
    uint64_t result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid slot context for ignore IMS Registration", (uint8_t *)&__p, 2u);
      return 0;
    }
    return result;
  }
  char v6 = *(unsigned __int8 **)(a1 + 208);
  BOOL v7 = (unsigned __int8 *)(a1 + 216);
  if (v6 == (unsigned __int8 *)(a1 + 216))
  {
LABEL_15:
    int v13 = 0;
    return v13 & a2;
  }
  while (1)
  {
    PersonalityIdFromSlotId();
    BOOL v8 = sub_10001D294(v6 + 32, (unsigned __int8 *)&__p);
    BOOL v9 = v8;
    if (SHIBYTE(v37) < 0)
    {
      operator delete((void *)__p);
      if (!v9) {
        goto LABEL_9;
      }
    }
    else if (!v8)
    {
      goto LABEL_9;
    }
    if (v6[56] && v6[58]) {
      break;
    }
LABEL_9:
    __int16 v10 = (unsigned __int8 *)*((void *)v6 + 1);
    if (v10)
    {
      do
      {
        int v11 = v10;
        __int16 v10 = *(unsigned __int8 **)v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        int v11 = (unsigned __int8 *)*((void *)v6 + 2);
        BOOL v12 = *(void *)v11 == (void)v6;
        char v6 = v11;
      }
      while (!v12);
    }
    char v6 = v11;
    if (v11 == v7) {
      goto LABEL_15;
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v6[58], *v5);
  unsigned int v17 = ServiceMap;
  if (v18 < 0)
  {
    int v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long __p = v18;
  int v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&__p);
  if (!v22)
  {
    uint64_t v24 = 0;
LABEL_29:
    std::mutex::unlock(v17);
    uint64_t v23 = 0;
    char v25 = 1;
    if (!v24) {
      goto LABEL_26;
    }
    goto LABEL_30;
  }
  uint64_t v24 = v22[3];
  uint64_t v23 = (std::__shared_weak_count *)v22[4];
  if (!v23) {
    goto LABEL_29;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  char v25 = 0;
  if (!v24)
  {
LABEL_26:
    int v26 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to get carrier interface", (uint8_t *)&__p, 2u);
    }
LABEL_44:
    if ((v25 & 1) == 0) {
      sub_10004D2C8(v23);
    }
    uint64_t v33 = *v4;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Ignoring IMS Registration during active CS call", (uint8_t *)&__p, 2u);
    }
    int v13 = 1;
    LODWORD(a2) = 1;
    return v13 & a2;
  }
LABEL_30:
  CFDictionaryRef v35 = 0;
  uint64_t v27 = operator new(0x10uLL);
  *((void *)&__p + 1) = v27 + 2;
  uint64_t v37 = v27 + 2;
  *uint64_t v27 = @"SMSSettings";
  v27[1] = @"UseIMSDuringCSCall";
  *(void *)&long long __p = v27;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, long long *, void, void))(*(void *)v24 + 88))(&v34, v24, a2, 1, &__p, 0, 0);
  sub_1000057AC(&v35, &v34);
  sub_1000577C4(&v34);
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  if (v35) {
    uint64_t v29 = sub_100084B4C;
  }
  else {
    uint64_t v29 = 0;
  }
  if (!v29)
  {
    sub_100062778((const void **)&v35);
    goto LABEL_44;
  }
  LOBYTE(__p) = 0;
  ctu::cf::assign((ctu::cf *)&__p, v35, v28);
  int v30 = __p;
  LODWORD(a2) = (_BYTE)__p == 0;
  int v31 = *v4;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v32 = "false";
    if (!v30) {
      BOOL v32 = "true";
    }
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Ignore IMS Registration during CS call (carrier pref): %s", (uint8_t *)&__p, 0xCu);
  }
  sub_100062778((const void **)&v35);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  int v13 = 1;
  return v13 & a2;
}

void sub_1009DC0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
  sub_100062778(&a10);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1009DC120(uint64_t a1, uint64_t a2)
{
  int v15 = a2;
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  int v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  *(void *)std::string buf = &v15;
  if (!*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 55))
  {
    BOOL v5 = *v4;
    int v6 = 0;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    *(_WORD *)std::string buf = 0;
    BOOL v7 = "#I BB not ready since Encoder unknown";
    goto LABEL_16;
  }
  *(void *)std::string buf = &v15;
  if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261))
  {
    BOOL v5 = *v4;
    int v6 = 0;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    *(_WORD *)std::string buf = 0;
    BOOL v7 = "#I BB not ready since service state = not ready";
    goto LABEL_16;
  }
  *(void *)std::string buf = &v15;
  if (*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 55) == 2)
  {
    *(void *)std::string buf = &v15;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261) == 1)
    {
      BOOL v5 = *v4;
      int v6 = 0;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v7 = "#I BB not ready since encoder is 3GPP2 and only 3GPP SMS service is up";
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
      int v6 = 0;
      goto LABEL_18;
    }
  }
  *(void *)std::string buf = &v15;
  if (*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 55) == 1)
  {
    *(void *)std::string buf = &v15;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261) == 2)
    {
      BOOL v5 = *v4;
      int v6 = 0;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v7 = "#I BB not ready since encoder is 3GPP and only 3GPP2 SMS service is up";
      goto LABEL_16;
    }
  }
  int v6 = 1;
LABEL_18:
  *(void *)std::string buf = &v15;
  if (*((unsigned __int8 *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
       + 268) != v6)
  {
    *(void *)std::string buf = &v15;
    *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 268) = v6;
    BOOL v8 = *v4;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)std::string buf = &v15;
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 268)) {
        BOOL v9 = "up";
      }
      else {
        BOOL v9 = "down";
      }
      *(void *)std::string buf = &v15;
      sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      uint64_t v10 = sms::asString();
      *(void *)std::string buf = &v15;
      int v11 = (uint64_t *)*((char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                       + 261);
      if ((unint64_t)v11 > 3) {
        BOOL v12 = "???";
      }
      else {
        BOOL v12 = off_101A28DD0[(void)v11];
      }
      int v13 = sub_1009CA2D8(a1, v15, v11);
      uint64_t v14 = "false";
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      __int16 v17 = 2080;
      if (v13) {
        uint64_t v14 = "true";
      }
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      uint64_t v20 = v12;
      __int16 v21 = 2080;
      int v22 = v14;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SMS Baseband service is: %s for encoder: %s service state: %s baseband activated: %s", buf, 0x2Au);
    }
    sub_1009E1038(a1, v15);
  }
}

uint64_t sub_1009DC57C(uint64_t a1)
{
  uint64_t result = subscriber::makeSimSlotRange();
  int v4 = v20;
  BOOL v3 = v21;
  if (v20 != v21)
  {
    BOOL v5 = v22;
    while (1)
    {
      uint64_t result = v22(*v4);
      if (result) {
        break;
      }
      if (++v4 == v21)
      {
        int v4 = v21;
        break;
      }
    }
    int v6 = v21;
    if (v4 != v21)
    {
      BOOL v7 = (uint64_t *)(a1 + 296);
      do
      {
        unsigned int v19 = 0;
        int v8 = *v4;
        unsigned int v19 = *v4;
        BOOL v9 = (uint64_t *)*v7;
        if (!*v7) {
          goto LABEL_19;
        }
        uint64_t v10 = a1 + 296;
        uint64_t v11 = *v7;
        do
        {
          int v12 = *(_DWORD *)(v11 + 28);
          BOOL v13 = v12 < v8;
          if (v12 >= v8) {
            uint64_t v14 = (uint64_t *)v11;
          }
          else {
            uint64_t v14 = (uint64_t *)(v11 + 8);
          }
          if (!v13) {
            uint64_t v10 = v11;
          }
          uint64_t v11 = *v14;
        }
        while (*v14);
        if ((uint64_t *)v10 == v7 || (int v15 = *(_DWORD *)(v10 + 28), v8 < v15) || v15 == *(_DWORD *)(a1 + 324))
        {
LABEL_19:
          uint64_t result = rest::operator==();
          if (result) {
            goto LABEL_31;
          }
          BOOL v9 = (uint64_t *)*v7;
          int v8 = v19;
        }
        if (!v9) {
LABEL_38:
        }
          sub_1000C14F0("map::at:  key not found");
        while (1)
        {
          while (1)
          {
            int v16 = *((_DWORD *)v9 + 7);
            if (v16 <= v8) {
              break;
            }
            BOOL v9 = (uint64_t *)*v9;
            if (!v9) {
              goto LABEL_38;
            }
          }
          if (v16 >= v8) {
            break;
          }
          BOOL v9 = (uint64_t *)v9[1];
          if (!v9) {
            goto LABEL_38;
          }
        }
        int v17 = *((_DWORD *)v9 + 8);
        uint64_t result = subscriber::isValidSimSlot();
        if (!result) {
          return result;
        }
        uint64_t v23 = (int *)&v19;
        uint64_t result = (uint64_t)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v19, (uint64_t)&unk_10144E20E, &v23);
        *(_DWORD *)(*(void *)(result + 40) + 224) = v17;
LABEL_31:
        uint64_t v18 = v4 + 1;
        int v4 = v3;
        if (v18 != v3)
        {
          int v4 = v18;
          while (1)
          {
            uint64_t result = v5(*v4);
            if (result) {
              break;
            }
            if (++v4 == v3)
            {
              int v4 = v3;
              break;
            }
          }
        }
      }
      while (v4 != v6);
    }
  }
  return result;
}

uint64_t sub_1009DC748(uint64_t result, int a2)
{
  if (a2 == 2)
  {
    uint64_t v33 = v2;
    uint64_t v34 = v3;
    uint64_t v4 = result;
    if (*(_DWORD *)(result + 2600) == 1)
    {
      uint64_t result = subscriber::makeSimSlotRange();
      int v6 = v28;
      BOOL v5 = v29;
      if (v28 != v29)
      {
        BOOL v7 = v30;
        while (1)
        {
          uint64_t result = v30(*v6);
          if (result) {
            break;
          }
          if (++v6 == v29)
          {
            int v6 = v29;
            break;
          }
        }
        int v8 = v29;
        if (v6 != v29)
        {
          BOOL v9 = (uint64_t **)(v4 + 2544);
          char v25 = v29;
          uint64_t v26 = v4;
          do
          {
            unsigned int v27 = 0;
            unsigned int v27 = *v6;
            uint64_t result = (***(uint64_t (****)(void))(v4 + 2568))(*(void *)(v4 + 2568));
            if (result)
            {
              uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v27);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Invalidating all Cell Broadcast Messages", buf, 2u);
              }
              *(void *)std::string buf = &v27;
              uint64_t v11 = *sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
              *(void *)std::string buf = &v27;
              uint64_t v12 = sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][1];
              if (v11 != v12)
              {
                BOOL v13 = (void *)v11;
                while (1)
                {
                  *(void *)std::string buf = *v13;
                  uint64_t v14 = (std::__shared_weak_count *)v13[1];
                  BOOL v32 = v14;
                  if (v14)
                  {
                    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
                    BOOL v15 = sub_1009ED27C((uint64_t)buf);
                    sub_10004D2C8(v14);
                    if (v15) {
                      break;
                    }
                    goto LABEL_19;
                  }
                  if (sub_1009ED27C((uint64_t)buf)) {
                    break;
                  }
LABEL_19:
                  v13 += 2;
                  if (v13 == (void *)v12)
                  {
                    uint64_t v11 = v12;
                    goto LABEL_32;
                  }
                }
                uint64_t v11 = v12;
                if (v13 != (void *)v12)
                {
                  int v16 = v13 + 2;
                  uint64_t v11 = (uint64_t)v13;
                  while (v16 != (void *)v12)
                  {
                    *(void *)std::string buf = *v16;
                    int v17 = (std::__shared_weak_count *)v16[1];
                    BOOL v32 = v17;
                    if (v17)
                    {
                      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
                      BOOL v18 = sub_1009ED27C((uint64_t)buf);
                      sub_10004D2C8(v17);
                      if (v18) {
                        goto LABEL_31;
                      }
                    }
                    else if (sub_1009ED27C((uint64_t)buf))
                    {
                      goto LABEL_31;
                    }
                    long long v19 = *(_OWORD *)v16;
                    *int v16 = 0;
                    v16[1] = 0;
                    uint64_t v20 = *(std::__shared_weak_count **)(v11 + 8);
                    *(_OWORD *)uint64_t v11 = v19;
                    if (v20) {
                      sub_10004D2C8(v20);
                    }
                    v11 += 16;
LABEL_31:
                    v16 += 2;
                  }
                }
              }
LABEL_32:
              *(void *)std::string buf = &v27;
              __int16 v21 = sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
              *(void *)std::string buf = &v27;
              int v22 = sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
              sub_1009D0EAC((uint64_t)v21, v11, (long long *)v22[5][1]);
              *(void *)std::string buf = &v27;
              uint64_t v23 = sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
              sub_10019E028(v23[5] + 34);
              *(void *)std::string buf = &v27;
              uint64_t result = (uint64_t)sub_1001B0B78(v9, (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
              *(void *)(*(void *)(result + 40) + 568) = *(void *)(*(void *)(result + 40) + 560);
              int v8 = v25;
              uint64_t v4 = v26;
            }
            uint64_t v24 = v6 + 1;
            int v6 = v5;
            if (v24 != v5)
            {
              int v6 = v24;
              while (1)
              {
                uint64_t result = v7(*v6);
                if (result) {
                  break;
                }
                if (++v6 == v5)
                {
                  int v6 = v5;
                  break;
                }
              }
            }
          }
          while (v6 != v8);
        }
      }
    }
  }
  return result;
}

void sub_1009DCAC0(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x100000000) == 0 && *(unsigned char *)(a1 + 260))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Purging MO messages due to reset", v4, 2u);
    }
    sub_1009CFF20(a1, 1);
  }
}

void sub_1009DCB40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (Registry **)(a2 + 80);
  if (subscriber::isValidSimSlot())
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *v6);
    BOOL v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      BOOL v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_13:
        long long v19 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
        uint64_t v20 = v19;
        if (v16)
        {
          *(void *)std::string buf = 0;
          uint64_t v26 = 0;
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 8))(buf, v16, a3);
          if (*(void *)buf)
          {
            if (*(char *)(*(void *)buf + 47) < 0)
            {
              sub_10004FC84((unsigned char *)a1, *(void **)(*(void *)buf + 24), *(void *)(*(void *)buf + 32));
            }
            else
            {
              long long v21 = *(_OWORD *)(*(void *)buf + 24);
              *(void *)(a1 + 16) = *(void *)(*(void *)buf + 40);
              *(_OWORD *)a1 = v21;
            }
          }
          else
          {
            uint64_t v23 = *v20;
            if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v24 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to get Personality Info. Not updating TPMR", v24, 2u);
            }
            *(void *)a1 = 0;
            *(void *)(a1 + 8) = 0;
            *(void *)(a1 + 16) = 0;
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
        }
        else
        {
          int v22 = *v19;
          if (os_log_type_enabled(*v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to get Personality Shop. Not updating TPMR", buf, 2u);
          }
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        return;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    BOOL v15 = 0;
    char v17 = 1;
    goto LABEL_13;
  }
  BOOL v18 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid slot for account ID", buf, 2u);
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
}

void sub_1009DCDC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009DCDFC(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  CFNumberRef v45 = 0;
  unint64_t v46 = 0;
  uint64_t v47 = 0;
  sub_1009DCB40((uint64_t)&v45, a1, a2);
  BOOL v9 = (uint64_t *)HIBYTE(v47);
  if (v47 < 0) {
    BOOL v9 = v46;
  }
  if (v9)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 80));
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      char v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        if (!v18) {
          goto LABEL_10;
        }
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
    if (!v18)
    {
LABEL_10:
      uint64_t v20 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet. Not updating TPMR", buf, 2u);
      }
LABEL_40:
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
      goto LABEL_42;
    }
LABEL_14:
    CFNumberRef v48 = 0;
    *(void *)std::string buf = a3;
    CFNumberRef v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
    if (v21)
    {
      CFNumberRef v22 = v48;
      CFNumberRef v48 = v21;
      *(void *)std::string buf = v22;
      sub_1000570E8((const void **)buf);
    }
    CFNumberRef v44 = v48;
    CFNumberRef v48 = 0;
    sub_1000570E8((const void **)&v48);
    (*(void (**)(uint64_t, void **, const __CFString *, CFNumberRef, const __CFString *, void, uint64_t, void))(*(void *)v18 + 16))(v18, &v45, @"TPMR", v44, @"SMSControllerWalletDomain", 0, 1, 0);
    sub_1000570E8((const void **)&v44);
    uint64_t v23 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Cached TPMR : %u", buf, 8u);
    }
    if (!a4) {
      goto LABEL_40;
    }
    char v25 = (std::mutex *)Registry::getServiceMap(v24, *(Registry **)(a1 + 80));
    uint64_t v26 = v25;
    if (v27 < 0)
    {
      CFBooleanRef v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v25);
    *(void *)std::string buf = v27;
    int v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      BOOL v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        char v40 = v32;
        sub_10004D2C8(v32);
        char v34 = 0;
        if (!v33)
        {
LABEL_28:
          CFDictionaryRef v35 = *v8;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Failed to get Subscriber Interface. Not updating TPMR in sim.", buf, 2u);
          }
        }
LABEL_30:
        unsigned int v36 = operator new(1uLL);
        *unsigned int v36 = a3;
        sub_10003E168(buf, (void *)(a1 + 8));
        uint64_t v38 = *(void *)buf;
        uint64_t v37 = v52;
        if (v52)
        {
          atomic_fetch_add_explicit(&v52->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v37);
        }
        unsigned int v42 = 0;
        uint64_t v43 = 0;
        long long __p = 0;
        sub_10005C928(&__p, v36, (uint64_t)(v36 + 1), 1uLL);
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v50 = 0;
        CFNumberRef v39 = operator new(0x28uLL);
        void *v39 = off_101A270F8;
        v39[1] = a1;
        v39[2] = v38;
        v39[3] = v37;
        *((_DWORD *)v39 + 8) = a2;
        uint64_t v50 = v39;
        (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void *))(*(void *)v33 + 224))(v33, a2, 36, &__p, v49);
        sub_100060644(v49);
        if (__p)
        {
          unsigned int v42 = __p;
          operator delete(__p);
        }
        if (v37) {
          std::__shared_weak_count::__release_weak(v37);
        }
        operator delete(v36);
        if ((v34 & 1) == 0) {
          sub_10004D2C8(v40);
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    char v40 = 0;
    char v34 = 1;
    if (!v33) {
      goto LABEL_28;
    }
    goto LABEL_30;
  }
LABEL_42:
  if (SHIBYTE(v47) < 0) {
    operator delete(v45);
  }
}

void sub_1009DD2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,uint64_t a23)
{
  sub_100060644(&a23);
  if (__p) {
    operator delete(__p);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  operator delete(v25);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009DD3A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  sub_1009DCB40((uint64_t)&__p, a1, a2);
  BOOL v5 = (uint64_t *)HIBYTE(v25);
  if (v25 < 0) {
    BOOL v5 = v24;
  }
  if (!v5)
  {
    unsigned __int8 v17 = 0;
    goto LABEL_27;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 80));
  BOOL v7 = ServiceMap;
  if (v8 < 0)
  {
    BOOL v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    char v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  char v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_10:
    uint64_t v16 = *v4;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet", buf, 2u);
    }
    unsigned __int8 v17 = 0;
    if (v15) {
      goto LABEL_27;
    }
LABEL_26:
    sub_10004D2C8(v13);
    goto LABEL_27;
  }
LABEL_17:
  *(void *)std::string buf = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v14 + 24))(&v22, v14, &__p, @"TPMR", @"SMSControllerWalletDomain", 0, 1);
  sub_1000842D0(buf, &v22);
  sub_1000577C4(&v22);
  if (*(void *)buf) {
    char v19 = sub_100081E58;
  }
  else {
    char v19 = 0;
  }
  if (v19)
  {
    LOBYTE(v22) = 0;
    ctu::cf::assign((ctu::cf *)&v22, *(unsigned __int8 **)buf, v18);
    unsigned __int8 v17 = (_BYTE)v22 + 1;
  }
  else
  {
    uint64_t v20 = *v4;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v22) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to read TPMR value", (uint8_t *)&v22, 2u);
    }
    unsigned __int8 v17 = 0;
  }
  sub_1000570E8((const void **)buf);
  if ((v15 & 1) == 0) {
    goto LABEL_26;
  }
LABEL_27:
  if (SHIBYTE(v25) < 0) {
    operator delete(__p);
  }
  return v17;
}

void sub_1009DD62C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16)
{
  sub_1000570E8(&a16);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009DD680(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 384);
  uint64_t v2 = *(void *)(a1 + 392);
  if (v1 != v2)
  {
    uint64_t v3 = (void *)(a1 + 344);
    uint64_t v4 = (uint64_t **)(a1 + 2544);
    do
    {
      int v5 = *(_DWORD *)v1;
      if (subscriber::isValidSimSlot())
      {
        uint64_t v7 = *(void *)(v1 + 16);
        uint64_t v6 = *(void *)(v1 + 24);
        if (v7 == v6)
        {
          BOOL v10 = 0;
        }
        else
        {
          uint64_t v8 = v7 + 4;
          do
          {
            unsigned int v9 = *(_DWORD *)(v8 - 4) - 1;
            BOOL v10 = v9 < 2;
            BOOL v11 = v9 < 2 || v8 == v6;
            v8 += 4;
          }
          while (!v11);
        }
        int v20 = v5;
        if (subscriber::isValidSimSlot())
        {
          uint64_t v12 = *v3;
          if (*v3)
          {
            char v13 = v3;
            do
            {
              int v14 = *(_DWORD *)(v12 + 32);
              BOOL v15 = v14 < v5;
              if (v14 >= v5) {
                uint64_t v16 = (uint64_t *)v12;
              }
              else {
                uint64_t v16 = (uint64_t *)(v12 + 8);
              }
              if (!v15) {
                char v13 = (void *)v12;
              }
              uint64_t v12 = *v16;
            }
            while (*v16);
            if (v13 != v3)
            {
              char v17 = !v10;
              if (*((_DWORD *)v13 + 8) > v5) {
                char v17 = 1;
              }
              if ((v17 & 1) == 0)
              {
                int v18 = *((unsigned __int8 *)v13 + 41);
                if (subscriber::isSimAbsent())
                {
                  if (v18 == 1)
                  {
                    CFNumberRef v21 = &v20;
                    char v19 = sub_1001B0B78(v4, &v20, (uint64_t)&unk_10144E20E, &v21);
                    sub_10019E028(v19[5]);
                  }
                }
              }
            }
          }
        }
      }
      v1 += 168;
    }
    while (v1 != v2);
  }
}

void sub_1009DD7D4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2304);
  uint64_t v3 = (void *)(a1 + 2312);
  if (v2 != (void *)(a1 + 2312))
  {
    int v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        break;
      }
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          BOOL v11 = (uint64_t *)v6;
        }
        else {
          BOOL v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 7)) {
        break;
      }
      uint64_t v12 = v2 + 4;
      if (*((unsigned __int8 *)v8 + 32) != *((unsigned __int8 *)v2 + 32)) {
        goto LABEL_14;
      }
LABEL_27:
      char v17 = (void *)v2[1];
      if (v17)
      {
        do
        {
          int v18 = v17;
          char v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v18 = (void *)v2[2];
          BOOL v13 = *v18 == (void)v2;
          uint64_t v2 = v18;
        }
        while (!v13);
      }
      uint64_t v2 = v18;
      if (v18 == v3) {
        return;
      }
    }
    uint64_t v12 = v2 + 4;
LABEL_14:
    if (subscriber::isValidSimSlot()) {
      BOOL v13 = *v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (!v13)
    {
      uint64_t v14 = *(void *)(a1 + 96);
      if (v14)
      {
        if (*(unsigned char *)(v14 + 149) && sub_100529568())
        {
          BOOL v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)char v19 = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Emergency SMS will be released", v19, 2u);
          }
          uint64_t v16 = *(void *)(a1 + 2648);
          *(void *)(a1 + 2648) = 0;
          if (v16) {
            (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
          }
          sub_1009D0860(a1);
        }
      }
    }
    goto LABEL_27;
  }
}

void sub_1009DD9A4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 2604) == 1)
  {
    subscriber::makeSimSlotRange();
    uint64_t v2 = v4;
    if (v4 != v5)
    {
      while ((v6(*v2) & 1) == 0)
      {
        if (++v2 == v5)
        {
          uint64_t v2 = v5;
          break;
        }
      }
LABEL_6:
      while (v2 != v5)
      {
        uint64_t v3 = v2 + 1;
        sub_1009DDA70(a1, *v2);
        uint64_t v2 = v5;
        if (v3 != v5)
        {
          uint64_t v2 = v3;
          while ((v6(*v2) & 1) == 0)
          {
            if (++v2 == v5)
            {
              uint64_t v2 = v5;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
}

void sub_1009DDA70(uint64_t a1, int a2)
{
  long long __p = 0;
  CFBooleanRef v28 = 0;
  uint64_t v29 = 0;
  sms::Controller::getDynamicMessageModes_sync(a1, a2, (uint64_t *)&__p);
  v26[0] = 1;
  v26[1] = a1 + 2376;
  uint64_t v4 = *(void *)(a1 + 2416);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = v4;
        int v6 = *(_DWORD *)(v4 + 32);
        if (v6 <= a2) {
          break;
        }
        uint64_t v4 = *(void *)v5;
        uint64_t v7 = (uint64_t **)v5;
        if (!*(void *)v5) {
          goto LABEL_9;
        }
      }
      if (v6 >= a2) {
        break;
      }
      uint64_t v4 = *(void *)(v5 + 8);
      if (!v4)
      {
        uint64_t v7 = (uint64_t **)(v5 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(a1 + 2416);
    uint64_t v5 = a1 + 2416;
LABEL_9:
    uint64_t v8 = operator new(0x40uLL);
    char v8[8] = a2;
    *((void *)v8 + 6) = 0;
    *((void *)v8 + 7) = 0;
    *((void *)v8 + 5) = 0;
    sub_100046C38((uint64_t **)(a1 + 2408), v5, v7, (uint64_t *)v8);
    uint64_t v5 = (uint64_t)v8;
  }
  if ((void **)(v5 + 40) != &__p)
  {
    int v9 = (char *)__p;
    BOOL v10 = v28;
    size_t v11 = v28 - (unsigned char *)__p;
    unint64_t v12 = (v28 - (unsigned char *)__p) >> 2;
    uint64_t v13 = *(void *)(v5 + 56);
    uint64_t v14 = *(char **)(v5 + 40);
    if (v12 <= (v13 - (uint64_t)v14) >> 2)
    {
      int v20 = *(char **)(v5 + 48);
      uint64_t v17 = v5 + 48;
      char v19 = v20;
      size_t v21 = v20 - v14;
      unint64_t v22 = (v20 - v14) >> 2;
      if (v22 < v12)
      {
        uint64_t v23 = (char *)__p + 4 * v22;
        if (v19 != v14)
        {
          memmove(v14, __p, v21);
          uint64_t v14 = *(char **)v17;
        }
        size_t v11 = v10 - v23;
        if (v10 == v23) {
          goto LABEL_30;
        }
        uint64_t v24 = v14;
        uint64_t v25 = v23;
        goto LABEL_29;
      }
    }
    else
    {
      if (v14)
      {
        *(void *)(v5 + 48) = v14;
        operator delete(v14);
        uint64_t v13 = 0;
        *(void *)(v5 + 40) = 0;
        *(void *)(v5 + 48) = 0;
        *(void *)(v5 + 56) = 0;
      }
      if ((v11 & 0x8000000000000000) != 0) {
        goto LABEL_34;
      }
      uint64_t v15 = v13 >> 1;
      if (v13 >> 1 <= v12) {
        uint64_t v15 = v12;
      }
      unint64_t v16 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v15;
      if (v16 >> 62) {
LABEL_34:
      }
        sub_10006A748();
      uint64_t v14 = (char *)sub_10005ECD8(v5 + 56, v16);
      *(void *)(v5 + 48) = v14;
      uint64_t v17 = v5 + 48;
      *(void *)(v17 - 8) = v14;
      *(void *)(v17 + 8) = &v14[4 * v18];
    }
    if (v10 == v9)
    {
LABEL_30:
      *(void *)uint64_t v17 = &v14[v11];
      goto LABEL_31;
    }
    uint64_t v24 = v14;
    uint64_t v25 = v9;
LABEL_29:
    memmove(v24, v25, v11);
    goto LABEL_30;
  }
LABEL_31:
  sub_1009FFC74((uint64_t)v26);
  if (__p)
  {
    CFBooleanRef v28 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1009DDC64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009DDC88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2328);
  uint64_t v3 = (void *)(a1 + 2336);
  if (v2 != (void *)(a1 + 2336))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      signed int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        signed int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          size_t v11 = (uint64_t *)v6;
        }
        else {
          size_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_18;
      }
      unint64_t v12 = (unsigned __int8 *)v2[5];
      uint64_t v13 = (unsigned __int8 *)v8[5];
      uint64_t v14 = (unsigned __int8 *)v8[6];
      if (v14 - v13 == v2[6] - (void)v12)
      {
        while (v13 != v14)
        {
          if (!sub_1000609C0((uint64_t)&v20, v13, v12))
          {
            signed int v7 = *((_DWORD *)v2 + 8);
            goto LABEL_28;
          }
          v13 += 24;
          v12 += 24;
        }
        goto LABEL_20;
      }
LABEL_28:
      uint64_t v16 = a1;
      uint64_t v15 = (void ***)(v2 + 5);
LABEL_19:
      sub_1009F89B0(v16, v7, v15);
LABEL_20:
      uint64_t v17 = (void *)v2[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v2[2];
          BOOL v19 = *v18 == (void)v2;
          uint64_t v2 = v18;
        }
        while (!v19);
      }
      uint64_t v2 = v18;
      if (v18 == v3) {
        return;
      }
    }
    signed int v7 = *((_DWORD *)v2 + 8);
LABEL_18:
    uint64_t v15 = (void ***)(v2 + 5);
    uint64_t v16 = a1;
    goto LABEL_19;
  }
}

void sub_1009DDDBC(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    signed int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    size_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  size_t v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v15 = v14;
  if (v12)
  {
    CFStringRef v49 = 0;
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(&buf, v12, a2, 1, @"PreventDetachAfterEmergencyCallTimer", 0, 0);
    sub_1000842D0(&v49, (CFTypeRef *)&buf);
    uint64_t v16 = sub_1000577C4((const void **)&buf);
    if (v49) {
      uint64_t v18 = sub_100081E58;
    }
    else {
      uint64_t v18 = 0;
    }
    if (!v18)
    {
      uint64_t v25 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I PreventDetachAfterEmergencyCallTimer not set in the carrier bundle. Returning!", (uint8_t *)&buf, 2u);
      }
      goto LABEL_59;
    }
    LODWORD(buf) = 0;
    ctu::cf::assign((ctu::cf *)v16, v49, v17);
    uint64_t v19 = buf;
    if (!buf)
    {
      char v26 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "PreventDetachAfterEmergencyCallTimer set to 0. Returning", (uint8_t *)&buf, 2u);
      }
      goto LABEL_59;
    }
    if (!*(void *)(a1 + 2656))
    {
      sub_100058DB0(&buf, "/cc/assertions/emergency_online");
      ctu::rest::AssertionHandle::create();
      if (v51 < 0) {
        operator delete((void *)buf);
      }
      long long v27 = v48;
      long long v48 = 0uLL;
      CFBooleanRef v28 = *(std::__shared_weak_count **)(a1 + 2664);
      *(_OWORD *)(a1 + 2656) = v27;
      if (v28)
      {
        sub_10004D2C8(v28);
        if (*((void *)&v48 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v48 + 1));
        }
      }
    }
    uint64_t v20 = *(void *)(a1 + 2616);
    size_t v21 = *v15;
    BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (!v22) {
        goto LABEL_33;
      }
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v19;
      uint64_t v23 = "#I Prevent Detach timer re-starting for %lld secs";
    }
    else
    {
      if (!v22) {
        goto LABEL_33;
      }
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v19;
      uint64_t v23 = "#I Prevent Detach timer starting for %lld secs";
    }
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&buf, 0xCu);
LABEL_33:
    uint64_t v29 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v29 || (uint64_t v30 = *(void *)(a1 + 8), (v31 = std::__shared_weak_count::lock(v29)) == 0)) {
      sub_100088B9C();
    }
    BOOL v32 = v31;
    atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v31);
    Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 80));
    uint64_t v33 = buf;
    sub_100058DB0(__p, "PreventDetachTimer");
    char v34 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v34;
    if (v34) {
      dispatch_retain(v34);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_1009DE498;
    aBlock[3] = &unk_101A24DB0;
    aBlock[4] = a1;
    void aBlock[5] = v30;
    unsigned int v42 = v32;
    atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    int v43 = a2;
    CFNumberRef v44 = _Block_copy(aBlock);
    sub_100118A44(v33, (uint64_t)__p, 1, 1000000 * v19, &object, &v44);
    uint64_t v35 = v48;
    *(void *)&long long v48 = 0;
    uint64_t v36 = *(void *)(a1 + 2616);
    *(void *)(a1 + 2616) = v35;
    if (v36)
    {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
      uint64_t v37 = v48;
      *(void *)&long long v48 = 0;
      if (v37) {
        (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
      }
    }
    if (v44) {
      _Block_release(v44);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v47 < 0) {
      operator delete(__p[0]);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (*(void *)(a1 + 2616))
    {
      uint64_t v38 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v19;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Prevent detach timer is set to %lld secs", (uint8_t *)&buf, 0xCu);
      }
      if (*(double *)(a1 + 2704) != (double)v19)
      {
        *(double *)(a1 + 2704) = (double)v19;
        uint64_t v39 = *(void *)(a1 + 2696);
        if (v39) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 48))(v39, a1 + 2704);
        }
      }
      uint64_t v40 = *(void *)(a1 + 112);
      if (v40) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v40 + 152))(v40, a2);
      }
    }
    if (v42) {
      std::__shared_weak_count::__release_weak(v42);
    }
    std::__shared_weak_count::__release_weak(v32);
LABEL_59:
    sub_1000570E8((const void **)&v49);
    goto LABEL_60;
  }
  uint64_t v24 = *v14;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unable to get Carrier Settings object.", (uint8_t *)&buf, 2u);
  }
LABEL_60:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1009DE3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v26);
  sub_1000570E8((const void **)(v28 - 120));
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(a1);
}

void sub_1009DE498(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Prevent Detach timer expired, releasing emergency online assertion", (uint8_t *)&__p, 2u);
        }
        if (*(void *)(v3 + 2656))
        {
          signed int v7 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency online timer expired, releasing emergency online assertion", (uint8_t *)&__p, 2u);
          }
          uint64_t v8 = *(std::__shared_weak_count **)(v3 + 2664);
          *(_OWORD *)(v3 + 2656) = 0u;
          if (v8) {
            sub_10004D2C8(v8);
          }
        }
        unsigned int v9 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Prevent detach timer is cleared", (uint8_t *)&__p, 2u);
        }
        if (*(double *)(v3 + 2704) != 0.0)
        {
          *(void *)(v3 + 2704) = 0;
          uint64_t v10 = *(void *)(v3 + 2696);
          if (v10) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v3 + 2704);
          }
        }
        uint64_t v11 = *(void *)(v3 + 2616);
        *(void *)(v3 + 2616) = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
        uint64_t v12 = *(void *)(v3 + 112);
        if (v12) {
          (*(void (**)(uint64_t, void))(*(void *)v12 + 152))(v12, *(unsigned int *)(a1 + 56));
        }
        char v13 = (uint64_t **)(v3 + 2544);
        uint64_t v14 = (int *)(a1 + 56);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
        uint64_t v15 = sub_1001B0B78((uint64_t **)(v3 + 2544), v14, (uint64_t)&unk_10144E20E, &__p)[5];
        sub_10005CD2C((uint64_t)(v15 + 67), (char *)v15[68]);
        v15[67] = (uint64_t)(v15 + 68);
        v15[69] = 0;
        v15[68] = 0;
        uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *v14);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = v14;
          CFNumberRef v17 = sub_1001B0B78(v13, v14, (uint64_t)&unk_10144E20E, &v20);
          sub_10082FF60(v17[5], &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315138;
          BOOL v22 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Emergency Text Numbers %s", buf, 0xCu);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009DE7A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009DE7C0(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (Registry **)(a1 + 80);
  subscriber::makeSimSlotRange();
  uint64_t v4 = v52;
  uint64_t v3 = v53;
  if (v52 != v53)
  {
    uint64_t v5 = v54;
    while ((v54(*v4) & 1) == 0)
    {
      if (++v4 == v53)
      {
        uint64_t v4 = v53;
        break;
      }
    }
    char v47 = v53;
    if (v4 != v53)
    {
      long long v48 = (uint64_t **)(v1 + 2544);
      unint64_t v46 = v2;
      do
      {
        unsigned int v51 = 0;
        unsigned int v51 = *v4;
        uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48));
        signed int v7 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Dumping SMS Param", (uint8_t *)&buf, 2u);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          if (*(unsigned char *)(v1 + 200)) {
            uint64_t v8 = "true";
          }
          else {
            uint64_t v8 = "false";
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          if (*((unsigned char *)sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf)[5] + 41)) {
            unsigned int v9 = "true";
          }
          else {
            unsigned int v9 = "false";
          }
          int v10 = sub_1009CA2D8(v1, v51, (uint64_t *)"true");
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          uint64_t v11 = "true";
          if (!v10) {
            uint64_t v11 = "false";
          }
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v9;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          uint64_t v59 = v11;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I fAirplaneMode: %s emergency callback mode: %s baseband activation status: %s", (uint8_t *)&buf, 0x20u);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          uint64_t v12 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          WirelessTechnologyList::asString((uint64_t *)&buf, (WirelessTechnologyList *)(v12[5] + 27));
          p_std::string buf = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v55.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Current Technologies: %s", (uint8_t *)&v55, 0xCu);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          uint64_t v14 = sms::asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v14;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Current Encoder: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          if (*((unsigned char *)sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf)[5] + 42)) {
            uint64_t v15 = "";
          }
          else {
            uint64_t v15 = " not";
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          if (*((unsigned char *)sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf)[5] + 270)) {
            uint64_t v16 = "true";
          }
          else {
            uint64_t v16 = "false";
          }
          BOOL v17 = sub_1009DF288(*v2, v51, (uint64_t *)"true");
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          uint64_t v18 = "";
          if (!v17) {
            uint64_t v18 = " not";
          }
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v16;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          uint64_t v59 = v18;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I We are%s IMS registered, Over Wifi(%s), and we will%s fallback to signaling on IMS send failures", (uint8_t *)&buf, 0x20u);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          uint64_t v19 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          uint64_t v20 = "";
          if (!*((unsigned char *)v19[5] + 72)) {
            uint64_t v20 = " not";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Reply address is%s being used", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v21 = sub_1009CFC3C(v1, v51);
          BOOL v22 = "true";
          if (!v21) {
            BOOL v22 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Rat change timer is running: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v55.__r_.__value_.__l.__data_) = v51;
          if (subscriber::isValidSimSlot())
          {
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v55;
            uint64_t v23 = sub_1001B0B78(v48, (int *)&v55, (uint64_t)&unk_10144E20E, &buf);
            uint64_t v24 = "true";
            if (!v23[5][38]) {
              uint64_t v24 = "false";
            }
          }
          else
          {
            uint64_t v24 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Retry wait timer is running: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = "true";
          if (!*(void *)(v1 + 2640)) {
            uint64_t v25 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I 2G hints timer is running: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          int v26 = *((_DWORD *)sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf)[5] + 78);
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v26;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I VVM data connection usable: %d", (uint8_t *)&buf, 8u);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          char v27 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          uint64_t v28 = "true";
          if (!*((unsigned char *)v27[5] + 268)) {
            uint64_t v28 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I BB service ready status: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          uint64_t v29 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          uint64_t v30 = "true";
          if (!*((unsigned char *)v29[5] + 269)) {
            uint64_t v30 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SMS ready status: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          int v31 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf)[5];
          BOOL v32 = v31 + 46;
          if (*((char *)v31 + 391) < 0) {
            BOOL v32 = (void *)*v32;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I VVM beacon SMSC address: %s", (uint8_t *)&buf, 0xCu);
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          sub_1009CFCA8((char **)&__p, v1, v51);
          uint64_t v33 = v1;
          uint64_t v35 = (char *)__p;
          char v34 = v50;
          memset(&v55, 0, sizeof(v55));
          if (__p == v50)
          {
            unsigned int v42 = &v55;
          }
          else
          {
            unint64_t v36 = *(char *)__p;
            uint64_t v37 = "???";
            if (v36 <= 2) {
              uint64_t v37 = off_101A28DB8[v36];
            }
            sub_10003ED78(&v55, v37);
            for (uint64_t i = v35 + 1; i != v34; ++i)
            {
              *((unsigned char *)&buf.__r_.__value_.__s + 23) = 1;
              strcpy((char *)&buf, ",");
              std::string::append(&v55, (const std::string::value_type *)&buf, 1uLL);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              unint64_t v39 = *i;
              uint64_t v40 = "???";
              if (v39 <= 2) {
                uint64_t v40 = off_101A28DB8[v39];
              }
              size_t v41 = strlen(v40);
              std::string::append(&v55, v40, v41);
            }
            unsigned int v42 = &v55;
            if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned int v42 = (std::string *)v55.__r_.__value_.__r.__words[0];
            }
          }
          *(_DWORD *)xpc_object_t v56 = 136315138;
          char v57 = v42;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SMS over IMS SMSC preference order: %s", v56, 0xCu);
          uint64_t v1 = v33;
          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v55.__r_.__value_.__l.__data_);
          }
          uint64_t v2 = v46;
          if (__p) {
            operator delete(__p);
          }
          signed int v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
          int v43 = sub_1001B0B78(v48, (int *)&v51, (uint64_t)&unk_10144E20E, &buf);
          sub_10082FF60(v43[5], &buf);
          CFNumberRef v44 = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            CFNumberRef v44 = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v55.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Emergency text numbers %{public}s", (uint8_t *)&v55, 0xCu);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        CFNumberRef v45 = v4 + 1;
        uint64_t v4 = v3;
        if (v45 != v3)
        {
          uint64_t v4 = v45;
          while ((v5(*v4) & 1) == 0)
          {
            if (++v4 == v3)
            {
              uint64_t v4 = v3;
              break;
            }
          }
        }
      }
      while (v4 != v47);
    }
  }
}

void sub_1009DF240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  operator delete(v34);
  _Unwind_Resume(a1);
}

BOOL sub_1009DF288@<W0>(Registry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    signed int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    BOOL v13 = 1;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
LABEL_20:
      sub_10004D2C8(v11);
      goto LABEL_21;
    }
    goto LABEL_11;
  }
  std::mutex::unlock(v5);
  if (!v12)
  {
LABEL_9:
    BOOL v13 = 1;
    goto LABEL_21;
  }
LABEL_11:
  uint64_t v14 = operator new(0x10uLL);
  int v21 = v14 + 2;
  BOOL v22 = v14 + 2;
  *uint64_t v14 = @"SMSSettings";
  v14[1] = @"TransportFallback";
  uint64_t v19 = 0;
  std::string __p = v14;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v12 + 104))(&v18, v12, a2, 1, &__p, 0, 0);
  sub_1000057AC(&v19, &v18);
  sub_1000577C4(&v18);
  if (v19) {
    uint64_t v16 = sub_100084B4C;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v16)
  {
    LOBYTE(v18) = 0;
    ctu::cf::assign((ctu::cf *)&v18, v19, v15);
    BOOL v13 = (_BYTE)v18 != 0;
  }
  else
  {
    BOOL v13 = 1;
  }
  sub_100062778((const void **)&v19);
  if (__p)
  {
    int v21 = __p;
    operator delete(__p);
  }
  if (v11) {
    goto LABEL_20;
  }
LABEL_21:
  sub_100057D78(&v23);
  return v13;
}

void sub_1009DF44C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_100062778(&a10);
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_100057D78(&a14);
  _Unwind_Resume(a1);
}

void sub_1009DF4B0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Controller - intialize()", (uint8_t *)&buf, 2u);
  }
  (*(void (**)(void))(**(void **)(a1 + 2568) + 160))(*(void *)(a1 + 2568));
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1009E0F20;
  aBlock[3] = &unk_101A24DE0;
  aBlock[4] = a1;
  uint64_t v3 = _Block_copy(aBlock);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      BOOL v17 = *(NSObject **)(a1 + 24);
      signed int v7 = v17;
      uint64_t v8 = _Block_copy(v3);
      uint64_t v18 = v8;
      dispatch_retain(v7);
      long long buf = 0u;
      long long v27 = 0u;
      v19[0] = v7;
      unsigned int v9 = _Block_copy(v8);
      v19[1] = v9;
      dispatch_retain(v7);
      v20[0] = v7;
      int v10 = _Block_copy(v9);
      v20[1] = v10;
      dispatch_retain(v7);
      v21[0] = v7;
      uint64_t v11 = _Block_copy(v10);
      v21[1] = v11;
      dispatch_retain(v7);
      __p[0] = 0;
      v22[0] = v7;
      uint64_t v12 = _Block_copy(v11);
      v22[1] = v12;
      dispatch_retain(v7);
      v23[0] = v7;
      BOOL v13 = _Block_copy(v12);
      v23[1] = v13;
      dispatch_retain(v7);
      v24[0] = v7;
      uint64_t v14 = _Block_copy(v13);
      v24[1] = v14;
      dispatch_retain(v7);
      v28[0] = v7;
      CFBooleanRef v15 = _Block_copy(v14);
      v28[1] = v15;
      dispatch_retain(v7);
      __p[1] = v7;
      __p[2] = _Block_copy(v15);
      dispatch_retain(v7);
      sub_1009F93AC((uint64_t)v28);
      sub_1009F93AC((uint64_t)v24);
      sub_1009F93AC((uint64_t)v23);
      __p[0] = off_101A271E8;
      sub_1009F93AC((uint64_t)v22);
      sub_1009F93AC((uint64_t)v21);
      sub_1009800B8((uint64_t *)__p, (uint64_t *)&v27 + 1);
      sub_100980A44((uint64_t *)__p);
      sub_1009F93AC((uint64_t)v20);
      sub_1009F93AC((uint64_t)v19);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1009E0BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E0F20(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  subscriber::makeSimSlotRange();
  uint64_t v5 = v10;
  uint64_t v4 = v11;
  if (v10 != v11)
  {
    uint64_t v6 = v12;
    while ((v12(*v5) & 1) == 0)
    {
      if (++v5 == v11)
      {
        uint64_t v5 = v11;
        break;
      }
    }
    signed int v7 = v11;
    while (v5 != v7)
    {
      int v9 = 0;
      uint64_t v8 = v5 + 1;
      int v9 = *v5;
      BOOL v13 = &v9;
      *((unsigned char *)sub_1001B0B78((uint64_t **)(v3 + 2544), &v9, (uint64_t)&unk_10144E20E, &v13)[5] + 41) = a2;
      sub_1009E1038(v3, v9);
      uint64_t v5 = v4;
      if (v8 != v4)
      {
        uint64_t v5 = v8;
        while ((v6(*v5) & 1) == 0)
        {
          if (++v5 == v4)
          {
            uint64_t v5 = v4;
            break;
          }
        }
      }
    }
  }
}

void sub_1009E1038(uint64_t a1, signed int a2)
{
  unsigned int v43 = a2;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    uint64_t v5 = *(void *)(a1 + 2488);
    if (v5)
    {
      uint64_t v6 = a1 + 2488;
      do
      {
        signed int v7 = *(_DWORD *)(v5 + 28);
        BOOL v8 = v7 < a2;
        if (v7 >= a2) {
          int v9 = (uint64_t *)v5;
        }
        else {
          int v9 = (uint64_t *)(v5 + 8);
        }
        if (!v8) {
          uint64_t v6 = v5;
        }
        uint64_t v5 = *v9;
      }
      while (*v9);
      if (v6 != a1 + 2488 && *(_DWORD *)(v6 + 28) <= a2 && *(unsigned char *)(v6 + 32))
      {
        int v10 = *v4;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "[not-ready]";
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SMS %s - Private network", buf, 0xCu);
        }
        sub_1009EA734(a1, a2, 0);
        return;
      }
    }
    if (sub_1009CA780((uint64_t **)a1, a2))
    {
      BOOL v13 = *v4;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "[ready]";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I SMS %s - over IMS", buf, 0xCu);
      }
      sub_1009EA734(a1, a2, 1);
      return;
    }
    if (sub_1009CA2D8(a1, a2, v12))
    {
      *(void *)long long buf = &v43;
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v43, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
           + 268))
      {
        uint64_t v14 = *v4;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)long long buf = &v43;
          sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v43, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
          uint64_t v15 = sms::asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = "[ready]";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&unsigned char buf[14] = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I SMS %s - over BB, encoder: %s", buf, 0x16u);
        }
        sub_1009EA734(a1, v43, 1);
        return;
      }
      if (sub_100529568())
      {
        unsigned int v17 = v43;
        uint64_t v18 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v43);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v19, *(Registry **)(a1 + 80));
        int v21 = ServiceMap;
        if (v22 < 0)
        {
          uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v24 = 5381;
          do
          {
            uint64_t v22 = v24;
            unsigned int v25 = *v23++;
            uint64_t v24 = (33 * v24) ^ v25;
          }
          while (v25);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v22;
        int v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
        if (v26)
        {
          uint64_t v28 = v26[3];
          long long v27 = (std::__shared_weak_count *)v26[4];
          if (v27)
          {
            atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v21);
            atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v27);
            char v29 = 0;
LABEL_46:
            if (!v28)
            {
              unsigned int v42 = *v18;
              if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to get LASDQuery", buf, 2u);
              }
              sub_1009EABF4(a1);
            }
            BOOL v32 = *(std::__shared_weak_count **)(a1 + 16);
            if (!v32 || (v33 = *(void *)(a1 + 8), (char v34 = std::__shared_weak_count::lock(v32)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v35 = v34;
            atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v34);
            Registry::getTimerService(&v49, *(Registry **)(a1 + 80));
            uint64_t v36 = v49;
            sub_100058DB0(__p, "2G Location hints timer");
            uint64_t v37 = *(NSObject **)(a1 + 24);
            dispatch_object_t object = v37;
            if (v37) {
              dispatch_retain(v37);
            }
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 1174405120;
            *(void *)&uint8_t buf[16] = sub_1009EACE0;
            unsigned int v53 = (const char *)&unk_101A24F80;
            *(void *)&long long v54 = a1;
            *((void *)&v54 + 1) = v33;
            std::string v55 = v35;
            atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            xpc_object_t v56 = v18;
            unsigned int v57 = v17;
            aBlocuint64_t k = _Block_copy(buf);
            sub_100118A44(v36, (uint64_t)__p, 0, 5000000, &object, &aBlock);
            uint64_t v38 = v48;
            uint64_t v48 = 0;
            uint64_t v39 = *(void *)(a1 + 2640);
            *(void *)(a1 + 2640) = v38;
            if (v39)
            {
              (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
              uint64_t v40 = v48;
              uint64_t v48 = 0;
              if (v40) {
                (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
              }
            }
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (object) {
              dispatch_release(object);
            }
            if (v47 < 0) {
              operator delete(__p[0]);
            }
            if (v50) {
              sub_10004D2C8(v50);
            }
            atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            unsigned int v51 = 0;
            size_t v41 = operator new(0x28uLL);
            void *v41 = off_101A28C00;
            v41[1] = v33;
            v41[2] = v35;
            v41[3] = a1;
            *((_DWORD *)v41 + 8) = v17;
            unsigned int v51 = v41;
            (*(void (**)(uint64_t, uint64_t *))(*(void *)v28 + 16))(v28, &v49);
            sub_100060644(&v49);
            if (v55) {
              std::__shared_weak_count::__release_weak(v55);
            }
            std::__shared_weak_count::__release_weak(v35);
            if ((v29 & 1) == 0) {
              sub_10004D2C8(v27);
            }
            return;
          }
        }
        else
        {
          uint64_t v28 = 0;
        }
        std::mutex::unlock(v21);
        long long v27 = 0;
        char v29 = 1;
        goto LABEL_46;
      }
      uint64_t v30 = *v4;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)long long buf = &v43;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v43, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 268))
          int v31 = "true";
        else {
          int v31 = "false";
        }
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "[not-ready]";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = "false";
        *(_WORD *)&unsigned char buf[22] = 2080;
        unsigned int v53 = v31;
        LOWORD(v54) = 2080;
        *(void *)((char *)&v54 + 2) = "true";
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I SMS %s - ims: %s, bb: %s, activation: %s", buf, 0x2Au);
      }
      sub_1009EA734(a1, v43, 0);
    }
    else
    {
      uint64_t v16 = *v4;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "[not-ready]";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I SMS %s - BB not activated", buf, 0xCu);
      }
      sub_1009EA734(a1, a2, 0);
    }
  }
  else
  {
    uint64_t v11 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid slot while calculating SMS ready.", buf, 2u);
    }
  }
}

void sub_1009E17B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009E187C(uint64_t a1)
{
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v3 = v6;
  if (v6 != v7)
  {
    while (1)
    {
      uint64_t result = v8(*v3);
      if (result) {
        break;
      }
      if (++v3 == v7)
      {
        uint64_t v3 = v7;
        break;
      }
    }
    while (v3 != v7)
    {
      uint64_t v4 = *v3;
      v9[0] = off_101A286E0;
      v9[1] = a1;
      v9[3] = v9;
      sub_1009E3B40(a1, v4, (uint64_t)v9);
      uint64_t result = (uint64_t)sub_1008FDE68(v9);
      uint64_t v5 = v3 + 1;
      uint64_t v3 = v7;
      if (v5 != v7)
      {
        uint64_t v3 = v5;
        while (1)
        {
          uint64_t result = v8(*v3);
          if (result) {
            break;
          }
          if (++v3 == v7)
          {
            uint64_t v3 = v7;
            break;
          }
        }
      }
    }
  }
  return result;
}

void sub_1009E19A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1008FDE68((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1009E19C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 336);
  uint64_t v3 = (void *)(a1 + 344);
  if (v2 != (void *)(a1 + 344))
  {
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        BOOL v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            uint64_t v11 = (uint64_t *)v6;
          }
          else {
            uint64_t v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            BOOL v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_27;
          }
          uint64_t v12 = *((unsigned int *)v2 + 8);
          *(_WORD *)unsigned int v17 = *((_WORD *)v2 + 20);
          if (*((char *)v2 + 71) < 0)
          {
            sub_10004FC84(&v18, (void *)v2[6], v2[7]);
          }
          else
          {
            long long v18 = *((_OWORD *)v2 + 3);
            uint64_t v19 = v2[8];
          }
          if (*((char *)v2 + 95) < 0)
          {
            sub_10004FC84(&v20, (void *)v2[9], v2[10]);
          }
          else
          {
            long long v20 = *(_OWORD *)(v2 + 9);
            uint64_t v21 = v2[11];
          }
          sub_100A01160(a1, v12, v17);
          if (SHIBYTE(v21) < 0) {
            operator delete((void *)v20);
          }
          BOOL v13 = (void **)&v18;
          if ((SHIBYTE(v19) & 0x80000000) == 0) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
      }
      *(_WORD *)uint64_t v22 = *((_WORD *)v2 + 20);
      if (*((char *)v2 + 71) < 0)
      {
        sub_10004FC84(&v23, (void *)v2[6], v2[7]);
      }
      else
      {
        long long v23 = *((_OWORD *)v2 + 3);
        uint64_t v24 = v2[8];
      }
      if (*((char *)v2 + 95) < 0)
      {
        sub_10004FC84(&__p, (void *)v2[9], v2[10]);
      }
      else
      {
        long long __p = *(_OWORD *)(v2 + 9);
        uint64_t v26 = v2[11];
      }
      sub_100A01160(a1, v7, v22);
      if (SHIBYTE(v26) < 0) {
        operator delete((void *)__p);
      }
      BOOL v13 = (void **)&v23;
      if ((SHIBYTE(v24) & 0x80000000) == 0) {
        goto LABEL_27;
      }
LABEL_26:
      operator delete(*v13);
LABEL_27:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != v3);
  }
}

void sub_1009E1BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a15 < 0) {
    operator delete(*v34);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E1C50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 360);
  uint64_t v3 = (void *)(a1 + 368);
  if (v2 != (void *)(a1 + 368))
  {
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        BOOL v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            uint64_t v11 = (uint64_t *)v6;
          }
          else {
            uint64_t v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            BOOL v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_27;
          }
          uint64_t v12 = *((unsigned int *)v2 + 8);
          if (*((char *)v2 + 71) < 0)
          {
            sub_10004FC84(&v17, (void *)v2[6], v2[7]);
          }
          else
          {
            long long v17 = *((_OWORD *)v2 + 3);
            uint64_t v18 = v2[8];
          }
          if (*((char *)v2 + 95) < 0)
          {
            sub_10004FC84(&v19, (void *)v2[9], v2[10]);
          }
          else
          {
            long long v19 = *(_OWORD *)(v2 + 9);
            uint64_t v20 = v2[11];
          }
          sub_100A00C00(a1, v12);
          if (SHIBYTE(v20) < 0) {
            operator delete((void *)v19);
          }
          BOOL v13 = (void **)&v17;
          if ((SHIBYTE(v18) & 0x80000000) == 0) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
      }
      __int16 v21 = *((_WORD *)v2 + 20);
      if (*((char *)v2 + 71) < 0)
      {
        sub_10004FC84(&v22, (void *)v2[6], v2[7]);
      }
      else
      {
        long long v22 = *((_OWORD *)v2 + 3);
        uint64_t v23 = v2[8];
      }
      if (*((char *)v2 + 95) < 0)
      {
        sub_10004FC84(&__p, (void *)v2[9], v2[10]);
      }
      else
      {
        long long __p = *(_OWORD *)(v2 + 9);
        uint64_t v25 = v2[11];
      }
      sub_100A00C00(a1, v7);
      if (SHIBYTE(v25) < 0) {
        operator delete((void *)__p);
      }
      BOOL v13 = (void **)&v22;
      if ((SHIBYTE(v23) & 0x80000000) == 0) {
        goto LABEL_27;
      }
LABEL_26:
      operator delete(*v13);
LABEL_27:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != v3);
  }
}

void sub_1009E1E7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a15 < 0) {
    operator delete(*v34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009E1EDC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 96))();
}

void sub_1009E1F00(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 280))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v4 = *(void **)(a1 + 264);
    uint64_t v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      BOOL v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          BOOL v8 = v3;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 264);
  }
  char v47 = (void *)(a1 + 272);
  if (v4 != (void *)(a1 + 272))
  {
    uint64_t v11 = a2 + 1;
    unint64_t v46 = a2 + 1;
    while (1)
    {
      uint64_t v12 = *v11;
      int v13 = *((_DWORD *)v4 + 7);
      if (!*v11) {
        break;
      }
      uint64_t v14 = v11;
      do
      {
        int v15 = *(_DWORD *)(v12 + 28);
        BOOL v16 = v15 < v13;
        if (v15 >= v13) {
          long long v17 = (uint64_t *)v12;
        }
        else {
          long long v17 = (uint64_t *)(v12 + 8);
        }
        if (!v16) {
          uint64_t v14 = (void *)v12;
        }
        uint64_t v12 = *v17;
      }
      while (*v17);
      if (v14 == v11 || v13 < *((_DWORD *)v14 + 7)) {
        break;
      }
      uint64_t v18 = (int *)(v4 + 4);
      if (*((_DWORD *)v14 + 8) != *((_DWORD *)v4 + 8)) {
        goto LABEL_35;
      }
LABEL_61:
      CFNumberRef v44 = (void *)v4[1];
      if (v44)
      {
        do
        {
          CFNumberRef v45 = v44;
          CFNumberRef v44 = (void *)*v44;
        }
        while (v44);
      }
      else
      {
        do
        {
          CFNumberRef v45 = (void *)v4[2];
          BOOL v6 = *v45 == (void)v4;
          uint64_t v4 = v45;
        }
        while (!v6);
      }
      uint64_t v4 = v45;
      if (v45 == v47) {
        return;
      }
    }
    uint64_t v18 = (int *)(v4 + 4);
LABEL_35:
    unsigned int v49 = *((_DWORD *)v4 + 7);
    long long v19 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v20 = *v19;
    if (os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Handling RAT changed: %s", buf, 0xCu);
    }
    int v22 = *v18;
    *(void *)long long buf = &v49;
    *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 66) = v22;
    *(void *)long long buf = &v49;
    BOOL v23 = *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
          + 54) == 0;
    *(void *)long long buf = &v49;
    *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 54) = 0;
    int v24 = asWirelessTechnology();
    *(void *)long long buf = &v49;
    uint64_t v25 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    *((_DWORD *)v25[5] + 54) |= v24;
    *(void *)long long buf = &v49;
    if (*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 54)) {
      BOOL v26 = v23;
    }
    else {
      BOOL v26 = 0;
    }
    sub_1009DAF14((void **)a1, v49);
    sub_1009DC120(a1, v49);
    sub_1009E1038(a1, v49);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(a1 + 80));
    char v29 = ServiceMap;
    if (v30 < 0)
    {
      int v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v30;
    char v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
    if (v34)
    {
      uint64_t v35 = v34[3];
      uint64_t v36 = (std::__shared_weak_count *)v34[4];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v36);
        char v37 = 0;
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v29);
    uint64_t v36 = 0;
    char v37 = 1;
LABEL_48:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v35 + 96))(&cf, v35, v49, 1, @"SuppressVMResetOnTechSwitch", kCFBooleanFalse, 0);
    uint64_t v38 = (BOOL *)cf;
    buf[0] = 0;
    if (cf && (CFTypeID v39 = CFGetTypeID(cf), v39 == CFBooleanGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)buf, v38, v40);
      BOOL v41 = buf[0] == 0;
    }
    else
    {
      BOOL v41 = 1;
    }
    sub_1000577C4(&cf);
    if ((v37 & 1) == 0) {
      sub_10004D2C8(v36);
    }
    if (v41)
    {
      uint64_t v11 = v46;
      if (v26)
      {
        *(void *)long long buf = &v49;
        if (sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][3])
        {
          *(void *)long long buf = &v49;
          unsigned int v42 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v49, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
          (*(void (**)(uint64_t, void))(*(void *)v42[5][3] + 136))(v42[5][3], v49);
        }
      }
    }
    else
    {
      unsigned int v43 = *v19;
      uint64_t v11 = v46;
      if (os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Suppressing the VM reset on activation of a new RAT because of the SuppressVMResetOnTechSwitch carrier bundle key", buf, 2u);
      }
    }
    goto LABEL_61;
  }
}

void sub_1009E247C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009E24C0(void *result)
{
  uint64_t v1 = (void *)result[260];
  uint64_t v2 = result + 261;
  if (v1 != result + 261)
  {
    uint64_t v3 = (uint64_t)result;
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asString();
        *(_DWORD *)long long buf = 136315138;
        uint64_t v12 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband service provisioned state : %s", buf, 0xCu);
      }
      uint64_t v6 = *((unsigned int *)v1 + 7);
      v10[0] = off_101A28770;
      v10[1] = v3;
      void v10[3] = v10;
      sub_1009E3B40(v3, v6, (uint64_t)v10);
      uint64_t result = sub_1008FDE68(v10);
      uint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v9);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
  return result;
}

void sub_1009E263C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1008FDE68((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1009E2658(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (a2[2] == *(void *)(result + 328))
  {
    uint64_t v3 = a2 + 1;
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return result;
    }
    uint64_t v5 = *(void **)(result + 312);
    while (*((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7))
    {
      uint64_t result = operator==();
      if (!result) {
        break;
      }
      uint64_t v6 = (void *)v4[1];
      uint64_t v7 = v4;
      if (v6)
      {
        do
        {
          uint64_t v4 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v7[2];
          BOOL v8 = *v4 == (void)v7;
          uint64_t v7 = v4;
        }
        while (!v8);
      }
      BOOL v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v4 == v3) {
        return result;
      }
    }
  }
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v12 = v28;
  uint64_t v11 = v29;
  if (v28 != v29)
  {
    int v13 = v30;
    while (1)
    {
      uint64_t result = v30(*v12);
      if (result) {
        break;
      }
      if (++v12 == v29)
      {
        uint64_t v12 = v29;
        break;
      }
    }
    uint64_t v14 = v29;
    if (v12 != v29)
    {
      char v15 = (void *)(v2 + 320);
      BOOL v16 = (uint64_t **)(v2 + 2544);
      do
      {
        unsigned int v27 = 0;
        int v17 = *v12;
        unsigned int v27 = *v12;
        uint64_t v18 = (uint64_t *)*v15;
        if (*v15)
        {
          long long v19 = v15;
          uint64_t v20 = *v15;
          do
          {
            int v21 = *(_DWORD *)(v20 + 28);
            BOOL v22 = v21 < v17;
            if (v21 >= v17) {
              BOOL v23 = (uint64_t *)v20;
            }
            else {
              BOOL v23 = (uint64_t *)(v20 + 8);
            }
            if (!v22) {
              long long v19 = (void *)v20;
            }
            uint64_t v20 = *v23;
          }
          while (*v23);
          if (v19 != v15 && v17 >= *((_DWORD *)v19 + 7))
          {
            while (1)
            {
              while (1)
              {
                int v24 = *((_DWORD *)v18 + 7);
                if (v24 <= v17) {
                  break;
                }
                uint64_t v18 = (uint64_t *)*v18;
                if (!v18) {
                  goto LABEL_49;
                }
              }
              if (v24 >= v17) {
                break;
              }
              uint64_t v18 = (uint64_t *)v18[1];
              if (!v18) {
LABEL_49:
              }
                sub_1000C14F0("map::at:  key not found");
            }
            int v25 = ConnectionAvailabilityContainer::error();
            int v31 = (int *)&v27;
            uint64_t result = (uint64_t)sub_1001B0B78(v16, (int *)&v27, (uint64_t)&unk_10144E20E, &v31);
            *(_DWORD *)(*(void *)(result + 40) + 312) = v25;
          }
        }
        BOOL v26 = v12 + 1;
        uint64_t v12 = v11;
        if (v26 != v11)
        {
          uint64_t v12 = v26;
          while (1)
          {
            uint64_t result = v13(*v12);
            if (result) {
              break;
            }
            if (++v12 == v11)
            {
              uint64_t v12 = v11;
              break;
            }
          }
        }
      }
      while (v12 != v14);
    }
  }
  return result;
}

void sub_1009E2898(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 2288) == a2[2])
  {
    uint64_t v3 = *(void **)(a1 + 2272);
    uint64_t v4 = (void *)(a1 + 2280);
    if (v3 == (void *)(a1 + 2280)) {
      return;
    }
    uint64_t v5 = (void *)*a2;
    while ((sub_10008D2E0((uint64_t)__p, (uint64_t)(v3 + 4), (uint64_t)(v5 + 4)) & 1) != 0)
    {
      uint64_t v6 = (void *)v3[1];
      uint64_t v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v7[2];
          BOOL v8 = *v3 == (void)v7;
          uint64_t v7 = v3;
        }
        while (!v8);
      }
      BOOL v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v3 == v4) {
        return;
      }
    }
  }
  uint64_t v11 = *(void **)(a1 + 2272);
  if (v11 != (void *)(a1 + 2280))
  {
    do
    {
      memset(__p, 0, 32);
      LODWORD(__p[0]) = *((_DWORD *)v11 + 8);
      if (*((char *)v11 + 63) < 0)
      {
        sub_10004FC84(&__p[1], (void *)v11[5], v11[6]);
      }
      else
      {
        *(_OWORD *)&__p[1] = *(_OWORD *)(v11 + 5);
        __p[3] = *((void **)v11 + 7);
      }
      if ((subscriber::isValidSimSlot() & 1) == 0) {
        goto LABEL_48;
      }
      *(void *)long long buf = __p;
      uint64_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)__p, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
      if (*((char *)v12 + 343) < 0)
      {
        if (v12[41]) {
          goto LABEL_27;
        }
      }
      else if (*((unsigned char *)v12 + 343))
      {
        goto LABEL_27;
      }
      *(void *)long long buf = __p;
      int v13 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)__p, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      std::string::operator=((std::string *)(v13[5] + 40), (const std::string *)&__p[1]);
LABEL_27:
      uint64_t v14 = (void *)HIBYTE(__p[3]);
      if (SHIBYTE(__p[3]) < 0) {
        uint64_t v14 = __p[2];
      }
      if (!v14) {
        goto LABEL_48;
      }
      *(void *)long long buf = __p;
      char v15 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)__p, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
      uint64_t v16 = *((unsigned __int8 *)v15 + 343);
      size_t v17 = v15[41];
      if ((v16 & 0x80u) == 0) {
        uint64_t v18 = *((unsigned __int8 *)v15 + 343);
      }
      else {
        uint64_t v18 = v15[41];
      }
      long long v19 = (void *)HIBYTE(__p[3]);
      if (SHIBYTE(__p[3]) < 0) {
        long long v19 = __p[2];
      }
      if ((void *)v18 != v19) {
        goto LABEL_45;
      }
      uint64_t v20 = (const void **)(v15 + 40);
      if (SHIBYTE(__p[3]) >= 0) {
        int v21 = &__p[1];
      }
      else {
        int v21 = (void **)__p[1];
      }
      if ((v16 & 0x80) != 0)
      {
        if (memcmp(*v20, v21, v17)) {
          goto LABEL_45;
        }
      }
      else if (v16)
      {
        while (*(unsigned __int8 *)v20 == *(unsigned __int8 *)v21)
        {
          uint64_t v20 = (const void **)((char *)v20 + 1);
          int v21 = (void **)((char *)v21 + 1);
          if (!--v16) {
            goto LABEL_48;
          }
        }
LABEL_45:
        *(void *)long long buf = __p;
        BOOL v22 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)__p, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
        std::string::operator=((std::string *)(v22[5] + 40), (const std::string *)&__p[1]);
        sub_1009CC01C(a1, LODWORD(__p[0]));
        sub_1009CA87C(a1, __p[0]);
        BOOL v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Purging MO messages due to subscriber change", buf, 2u);
        }
        sub_1009CFF20(a1, 1);
      }
LABEL_48:
      if (SHIBYTE(__p[3]) < 0) {
        operator delete(__p[1]);
      }
      int v24 = (void *)v11[1];
      if (v24)
      {
        do
        {
          int v25 = v24;
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          int v25 = (void *)v11[2];
          BOOL v8 = *v25 == (void)v11;
          uint64_t v11 = v25;
        }
        while (!v8);
      }
      uint64_t v11 = v25;
    }
    while (v25 != (void *)(a1 + 2280));
  }
}

void sub_1009E2BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E2C04(uint64_t a1, uint64_t *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_1009E3E1C;
  void v6[3] = &unk_101A24E00;
  uint64_t v4 = *a2;
  v6[4] = a1;
  v6[5] = v4;
  sub_10009DB3C((uint64_t)&v7, (uint64_t)(a2 + 1));
  long long __p = 0;
  size_t v17 = 0;
  uint64_t v18 = 0;
  sub_10005C928(&__p, (const void *)a2[18], a2[19], a2[19] - a2[18]);
  __int16 v19 = *((_WORD *)a2 + 84);
  uint64_t v22 = 0;
  BOOL v23 = 0;
  sub_10003E168(&v22, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v22;
  int v21 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (__p)
  {
    size_t v17 = __p;
    operator delete(__p);
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if (v13 < 0) {
    operator delete(v12);
  }
  if (v11 < 0) {
    operator delete(v10);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
}

void sub_1009E2D98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E2DE4(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_1009E2ECC(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/display_status");
  v4[0] = off_101A27EC0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1009E2F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009E2FAC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 456);
  char v3 = (void *)(a1 + 464);
  if (v2 != (void *)(a1 + 464))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      signed int v7 = *((_DWORD *)v2 + 8);
      BOOL v8 = v5;
      do
      {
        signed int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          char v11 = (uint64_t *)v6;
        }
        else {
          char v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((rest::operator==() & 1) == 0)
      {
        signed int v7 = *((_DWORD *)v2 + 8);
        uint64_t v12 = a1;
        goto LABEL_17;
      }
LABEL_18:
      char v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          char v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          uint64_t v2 = v14;
        }
        while (!v15);
      }
      uint64_t v2 = v14;
      if (v14 == v3) {
        return;
      }
    }
    signed int v7 = *((_DWORD *)v2 + 8);
LABEL_16:
    uint64_t v12 = a1;
LABEL_17:
    sub_100A00838(v12, v7);
    goto LABEL_18;
  }
}

void sub_1009E309C(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3 && *(unsigned char *)(v3 + 149))
    {
      uint64_t v4 = *(unsigned int *)(v3 + 8);
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v23[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Emergency ready", (uint8_t *)v23, 2u);
      }
      if (!sub_100529568()) {
        goto LABEL_20;
      }
      uint64_t v6 = *(void *)(a1 + 2312);
      if (v6)
      {
        uint64_t v7 = a1 + 2312;
        do
        {
          int v8 = *(_DWORD *)(v6 + 28);
          BOOL v9 = v8 < (int)v4;
          if (v8 >= (int)v4) {
            BOOL v10 = (uint64_t *)v6;
          }
          else {
            BOOL v10 = (uint64_t *)(v6 + 8);
          }
          if (!v9) {
            uint64_t v7 = v6;
          }
          uint64_t v6 = *v10;
        }
        while (*v10);
        if (v7 != a1 + 2312 && *(_DWORD *)(v7 + 28) <= (int)v4 && *(unsigned char *)(v7 + 32))
        {
          char v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Emergency Text: In home country", buf, 2u);
          }
LABEL_20:
          sub_1009DDDBC(a1, v4);
          sub_1009D0860(a1);
          return;
        }
      }
      char v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Starting home country determination timer", buf, 2u);
      }
      uint64_t v14 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v14 || (v15 = *(void *)(a1 + 8), (uint64_t v16 = std::__shared_weak_count::lock(v14)) == 0)) {
        sub_100088B9C();
      }
      size_t v17 = v16;
      atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 80));
      uint64_t v18 = *(void *)buf;
      sub_100058DB0(__p, "Home country determination");
      __int16 v19 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v19;
      if (v19) {
        dispatch_retain(v19);
      }
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 1174405120;
      void v23[2] = sub_1009E4008;
      v23[3] = &unk_101A24E30;
      v23[4] = a1;
      v23[5] = v15;
      int v24 = v17;
      atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      int v25 = v4;
      aBlocuint64_t k = _Block_copy(v23);
      sub_100118A44(v18, (uint64_t)__p, 0, 10000000, &object, &aBlock);
      uint64_t v20 = v32;
      uint64_t v32 = 0;
      uint64_t v21 = *(void *)(a1 + 2648);
      *(void *)(a1 + 2648) = v20;
      if (v21)
      {
        (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
        uint64_t v22 = v32;
        uint64_t v32 = 0;
        if (v22) {
          (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v29 < 0) {
        operator delete(__p[0]);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
      if (v24) {
        std::__shared_weak_count::__release_weak(v24);
      }
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  else
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v23[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Emergency ready not successful", (uint8_t *)v23, 2u);
    }
  }
}

void sub_1009E346C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v26 - 72);
  if (v28) {
    sub_10004D2C8(v28);
  }
  std::__shared_weak_count::__release_weak(v25);
  _Unwind_Resume(a1);
}

void sub_1009E34D8(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/baseband_activated");
  v4[0] = off_101A280C0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1009E358C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t **sub_1009E35B8(uint64_t **result, uint64_t a2)
{
  uint64_t v2 = result[318];
  char v3 = result + 319;
  if (v2 != (uint64_t *)(result + 319))
  {
    uint64_t v5 = result + 318;
    uint64_t v6 = (void *)(a2 + 8);
    do
    {
      int v7 = *((_DWORD *)v2 + 8);
      int v17 = v7;
      uint64_t v8 = *v6;
      if (*v6)
      {
        BOOL v9 = v6;
        do
        {
          int v10 = *(_DWORD *)(v8 + 28);
          BOOL v11 = v10 < v7;
          if (v10 >= v7) {
            uint64_t v12 = (uint64_t *)v8;
          }
          else {
            uint64_t v12 = (uint64_t *)(v8 + 8);
          }
          if (!v11) {
            BOOL v9 = (void *)v8;
          }
          uint64_t v8 = *v12;
        }
        while (*v12);
        if (v9 != v6 && v7 >= *((_DWORD *)v9 + 7))
        {
          int v13 = *(_DWORD *)sub_10012EF5C(a2, &v17);
          uint64_t v18 = &v17;
          uint64_t result = sub_1001B0B78(v5, &v17, (uint64_t)&unk_10144E20E, &v18);
          *((_DWORD *)result[5] + 146) = v13;
        }
      }
      uint64_t v14 = (uint64_t *)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (uint64_t *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != (uint64_t *)v3);
  }
  return result;
}

uint64_t **sub_1009E36CC(uint64_t **result, uint64_t a2)
{
  uint64_t v2 = result[318];
  char v3 = result + 319;
  if (v2 != (uint64_t *)(result + 319))
  {
    uint64_t v5 = result + 318;
    uint64_t v6 = (void *)(a2 + 8);
    do
    {
      int v7 = *((_DWORD *)v2 + 8);
      int v17 = v7;
      uint64_t v8 = *v6;
      if (*v6)
      {
        BOOL v9 = v6;
        do
        {
          int v10 = *(_DWORD *)(v8 + 28);
          BOOL v11 = v10 < v7;
          if (v10 >= v7) {
            uint64_t v12 = (uint64_t *)v8;
          }
          else {
            uint64_t v12 = (uint64_t *)(v8 + 8);
          }
          if (!v11) {
            BOOL v9 = (void *)v8;
          }
          uint64_t v8 = *v12;
        }
        while (*v12);
        if (v9 != v6 && v7 >= *((_DWORD *)v9 + 7))
        {
          char v13 = *(unsigned char *)sub_10012EF5C(a2, &v17);
          uint64_t v18 = &v17;
          uint64_t result = sub_1001B0B78(v5, &v17, (uint64_t)&unk_10144E20E, &v18);
          *((unsigned char *)result[5] + 588) = v13;
        }
      }
      uint64_t v14 = (uint64_t *)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (uint64_t *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
    }
    while (v15 != (uint64_t *)v3);
  }
  return result;
}

void sub_1009E37E0(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/private_network_sims_active");
  v4[0] = off_101A28240;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1009E3894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009E38C0(void *a1, uint64_t a2)
{
  v4[0] = off_101A28440;
  v4[1] = a2;
  v4[3] = v4;
  sub_1009FF1B0(v4, a1);
  sub_1009ED6E0(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

void sub_1009E3980(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/prevent_detach_expiry_time");
  v4[0] = off_101A284D0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1009E3A34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009E3A60(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/reg_net_info1");
  v4[0] = off_101A28660;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1009E3B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1009E3B40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 80));
  BOOL v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    BOOL v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v21);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_8;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_8:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_9:
  if ((subscriber::isValidSimSlot() & 1) == 0 && (uint64_t v18 = *v6, os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR)))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid slot while handling Customer Ready", (uint8_t *)&v21, 2u);
    if (v16)
    {
LABEL_12:
      LODWORD(v22) = a2;
      *((void *)&v22 + 1) = a1;
      sub_10090994C((uint64_t)v23, a3);
      int v25 = 0;
      __int16 v19 = (char *)operator new(0x38uLL);
      *(void *)__int16 v19 = off_101A28C80;
      *(_OWORD *)(v19 + 8) = v22;
      sub_1009099E4((uint64_t)(v19 + 24), (uint64_t)v23);
      int v25 = v19;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 112))(v16, a2, v24);
      sub_100060644(v24);
      sub_1008FDE68(v23);
      if (v17) {
        return;
      }
      goto LABEL_17;
    }
  }
  else if (v16)
  {
    goto LABEL_12;
  }
  uint64_t v20 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get activation interface while handling Customer Ready", (uint8_t *)&v21, 2u);
    if (v17) {
      return;
    }
  }
  else if (v17)
  {
    return;
  }
LABEL_17:
  sub_10004D2C8(v15);
}

void sub_1009E3DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100060644((uint64_t *)va);
  sub_1008FDE68(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  _Unwind_Resume(a1);
}

void sub_1009E3E1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v4 = 0;
  sub_10012CD04(__p, *(char **)(a1 + 184), *(char **)(a1 + 192), *(void *)(a1 + 192) - *(void *)(a1 + 184));
  (*(void (**)(uint64_t, void, void, uint64_t, void **, uint64_t, uint64_t))(*(void *)v2 + 472))(v2, *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), a1 + 48, __p, a1 + 208, a1 + 209);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1009E3EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009E3EDC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  sub_10009DB3C(a1 + 48, a2 + 48);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  uint64_t result = sub_10005C928((void *)(a1 + 184), *(const void **)(a2 + 184), *(void *)(a2 + 192), *(void *)(a2 + 192) - *(void *)(a2 + 184));
  *(_WORD *)(a1 + 208) = *(_WORD *)(a2 + 208);
  return result;
}

void sub_1009E3F34(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 159) < 0) {
    operator delete(*(void **)(v1 + 136));
  }
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*(void **)(v1 + 112));
  }
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*(void **)(v1 + 80));
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*(void **)(v1 + 56));
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E3F80(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 184);
  if (v2)
  {
    *(void *)(a1 + 192) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0)
  {
    char v3 = *(void **)(a1 + 56);
    operator delete(v3);
  }
}

void sub_1009E4008(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(a1 + 56));
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v8) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Home country determination timeout", (uint8_t *)&v8, 2u);
        }
        long long v8 = 0uLL;
        sub_1009D0128(v3, *(_DWORD *)(a1 + 56), 1, &v8);
        uint64_t v7 = *(void *)(v3 + 2648);
        *(void *)(v3 + 2648) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009E4114(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009E412C(uint64_t a1, unsigned int a2)
{
  unsigned int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (!*(void *)(a1 + 32))
  {
    BOOL v5 = 1;
LABEL_9:
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    void v9[2] = sub_100A0131C;
    v9[3] = &unk_101A28940;
    void v9[4] = a1 + 8;
    void v9[5] = v7;
    char v10 = v9;
    uint64_t v6 = *(NSObject **)(a1 + 24);
    char v17 = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    if (v5)
    {
      unsigned int v13 = sub_10005A304;
      uint64_t v14 = &unk_101A253A8;
      uint64_t v15 = &v17;
      uint64_t v16 = &v10;
      dispatch_sync(v6, buf);
    }
    else
    {
      unsigned int v13 = sub_10005B068;
      uint64_t v14 = &unk_101A253C8;
      uint64_t v15 = &v17;
      uint64_t v16 = &v10;
      dispatch_async_and_wait(v6, buf);
    }
    return v17 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v5 = *(void *)(a1 + 32) == 0;
    goto LABEL_9;
  }
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received a call to check if Service Center Address is Available", buf, 2u);
    }
    return sub_1009E4324(a1, v8);
  }
  return result;
}

BOOL sub_1009E4324(uint64_t a1, unsigned int a2)
{
  unsigned int v7 = a2;
  if (!subscriber::isValidSimSlot()) {
    return 0;
  }
  *(void *)long long buf = &v7;
  uint64_t v3 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v7, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)(v3[5] + 10));
  if (v10 < 0)
  {
    BOOL v4 = v9 != 0;
    operator delete(*(void **)buf);
  }
  else
  {
    BOOL v4 = v10 != 0;
  }
  BOOL v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Service Center Address availability %d", buf, 8u);
  }
  return v4;
}

void sub_1009E4464(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1009E4578;
  v4[3] = &unk_101A24E60;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v8;
  unsigned int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1009E4578(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v3 = *(unsigned int *)(a1 + 40);
    int v11 = v3;
    if (subscriber::isValidSimSlot())
    {
      uint64_t v4 = *(void *)(v2 + 112);
      if (v4 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 80))(v4, v3) & 1) == 0)
      {
        uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v8) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Service Center address fetch failed", (uint8_t *)&v8, 2u);
        }
        sub_100CC9534((uint64_t)&v8, 71);
        unsigned int v7 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
        sub_100A01420(v7, (uint64_t)&v8);
        if (__p)
        {
          char v10 = __p;
          operator delete(__p);
        }
        uint64_t v8 = 1;
        long long __p = (void *)(v2 + 2216);
        uint64_t v12 = &v11;
        *((unsigned char *)sub_10005CE78((uint64_t **)(v2 + 2248), &v11, (uint64_t)&unk_10144E20E, &v12) + 32) = 1;
        sub_100A02388((uint64_t)&v8);
      }
      else
      {
        int v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v8) = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Service Center Address fetch action completed", (uint8_t *)&v8, 2u);
        }
      }
    }
  }
}

void sub_1009E474C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

uint64_t sub_1009E4778(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  unsigned int v42 = a2;
  unsigned int v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t result = subscriber::isValidSimSlot();
  if (!result) {
    return result;
  }
  if (a3)
  {
    *(void *)&__p.var0 = &v42;
    uint64_t v9 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v42, (uint64_t)&unk_10144E20E, &__p)[5];
    v9[10] = *(void *)a4;
    std::string::operator=((std::string *)(v9 + 11), (const std::string *)(a4 + 8));
    std::string::operator=((std::string *)(v9 + 14), (const std::string *)(a4 + 32));
    int v10 = *(_DWORD *)(a4 + 56);
    *((unsigned char *)v9 + 140) = *(unsigned char *)(a4 + 60);
    *((_DWORD *)v9 + 34) = v10;
    std::string::operator=((std::string *)v9 + 6, (const std::string *)(a4 + 64));
    std::string::operator=((std::string *)v9 + 7, (const std::string *)(a4 + 88));
    long long v11 = *(_OWORD *)(a4 + 112);
    *((unsigned char *)v9 + 208) = *(unsigned char *)(a4 + 128);
    *((_OWORD *)v9 + 12) = v11;
    uint64_t v12 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v43 = &v42;
      unsigned int v13 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v42, (uint64_t)&unk_10144E20E, &v43);
      p_p = &__p;
      CSIPhoneNumber::getFullNumber((uint64_t *)&__p.var0, (CSIPhoneNumber *)(v13[5] + 10));
      if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        p_p = *(CSIPhoneNumber **)&__p.var0;
      }
      unsigned int v43 = &v42;
      uint64_t v15 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v42, (uint64_t)&unk_10144E20E, &v43);
      int TypeOfAddress = CSIPhoneNumber::getTypeOfAddress((CSIPhoneNumber *)(v15[5] + 10));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = p_p;
      __int16 v45 = 1024;
      int v46 = TypeOfAddress;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received Service Center Address %s with type %d", buf, 0x12u);
      if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&__p.var0);
      }
    }
    if (v42 == 2)
    {
      sub_100CC9534((uint64_t)&__p, 70);
      uint64_t v26 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
      sub_100A01420(v26, (uint64_t)&__p);
    }
    else
    {
      if (v42 != 1)
      {
LABEL_33:
        uint64_t v27 = *(void *)(a1 + 2528);
        uint64_t v28 = v42;
        *(void *)&__p.var0 = &v42;
        char v29 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v42, (uint64_t)&unk_10144E20E, &__p);
        CSIPhoneNumber::getFullNumber((uint64_t *)v40, (CSIPhoneNumber *)(v29[5] + 10));
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v27 + 144))(v27, v28, v40);
        if (v41 < 0) {
          operator delete(v40[0]);
        }
        *(void *)&__p.var0 = 1;
        __p.var2.__r_.__value_.var0.var1.__data_ = (char *)(a1 + 2104);
        *(void *)long long buf = &v42;
        *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2136), (int *)&v42, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 1;
        return sub_100A023EC((uint64_t)&__p);
      }
      sub_100CC9534((uint64_t)&__p, 69);
      char v17 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
      sub_100A01420(v17, (uint64_t)&__p);
    }
    if (__p.var2.__r_.__value_.var0.var1.__data_)
    {
      __p.var2.__r_.__value_.var0.var1.__size_ = (unint64_t)__p.var2.__r_.__value_.var0.var1.__data_;
      operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
    }
    goto LABEL_33;
  }
  uint64_t v18 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I SMSC Fetch error", (uint8_t *)&__p, 2u);
  }
  CSIPhoneNumber::CSIPhoneNumber(&__p);
  *(void *)long long buf = &v42;
  __int16 v19 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v42, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
  v19[10] = *(void *)&__p.var0;
  uint64_t v20 = (void **)(v19 + 11);
  if (*((char *)v19 + 111) < 0) {
    operator delete(*v20);
  }
  *(_OWORD *)uint64_t v20 = *(_OWORD *)__p.var2.__r_.__value_.var0.var0.__data_;
  v19[13] = *((void *)&__p.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&__p.var2.__r_.__value_.var0.var1 + 23) = 0;
  __p.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  unint64_t v21 = (void **)(v19 + 14);
  if (*((char *)v19 + 135) < 0) {
    operator delete(*v21);
  }
  *(_OWORD *)unint64_t v21 = *(_OWORD *)&__p.var2.__r_.var0;
  uint8_t v19[16] = v31;
  HIBYTE(v31) = 0;
  LOBYTE(__p.var2.__r_.var0) = 0;
  *((_DWORD *)v19 + 34) = v32;
  *((unsigned char *)v19 + 140) = v33;
  long long v22 = (void **)(v19 + 18);
  if (*((char *)v19 + 167) < 0) {
    operator delete(*v22);
  }
  *(_OWORD *)long long v22 = v34;
  v19[20] = v35;
  HIBYTE(v35) = 0;
  LOBYTE(v34) = 0;
  BOOL v23 = v19 + 21;
  if (*((char *)v19 + 191) < 0)
  {
    operator delete((void *)v19[21]);
    int v24 = SHIBYTE(v35);
    *BOOL v23 = v36;
    v19[23] = v37;
    HIBYTE(v37) = 0;
    LOBYTE(v36) = 0;
    *((_OWORD *)v19 + 12) = v38;
    *((unsigned char *)v19 + 208) = v39;
    if (v24 < 0) {
      operator delete((void *)v34);
    }
  }
  else
  {
    *BOOL v23 = v36;
    v19[23] = v37;
    HIBYTE(v37) = 0;
    LOBYTE(v36) = 0;
    *((_OWORD *)v19 + 12) = v38;
    *((unsigned char *)v19 + 208) = v39;
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(*(void **)&__p.var2.__r_.var0);
  }
  if (*((char *)&__p.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
  }
  sub_100CC9534((uint64_t)&__p, 71);
  int v25 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
  sub_100A01420(v25, (uint64_t)&__p);
  if (__p.var2.__r_.__value_.var0.var1.__data_)
  {
    __p.var2.__r_.__value_.var0.var1.__size_ = (unint64_t)__p.var2.__r_.__value_.var0.var1.__data_;
    operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
  }
  *(void *)&__p.var0 = 1;
  __p.var2.__r_.__value_.var0.var1.__data_ = (char *)(a1 + 2216);
  *(void *)long long buf = &v42;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2248), (int *)&v42, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 1;
  return sub_100A02388((uint64_t)&__p);
}

void sub_1009E4CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009E4D58(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v9 = a3;
  v8[0] = a1;
  v8[1] = &v9;
  void v8[2] = a2;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      uint64_t result = subscriber::isValidSimSlot();
      if (result) {
        return sub_1009E4EF4(a1, a2, v9);
      }
      return result;
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_100A02450;
  void v10[3] = &unk_101A28960;
  void v10[4] = a1 + 8;
  v10[5] = v8;
  long long v11 = v10;
  unsigned int v7 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    unsigned int v13 = sub_10005A304;
    uint64_t v14 = &unk_101A253A8;
    uint64_t v15 = &v17;
    uint64_t v16 = &v11;
    dispatch_sync(v7, block);
  }
  else
  {
    unsigned int v13 = sub_10005B068;
    uint64_t v14 = &unk_101A253C8;
    uint64_t v15 = &v17;
    uint64_t v16 = &v11;
    dispatch_async_and_wait(v7, block);
  }
  return v17 != 0;
}

uint64_t sub_1009E4EF4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v14 = a3;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v15 = &v14;
    BOOL v6 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v14, (uint64_t)&unk_10144E20E, &v15);
    CSIPhoneNumber::getFullNumber((uint64_t *)v12, (CSIPhoneNumber *)(v6[5] + 10));
    if (v13 < 0)
    {
      int v10 = v12[1];
      operator delete(v12[0]);
      if (v10) {
        goto LABEL_4;
      }
    }
    else if (v13)
    {
LABEL_4:
      v12[0] = &v14;
      unsigned int v7 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v14, (uint64_t)&unk_10144E20E, v12)[5];
      *(void *)a2 = v7[10];
      std::string::operator=((std::string *)(a2 + 8), (const std::string *)(v7 + 11));
      std::string::operator=((std::string *)(a2 + 32), (const std::string *)(v7 + 14));
      char v8 = *((unsigned char *)v7 + 140);
      *(_DWORD *)(a2 + 56) = *((_DWORD *)v7 + 34);
      *(unsigned char *)(a2 + 60) = v8;
      std::string::operator=((std::string *)(a2 + 64), (const std::string *)v7 + 6);
      std::string::operator=((std::string *)(a2 + 88), (const std::string *)v7 + 7);
      char v9 = *((unsigned char *)v7 + 208);
      *(_OWORD *)(a2 + 112) = *((_OWORD *)v7 + 12);
      *(unsigned char *)(a2 + 128) = v9;
      return 1;
    }
    long long v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(v12[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "SMSC Address is not available", (uint8_t *)v12, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1009E5084(uint64_t a1, unsigned int a2)
{
  unsigned int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      if (subscriber::isValidSimSlot()) {
        return sub_1009E5214(a1, v7);
      }
      else {
        return 300;
      }
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100A024AC;
  void v8[3] = &unk_101A28980;
  void v8[4] = a1 + 8;
  v8[5] = v6;
  char v9 = v8;
  int v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    long long v11 = sub_100A0250C;
    uint64_t v12 = &unk_101A289A0;
    char v13 = &v15;
    unsigned int v14 = &v9;
    uint64_t v15 = 0;
    dispatch_sync(v5, block);
  }
  else
  {
    long long v11 = sub_100A02548;
    uint64_t v12 = &unk_101A289C0;
    char v13 = &v15;
    unsigned int v14 = &v9;
    uint64_t v15 = 0;
    dispatch_async_and_wait(v5, block);
  }
  return v15;
}

uint64_t sub_1009E5214(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  BOOL v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 80));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    char v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    char v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_19;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  char v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14) {
    goto LABEL_19;
  }
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v14 + 96))(&v26, v14, a2, 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
  sub_10004EFE4(&v27, &v26);
  CFDictionaryRef v16 = theDict;
  CFDictionaryRef theDict = v27;
  *(void *)long long buf = v16;
  CFDictionaryRef v27 = 0;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)&v27);
  sub_1000577C4(&v26);
  if (theDict) {
    char v17 = sub_100080778;
  }
  else {
    char v17 = 0;
  }
  if (v17)
  {
    CFDictionaryRef Value = (unsigned int *)CFDictionaryGetValue(theDict, @"EmergencyModeTimerForTextToEmergency");
    __int16 v19 = Value;
    unsigned int v20 = 300;
    *(_DWORD *)long long buf = 300;
    if (!Value) {
      goto LABEL_20;
    }
    CFTypeID v21 = CFGetTypeID(Value);
    if (v21 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v19, v22);
      unsigned int v20 = *(_DWORD *)buf;
      goto LABEL_20;
    }
  }
  else
  {
    BOOL v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to get Carrier interface for Text To Emergency Timer reading", buf, 2u);
    }
  }
LABEL_19:
  unsigned int v20 = 300;
LABEL_20:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  int v24 = *v4;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Emergency Text timer value %d", buf, 8u);
  }
  sub_100057D78((const void **)&theDict);
  return v20;
}

void sub_1009E5504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1009E5558(uint64_t a1, uint64_t a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1009E566C;
  v5[3] = &unk_101A24E80;
  uint64_t v5[4] = a1;
  void v5[5] = a2;
  int v6 = a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  BOOL v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v9;
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_1009E566C(uint64_t a1)
{
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)char v17 = 0u;
  *(_OWORD *)uint64_t v18 = 0u;
  *(_OWORD *)char v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)char v13 = 0u;
  long long v14 = 0u;
  uint64_t v2 = *(void *)(a1 + 32);
  sub_10009DB3C((uint64_t)v13, *(void *)(a1 + 40));
  if (subscriber::isValidSimSlot())
  {
    uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 48));
    uint64_t v4 = *(void *)(v2 + 112);
    if (v4
      && ((*(uint64_t (**)(uint64_t, void, void **))(*(void *)v4 + 88))(v4, *(unsigned int *)(a1 + 48), v13) & 1) == 0)
    {
      uint64_t v8 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Call to set SMSC has failed", (uint8_t *)&v10, 2u);
      }
      sub_100CC9534((uint64_t)&v10, 73);
      uint64_t v9 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
      sub_100A01420(v9, (uint64_t)&v10);
      unsigned int v7 = __p;
      if (__p)
      {
        uint64_t v12 = __p;
        goto LABEL_14;
      }
    }
    else
    {
      char v5 = *v3;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)&v10, *(CSIPhoneNumber **)(a1 + 40));
        int v6 = SHIBYTE(v12) >= 0 ? (uint64_t *)&v10 : v10;
        *(_DWORD *)long long buf = 136315138;
        BOOL v23 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sent Set SMSC Address request to baseband with number %s", buf, 0xCu);
        if (SHIBYTE(v12) < 0)
        {
          unsigned int v7 = v10;
LABEL_14:
          operator delete(v7);
        }
      }
    }
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  if (SHIBYTE(v18[0]) < 0) {
    operator delete(v17[0]);
  }
  if (SBYTE7(v16) < 0) {
    operator delete(v15[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[1]);
  }
}

void sub_1009E5888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100087E24((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1009E58C8(uint64_t a1, int a2, uint64_t a3)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a3);
  if (subscriber::isValidSimSlot())
  {
    if (a2) {
      sub_100CC9534((uint64_t)&v5, 72);
    }
    else {
      sub_100CC9534((uint64_t)&v5, 73);
    }
    uint64_t v4 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
    sub_100A01420(v4, (uint64_t)&v5);
    if (__p)
    {
      unsigned int v7 = __p;
      operator delete(__p);
    }
  }
}

void sub_1009E5990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E59B0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (Registry **)(a1 + 80);
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v10 = *v9;
  BOOL v11 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
  if (v11)
  {
    uint64_t v12 = "false";
    if (a3) {
      uint64_t v12 = "true";
    }
    *(_DWORD *)char v33 = 136315394;
    *(void *)&v33[4] = v12;
    __int16 v34 = 1024;
    int v35 = a4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received voicemail Info isWaiting: %s num: %d", v33, 0x12u);
  }
  char v13 = *(_DWORD **)(a1 + 384);
  long long v14 = *(_DWORD **)(a1 + 392);
  if (v13 == v14)
  {
    char v29 = *v9;
    if (!os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)char v33 = 0;
    uint64_t v30 = "sims is empty. Dropping voicemail Indication...";
LABEL_28:
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v30, v33, 2u);
    return;
  }
  char v15 = 0;
  do
  {
    BOOL v17 = *v13 == a2 && v13[2] == 5;
    v15 |= v17;
    v13 += 42;
  }
  while (v13 != v14);
  if (!v15)
  {
    char v29 = *v9;
    if (!os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)char v33 = 0;
    uint64_t v30 = "sim slot not in ready state. Dropping voicemail Indication...";
    goto LABEL_28;
  }
  if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v11))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *v8);
    long long v20 = ServiceMap;
    if (v21 < 0)
    {
      CFNumberRef v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(ServiceMap);
    *(void *)char v33 = v21;
    int v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)v33);
    if (v25)
    {
      uint64_t v27 = v25[3];
      uint64_t v26 = (std::__shared_weak_count *)v25[4];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        char v28 = 0;
        if (!v27)
        {
LABEL_37:
          if ((v28 & 1) == 0) {
            sub_10004D2C8(v26);
          }
          return;
        }
LABEL_33:
        if (a4 <= 0) {
          uint64_t v32 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v32 = a4;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL, uint64_t, void))(*(void *)v27 + 16))(v27, a2, a3, a4 > 0, v32, 0);
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    std::mutex::unlock(v20);
    uint64_t v26 = 0;
    char v28 = 1;
    if (!v27) {
      goto LABEL_37;
    }
    goto LABEL_33;
  }
  uint64_t v31 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v33 = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I handleVoicemailNotification_sync: Device does not support Voicecalls, ignoring Voicemail Indication", v33, 2u);
  }
}

void sub_1009E5CB0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E5CE0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 80));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v14);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    BOOL v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  BOOL v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 24))(v12, a2);
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1009E5DF0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009E5E0C(uint64_t a1, uint64_t a2, char a3, int a4, char a5)
{
  unsigned int v21 = a2;
  if (subscriber::isValidSimSlot())
  {
    uint64_t v10 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    *(void *)long long buf = &v21;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 42)
      && (a3 & 1) == 0
      && ((*(void *)long long buf = &v21,
           BOOL v11 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf),
           !a4)
       && v11[5][3] == *(void *)(a1 + 128)
       || (*(void *)long long buf = &v21,
           uint64_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf),
           a4 == 1)
       && v12[5][3] == *(void *)(a1 + 112)))
    {
      char v13 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        if (a4 == 1) {
          unint64_t v14 = "Agent";
        }
        else {
          unint64_t v14 = "Baseband";
        }
        *(void *)long long buf = &v21;
        if (sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5][3] == *(void *)(a1 + 128)) {
          char v15 = "Agent";
        }
        else {
          char v15 = "Baseband";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v23 = 2080;
        unsigned int v24 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Ignoring Registration status from wrong transport [%s] as we are currently IMS Registered on [%s]", buf, 0x16u);
      }
    }
    else
    {
      *(void *)long long buf = &v21;
      *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 42) = a3;
      *(void *)long long buf = &v21;
      long long v16 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      if (a4 == 1 && *((unsigned char *)v16[5] + 42))
      {
        *(void *)long long buf = &v21;
        *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270) = a5;
      }
      sub_1009C8A44(a1, v21);
      sub_1009DAF14((void **)a1, v21);
      BOOL v17 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)long long buf = &v21;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 42))
          uint64_t v18 = "true";
        else {
          uint64_t v18 = "false";
        }
        *(void *)long long buf = &v21;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 270))
          long long v19 = "true";
        else {
          long long v19 = "false";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        __int16 v23 = 2080;
        unsigned int v24 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I IMS registered: %s, Over Wifi: %s", buf, 0x16u);
      }
      sub_1009E1038(a1, v21);
      int v20 = v21;
      if (sub_1009E61B4(a1, v21)) {
        sub_1009CE628(a1, v20);
      }
    }
  }
}

BOOL sub_1009E61B4(uint64_t a1, int a2)
{
  int v8 = a2;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  *(void *)long long buf = &v8;
  uint64_t v4 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v8, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  if (v4[5][61] == v4[5][62] || *(_DWORD *)(a1 + 2360) != 2) {
    return 0;
  }
  int v5 = sub_1009E62D8(a1);
  unint64_t v6 = *v3;
  BOOL result = os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!result) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Active Call. Emergency text held.", buf, 2u);
    return 0;
  }
  if (result)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Pending messages in queue will be released.", buf, 2u);
  }
  return 1;
}

uint64_t sub_1009E62D8(uint64_t a1)
{
  char v1 = *(void **)(a1 + 208);
  uint64_t v2 = (void *)(a1 + 216);
  if (v1 == (void *)(a1 + 216)) {
    return 0;
  }
  do
  {
    if (*((unsigned char *)v1 + 57)) {
      BOOL v3 = *((unsigned char *)v1 + 56) == 0;
    }
    else {
      BOOL v3 = 1;
    }
    uint64_t result = !v3;
    if (!v3) {
      break;
    }
    int v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        unint64_t v6 = v5;
        int v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        unint64_t v6 = (void *)v1[2];
        BOOL v3 = *v6 == (void)v1;
        char v1 = v6;
      }
      while (!v3);
    }
    char v1 = v6;
  }
  while (v6 != v2);
  return result;
}

void sub_1009E6344(uint64_t a1, int a2, char a3)
{
  if (subscriber::isValidSimSlot())
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    void v7[2] = sub_1009E6474;
    void v7[3] = &unk_101A24EA0;
    v7[4] = a1;
    int v8 = a2;
    char v9 = a3;
    uint64_t v12 = 0;
    char v13 = 0;
    sub_10003E168(&v12, (void *)(a1 + 8));
    unint64_t v6 = *(NSObject **)(a1 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_1009EE930;
    block[3] = &unk_101A25358;
    block[5] = v12;
    BOOL v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v7;
    dispatch_async(v6, block);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_1009E6474(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(a1 + 40));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = *(char *)(a1 + 44);
    if (v5 > 3) {
      unint64_t v6 = "???";
    }
    else {
      unint64_t v6 = off_101A28DD0[v5];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I BB service ready received: %s", buf, 0xCu);
  }
  *(void *)long long buf = v2;
  int v7 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(v3 + 2544), v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261);
  int v8 = *(unsigned __int8 *)(a1 + 44);
  if (v7 != v8)
  {
    *(void *)long long buf = v2;
    *((unsigned char *)sub_1001B0B78((uint64_t **)(v3 + 2544), v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261) = v8;
    sub_1009CC30C(v3, *v2);
    sub_1009DC120(v3, *v2);
    sms::Controller::setupBasebandForCellBroadcast_sync(v3, *v2);
    sub_1009E669C(v3, *v2);
  }
  *(void *)long long buf = v2;
  if (*((unsigned char *)sub_1001B0B78((uint64_t **)(v3 + 2544), v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 261))
  {
    sub_1009C8A44(v3, *v2);
    int v9 = *v2;
    if (sub_1009E61B4(v3, *v2)) {
      sub_1009CE628(v3, v9);
    }
  }
  if (!v7)
  {
    *(void *)long long buf = v2;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(v3 + 2544), v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 269)) {
      sub_1009CE628(v3, *v2);
    }
  }
}

void sub_1009E669C(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_1009EA19C;
  v4[3] = &unk_101A24F30;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1009EE930;
  block[3] = &unk_101A25358;
  block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}