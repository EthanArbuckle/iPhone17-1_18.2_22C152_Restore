__n128 sub_100691D7C(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(void *)a2 = off_1019F7958;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100691DB4(void *a1, xpc_object_t *a2)
{
  v3 = (unsigned char *)a1[1];
  v9[0] = 0;
  v9[1] = 0;
  v8 = v9;
  sub_10031571C((uint64_t)&v8, a2);
  int v4 = *v3;
  sub_1003159D4(v3, &v8);
  if (v4 != *v3)
  {
    v5 = (void (*)(void *, BOOL))a1[3];
    uint64_t v6 = a1[4];
    v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      v5 = *(void (**)(void *, BOOL))(*v7 + v5);
    }
    v5(v7, v4 != 0);
  }
  sub_10005CD2C((uint64_t)&v8, v9[0]);
}

void sub_100691E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100691E94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100691ED4()
{
}

void sub_100691EE4()
{
}

void *sub_100691EF8(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F79D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100691F40(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F79D8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100691F6C(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  unsigned char *v3 = result;
  return result;
}

uint64_t sub_100691F9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100691FDC()
{
}

void sub_100691FEC()
{
}

__n128 sub_100692000(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F7A58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100692054(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10069208C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v9 = *(_OWORD *)v3;
  uint64_t v10 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_10010C4E0(v3, a2);
  int v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    int v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  long long v7 = v9;
  uint64_t v8 = v10;
  uint64_t v10 = 0;
  long long v9 = 0uLL;
  v4(v6, &v7);
  v11 = (void **)&v7;
  sub_1000C56F4(&v11);
  v11 = (void **)&v9;
  sub_1000C56F4(&v11);
}

void sub_100692158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v13 - 24) = &a9;
  sub_1000C56F4((void ***)(v13 - 24));
  *(void *)(v13 - 24) = &a13;
  sub_1000C56F4((void ***)(v13 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10069218C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006921CC()
{
}

void sub_1006921DC()
{
}

void *sub_1006921F0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F7AD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100692238(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F7AD8;
  a2[1] = v2;
  return result;
}

void sub_100692264(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  int v4 = (uint64_t **)(v2 + 8);
  sub_10003FB28(v2, *(void **)(v2 + 8));
  *(void *)uint64_t v2 = v2 + 8;
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v26, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    xpc_object_t v18 = v3;
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v25, object, count);
    xpc_release(object[0]);
    for (i = v27; ; i = ++v27)
    {
      if (i == v25[1] && v26 == v25[0])
      {
        xpc_release(v26);
        xpc_release(v26);
        xpc_object_t v3 = v18;
        goto LABEL_49;
      }
      xpc_object_t v24 = 0;
      object[0] = &v26;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v24);
      if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_47:
      xpc_release(v24);
    }
    uint64_t v23 = 0;
    long long v21 = 0u;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)object = 0u;
    *(_OWORD *)v20 = 0u;
    rest::GeoPlmn::GeoPlmn((rest::GeoPlmn *)&object[1]);
    xpc_object_t v7 = v24;
    if (v24)
    {
      xpc_retain(v24);
      xpc_object_t v29 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v29 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v31 = (uint64_t *)&v29;
        v32 = "first";
        sub_100048BAC((uint64_t)&v31, &v28);
        xpc_type_t type = xpc_get_type(v28);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          int v30 = (int)object[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v30, (int *)&v28, v10);
          LODWORD(object[0]) = v30;
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(object[0]) = xpc::dyn_cast_or_default((xpc *)&v28, 0, (uint64_t)v10);
        }
        xpc_release(v28);
        v31 = (uint64_t *)&v29;
        v32 = "second";
        sub_100048BAC((uint64_t)&v31, &v28);
        rest::read_rest_value((rest *)&object[1], (rest::GeoPlmn *)&v28, v11);
        xpc_release(v28);
        xpc_object_t v8 = v29;
      }
      xpc_release(v8);
      xpc_release(v7);
      int v12 = (int)object[0];
      uint64_t v13 = *v4;
      v14 = (uint64_t **)(v2 + 8);
      v15 = (uint64_t **)(v2 + 8);
      if (*v4)
      {
        while (1)
        {
          while (1)
          {
            v15 = (uint64_t **)v13;
            int v16 = *((_DWORD *)v13 + 8);
            if (v16 <= SLODWORD(object[0])) {
              break;
            }
            uint64_t v13 = *v15;
            v14 = v15;
            if (!*v15) {
              goto LABEL_42;
            }
          }
          if (v16 >= SLODWORD(object[0])) {
            break;
          }
          uint64_t v13 = v15[1];
          if (!v13)
          {
            v14 = v15 + 1;
            goto LABEL_42;
          }
        }
      }
      else
      {
LABEL_42:
        uint64_t v33 = 0;
        v17 = (uint64_t *)operator new(0x68uLL);
        v31 = v17;
        v32 = (const char *)(v2 + 8);
        LOBYTE(v33) = 0;
        *((_DWORD *)v17 + 8) = v12;
        MCC::MCC((MCC *)(v17 + 5), (const MCC *)&object[1]);
        MCC::MCC((MCC *)(v17 + 9), (const MCC *)((char *)&v21 + 8));
        LOBYTE(v33) = 1;
        sub_100046C38((uint64_t **)v2, (uint64_t)v15, v14, v31);
        v31 = 0;
        sub_10003FD44((uint64_t)&v31, 0);
      }
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
      if (SBYTE7(v21) < 0) {
        operator delete(v20[0]);
      }
      goto LABEL_47;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v29 = v8;
    goto LABEL_27;
  }
LABEL_49:
  xpc_release(v3);
}

void sub_100692674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,xpc_object_t a27,xpc_object_t a28,uint64_t a29,xpc_object_t a30,uint64_t a31,xpc_object_t a32)
{
}

uint64_t sub_1006927A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006927E8()
{
}

void sub_1006927F8()
{
}

__n128 sub_10069280C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F7B58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100692860(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100692898(void *a1, xpc *this, BOOL a3)
{
  int v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *int v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100692934(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100692974()
{
}

void sub_100692984()
{
}

__n128 sub_100692998(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019F7BD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1006929EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7BD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100692A24(void *a1, uint64_t a2, void ***a3)
{
  int v5 = *a3;
  int v4 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  memset(v10, 0, sizeof(v10));
  rest::read_rest_value();
  uint64_t v6 = (void (*)(void *, void *, void ***))a1[2];
  uint64_t v7 = a1[3];
  xpc_object_t v8 = (void *)(a1[1] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void *, void ***))(*v8 + v6);
  }
  LOBYTE(v9[0]) = 0;
  v9[1] = v5;
  v9[2] = v4;
  v6(v8, v10, v9);
  sub_100692B6C((unsigned __int8 *)v9);
  v9[0] = (void **)v10;
  sub_1006881C0(v9);
}

void sub_100692AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_100692B20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100692B60()
{
}

unsigned __int8 *sub_100692B6C(unsigned __int8 *a1)
{
  if (*((void *)a1 + 1))
  {
    xpc_object_t v2 = xpc_int64_create(*a1);
    if (!v2) {
      xpc_object_t v2 = xpc_null_create();
    }
    xpc_object_t v3 = (void **)*((void *)a1 + 1);
    int v4 = *v3;
    uint64_t *v3 = v2;
    xpc_release(v4);
  }
  int v5 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_100692BD8()
{
}

__n128 sub_100692BEC(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_1019F7C58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100692C40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100692C78(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  int v5 = (void *)v3[1];
  long long v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *int v4 = 0;
    v3[2] = 0;
  }
  else
  {
    long long v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100692D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100692D50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100692D90()
{
}

void sub_100692D9C(uint64_t **a1)
{
  v11 = a1;
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 2056) + 24))(*(void *)(v1 + 2056));
  DevicePersistentCopyValue((uint64_t *)&v12, kNextCarrierBundleUpdateCheck, 0);
  sub_100201EE4(&v13, &v12);
  xpc_object_t v2 = (CFDateRef *)(v1 + 416);
  if ((CFDateRef *)(v1 + 416) != &v13)
  {
    CFDateRef v3 = *v2;
    *xpc_object_t v2 = v13;
    CFDateRef v13 = 0;
    *(void *)buf = v3;
    sub_10007CA64((const void **)buf);
  }
  sub_10007CA64((const void **)&v13);
  sub_1000577C4(&v12);
  uint64_t v4 = *(void *)(v1 + 416);
  if (v4) {
    int v5 = sub_1001908E4;
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = *(NSObject **)(v1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      *(_DWORD *)buf = 138543362;
      *(void *)&buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Retrieved next update from preferences file: %{public}@", buf, 0xCu);
    }
    double Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v13 = CFDateCreate(kCFAllocatorDefault, Current);
    if (Current >= CFDateGetAbsoluteTime(*v2))
    {
      uint64_t v10 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&buf[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Next update present in the preferences file is past now (%{public}@), will check for update as soon as possible", buf, 0xCu);
      }
      int v9 = 4;
    }
    else
    {
      int v9 = 1;
    }
    sub_10007CA64((const void **)&v13);
  }
  else if (v7)
  {
    *(_WORD *)buf = 0;
    int v9 = 2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I No saved update date in preferences file", buf, 2u);
  }
  else
  {
    int v9 = 2;
  }
  sub_10067D784(v1, v9, 2);
  sub_100671AF0((uint64_t)buf, v1);
  sub_10000BDF8((uint64_t)buf);
  operator delete();
}

void sub_100693010(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10007CA64((const void **)va);
  operator delete();
}

uint64_t *sub_10069305C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    xpc_object_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    CFDateRef v3 = *(NSObject **)(v1 + 16);
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = *(NSObject **)(v1 + 16);
      if (v4) {
        dispatch_release(v4);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_1006930D8(uint64_t *a1)
{
  xpc_object_t v24 = a1;
  uint64_t v1 = *a1;
  *(void *)buf = a1 + 1;
  int v30 = "kIsEraseInstall";
  sub_100048BAC((uint64_t)buf, &v35);
  int v3 = xpc::dyn_cast_or_default((xpc *)&v35, 0, v2);
  xpc_release(v35);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Erase-install, skipping carrier bundle migration", buf, 2u);
    }
    return sub_10069305C((uint64_t *)&v24);
  }
  int v5 = *(NSObject **)(v1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Handling migration for carrier bundles", buf, 2u);
  }
  if (CarrierBundleHandler::removeVerificationKeys((CarrierBundleHandler *)v6))
  {
    xpc_object_t v33 = 0;
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v8 = v7;
    if (v7)
    {
      xpc_object_t v33 = v7;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v33 = v8;
      if (!v8)
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v8 = 0;
        goto LABEL_30;
      }
    }
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v8);
LABEL_31:
      xpc_release(v8);
LABEL_35:
      xpc_object_t object = xpc_BOOL_create(1);
      if (!object) {
        xpc_object_t object = xpc_null_create();
      }
      *(void *)buf = &v33;
      int v30 = off_101B0B018[0];
      sub_100035E70((uint64_t)buf, &object, &v32);
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_release(object);
      xpc_object_t object = 0;
      goto LABEL_38;
    }
    xpc_object_t v14 = xpc_null_create();
LABEL_30:
    xpc_object_t v33 = v14;
    goto LABEL_31;
  }
  *(void *)buf = CFPreferencesCopyValue(@"IMSI", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  if (*(void *)buf) {
    int v9 = sub_100080934;
  }
  else {
    int v9 = 0;
  }
  BOOL v10 = v9 != 0;
  if (v9)
  {
    CFPreferencesSetValue(@"IMSI", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_1003F2A04();
  }
  v35 = (void *)CFPreferencesCopyValue(@"IMSI2", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  if (v35) {
    v11 = sub_100080934;
  }
  else {
    v11 = 0;
  }
  if (v11)
  {
    CFPreferencesSetValue(@"IMSI2", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_1003F2A04();
    BOOL v10 = 1;
  }
  sub_1000577C4((const void **)&v35);
  sub_1000577C4((const void **)buf);
  xpc_object_t v33 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v33 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v33 = v13;
    if (!v13)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_33;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_34;
  }
  xpc_object_t v15 = xpc_null_create();
LABEL_33:
  xpc_object_t v33 = v15;
LABEL_34:
  xpc_release(v13);
  if (v10) {
    goto LABEL_35;
  }
LABEL_38:
  sub_10067D278(v1, 1, @"CarrierBundleName");
  if (capabilities::ct::supportsGemini(v16)) {
    sub_10067D278(v1, 2, @"Carrier2BundleName");
  }
  xpc_object_t v27 = xpc_string_create(off_101B0AED8[0]);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)buf = &v33;
  int v30 = off_101B0AEB0[0];
  sub_100035E70((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  uint64_t v17 = *(void *)(v1 + 120);
  xpc_object_t v25 = v33;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v25 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v17 + 16))(&v26, v17, &v25);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  sub_100678B30(v1);
  xpc_object_t v18 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Removing the Carrier Bundle legacy files", buf, 2u);
  }
  v35 = 0;
  v19 = off_101B0AEB0[0];
  v20 = off_101B0AF30[0];
  sub_1006941A8(buf);
  sub_1006940C4(v20, (void **)buf, (uint64_t)v19, &v35);
  xpc_release(*(xpc_object_t *)buf);
  uint64_t v21 = *(void *)(v1 + 120);
  xpc_object_t v34 = v35;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    xpc_object_t v34 = xpc_null_create();
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v21 + 16))(buf, v21, &v34);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)buf = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release(v35);
  v22 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Finished migration for carrier bundles", buf, 2u);
  }
  xpc_release(v33);
  return sub_10069305C((uint64_t *)&v24);
}

void sub_100693634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15)
{
}

void sub_100693720()
{
}

void *sub_100693734()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_1019F7CD8;
  return result;
}

void sub_10069376C(uint64_t a1, void *a2)
{
  *a2 = off_1019F7CD8;
}

uint64_t sub_100693798(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006937D8()
{
}

uint64_t *sub_1006937E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  long long v22 = 0u;
  memset(v21, 0, sizeof(v21));
  sub_100058198(&v20, (const void **)(v1 + 8));
  sub_100058198(&v19, (const void **)(v1 + 8));
  int v18 = 0;
  CarrierBundleHandler::matchCarrierBundle_sync(v2, &v20, &v19, &v18, *(unsigned int *)(v1 + 16), 1, (uint64_t)v21);
  sub_100057D78(&v19);
  sub_100057D78(&v20);
  if (!*(unsigned char *)(v2 + 432)) {
    goto LABEL_14;
  }
  int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = "true";
    __int16 v24 = 2080;
    xpc_object_t v25 = "false";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrap active is changing from %s to %s", buf, 0x16u);
  }
  *(unsigned char *)(v2 + 432) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    xpc_object_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  v11 = 0;
  char v13 = 1;
LABEL_12:
  (*(void (**)(uint64_t, void))(*(void *)v12 + 72))(v12, *(unsigned __int8 *)(v2 + 432));
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
LABEL_14:
  sub_10000BE9C((uint64_t)buf, (uint64_t)v21);
  char v26 = BYTE8(v22);
  uint64_t v14 = *(void *)(v1 + 48);
  if (!v14) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v14 + 48))(v14, buf);
  sub_10000BDF8((uint64_t)buf);
  sub_10000BDF8((uint64_t)v21);
  sub_100693AE8(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_100693A78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_10000BDF8((uint64_t)va2);
  sub_100693AE8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100693AE8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100687CB0((void *)(v1 + 24));
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100693B44()
{
}

void *sub_100693B58(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F7D58;
  result[1] = v3;
  return result;
}

uint64_t sub_100693BA0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F7D58;
  a2[1] = v2;
  return result;
}

void sub_100693BCC(uint64_t a1)
{
}

uint64_t sub_100693BDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100693C1C()
{
}

void sub_100693C2C()
{
}

void *sub_100693C40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F7DD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100693C88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F7DD8;
  a2[1] = v2;
  return result;
}

void sub_100693CB4(uint64_t a1)
{
}

uint64_t sub_100693CC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100693D04()
{
}

void sub_100693D14()
{
}

void *sub_100693D28()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_1019F7E58;
  return result;
}

void sub_100693D60(uint64_t a1, void *a2)
{
  *a2 = off_1019F7E58;
}

uint64_t sub_100693D8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100693DCC()
{
}

void sub_100693DDC()
{
}

void *sub_100693DF0()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_1019F7ED8;
  return result;
}

void sub_100693E28(uint64_t a1, void *a2)
{
  *a2 = off_1019F7ED8;
}

uint64_t sub_100693E54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100693E94()
{
}

void sub_100693EA0(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v14);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  long long v3 = *(_OWORD *)v14;
  *(void *)(v2 + 16) = v15;
  *(_OWORD *)uint64_t v2 = v3;
  HIBYTE(v15) = 0;
  LOBYTE(v14[0]) = 0;
  uint64_t v4 = (void **)(v2 + 24);
  if (*(char *)(v2 + 47) < 0) {
    operator delete(*v4);
  }
  long long v5 = v16;
  *(void *)(v2 + 40) = v17;
  *(_OWORD *)uint64_t v4 = v5;
  HIBYTE(v17) = 0;
  LOBYTE(v16) = 0;
  uint64_t v6 = (void **)(v2 + 48);
  if (*(char *)(v2 + 71) < 0) {
    operator delete(*v6);
  }
  long long v7 = v18;
  *(void *)(v2 + 64) = v19;
  *(_OWORD *)uint64_t v6 = v7;
  HIBYTE(v19) = 0;
  LOBYTE(v18) = 0;
  uint64_t v8 = (void **)(v2 + 72);
  if (*(char *)(v2 + 95) < 0) {
    operator delete(*v8);
  }
  long long v9 = __p;
  *(void *)(v2 + 88) = v21;
  *(_OWORD *)uint64_t v8 = v9;
  HIBYTE(v21) = 0;
  LOBYTE(__p) = 0;
  uint64_t v10 = (_OWORD *)(v2 + 96);
  if (*(char *)(v2 + 119) < 0)
  {
    operator delete(*(void **)(v2 + 96));
    int v12 = SHIBYTE(v21);
    long long v13 = v22;
    *(void *)(v2 + 112) = v23;
    *uint64_t v10 = v13;
    HIBYTE(v23) = 0;
    LOBYTE(v22) = 0;
    *(unsigned char *)(v2 + 120) = v24;
    if (v12 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    long long v11 = v22;
    *(void *)(v2 + 112) = v23;
    *uint64_t v10 = v11;
    HIBYTE(v23) = 0;
    LOBYTE(v22) = 0;
    *(unsigned char *)(v2 + 120) = v24;
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void sub_100694044(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100678B30(**a1);
  operator delete();
}

void sub_100694098()
{
}

void sub_1006940C4(char *string@<X2>, void **a2@<X0>, uint64_t a3@<X1>, void **a4@<X8>)
{
  xpc_object_t v7 = xpc_string_create(string);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v11 = v7;
LABEL_4:
    xpc_retain(v8);
    goto LABEL_5;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v11 = v8;
  if (v8) {
    goto LABEL_4;
  }
  xpc_object_t v8 = 0;
  xpc_object_t v11 = xpc_null_create();
LABEL_5:
  v10[0] = a2;
  v10[1] = a3;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  long long v9 = *a2;
  *a4 = *a2;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a4 = xpc_null_create();
  }
  xpc_release(v8);
}

void *sub_1006941A8(void *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  if (v2 || (xpc_object_t v2 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v2);
      xpc_object_t v3 = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v2 = 0;
  }
  xpc_release(v2);
  *a1 = v3;
  xpc_object_t v4 = xpc_null_create();
  xpc_release(v4);
  return a1;
}

void sub_100694264(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  ctu::cf::assign();
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0uLL;
  long long v5 = *(void (**)(uint64_t, void **, long long *))(v4 + 16);
  *(void *)&long long v8 = a3;
  v5(v4, __p, &v8);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006942DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10069430C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

const void **sub_100694328@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 8);
  char v5 = asWirelessTechnology();
  *a2 = 0;
  if ((v5 & 0xE4) != 0) {
    sub_100679644(&v7, v4, *(const MCC **)(v3 + 24), *(const MNC **)(v3 + 32), **(unsigned int **)(v3 + 16));
  }
  else {
    sub_10067BFBC(&v7, v4, **(_DWORD **)(v3 + 16));
  }
  if (&v7 != a2)
  {
    *a2 = v7;
    uint64_t v7 = 0;
    long long v8 = 0;
    sub_100057D78(&v8);
  }
  return sub_100057D78(&v7);
}

void sub_1006943D4(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

const void **sub_1006943EC(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  xpc_object_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *xpc_object_t v2 = 0;
    uint64_t v6 = v3;
    *xpc_object_t v2 = v5;
    char v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_100694464(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  xpc_object_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *xpc_object_t v2 = 0;
    uint64_t v6 = v3;
    *xpc_object_t v2 = v5;
    char v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

uint64_t *sub_1006944DC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  char v5 = v1;
  (*(void (**)(void **__return_ptr))(*(void *)*v1 + 128))(__p);
  uint64_t v2 = v1[4];
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 48))(v2, __p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_1006945C4((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100694590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

uint64_t *sub_1006945C4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10001E914((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100694614(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if (*((unsigned char *)*v1 + 432)) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 144))();
  }
  else {
    return (*(uint64_t (**)(unsigned int *, void))(*(void *)v2 + 128))(v2, *v1[1]);
  }
}

__n128 sub_100694674(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t sub_1006946D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = **(_DWORD **)(v1 + 8);
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  sub_10067C528((uint64_t)v6, v2, 1u, v3);
  if ((_BYTE)v14) {
    char v4 = BYTE8(v7);
  }
  else {
    char v4 = 0;
  }
  sub_100687D34((uint64_t)v6);
  return v4;
}

uint64_t sub_100694754(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100694790(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_1006947CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 40);
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  sub_10067C528((uint64_t)v9, v2, 1u, v3);
  uint64_t v4 = v1 + 8;
  if ((_BYTE)v17) {
    char v5 = BYTE8(v10);
  }
  else {
    char v5 = 0;
  }
  sub_100687D34((uint64_t)v9);
  sub_1006948DC(v4, v5);
  sub_10069488C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100694870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10069488C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100687D78((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1006948DC(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t *sub_100694930(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v4 = a1;
  uint64_t v5 = v1;
  sub_10067C934(&v6, *(void *)v1, *(_DWORD *)(v1 + 40));
  uint64_t v2 = *(void *)(v1 + 32);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, &v6);
  sub_1000558F4(&v6);
  sub_1006949E8(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1006949BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1006949E8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006949E8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001289E8((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100694A38@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  return sub_10067C934(a2, **(void **)(a1 + 40), **(_DWORD **)(*(void *)(a1 + 40) + 8));
}

const void **sub_100694A4C(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

const void **sub_100694AC4(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

const void **sub_100694B3C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10067CDD0(a2, **(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8));
}

const void **sub_100694B50(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  sub_100694BB0(*(const void ***)(a1 + 32), (uint64_t)&v3);
  sub_100057D78(&v5);
  return sub_100057D78(&v4);
}

const void **sub_100694BB0(const void **result, uint64_t a2)
{
  *(unsigned char *)uint64_t result = *(unsigned char *)a2;
  if (result != (const void **)a2)
  {
    uint64_t v3 = result;
    char v4 = result[1];
    result[1] = 0;
    uint64_t v6 = v4;
    result[1] = *(const void **)(a2 + 8);
    *(void *)(a2 + 8) = 0;
    sub_100057D78(&v6);
    uint64_t v5 = v3[2];
    v3[2] = 0;
    uint64_t v6 = v5;
    v3[2] = *(const void **)(a2 + 16);
    *(void *)(a2 + 16) = 0;
    return sub_100057D78(&v6);
  }
  return result;
}

const void **sub_100694C2C(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  sub_100694BB0(*(const void ***)(a1 + 32), (uint64_t)&v3);
  sub_100057D78(&v5);
  return sub_100057D78(&v4);
}

uint64_t *sub_100694C8C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  CFTypeRef cf = 0;
  CFTypeRef v12 = 0;
  uint64_t v10 = 0;
  sub_10067CDD0((uint64_t)&v10, v2, *(unsigned int *)(v1 + 8));
  v7[0] = v10;
  CFTypeRef v8 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v9 = v12;
  if (v12) {
    CFRetain(v12);
  }
  uint64_t v3 = *(void *)(v1 + 40);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v3 + 48))(v3, v7);
  sub_100057D78(&v9);
  sub_100057D78(&v8);
  sub_100057D78(&v12);
  sub_100057D78(&cf);
  sub_100694DD8(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100694D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100694DD8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100687DFC((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100694E28(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_100694E68(uint64_t *a1, uint64_t **a2, int a3)
{
  uint64_t v3 = a1[1];
  if (!v3 || atomic_load_explicit((atomic_uint *volatile)(v3 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a2;
  long long v7 = (uint64_t *)sub_100694E28(*a1);
  uint64_t result = sub_100695234(*v7);
  if ((uint64_t *)result != v6)
  {
    unsigned int v9 = 0;
    unsigned int v10 = a3 - 1;
    long long v11 = v6;
    v38 = v5;
    do
    {
      if (*(unsigned char *)(sub_1006951B4(v11[2]) + 24))
      {
        uint64_t v6 = (uint64_t *)v11[1];
      }
      else
      {
        CFTypeRef v12 = *(uint64_t **)sub_100694E28(*v5);
        sub_100695234((uint64_t)v12);
        uint64_t v13 = sub_1006951B4(v11[2]);
        if (v11 == v12) {
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        }
        long long v14 = v12 + 4;
        long long v15 = (void *)v12[4];
        if (!v15) {
          goto LABEL_45;
        }
        uint64_t v16 = v13 + 64;
        v39 = (uint64_t **)(v12 + 3);
        uint64_t v17 = v12 + 4;
        do
        {
          BOOL v18 = sub_100162ED8((uint64_t)(v12 + 6), (uint64_t)(v15 + 4), v16);
          uint64_t v19 = v15 + 1;
          if (!v18)
          {
            uint64_t v19 = v15;
            uint64_t v17 = v15;
          }
          long long v15 = (void *)*v19;
        }
        while (*v19);
        if (v17 == v14) {
LABEL_45:
        }
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (sub_100162ED8((uint64_t)(v12 + 7), (uint64_t)(v17 + 4), v16)
          || sub_100162ED8((uint64_t)(v12 + 7), v16, (uint64_t)(v17 + 4)))
        {
          __assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)");
        }
        if ((uint64_t *)v17[6] == v11)
        {
          uint64_t v37 = v11[1];
          v20 = (void *)*v14;
          uint64_t v21 = v12;
          if (*v14)
          {
            long long v22 = v12 + 4;
            do
            {
              BOOL v23 = sub_100162ED8((uint64_t)(v12 + 6), v16, (uint64_t)(v20 + 4));
              char v24 = v20 + 1;
              if (v23)
              {
                char v24 = v20;
                long long v22 = v20;
              }
              v20 = (void *)*v24;
            }
            while (*v24);
            uint64_t v21 = v12;
            if (v22 != v14) {
              uint64_t v21 = (uint64_t *)v22[6];
            }
          }
          if ((uint64_t *)v37 == v21)
          {
            xpc_object_t v29 = (uint64_t *)v17[1];
            int v30 = v17;
            if (v29)
            {
              do
              {
                v31 = v29;
                xpc_object_t v29 = (uint64_t *)*v29;
              }
              while (v29);
            }
            else
            {
              do
              {
                v31 = (uint64_t *)v30[2];
                BOOL v32 = *v31 == (void)v30;
                int v30 = v31;
              }
              while (!v32);
            }
            if (*v39 == v17) {
              *v39 = v31;
            }
            xpc_object_t v33 = (uint64_t *)v12[4];
            --v12[5];
            sub_10005EE6C(v33, v17);
            operator delete(v17);
          }
          else
          {
            uint64_t v40 = 0;
            xpc_object_t v25 = (void **)sub_100162E38((uint64_t)v39, &v40, v16);
            char v26 = *v25;
            if (!*v25)
            {
              xpc_object_t v27 = (uint64_t **)v25;
              char v26 = operator new(0x38uLL);
              int v28 = *(_DWORD *)(v16 + 8);
              v26[4] = *(void *)v16;
              *((_DWORD *)v26 + 10) = v28;
              v26[6] = 0;
              sub_100046C38(v39, v40, v27, v26);
            }
            v26[6] = v37;
          }
        }
        uint64_t v34 = *v11;
        uint64_t v6 = (uint64_t *)v11[1];
        *(void *)(v34 + 8) = v6;
        *(void *)v11[1] = v34;
        --v12[2];
        sub_10000A740((atomic_uint **)v11 + 3);
        operator delete(v11);
        uint64_t v5 = v38;
      }
      ++v9;
      v35 = (uint64_t *)sub_100694E28(*v5);
      uint64_t result = sub_100695234(*v35);
      BOOL v36 = v6 != (uint64_t *)result && v10 >= v9;
      long long v11 = v6;
    }
    while (v36);
  }
  v5[2] = (uint64_t)v6;
  return result;
}

uint64_t sub_1006951B4(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_1006951F4(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100695234(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100695274(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100695598(v3);
      sub_10000A4EC(&v18, v3);
      uint64_t v4 = *(void *)(*a1 + 16);
      sub_1006951B4(v4);
      uint64_t v5 = *(_DWORD ***)(v4 + 32);
      if (v5)
      {
        uint64_t v6 = a1[2];
        long long v7 = *v5;
        if (v7 != *(_DWORD **)(sub_1006951F4((uint64_t)v5) + 8))
        {
          CFTypeRef v8 = (void *)(v6 + 8);
          while (1)
          {
            memset(v30, 0, sizeof(v30));
            sub_100060B10(v7, (uint64_t)v30);
            if (sub_100060A68((uint64_t)v7)) {
              break;
            }
            sub_100062188(v8, (uint64_t)v30);
            sub_1000624B4((uint64_t)v30);
            v7 += 6;
            if (v7 == *(_DWORD **)(sub_1006951F4(*(void *)(v4 + 32)) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v4 + 24))
          {
            *(unsigned char *)(v4 + 24) = 0;
            sub_100060D70((atomic_uint **)v4, &v18);
          }
          sub_1000624B4((uint64_t)v30);
        }
      }
LABEL_12:
      uint64_t v9 = sub_1006951B4(*(void *)(*a1 + 16));
      uint64_t v10 = a1[2];
      if (*(unsigned char *)(v9 + 24)) {
        ++*(_DWORD *)(v10 + 288);
      }
      else {
        ++*(_DWORD *)(v10 + 292);
      }
      uint64_t v11 = sub_1006951B4(*(void *)(*a1 + 16));
      if (!*(unsigned char *)(v11 + 24)
        || (uint64_t v12 = *(void *)(v11 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v12 + 8), memory_order_acquire))
      {
        int v13 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v18, *a1);
        int v13 = 0;
      }
      (*(void (**)(void))(**((void **)&v29 + 1) + 32))(*((void *)&v29 + 1));
      sub_10000A5F8(&v18);
      uint64_t v1 = *a1;
      uint64_t v14 = a1[1];
      if (!v13) {
        break;
      }
      uint64_t v15 = *(void *)(v1 + 8);
      *a1 = v15;
      if (v15 == v14)
      {
        uint64_t v1 = v14;
        goto LABEL_24;
      }
    }
    if (v1 == v14)
    {
LABEL_24:
      uint64_t v16 = a1[3];
      if (v16 != v1)
      {
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        uint64_t v17 = *(void *)(v16 + 16);
        sub_100695598(v17);
        sub_10000A4EC(&v18, v17);
        sub_1001C36EC(a1, &v18, a1[1]);
        (*(void (**)(void))(**((void **)&v29 + 1) + 32))(*((void *)&v29 + 1));
        sub_10000A5F8(&v18);
      }
    }
  }
}

void sub_100695540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100695598(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_1006955D8(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v2 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v3 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_100694E28(*v3);
    if (sub_100695234(*v5) == v2)
    {
      uint64_t v6 = v3[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      long long v7 = (uint64_t *)sub_100694E28(*v3);
      uint64_t v9 = *(uint64_t **)(sub_100695234(*v7) + 8);
      sub_100694E68(v3, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100695B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    sub_10016267C(a12);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_100695B90(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v10);
    sub_100161F10((uint64_t)va);
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100695BAC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100695D20(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100695BCC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v2);
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100695BE8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  operator delete(a12, 0x20C40DC1BFBCFLL);
  JUMPOUT(0x100695C7CLL);
}

void sub_100695BF4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100161F10((uint64_t)va);
  sub_10006A6AC(a1);
}

void sub_100695C20(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100695C84);
}

void sub_100695C90()
{
}

uint64_t sub_100695CA4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100695D08()
{
  return 0;
}

uint64_t sub_100695D10()
{
  return 0;
}

uint64_t sub_100695D18()
{
  return 0;
}

uint64_t sub_100695D20(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (atomic_uint **)result;
    sub_10005D144(*(void **)(result + 32));
    sub_100162A90(v1);
    operator delete();
  }
  return result;
}

void sub_100695D80()
{
}

uint64_t sub_100695D94(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10005D144(*(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100695DF8()
{
  return 0;
}

uint64_t sub_100695E00()
{
  return 0;
}

uint64_t sub_100695E08()
{
  return 0;
}

uint64_t sub_100695E10(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100695EE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100695F08()
{
}

void *sub_100695F1C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F8280;
  result[1] = v3;
  return result;
}

uint64_t sub_100695F64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F8280;
  a2[1] = v2;
  return result;
}

char *sub_100695F90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  subscriber::makeSimSlotRange();
  uint64_t v2 = (unsigned int *)*((void *)&v19 + 1);
  uint64_t v3 = (unsigned int *)v19;
  if ((void)v19 != *((void *)&v19 + 1))
  {
    uint64_t v4 = v20;
    while ((v20(*v3) & 1) == 0)
    {
      if (++v3 == *((unsigned int **)&v19 + 1))
      {
        uint64_t v3 = (unsigned int *)*((void *)&v19 + 1);
        break;
      }
    }
    long long v5 = (unsigned int *)*((void *)&v19 + 1);
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      unint64_t v18 = ((unint64_t)v6 << 32) | 1;
      *(void *)buf = &v18;
      if (*((void *)sub_100688D4C((uint64_t **)(v1 + 136), (unsigned __int8 *)&v18, (uint64_t)&unk_10144E20E, (void **)buf)+ 30))long long v7 = sub_100080778; {
      else
      }
        long long v7 = 0;
      if (v7)
      {
        CFTypeRef v8 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = asString();
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Default bundle is updated, issuing update for %s", buf, 0xCu);
        }
        sub_100673654(v1, 1u, 1, v6);
      }
      unint64_t v18 = (v6 << 32) | 2;
      *(void *)buf = &v18;
      if (*((void *)sub_100688D4C((uint64_t **)(v1 + 136), (unsigned __int8 *)&v18, (uint64_t)&unk_10144E20E, (void **)buf)+ 30))uint64_t v10 = sub_100080778; {
      else
      }
        uint64_t v10 = 0;
      if (v10)
      {
        long long v11 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = asString();
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Default bundle is updated, issuing update for %s", buf, 0xCu);
        }
        sub_100673654(v1, 2u, 1, v6);
      }
      int v13 = v3 + 1;
      uint64_t v3 = v2;
      if (v13 != v2)
      {
        uint64_t v3 = v13;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            uint64_t v3 = v2;
            break;
          }
        }
      }
    }
  }
  *(void *)buf = 0x100000003;
  *(void *)&long long v19 = buf;
  uint64_t result = sub_100688D4C((uint64_t **)(v1 + 136), buf, (uint64_t)&unk_10144E20E, (void **)&v19);
  if (*((void *)result + 30)) {
    uint64_t v15 = sub_100080778;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15)
  {
    uint64_t v16 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = asString();
      LODWORD(v19) = 136315138;
      *(void *)((char *)&v19 + 4) = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Default bundle is updated, issuing update for %s", (uint8_t *)&v19, 0xCu);
    }
    return (char *)sub_100673654(v1, 3u, 1, 1);
  }
  return result;
}

uint64_t sub_1006962A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006962E8()
{
}

void sub_1006962F4(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10067D784(**a1, 0, *((unsigned __int8 *)*a1 + 8));
  operator delete();
}

void sub_100696350()
{
}

uint64_t sub_10069637C(__CFDictionary *a1, void *cf, uint64_t a3)
{
  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v6 = a3;
  if (a3)
  {
    CFRetain((CFTypeRef)a3);
    if (key)
    {
      CFDictionaryAddValue(a1, key, (const void *)a3);
      a3 = 1;
    }
    else
    {
      a3 = 0;
    }
  }
  sub_10010F494((const void **)&v6);
  sub_10010F494((const void **)&key);
  return a3;
}

void sub_1006963FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t **sub_100696420(uint64_t **a1, unsigned __int8 a2, unsigned __int8 *a3)
{
  uint64_t v6 = a1 + 1;
  long long v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int8 *)v5 + 25);
        if (v8 <= a2) {
          break;
        }
        long long v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      long long v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (char *)operator new(0x20uLL);
    *(_WORD *)(v9 + 25) = *a3;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_1006964D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t result = sub_1000608A8(v4 + 136, *(unsigned char *)v3, *(_DWORD *)(v3 + 4));
  if (v4 + 144 == result)
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    uint64_t v6 = result;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v8 = 0u;
    memset(v7, 0, sizeof(v7));
    sub_10000BE9C((uint64_t)v7, result + 40);
    sub_100058198((const void **)&v9 + 1, (const void **)(v6 + 240));
    sub_100058198((const void **)&v10, (const void **)(v6 + 248));
    DWORD2(v10) = *(_DWORD *)(v6 + 256);
    if (SBYTE7(v9) < 0)
    {
      sub_10004FC84((unsigned char *)a2, (void *)v8, *((unint64_t *)&v8 + 1));
    }
    else
    {
      *(_OWORD *)a2 = v8;
      *(void *)(a2 + 16) = v9;
    }
    sub_100057D78((const void **)&v10);
    sub_100057D78((const void **)&v9 + 1);
    return sub_10000BDF8((uint64_t)v7);
  }
  return result;
}

void sub_1006965D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100057D78(v10);
  sub_100057D78(v9);
  sub_10000BDF8((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1006965FC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_100681FDC(a2, *(void *)(*(void *)(a1 + 40) + 8), **(unsigned char **)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 40) + 4));
}

const void **sub_100696614@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 40);
  uint64_t v4 = *((void *)v3 + 1);
  uint64_t v5 = *v3;
  uint64_t v6 = *((unsigned int *)v3 + 1);
  v83 = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v81 = 0;
  v82 = 0;
  v79 = 0;
  v80 = 0;
  v78 = 0;
  uint64_t v77 = 0;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  memset(v68, 0, sizeof(v68));
  sub_10067C528((uint64_t)v68, v4, v5, v6);
  if (!(_BYTE)v77) {
    goto LABEL_87;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 104));
  long long v8 = ServiceMap;
  uint64_t v10 = v9;
  if (v9 < 0)
  {
    long long v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v88 = v10;
  uint64_t v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v88);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_10:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v16 + 80))(__p, v16, v6, v5, @"CarrierName", 0, 0);
  sub_100056248(&__dst, (CFTypeRef *)__p);
  *(void *)&long long v88 = v82;
  v82 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000558F4((const void **)&v88);
  sub_1000558F4((const void **)&__dst);
  sub_1000577C4((const void **)__p);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (SBYTE7(v70) < 0)
  {
    sub_10004FC84(__p, (void *)v69, *((unint64_t *)&v69 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = v69;
    uint64_t v67 = v70;
  }
  if (SHIBYTE(v67) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v87 = v67;
  }
  v90 = 0;
  if (SHIBYTE(v87) < 0)
  {
    sub_10004FC84(&v88, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v88 = __dst;
    uint64_t v89 = v87;
  }
  v91[0] = 0;
  if (ctu::cf::convert_copy())
  {
    unint64_t v18 = v90;
    v90 = (void *)v91[0];
    v63[0] = v18;
    sub_1000558F4((const void **)v63);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete((void *)v88);
  }
  v85 = v90;
  v90 = 0;
  sub_1000558F4((const void **)&v90);
  if (SHIBYTE(v87) < 0) {
    operator delete((void *)__dst);
  }
  *(void *)&long long v88 = v81;
  v81 = v85;
  v85 = 0;
  sub_1000558F4((const void **)&v88);
  sub_1000558F4(&v85);
  if (SHIBYTE(v67) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v68[2]) < 0)
  {
    sub_10004FC84(v63, *((void **)&v68[1] + 1), *(unint64_t *)&v68[2]);
  }
  else
  {
    *(_OWORD *)v63 = *(_OWORD *)((char *)&v68[1] + 8);
    uint64_t v64 = *((void *)&v68[2] + 1);
  }
  if (SHIBYTE(v64) < 0)
  {
    sub_10004FC84(&__dst, v63[0], (unint64_t)v63[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v63;
    uint64_t v87 = v64;
  }
  v85 = 0;
  if (SHIBYTE(v87) < 0)
  {
    sub_10004FC84(&v88, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v88 = __dst;
    uint64_t v89 = v87;
  }
  v90 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v19 = v85;
    v85 = v90;
    v91[0] = v19;
    sub_1000558F4(v91);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete((void *)v88);
  }
  v65 = v85;
  v85 = 0;
  sub_1000558F4(&v85);
  if (SHIBYTE(v87) < 0) {
    operator delete((void *)__dst);
  }
  *(void *)&long long v88 = v80;
  v80 = v65;
  v65 = 0;
  sub_1000558F4((const void **)&v88);
  long long v20 = sub_1000558F4(&v65);
  if (SHIBYTE(v64) < 0) {
    operator delete(v63[0]);
  }
  if (capabilities::ct::supportsDERFileFormat((capabilities::ct *)v20))
  {
    long long v21 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 104));
    long long v22 = v21;
    uint64_t v23 = v9;
    if (v9 < 0)
    {
      long long v24 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    *(void *)&long long v88 = v23;
    long long v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)&v88);
    if (v27)
    {
      uint64_t v29 = v27[3];
      long long v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    long long v28 = 0;
    char v30 = 1;
LABEL_61:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v29 + 80))(v91, v29, v6, v5, @"DerPriFileName", 0, 0);
    sub_100056248(&__dst, v91);
    *(void *)&long long v88 = v78;
    v78 = (const void *)__dst;
    *(void *)&long long __dst = 0;
    sub_1000558F4((const void **)&v88);
    sub_1000558F4((const void **)&__dst);
    sub_1000577C4(v91);
    if ((v30 & 1) == 0) {
      sub_10004D2C8(v28);
    }
    v41 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 104));
    v42 = v41;
    if (v9 < 0)
    {
      v43 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v44 = 5381;
      do
      {
        uint64_t v9 = v44;
        unsigned int v45 = *v43++;
        uint64_t v44 = (33 * v44) ^ v45;
      }
      while (v45);
    }
    std::mutex::lock(v41);
    *(void *)&long long v88 = v9;
    v46 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)&v88);
    if (v46)
    {
      uint64_t v48 = v46[3];
      v47 = (std::__shared_weak_count *)v46[4];
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v42);
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v47);
        char v49 = 0;
LABEL_81:
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v48 + 80))(v91, v48, v6, v5, @"DerPriFileVersion", 0, 0);
        sub_100056248(&__dst, v91);
        goto LABEL_85;
      }
    }
    else
    {
      uint64_t v48 = 0;
    }
    std::mutex::unlock(v42);
    v47 = 0;
    char v49 = 1;
    goto LABEL_81;
  }
  v31 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 104));
  BOOL v32 = v31;
  uint64_t v33 = v9;
  if (v9 < 0)
  {
    uint64_t v34 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v35 = 5381;
    do
    {
      uint64_t v33 = v35;
      unsigned int v36 = *v34++;
      uint64_t v35 = (33 * v35) ^ v36;
    }
    while (v36);
  }
  std::mutex::lock(v31);
  *(void *)&long long v88 = v33;
  uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)&v88);
  if (v37)
  {
    uint64_t v39 = v37[3];
    v38 = (std::__shared_weak_count *)v37[4];
    if (v38)
    {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v32);
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v38);
      char v40 = 0;
      goto LABEL_71;
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  std::mutex::unlock(v32);
  v38 = 0;
  char v40 = 1;
LABEL_71:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v39 + 80))(v91, v39, v6, v5, @"PRIFileName", 0, 0);
  sub_100056248(&__dst, v91);
  *(void *)&long long v88 = v78;
  v78 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000558F4((const void **)&v88);
  sub_1000558F4((const void **)&__dst);
  sub_1000577C4(v91);
  if ((v40 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  v50 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 104));
  v51 = v50;
  if (v9 < 0)
  {
    v52 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v53 = 5381;
    do
    {
      uint64_t v9 = v53;
      unsigned int v54 = *v52++;
      uint64_t v53 = (33 * v53) ^ v54;
    }
    while (v54);
  }
  std::mutex::lock(v50);
  *(void *)&long long v88 = v9;
  v55 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)&v88);
  if (!v55)
  {
    uint64_t v56 = 0;
    goto LABEL_83;
  }
  uint64_t v56 = v55[3];
  v47 = (std::__shared_weak_count *)v55[4];
  if (!v47)
  {
LABEL_83:
    std::mutex::unlock(v51);
    v47 = 0;
    char v49 = 1;
    goto LABEL_84;
  }
  atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v51);
  atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v47);
  char v49 = 0;
LABEL_84:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v56 + 80))(v91, v56, v6, v5, @"PriVersion", 0, 0);
  sub_100056248(&__dst, v91);
LABEL_85:
  *(void *)&long long v88 = v79;
  v79 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000558F4((const void **)&v88);
  sub_1000558F4((const void **)&__dst);
  sub_1000577C4(v91);
  if ((v49 & 1) == 0) {
    sub_10004D2C8(v47);
  }
LABEL_87:
  if (v82) {
    v57 = sub_1000810B8;
  }
  else {
    v57 = 0;
  }
  if (v57) {
    CFDictionarySetValue(Mutable, @"CarrierName", v82);
  }
  if (v81) {
    v58 = sub_1000810B8;
  }
  else {
    v58 = 0;
  }
  if (v58) {
    CFDictionarySetValue(Mutable, @"BundleVersion", v81);
  }
  if (v80) {
    v59 = sub_1000810B8;
  }
  else {
    v59 = 0;
  }
  if (v59) {
    CFDictionarySetValue(Mutable, @"BundleIdentifier", v80);
  }
  if (v78) {
    v60 = sub_1000810B8;
  }
  else {
    v60 = 0;
  }
  if (v60) {
    CFDictionarySetValue(Mutable, @"PRIName", v78);
  }
  if (v79) {
    v61 = sub_1000810B8;
  }
  else {
    v61 = 0;
  }
  if (v61) {
    CFDictionarySetValue(Mutable, @"PRIVersion", v79);
  }
  sub_10004EFE4(a2, (CFTypeRef *)&Mutable);
  sub_100687D34((uint64_t)v68);
  sub_1000558F4(&v78);
  sub_1000558F4(&v79);
  sub_1000558F4(&v80);
  sub_1000558F4(&v81);
  sub_1000558F4(&v82);
  sub_1000558F4(&v83);
  return sub_10005717C((const void **)&Mutable);
}

void sub_100696FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  sub_1000558F4((const void **)(v23 - 168));
  if (*(char *)(v23 - 137) < 0) {
    operator delete(*(void **)(v23 - 160));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100687D34((uint64_t)&a23);
  sub_1000558F4((const void **)(v23 - 224));
  sub_1000558F4((const void **)(v23 - 216));
  sub_1000558F4((const void **)(v23 - 208));
  sub_1000558F4((const void **)(v23 - 200));
  sub_1000558F4((const void **)(v23 - 192));
  sub_1000558F4((const void **)(v23 - 184));
  sub_10005717C((const void **)(v23 - 176));
  _Unwind_Resume(a1);
}

uint64_t *sub_100697164(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void **)v1;
  sub_100119B5C((const void **)&v12, (const void **)(v1 + 8));
  sub_1000DFC90((uint64_t)v19, v1 + 16);
  xpc_object_t v18 = 0;
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v18 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v18 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v5;
LABEL_9:
  xpc_release(v4);
  xpc_object_t v16 = xpc_string_create(off_101B0AF00[0]);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  v20[0] = &v18;
  v20[1] = off_101B0AEB0[0];
  sub_100035E70((uint64_t)v20, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  ctu::cf_to_xpc((uint64_t *)&v14, v12, v6);
  v20[0] = &v18;
  v20[1] = off_101B0AF58[0];
  sub_100035E70((uint64_t)v20, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v14);
  uint64_t v7 = v2[15];
  xpc_object_t v13 = v18;
  xpc_object_t v14 = 0;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v13 = xpc_null_create();
  }
  v20[0] = v2;
  v20[1] = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    v20[1] = xpc_null_create();
  }
  sub_1000DFC90((uint64_t)v21, (uint64_t)v19);
  uint64_t v23 = 0;
  long long v8 = (char *)operator new(0x38uLL);
  *(void *)long long v8 = off_1019F8380;
  *(_OWORD *)(v8 + 8) = *(_OWORD *)v20;
  v20[1] = xpc_null_create();
  sub_100023950((uint64_t)(v8 + 24), (uint64_t)v21);
  uint64_t v23 = v8;
  (*(void (**)(uint64_t, xpc_object_t *, void *))(*(void *)v7 + 24))(v7, &v13, v22);
  sub_1001472DC(v22);
  sub_100060644(v21);
  xpc_release(v20[1]);
  v20[1] = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v18);
  sub_100060644(v19);
  sub_1000FE824((const void **)&v12);
  sub_1006974E8(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_10069740C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,xpc_object_t a30)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_1006974E8(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    sub_1000FE824((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100697540(uint64_t a1)
{
  *(void *)a1 = off_1019F8380;
  sub_100060644((void *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_100697594(uint64_t a1)
{
  *(void *)a1 = off_1019F8380;
  sub_100060644((void *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_100697608(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_1019F8380;
  sub_1006979B8(v2 + 1, v1);
  return v2;
}

void sub_10069765C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100697670(uint64_t a1, void *a2)
{
  *a2 = off_1019F8380;
  return sub_1006979B8(a2 + 1, (void *)(a1 + 8));
}

void sub_10069769C(uint64_t a1)
{
}

void sub_1006976A4(void *a1)
{
  sub_100697A28((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1006976E0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_object_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&p_object, (xpc::object *)(a1 + 16));
    int v5 = v16;
    uint64_t v6 = (void **)p_object;
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    uint64_t v7 = &p_object;
    if (v5 < 0) {
      uint64_t v7 = v6;
    }
    if (v13 >= 0) {
      long long v8 = __p;
    }
    else {
      long long v8 = (void **)__p[0];
    }
    buf[0] = 136446466;
    *(void *)&buf[1] = v7;
    __int16 v18 = 2082;
    long long v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sent request %{public}s to install bundle, received result: %{public}s", (uint8_t *)buf, 0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    if (v16 < 0) {
      operator delete(p_object);
    }
  }
  p_xpc_object_t object = &object;
  xpc_object_t v15 = off_101B0AF60[0];
  sub_100048BAC((uint64_t)&p_object, __p);
  int v10 = xpc::dyn_cast_or_default((xpc *)__p, 0, v9);
  xpc_release(__p[0]);
  if (v10)
  {
    p_xpc_object_t object = 0;
    xpc_object_t v15 = 0;
    sub_10003E168(&p_object, (void *)(v3 + 8));
    operator new();
  }
  sub_1000607A8(a1 + 24, 0);
  xpc_release(object);
}

void sub_100697904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10069796C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006979AC()
{
}

void *sub_1006979B8(void *a1, void *a2)
{
  xpc_object_t v4 = (void *)a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    a1[1] = xpc_null_create();
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_100697A08(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void sub_100697A28(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

void sub_100697A60(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100678B30(**a1);
  operator delete();
}

void sub_100697AB4()
{
}

uint64_t *sub_100697AE0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  int v10 = 0;
  DevicePersistentCopyValue((uint64_t *)v7, @"kRemoteCarrierBundleInfo", 0);
  sub_10004EFE4(&v10, v7);
  sub_1000577C4(v7);
  if (v10) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v10, v2);
    v7[0] = *(const void **)(v1 + 8);
    v7[1] = "kCarrierBundleRemoteBundleInfo";
    sub_100035E70((uint64_t)v7, &object, &v9);
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
  }
  sub_100057D78((const void **)&v10);
  sub_1000E1A60(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100697BB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  sub_100057D78((const void **)(v2 - 24));
  sub_1000E1A60((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100697BF4(void *a1)
{
  uint64_t v2 = a1;
  if (*a1) {
    operator delete();
  }
  return sub_100046B58((uint64_t *)&v2);
}

uint64_t sub_100697C38(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Request to clear user library bundles.", buf, 2u);
  }
  xpc_object_t v19 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v19 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_11;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_10:
  xpc_object_t v19 = v6;
LABEL_11:
  xpc_release(v5);
  xpc_object_t object = xpc_string_create(off_101B0AF08[0]);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)buf = &v19;
  char v16 = off_101B0AEB0[0];
  sub_100035E70((uint64_t)buf, &object, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v7 = *(void *)(v2 + 120);
  xpc_object_t v13 = v19;
  xpc_object_t v14 = 0;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v13 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v7 + 16))(&v14, v7, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  *(void *)buf = &v14;
  char v16 = off_101B0AF68[0];
  sub_100048BAC((uint64_t)buf, &v12);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&v12, 0, v8);
  xpc_release(v12);
  if (v9)
  {
    int v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I CarrierBundles removed from User directory. Need to rematch bundles", buf, 2u);
    }
    sub_100678B30(v2);
  }
  xpc_release(v14);
  xpc_release(v19);
  return v9;
}

void sub_100697E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t a11, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 40));
  _Unwind_Resume(a1);
}

uint64_t *sub_100697EE4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v63 = a1;
  uint64_t v64 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100058198((const void **)&theDict, (const void **)(v1 + 8));
  sub_100128950((uint64_t)v90, v1 + 16);
  if (theDict) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    uint64_t v72 = 0;
    CFDictionaryRef v73 = MutableCopy;
    v71[0] = 0;
    v71[1] = 0;
    CFDictionaryGetValue(MutableCopy, @"MCC");
    memset(buf, 0, sizeof(buf));
    *(void *)&v95[0] = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v71 = *(_OWORD *)buf;
    uint64_t v72 = *(void *)&v95[0];
    v69[0] = 0;
    v69[1] = 0;
    uint64_t v70 = 0;
    CFDictionaryGetValue(v73, @"MNC");
    memset(buf, 0, sizeof(buf));
    *(void *)&v95[0] = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v69 = *(_OWORD *)buf;
    uint64_t v70 = *(void *)&v95[0];
    xpc_object_t v5 = v71[1];
    if (v72 >= 0) {
      xpc_object_t v5 = (void *)HIBYTE(v72);
    }
    if (!v5) {
      goto LABEL_13;
    }
    xpc_object_t v6 = (void *)HIBYTE(v70);
    if (v70 < 0) {
      xpc_object_t v6 = v69[1];
    }
    if (!v6)
    {
LABEL_13:
      uint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Not valid MCC/MNC values", buf, 2u);
      }
      *(void *)buf = 0;
      if (!v91) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v91 + 48))(v91, buf);
      sub_1000558F4((const void **)buf);
      goto LABEL_174;
    }
    uint64_t v7 = v73;
    BOOL v8 = (const void *)qword_101B13EC0;
    sub_1002055B4((const void **)v71, (const void **)v69, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&valuePtr, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string valuePtr = __p;
    }
    __str.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(buf, valuePtr.__r_.__value_.__l.__data_, valuePtr.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)buf = *(_OWORD *)&valuePtr.__r_.__value_.__l.__data_;
      *(void *)&v95[0] = *((void *)&valuePtr.__r_.__value_.__l + 2);
    }
    object.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v11 = __str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = object.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = v11;
      sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    }
    if (SBYTE7(v95[0]) < 0) {
      operator delete(*(void **)buf);
    }
    value.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(valuePtr.__r_.__value_.__l.__data_);
    }
    CFDictionarySetValue(v7, v8, value.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&value.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v67 = 0;
    sub_10004EFE4(&cf, (CFTypeRef *)&v73);
    *(void *)v85 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      xpc_object_t v14 = *(__CFDictionary **)v85;
      *(void *)v85 = Mutable;
      *(void *)buf = v14;
      sub_10005717C((const void **)buf);
    }
    if (cf) {
      xpc_object_t v15 = sub_100080778;
    }
    else {
      xpc_object_t v15 = 0;
    }
    if (!v15)
    {
      sub_10004EFE4(&v67, (CFTypeRef *)v85);
      goto LABEL_149;
    }
    uint64_t v84 = 0;
    __dst.__r_.__value_.__r.__words[0] = 0;
    valuePtr.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&valuePtr, (const __CFString **)"", (const char *)0x8000100, kCFAllocatorDefault, v13))
    {
      std::string::size_type v16 = __dst.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = valuePtr.__r_.__value_.__r.__words[0];
      *(void *)buf = v16;
      sub_1000558F4((const void **)buf);
    }
    uint64_t v84 = __dst.__r_.__value_.__r.__words[0];
    __dst.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
    xpc_object_t v18 = ServiceMap;
    uint64_t v20 = v19;
    if (v19 < 0)
    {
      long long v21 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    *(void *)buf = v20;
    long long v24 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26) {
          goto LABEL_65;
        }
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_65;
    }
LABEL_51:
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v26 + 200))(&object, v26);
    if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&valuePtr, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
    }
    else {
      std::string valuePtr = object;
    }
    value.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(buf, valuePtr.__r_.__value_.__l.__data_, valuePtr.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)buf = *(_OWORD *)&valuePtr.__r_.__value_.__l.__data_;
      *(void *)&v95[0] = *((void *)&valuePtr.__r_.__value_.__l + 2);
    }
    __str.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v28 = value.__r_.__value_.__r.__words[0];
      value.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = v28;
      sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    }
    if (SBYTE7(v95[0]) < 0) {
      operator delete(*(void **)buf);
    }
    v74.__r_.__value_.__r.__words[0] = value.__r_.__value_.__r.__words[0];
    value.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&value.__r_.__value_.__l.__data_);
    if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(valuePtr.__r_.__value_.__l.__data_);
    }
    *(void *)buf = v84;
    uint64_t v84 = v74.__r_.__value_.__r.__words[0];
    v74.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v74.__r_.__value_.__l.__data_);
    if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(object.__r_.__value_.__l.__data_);
    }
LABEL_65:
    uint64_t v29 = (capabilities::ct *)sub_10010F3F0(*(__CFDictionary **)v85, @"DeviceName", v84);
    int v30 = capabilities::ct::supportsVoiceCall(v29);
    v31 = (uint64_t *)&kCFBooleanTrue;
    if (!v30) {
      v31 = (uint64_t *)&kCFBooleanFalse;
    }
    sub_10012C97C(*(__CFDictionary **)v85, @"SupportsVoiceCall", *v31);
    CFTypeRef v82 = 0;
    BOOL v32 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
    uint64_t v33 = v32;
    if (v19 < 0)
    {
      uint64_t v34 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v35 = 5381;
      do
      {
        uint64_t v19 = v35;
        unsigned int v36 = *v34++;
        uint64_t v35 = (33 * v35) ^ v36;
      }
      while (v36);
    }
    std::mutex::lock(v32);
    *(void *)buf = v19;
    uint64_t v37 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
    if (v37)
    {
      uint64_t v39 = v37[3];
      v38 = (std::__shared_weak_count *)v37[4];
      if (v38)
      {
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v33);
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v38);
        char v40 = 0;
LABEL_75:
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v39 + 112))(&v82, v39);
        if ((v40 & 1) == 0) {
          sub_10004D2C8(v38);
        }
        sub_10010F3F0(*(__CFDictionary **)v85, @"SWVersion", (uint64_t)v82);
        CFArrayRef theArray = 0;
        sub_10067FAAC(&theArray, v2);
        CFTypeRef v80 = 0;
        CFTypeRef v80 = CFArrayCreateMutableCopy(0, 0, theArray);
        long long v99 = 0u;
        long long v100 = 0u;
        long long v97 = 0u;
        long long v98 = 0u;
        long long v96 = 0u;
        *(_OWORD *)buf = 0u;
        memset(v95, 0, sizeof(v95));
        CFTypeRef v79 = cf;
        if (cf) {
          CFRetain(cf);
        }
        CarrierBundleHandler::lookupBundle_sync(v2, 1u, &v79, (uint64_t)buf);
        sub_100057D78(&v79);
        v78 = 0;
        CFMutableDictionaryRef v41 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)cf);
        CFMutableDictionaryRef v42 = v41;
        v78 = v41;
        uint64_t v43 = BYTE7(v95[0]);
        if (SBYTE7(v95[0]) < 0) {
          uint64_t v43 = *(void *)&buf[8];
        }
        if (v43)
        {
          unint64_t v44 = HIBYTE(v95[1]);
          char v45 = HIBYTE(v95[1]);
          if (v95[1] < 0) {
            unint64_t v44 = *(void *)&v95[1];
          }
          if (v44 >= 0xB)
          {
            if (BYTE8(v100) == 1)
            {
              CFDictionaryRemoveValue(v41, (const void *)qword_101B13ED0);
              char v45 = HIBYTE(v95[1]);
            }
            memset(&__str, 0, sizeof(__str));
            if (v45 < 0) {
              sub_10004FC84(&__str, *((void **)&v95[0] + 1), *(unint64_t *)&v95[1]);
            }
            else {
              std::string __str = *(std::string *)((char *)v95 + 8);
            }
            std::string::basic_string(&valuePtr, &__str, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            std::string __str = valuePtr;
            v46 = v78;
            if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&value, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
            }
            else {
              std::string value = __str;
            }
            if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__dst, value.__r_.__value_.__l.__data_, value.__r_.__value_.__l.__size_);
            }
            else {
              std::string __dst = value;
            }
            xpc_object_t v88 = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string valuePtr = __dst;
            }
            xpc_object_t v89 = 0;
            if (ctu::cf::convert_copy())
            {
              xpc_object_t v47 = v88;
              xpc_object_t v88 = v89;
              v74.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
              sub_1000558F4((const void **)&v74.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(valuePtr.__r_.__value_.__l.__data_);
            }
            xpc_object_t v86 = v88;
            xpc_object_t v88 = 0;
            sub_1000558F4((const void **)&v88);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            CFDictionarySetValue(v46, @"BundleIDOnTheDevice", v86);
            sub_1000558F4((const void **)&v86);
            if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(value.__r_.__value_.__l.__data_);
            }
            uint64_t v48 = v78;
            if (SBYTE7(v100) < 0)
            {
              sub_10004FC84(&v74, (void *)v99, *((unint64_t *)&v99 + 1));
            }
            else
            {
              *(_OWORD *)&v74.__r_.__value_.__l.__data_ = v99;
              v74.__r_.__value_.__r.__words[2] = v100;
            }
            if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__dst, v74.__r_.__value_.__l.__data_, v74.__r_.__value_.__l.__size_);
            }
            else {
              std::string __dst = v74;
            }
            xpc_object_t v86 = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string valuePtr = __dst;
            }
            xpc_object_t v88 = 0;
            if (ctu::cf::convert_copy())
            {
              xpc_object_t v49 = v86;
              xpc_object_t v86 = v88;
              xpc_object_t v89 = v49;
              sub_1000558F4((const void **)&v89);
            }
            if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(valuePtr.__r_.__value_.__l.__data_);
            }
            long long v75 = v86;
            xpc_object_t v86 = 0;
            sub_1000558F4((const void **)&v86);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            CFDictionarySetValue(v48, @"BundleVersionOnTheDevice", v75);
            sub_1000558F4((const void **)&v75);
            if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v74.__r_.__value_.__l.__data_);
            }
            v50 = v78;
            __dst.__r_.__value_.__r.__words[0] = 0;
            valuePtr.__r_.__value_.__r.__words[0] = 1;
            CFNumberRef v51 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
            if (v51)
            {
              std::string::size_type v52 = __dst.__r_.__value_.__r.__words[0];
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
              valuePtr.__r_.__value_.__r.__words[0] = v52;
              sub_1000570E8((const void **)&valuePtr.__r_.__value_.__l.__data_);
            }
            xpc_object_t v89 = (xpc_object_t)__dst.__r_.__value_.__r.__words[0];
            __dst.__r_.__value_.__r.__words[0] = 0;
            sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
            CFDictionarySetValue(v50, @"kUpdateBundleType", v89);
            sub_1000570E8((const void **)&v89);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            CFMutableDictionaryRef v42 = v78;
          }
        }
        sub_100699750((__CFArray *)v80, v42);
        if (v80) {
          uint64_t v53 = sub_100289354;
        }
        else {
          uint64_t v53 = 0;
        }
        if (v53) {
          sub_1001C6DC0(*(__CFDictionary **)v85, @"kBundleUpdateCheckCriteria", (uint64_t)v80);
        }
        sub_10004EFE4(&v67, (CFTypeRef *)v85);
        sub_10005717C((const void **)&v78);
        if (SBYTE7(v100) < 0) {
          operator delete((void *)v99);
        }
        if (SHIBYTE(v98) < 0) {
          operator delete(*((void **)&v97 + 1));
        }
        if (SBYTE7(v97) < 0) {
          operator delete((void *)v96);
        }
        if (SHIBYTE(v95[1]) < 0) {
          operator delete(*((void **)&v95[0] + 1));
        }
        if (SBYTE7(v95[0]) < 0) {
          operator delete(*(void **)buf);
        }
        sub_1000440D4(&v80);
        sub_100044D00((const void **)&theArray);
        sub_1000558F4(&v82);
        if ((v27 & 1) == 0) {
          sub_10004D2C8(v25);
        }
        sub_1000558F4((const void **)&v84);
LABEL_149:
        sub_10005717C((const void **)v85);
        sub_100057D78(&cf);
        if (v67) {
          unsigned int v54 = sub_100080778;
        }
        else {
          unsigned int v54 = 0;
        }
        if (!v54)
        {
          sub_10004EFE4(&valuePtr, (CFTypeRef *)&v73);
          sub_100682908((const void **)buf, v2, (const void **)&valuePtr.__r_.__value_.__l.__data_);
          if (!v91) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v91 + 48))(v91, buf);
          sub_1000558F4((const void **)buf);
          sub_100057D78((const void **)&valuePtr.__r_.__value_.__l.__data_);
          goto LABEL_173;
        }
        __dst.__r_.__value_.__r.__words[0] = 0;
        xpc_object_t v55 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v56 = v55;
        if (v55)
        {
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
        }
        else
        {
          xpc_object_t v56 = xpc_null_create();
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
          if (!v56)
          {
            xpc_object_t v57 = xpc_null_create();
            xpc_object_t v56 = 0;
            goto LABEL_162;
          }
        }
        if (xpc_get_type(v56) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v56);
LABEL_163:
          xpc_release(v56);
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_string_create(off_101B0AEF0[0]);
          if (!__str.__r_.__value_.__r.__words[0]) {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
          }
          *(void *)buf = &__dst;
          *(char **)&uint8_t buf[8] = off_101B0AEB0[0];
          sub_100035E70((uint64_t)buf, (xpc_object_t *)&__str.__r_.__value_.__l.__data_, (xpc_object_t *)&object.__r_.__value_.__l.__data_);
          xpc_release(object.__r_.__value_.__l.__data_);
          object.__r_.__value_.__r.__words[0] = 0;
          xpc_release(__str.__r_.__value_.__l.__data_);
          __str.__r_.__value_.__r.__words[0] = 0;
          v74.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_int64_create(5);
          if (!v74.__r_.__value_.__r.__words[0]) {
            v74.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
          }
          *(void *)buf = &__dst;
          *(char **)&uint8_t buf[8] = off_101B0B020[0];
          sub_100035E70((uint64_t)buf, (xpc_object_t *)&v74.__r_.__value_.__l.__data_, (xpc_object_t *)&value.__r_.__value_.__l.__data_);
          xpc_release(value.__r_.__value_.__l.__data_);
          value.__r_.__value_.__r.__words[0] = 0;
          xpc_release(v74.__r_.__value_.__l.__data_);
          v74.__r_.__value_.__r.__words[0] = 0;
          ctu::cf_to_xpc((uint64_t *)&v88, v67, v58);
          *(void *)buf = &__dst;
          *(char **)&uint8_t buf[8] = off_101B0AF40[0];
          sub_100035E70((uint64_t)buf, &v88, &v89);
          xpc_release(v89);
          xpc_object_t v89 = 0;
          xpc_release(v88);
          xpc_object_t v88 = 0;
          uint64_t v59 = *(void *)(v2 + 120);
          xpc_object_t v86 = (xpc_object_t)__dst.__r_.__value_.__r.__words[0];
          if (__dst.__r_.__value_.__r.__words[0]) {
            xpc_retain(__dst.__r_.__value_.__l.__data_);
          }
          else {
            xpc_object_t v86 = xpc_null_create();
          }
          *(void *)buf = v2;
          sub_100128950((uint64_t)&buf[8], (uint64_t)v90);
          *((void *)&v95[1] + 1) = v73;
          if (v73) {
            CFRetain(v73);
          }
          v93 = 0;
          v60 = operator new(0x38uLL);
          uint64_t v61 = *(void *)buf;
          void *v60 = off_1019F8460;
          v60[1] = v61;
          sub_1001288D0((uint64_t)(v60 + 2), (uint64_t)&buf[8]);
          v60[6] = *((void *)&v95[1] + 1);
          *((void *)&v95[1] + 1) = 0;
          v93 = v60;
          (*(void (**)(uint64_t, xpc_object_t *, std::string *))(*(void *)v59 + 24))(v59, &v86, &valuePtr);
          sub_1001472DC(&valuePtr);
          sub_10005717C((const void **)&v95[1] + 1);
          sub_1001289E8(&buf[8]);
          xpc_release(v86);
          xpc_object_t v86 = 0;
          xpc_release(__dst.__r_.__value_.__l.__data_);
LABEL_173:
          sub_100057D78((const void **)&v67);
LABEL_174:
          if (SHIBYTE(v70) < 0) {
            operator delete(v69[0]);
          }
          if (SHIBYTE(v72) < 0) {
            operator delete(v71[0]);
          }
          sub_10005717C((const void **)&v73);
          goto LABEL_179;
        }
        xpc_object_t v57 = xpc_null_create();
LABEL_162:
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
        goto LABEL_163;
      }
    }
    else
    {
      uint64_t v39 = 0;
    }
    std::mutex::unlock(v33);
    v38 = 0;
    char v40 = 1;
    goto LABEL_75;
  }
  int v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "match info is empty. Not processing this request.", buf, 2u);
  }
  *(void *)buf = 0;
  if (!v91) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v91 + 48))(v91, buf);
  sub_1000558F4((const void **)buf);
LABEL_179:
  sub_1001289E8(v90);
  sub_100057D78((const void **)&theDict);
  sub_100699248(&v64);
  return sub_100046B58((uint64_t *)&v63);
}

void sub_100698E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,const void *a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,const void *a48,uint64_t a49,const void *a50,const void *a51,const void *a52,void *a53,uint64_t a54,uint64_t a55,const void *a56,const void *a57,xpc_object_t object,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  sub_1000558F4((const void **)&object);
  if (a64 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  sub_10005717C(&a48);
  sub_10039A890(v70 - 224);
  sub_1000440D4(&a50);
  sub_100044D00(&a51);
  sub_1000558F4(&a52);
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v68);
  }
  sub_1000558F4(&a56);
  sub_10005717C(&a57);
  sub_100057D78(&a12);
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10005717C(&a30);
  sub_1001289E8(&a68);
  sub_100057D78(&a11);
  sub_100699248(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1006991D0()
{
}

void sub_1006991D8()
{
}

void sub_1006991E0()
{
  if (*(char *)(v0 - 201) < 0) {
    JUMPOUT(0x10069918CLL);
  }
  JUMPOUT(0x100699190);
}

void sub_1006991F4()
{
}

void sub_1006991FC()
{
  if (*(char *)(v0 - 201) < 0) {
    JUMPOUT(0x10069919CLL);
  }
  JUMPOUT(0x1006991A0);
}

void sub_100699210()
{
}

void sub_100699218()
{
}

void sub_100699220()
{
  sub_1000558F4((const void **)(v0 - 224));
  JUMPOUT(0x1006991A8);
}

void sub_100699230()
{
  sub_1000558F4((const void **)(v0 - 224));
  JUMPOUT(0x100699180);
}

void sub_100699240()
{
}

uint64_t *sub_100699248(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1001289E8((void *)(v1 + 16));
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1006992A0(uint64_t a1)
{
  *(void *)a1 = off_1019F8460;
  sub_10005717C((const void **)(a1 + 48));
  sub_1001289E8((void *)(a1 + 16));
  return a1;
}

void sub_1006992EC(uint64_t a1)
{
  *(void *)a1 = off_1019F8460;
  sub_10005717C((const void **)(a1 + 48));
  sub_1001289E8((void *)(a1 + 16));

  operator delete();
}

void *sub_100699358(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v2 = off_1019F8460;
  *((void *)v2 + 1) = v3;
  sub_100128950((uint64_t)v2 + 16, a1 + 16);
  sub_100057240((const void **)v2 + 6, (const void **)(a1 + 48));
  return v2;
}

void sub_1006993BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

const void **sub_1006993D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = off_1019F8460;
  *(void *)(a2 + 8) = v4;
  sub_100128950(a2 + 16, a1 + 16);

  return sub_100057240((const void **)(a2 + 48), (const void **)(a1 + 48));
}

void *sub_100699438(uint64_t a1)
{
  sub_10005717C((const void **)(a1 + 48));

  return sub_1001289E8((void *)(a1 + 16));
}

void sub_100699474(uint64_t a1)
{
  sub_10005717C((const void **)(a1 + 48));
  sub_1001289E8((void *)(a1 + 16));

  operator delete((void *)a1);
}

void sub_1006994B8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v11 = *a2;
  *a2 = xpc_null_create();
  uint64_t v3 = *(void *)(a1 + 8);
  v14[0] = &v11;
  v14[1] = off_101B0AF60[0];
  sub_100048BAC((uint64_t)v14, &object);
  int v5 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
  xpc_release(object);
  if (v5)
  {
    sub_1006888D0(*(void **)(v3 + 168));
    *(void *)(v3 + 160) = v3 + 168;
    *(void *)(v3 + 168) = 0;
    *(void *)(v3 + 176) = 0;
    xpc_object_t v6 = off_101B0AEB0[0];
    uint64_t v7 = off_101B0AEE0[0];
    sub_1006941A8(v14);
    sub_1006940C4(v7, v14, (uint64_t)v6, &object);
    xpc_release(v14[0]);
    xpc_object_t v8 = object;
    xpc_object_t object = xpc_null_create();
    xpc_release(object);
    uint64_t v9 = *(void *)(v3 + 120);
    xpc_object_t object = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v9 + 16))(v14, v9, &object);
    xpc_release(v14[0]);
    v14[0] = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v8);
  }
  sub_10004EFE4(&v12, (CFTypeRef *)(a1 + 48));
  sub_100682908(&v13, v3, &v12);
  uint64_t v10 = *(void *)(a1 + 40);
  if (!v10) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v10 + 48))(v10, &v13);
  sub_1000558F4(&v13);
  sub_100057D78(&v12);
  xpc_release(v11);
}

void sub_100699678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v17);
  xpc_release(a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100699704(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100699744()
{
}

BOOL sub_100699750(__CFArray *a1, CFTypeRef cf)
{
  int v5 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFArrayAppendValue(a1, cf);
  }
  sub_10010F494(&v5);
  return cf != 0;
}

void sub_1006997AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010F494((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006997C0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_100699824(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  xpc_object_t v6 = a1[1];
  xpc_object_t v8 = a1 + 1;
  uint64_t v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        xpc_object_t v6 = *v9;
        xpc_object_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      xpc_object_t v6 = v9[1];
      if (!v6)
      {
        xpc_object_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    xpc_object_t v14[2] = 1;
    uint64_t v12 = operator new(0x60uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((void *)v12 + 5) = 255;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_10008B0C4((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

uint64_t sub_100699924(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t *sub_100699988(uint64_t **a1)
{
  uint64_t v1 = *a1;
  CFMutableDictionaryRef v42 = a1;
  uint64_t v43 = v1;
  v38 = v1;
  uint64_t v2 = *v1;
  unint64_t v44 = 0;
  CFTypeRef cf = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFTypeRef v4 = cf;
    CFTypeRef cf = Mutable;
    *(void *)buf = v4;
    sub_1000440D4((const void **)buf);
  }
  uint64_t v48 = v2;
  CFMutableArrayRef theArray = (CFMutableArrayRef)cf;
  if (cf) {
    CFRetain(cf);
  }
  subscriber::makeSimSlotRange();
  int v5 = v45;
  if (v45 != v46)
  {
    while ((v47(*v5) & 1) == 0)
    {
      if (++v5 == v46)
      {
        int v5 = v46;
        break;
      }
    }
    if (v5 != v46)
    {
      key = (void *)qword_101B13ED0;
      CFMutableDictionaryRef v41 = (void *)kCTPostponementInfoGID1;
      char v40 = (void *)kCTPostponementInfoGID2;
      do
      {
        uint64_t v6 = *v5;
        uint64_t v7 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v48 + 48) + 16))(*(void *)(v48 + 48), v6);
        *(void *)&long long __p = (v6 << 32) | 1;
        *(void *)buf = &__p;
        if (*((void *)sub_100688D4C((uint64_t **)(v48 + 136), (unsigned __int8 *)&__p, (uint64_t)&unk_10144E20E, (void **)buf)+ 30))xpc_object_t v8 = sub_100080778; {
        else
        }
          xpc_object_t v8 = 0;
        if (!v8)
        {
          std::string::size_type v16 = *v7;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = asString();
            *(_DWORD *)buf = 136315138;
            *(void *)&buf[4] = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No matching info for %s", buf, 0xCu);
          }
          goto LABEL_94;
        }
        long long v71 = 0u;
        long long v72 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v68 = 0u;
        memset(buf, 0, sizeof(buf));
        *(void *)&long long object = (v6 << 32) | 1;
        *(void *)&long long __p = &object;
        uint64_t v9 = sub_100688D4C((uint64_t **)(v48 + 136), (unsigned __int8 *)&object, (uint64_t)&unk_10144E20E, (void **)&__p);
        sub_100058198(&v59, (const void **)v9 + 30);
        CarrierBundleHandler::lookupBundle_sync(v48, 1u, &v59, (uint64_t)buf);
        sub_100057D78(&v59);
        CFMutableDictionaryRef theDict = 0;
        *(void *)&long long object = (v6 << 32) | 1;
        *(void *)&long long __p = &object;
        int v10 = sub_100688D4C((uint64_t **)(v48 + 136), (unsigned __int8 *)&object, (uint64_t)&unk_10144E20E, (void **)&__p);
        CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *((CFDictionaryRef *)v10 + 30));
        CFMutableDictionaryRef theDict = MutableCopy;
        uint64_t v12 = (const __CFString **)subscriber::asString();
        *(void *)&long long __dst = 0;
        *(void *)&long long object = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&object, v12, (const char *)0x8000100, kCFAllocatorDefault, v13))
        {
          uint64_t v14 = __dst;
          *(void *)&long long __dst = object;
          *(void *)&long long __p = v14;
          sub_1000558F4((const void **)&__p);
        }
        value[0] = (void *)__dst;
        *(void *)&long long __dst = 0;
        sub_1000558F4((const void **)&__dst);
        CFDictionarySetValue(MutableCopy, @"Slot", value[0]);
        sub_1000558F4((const void **)value);
        uint64_t v15 = buf[23];
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v15 = *(void *)&buf[8];
        }
        if (v15)
        {
          if (BYTE8(v72) == 1) {
            CFDictionaryRemoveValue(theDict, key);
          }
          long long __dst = 0uLL;
          uint64_t v57 = 0;
          if ((char)buf[47] < 0)
          {
            sub_10004FC84(&__dst, *(void **)&buf[24], *(unint64_t *)&buf[32]);
          }
          else
          {
            long long __dst = *(_OWORD *)&buf[24];
            uint64_t v57 = *(void *)&buf[40];
          }
          xpc_object_t v18 = theDict;
          if (SHIBYTE(v57) < 0)
          {
            sub_10004FC84(value, (void *)__dst, *((unint64_t *)&__dst + 1));
          }
          else
          {
            *(_OWORD *)std::string value = __dst;
            uint64_t v55 = v57;
          }
          if (SHIBYTE(v55) < 0)
          {
            sub_10004FC84(&object, value[0], (unint64_t)value[1]);
          }
          else
          {
            long long object = *(_OWORD *)value;
            uint64_t v62 = v55;
          }
          v65 = 0;
          if (SHIBYTE(v62) < 0)
          {
            sub_10004FC84(&__p, (void *)object, *((unint64_t *)&object + 1));
          }
          else
          {
            long long __p = object;
            uint64_t v64 = v62;
          }
          v66 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v19 = v65;
            v65 = v66;
            v51[0] = v19;
            sub_1000558F4((const void **)v51);
          }
          if (SHIBYTE(v64) < 0) {
            operator delete((void *)__p);
          }
          v60 = v65;
          v65 = 0;
          sub_1000558F4((const void **)&v65);
          if (SHIBYTE(v62) < 0) {
            operator delete((void *)object);
          }
          CFDictionarySetValue(v18, kCFBundleIdentifierKey, v60);
          sub_1000558F4((const void **)&v60);
          if (SHIBYTE(v55) < 0) {
            operator delete(value[0]);
          }
          uint64_t v20 = theDict;
          if (SBYTE7(v72) < 0)
          {
            sub_10004FC84(v51, (void *)v71, *((unint64_t *)&v71 + 1));
          }
          else
          {
            *(_OWORD *)CFNumberRef v51 = v71;
            uint64_t v52 = v72;
          }
          if (SHIBYTE(v52) < 0)
          {
            sub_10004FC84(&object, v51[0], (unint64_t)v51[1]);
          }
          else
          {
            long long object = *(_OWORD *)v51;
            uint64_t v62 = v52;
          }
          v60 = 0;
          if (SHIBYTE(v62) < 0)
          {
            sub_10004FC84(&__p, (void *)object, *((unint64_t *)&object + 1));
          }
          else
          {
            long long __p = object;
            uint64_t v64 = v62;
          }
          v65 = 0;
          if (ctu::cf::convert_copy())
          {
            long long v21 = v60;
            v60 = v65;
            v66 = v21;
            sub_1000558F4((const void **)&v66);
          }
          if (SHIBYTE(v64) < 0) {
            operator delete((void *)__p);
          }
          uint64_t v53 = v60;
          v60 = 0;
          sub_1000558F4((const void **)&v60);
          if (SHIBYTE(v62) < 0) {
            operator delete((void *)object);
          }
          CFDictionarySetValue(v20, kCFBundleVersionKey, v53);
          sub_1000558F4((const void **)&v53);
          if (SHIBYTE(v52) < 0) {
            operator delete(v51[0]);
          }
          if (SHIBYTE(v57) < 0) {
            operator delete((void *)__dst);
          }
        }
        else
        {
          CFDictionarySetValue(theDict, kCFBundleIdentifierKey, @"com.apple.Unknown");
          CFDictionarySetValue(theDict, kCFBundleVersionKey, @"0.0");
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v48 + 104));
        unsigned int v23 = ServiceMap;
        if (v24 < 0)
        {
          uint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v26 = 5381;
          do
          {
            uint64_t v24 = v26;
            unsigned int v27 = *v25++;
            uint64_t v26 = (33 * v26) ^ v27;
          }
          while (v27);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long __p = v24;
        std::string::size_type v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&__p);
        if (v28)
        {
          uint64_t v30 = v28[3];
          uint64_t v29 = (std::__shared_weak_count *)v28[4];
          if (v29)
          {
            atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v23);
            atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v29);
            char v31 = 0;
            if (v30) {
              goto LABEL_74;
            }
            goto LABEL_70;
          }
        }
        else
        {
          uint64_t v30 = 0;
        }
        std::mutex::unlock(v23);
        uint64_t v29 = 0;
        char v31 = 1;
        if (v30)
        {
LABEL_74:
          long long __p = 0uLL;
          uint64_t v64 = 0;
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v30 + 176))(&__p, v30, v6, 1);
          long long object = 0uLL;
          uint64_t v62 = 0;
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v30 + 176))(&object, v30, v6, 2);
          if ((void)__p != *((void *)&__p + 1))
          {
            *(void *)&long long __dst = 0;
            *(void *)&long long __dst = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)__p, *((void *)&__p + 1) - __p);
            CFDictionarySetValue(theDict, v41, (const void *)__dst);
            sub_100030068((const void **)&__dst);
          }
          uint64_t v33 = (void *)object;
          if ((void)object != *((void *)&object + 1))
          {
            *(void *)&long long __dst = 0;
            *(void *)&long long __dst = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)object, *((void *)&object + 1) - object);
            CFDictionarySetValue(theDict, v40, (const void *)__dst);
            sub_100030068((const void **)&__dst);
            uint64_t v33 = (void *)object;
          }
          if (v33)
          {
            *((void *)&object + 1) = v33;
            operator delete(v33);
          }
          if ((void)__p)
          {
            *((void *)&__p + 1) = __p;
            operator delete((void *)__p);
          }
          goto LABEL_82;
        }
LABEL_70:
        BOOL v32 = *v7;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Subscriber sim controller not found. Could not retrieve SIMGID1 and SIMGID2.", (uint8_t *)&__p, 2u);
        }
LABEL_82:
        if ((v31 & 1) == 0) {
          sub_10004D2C8(v29);
        }
        CFArrayAppendValue(theArray, theDict);
        sub_10005717C((const void **)&theDict);
        if (SBYTE7(v72) < 0) {
          operator delete((void *)v71);
        }
        if (SHIBYTE(v70) < 0) {
          operator delete(*((void **)&v69 + 1));
        }
        if (SBYTE7(v69) < 0) {
          operator delete((void *)v68);
        }
        if ((char)buf[47] < 0) {
          operator delete(*(void **)&buf[24]);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
LABEL_94:
        uint64_t v34 = v5 + 1;
        int v5 = v46;
        if (v34 != v46)
        {
          int v5 = v34;
          while ((v47(*v5) & 1) == 0)
          {
            if (++v5 == v46)
            {
              int v5 = v46;
              break;
            }
          }
        }
      }
      while (v5 != v46);
    }
  }
  sub_100044D6C(&v44, &cf);
  sub_1000440D4((const void **)&theArray);
  sub_1000440D4(&cf);
  if (v44) {
    unsigned int v36 = sub_100083F10;
  }
  else {
    unsigned int v36 = 0;
  }
  if (v36)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v44, v35);
    *(void *)buf = v38[1];
    *(void *)&uint8_t buf[8] = "kCarrierSettingsBundleInfo";
    sub_100035E70((uint64_t)buf, (xpc_object_t *)&object, (xpc_object_t *)&__p);
    xpc_release((xpc_object_t)__p);
    *(void *)&long long __p = 0;
    xpc_release((xpc_object_t)object);
    *(void *)&long long object = 0;
  }
  sub_100044D00((const void **)&v44);
  sub_1000E1A60((uint64_t *)&v43);
  return sub_100046B58((uint64_t *)&v42);
}

void sub_10069A324(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_10069A520(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v36 = a1;
  uint64_t v37 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    sub_10004EFE4(buf, (CFTypeRef *)&theDict);
    if (v13) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_13:
  std::string value = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(buf, v12, v3, 1, @"CarrierBookmarks", 0, 0);
  sub_100044D6C(&value, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (value) {
    std::string::size_type v16 = sub_100083F10;
  }
  else {
    std::string::size_type v16 = 0;
  }
  if (v16) {
    CFDictionarySetValue(theDict, @"CarrierBookmarks", value);
  }
  uint64_t v43 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(buf, v12, v3, 1, @"MyAccountURL", 0, 0);
  sub_100056248(&v43, (CFTypeRef *)buf);
  uint64_t v17 = sub_1000577C4((const void **)buf);
  if (v43) {
    xpc_object_t v18 = sub_1000810B8;
  }
  else {
    xpc_object_t v18 = 0;
  }
  if (!v18)
  {
    sub_10004EFE4(v17, (CFTypeRef *)&theDict);
    goto LABEL_64;
  }
  CFMutableDictionaryRef v42 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(buf, v12, v3, 1, @"MyAccountURLTitle", 0, 0);
  sub_100056248(&v42, (CFTypeRef *)buf);
  uint64_t v19 = sub_1000577C4((const void **)buf);
  if (v42) {
    uint64_t v20 = sub_1000810B8;
  }
  else {
    uint64_t v20 = 0;
  }
  if (v20)
  {
    CFStringRef theString2 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@_MYACCOUNTURLTITLE", v42);
    if (theString2) {
      long long v21 = sub_1000810B8;
    }
    else {
      long long v21 = 0;
    }
    if (!v21)
    {
      sub_10004EFE4(buf, (CFTypeRef *)&theDict);
LABEL_62:
      sub_1000558F4((const void **)&theString2);
      goto LABEL_63;
    }
    char v40 = 0;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v2 + 128))(v38, v2, v3);
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(__p, v38[0], (unint64_t)v38[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v38;
      uint64_t v48 = v39;
    }
    v46 = 0;
    if (SHIBYTE(v48) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)buf = *(_OWORD *)__p;
      uint64_t v52 = v48;
    }
    xpc_object_t v49 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v22 = v46;
      v46 = v49;
      v50 = v22;
      sub_1000558F4(&v50);
    }
    if (SHIBYTE(v52) < 0) {
      operator delete(*(void **)buf);
    }
    char v40 = v46;
    v46 = 0;
    sub_1000558F4(&v46);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[0]);
    }
    __p[0] = 0;
    unsigned int v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
    uint64_t v24 = v23;
    if (v25 < 0)
    {
      uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v27 = 5381;
      do
      {
        uint64_t v25 = v27;
        unsigned int v28 = *v26++;
        uint64_t v27 = (33 * v27) ^ v28;
      }
      while (v28);
    }
    std::mutex::lock(v23);
    *(void *)buf = v25;
    uint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
    if (v29)
    {
      uint64_t v31 = v29[3];
      uint64_t v30 = (std::__shared_weak_count *)v29[4];
      if (v30)
      {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v24);
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v30);
        char v32 = 0;
LABEL_55:
        (*(void (**)(void **__return_ptr, uint64_t, const void *, void, CFStringRef, uint64_t))(*(void *)v31 + 24))(__p, v31, v40, kCarrierBundleCarriersLocalizationTable, theString2, 1);
        if ((v32 & 1) == 0) {
          sub_10004D2C8(v30);
        }
        CFComparisonResult v33 = CFStringCompare((CFStringRef)__p[0], theString2, 0);
        uint64_t v34 = (const void **)__p;
        if (v33 == kCFCompareEqualTo) {
          uint64_t v34 = &v42;
        }
        CFDictionarySetValue(theDict, @"MyAccountURLTitle_Localized", *v34);
        CFDictionarySetValue(theDict, @"MyAccountURL", v43);
        uint64_t v35 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)&buf[4] = theDict;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Bookmarks dictionary: %{public}@", buf, 0xCu);
        }
        sub_10004EFE4(buf, (CFTypeRef *)&theDict);
        sub_1000558F4((const void **)__p);
        sub_1000558F4(&v40);
        goto LABEL_62;
      }
    }
    else
    {
      uint64_t v31 = 0;
    }
    std::mutex::unlock(v24);
    uint64_t v30 = 0;
    char v32 = 1;
    goto LABEL_55;
  }
  sub_10004EFE4(v19, (CFTypeRef *)&theDict);
LABEL_63:
  sub_1000558F4(&v42);
LABEL_64:
  sub_1000558F4((const void **)&v43);
  sub_100044D00((const void **)&value);
  if ((v13 & 1) == 0) {
LABEL_8:
  }
    sub_10004D2C8(v11);
LABEL_9:
  sub_10005717C((const void **)&theDict);
  uint64_t v14 = *(void *)(v1 + 40);
  if (!v14) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v14 + 48))(v14, buf);
  sub_100057D78((const void **)buf);
  sub_10069ACF4(&v37);
  return sub_100046B58((uint64_t *)&v36);
}

void sub_10069AB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, int a20,const void *a21,const void *a22,const void *a23,const void *a24,const void *a25,const void *a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1000558F4(&a26);
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a18 < 0) {
    operator delete(a13);
  }
  sub_1000558F4(&a21);
  sub_1000558F4(&a22);
  sub_1000558F4(&a23);
  sub_100044D00(&a24);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  sub_10005717C(&a25);
  sub_10069ACF4(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_10069ACF4(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10010E020((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_10069AD44(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFTypeRef v4 = a1;
  uint64_t v5 = v1;
  sub_100681FDC((uint64_t)__p, *(void *)v1, *(unsigned char *)(v1 + 12), *(_DWORD *)(v1 + 8));
  uint64_t v2 = *(void *)(v1 + 40);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 48))(v2, __p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_10069AE10(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10069ADDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

uint64_t *sub_10069AE10(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10001E914((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_10069AE60(uint64_t a1, const void **a2)
{
  if (a2)
  {
    sub_10069AE60(a1, *a2);
    sub_10069AE60(a1, a2[1]);
    sub_100057D78(a2 + 33);
    sub_100057D78(a2 + 32);
    sub_10000BDF8((uint64_t)(a2 + 5));
    operator delete(a2);
  }
}

void sub_10069AED0(uint64_t a1, const void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    sub_100057D78(__p + 33);
    sub_100057D78(__p + 32);
    sub_10000BDF8((uint64_t)(__p + 5));
  }
  if (__p)
  {
    operator delete(__p);
  }
}

uint64_t *sub_10069AF38(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10069AF90(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10069AF78(_Unwind_Exception *a1)
{
  sub_10069AE60(v1, *(const void ***)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10069AF90(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    CFTypeRef v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_10069B01C(v5, v6, v4 + 8, v4 + 8);
      char v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          char v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          CFTypeRef v4 = v8;
        }
        while (!v9);
      }
      CFTypeRef v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10069B01C(uint64_t **a1, uint64_t *a2, int *a3, _DWORD *a4)
{
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v6 = (uint64_t **)sub_1000262C0(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10069B0AC((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

uint64_t sub_10069B0AC@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  char v7 = operator new(0x110uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  unsigned char v7[8] = *a2;
  uint64_t result = sub_10069B144((uint64_t)(v7 + 10), (uint64_t)(a2 + 2));
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10069B128(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_10069AED0(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_10069B144(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10000BE9C(a1, a2);
  *(unsigned char *)(v4 + 200) = *(unsigned char *)(a2 + 200);
  *(unsigned char *)(v4 + 208) = *(unsigned char *)(a2 + 208);
  sub_100058198((const void **)(v4 + 216), (const void **)(a2 + 216));
  sub_100058198((const void **)(a1 + 224), (const void **)(a2 + 224));
  return a1;
}

const void **sub_10069B198@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  sub_100058198(&v6, *(const void ***)(v3 + 8));
  sub_100682C2C(a2, v4, 1u, &v6);
  return sub_100057D78(&v6);
}

void sub_10069B1EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10069B200(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v2);
  sub_10069B2AC(*(void *)(a1 + 32), (long long *)v2);
  if (v13 < 0) {
    operator delete(__p);
  }
  if (v11 < 0) {
    operator delete(v10);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
  if (v3 < 0) {
    operator delete(v2[0]);
  }
}

__n128 sub_10069B2AC(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  char v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)char v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  char v7 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*v7);
  }
  long long v8 = a2[3];
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(_OWORD *)char v7 = v8;
  *((unsigned char *)a2 + 71) = 0;
  *((unsigned char *)a2 + 48) = 0;
  char v9 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*v9);
  }
  long long v10 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)char v9 = v10;
  *((unsigned char *)a2 + 95) = 0;
  *((unsigned char *)a2 + 72) = 0;
  char v11 = (void **)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*v11);
  }
  long long v12 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(_OWORD *)char v11 = v12;
  *((unsigned char *)a2 + 119) = 0;
  *((unsigned char *)a2 + 96) = 0;
  *(unsigned char *)(a1 + 120) = *((unsigned char *)a2 + 120);
  char v13 = (void **)(a1 + 128);
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*v13);
  }
  __n128 result = (__n128)a2[8];
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(__n128 *)char v13 = result;
  *((unsigned char *)a2 + 151) = 0;
  *((unsigned char *)a2 + 128) = 0;
  return result;
}

void sub_10069B3F0(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v2);
  sub_10069B2AC(*(void *)(a1 + 32), (long long *)v2);
  if (v13 < 0) {
    operator delete(__p);
  }
  if (v11 < 0) {
    operator delete(v10);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
  if (v3 < 0) {
    operator delete(v2[0]);
  }
}

const void **sub_10069B49C@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  sub_100058198(&v6, *(const void ***)(v3 + 8));
  sub_100682C2C(a2, v4, 5u, &v6);
  return sub_100057D78(&v6);
}

void sub_10069B4F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10069B504@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  sub_100058198(&cf, *(const void ***)(v3 + 8));
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  *(_OWORD *)std::string::size_type v16 = 0u;
  *(_OWORD *)char v13 = 0u;
  *(_OWORD *)uint64_t v14 = 0u;
  CFTypeRef v12 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100027ECC((uint64_t)v13, v4, 5u, &v12);
  sub_100057D78(&v12);
  char v5 = (void *)HIBYTE(v14[0]);
  if (SHIBYTE(v14[0]) < 0) {
    char v5 = v13[1];
  }
  if (v5)
  {
    if (SHIBYTE(v17[0]) < 0)
    {
      sub_10004FC84(__p, v16[0], (unint64_t)v16[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v16;
      char v11 = v17[0];
    }
    if (SHIBYTE(v11) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      unsigned int v23 = v11;
    }
    long long v21 = 0;
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long buf = __dst;
      uint64_t v27 = v23;
    }
    uint64_t v24 = 0;
    if (ctu::cf::convert_copy())
    {
      char v7 = v21;
      long long v21 = v24;
      uint64_t v25 = v7;
      sub_1000558F4(&v25);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)buf);
    }
    *a2 = v21;
    long long v21 = 0;
    sub_1000558F4(&v21);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = cf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N No matched bundle found for provided matching info: %@", (uint8_t *)&buf, 0xCu);
    }
    *a2 = 0;
  }
  if (SBYTE7(v20) < 0) {
    operator delete((void *)v19);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  if (SHIBYTE(v17[0]) < 0) {
    operator delete(v16[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[1]);
  }
  if (SHIBYTE(v14[0]) < 0) {
    operator delete(v13[0]);
  }
  return sub_100057D78(&cf);
}

void sub_10069B77C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1000558F4((const void **)(v21 - 120));
  if (*(char *)(v21 - 89) < 0) {
    operator delete(*(void **)(v21 - 112));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10039A890((uint64_t)&a19);
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

const void **sub_10069B808@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_100083DA4((const void **)&theString1, *(const void ***)(*(void *)(a1 + 40) + 8));
  LOBYTE(v11[1]) = 0;
  v11[0] = 0;
  if (CFStringCompare(theString1, @"USA", 1uLL) && CFStringCompare(theString1, @"GUM", 1uLL))
  {
    if (CFStringCompare(theString1, @"CAN", 1uLL))
    {
      if (CFStringCompare(theString1, @"PRI", 1uLL))
      {
        *a2 = 0;
        return sub_1000558F4((const void **)&theString1);
      }
      char v7 = 0;
      char v6 = 0;
      qmemcpy(v11, "ico", 3);
      uint64_t v3 = 0x6F74726575502E65;
      char v4 = 82;
      char v5 = 20;
    }
    else
    {
      char v7 = 0;
      char v6 = 0;
      char v4 = 0;
      uint64_t v3 = 0x6164616E61432E65;
      char v5 = 16;
    }
  }
  else
  {
    uint64_t v3 = 0x646574696E552E65;
    qmemcpy(v11, "tat", 3);
    char v4 = 83;
    char v5 = 22;
    char v6 = 115;
    char v7 = 101;
  }
  __int16 v16 = v11[0];
  char v17 = v11[1];
  CFTypeRef v12 = 0;
  long long __p = (void *)0x6C7070612E6D6F63;
  uint64_t v14 = v3;
  char v15 = v4;
  char v18 = v7;
  char v19 = v6;
  char v20 = 0;
  char v21 = v5;
  uint64_t v22 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v8 = v12;
    CFTypeRef v12 = v22;
    unsigned int v23 = v8;
    sub_1000558F4(&v23);
  }
  if (v21 < 0) {
    operator delete(__p);
  }
  *a2 = v12;
  CFTypeRef v12 = 0;
  sub_1000558F4(&v12);
  return sub_1000558F4((const void **)&theString1);
}

void sub_10069B9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a11);
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10069BA14(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v6 = a1;
  uint64_t v7 = v1;
  unsigned __int8 v2 = *(unsigned char *)(v1 + 12);
  if (((v2 - 3) & 0xFE) != 0) {
    int v3 = *(_DWORD *)(v1 + 8);
  }
  else {
    int v3 = 1;
  }
  sub_10000A774((uint64_t)__p, *(void *)v1, v2, v3);
  uint64_t v4 = *(void *)(v1 + 40);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v4 + 48))(v4, __p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_10069AE10(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10069BAB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

const void **sub_10069BAEC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = **(void **)(a1 + 40);
  uint64_t v59 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    char v5 = v59;
    uint64_t v59 = Mutable;
    *(void *)&v52[0] = v5;
    sub_1000440D4((const void **)v52);
  }
  v58 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(v3 + 88) + 152))(&v58);
  char v6 = v58;
  if (v58) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  long long v8 = (os_log_t *)(v3 + 40);
  if (!v7)
  {
    unsigned int v36 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v52[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Invalid versionxmlDict.", (uint8_t *)v52, 2u);
    }
    goto LABEL_63;
  }
  long long v10 = *(std::__shared_weak_count **)(v3 + 112);
  char v9 = (uint64_t *)(v3 + 104);
  v57[0] = *(void *)(v3 + 104);
  v57[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v56 = v6;
  if (v6) {
    CFRetain(v6);
  }
  char v11 = sub_1006CE8D4((os_log_t *)(v3 + 40), (uint64_t)v57, (uint64_t *)&v56);
  sub_100057D78(&v56);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if ((v11 & 1) == 0)
  {
    uint64_t v37 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v52[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Versionxml failed verification.", (uint8_t *)v52, 2u);
    }
LABEL_63:
    sub_100044D6C(a2, (CFTypeRef *)&v59);
    goto LABEL_68;
  }
  CFDictionaryRef v55 = 0;
  sub_10067E4A4(&v55, v3);
  Value = (BOOL *)CFDictionaryGetValue(v55, @"SupportsVoiceCall");
  char v13 = Value;
  LOBYTE(v52[0]) = 0;
  if (Value)
  {
    CFTypeID v14 = CFGetTypeID(Value);
    if (v14 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)v52, v13, v15);
    }
  }
  int v16 = LOBYTE(v52[0]);
  unsigned int v54 = 0;
  *(void *)&v52[0] = CFDictionaryGetValue(v55, @"DeviceName");
  sub_100056248(&v54, (CFTypeRef *)v52);
  CFArrayRef v17 = (const __CFArray *)CFDictionaryGetValue(v55, @"kBundleUpdateCheckCriteria");
  CFArrayRef v18 = v17;
  if (v17 && (CFTypeID v19 = CFGetTypeID(v17), v19 == CFArrayGetTypeID()))
  {
    uint64_t v53 = 0;
    memset(v52, 0, sizeof(v52));
    CFNumberRef v51 = v58;
    if (v58) {
      CFRetain(v58);
    }
    v50 = v54;
    if (v54) {
      CFRetain(v54);
    }
    sub_1004963D0((uint64_t *)v52, (uint64_t)v8, v9, &v51, v16 != 0, &v50);
    sub_1000558F4(&v50);
    sub_100057D78(&v51);
    memset(v49, 0, sizeof(v49));
    uint64_t v48 = v58;
    if (v58) {
      CFRetain(v58);
    }
    xpc_object_t v47 = v54;
    if (v54) {
      CFRetain(v54);
    }
    CFMutableDictionaryRef v41 = v8;
    sub_100810FD0((uint64_t)v49, v9, &v48, &v47);
    char v40 = a2;
    sub_1000558F4(&v47);
    sub_100057D78(&v48);
    CFIndex Count = CFArrayGetCount(v18);
    if (Count >= 1)
    {
      CFIndex v21 = 0;
      uint64_t v22 = (const void *)qword_101B13EC0;
      while (1)
      {
        CFDictionaryRef theDict = 0;
        *(void *)long long buf = CFArrayGetValueAtIndex(v18, v21);
        sub_10004EFE4(&theDict, (CFTypeRef *)buf);
        unsigned int v23 = (int *)CFDictionaryGetValue(theDict, @"kUpdateBundleType");
        uint64_t v24 = v23;
        *(_DWORD *)long long buf = 0;
        if (v23)
        {
          CFTypeID v25 = CFGetTypeID(v23);
          if (v25 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)buf, v24, v26);
          }
        }
        int v27 = buf[0];
        unsigned int v28 = CFDictionaryGetValue(theDict, v22);
        uint64_t v29 = v28;
        if (!v28) {
          break;
        }
        CFTypeID v30 = CFGetTypeID(v28);
        if (v30 == CFStringGetTypeID()) {
          uint64_t v31 = v29;
        }
        else {
          uint64_t v31 = 0;
        }
        CFTypeRef cf = 0;
        if ((v27 - 5) < 2)
        {
LABEL_43:
          *(_OWORD *)long long buf = 0uLL;
          CFDictionaryRef v44 = theDict;
          if (theDict) {
            CFRetain(theDict);
          }
          sub_100811544((uint64_t)v49, &v44, (uint64_t)buf);
          char v32 = &v44;
          goto LABEL_49;
        }
        if (!v31 || !CFEqual(v31, @"OtherKnown.bundle")) {
          goto LABEL_46;
        }
        *(_OWORD *)long long buf = 0uLL;
        CFDictionaryRef v43 = theDict;
        if (theDict) {
          CFRetain(theDict);
        }
        sub_1004988C4((uint64_t)v52, (const void **)&v43, (uint64_t)buf);
        char v32 = &v43;
LABEL_49:
        sub_100057D78((const void **)v32);
        sub_100058140(&cf, (const void **)&buf[8]);
        int v33 = buf[0];
        sub_100057D78((const void **)&buf[8]);
        if (cf) {
          uint64_t v34 = sub_100080778;
        }
        else {
          uint64_t v34 = 0;
        }
        if (v34 && v33 == 4) {
          sub_10055DA44(v59, cf);
        }
        sub_100057D78(&cf);
        sub_100057D78((const void **)&theDict);
        if (Count == ++v21) {
          goto LABEL_56;
        }
      }
      CFTypeRef cf = 0;
      if ((v27 - 5) <= 1) {
        goto LABEL_43;
      }
LABEL_46:
      *(_OWORD *)long long buf = 0uLL;
      CFDictionaryRef v42 = theDict;
      if (theDict) {
        CFRetain(theDict);
      }
      sub_10049707C((uint64_t)v52, &v42, (uint64_t)buf);
      char v32 = &v42;
      goto LABEL_49;
    }
LABEL_56:
    uint64_t v35 = *v41;
    if (os_log_type_enabled(*v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&buf[4] = v59;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Printing all the available updates: %{public}@", buf, 0xCu);
    }
    sub_100044D6C(v40, (CFTypeRef *)&v59);
    sub_10055D800((uint64_t)v49);
    sub_10068800C((uint64_t)v52);
  }
  else
  {
    v38 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v52[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Cannot find bundle match criteria in the device info", (uint8_t *)v52, 2u);
    }
    sub_100044D6C(a2, (CFTypeRef *)&v59);
  }
  sub_1000558F4(&v54);
  sub_100057D78((const void **)&v55);
LABEL_68:
  sub_100057D78(&v58);
  return sub_1000440D4((const void **)&v59);
}

void sub_10069C10C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,int a51,__int16 a52,char a53,char a54,int a55,__int16 a56,char a57,char a58)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10069C240(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  unsigned __int8 v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *unsigned __int8 v2 = 0;
    char v6 = v3;
    *unsigned __int8 v2 = v5;
    char v5 = 0;
    sub_100044D00(&v6);
  }
  return sub_100044D00(&v5);
}

const void **sub_10069C2B8(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  unsigned __int8 v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *unsigned __int8 v2 = 0;
    char v6 = v3;
    *unsigned __int8 v2 = v5;
    char v5 = 0;
    sub_100044D00(&v6);
  }
  return sub_100044D00(&v5);
}

uint64_t *sub_10069C330(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v11 = a1;
  uint64_t v12 = v1;
  unsigned __int8 v2 = *(void **)v1;
  sub_100062740((const void **)&v13, (const void **)(v1 + 8));
  int v3 = *(unsigned __int8 *)(v1 + 16);
  sub_1000DFC90((uint64_t)v22, v1 + 24);
  xpc_object_t v21 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v21 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v21 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v19 = xpc_string_create(off_101B0B028[0]);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  v23[0] = &v21;
  v23[1] = off_101B0AEB0[0];
  sub_100035E70((uint64_t)v23, &v19, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  ctu::cf_to_xpc((uint64_t *)&v17, v13, v7);
  v23[0] = &v21;
  v23[1] = off_101B0B030[0];
  sub_100035E70((uint64_t)v23, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v15 = xpc_BOOL_create(v3 != 0);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  v23[0] = &v21;
  v23[1] = off_101B0B038[0];
  sub_100035E70((uint64_t)v23, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  uint64_t v8 = v2[15];
  xpc_object_t v14 = v21;
  xpc_object_t v15 = 0;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  v23[0] = v2;
  v23[1] = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    v23[1] = xpc_null_create();
  }
  sub_1000DFC90((uint64_t)v24, (uint64_t)v22);
  CFNumberRef v26 = 0;
  char v9 = (char *)operator new(0x38uLL);
  *(void *)char v9 = off_1019F8600;
  *(_OWORD *)(v9 + 8) = *(_OWORD *)v23;
  v23[1] = xpc_null_create();
  sub_100023950((uint64_t)(v9 + 24), (uint64_t)v24);
  CFNumberRef v26 = v9;
  (*(void (**)(uint64_t, xpc_object_t *, void *))(*(void *)v8 + 24))(v8, &v14, v25);
  sub_1001472DC(v25);
  sub_100060644(v24);
  xpc_release(v23[1]);
  v23[1] = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v21);
  sub_100060644(v22);
  sub_100044D00((const void **)&v13);
  sub_10069C71C(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_10069C630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,xpc_object_t a32)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_10069C71C(uint64_t *result)
{
  uint64_t v1 = *result;
  uint64_t *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 24));
    sub_100044D00((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10069C774(uint64_t a1)
{
  *(void *)a1 = off_1019F8600;
  sub_100060644((void *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_10069C7C8(uint64_t a1)
{
  *(void *)a1 = off_1019F8600;
  sub_100060644((void *)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_10069C83C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  unsigned __int8 v2 = operator new(0x38uLL);
  *unsigned __int8 v2 = off_1019F8600;
  sub_10069CC38(v2 + 1, v1);
  return v2;
}

void sub_10069C890(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10069C8A4(uint64_t a1, void *a2)
{
  *a2 = off_1019F8600;
  return sub_10069CC38(a2 + 1, (void *)(a1 + 8));
}

void sub_10069C8D0(uint64_t a1)
{
}

void sub_10069C8D8(void *a1)
{
  sub_10069CCA8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10069C914(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_object_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&p_object, (xpc::object *)(a1 + 16));
    int v5 = v18;
    xpc_object_t v6 = (void **)p_object;
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    uint64_t v7 = &p_object;
    if (v5 < 0) {
      uint64_t v7 = v6;
    }
    if (v15 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    buf[0] = 136446466;
    *(void *)&buf[1] = v7;
    __int16 v20 = 2082;
    xpc_object_t v21 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sent request %{public}s , received result: %{public}s", (uint8_t *)buf, 0x16u);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(p_object);
    }
  }
  p_xpc_object_t object = &object;
  xpc_object_t v17 = off_101B0AF60[0];
  sub_100048BAC((uint64_t)&p_object, __p);
  int v10 = xpc::dyn_cast_or_default((xpc *)__p, 0, v9);
  xpc_release(__p[0]);
  if (v10)
  {
    p_xpc_object_t object = 0;
    xpc_object_t v17 = 0;
    sub_10003E168(&p_object, (void *)(v3 + 8));
    operator new();
  }
  p_xpc_object_t object = &object;
  xpc_object_t v17 = off_101B0B040[0];
  sub_100048BAC((uint64_t)&p_object, __p);
  int v12 = xpc::dyn_cast_or_default((xpc *)__p, 0, v11);
  xpc_release(__p[0]);
  sub_1000607A8(a1 + 24, v12 ^ 1);
  xpc_release(object);
}

void sub_10069CB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10069CBEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10069CC2C()
{
}

void *sub_10069CC38(void *a1, void *a2)
{
  xpc_object_t v4 = (void *)a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    a1[1] = xpc_null_create();
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10069CC88(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void sub_10069CCA8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
}

void sub_10069CCE0(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100678B30(**a1);
  operator delete();
}

void sub_10069CD34()
{
}

uint64_t *sub_10069CD60(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v39 = a1;
  char v40 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *((unsigned int *)v1 + 2);
  int v4 = *((unsigned __int8 *)v1 + 12);
  int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*v1 + 48) + 16))(*(void *)(*v1 + 48), v3);
  CFDictionaryRef theDict = 0;
  xpc_object_t v6 = (uint64_t **)(v2 + 136);
  v48[0] = (void *)((v3 << 32) | 1);
  *(void *)&long long buf = v48;
  uint64_t v7 = sub_100688D4C((uint64_t **)(v2 + 136), (unsigned __int8 *)v48, (uint64_t)&unk_10144E20E, (void **)&buf);
  sub_100058198((const void **)&theDict, (const void **)v7 + 30);
  if (theDict) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    v48[0] = 0;
    v48[1] = 0;
    uint64_t v49 = 0;
    CFDictionaryGetValue(theDict, (const void *)qword_101B13EB8);
    long long buf = 0uLL;
    *(void *)&long long v53 = 0;
    ctu::cf::assign();
    *(_OWORD *)uint64_t v48 = buf;
    uint64_t v49 = v53;
    uint64_t v9 = *((void *)&buf + 1);
    if ((SBYTE7(v53) & 0x80u) == 0) {
      uint64_t v9 = BYTE7(v53);
    }
    if (!v9)
    {
      uint64_t v24 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No ICCID present in matching info. Cannot save the switch state", (uint8_t *)&buf, 2u);
      }
      char v22 = 0;
      goto LABEL_42;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 104));
    BOOL v11 = ServiceMap;
    if (v12 < 0)
    {
      char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v12;
    xpc_object_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
    uint64_t v38 = v2;
    if (v16)
    {
      uint64_t v18 = v16[3];
      xpc_object_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        xpc_object_t v19 = v17;
        sub_10004D2C8(v17);
        char v20 = 0;
        if (!v18)
        {
LABEL_14:
          xpc_object_t v21 = *v5;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface", (uint8_t *)&buf, 2u);
          }
          char v22 = 0;
LABEL_40:
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v19);
          }
LABEL_42:
          if (SHIBYTE(v49) < 0) {
            operator delete(v48[0]);
          }
          goto LABEL_44;
        }
LABEL_25:
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v47 = 0;
        if (SHIBYTE(v49) < 0)
        {
          sub_10004FC84(__p, v48[0], (unint64_t)v48[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)v48;
          uint64_t v47 = v49;
        }
        CFTypeID v25 = &kCFBooleanTrue;
        if (!v4) {
          CFTypeID v25 = &kCFBooleanFalse;
        }
        if ((*(unsigned int (**)(uint64_t, void **, void, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v18 + 48))(v18, __p, kGsmaSettingsSwitchState, *v25, 0, 0, 1, 0))
        {
          CFNumberRef v26 = *v5;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            int v27 = v48;
            if (v49 < 0) {
              int v27 = (void **)v48[0];
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v27;
            unsigned int v28 = "Could not store GSMA Switch state for %s";
            uint64_t v29 = v26;
LABEL_56:
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          int v30 = (*(uint64_t (**)(uint64_t, void **, void, void, void, void, uint64_t, void))(*(void *)v18 + 48))(v18, __p, kOtherKnownCarrierSettingsAppliedByDefault, 0, 0, 0, 1, 0);
          uint64_t v31 = *v5;
          if (!v30)
          {
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Rematch carrier bundle to apply GSMA overlay based off the user preference", (uint8_t *)&buf, 2u);
            }
            long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            long long v62 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            long long v55 = 0u;
            long long v56 = 0u;
            long long v53 = 0u;
            long long v54 = 0u;
            long long buf = 0u;
            *(void *)CFDictionaryRef v44 = (v3 << 32) | 1;
            CFNumberRef v51 = (uint64_t *)v44;
            int v33 = sub_100688D4C(v6, v44, (uint64_t)&unk_10144E20E, &v51);
            sub_100058198(&v45, (const void **)v33 + 30);
            uint64_t v42 = (v3 << 32) | 1;
            CFNumberRef v51 = &v42;
            uint64_t v34 = sub_100688D4C(v6, (unsigned __int8 *)&v42, (uint64_t)&unk_10144E20E, &v51);
            sub_100058198(&v43, (const void **)v34 + 31);
            uint64_t v41 = (v3 << 32) | 1;
            CFNumberRef v51 = &v41;
            LODWORD(v51) = *((_DWORD *)sub_100688D4C(v6, (unsigned __int8 *)&v41, (uint64_t)&unk_10144E20E, &v51) + 64);
            CarrierBundleHandler::matchCarrierBundle_sync(v38, &v45, &v43, (int *)&v51, v3, 0, (uint64_t)&buf);
            sub_100057D78(&v43);
            sub_100057D78(&v45);
            char v22 = BYTE8(v64) != 5;
            if (BYTE8(v64) == 5)
            {
              uint64_t v35 = *v5;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)CFDictionaryRef v44 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Set up error seen when loading carrier bundle with GSMA settings.", v44, 2u);
              }
            }
            sub_10000BDF8((uint64_t)&buf);
            goto LABEL_38;
          }
          if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = v48;
            if (v49 < 0) {
              uint64_t v37 = (void **)v48[0];
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v37;
            unsigned int v28 = "Failed to reset OtherKnownSetting by default for %s";
            uint64_t v29 = v31;
            goto LABEL_56;
          }
        }
        char v22 = 0;
LABEL_38:
        if (SHIBYTE(v47) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    xpc_object_t v19 = 0;
    char v20 = 1;
    if (!v18) {
      goto LABEL_14;
    }
    goto LABEL_25;
  }
  unsigned int v23 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    uint64_t v36 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v36;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No valid matching info for slot: %s", (uint8_t *)&buf, 0xCu);
  }
  char v22 = 0;
LABEL_44:
  sub_100057D78((const void **)&theDict);
  if (v1[5]) {
    sub_1000607A8((uint64_t)(v1 + 2), v22);
  }
  sub_10069D4A0((uint64_t *)&v40);
  return sub_100046B58((uint64_t *)&v39);
}

void sub_10069D3E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,const void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_100057D78(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if ((v38 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_100057D78(&a30);
  sub_10069D4A0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10069D4A0(uint64_t *result)
{
  uint64_t v1 = *result;
  uint64_t *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_10069D4F0(uint64_t a1)
{
  return CarrierBundleHandler::evaluateGsmaSettingsSwitchState_sync(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_10069D500(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10069D53C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_10069D578(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v3 = v14;
  uint64_t v2 = v15;
  if (v14 != v15)
  {
    int v4 = v16;
    do
    {
      if (v16(*v3)) {
        goto LABEL_6;
      }
      ++v3;
    }
    while (v3 != v15);
    uint64_t v3 = v15;
LABEL_6:
    int v5 = v15;
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      memset(&__str, 0, sizeof(__str));
      uint64_t v12 = (v6 << 32) | 1;
      v11.__r_.__value_.__r.__words[0] = (std::string::size_type)&v12;
      uint64_t v7 = sub_100688D4C((uint64_t **)(v1 + 136), (unsigned __int8 *)&v12, (uint64_t)&unk_10144E20E, &v11);
      if (v7[87] < 0) {
        sub_10004FC84(&__str, *((void **)v7 + 8), *((void *)v7 + 9));
      }
      else {
        std::string __str = *(std::string *)(v7 + 64);
      }
      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      char v9 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __str.__r_.__value_.__l.__size_;
      }
      if (size >= 0xB)
      {
        std::string::basic_string(&v11, &__str, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v12);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        std::string __str = v11;
        CarrierBundleHandler::submitLegacyDesktopHostUpdateMetric_sync(v1, 1, (uint64_t)&__str);
        char v9 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      if (v9 < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      int v10 = v3 + 1;
      uint64_t v3 = v2;
      if (v10 != v2)
      {
        uint64_t v3 = v10;
        do
        {
          if (v4(*v3)) {
            goto LABEL_23;
          }
          ++v3;
        }
        while (v3 != v2);
        uint64_t v3 = v2;
      }
LABEL_23:
      ;
    }
  }
  operator delete();
}

void sub_10069D74C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_10069D7A0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Request to clear user library trial bundles.", buf, 2u);
  }
  xpc_object_t v17 = 0;
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v17 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v17 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_11;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_10:
  xpc_object_t v17 = v5;
LABEL_11:
  xpc_release(v4);
  xpc_object_t object = xpc_string_create(off_101B0AF10[0]);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)long long buf = &v17;
  uint64_t v14 = off_101B0AEB0[0];
  sub_100035E70((uint64_t)buf, &object, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v6 = *(void *)(v1 + 120);
  xpc_object_t v11 = v17;
  xpc_object_t v12 = 0;
  if (v17) {
    xpc_retain(v17);
  }
  else {
    xpc_object_t v11 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v6 + 16))(&v12, v6, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  *(void *)long long buf = &v12;
  uint64_t v14 = off_101B0AF68[0];
  sub_100048BAC((uint64_t)buf, &v10);
  int v8 = xpc::dyn_cast_or_default((xpc *)&v10, 0, v7);
  xpc_release(v10);
  if (v8)
  {
    char v9 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Trial CarrierBundles removed from User directory. Need to rematch bundles", buf, 2u);
    }
    sub_100678B30(v1);
  }
  xpc_release(v12);
  xpc_release(v17);
  operator delete();
}

void sub_10069D9EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t a11, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 40));
  operator delete();
}

void sub_10069DA8C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F86E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10069DAAC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F86E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

unsigned __int8 *sub_10069DB00(uint64_t a1)
{
  return sub_100692B6C((unsigned __int8 *)(a1 + 24));
}

void *sub_10069DB0C(void *a1)
{
  *a1 = off_1019F8730;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10069DB58(void *a1)
{
  *a1 = off_1019F8730;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10069DBC4(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019F8730;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_10069DC28(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019F8730;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_10069DC68(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10069DC78(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10069DCB8(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 24);
  if (xpc_dictionary_get_value(v3, off_101B0AF60[0]))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    sub_10003E168(&v6, (void *)(v4 + 8));
    operator new();
  }
  *(unsigned char *)(v4 + 434) = 0;
  if (*(_DWORD *)(v4 + 412) == 7)
  {
    if (sub_100679F70(v4))
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      sub_10003E168(&v6, (void *)(v4 + 8));
      operator new();
    }
    xpc_object_t v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Plans only update ended, but not valid time window for silent updates.", (uint8_t *)&v6, 2u);
    }
  }
  **(unsigned char **)(a1 + 8) = 0;
  xpc_release(v3);
}

void sub_10069DEEC(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10069DF04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10069DF44()
{
}

void sub_10069DF50(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100678B30(**a1);
  operator delete();
}

void sub_10069DFA4()
{
}

void sub_10069DFD0(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Plans only update ended, checking for bundle update", buf, 2u);
  }
  sub_100679FCC(v1);
  operator delete();
}

void sub_10069E06C()
{
}

void sub_10069E098(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x170uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019F8878;
  uint64_t v7 = &v6[1].__vftable;
  int v8 = *a2;
  *a2 = 0;
  dispatch_object_t object = v8;
  sub_10069E1E0((uint64_t)&v6[1], a1, &object);
  if (object) {
    dispatch_release(object);
  }
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019F88C8;
  shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    goto LABEL_7;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_7:
    sub_10004D2C8(v6);
  }
  sub_10069E4E4(v7);
  *a3 = v7;
  a3[1] = v6;
}

void sub_10069E1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10069E1E0(uint64_t a1, uint64_t a2, NSObject **a3)
{
  uint64_t v29 = *a3;
  *a3 = 0;
  sub_1011DD9C4((void *)a1, a2, &v29, (uint64_t)"SuppServicesPreferencesSink", "set.supp.prefs");
  if (v29) {
    dispatch_release(v29);
  }
  *(void *)a1 = off_1019F87B0;
  uint64_t v4 = (const char *)kSuppServicesCLIRStatusChangedNotification;
  xpc_object_t v5 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  v6.fObj.fObj = (dispatch_object_s *)&object;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 96), v4, v6);
  if (object) {
    dispatch_release(object);
  }
  uint64_t v7 = (const char *)kSuppServicesCLIRNetworkStatusChangedNotification;
  int v8 = *(NSObject **)(a1 + 24);
  dispatch_object_t v27 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  v9.fObj.fObj = (dispatch_object_s *)&v27;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 120), v7, v9);
  if (v27) {
    dispatch_release(v27);
  }
  xpc_object_t v10 = (const char *)kSuppServicesCallWaitingStatusChangedNotification;
  xpc_object_t v11 = *(NSObject **)(a1 + 24);
  dispatch_object_t v26 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  v12.fObj.fObj = (dispatch_object_s *)&v26;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 144), v10, v12);
  if (v26) {
    dispatch_release(v26);
  }
  char v13 = (const char *)kSuppServicesAutoAnswerStatusChangedNotification;
  uint64_t v14 = *(NSObject **)(a1 + 24);
  dispatch_object_t v25 = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  v15.fObj.fObj = (dispatch_object_s *)&v25;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 168), v13, v15);
  if (v25) {
    dispatch_release(v25);
  }
  xpc_object_t v16 = (const char *)kUserDefaultVoiceSlotChangedNotification;
  xpc_object_t v17 = *(NSObject **)(a1 + 24);
  dispatch_object_t v24 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  v18.fObj.fObj = (dispatch_object_s *)&v24;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 192), v16, v18);
  if (v24) {
    dispatch_release(v24);
  }
  sub_100058DB0(&__p, *(char **)(a1 + 88));
  xpc_object_t v19 = *(NSObject **)(a1 + 24);
  xpc_object_t v21 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  ctu::RestModule::RestModule();
  if (v21) {
    dispatch_release(v21);
  }
  if (v23 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 232) = 0;
  return a1;
}

void sub_10069E400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t a18)
{
  if (object) {
    dispatch_release(object);
  }
  if (a11) {
    dispatch_release(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  NotifySubscription::~NotifySubscription(v23);
  NotifySubscription::~NotifySubscription(v22);
  NotifySubscription::~NotifySubscription(v21);
  NotifySubscription::~NotifySubscription(v20);
  NotifySubscription::~NotifySubscription(v19);
  sub_1011DDB58(v18);
  _Unwind_Resume(a1);
}

void sub_10069E480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x10069E458);
}

void sub_10069E494(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x10069E460);
}

void sub_10069E4A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x10069E468);
}

void sub_10069E4BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x10069E470);
}

void sub_10069E4D0()
{
  uint64_t v1 = *(NSObject **)(v0 - 72);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x10069E478);
}

void sub_10069E4E4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2) {
    goto LABEL_14;
  }
  uint64_t v3 = (std::__shared_weak_count_vtbl *)a1[1];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    goto LABEL_14;
  }
  xpc_object_t v5 = v4;
  sub_10069E6A8((NotifySubscription *)(a1 + 12), v3, v4, (uint64_t)sub_10069E828, 0);
  sub_10004D2C8(v5);
  queue v6 = (std::__shared_weak_count *)a1[2];
  if (!v6) {
    goto LABEL_14;
  }
  uint64_t v7 = (std::__shared_weak_count_vtbl *)a1[1];
  int v8 = std::__shared_weak_count::lock(v6);
  if (!v8) {
    goto LABEL_14;
  }
  queue v9 = v8;
  sub_10069E6A8((NotifySubscription *)(a1 + 15), v7, v8, (uint64_t)sub_10069E920, 0);
  sub_10004D2C8(v9);
  xpc_object_t v10 = (std::__shared_weak_count *)a1[2];
  if (!v10) {
    goto LABEL_14;
  }
  xpc_object_t v11 = (std::__shared_weak_count_vtbl *)a1[1];
  queue v12 = std::__shared_weak_count::lock(v10);
  if (!v12) {
    goto LABEL_14;
  }
  char v13 = v12;
  sub_10069E6A8((NotifySubscription *)(a1 + 18), v11, v12, (uint64_t)sub_10069EA24, 0);
  sub_10004D2C8(v13);
  uint64_t v14 = (std::__shared_weak_count *)a1[2];
  if (!v14) {
    goto LABEL_14;
  }
  queue v15 = (std::__shared_weak_count_vtbl *)a1[1];
  xpc_object_t v16 = std::__shared_weak_count::lock(v14);
  if (!v16
    || (xpc_object_t v17 = v16,
        sub_10069E6A8((NotifySubscription *)(a1 + 21), v15, v16, (uint64_t)sub_10069EAEC, 0),
        sub_10004D2C8(v17),
        (queue v18 = (std::__shared_weak_count *)a1[2]) == 0)
    || (xpc_object_t v19 = (std::__shared_weak_count_vtbl *)a1[1], (v20 = std::__shared_weak_count::lock(v18)) == 0))
  {
LABEL_14:
    sub_100088B9C();
  }
  xpc_object_t v21 = v20;
  sub_10069E6A8((NotifySubscription *)(a1 + 24), v19, v20, (uint64_t)sub_10069EBB4, 0);

  sub_10004D2C8(v21);
}

void sub_10069E684(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10069E6A8(NotifySubscription *this, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count *a3, uint64_t a4, std::__shared_weak_count_vtbl *a5)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&a3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(a3);
    atomic_fetch_add_explicit(&a3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel(this);
  xpc_object_t v10 = (std::__shared_weak_count *)operator new(0x38uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_1019F89C0;
  v10[1].__vftable = a2;
  v10[1].__shared_owners_ = (uint64_t)a3;
  v10[1].__shared_weak_owners_ = a4;
  v10[2].__vftable = a5;
  xpc_object_t v11 = *(const char **)this;
  queue v12 = *((void *)this + 1);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_10069F4E0;
  v13[3] = &unk_1019F8980;
  v13[4] = v10 + 1;
  uint64_t v14 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v11, (int *)this + 4, v12, v13);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v10);
  if (a3) {
    std::__shared_weak_count::__release_weak(a3);
  }
}

void sub_10069E7E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v15);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(a1);
}

void sub_10069E828(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received notification that CLIR status value changed", buf, 2u);
  }
  *(void *)long long buf = 0;
  int v8 = 0;
  int v3 = sub_10069ECA0(a1);
  sub_1011DDC08(a1, v3, (unint64_t *)buf);
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(void *)buf)
    {
      uint64_t v5 = *(void *)buf;
      queue v6 = v8;
      *(void *)long long buf = 0;
      int v8 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 16))(v4, 1, &v5);
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_10069E908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10069E920(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received notification that CLIR network status value changed", buf, 2u);
  }
  *(void *)long long buf = 0;
  int v8 = 0;
  int v3 = sub_10069ECA0(a1);
  sub_1011DDFD0(a1, v3, buf);
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    if (*(void *)buf)
    {
      uint64_t v5 = *(void *)buf;
      queue v6 = v8;
      *(void *)long long buf = 0;
      int v8 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 24))(v4, 1, &v5);
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_10069EA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10069EA24(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)queue v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received notification that Call Waiting status value changed", v6, 2u);
  }
  sub_10069ECA0(a1);
  int v3 = sub_10069ECA0(a1);
  unsigned __int16 v4 = sub_1011DE6E8(a1, v3);
  uint64_t result = *(void *)(a1 + 80);
  if (result)
  {
    if (v4 >= 0x100u) {
      return (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)result + 32))(result, 1, v4 != 0);
    }
  }
  return result;
}

uint64_t sub_10069EAEC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)queue v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received notification that Auto Answer status value changed", v6, 2u);
  }
  sub_10069ECA0(a1);
  int v3 = sub_10069ECA0(a1);
  unsigned __int16 v4 = sub_1011DEA2C(a1, v3);
  uint64_t result = *(void *)(a1 + 80);
  if (result)
  {
    if (v4 >= 0x100u) {
      return (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)result + 40))(result, 1, v4 != 0);
    }
  }
  return result;
}

void sub_10069EBB4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)queue v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received notification that User Default Voice Slot value changed", v6, 2u);
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1);
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    BOOL v5 = (v3 & 0xFF00000000) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  }
  if (!*(unsigned char *)(a1 + 232) || !*(_DWORD *)(a1 + 336))
  {
    sub_10069E828(a1);
    sub_10069E920(a1);
  }
}

uint64_t sub_10069ECA0(uint64_t a1)
{
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  if (*(unsigned char *)(a1 + 232)
    && (sub_1003C8068((uint64_t)v7, (long long *)(a1 + 240)), LOBYTE(v7[0]))
    && (uint64_t v2 = DWORD2(v8), DWORD2(v8)))
  {
    sub_1003C8134(v7);
  }
  else
  {
    sub_1003C8134(v7);
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1);
    uint64_t v2 = v3;
    if ((v3 & 0xFF00000000) == 0 || v3 == 0)
    {
      BOOL v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v7[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Unknown slot, default to kOne", (uint8_t *)v7, 2u);
      }
      return 1;
    }
  }
  return v2;
}

uint64_t sub_10069EDC8(uint64_t a1)
{
  int v2 = sub_10069ECA0(a1);

  return sub_1011DE6E8(a1, v2);
}

uint64_t sub_10069EE04(uint64_t a1)
{
  int v2 = sub_10069ECA0(a1);

  return sub_1011DEA2C(a1, v2);
}

unsigned char *sub_10069EE40(uint64_t a1, uint64_t a2)
{
  long long v24 = 0u;
  memset(v23, 0, sizeof(v23));
  if (*(unsigned char *)(a1 + 232))
  {
    sub_1003C8068((uint64_t)v23, (long long *)(a1 + 240));
    if (*(unsigned char *)a2 && LOBYTE(v23[0]) && *(_DWORD *)(a2 + 104) == DWORD2(v24)) {
      return sub_1003C8134(v23);
    }
    int v4 = *(unsigned __int8 *)(a1 + 232);
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    if (v4)
    {
      sub_1003C8068((uint64_t)&v16, (long long *)(a1 + 240));
      if ((_BYTE)v16)
      {
        BOOL v5 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_13;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v15 = subscriber::asString();
        queue v6 = "#I Cellular plan subscription info changed to companion slot: %s";
        uint64_t v7 = v5;
        uint32_t v8 = 12;
        goto LABEL_12;
      }
    }
  }
  else
  {
    long long v21 = 0uLL;
    long long v22 = 0uLL;
    long long v19 = 0uLL;
    long long v20 = 0uLL;
    long long v17 = 0uLL;
    long long v18 = 0uLL;
    long long v16 = 0uLL;
  }
  queue v9 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_13;
  }
  *(_WORD *)long long buf = 0;
  queue v6 = "#I Cellular plan subscription info missing";
  uint64_t v7 = v9;
  uint32_t v8 = 2;
LABEL_12:
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
LABEL_13:
  sub_1003C8134(&v16);
  long long v16 = 0uLL;
  int v10 = sub_10069ECA0(a1);
  sub_1011DDC08(a1, v10, (unint64_t *)&v16);
  uint64_t v11 = *(void *)(a1 + 80);
  if (v11)
  {
    if ((void)v16)
    {
      long long v13 = v16;
      long long v16 = 0uLL;
      (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v11 + 16))(v11, 1, &v13);
      if (*((void *)&v13 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
      }
    }
  }
  if (*((void *)&v16 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
  }
  return sub_1003C8134(v23);
}

void sub_10069F044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_10069F088(Registry **a1)
{
  if (capabilities::ct::supportsSIMProvisioningAsSignupDestination((capabilities::ct *)a1))
  {
    sub_100058DB0(&__p, "/cc/props/cellular_plan_remotesubscription_info");
    int v2 = operator new(0x28uLL);
    *int v2 = off_1019F8B10;
    v2[1] = a1 + 29;
    v2[2] = a1;
    v2[3] = sub_10069EE40;
    v2[4] = 0;
    v7[3] = v2;
    ctu::RestModule::observeProperty();
    sub_10003F600(v7);
    if (v6 < 0) {
      operator delete(__p);
    }
    Registry::createRestModuleOneTimeUseConnection(&v3, a1[6]);
    ctu::RestModule::connect();
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

void sub_10069F188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10069F1D0(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 216));
}

uint64_t sub_10069F1D8()
{
  return 0;
}

uint64_t sub_10069F1E0()
{
  return 0;
}

uint64_t sub_10069F1E8()
{
  return 0;
}

uint64_t sub_10069F1F0()
{
  return 0;
}

SuppServicesPreferencesInterface *sub_10069F1FC(uint64_t a1)
{
  *(void *)a1 = off_1019F87B0;
  sub_1003C8134((unsigned char *)(a1 + 232));
  int v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 192));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 168));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 144));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 120));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 96));

  return sub_1011DDB58((SuppServicesPreferencesInterface *)a1);
}

void sub_10069F284(uint64_t a1)
{
  *(void *)a1 = off_1019F87B0;
  sub_1003C8134((unsigned char *)(a1 + 232));
  int v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 192));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 168));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 144));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 120));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 96));
  sub_1011DDB58((SuppServicesPreferencesInterface *)a1);

  operator delete();
}

void sub_10069F320(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F8878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10069F340(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F8878;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10069F394(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

SuppServicesPreferencesInterface *sub_10069F3BC(uint64_t a1)
{
  *(void *)a1 = off_1019F87B0;
  sub_1003C8134((unsigned char *)(a1 + 232));
  int v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 192));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 168));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 144));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 120));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 96));

  return sub_1011DDB58((SuppServicesPreferencesInterface *)a1);
}

void sub_10069F444(uint64_t a1)
{
  *(void *)a1 = off_1019F87B0;
  sub_1003C8134((unsigned char *)(a1 + 232));
  int v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 192));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 168));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 144));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 120));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 96));
  sub_1011DDB58((SuppServicesPreferencesInterface *)a1);

  operator delete();
}

void sub_10069F4E0(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)v2[1];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      char v6 = v5;
      if (*v2)
      {
        uint64_t v7 = (void (*)(void *, uint64_t))v2[2];
        uint64_t v8 = v2[3];
        queue v9 = (void *)(*v2 + (v8 >> 1));
        if (v8) {
          uint64_t v7 = *(void (**)(void *, uint64_t))(*v9 + v7);
        }
        v7(v9, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10069F594(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10069F5A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10069F5C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10069F5D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F89C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10069F5F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F89C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10069F648(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10069F65C(const std::logic_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_10069F6BC((uint64_t)exception, a1);
}

void sub_10069F6A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10069F6BC(uint64_t a1, const std::logic_error *a2)
{
  *(void *)a1 = &off_10199A898;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_1019F8A70;
  *(void *)(a1 + 8) = off_1019F8AA0;
  *(void *)(a1 + 24) = off_1019F8AC8;
  return a1;
}

uint64_t sub_10069F768(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));
  return a1;
}

void sub_10069F7BC()
{
}

void sub_10069F988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100098B6C(&a9);
  sub_100098B6C(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_10069FA00(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_10069FCA8((uint64_t)exception, a1);
}

void sub_10069FA48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10069FA5C(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::logic_error::~logic_error((std::logic_error *)(a1 + 8));

  operator delete();
}

void sub_10069FAD0(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));

  std::logic_error::~logic_error((std::logic_error *)a1);
}

void sub_10069FB2C(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::logic_error::~logic_error((std::logic_error *)a1);

  operator delete();
}

void sub_10069FBA4(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);

  std::logic_error::~logic_error((std::logic_error *)a1 - 1);
}

void sub_10069FBFC(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);
  std::logic_error::~logic_error((std::logic_error *)a1 - 1);

  operator delete();
}

void sub_10069FC70(std::logic_error *a1)
{
  std::logic_error::~logic_error(a1);

  operator delete();
}

uint64_t sub_10069FCA8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10199A898;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  *(void *)(a1 + 8) = &off_1019F8AE8;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_10199A8F0;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &off_1019F8A70;
  *(void *)(a1 + 8) = off_1019F8AA0;
  *(void *)(a1 + 24) = off_1019F8AC8;
  return a1;
}

void sub_10069FDD0(_Unwind_Exception *a1)
{
  std::logic_error::~logic_error(v1);
  _Unwind_Resume(a1);
}

void sub_10069FDE8()
{
}

__n128 sub_10069FDFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F8B10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10069FE50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F8B10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unsigned char *sub_10069FE88(void *a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  uint64_t v3 = a1[1];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  memset(v11, 0, sizeof(v11));
  if (*(unsigned char *)v3)
  {
    long long v4 = *(_OWORD *)(v3 + 8);
    *((void *)&v11[1] + 1) = *(void *)(v3 + 24);
    *(_OWORD *)((char *)v11 + 8) = v4;
    *(void *)(v3 + 16) = 0;
    *(void *)(v3 + 24) = 0;
    *(void *)(v3 + 8) = 0;
    LODWORD(v12) = *(_DWORD *)(v3 + 32);
    if (*(unsigned char *)(v3 + 40))
    {
      long long v5 = *(_OWORD *)(v3 + 48);
      *(void *)&long long v14 = *(void *)(v3 + 64);
      long long v13 = v5;
      *(void *)(v3 + 56) = 0;
      *(void *)(v3 + 64) = 0;
      *(void *)(v3 + 48) = 0;
      BYTE8(v12) = 1;
    }
    BYTE8(v14) = 0;
    if (*(unsigned char *)(v3 + 72))
    {
      long long v6 = *(_OWORD *)(v3 + 80);
      *(void *)&long long v16 = *(void *)(v3 + 96);
      long long v15 = v6;
      *(void *)(v3 + 88) = 0;
      *(void *)(v3 + 96) = 0;
      *(void *)(v3 + 80) = 0;
      BYTE8(v14) = 1;
    }
    DWORD2(v16) = *(_DWORD *)(v3 + 104);
    LOBYTE(v11[0]) = 1;
  }
  sub_1003C8A7C((unsigned char *)v3, a2);
  uint64_t v7 = (void (*)(void *, _OWORD *))a1[3];
  uint64_t v8 = a1[4];
  queue v9 = (void *)(a1[2] + (v8 >> 1));
  if (v8) {
    uint64_t v7 = *(void (**)(void *, _OWORD *))(*v9 + v7);
  }
  v7(v9, v11);
  return sub_1003C8134(v11);
}

void sub_10069FFD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_10069FFEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006A002C()
{
}

long long *stewie::TargetInstant::invalidInstance(stewie::TargetInstant *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13E18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13E18))
  {
    xmmword_101B13E00 = xmmword_10146FCC0;
    qword_101B13E10 = 0xBFF0000000000000;
    __cxa_guard_release(&qword_101B13E18);
  }
  return &xmmword_101B13E00;
}

void sub_1006A00A8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1006A01B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
    if (!v9)
    {
LABEL_3:
      if (v10) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v9)
  {
    goto LABEL_3;
  }
  dispatch_release(v9);
  if (v10) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006A021C(uint64_t a1, uint64_t a2, dispatch_object_t *a3, uint64_t *a4)
{
  uint64_t v8 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "cb.man");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v16, &v18);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  v17[0] = off_101999E18;
  v17[1] = sub_1006A0684;
  v17[3] = v17;
  *(void *)(a1 + 32) = 0;
  if ((capabilities::ct::supportsGemini(v9) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 32)) {
    operator new();
  }
  sub_10008863C(v17);
  *(void *)a1 = off_1019F8BD0;
  uint64_t v10 = *a4;
  *a4 = 0;
  *(void *)(a1 + 40) = v10;
  Registry::getFileSystemInterface((uint64_t *)(a1 + 48), *(Registry **)a2);
  *(void *)(a1 + 64) = *(void *)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  *(void *)(a1 + 72) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "Carrier Bundle Manager");
  long long v13 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 216) = a1 + 224;
  return a1;
}

void sub_1006A0514(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_1006A0684(int a1)
{
  uint64_t v1 = "cb.man.?";
  if (a1 == 2) {
    uint64_t v1 = "cb.man.2";
  }
  if (a1 == 1) {
    return "cb.man.1";
  }
  else {
    return v1;
  }
}

void sub_1006A06B0(uint64_t a1)
{
  *(void *)a1 = off_1019F8BD0;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 80));
  sub_1006B1840(*(void **)(a1 + 224));
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  sub_1000346F8(a1 + 96, *(void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  CarrierBundleManagerInterface::~CarrierBundleManagerInterface((CarrierBundleManagerInterface *)a1);
}

void sub_1006A07F8(uint64_t a1)
{
  sub_1006A06B0(a1);

  operator delete();
}

uint64_t sub_1006A0830(uint64_t a1, const void **a2)
{
  if (*a2) {
    uint64_t v3 = sub_1000FCC20;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    memset(v13, 0, sizeof(v13));
    uint64_t v14 = 0;
    sub_100119B5C((const void **)&v12, a2);
    asString(v12, (uint64_t)v13);
    sub_1000FE824((const void **)&v12);
    long long v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = v13;
      if (v14 < 0) {
        uint64_t v5 = *(uint8_t **)v13;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Install bundle: %{public}s ", buf, 0xCu);
    }
    *(_OWORD *)long long buf = 0uLL;
    uint64_t v6 = *(void *)(a1 + 40);
    if (SHIBYTE(v14) < 0)
    {
      sub_10004FC84(__p, *(void **)v13, *(unint64_t *)&v13[8]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v13;
      uint64_t v11 = v14;
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v6 + 72))(buf, v6, __p);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)buf + 16))(*(void *)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(*(void **)v13);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Empty bundle path. Cannot install", v13, 2u);
    }
    return 0;
  }
  return v8;
}

void sub_1006A0A28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006A0A80@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = (Registry **)(a1 + 64);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      std::string::size_type v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    long long v13 = (GestaltUtilityInterface *)v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    long long v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  char v14 = 1;
LABEL_9:
  int isIPhone = GestaltUtilityInterface::isIPhone(v13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (isIPhone)
  {
    Registry::createRestModuleOneTimeUseConnection(&v73, *(Registry **)(a1 + 64));
    ctu::RestModule::connect();
    if (v74) {
      sub_10004D2C8(v74);
    }
    sub_100058DB0(__dst, "/cc/props/ui_apns_available");
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019F8EA0;
    buf.__r_.__value_.__l.__size_ = a1 + 96;
    *(void *)&long long v98 = &buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(&buf);
    if (v88 < 0) {
      operator delete(*(void **)__dst);
    }
  }
  long long v16 = (os_log_t *)(a1 + 8);
  long long v17 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Initializing Carrier Bundle Locations", (uint8_t *)&buf, 2u);
  }
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  Registry::getMobileHelper(&v83, *v4);
  if (v83)
  {
    v81[0] = 0;
    v81[1] = 0;
    uint64_t v82 = 0;
    getCarrierBundleLinksDir(v81);
    if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 48) + 88))(*(void *)(a1 + 48), v81))
    {
      int v18 = 0;
    }
    else
    {
      int v18 = checkFilePresentUsingMobileHelper((os_log_t *)(a1 + 8), v4, (uint64_t *)v81);
      if (v18) {
        sub_1006AC3E0(a1, (std::string::size_type)v81);
      }
      long long v20 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        long long v21 = v81;
        if (v82 < 0) {
          long long v21 = (void **)v81[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Creating carrier bundle links dir %{public}s", (uint8_t *)&buf, 0xCu);
      }
      if (((*(uint64_t (**)(void))(*(void *)v83 + 136))() & 1) == 0)
      {
        long long v22 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
        {
          long long v64 = v81;
          if (v82 < 0) {
            long long v64 = (void **)v81[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v64;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to create Carrier Bundle symlinks directory, %{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
    }
    v79[0] = 0;
    v79[1] = 0;
    uint64_t v80 = 0;
    getCarrierBundlePreferencesDir(v79);
    if (((*(uint64_t (**)(void, void **))(**(void **)(a1 + 48) + 88))(*(void *)(a1 + 48), v79) & 1) == 0)
    {
      if (checkFilePresentUsingMobileHelper((os_log_t *)(a1 + 8), v4, (uint64_t *)v79))
      {
        sub_1006AC3E0(a1, (std::string::size_type)v79);
        int v18 = 1;
      }
      char v23 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        long long v24 = v79;
        if (v80 < 0) {
          long long v24 = (void **)v79[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Creating carrier bundle preferences dir %{public}s", (uint8_t *)&buf, 0xCu);
      }
      if (((*(uint64_t (**)(void))(*(void *)v83 + 136))() & 1) == 0)
      {
        dispatch_object_t v25 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
        {
          v65 = v79;
          if (v80 < 0) {
            v65 = (void **)v79[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v65;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to create Carrier Bundle preferences directory, %{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
    }
    v77[0] = 0;
    v77[1] = 0;
    uint64_t v78 = 0;
    getCountryBundleLinksDir(v77);
    if (((*(uint64_t (**)(void, void **))(**(void **)(a1 + 48) + 88))(*(void *)(a1 + 48), v77) & 1) == 0)
    {
      if (checkFilePresentUsingMobileHelper((os_log_t *)(a1 + 8), v4, (uint64_t *)v77))
      {
        sub_1006AC3E0(a1, (std::string::size_type)v77);
        int v18 = 1;
      }
      dispatch_object_t v26 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        dispatch_object_t v27 = v77;
        if (v78 < 0) {
          dispatch_object_t v27 = (void **)v77[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Creating country bundle links dir %{public}s", (uint8_t *)&buf, 0xCu);
      }
      if (((*(uint64_t (**)(void))(*(void *)v83 + 136))() & 1) == 0)
      {
        unsigned int v28 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
        {
          v66 = v77;
          if (v78 < 0) {
            v66 = (void **)v77[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to create Country Bundles symlinks directory, %{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
    }
    v75[0] = 0;
    v75[1] = 0;
    uint64_t v76 = 0;
    getCountryBundlePreferencesDir(v75);
    if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 48) + 88))(*(void *)(a1 + 48), v75)) {
      goto LABEL_58;
    }
    if (checkFilePresentUsingMobileHelper((os_log_t *)(a1 + 8), v4, (uint64_t *)v75))
    {
      sub_1006AC3E0(a1, (std::string::size_type)v75);
      int v18 = 1;
    }
    uint64_t v29 = *v16;
    if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = v75;
      if (v76 < 0) {
        int v30 = (void **)v75[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Creating country bundle preferences dir %{public}s", (uint8_t *)&buf, 0xCu);
    }
    if (((*(uint64_t (**)(void))(*(void *)v83 + 136))() & 1) != 0
      || (uint64_t v31 = *v16, !os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR)))
    {
LABEL_58:
      if (!v18)
      {
LABEL_96:
        if (SHIBYTE(v76) < 0) {
          operator delete(v75[0]);
        }
        if (SHIBYTE(v78) < 0) {
          operator delete(v77[0]);
        }
        if (SHIBYTE(v80) < 0) {
          operator delete(v79[0]);
        }
        if (SHIBYTE(v82) < 0) {
          operator delete(v81[0]);
        }
        goto LABEL_104;
      }
    }
    else
    {
      uint64_t v67 = v75;
      if (v76 < 0) {
        uint64_t v67 = (void **)v75[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to create Country Bundles preferences directory, %{public}s", (uint8_t *)&buf, 0xCu);
      if ((v18 & 1) == 0) {
        goto LABEL_96;
      }
    }
    *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(&v101, 0, sizeof(v101));
    long long v100 = 0u;
    long long v99 = 0u;
    long long v98 = 0u;
    uint64_t v102 = 23;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 9;
    qmemcpy(&buf, "Telephony", 9);
    sub_10003ECB8((std::string *)&v98, "CarrierBundlePermission", 0x17uLL);
    sub_10003ECB8((std::string *)((char *)&v99 + 8), "CBRecreatBundleFolderFailureDuringInitialize", 0x2CuLL);
    sub_10003ECB8(&v101, "Carrier Bundles and/or Country Bundles folder recreated", 0x37uLL);
    v102 |= 1uLL;
    char v32 = *(std::__shared_weak_count **)(a1 + 24);
    if (v32)
    {
      int v33 = std::__shared_weak_count::lock(v32);
      uint64_t v34 = v33;
      if (v33)
      {
        uint64_t v35 = *(void *)(a1 + 16);
        atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v33);
      }
      else
      {
        uint64_t v35 = 0;
      }
    }
    else
    {
      uint64_t v35 = 0;
      uint64_t v34 = 0;
    }
    uint64_t v36 = (std::mutex *)Registry::getServiceMap(*v4);
    uint64_t v37 = v36;
    if (v38 < 0)
    {
      uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v40 = 5381;
      do
      {
        uint64_t v38 = v40;
        unsigned int v41 = *v39++;
        uint64_t v40 = (33 * v40) ^ v41;
      }
      while (v41);
    }
    std::mutex::lock(v36);
    *(void *)long long __dst = v38;
    uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)__dst);
    uint64_t v68 = v35;
    if (v42)
    {
      uint64_t v44 = v42[3];
      CFDictionaryRef v43 = (std::__shared_weak_count *)v42[4];
      if (v43)
      {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v37);
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v43);
        char v45 = 0;
        goto LABEL_72;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    std::mutex::unlock(v37);
    CFDictionaryRef v43 = 0;
    char v45 = 1;
LABEL_72:
    sub_1000DB86C(__dst, (long long *)&buf);
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v86 = 0;
    v46 = operator new(0x20uLL);
    void *v46 = off_1019F9238;
    v46[1] = a1;
    v46[2] = v68;
    v46[3] = v34;
    xpc_object_t v86 = v46;
    (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v44 + 16))(v44, __dst, v85);
    sub_1000DBADC(v85);
    if (v96 < 0) {
      operator delete(v95);
    }
    if (v94 < 0) {
      operator delete(v93);
    }
    if (v92 < 0) {
      operator delete(v91);
    }
    if (v90 < 0) {
      operator delete(v89);
    }
    if (v88 < 0)
    {
      operator delete(*(void **)__dst);
      if (v45)
      {
LABEL_84:
        if (!v34)
        {
LABEL_86:
          if (SBYTE7(v104) < 0) {
            operator delete((void *)v103);
          }
          if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v101.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v100) < 0) {
            operator delete(*((void **)&v99 + 1));
          }
          if (SBYTE7(v99) < 0) {
            operator delete((void *)v98);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          goto LABEL_96;
        }
LABEL_85:
        std::__shared_weak_count::__release_weak(v34);
        goto LABEL_86;
      }
    }
    else if (v45)
    {
      goto LABEL_84;
    }
    sub_10004D2C8(v43);
    if (!v34) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  long long v19 = *v16;
  if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to create bundle directories, MobileHelper is not found", (uint8_t *)&buf, 2u);
  }
LABEL_104:
  if (v84) {
    sub_10004D2C8(v84);
  }
  sub_10003ED78((std::string *)(a1 + 120), kSysCBDir);
  appendDeviceTypeCarrierBundleFolderLocation();
  uint64_t v47 = (char *)sub_1003F26A8();
  sub_100058DB0(&buf, v47);
  size_t v48 = strlen(kUserCBDir);
  uint64_t v49 = std::string::append(&buf, kUserCBDir, v48);
  std::string::size_type v50 = v49->__r_.__value_.__r.__words[0];
  *(void *)long long __dst = v49->__r_.__value_.__l.__size_;
  *(void *)&__dst[7] = *(std::string::size_type *)((char *)&v49->__r_.__value_.__r.__words[1] + 7);
  char v51 = HIBYTE(v49->__r_.__value_.__r.__words[2]);
  v49->__r_.__value_.__l.__size_ = 0;
  v49->__r_.__value_.__r.__words[2] = 0;
  v49->__r_.__value_.__r.__words[0] = 0;
  uint64_t v52 = (void **)(a1 + 144);
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*v52);
  }
  uint64_t v53 = *(void *)__dst;
  *(void *)(a1 + 144) = v50;
  *(void *)(a1 + 152) = v53;
  *(void *)(a1 + 159) = *(void *)&__dst[7];
  *(unsigned char *)(a1 + 167) = v51;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  appendDeviceTypeCarrierBundleFolderLocation();
  long long v54 = *v16;
  if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v55 = a1 + 120;
    if (*(char *)(a1 + 143) < 0) {
      std::string::size_type v55 = *(void *)(a1 + 120);
    }
    if (*(char *)(a1 + 167) < 0) {
      uint64_t v52 = (void **)*v52;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v55;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v52;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Using %{public}s and %{public}s for ", (uint8_t *)&buf, 0x16u);
  }
  sub_1006A1A30(a1, (const void **)(a1 + 120));
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  sub_1006A1FB0(a1, 4, 1);
  sub_1006A1FB0(a1, 1, 1);
  sub_1006A1FB0(a1, 2, 1);
  sub_1006A1FB0(a1, 3, 1);
  sub_1006A1FB0(a1, 1, 2);
  sub_1006A1FB0(a1, 2, 2);
  long long v70 = 0;
  int v69 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, const void **, int *, uint64_t))(*(void *)a1 + 24))(&v71, a1, 4, &v70, &v69, 1);
  sub_1007DE5C8((uint64_t)&v72);
  sub_100057D78(&v70);
  uint64_t v56 = a1 + 216;
  uint64_t v57 = sub_1006A29CC(v56, 4u, 1);
  uint64_t v58 = sub_1006A29CC(v56, 1u, 1);
  uint64_t v59 = sub_1006A29CC(v56, 2u, 1);
  uint64_t v60 = sub_1006A29CC(v56, 3u, 1);
  uint64_t v61 = sub_1006A29CC(v56, 1u, 2);
  uint64_t v62 = sub_1006A29CC(v56, 2u, 2);
  sub_1007DE310(a2, v57 + 88);
  sub_1007DE310(a2 + 184, v58 + 88);
  sub_1007DE310(a2 + 368, v59 + 88);
  sub_1007DE310(a2 + 552, v60 + 88);
  sub_1007DE310(a2 + 736, v61 + 88);
  return sub_1007DE310(a2 + 920, v62 + 88);
}

void sub_1006A1870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  sub_1000DBADC(&a64);
  sub_1001278A0((uint64_t)&a68);
  if ((v70 & 1) == 0) {
    sub_10004D2C8(v69);
  }
  if (v68) {
    std::__shared_weak_count::__release_weak(v68);
  }
  sub_1001278A0(v72 - 240);
  if (a43 < 0) {
    operator delete(*(void **)(v71 + 16));
  }
  if (a49 < 0) {
    operator delete(*(void **)(v71 + 40));
  }
  if (a55 < 0) {
    operator delete(*(void **)(v71 + 64));
  }
  if (a61 < 0) {
    operator delete(*(void **)(v71 + 88));
  }
  std::string v74 = *(std::__shared_weak_count **)(v71 + 120);
  if (v74) {
    sub_10004D2C8(v74);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_1006A1A30(uint64_t a1, const void **a2)
{
  memset(v44, 0, sizeof(v44));
  long long v43 = 0u;
  long long v4 = (os_log_t *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(a1 + 8);
  os_signpost_id_t v6 = os_signpost_id_generate(v5);
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    std::string::size_type v7 = *v4;
    if (os_signpost_enabled(*v4))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v8 = a2;
      }
      else {
        uint64_t v8 = (void *)*a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v6, "CarrierBundleScan", "path=%{signpost.description:attribute}s", buf, 0xCu);
    }
  }
  *(void *)std::string buf = off_1019F9138;
  v46 = buf;
  *(void *)&long long v43 = v6;
  *((void *)&v43 + 1) = os_retain(v5);
  sub_1000336E8((uint64_t)v44, (uint64_t)buf);
  sub_100033A10(buf);
  *(_OWORD *)std::string buf = 0uLL;
  uint64_t v9 = (Registry **)(a1 + 64);
  sub_100058DB0(&__p, "scan carrier bundles");
  long long v41 = v43;
  sub_1000336E8((uint64_t)&v42, (uint64_t)v44);
  long long v43 = 0uLL;
  sub_100033AF4(v44);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC((uint64_t *)&v41);
  if (v39 < 0) {
    operator delete(__p);
  }
  uint64_t v37 = 0;
  int v10 = *((char *)a2 + 23);
  if (v10 >= 0) {
    uint64_t v11 = (const UInt8 *)a2;
  }
  else {
    uint64_t v11 = (const UInt8 *)*a2;
  }
  if (v10 >= 0) {
    CFIndex v12 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    CFIndex v12 = (CFIndex)a2[1];
  }
  uint64_t v37 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v11, v12, 1u);
  sub_1004D1B74(v37, v4, (void **)v40);
  if (*(void *)v40) {
    long long v13 = sub_100083F10;
  }
  else {
    long long v13 = 0;
  }
  sub_100044D00((const void **)v40);
  char v14 = *v4;
  BOOL v15 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      if (*((char *)a2 + 23) >= 0) {
        long long v16 = a2;
      }
      else {
        long long v16 = (void *)*a2;
      }
      *(_DWORD *)uint64_t v40 = 136446210;
      *(void *)&v40[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Directory %{public}s has already been scanned, not scanning again", v40, 0xCu);
    }
    goto LABEL_65;
  }
  if (v15)
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v17 = a2;
    }
    else {
      long long v17 = (void *)*a2;
    }
    *(_DWORD *)uint64_t v40 = 136446210;
    *(void *)&v40[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Scanning for carrier bundles in %{public}s", v40, 0xCu);
  }
  uint64_t v36 = 0;
  uint64_t v18 = *((unsigned __int8 *)a2 + 23);
  if ((v18 & 0x80u) == 0) {
    long long v19 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    long long v19 = a2[1];
  }
  long long v20 = (const void *)*(unsigned __int8 *)(a1 + 167);
  int v21 = (char)v20;
  if ((char)v20 < 0) {
    long long v20 = *(const void **)(a1 + 152);
  }
  if (v19 != v20) {
    goto LABEL_45;
  }
  long long v24 = *(unsigned __int8 **)(a1 + 144);
  char v23 = (unsigned __int8 *)(a1 + 144);
  long long v22 = v24;
  if (v21 >= 0) {
    dispatch_object_t v25 = v23;
  }
  else {
    dispatch_object_t v25 = v22;
  }
  if ((v18 & 0x80) == 0)
  {
    if (*((unsigned char *)a2 + 23))
    {
      dispatch_object_t v26 = a2;
      while (*(unsigned __int8 *)v26 == *v25)
      {
        dispatch_object_t v26 = (const void **)((char *)v26 + 1);
        ++v25;
        if (!--v18) {
          goto LABEL_46;
        }
      }
      goto LABEL_45;
    }
LABEL_46:
    copyDirectoryContentsInString(v4, v9, 1, &v35);
    goto LABEL_47;
  }
  if (!memcmp(*a2, v25, (size_t)a2[1])) {
    goto LABEL_46;
  }
LABEL_45:
  copyDirectoryContentsInString(v4, v9, 0, &v35);
LABEL_47:
  *(void *)uint64_t v40 = v36;
  dispatch_object_t v27 = v35;
  uint64_t v35 = 0;
  uint64_t v36 = v27;
  sub_100044D00((const void **)v40);
  sub_100044D00(&v35);
  if (v36) {
    unsigned int v28 = sub_100083F10;
  }
  else {
    unsigned int v28 = 0;
  }
  if (v28)
  {
    uint64_t v35 = 0;
    copyURLAsString((uint64_t *)&v35, v37);
    uint64_t v29 = *v4;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        int v30 = a2;
      }
      else {
        int v30 = (void *)*a2;
      }
      *(_DWORD *)uint64_t v40 = 136446210;
      *(void *)&v40[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Saving the contents of directory %{public}s", v40, 0xCu);
    }
    uint64_t v34 = v36;
    if (v36) {
      CFRetain(v36);
    }
    CarrierBundleDevicePersistentSaveValue();
    sub_1000577C4(&v34);
    sub_1000558F4(&v35);
  }
  else
  {
    uint64_t v31 = *v4;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        char v32 = a2;
      }
      else {
        char v32 = (void *)*a2;
      }
      *(_DWORD *)uint64_t v40 = 136446210;
      *(void *)&v40[4] = v32;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Directory %{public}s contents cannot be cached", v40, 0xCu);
    }
  }
  sub_100044D00(&v36);
LABEL_65:
  sub_1000FE824((const void **)&v37);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return sub_1000339DC((uint64_t *)&v43);
}

void sub_1006A1F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, const void *a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  sub_100044D00(&a16);
  sub_1000FE824(&a17);
  uint64_t v34 = *(std::__shared_weak_count **)(v32 - 104);
  if (v34) {
    sub_10004D2C8(v34);
  }
  sub_1000339DC(&a32);
  _Unwind_Resume(a1);
}

void sub_1006A1FA0()
{
  sub_100033A10((void *)(v0 - 112));
  JUMPOUT(0x1006A1F98);
}

void sub_1006A1FB0(uint64_t a1, int a2, int a3)
{
  LODWORD(__dst.__r_.__value_.__l.__data_) = a2;
  HIDWORD(__dst.__r_.__value_.__r.__words[0]) = a3;
  *(void *)std::string buf = 0;
  *(_DWORD *)&uint8_t buf[8] = 0;
  *(_OWORD *)uint64_t v34 = 0u;
  *(_OWORD *)uint64_t v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)long long __p = 0u;
  uint64_t v38 = 0;
  sub_1007DE21C((uint64_t)v39, a1 + 64);
  sub_1006AFEC0(a1 + 216, a2, a3, (uint64_t *)&__dst, (uint64_t)buf);
  sub_1007DE5C8((uint64_t)v39);
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[1]);
  }
  if (SHIBYTE(v35[0]) < 0) {
    operator delete(v34[0]);
  }
  sub_100057D78((const void **)buf);
  uint64_t v6 = sub_1006A29CC(a1 + 216, a2, a3);
  getBundleLocation(a2, a3, buf);
  std::string::size_type v7 = (void **)(v6 + 16);
  if (*(char *)(v6 + 39) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)std::string::size_type v7 = *(_OWORD *)buf;
  *(void **)(v6 + 32) = v34[0];
  getBundlePrefsFilePath(a2, a3, (uint64_t)buf);
  uint64_t v8 = (void **)(v6 + 40);
  if (*(char *)(v6 + 63) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)uint64_t v8 = *(_OWORD *)buf;
  *(void **)(v6 + 56) = v34[0];
  getSimSlotBundlePrefsDomain(a3, a2, (uint64_t)buf);
  uint64_t v9 = (void **)(v6 + 64);
  if (*(char *)(v6 + 87) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)uint64_t v9 = *(_OWORD *)buf;
  *(void **)(v6 + 80) = v34[0];
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), v6 + 16) & 1) == 0
    && ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), v6 + 40) & 1) == 0)
  {
    int v10 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle links not found, attempting to use the legacy links", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    v34[0] = 0;
    getCarrierBundleLegacyLocation(a2, a3, (uint64_t)buf);
    memset(&__dst, 0, sizeof(__dst));
    getCarrierBundlePrefsLegacyFilePath(a2, a3, &__dst);
    if ((*(unsigned int (**)(void, uint8_t *))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), buf)
      && (*(unsigned int (**)(void, std::string *))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), &__dst))
    {
      sub_1007DE664(v6 + 88, (const std::string *)buf, &__dst);
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 48) + 144))(&__str);
      std::string::operator=((std::string *)(v6 + 224), &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      uint64_t v11 = *(void *)(a1 + 48);
      if (*(char *)(v6 + 247) < 0)
      {
        sub_10004FC84(v29, *(void **)(v6 + 224), *(void *)(v6 + 232));
      }
      else
      {
        *(_OWORD *)uint64_t v29 = *(_OWORD *)(v6 + 224);
        uint64_t v30 = *(void *)(v6 + 240);
      }
      (*(void (**)(std::string *__return_ptr, uint64_t, void **))(*(void *)v11 + 120))(&__str, v11, v29);
      *(_DWORD *)(v6 + 248) |= sub_100DBA364(&__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete(v29[0]);
      }
      sub_1007E011C(v6 + 88, (const std::string *)(v6 + 16), (std::string *)(v6 + 40));
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v34[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), v6 + 16))
  {
    sub_1007DE664(v6 + 88, (const std::string *)(v6 + 16), (const std::string *)(v6 + 40));
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 144))(buf);
    std::string::operator=((std::string *)(v6 + 224), (const std::string *)buf);
    if (SHIBYTE(v34[0]) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v12 = *(void *)(a1 + 48);
    if (*(char *)(v6 + 247) < 0) {
      sub_10004FC84(&__dst, *(void **)(v6 + 224), *(void *)(v6 + 232));
    }
    else {
      std::string __dst = *(std::string *)(v6 + 224);
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, std::string *))(*(void *)v12 + 120))(buf, v12, &__dst);
    *(_DWORD *)(v6 + 248) |= sub_100DBA364((void **)buf);
    if (SHIBYTE(v34[0]) < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    char v23 = *(NSObject **)(a1 + 8);
    int v21 = (os_log_t *)(a1 + 8);
    long long v22 = v23;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      long long v24 = sub_100DBA340(*(_DWORD *)(v6 + 248));
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Is carrier bundle's plist file overridden: %s", buf, 0xCu);
      long long v22 = *v21;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle state on CarrierBundleManager initialization", buf, 2u);
    }
    sub_1007DE920(v6 + 88, v21, 0, 1);
    return;
  }
  if (a3 == 1)
  {
    uint64_t v13 = *(void *)(a1 + 48);
    getUserBundleLegacyLocation(a2, buf);
    int v14 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v13 + 208))(v13, buf);
    int v15 = v14;
    if (SHIBYTE(v34[0]) < 0)
    {
      operator delete(*(void **)buf);
      if (v15) {
        goto LABEL_41;
      }
    }
    else if (v14)
    {
LABEL_41:
      long long v16 = (os_log_t *)(a1 + 8);
      long long v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v6 + 39) < 0) {
          std::string::size_type v7 = *(void ***)(v6 + 16);
        }
        getUserBundleLocation(a2, buf);
        if (SHIBYTE(v34[0]) >= 0) {
          uint64_t v18 = buf;
        }
        else {
          uint64_t v18 = *(uint8_t **)buf;
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136446466;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
        WORD2(__dst.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %{public}s is not a symlink. Checking if %{public}s is present. Link these parameters to slot1 bundle", (uint8_t *)&__dst, 0x16u);
        if (SHIBYTE(v34[0]) < 0) {
          operator delete(*(void **)buf);
        }
      }
      getUserBundleLocation(a2, buf);
      sub_1007DE664(v6 + 88, (const std::string *)buf, (const std::string *)(v6 + 40));
      if (SHIBYTE(v34[0]) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v19 = *(void *)(a1 + 48);
      getUserBundlePrefsLegacyFilePath(a2, &__dst);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, std::string *))(*(void *)v19 + 144))(buf, v19, &__dst);
      std::string::operator=((std::string *)(v6 + 224), (const std::string *)buf);
      if (SHIBYTE(v34[0]) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v20 = *(void *)(a1 + 48);
      if (*(char *)(v6 + 247) < 0) {
        sub_10004FC84(&__dst, *(void **)(v6 + 224), *(void *)(v6 + 232));
      }
      else {
        std::string __dst = *(std::string *)(v6 + 224);
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, std::string *))(*(void *)v20 + 120))(buf, v20, &__dst);
      *(_DWORD *)(v6 + 248) |= sub_100DBA364((void **)buf);
      if (SHIBYTE(v34[0]) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      dispatch_object_t v27 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v28 = sub_100DBA340(*(_DWORD *)(v6 + 248));
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Is carrier bundle's plist file overridden: %s", buf, 0xCu);
        dispatch_object_t v27 = *v16;
      }
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle state on CarrierBundleManager initialization", buf, 2u);
      }
      sub_1007DE920(v6 + 88, v16, 0, 1);
      return;
    }
  }
  dispatch_object_t v25 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v6 + 39) >= 0) {
      uint64_t v26 = v6 + 16;
    }
    else {
      uint64_t v26 = *(void *)(v6 + 16);
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N %{public}s is not a symlink, ignoring", buf, 0xCu);
  }
}

void sub_1006A28AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006A29CC(uint64_t a1, unsigned __int8 a2, int a3)
{
  uint64_t v3 = *sub_1006B005C(a1, &v5, a2, a3);
  if (!v3) {
    sub_1000C14F0("map::at:  key not found");
  }
  return v3 + 40;
}

void sub_1006A2A10(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = (NSObject **)(a1 + 8);
  long long v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Initializing CountryBundle Locations", (uint8_t *)&buf, 2u);
  }
  uint64_t v6 = (void *)(a1 + 168);
  sub_10003ED78((std::string *)(a1 + 168), kSysCountryBundleDir);
  appendDeviceTypeCarrierBundleFolderLocation();
  std::string::size_type v7 = (char *)sub_1003F26A8();
  sub_100058DB0(&buf, v7);
  size_t v8 = strlen(kUserCountryBundleDir);
  uint64_t v9 = std::string::append(&buf, kUserCountryBundleDir, v8);
  std::string::size_type v10 = v9->__r_.__value_.__r.__words[0];
  __p[0] = (void *)v9->__r_.__value_.__l.__size_;
  *(void **)((char *)__p + 7) = *(void **)((char *)&v9->__r_.__value_.__r.__words[1] + 7);
  char v11 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = (void **)(a1 + 192);
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*v12);
  }
  uint64_t v13 = __p[0];
  *(void *)(a1 + 192) = v10;
  *(void *)(a1 + 200) = v13;
  *(void **)(a1 + 207) = *(void **)((char *)__p + 7);
  *(unsigned char *)(a1 + 215) = v11;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  appendDeviceTypeCarrierBundleFolderLocation();
  int v14 = *v5;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 191) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    if (*(char *)(a1 + 215) < 0) {
      uint64_t v12 = (void **)*v12;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v12;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Using %{public}s and %{public}s for respective locations", (uint8_t *)&buf, 0x16u);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
  sub_1006A2EA8(a1, 5u, 1);
  sub_1006A2EA8(a1, 5u, 2);
  sub_1006A2EA8(a1, 6u, 1);
  sub_1006A2EA8(a1, 6u, 2);
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  sub_100058DB0(__p, off_101B0AFA8[0]);
  uint64_t v15 = a1 + 216;
  uint64_t v16 = sub_1006A29CC(v15, 5u, 1);
  sub_1006B0198((uint64_t)&buf, (long long *)__p, v16 + 88);
  sub_1006B1A20((uint64_t)a2, (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
  sub_1007DE5C8((uint64_t)v23);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, off_101B0AFB8[0]);
  uint64_t v17 = sub_1006A29CC(v15, 5u, 2);
  sub_1006B0198((uint64_t)&buf, (long long *)__p, v17 + 88);
  sub_1006B1A20((uint64_t)a2, (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
  sub_1007DE5C8((uint64_t)v23);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, off_101B0AFB0[0]);
  uint64_t v18 = sub_1006A29CC(v15, 6u, 1);
  sub_1006B0198((uint64_t)&buf, (long long *)__p, v18 + 88);
  sub_1006B1A20((uint64_t)a2, (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
  sub_1007DE5C8((uint64_t)v23);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, off_101B0AFC0[0]);
  uint64_t v19 = sub_1006A29CC(v15, 6u, 2);
  sub_1006B0198((uint64_t)&buf, (long long *)__p, v19 + 88);
  sub_1006B1A20((uint64_t)a2, (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
  sub_1007DE5C8((uint64_t)v23);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006A2E24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1006A3320((uint64_t)&a16);
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1006B1974(v21, *(void **)(v21 + 8));
  _Unwind_Resume(a1);
}

void sub_1006A2EA8(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v3 = a3;
  v17[0] = (void *)(a2 | (unint64_t)(a3 << 32));
  *(void *)std::string __str = 0;
  *(_DWORD *)&__str[8] = 0;
  *(_OWORD *)&__str[16] = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)long long __p = 0u;
  uint64_t v23 = 0;
  sub_1007DE21C((uint64_t)v24, a1 + 64);
  sub_1006AFEC0(a1 + 216, a2, v3, (uint64_t *)v17, (uint64_t)__str);
  sub_1007DE5C8((uint64_t)v24);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  if (SHIBYTE(v20[0]) < 0) {
    operator delete(*(void **)&__str[16]);
  }
  sub_100057D78((const void **)__str);
  uint64_t v6 = sub_1006A29CC(a1 + 216, a2, v3);
  getBundleLocation(a2, v3, __str);
  std::string::size_type v7 = (void **)(v6 + 16);
  if (*(char *)(v6 + 39) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)std::string::size_type v7 = *(_OWORD *)__str;
  *(void *)(v6 + 32) = *(void *)&__str[16];
  getBundlePrefsFilePath(a2, v3, (uint64_t)__str);
  size_t v8 = (void **)(v6 + 40);
  if (*(char *)(v6 + 63) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)size_t v8 = *(_OWORD *)__str;
  *(void *)(v6 + 56) = *(void *)&__str[16];
  getSimSlotBundlePrefsDomain(v3, a2, (uint64_t)__str);
  uint64_t v9 = (void **)(v6 + 64);
  if (*(char *)(v6 + 87) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)uint64_t v9 = *(_OWORD *)__str;
  *(void *)(v6 + 80) = *(void *)&__str[16];
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), v6 + 16))
  {
    sub_1007DE664(v6 + 88, (const std::string *)(v6 + 16), (const std::string *)(v6 + 40));
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 48) + 144))(__str);
    std::string::operator=((std::string *)(v6 + 224), (const std::string *)__str);
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
    uint64_t v10 = *(void *)(a1 + 48);
    if (*(char *)(v6 + 247) < 0)
    {
      sub_10004FC84(v17, *(void **)(v6 + 224), *(void *)(v6 + 232));
    }
    else
    {
      *(_OWORD *)uint64_t v17 = *(_OWORD *)(v6 + 224);
      uint64_t v18 = *(void *)(v6 + 240);
    }
    (*(void (**)(unsigned char *__return_ptr, uint64_t, void **))(*(void *)v10 + 120))(__str, v10, v17);
    *(_DWORD *)(v6 + 248) |= sub_100DBA364((void **)__str);
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    uint64_t v15 = *(NSObject **)(a1 + 8);
    uint64_t v13 = (os_log_t *)(a1 + 8);
    int v14 = v15;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = sub_100DBA340(*(_DWORD *)(v6 + 248));
      *(_DWORD *)std::string __str = 136315138;
      *(void *)&__str[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Is carrier bundle's plist file overridden: %s", __str, 0xCu);
      int v14 = *v13;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __str = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle state on CarrierBundleManager initialization", __str, 2u);
    }
    sub_1007DE920(v6 + 88, v13, 0, 1);
  }
  else
  {
    char v11 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v6 + 39) >= 0) {
        uint64_t v12 = v6 + 16;
      }
      else {
        uint64_t v12 = *(void *)(v6 + 16);
      }
      *(_DWORD *)std::string __str = 136446210;
      *(void *)&__str[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N %{public}s is not a symlink, ignoring", __str, 0xCu);
    }
  }
}

void sub_1006A3280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006A3320(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL sub_1006A335C(uint64_t a1, CFDictionaryRef theDict, int a3, uint64_t a4, char a5)
{
  Value = CFDictionaryGetValue(theDict, (const void *)qword_101B13ED0);
  if (Value)
  {
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 == CFStringGetTypeID()) {
      return 0;
    }
  }
  CFMutableDictionaryRef theDicta = 0;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v13 = theDicta;
    CFMutableDictionaryRef theDicta = Mutable;
    CFMutableDictionaryRef v17 = v13;
    sub_10005717C((const void **)&v17);
  }
  CFDictionarySetValue(theDicta, (const void *)qword_101B13EC0, @"Unknown.bundle");
  sub_10004EFE4(&v15, (CFTypeRef *)&theDicta);
  BOOL v11 = sub_1006A3488(a1, (const __CFDictionary **)&v15, a3, a4, a5);
  sub_100057D78(&v15);
  sub_10005717C((const void **)&theDicta);
  return v11;
}

void sub_1006A3464(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL sub_1006A3488(uint64_t a1, const __CFDictionary **a2, int a3, uint64_t a4, char a5)
{
  std::string::size_type v7 = a2;
  char v80 = a5;
  long long v79 = 0u;
  long long v77 = 0u;
  memset(v78, 0, sizeof(v78));
  memset(v76, 0, sizeof(v76));
  *(void *)long long v75 = 0;
  sub_1004D384C(*a2, (const void **)v75);
  CFURLRef v74 = 0;
  copyURLForPath();
  CFURLRef v73 = 0;
  copyURLForPath();
  if ((a3 - 5) <= 1)
  {
    copyURLForPath();
    *(void *)std::string buf = v74;
    CFURLRef v74 = (const __CFURL *)v85.__r_.__value_.__r.__words[0];
    v85.__r_.__value_.__r.__words[0] = 0;
    sub_1000FE824((const void **)buf);
    sub_1000FE824((const void **)&v85.__r_.__value_.__l.__data_);
    copyURLForPath();
    *(void *)std::string buf = v73;
    CFURLRef v73 = (const __CFURL *)v85.__r_.__value_.__r.__words[0];
    v85.__r_.__value_.__r.__words[0] = 0;
    sub_1000FE824((const void **)buf);
    sub_1000FE824((const void **)&v85.__r_.__value_.__l.__data_);
  }
  CFTypeID v10 = (os_log_t *)(a1 + 8);
  uint64_t v9 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ********** System Bundle Lookup *********", buf, 2u);
  }
  sub_1006A4A38((const void **)buf, (os_log_t *)(a1 + 8), (Registry **)(a1 + 64), *(const __CFString **)v75, *v7, v74, v80);
  sub_1006A5E9C((uint64_t)v78, (uint64_t)buf);
  sub_1006A5E9C((uint64_t)&v78[5], (uint64_t)v71);
  if (v72) {
    sub_10004D2C8(v72);
  }
  sub_1000FE824(v71);
  if (v70) {
    sub_10004D2C8(v70);
  }
  sub_1000FE824((const void **)buf);
  BOOL v11 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I *********** User Bundle Lookup **********", buf, 2u);
  }
  sub_1006A4A38((const void **)buf, (os_log_t *)(a1 + 8), (Registry **)(a1 + 64), *(const __CFString **)v75, *v7, v73, v80);
  sub_1006A5E9C((uint64_t)v76, (uint64_t)buf);
  sub_1006A5E9C((uint64_t)&v76[5], (uint64_t)v71);
  if (v72) {
    sub_10004D2C8(v72);
  }
  sub_1000FE824(v71);
  if (v70) {
    sub_10004D2C8(v70);
  }
  sub_1000FE824((const void **)buf);
  if (v78[5]) {
    uint64_t v12 = sub_1000FCC20;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    char v70 = 0;
    *(_OWORD *)std::string buf = 0u;
    long long v69 = 0u;
    if (v76[5]) {
      CFMutableDictionaryRef v13 = sub_1000FCC20;
    }
    else {
      CFMutableDictionaryRef v13 = 0;
    }
    if (v13)
    {
      uint64_t v62 = v7;
      *((void *)&v87 + 1) = 0;
      uint64_t v88 = 0;
      *(void *)&long long v87 = (char *)&v87 + 8;
      memset(&v85, 0, sizeof(v85));
      int v14 = operator new(0x20uLL);
      *int v14 = off_1019F8F20;
      v14[1] = &v87;
      xpc_object_t v14[2] = &v80;
      void v14[3] = a1;
      xpc_object_t v86 = v14;
      sub_1006B216C((uint64_t)v14, (uint64_t)&v78[5]);
      if (!v86
        || ((*(void (**)(void *, const void **))(*v86 + 48))(v86, v78), !v86)
        || ((*(void (**)(void *, const void **))(*v86 + 48))(v86, &v76[5]), !v86))
      {
        sub_10007B600();
      }
      (*(void (**)(void *, const void **))(*v86 + 48))(v86, v76);
      uint64_t v61 = a4;
      v65 = 0;
      v66 = 0;
      uint64_t v67 = 0;
      uint64_t v15 = (_OWORD *)v87;
      if ((long long *)v87 != (long long *)((char *)&v87 + 8))
      {
        uint64_t v16 = 0;
        while (1)
        {
          if (v16 < v67)
          {
            sub_100119B5C(v16, (const void **)v15 + 7);
            CFMutableDictionaryRef v17 = (const void *)*((void *)v15 + 8);
            *((unsigned char *)v16 + 16) = *((unsigned char *)v15 + 72);
            v16[1] = v17;
            v16[3] = (const void *)*((void *)v15 + 10);
            uint64_t v18 = (atomic_ullong *)*((void *)v15 + 11);
            v16[4] = v18;
            if (v18) {
              atomic_fetch_add_explicit(v18 + 1, 1uLL, memory_order_relaxed);
            }
            v16 += 5;
            goto LABEL_56;
          }
          unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * (v16 - v65);
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0x666666666666666) {
            sub_10006A748();
          }
          if (0x999999999999999ALL * (v67 - v65) > v20) {
            unint64_t v20 = 0x999999999999999ALL * (v67 - v65);
          }
          if (0xCCCCCCCCCCCCCCCDLL * (v67 - v65) >= 0x333333333333333) {
            unint64_t v21 = 0x666666666666666;
          }
          else {
            unint64_t v21 = v20;
          }
          if (v21)
          {
            if (v21 > 0x666666666666666) {
              sub_10006A7CC();
            }
            long long v22 = (const void **)operator new(40 * v21);
          }
          else
          {
            long long v22 = 0;
          }
          uint64_t v23 = sub_100119B5C(&v22[5 * v19], (const void **)v15 + 7);
          long long v24 = (const void *)*((void *)v15 + 8);
          *((unsigned char *)v23 + 16) = *((unsigned char *)v15 + 72);
          v23[1] = v24;
          v23[3] = (const void *)*((void *)v15 + 10);
          dispatch_object_t v25 = (atomic_ullong *)*((void *)v15 + 11);
          v23[4] = v25;
          if (v25) {
            atomic_fetch_add_explicit(v25 + 1, 1uLL, memory_order_relaxed);
          }
          uint64_t v26 = &v22[5 * v21];
          uint64_t v16 = v23 + 5;
          dispatch_object_t v27 = (char *)v65;
          unsigned int v28 = v66;
          if (v66 == v65)
          {
            v65 = v23;
            v66 = v23 + 5;
            uint64_t v67 = v26;
          }
          else
          {
            uint64_t v29 = v10;
            do
            {
              uint64_t v30 = v23;
              uint64_t v31 = v28 - 5;
              uint64_t v23 = sub_100119B5C(v23 - 5, v28 - 5);
              uint64_t v32 = *(v28 - 4);
              *((unsigned char *)v30 - 24) = *((unsigned char *)v28 - 24);
              *(v30 - 4) = v32;
              *(v30 - 2) = *(v28 - 2);
              int v33 = (atomic_ullong *)*(v28 - 1);
              *(v30 - 1) = v33;
              if (v33) {
                atomic_fetch_add_explicit(v33 + 1, 1uLL, memory_order_relaxed);
              }
              v28 -= 5;
            }
            while (v31 != (const void **)v27);
            unsigned int v28 = v65;
            uint64_t v34 = (uint64_t)v66;
            v65 = v23;
            v66 = v16;
            uint64_t v67 = v26;
            CFTypeID v10 = v29;
            if ((const void **)v34 != v28)
            {
              do
              {
                v34 -= 40;
                sub_1006A5EFC(v34);
              }
              while ((const void **)v34 != v28);
              if (!v28) {
                goto LABEL_56;
              }
LABEL_55:
              operator delete(v28);
              goto LABEL_56;
            }
          }
          if (v28) {
            goto LABEL_55;
          }
LABEL_56:
          v66 = v16;
          uint64_t v35 = (void *)*((void *)v15 + 1);
          if (v35)
          {
            do
            {
              long long v36 = v35;
              uint64_t v35 = (void *)*v35;
            }
            while (v35);
          }
          else
          {
            do
            {
              long long v36 = (_OWORD *)*((void *)v15 + 2);
              BOOL v37 = *(void *)v36 == (void)v15;
              uint64_t v15 = v36;
            }
            while (!v37);
          }
          uint64_t v15 = v36;
          if (v36 == (long long *)((char *)&v87 + 8))
          {
            uint64_t v38 = (uint64_t)v65;
            goto LABEL_79;
          }
        }
      }
      uint64_t v16 = 0;
      uint64_t v38 = 0;
LABEL_79:
      unint64_t v43 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v16 - v38) >> 3));
      if (v16 == (const void **)v38) {
        uint64_t v44 = 0;
      }
      else {
        uint64_t v44 = v43;
      }
      sub_1006B0230(v38, v16, v44, 1);
      a4 = v61;
      std::string::size_type v7 = v62;
      char v45 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v81 = 134217984;
        *(void *)&v81[4] = 0xCCCCCCCCCCCCCCCDLL * (v66 - v65);
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I List of candidates in the order to preference, size: %zu", v81, 0xCu);
      }
      uint64_t v46 = (uint64_t)v65;
      if (v65 != v66)
      {
        do
        {
          uint64_t v47 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            sub_1006A5C38(v81, v46);
            size_t v48 = v82 >= 0 ? v81 : *(unsigned char **)v81;
            *(_DWORD *)uint64_t v83 = 136315138;
            uint64_t v84 = v48;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s", v83, 0xCu);
            if (v82 < 0) {
              operator delete(*(void **)v81);
            }
          }
          v46 += 40;
        }
        while ((const void **)v46 != v66);
        uint64_t v49 = v65;
        std::string::size_type v7 = v62;
        if (v66 != v65)
        {
          for (i = v65 + 5; i != v66; i += 5)
          {
            if (sub_1006B10C0(v49, i)) {
              uint64_t v49 = i;
            }
          }
          sub_1006A5E9C((uint64_t)buf, (uint64_t)v49);
        }
      }
      *(void *)v81 = &v65;
      sub_1006B1630((void ***)v81);
      sub_1006B287C(&v85);
      sub_1006B2014(*((void **)&v87 + 1));
      goto LABEL_100;
    }
    uint64_t v42 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v85.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I No match in user's, choosing System match", (uint8_t *)&v85, 2u);
    }
    if (v80) {
      long long v41 = &v78[5];
    }
    else {
      long long v41 = v78;
    }
LABEL_77:
    sub_1006A5E9C((uint64_t)buf, (uint64_t)v41);
LABEL_100:
    char v51 = *(__CFURL **)buf;
    if (*(void *)buf) {
      uint64_t v52 = sub_1000FCC20;
    }
    else {
      uint64_t v52 = 0;
    }
    BOOL v53 = v52 != 0;
    if (v52)
    {
      memset(&v85, 0, sizeof(v85));
      long long v64 = *(__CFURL **)buf;
      if (*(void *)buf)
      {
        CFRetain(*(CFTypeRef *)buf);
        char v51 = v64;
      }
      asString(v51, (uint64_t)&v85);
      sub_1000FE824((const void **)&v64);
      long long v54 = *v10;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v55 = &v85;
        if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v55 = (std::string *)v85.__r_.__value_.__r.__words[0];
        }
        LODWORD(v87) = 136315138;
        *(void *)((char *)&v87 + 4) = v55;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Best match URL: %s", (uint8_t *)&v87, 0xCu);
      }
      sub_1007DE874(a4, &v85);
      sub_100058198((const void **)&theDict, (const void **)v7);
      Value = CFDictionaryGetValue(theDict, (const void *)qword_101B13ED0);
      if (Value && (CFTypeID v57 = CFGetTypeID(Value), v57 == CFStringGetTypeID())) {
        char v58 = 2;
      }
      else {
        char v58 = 1;
      }
      *(unsigned char *)(a4 + 164) = v58;
      sub_100057D78((const void **)&theDict);
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v85.__r_.__value_.__l.__data_);
      }
    }
    if (v70) {
      sub_10004D2C8(v70);
    }
    sub_1000FE824((const void **)buf);
    goto LABEL_119;
  }
  if (v76[5]) {
    char v39 = sub_1000FCC20;
  }
  else {
    char v39 = 0;
  }
  if (v39)
  {
    char v70 = 0;
    *(_OWORD *)std::string buf = 0u;
    long long v69 = 0u;
    uint64_t v40 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v85.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I No match in System's, choosing user match", (uint8_t *)&v85, 2u);
    }
    if (v80) {
      long long v41 = &v76[5];
    }
    else {
      long long v41 = v76;
    }
    goto LABEL_77;
  }
  uint64_t v60 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "No matching bundle found in System or user directories", buf, 2u);
  }
  BOOL v53 = 0;
LABEL_119:
  sub_1000FE824((const void **)&v73);
  sub_1000FE824((const void **)&v74);
  sub_1000558F4((const void **)v75);
  if (*((void *)&v77 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v77 + 1));
  }
  sub_1000FE824(&v76[5]);
  if (v76[4]) {
    sub_10004D2C8((std::__shared_weak_count *)v76[4]);
  }
  sub_1000FE824(v76);
  if (*((void *)&v79 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v79 + 1));
  }
  sub_1000FE824(&v78[5]);
  if (v78[4]) {
    sub_10004D2C8((std::__shared_weak_count *)v78[4]);
  }
  sub_1000FE824(v78);
  return v53;
}

void sub_1006A3F14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006A4008@<X0>(uint64_t a1@<X0>, int a2@<W1>, const void **a3@<X2>, BOOL *a4@<X8>)
{
  size_t v8 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I ================================= Lookup Bundle for %s =================================", buf, 0xCu);
  }
  sub_100058198(&v13, a3);
  sub_1006A41E4(a1, (CFDictionaryRef *)&v13);
  sub_100057D78(&v13);
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_1007DE21C((uint64_t)buf, a1 + 64);
  sub_100058198(&v12, a3);
  if (sub_1006A3488(a1, (const __CFDictionary **)&v12, a2, (uint64_t)buf, 1))
  {
    BOOL v9 = 1;
  }
  else
  {
    sub_100058198((const void **)&theDict, a3);
    BOOL v9 = sub_1006A335C(a1, theDict, a2, (uint64_t)buf, 1);
    sub_100057D78((const void **)&theDict);
  }
  sub_100057D78(&v12);
  *a4 = v9;
  sub_1007DE310((uint64_t)(a4 + 8), (uint64_t)buf);
  return sub_1007DE5C8((uint64_t)buf);
}

void sub_1006A4198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  uint64_t v7 = va_arg(va2, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1007DE5C8((uint64_t)va2);
  _Unwind_Resume(a1);
}

void sub_1006A41E4(uint64_t a1, CFDictionaryRef *a2)
{
  CFDictionaryRef v2 = *a2;
  if (*a2) {
    int v3 = sub_100080778;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    bzero(buffer, 0x400uLL);
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v57) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ---Begin Carrier Info for Bundle Matching---", (uint8_t *)&v57, 2u);
      uint64_t v6 = *(NSObject **)(a1 + 8);
      CFDictionaryRef v2 = *a2;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex Count = CFDictionaryGetCount(v2);
      int v57 = 134217984;
      char v58 = (char *)Count;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Number of key-values: %zu", (uint8_t *)&v57, 0xCu);
      CFDictionaryRef v2 = *a2;
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, @"HomeBundleIdentifier");
    if (Value)
    {
      CFStringRef v9 = Value;
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v9, buffer, 1024, 0x8000100u))
        {
          BOOL v11 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136446210;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I HomeBundleIdentifier = '%{public}s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(*a2, (const void *)qword_101B13ED0);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v13, buffer, 1024, 0x8000100u))
        {
          long long v15 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136446210;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Carrier ID = '%{public}s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(*a2, @"MCC");
    if (v16)
    {
      CFStringRef v17 = v16;
      CFTypeID v18 = CFGetTypeID(v16);
      if (v18 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v17, buffer, 1024, 0x8000100u))
        {
          long long v19 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I MCC = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v20 = (const __CFString *)CFDictionaryGetValue(*a2, @"MNC");
    if (v20)
    {
      CFStringRef v21 = v20;
      CFTypeID v22 = CFGetTypeID(v20);
      if (v22 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v21, buffer, 1024, 0x8000100u))
        {
          long long v23 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I MNC = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(*a2, @"GID1");
    if (v24)
    {
      CFStringRef v25 = v24;
      CFTypeID v26 = CFGetTypeID(v24);
      if (v26 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v25, buffer, 1024, 0x8000100u))
        {
          dispatch_object_t v27 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I GID1 = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v28 = (const __CFString *)CFDictionaryGetValue(*a2, @"GwGID1");
    if (v28)
    {
      CFStringRef v29 = v28;
      CFTypeID v30 = CFGetTypeID(v28);
      if (v30 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v29, buffer, 1024, 0x8000100u))
        {
          uint64_t v31 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Gw GID1 = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v32 = (const __CFString *)CFDictionaryGetValue(*a2, @"GID2");
    if (v32)
    {
      CFStringRef v33 = v32;
      CFTypeID v34 = CFGetTypeID(v32);
      if (v34 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v33, buffer, 1024, 0x8000100u))
        {
          uint64_t v35 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I GID2 = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v36 = (const __CFString *)CFDictionaryGetValue(*a2, @"GwGID2");
    if (v36)
    {
      CFStringRef v37 = v36;
      CFTypeID v38 = CFGetTypeID(v36);
      if (v38 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v37, buffer, 1024, 0x8000100u))
        {
          char v39 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Gw GID2 = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(*a2, (const void *)qword_101B13EB8);
    if (v40)
    {
      CFStringRef v41 = v40;
      CFTypeID v42 = CFGetTypeID(v40);
      if (v42 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v41, buffer, 1024, 0x8000100u))
        {
          unint64_t v43 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I ICCID = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v44 = (const __CFString *)CFDictionaryGetValue(*a2, (const void *)qword_101B13EC0);
    if (v44)
    {
      CFStringRef v45 = v44;
      CFTypeID v46 = CFGetTypeID(v44);
      if (v46 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v45, buffer, 1024, 0x8000100u))
        {
          uint64_t v47 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I IMSI = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v48 = (const __CFString *)CFDictionaryGetValue(*a2, @"1xIMSI");
    if (v48)
    {
      CFStringRef v49 = v48;
      CFTypeID v50 = CFGetTypeID(v48);
      if (v50 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v49, buffer, 1024, 0x8000100u))
        {
          char v51 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I 1x IMSI = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    CFStringRef v52 = (const __CFString *)CFDictionaryGetValue(*a2, @"GwIMSI");
    if (v52)
    {
      CFStringRef v53 = v52;
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 == CFStringGetTypeID())
      {
        if (CFStringGetCString(v53, buffer, 1024, 0x8000100u))
        {
          std::string::size_type v55 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            int v57 = 136315138;
            char v58 = buffer;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Gw IMSI = '%s'", (uint8_t *)&v57, 0xCu);
          }
        }
      }
    }
    uint64_t v56 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v57) = 0;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I ---End of Carrier Info---", (uint8_t *)&v57, 2u);
    }
  }
}

const void **sub_1006A4A38(const void **result, os_log_t *a2, Registry **a3, const __CFString *a4, CFDictionaryRef theDict, const __CFURL *a6, char a7)
{
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *(_OWORD *)__n128 result = 0u;
  if (!a4 || !theDict || !a6) {
    return result;
  }
  uint64_t v13 = (uint64_t)result;
  CFStringRef Value = CFDictionaryGetValue(theDict, (const void *)qword_101B13ED0);
  long long v15 = Value;
  if (Value)
  {
    CFTypeID v16 = CFGetTypeID(Value);
    if (v16 == CFStringGetTypeID()) {
      CFStringRef v17 = v15;
    }
    else {
      CFStringRef v17 = 0;
    }
  }
  else
  {
    CFStringRef v17 = 0;
  }
  CFTypeID v18 = CFDictionaryGetValue(theDict, @"HomeBundleIdentifier");
  if (!v18)
  {
    if (!v17) {
      goto LABEL_49;
    }
LABEL_30:
    CFTypeRef cf = 0;
    CFArrayRef theArray = 0;
    if (CFStringGetLength(a4) < 1)
    {
      uint64_t v60 = *a2;
      double v36 = 0.0;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v102 = 0;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Invalid prefix provided to search for best match with SIM Info", v102, 2u);
      }
      goto LABEL_105;
    }
    CFStringRef theString2 = 0;
    sub_1004D0FD0(a6, a2, a3, a4, (uint8_t *)&theString2);
    if (theString2) {
      CFStringRef v28 = sub_100083F10;
    }
    else {
      CFStringRef v28 = 0;
    }
    if (v28)
    {
      if (CFArrayGetCount((CFArrayRef)theString2) == 1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)theString2, 0);
        *(void *)uint64_t v102 = 0;
        CFTypeID v30 = (const void **)sub_1006B1DDC(v102, ValueAtIndex);
        CFArrayRef v31 = theArray;
        CFArrayRef theArray = *(CFArrayRef *)v102;
        *(void *)uint64_t v102 = v31;
        sub_1000FE824(v30);
        sub_1003C4D24(&cf, (const void **)&theArray);
        CFStringRef v32 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          memset(v102, 0, sizeof(v102));
          uint64_t v103 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long v100 = *(_OWORD *)v102;
          uint64_t v101 = v103;
          CFStringRef v33 = (const void **)theArray;
          if (v103 >= 0) {
            CFTypeID v34 = v100;
          }
          else {
            CFTypeID v34 = (CFTypeRef *)v100[0];
          }
          *(void *)uint64_t v91 = theArray;
          if (theArray)
          {
            CFRetain(theArray);
            CFStringRef v33 = *(const void ***)v91;
          }
          copyFileName(v33, (CFStringRef *)&v92);
          memset(v102, 0, sizeof(v102));
          uint64_t v103 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long __p = *(_OWORD *)v102;
          *(void *)&__p[16] = v103;
          uint64_t v35 = __p;
          if (v103 < 0) {
            uint64_t v35 = *(unsigned char **)__p;
          }
          *(_DWORD *)std::string buf = 136446466;
          *(void *)&uint8_t buf[4] = v34;
          __int16 v98 = 2082;
          long long v99 = v35;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Best match for the given Carrier ID and prefix '%{public}s': '%{public}s'", buf, 0x16u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          sub_1000558F4((const void **)&v92);
          sub_1000FE824((const void **)v91);
          if (SHIBYTE(v101) < 0) {
            operator delete((void *)v100[0]);
          }
        }
        double v36 = 50.0;
        goto LABEL_104;
      }
      os_log_t v65 = *a2;
      double v36 = 0.0;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)theString2);
        *(_DWORD *)uint64_t v102 = 134217984;
        *(void *)&v102[4] = Count;
        uint64_t v62 = "#I No Unique match found for CarrierBundle = %zu";
        long long v63 = v65;
        uint32_t v64 = 12;
        goto LABEL_103;
      }
    }
    else
    {
      os_log_t v61 = *a2;
      double v36 = 0.0;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v102 = 0;
        uint64_t v62 = "#I No candidates were found in the collection";
        long long v63 = v61;
        uint32_t v64 = 2;
LABEL_103:
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, v62, v102, v64);
      }
    }
LABEL_104:
    sub_100044D00((const void **)&theString2);
LABEL_105:
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v84 = 0u;
    *(void *)long long __p = theArray;
    if (theArray) {
      CFRetain(theArray);
    }
    *(void *)std::string buf = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_1006B1E38((uint64_t)&v84, a3, (const void **)__p, (const void **)buf, v36, v36);
    sub_1000FE824((const void **)buf);
    sub_1000FE824((const void **)__p);
    uint64_t v67 = *a2;
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      sub_1006B1B88(v102, (uint64_t)&v84);
      uint64_t v68 = v103 >= 0 ? v102 : *(uint8_t **)v102;
      LODWORD(v100[0]) = 136446210;
      *(CFTypeRef *)((char *)v100 + 4) = v68;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I Returning bundle match: %{public}s", (uint8_t *)v100, 0xCu);
      if (SHIBYTE(v103) < 0) {
        operator delete(*(void **)v102);
      }
    }
    sub_1000FE824(&cf);
    p_CFArrayRef theArray = (const void **)&theArray;
    goto LABEL_175;
  }
  CFTypeID v19 = CFGetTypeID(v18);
  CFTypeID TypeID = CFStringGetTypeID();
  if (v17) {
    goto LABEL_30;
  }
  if (v19 == TypeID)
  {
    *(void *)std::string buf = 0;
    if (CFStringGetLength(a4) <= 0)
    {
      long long v84 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      *(void *)long long __p = *(void *)buf;
      CFArrayRef theArray = 0;
      sub_1006B1E38((uint64_t)&v84, a3, (const void **)__p, (const void **)&theArray, 0.0, 0.0);
      sub_1000FE824((const void **)&theArray);
      sub_1000FE824((const void **)__p);
      uint64_t v78 = *a2;
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        sub_1006B1B88(v102, (uint64_t)&v84);
        long long v79 = v103 >= 0 ? v102 : *(uint8_t **)v102;
        LODWORD(v100[0]) = 136446210;
        *(CFTypeRef *)((char *)v100 + 4) = v79;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Invalid homeBundleIdentifierFromMatchInfo provided to search for best match with SIM Info. Returning bundle match: %{public}s", (uint8_t *)v100, 0xCu);
        if (SHIBYTE(v103) < 0) {
          operator delete(*(void **)v102);
        }
      }
      goto LABEL_174;
    }
    CFArrayRef theArray = 0;
    sub_1004D0FD0(a6, a2, a3, a4, (uint8_t *)&theArray);
    if (theArray) {
      CFStringRef v21 = sub_100083F10;
    }
    else {
      CFStringRef v21 = 0;
    }
    if (v21 && CFArrayGetCount(theArray) > 0)
    {
      CFIndex v22 = CFArrayGetCount(theArray);
      double v23 = 0.0;
      if (v22 >= 1)
      {
        CFIndex v24 = 0;
        while (1)
        {
          CFTypeRef cf = 0;
          CFStringRef v25 = CFArrayGetValueAtIndex(theArray, v24);
          sub_1006B1DDC(&cf, v25);
          CFTypeID v26 = (const void **)cf;
          char v92 = (__CFURL *)cf;
          CFStringRef theString2 = 0;
          if (cf)
          {
            CFRetain(cf);
            CFTypeID v26 = (const void **)v92;
          }
          copyFileName(v26, &theString2);
          sub_1000FE824((const void **)&v92);
          dispatch_object_t v27 = theString2 ? sub_1000810B8 : 0;
          if (v27 && CFStringCompare(a4, theString2, 1uLL) == kCFCompareEqualTo) {
            break;
          }
          sub_1000558F4((const void **)&theString2);
          sub_1000FE824(&cf);
          if (v22 == ++v24) {
            goto LABEL_162;
          }
        }
        sub_1003C4D24((const void **)buf, &cf);
        char v80 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          v81 = *(const void ***)buf;
          char v90 = *(__CFURL **)buf;
          if (*(void *)buf)
          {
            CFRetain(*(CFTypeRef *)buf);
            v81 = (const void **)v90;
          }
          copyFileName(v81, (CFStringRef *)v91);
          memset(v102, 0, sizeof(v102));
          uint64_t v103 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long v100 = *(_OWORD *)v102;
          uint64_t v101 = v103;
          char v82 = v100;
          if (v103 < 0) {
            char v82 = (CFTypeRef *)v100[0];
          }
          *(_DWORD *)long long __p = 138543618;
          *(void *)&__p[4] = a4;
          *(_WORD *)&__p[12] = 2082;
          *(void *)&__p[14] = v82;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I Best match for the given Home Bundle Identifier '%{public}@': '%{public}s'", __p, 0x16u);
          if (SHIBYTE(v101) < 0) {
            operator delete((void *)v100[0]);
          }
          sub_1000558F4((const void **)v91);
          sub_1000FE824((const void **)&v90);
        }
        sub_1000558F4((const void **)&theString2);
        sub_1000FE824(&cf);
        double v23 = 50.0;
      }
LABEL_162:
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v84 = 0u;
      *(void *)long long __p = *(void *)buf;
      if (*(void *)buf)
      {
        CFRetain(*(CFTypeRef *)buf);
        CFTypeRef cf = *(CFTypeRef *)buf;
        if (*(void *)buf) {
          CFRetain(*(CFTypeRef *)buf);
        }
      }
      else
      {
        CFTypeRef cf = 0;
      }
      sub_1006B1E38((uint64_t)&v84, a3, (const void **)__p, &cf, v23, v23);
      sub_1000FE824(&cf);
      sub_1000FE824((const void **)__p);
      long long v75 = *a2;
      if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_173;
      }
      sub_1006B1B88(v102, (uint64_t)&v84);
      if (v103 >= 0) {
        uint64_t v83 = v102;
      }
      else {
        uint64_t v83 = *(uint8_t **)v102;
      }
      LODWORD(v100[0]) = 136446210;
      *(CFTypeRef *)((char *)v100 + 4) = v83;
      long long v77 = "#I Returning bundle match: %{public}s";
    }
    else
    {
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v84 = 0u;
      *(void *)long long __p = *(void *)buf;
      if (*(void *)buf)
      {
        CFRetain(*(CFTypeRef *)buf);
        CFTypeRef cf = *(CFTypeRef *)buf;
        if (*(void *)buf) {
          CFRetain(*(CFTypeRef *)buf);
        }
      }
      else
      {
        CFTypeRef cf = 0;
      }
      sub_1006B1E38((uint64_t)&v84, a3, (const void **)__p, &cf, 0.0, 0.0);
      sub_1000FE824(&cf);
      sub_1000FE824((const void **)__p);
      long long v75 = *a2;
      if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_173;
      }
      sub_1006B1B88(v102, (uint64_t)&v84);
      if (v103 >= 0) {
        uint64_t v76 = v102;
      }
      else {
        uint64_t v76 = *(uint8_t **)v102;
      }
      LODWORD(v100[0]) = 136446210;
      *(CFTypeRef *)((char *)v100 + 4) = v76;
      long long v77 = "#I No candidates were found in the collection. Returning bundle match: %{public}s";
    }
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, v77, (uint8_t *)v100, 0xCu);
    if (SHIBYTE(v103) < 0) {
      operator delete(*(void **)v102);
    }
LABEL_173:
    sub_100044D00((const void **)&theArray);
    goto LABEL_174;
  }
LABEL_49:
  *(void *)std::string buf = 0;
  CFArrayRef theArray = 0;
  CFStringRef v37 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    memset(v102, 0, sizeof(v102));
    uint64_t v103 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v100 = 0u;
    uint64_t v101 = 0;
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v100;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Provided match prefix to search based on SIM information: %s", __p, 0xCu);
    if (SHIBYTE(v101) < 0) {
      operator delete((void *)v100[0]);
    }
  }
  if (CFStringGetLength(a4) < 1)
  {
    char v70 = *a2;
    double v54 = 0.0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v102 = 0;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Invalid prefix provided to search for best match with SIM Info", v102, 2u);
    }
    double v55 = 0.0;
    goto LABEL_130;
  }
  *(void *)long long __p = 0;
  sub_1004D0FD0(a6, a2, a3, a4, __p);
  if (*(void *)__p) {
    CFTypeID v38 = sub_100083F10;
  }
  else {
    CFTypeID v38 = 0;
  }
  if (!v38)
  {
    uint64_t v71 = *a2;
    double v54 = 0.0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v102 = 0;
      uint64_t v72 = "#I No candidates were found in the collection";
LABEL_127:
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v72, v102, 2u);
    }
LABEL_128:
    double v55 = 0.0;
    goto LABEL_129;
  }
  CFIndex v39 = CFArrayGetCount(*(CFArrayRef *)__p);
  if (v39 < 1)
  {
    uint64_t v71 = *a2;
    double v54 = 0.0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v102 = 0;
      uint64_t v72 = "#I No candidates in the candidate list";
      goto LABEL_127;
    }
    goto LABEL_128;
  }
  memset(v102, 0, sizeof(v102));
  uint64_t v103 = 0;
  v100[0] = 0;
  sub_1004D6618(v102, v39, v100);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, theDict);
  CFIndex v41 = 0;
  CFTypeRef cf = Copy;
  double v42 = 0.0;
  double v43 = 0.0;
  double v44 = 0.0;
  double v45 = 0.0;
  do
  {
    v100[0] = 0;
    CFTypeID v46 = CFArrayGetValueAtIndex(*(CFArrayRef *)__p, v41);
    sub_1006B1DDC(v100, v46);
    uint64_t v47 = (const void **)v100[0];
    char v92 = (__CFURL *)v100[0];
    CFStringRef theString2 = 0;
    if (v100[0])
    {
      CFRetain(v100[0]);
      uint64_t v47 = (const void **)v92;
    }
    copyFileName(v47, &theString2);
    sub_1000FE824((const void **)&v92);
    if (theString2) {
      CFStringRef v48 = sub_1000810B8;
    }
    else {
      CFStringRef v48 = 0;
    }
    if (v48)
    {
      *(void *)uint64_t v91 = 0;
      sub_1006B3B08((CFDictionaryRef *)v91, a2, theString2);
      double v49 = sub_1006B3F4C((CFDictionaryRef *)v91, (CFDictionaryRef *)&cf);
      *(double *)(*(void *)v102 + 8 * v41) = v49;
      if (v49 != 0.0)
      {
        char v90 = (__CFURL *)v100[0];
        if (v100[0])
        {
          CFRetain(v100[0]);
          CFTypeID v50 = v90;
        }
        else
        {
          CFTypeID v50 = 0;
        }
        BOOL v52 = sub_1004D362C(a3, v50);
        sub_1000FE824((const void **)&v90);
        if (!v52)
        {
          *(void *)(*(void *)v102 + 8 * v41) = 0;
          goto LABEL_85;
        }
        double v49 = *(double *)(*(void *)v102 + 8 * v41);
      }
      if (v49 != 0.0)
      {
        if ((a7 & 1) == 0)
        {
          CFTypeRef v89 = v100[0];
          if (v100[0]) {
            CFRetain(v100[0]);
          }
          char v53 = sub_1004D276C(a2, a3, &v89);
          sub_1000FE824(&v89);
          double v49 = *(double *)(*(void *)v102 + 8 * v41);
          if (v49 <= 0.0) {
            goto LABEL_85;
          }
          goto LABEL_81;
        }
        if (v49 > 0.0)
        {
          char v53 = 1;
LABEL_81:
          if (v49 > v43)
          {
            double v43 = v49;
            double v42 = (double)(int)v41;
          }
          if ((v53 & (v49 > v45)) != 0)
          {
            double v45 = v49;
            double v44 = (double)(int)v41;
          }
        }
      }
LABEL_85:
      sub_1006B3F14((const void **)v91);
      goto LABEL_86;
    }
    char v51 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v91 = 0;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Failed to get the candidate name", v91, 2u);
    }
LABEL_86:
    sub_1000558F4((const void **)&theString2);
    sub_1000FE824(v100);
    ++v41;
  }
  while (v39 != v41);
  double v54 = 0.0;
  double v55 = 0.0;
  if (v44 >= 0.0 && v44 < (double)v39 && v45 > 0.0)
  {
    uint64_t v56 = CFArrayGetValueAtIndex(*(CFArrayRef *)__p, (uint64_t)v44);
    v100[0] = 0;
    sub_1006B1DDC(v100, v56);
    int v57 = *(const void **)buf;
    *(CFTypeRef *)std::string buf = v100[0];
    v100[0] = v57;
    sub_1000FE824(v100);
    double v55 = v45;
  }
  if (v42 >= 0.0 && v42 < (double)v39 && v43 > 0.0)
  {
    char v58 = CFArrayGetValueAtIndex(*(CFArrayRef *)__p, (uint64_t)v42);
    v100[0] = 0;
    sub_1006B1DDC(v100, v58);
    CFArrayRef v59 = theArray;
    CFArrayRef theArray = (CFArrayRef)v100[0];
    v100[0] = v59;
    sub_1000FE824(v100);
    double v54 = v43;
  }
  sub_1006B3F14(&cf);
  if (*(void *)v102)
  {
    *(void *)&v102[8] = *(void *)v102;
    operator delete(*(void **)v102);
  }
LABEL_129:
  sub_100044D00((const void **)__p);
LABEL_130:
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v84 = 0u;
  *(void *)long long __p = *(void *)buf;
  if (*(void *)buf) {
    CFRetain(*(CFTypeRef *)buf);
  }
  CFTypeRef cf = theArray;
  if (theArray) {
    CFRetain(theArray);
  }
  sub_1006B1E38((uint64_t)&v84, a3, (const void **)__p, &cf, v55, v54);
  sub_1000FE824(&cf);
  sub_1000FE824((const void **)__p);
  CFURLRef v73 = *a2;
  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006B1B88(v102, (uint64_t)&v84);
    CFURLRef v74 = v103 >= 0 ? v102 : *(uint8_t **)v102;
    LODWORD(v100[0]) = 136315138;
    *(CFTypeRef *)((char *)v100 + 4) = v74;
    _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I Returning bundle match: %s", (uint8_t *)v100, 0xCu);
    if (SHIBYTE(v103) < 0) {
      operator delete(*(void **)v102);
    }
  }
  sub_1000FE824((const void **)&theArray);
LABEL_174:
  p_CFArrayRef theArray = (const void **)buf;
LABEL_175:
  sub_1000FE824(p_theArray);
  sub_1006A5E9C(v13, (uint64_t)&v84);
  sub_1006A5E9C(v13 + 40, (uint64_t)&v86 + 8);
  if (*((void *)&v88 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v88 + 1));
  }
  sub_1000FE824((const void **)&v86 + 1);
  if ((void)v86) {
    sub_10004D2C8((std::__shared_weak_count *)v86);
  }
  return sub_1000FE824((const void **)&v84);
}

void sub_1006A590C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,__int16 a39,char a40,char a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1006A5BE0(uint64_t a1)
{
  CFDictionaryRef v2 = (const void **)(a1 + 40);
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000FE824(v2);
  long long v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_1000FE824((const void **)a1);
}

uint64_t sub_1006A5C38(void *a1, uint64_t a2)
{
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)CFTypeID v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  sub_10004DE24((uint64_t)v17);
  long long v4 = sub_10004B96C(v17, (uint64_t)"[Name: ", 7);
  sub_100119B5C((const void **)&v14, (const void **)a2);
  asString(v14, (uint64_t)__p);
  if ((v16 & 0x80u) == 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v6 = v16;
  }
  else {
    uint64_t v6 = (uint64_t)__p[1];
  }
  uint64_t v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  sub_10004B96C(v7, (uint64_t)", Score: ", 9);
  size_t v8 = (void *)std::ostream::operator<<();
  CFStringRef v9 = sub_10004B96C(v8, (uint64_t)", include cookie: ", 18);
  if (*(unsigned char *)(a2 + 16)) {
    CFTypeID v10 = "true";
  }
  else {
    CFTypeID v10 = "false";
  }
  if (*(unsigned char *)(a2 + 16)) {
    uint64_t v11 = 4;
  }
  else {
    uint64_t v11 = 5;
  }
  CFStringRef v12 = sub_10004B96C(v9, (uint64_t)v10, v11);
  sub_10004B96C(v12, (uint64_t)"]", 1);
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  sub_1000FE824((const void **)&v14);
  sub_10004BC98((uint64_t)v17 + 8, a1);
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1006A5E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1006A5E9C(uint64_t a1, uint64_t a2)
{
  sub_1003C4D24((const void **)a1, (const void **)a2);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  return a1;
}

const void **sub_1006A5EFC(uint64_t a1)
{
  CFDictionaryRef v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_1000FE824((const void **)a1);
}

uint64_t sub_1006A5F3C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = a1 + 216;
  uint64_t v7 = (const void **)sub_1006A29CC(a1 + 216, a2, a3);
  sub_1006A29CC(v6, a2, a3);
  sub_1006A29CC(v6, a2, a3);
  std::string::size_type v36 = 0;
  uint64_t v8 = sub_1006A29CC(v6, a2, a3);
  if (*(char *)(v8 + 87) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v8 + 64), *(void *)(v8 + 72));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(v8 + 64);
    uint64_t v35 = *(void *)(v8 + 80);
  }
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(v21, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long v21 = *(_OWORD *)__dst;
    *(void *)&long long v22 = v35;
  }
  __str.__r_.__value_.__r.__words[0] = 0;
  if (SBYTE7(v22) < 0)
  {
    sub_10004FC84(__p, v21[0], (unint64_t)v21[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v21;
    v43[0] = (void *)v22;
  }
  *(void *)CFStringRef v37 = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v9 = __str.__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = *(void *)v37;
    *(void *)std::string buf = v9;
    sub_1000558F4((const void **)buf);
  }
  if (SHIBYTE(v43[0]) < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type v36 = __str.__r_.__value_.__r.__words[0];
  __str.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
  if (SBYTE7(v22) < 0) {
    operator delete(v21[0]);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__dst[0]);
  }
  sub_1006A29CC(v6, a2, a3);
  sub_1006A29CC(v6, a2, a3);
  CFTypeID v10 = (os_log_t *)(a1 + 8);
  uint64_t v11 = (os_log_t *)(a1 + 8);
  if ((a2 - 1) <= 1u) {
    uint64_t v11 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), a3);
  }
  CFStringRef v12 = *v11;
  if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = (void *)asString();
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I =========================== Potentially Resetting %s Bundle ===========================", (uint8_t *)__p, 0xCu);
  }
  sub_100058198(&v33, v7);
  sub_1006A41E4(a1, (CFDictionaryRef *)&v33);
  sub_100057D78(&v33);
  int v19 = CFDictionaryContainsKey((CFDictionaryRef)*v7, @"1xIMSI");
  int v14 = CFDictionaryContainsKey((CFDictionaryRef)*v7, (const void *)qword_101B13ED0);
  if (CFDictionaryContainsKey((CFDictionaryRef)*v7, (const void *)qword_101B13EC0)) {
    BOOL v15 = CFDictionaryContainsKey((CFDictionaryRef)*v7, (const void *)qword_101B13EB8) != 0;
  }
  else {
    BOOL v15 = 0;
  }
  if ((a2 & 0xFFFFFFFD) != 1 || v14 || v15 || v19)
  {
    uint64_t v32 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    *(_OWORD *)__src = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    *(_OWORD *)long long v21 = 0u;
    sub_1007DE21C((uint64_t)v21, a1 + 64);
    CFStringRef v17 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I ------------ Device Overlay ------------ ", (uint8_t *)__p, 2u);
    }
    sub_100058198(&v20, v7);
    v40[0] = off_1019F9028;
    v40[1] = a1;
    v40[2] = a2;
    v40[3] = v40;
    v39[0] = off_1019F90B8;
    v39[1] = a1;
    v39[2] = a2;
    v39[3] = v39;
    memset(v37, 0, sizeof(v37));
    operator new();
  }
  unsigned __int8 v16 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N There is no CarrierID or SIM Info present", (uint8_t *)__p, 2u);
  }
  sub_1000558F4((const void **)&v36);
  return 0;
}

void sub_1006A8B84(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1006A92A4()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  operator new();
}

void sub_1006A98E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,int a21,const void *a22,const void *a23,const void *a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006A99E0(uint64_t a1)
{
  memset(&__p, 0, sizeof(__p));
  if (*(char *)(a1 + 55) < 0) {
    sub_10004FC84(&__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else {
    std::string __p = *(std::string *)(a1 + 32);
  }
  std::string::append(&__p, "\n", 1uLL);
  (*(void (**)(void, uint64_t, std::string *))(**(void **)(a1 + 56) + 24))(*(void *)(a1 + 56), a1 + 72, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1006A9A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_1006A9AAC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v4;
  }
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v7 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)__n128 result = v7;
  return result;
}

void sub_1006A9B4C(_Unwind_Exception *exception_object)
{
  long long v4 = *(std::__shared_weak_count **)(v2 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(v2 + 55) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006A9B74(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 55) < 0)
  {
    int v3 = *(void **)(a1 + 32);
    operator delete(v3);
  }
}

uint64_t *sub_1006A9BD8(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 144);
  sub_1006A9C20(*(NSObject **)(a1 + 8), (const UInt8 *)(a1 + 144));

  return sub_1006A1A30(a1, v2);
}

const void **sub_1006A9C20(NSObject *a1, const UInt8 *a2)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v4 = a2;
    }
    else {
      long long v4 = *(const UInt8 **)a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Resetting carrier bundle content cache associated with: %{public}s", buf, 0xCu);
  }
  int v5 = *((char *)a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a2;
  }
  if (v5 >= 0) {
    CFIndex v7 = a2[23];
  }
  else {
    CFIndex v7 = *((void *)a2 + 1);
  }
  CFTypeID v10 = 0;
  *(void *)std::string buf = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v6, v7, 1u);
  copyURLAsString((uint64_t *)&v10, *(const __CFURL **)buf);
  if (v10) {
    uint64_t v8 = sub_1000810B8;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8) {
    CarrierBundleDevicePersistentSaveValue(v10, 0);
  }
  sub_1000558F4((const void **)&v10);
  return sub_1000FE824((const void **)buf);
}

void sub_1006A9D38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000FE824((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006A9D64(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  sub_1006A9C20(*(NSObject **)(a1 + 8), (const UInt8 *)(a1 + 120));

  return sub_1006A1A30(a1, (const void **)(a1 + 120));
}

uint64_t *sub_1006A9DD0(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 8);
  uint64_t v3 = a1 + 192;
  sub_1006AA304(*(NSObject **)(a1 + 8), (const UInt8 *)(a1 + 192));
  memset(v36, 0, sizeof(v36));
  long long v35 = 0u;
  os_log_t v4 = *v2;
  os_signpost_id_t v5 = os_signpost_id_generate(*v2);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v6 = *v2;
    if (os_signpost_enabled(*v2))
    {
      if (*(char *)(a1 + 215) >= 0) {
        CFIndex v7 = v2 + 23;
      }
      else {
        CFIndex v7 = *(os_log_t **)(a1 + 192);
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v7;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "CountryBundleScan", "path=%{signpost.description:attribute}s", (uint8_t *)&buf, 0xCu);
    }
  }
  *(void *)&long long buf = off_1019F91B8;
  v34[1] = &buf;
  *(void *)&long long v35 = v5;
  *((void *)&v35 + 1) = os_retain(v4);
  sub_1000336E8((uint64_t)v36, (uint64_t)&buf);
  sub_100033A10(&buf);
  uint64_t v30 = 0;
  long long v31 = 0;
  sub_100058DB0(&__p, "scan country bundles");
  long long buf = v35;
  sub_1000336E8((uint64_t)v34, (uint64_t)v36);
  long long v35 = 0uLL;
  sub_100033AF4(v36);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC((uint64_t *)&buf);
  if (v29 < 0) {
    operator delete(__p);
  }
  long long v27 = 0;
  int v8 = *(char *)(a1 + 215);
  if (v8 >= 0) {
    std::string::size_type v9 = (const UInt8 *)(v2 + 23);
  }
  else {
    std::string::size_type v9 = *(const UInt8 **)(a1 + 192);
  }
  if (v8 >= 0) {
    CFIndex v10 = *(unsigned __int8 *)(a1 + 215);
  }
  else {
    CFIndex v10 = *(void *)(a1 + 200);
  }
  long long v27 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v9, v10, 1u);
  sub_1004D1B74(v27, v2, (void **)v32);
  if (*(void *)v32) {
    uint64_t v11 = sub_100083F10;
  }
  else {
    uint64_t v11 = 0;
  }
  sub_100044D00((const void **)v32);
  CFStringRef v12 = *v2;
  BOOL v13 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
  if (v11)
  {
    if (v13)
    {
      if (*(char *)(a1 + 215) >= 0) {
        int v14 = v2 + 23;
      }
      else {
        int v14 = *(os_log_t **)(a1 + 192);
      }
      *(_DWORD *)uint64_t v32 = 136446210;
      *(void *)&v32[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Directory %{public}s has already been scanned, not scanning again", v32, 0xCu);
    }
  }
  else
  {
    if (v13)
    {
      if (*(char *)(a1 + 215) >= 0) {
        BOOL v15 = v2 + 23;
      }
      else {
        BOOL v15 = *(os_log_t **)(a1 + 192);
      }
      *(_DWORD *)uint64_t v32 = 136446210;
      *(void *)&v32[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Scanning for country bundles in %{public}s", v32, 0xCu);
    }
    long long v26 = 0;
    if (*(char *)(a1 + 215) >= 1)
    {
      uint64_t v16 = *(unsigned __int8 *)(a1 + 215);
      CFStringRef v17 = v2 + 23;
      do
      {
        CFStringRef v17 = (os_log_t *)((char *)v17 + 1);
        --v16;
      }
      while (v16);
    }
    copyDirectoryContentsInString(v2, (Registry **)(a1 + 64), 1, &v25);
    *(void *)uint64_t v32 = v26;
    CFTypeID v18 = v25;
    long long v25 = 0;
    long long v26 = v18;
    sub_100044D00((const void **)v32);
    sub_100044D00(&v25);
    if (v26) {
      int v19 = sub_100083F10;
    }
    else {
      int v19 = 0;
    }
    if (v19)
    {
      long long v25 = 0;
      copyURLAsString((uint64_t *)&v25, v27);
      long long v20 = *v2;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 215) >= 0) {
          uint64_t v21 = v3;
        }
        else {
          uint64_t v21 = *(void *)(a1 + 192);
        }
        *(_DWORD *)uint64_t v32 = 136446210;
        *(void *)&v32[4] = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Saving the contents of directory %{public}s", v32, 0xCu);
      }
      *(void *)uint64_t v32 = v26;
      if (v26) {
        CFRetain(v26);
      }
      CountryBundleDevicePersistentSaveValue();
      sub_1000577C4((const void **)v32);
      sub_1000558F4(&v25);
    }
    else
    {
      long long v22 = *v2;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 215) >= 0) {
          uint64_t v23 = v3;
        }
        else {
          uint64_t v23 = *(void *)(a1 + 192);
        }
        *(_DWORD *)uint64_t v32 = 136446210;
        *(void *)&v32[4] = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Directory %{public}s contents cannot be cached", v32, 0xCu);
      }
    }
    sub_100044D00(&v26);
  }
  sub_1000FE824((const void **)&v27);
  if (v31) {
    sub_10004D2C8(v31);
  }
  return sub_1000339DC((uint64_t *)&v35);
}

void sub_1006AA25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_1000339DC(&a28);
  _Unwind_Resume(a1);
}

void sub_1006AA2F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_100033A10((uint64_t *)va);
  JUMPOUT(0x1006AA2ECLL);
}

const void **sub_1006AA304(NSObject *a1, const UInt8 *a2)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      os_log_t v4 = a2;
    }
    else {
      os_log_t v4 = *(const UInt8 **)a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Resetting country bundle content cache associated with: %{public}s", buf, 0xCu);
  }
  int v5 = *((char *)a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a2;
  }
  if (v5 >= 0) {
    CFIndex v7 = a2[23];
  }
  else {
    CFIndex v7 = *((void *)a2 + 1);
  }
  CFIndex v10 = 0;
  *(void *)long long buf = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, v6, v7, 1u);
  copyURLAsString((uint64_t *)&v10, *(const __CFURL **)buf);
  if (v10) {
    int v8 = sub_1000810B8;
  }
  else {
    int v8 = 0;
  }
  if (v8) {
    CountryBundleDevicePersistentSaveValue(v10, 0);
  }
  sub_1000558F4((const void **)&v10);
  return sub_1000FE824((const void **)buf);
}

void sub_1006AA41C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000FE824((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_1006AA448(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
  uint64_t v2 = *(NSObject **)(a1 + 8);

  return sub_1006AA304(v2, (const UInt8 *)(a1 + 168));
}

uint64_t sub_1006AA4A4@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, const void **a3@<X2>, _DWORD *a4@<X3>, unsigned int a5@<W4>, unsigned char *a6@<X8>)
{
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  sub_1007DE21C((uint64_t)v20, a1 + 64);
  char v12 = 0;
  if (a2 <= 6)
  {
    if (((1 << a2) & 0x76) == 0)
    {
      if (a2 != 3) {
        goto LABEL_15;
      }
      sub_100058198(&v18, a3);
      sub_1004D3980((CFDictionaryRef *)&v18, (const __CFDictionary **)&v19);
      if (&v19 != a3)
      {
        *(void *)long long buf = *a3;
        *a3 = v19;
        int v19 = 0;
        sub_100057D78((const void **)buf);
      }
      sub_100057D78(&v19);
      sub_100057D78(&v18);
    }
    if (*a3) {
      BOOL v13 = sub_100080778;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13 && CFDictionaryGetCount((CFDictionaryRef)*a3))
    {
      int v14 = (const void **)sub_1006A29CC(a1 + 216, a2, a5);
      sub_100058140(v14, a3);
      *(_DWORD *)(sub_1006A29CC(a1 + 216, a2, a5) + 8) = *a4;
      char v12 = sub_1006A5F3C(a1, a2, a5);
      uint64_t v15 = sub_1006A29CC(a1 + 216, a2, a5);
      sub_1007DE538((uint64_t)v20, v15 + 88);
    }
    else
    {
      uint64_t v16 = *(NSObject **)(a1 + 8);
      char v12 = 0;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Invalid matching information", buf, 2u);
        char v12 = 0;
      }
    }
  }
LABEL_15:
  *a6 = v12;
  sub_1007DE310((uint64_t)(a6 + 8), (uint64_t)v20);
  return sub_1007DE5C8((uint64_t)v20);
}

void sub_1006AA698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, char a11)
{
}

void sub_1006AA6C8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 216);
  uint64_t v2 = (void *)(a1 + 224);
  if (v1 != (void *)(a1 + 224))
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v7 = 0;
      sub_1007E0E28((uint64_t)(v1 + 16), (uint64_t)__p);
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v3 = (void *)v1[1];
      if (v3)
      {
        do
        {
          os_log_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          os_log_t v4 = (void *)v1[2];
          BOOL v5 = *v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != v2);
  }
}

void sub_1006AA758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006AA774(uint64_t a1)
{
  uint64_t v3 = (os_log_t *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I =========================== Carrier Bundle Manager Dump State ===========================", buf, 2u);
  }
  os_log_t v4 = *(void **)(a1 + 216);
  if (v4 != (void *)(a1 + 224))
  {
    do
    {
      BOOL v5 = v3;
      if ((*((unsigned char *)v4 + 32) - 1) <= 1u) {
        BOOL v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), *((unsigned int *)v4 + 9));
      }
      uint64_t v6 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Bundle type: %s", buf, 0xCu);
      }
      sub_100058198(&v16, (const void **)v4 + 5);
      sub_1006A41E4(a1, (CFDictionaryRef *)&v16);
      sub_100057D78(&v16);
      int v8 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyList::asString((uint64_t *)buf, (WirelessTechnologyList *)(v4 + 6));
        std::string::size_type v9 = buf;
        if (v18 < 0) {
          std::string::size_type v9 = *(unsigned char **)buf;
        }
        *(_DWORD *)int v19 = 136446210;
        long long v20 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Tech: %{public}s", v19, 0xCu);
        if (v18 < 0) {
          operator delete(*(void **)buf);
        }
        int v8 = *v5;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex v10 = v4 + 7;
        if (*((char *)v4 + 79) < 0) {
          CFIndex v10 = (void *)*v10;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Bundle location: %{public}s", buf, 0xCu);
        int v8 = *v5;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = v4 + 10;
        if (*((char *)v4 + 103) < 0) {
          uint64_t v11 = (void *)*v11;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Pref file path: %{public}s", buf, 0xCu);
        int v8 = *v5;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        char v12 = v4 + 13;
        if (*((char *)v4 + 127) < 0) {
          char v12 = (void *)*v12;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Pref domain: %{public}s", buf, 0xCu);
      }
      sub_1007DE920((uint64_t)(v4 + 16), v5, 0, 1);
      BOOL v13 = (void *)v4[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          BOOL v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void *)v4[2];
          BOOL v15 = *v14 == (void)v4;
          os_log_t v4 = v14;
        }
        while (!v15);
      }
      os_log_t v4 = v14;
    }
    while (v14 != (void *)(a1 + 224));
  }
}

void sub_1006AAABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006AAAD8(uint64_t a1)
{
  uint64_t v2 = (char *)sub_1003F26A8();
  sub_100058DB0(&v14, v2);
  size_t v3 = strlen(kUserCBDir);
  os_log_t v4 = std::string::append(&v14, kUserCBDir, v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  sub_100058DB0(__p, kOverlayDir);
  if ((v13 & 0x80u) == 0) {
    uint64_t v6 = __p;
  }
  else {
    uint64_t v6 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v7 = v13;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)__p[1];
  }
  int v8 = std::string::append(&v15, (const std::string::value_type *)v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  std::string::size_type v17 = v8->__r_.__value_.__r.__words[2];
  long long v16 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  uint64_t v10 = sub_1006AAC54(a1, (uint64_t *)(a1 + 144), (uint64_t)&v16);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  return v10;
}

void sub_1006AABF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 25) < 0) {
    operator delete(*(void **)(v26 - 48));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006AAC54(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v23 = (uint64_t)&v23;
  long long v24 = &v23;
  uint64_t v25 = 0;
  if ((*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(a1 + 48) + 96))(*(void *)(a1 + 48), a2, &v23, 1))
  {
    BOOL v6 = 1;
  }
  else
  {
    BOOL v6 = v25 == 0;
  }
  if (v6)
  {
    uint64_t v7 = 0;
  }
  else
  {
    int v8 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Clearing %{public}s:", buf, 0xCu);
    }
    uint64_t v11 = v24;
    if (v24 == &v23)
    {
      char v12 = 0;
    }
    else
    {
      char v12 = 0;
      do
      {
        uint64_t v39 = 0;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v32 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v29 = 0u;
        sub_1007DE21C((uint64_t)buf, a1 + 64);
        unsigned __int8 v13 = v11 + 2;
        sub_1007DE874((uint64_t)buf, (std::string *)(v11 + 2));
        if (sub_1007E1374((uint64_t)buf))
        {
          char v12 = 1;
        }
        else
        {
          std::string v14 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)v11 + 39) < 0) {
              unsigned __int8 v13 = (void *)*v13;
            }
            LODWORD(v26) = 136315138;
            *(void *)((char *)&v26 + 4) = v13;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to remove bundle %s", (uint8_t *)&v26, 0xCu);
          }
        }
        sub_1007DE5C8((uint64_t)buf);
        uint64_t v11 = (uint64_t *)v11[1];
      }
      while (v11 != &v23);
    }
    *(void *)long long buf = buf;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&long long v29 = 0;
    if ((*(uint64_t (**)(void, uint64_t, uint8_t *, uint64_t))(**(void **)(a1 + 48) + 96))(*(void *)(a1 + 48), a3, buf, 1))
    {
      BOOL v15 = 1;
    }
    else
    {
      BOOL v15 = (void)v29 == 0;
    }
    if (!v15)
    {
      std::string::size_type v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          int v19 = a2;
        }
        else {
          int v19 = (uint64_t *)*a2;
        }
        LODWORD(v26) = 136446210;
        *(void *)((char *)&v26 + 4) = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Clearing Overlay files from: %{public}s", (uint8_t *)&v26, 0xCu);
      }
      for (uint64_t i = *(void *)&buf[8]; (uint8_t *)i != buf; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v21 = 0;
        long long v22 = 0;
        Registry::getMobileHelper(&v21, *(Registry **)(a1 + 64));
        if (v21)
        {
          long long v26 = 0uLL;
          uint64_t v27 = 0;
          (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v21 + 120))(v21, i + 16, &v26);
          if (SHIBYTE(v27) < 0) {
            operator delete((void *)v26);
          }
        }
        if (v22) {
          sub_10004D2C8(v22);
        }
      }
    }
    sub_1001257B0(buf);
    uint64_t v7 = v12 & 1;
  }
  sub_1001257B0(&v23);
  return v7;
}

void sub_1006AAFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24)
{
}

uint64_t sub_1006AB004(uint64_t a1)
{
  uint64_t v2 = (char *)sub_1003F26A8();
  sub_100058DB0(&v14, v2);
  size_t v3 = strlen(kUserCountryBundleDir);
  os_log_t v4 = std::string::append(&v14, kUserCountryBundleDir, v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  sub_100058DB0(__p, kOverlayDir);
  if ((v13 & 0x80u) == 0) {
    BOOL v6 = __p;
  }
  else {
    BOOL v6 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    std::string::size_type v7 = v13;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)__p[1];
  }
  int v8 = std::string::append(&v15, (const std::string::value_type *)v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  std::string::size_type v17 = v8->__r_.__value_.__r.__words[2];
  long long v16 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  uint64_t v10 = sub_1006AAC54(a1, (uint64_t *)(a1 + 192), (uint64_t)&v16);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  return v10;
}

void sub_1006AB120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 25) < 0) {
    operator delete(*(void **)(v26 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_1006AB180(uint64_t a1, uint64_t a2, const void **a3)
{
  if (*a3) {
    size_t v3 = sub_100080778;
  }
  else {
    size_t v3 = 0;
  }
  os_log_t v4 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ------------ Device Overlay ------------ ", buf, 2u);
    }
    sub_100058198(&v6, a3);
    memset(buf, 0, sizeof(buf));
    operator new();
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Empty matching info.", buf, 2u);
  }
}

void sub_1006ABA98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, char a13, int a14, __int16 a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,const void *a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,char a35,int a36,__int16 a37,char a38,char a39,int a40,__int16 a41,char a42,char a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (!v56 || (sub_10004D2C8(v56), v55 < 0)) {
    operator delete(__p);
  }
  sub_100057D78(&a27);
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

void sub_1006ABC58()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  operator new();
}

void sub_1006AC2E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,int a21,const void *a22,const void *a23,const void *a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006AC3E0(uint64_t a1, std::string::size_type a2)
{
  os_log_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v5 = a2;
    }
    else {
      std::string::size_type v5 = *(void *)a2;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Print more logging for path: %{public}s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v234 = 0;
  v235 = 0;
  Registry::getFileSystemInterface(&v234, *(Registry **)(a1 + 64));
  if (v234)
  {
    std::string::size_type v232 = 0;
    v233 = 0;
    (*(void (**)(std::string::size_type *__return_ptr))(*(void *)v234 + 248))(&v232);
    std::string::size_type v6 = v232;
    if (v232) {
      std::string::size_type v7 = sub_100080778;
    }
    else {
      std::string::size_type v7 = 0;
    }
    if (v7 || ((uint64_t v10 = v233) != 0 ? (v11 = sub_10039195C) : (v11 = 0), !v11))
    {
      int v8 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I File attributes using CC: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_331;
    }
    char v12 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Error reading attributes using CC: %{public}@", (uint8_t *)&buf, 0xCu);
      char v12 = *(NSObject **)(a1 + 8);
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Using mobilehelper to get attributes", (uint8_t *)&buf, 2u);
    }
    uint64_t v230 = 0;
    v231 = 0;
    Registry::getMobileHelper(&v230, *(Registry **)(a1 + 64));
    if (!v230)
    {
      long long v16 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Couldnt get MobileHelper", (uint8_t *)&buf, 2u);
      }
      goto LABEL_329;
    }
    CFDictionaryRef v229 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v230 + 168))(&v229);
    CFDictionaryRef v13 = v229;
    if (v229) {
      std::string v14 = sub_100080778;
    }
    else {
      std::string v14 = 0;
    }
    std::string v15 = *(NSObject **)(a1 + 8);
    if (v14)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I File attributes using CCMH: %{public}@", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Error reading attributes using CCMH", (uint8_t *)&buf, 2u);
    }
    v227[0] = 0;
    v227[1] = 0;
    uint64_t v228 = 0;
    getCarrierBundleDir(v227);
    CFDictionaryRef v226 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v230 + 168))(&v226);
    CFDictionaryRef v17 = v226;
    if (v226) {
      char v18 = sub_100080778;
    }
    else {
      char v18 = 0;
    }
    int v19 = *(NSObject **)(a1 + 8);
    BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    if (v18)
    {
      if (!v20) {
        goto LABEL_47;
      }
      uint64_t v21 = v227;
      if (v228 < 0) {
        uint64_t v21 = (void **)v227[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
      long long v22 = "#I File attributes of CB directory:%{public}s using CCMH: %{public}@";
      uint64_t v23 = v19;
      uint32_t v24 = 22;
    }
    else
    {
      if (!v20) {
        goto LABEL_47;
      }
      uint64_t v25 = v227;
      if (v228 < 0) {
        uint64_t v25 = (void **)v227[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
      long long v22 = "#I Failed to get File attributes of CB directory: %{public}s using CCMH";
      uint64_t v23 = v19;
      uint32_t v24 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&buf, v24);
LABEL_47:
    v224[0] = 0;
    v224[1] = 0;
    uint64_t v225 = 0;
    getCountryBundleDir(v224);
    CFDictionaryRef v223 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v230 + 168))(&v223);
    CFDictionaryRef v26 = v223;
    if (v223) {
      uint64_t v27 = sub_100080778;
    }
    else {
      uint64_t v27 = 0;
    }
    long long v28 = *(NSObject **)(a1 + 8);
    BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
    if (v27)
    {
      if (!v29) {
        goto LABEL_60;
      }
      long long v30 = v224;
      if (v225 < 0) {
        long long v30 = (void **)v224[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v26;
      long long v31 = "#I File attributes of countrybundles directory:%{public}s using CCMH: %{public}@";
      long long v32 = v28;
      uint32_t v33 = 22;
    }
    else
    {
      if (!v29) {
        goto LABEL_60;
      }
      long long v34 = v224;
      if (v225 < 0) {
        long long v34 = (void **)v224[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
      long long v31 = "#I Failed to get File attributes of countrybundles directory:%{public}s using CCMH";
      long long v32 = v28;
      uint32_t v33 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&buf, v33);
LABEL_60:
    long long v35 = (char *)sub_1003F26A8();
    v221[1] = 0;
    v221[0] = 0;
    uint64_t v222 = 0;
    sub_100058DB0(v221, v35);
    ctu::path_join_impl();
    CFDictionaryRef theDict = 0;
    (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v230 + 168))(&theDict);
    CFDictionaryRef v36 = theDict;
    if (theDict) {
      long long v37 = sub_100080778;
    }
    else {
      long long v37 = 0;
    }
    long long v38 = *(NSObject **)(a1 + 8);
    BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    if (v37)
    {
      if (!v39) {
        goto LABEL_73;
      }
      CFStringRef v40 = v221;
      if (v222 < 0) {
        CFStringRef v40 = (void **)v221[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v36;
      CFIndex v41 = "#I File attributes of mobileLib directory:%{public}s using CCMH: %{public}@";
      double v42 = v38;
      uint32_t v43 = 22;
    }
    else
    {
      if (!v39) {
        goto LABEL_73;
      }
      double v44 = v221;
      if (v222 < 0) {
        double v44 = (void **)v221[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
      CFIndex v41 = "#I Failed to get File attributes of mobileLib directory: %{public}s using CCMH";
      double v42 = v38;
      uint32_t v43 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&buf, v43);
LABEL_73:
    CFDictionaryRef v219 = 0;
    uint64_t v45 = v230;
    CFTypeID v46 = (char *)sub_1003F26A8();
    sub_100058DB0(&buf, v46);
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, std::string *))(*(void *)v45 + 168))(&v219, v45, &buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (v219) {
      uint64_t v47 = sub_100080778;
    }
    else {
      uint64_t v47 = 0;
    }
    CFStringRef v48 = *(NSObject **)(a1 + 8);
    BOOL v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
    if (v47)
    {
      if (!v49) {
        goto LABEL_84;
      }
      uint64_t v50 = sub_1003F26A8();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v50;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v219;
      char v51 = "#I File attributes of mobile directory: %{public}s using CCMH: %{public}@";
      BOOL v52 = v48;
      uint32_t v53 = 22;
    }
    else
    {
      if (!v49) {
        goto LABEL_84;
      }
      uint64_t v54 = sub_1003F26A8();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v54;
      char v51 = "#I Failed to get File attributes of mobile directory: %{public}s using CCMH";
      BOOL v52 = v48;
      uint32_t v53 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, (uint8_t *)&buf, v53);
LABEL_84:
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    uint64_t v56 = ServiceMap;
    if ((v57 & 0x8000000000000000) != 0)
    {
      char v58 = (unsigned __int8 *)(v57 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v59 = 5381;
      do
      {
        std::string::size_type v57 = v59;
        unsigned int v60 = *v58++;
        uint64_t v59 = (33 * v59) ^ v60;
      }
      while (v60);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v57;
    os_log_t v61 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)&buf);
    if (v61)
    {
      uint64_t v63 = v61[3];
      uint64_t v62 = (std::__shared_weak_count *)v61[4];
      if (v62)
      {
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v56);
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v62);
        if (!v63)
        {
LABEL_321:
          sub_10004D2C8(v62);
          goto LABEL_322;
        }
LABEL_93:
        xpc_object_t v218 = 0;
        xpc_object_t v64 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v65 = v64;
        if (v64)
        {
          xpc_object_t v218 = v64;
        }
        else
        {
          xpc_object_t v65 = xpc_null_create();
          xpc_object_t v218 = v65;
          if (!v65)
          {
            xpc_object_t v66 = xpc_null_create();
            xpc_object_t v65 = 0;
            goto LABEL_100;
          }
        }
        if (xpc_get_type(v65) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v65);
          goto LABEL_101;
        }
        xpc_object_t v66 = xpc_null_create();
LABEL_100:
        xpc_object_t v218 = v66;
LABEL_101:
        xpc_release(v65);
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v67 = (const char *)a2;
        }
        else {
          uint64_t v67 = *(const char **)a2;
        }
        xpc_object_t v216 = xpc_string_create(v67);
        if (!v216) {
          xpc_object_t v216 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"file_name";
        sub_100035E70((uint64_t)&buf, &v216, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v216);
        xpc_object_t v216 = 0;
        CFErrorGetDomain(v233);
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v215 = buf;
        unsigned int Code = CFErrorGetCode(v233);
        v213[1] = 0;
        v213[0] = 0;
        int64_t v214 = 0;
        (*(void (**)(std::string *__return_ptr))(*(void *)v234 + 120))(&v209);
        long long v69 = std::string::insert(&v209, 0, "Failed to load file:", 0x14uLL);
        long long v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
        v210.__r_.__value_.__r.__words[2] = v69->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v70;
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        uint64_t v71 = std::string::append(&v210, ". Error Domain:", 0xFuLL);
        long long v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
        v211.__r_.__value_.__r.__words[2] = v71->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v211.__r_.__value_.__l.__data_ = v72;
        v71->__r_.__value_.__l.__size_ = 0;
        v71->__r_.__value_.__r.__words[2] = 0;
        v71->__r_.__value_.__r.__words[0] = 0;
        if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFURLRef v73 = &v215;
        }
        else {
          CFURLRef v73 = (std::string *)v215.__r_.__value_.__r.__words[0];
        }
        if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v215.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v215.__r_.__value_.__l.__size_;
        }
        long long v75 = std::string::append(&v211, (const std::string::value_type *)v73, size);
        long long v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
        v212.__r_.__value_.__r.__words[2] = v75->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v76;
        v75->__r_.__value_.__l.__size_ = 0;
        v75->__r_.__value_.__r.__words[2] = 0;
        v75->__r_.__value_.__r.__words[0] = 0;
        long long v77 = std::string::append(&v212, ", Error Code:", 0xDuLL);
        long long v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v78;
        v77->__r_.__value_.__l.__size_ = 0;
        v77->__r_.__value_.__r.__words[2] = 0;
        v77->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v208, Code);
        if ((v208.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v79 = &v208;
        }
        else {
          long long v79 = (std::string *)v208.__r_.__value_.__r.__words[0];
        }
        if ((v208.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v80 = HIBYTE(v208.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v80 = v208.__r_.__value_.__l.__size_;
        }
        v81 = std::string::append(&buf, (const std::string::value_type *)v79, v80);
        long long v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
        int64_t v214 = v81->__r_.__value_.__r.__words[2];
        *(_OWORD *)v213 = v82;
        v81->__r_.__value_.__l.__size_ = 0;
        v81->__r_.__value_.__r.__words[2] = 0;
        v81->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v208.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v208.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v211.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v210.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v209.__r_.__value_.__l.__data_);
        }
        if (v214 >= 0) {
          uint64_t v83 = v213;
        }
        else {
          uint64_t v83 = (void **)v213[0];
        }
        xpc_object_t v206 = xpc_string_create((const char *)v83);
        if (!v206) {
          xpc_object_t v206 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"failure_reason";
        sub_100035E70((uint64_t)&buf, &v206, &v207);
        xpc_release(v207);
        xpc_object_t v207 = 0;
        xpc_release(v206);
        xpc_object_t v206 = 0;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v229, @"CopyFileAttributes");
        CFDictionaryRef v85 = Value;
        if (!Value || (CFTypeID v86 = CFGetTypeID(Value), v86 != CFDictionaryGetTypeID()))
        {
LABEL_316:
          if (SHIBYTE(v214) < 0) {
            operator delete(v213[0]);
          }
          if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v215.__r_.__value_.__l.__data_);
          }
          xpc_release(v218);
          if (!v62) {
            goto LABEL_322;
          }
          goto LABEL_321;
        }
        CFDictionaryGetValue(v85, @"NSFileOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v212 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v87 = &v212;
        }
        else {
          long long v87 = (std::string *)v212.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v204 = xpc_string_create((const char *)v87);
        if (!v204) {
          xpc_object_t v204 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"ownerName";
        sub_100035E70((uint64_t)&buf, &v204, &v205);
        xpc_release(v205);
        xpc_object_t v205 = 0;
        xpc_release(v204);
        xpc_object_t v204 = 0;
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        CFDictionaryGetValue(v85, @"NSFileGroupOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v212 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v88 = &v212;
        }
        else {
          long long v88 = (std::string *)v212.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v202 = xpc_string_create((const char *)v88);
        if (!v202) {
          xpc_object_t v202 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"groupName";
        sub_100035E70((uint64_t)&buf, &v202, &v203);
        xpc_release(v203);
        xpc_object_t v203 = 0;
        xpc_release(v202);
        xpc_object_t v202 = 0;
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        CFTypeRef v89 = (int *)CFDictionaryGetValue(v85, @"NSFilePosixPermissions");
        char v90 = v89;
        LODWORD(buf.__r_.__value_.__l.__data_) = 0;
        if (v89)
        {
          CFTypeID v91 = CFGetTypeID(v89);
          if (v91 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf, v90, v92);
          }
        }
        xpc_object_t v200 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
        if (!v200) {
          xpc_object_t v200 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"permissions";
        sub_100035E70((uint64_t)&buf, &v200, &v201);
        xpc_release(v201);
        xpc_object_t v201 = 0;
        xpc_release(v200);
        xpc_object_t v200 = 0;
        CFDictionaryGetValue(v85, @"NSFileProtectionKey");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        __src = (void *)buf.__r_.__value_.__r.__words[0];
        LODWORD(v211.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v211.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                            + 3);
        int v93 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          if (!buf.__r_.__value_.__l.__size_) {
            goto LABEL_165;
          }
          sub_10004FC84(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
        }
        else
        {
          if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
            goto LABEL_165;
          }
          long long __p = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_DWORD *)v196 = v211.__r_.__value_.__l.__data_;
          *(_DWORD *)&v196[3] = *(_DWORD *)((char *)v211.__r_.__value_.__r.__words + 3);
          char v197 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        unsigned int v94 = sub_10040CA90((const void **)&__p);
        xpc_object_t v198 = xpc_int64_create(v94);
        if (!v198) {
          xpc_object_t v198 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"DataProtectionClass";
        sub_100035E70((uint64_t)&buf, &v198, &v199);
        xpc_release(v199);
        xpc_object_t v199 = 0;
        xpc_release(v198);
        xpc_object_t v198 = 0;
        if (v197 < 0) {
          operator delete((void *)__p);
        }
LABEL_165:
        if (v226) {
          v95 = sub_100080778;
        }
        else {
          v95 = 0;
        }
        if (v95)
        {
          CFDictionaryRef v96 = (const __CFDictionary *)CFDictionaryGetValue(v226, @"CopyFileAttributes");
          CFDictionaryRef v97 = v96;
          if (v96)
          {
            CFTypeID v98 = CFGetTypeID(v96);
            if (v98 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v97, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v99 = &v212;
              }
              else {
                long long v99 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v193 = xpc_string_create((const char *)v99);
              if (!v193) {
                xpc_object_t v193 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesOwnerName";
              sub_100035E70((uint64_t)&buf, &v193, &v194);
              xpc_release(v194);
              xpc_object_t v194 = 0;
              xpc_release(v193);
              xpc_object_t v193 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v97, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v100 = &v212;
              }
              else {
                long long v100 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v191 = xpc_string_create((const char *)v100);
              if (!v191) {
                xpc_object_t v191 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesGroupName";
              sub_100035E70((uint64_t)&buf, &v191, &v192);
              xpc_release(v192);
              xpc_object_t v192 = 0;
              xpc_release(v191);
              xpc_object_t v191 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              uint64_t v101 = (int *)CFDictionaryGetValue(v97, @"NSFilePosixPermissions");
              uint64_t v102 = v101;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v101)
              {
                CFTypeID v103 = CFGetTypeID(v101);
                if (v103 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v102, v104);
                }
              }
              xpc_object_t v189 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v189) {
                xpc_object_t v189 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesPermissions";
              sub_100035E70((uint64_t)&buf, &v189, &v190);
              xpc_release(v190);
              xpc_object_t v190 = 0;
              xpc_release(v189);
              xpc_object_t v189 = 0;
              CFDictionaryGetValue(v97, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              v105 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v212.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v106 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_200:
                  operator delete(v105);
                  goto LABEL_201;
                }
                sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_201;
                }
                long long __dst = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)v185 = v212.__r_.__value_.__l.__data_;
                *(_DWORD *)&v185[3] = *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3);
                char v186 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v107 = sub_10040CA90((const void **)&__dst);
              xpc_object_t v187 = xpc_int64_create(v107);
              if (!v187) {
                xpc_object_t v187 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v187, &v188);
              xpc_release(v188);
              xpc_object_t v188 = 0;
              xpc_release(v187);
              xpc_object_t v187 = 0;
              if (v186 < 0) {
                operator delete((void *)__dst);
              }
              if (v106 < 0) {
                goto LABEL_200;
              }
            }
          }
        }
LABEL_201:
        if (v223) {
          v108 = sub_100080778;
        }
        else {
          v108 = 0;
        }
        if (v108)
        {
          CFDictionaryRef v109 = (const __CFDictionary *)CFDictionaryGetValue(v223, @"CopyFileAttributes");
          CFDictionaryRef v110 = v109;
          if (v109)
          {
            CFTypeID v111 = CFGetTypeID(v109);
            if (v111 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v110, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                v112 = &v212;
              }
              else {
                v112 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v182 = xpc_string_create((const char *)v112);
              if (!v182) {
                xpc_object_t v182 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesOwnerName";
              sub_100035E70((uint64_t)&buf, &v182, &v183);
              xpc_release(v183);
              xpc_object_t v183 = 0;
              xpc_release(v182);
              xpc_object_t v182 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v110, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                v113 = &v212;
              }
              else {
                v113 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v180 = xpc_string_create((const char *)v113);
              if (!v180) {
                xpc_object_t v180 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesGroupName";
              sub_100035E70((uint64_t)&buf, &v180, &v181);
              xpc_release(v181);
              xpc_object_t v181 = 0;
              xpc_release(v180);
              xpc_object_t v180 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              v114 = (int *)CFDictionaryGetValue(v110, @"NSFilePosixPermissions");
              v115 = v114;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v114)
              {
                CFTypeID v116 = CFGetTypeID(v114);
                if (v116 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v115, v117);
                }
              }
              xpc_object_t v178 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v178) {
                xpc_object_t v178 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesPermissions";
              sub_100035E70((uint64_t)&buf, &v178, &v179);
              xpc_release(v179);
              xpc_object_t v179 = 0;
              xpc_release(v178);
              xpc_object_t v178 = 0;
              CFDictionaryGetValue(v110, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              v118 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v212.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v119 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_236:
                  operator delete(v118);
                  goto LABEL_237;
                }
                sub_10004FC84(&v173, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_237;
                }
                long long v173 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)v174 = v212.__r_.__value_.__l.__data_;
                *(_DWORD *)&v174[3] = *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3);
                char v175 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v120 = sub_10040CA90((const void **)&v173);
              xpc_object_t v176 = xpc_int64_create(v120);
              if (!v176) {
                xpc_object_t v176 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v176, &v177);
              xpc_release(v177);
              xpc_object_t v177 = 0;
              xpc_release(v176);
              xpc_object_t v176 = 0;
              if (v175 < 0) {
                operator delete((void *)v173);
              }
              if (v119 < 0) {
                goto LABEL_236;
              }
            }
          }
        }
LABEL_237:
        if (theDict) {
          v121 = sub_100080778;
        }
        else {
          v121 = 0;
        }
        if (v121)
        {
          CFDictionaryRef v122 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CopyFileAttributes");
          CFDictionaryRef v123 = v122;
          if (v122)
          {
            CFTypeID v124 = CFGetTypeID(v122);
            if (v124 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v123, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                v125 = &v212;
              }
              else {
                v125 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v171 = xpc_string_create((const char *)v125);
              if (!v171) {
                xpc_object_t v171 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryOwnerName";
              sub_100035E70((uint64_t)&buf, &v171, &v172);
              xpc_release(v172);
              xpc_object_t v172 = 0;
              xpc_release(v171);
              xpc_object_t v171 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v123, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v212 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                v126 = &v212;
              }
              else {
                v126 = (std::string *)v212.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v169 = xpc_string_create((const char *)v126);
              if (!v169) {
                xpc_object_t v169 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryGroupName";
              sub_100035E70((uint64_t)&buf, &v169, &v170);
              xpc_release(v170);
              xpc_object_t v170 = 0;
              xpc_release(v169);
              xpc_object_t v169 = 0;
              if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v212.__r_.__value_.__l.__data_);
              }
              v127 = (int *)CFDictionaryGetValue(v123, @"NSFilePosixPermissions");
              v128 = v127;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v127)
              {
                CFTypeID v129 = CFGetTypeID(v127);
                if (v129 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v128, v130);
                }
              }
              xpc_object_t v167 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v167) {
                xpc_object_t v167 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryPermissions";
              sub_100035E70((uint64_t)&buf, &v167, &v168);
              xpc_release(v168);
              xpc_object_t v168 = 0;
              xpc_release(v167);
              xpc_object_t v167 = 0;
              CFDictionaryGetValue(v123, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              v131 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v212.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v132 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_272:
                  operator delete(v131);
                  goto LABEL_273;
                }
                sub_10004FC84(&v162, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_273;
                }
                long long v162 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)v163 = v212.__r_.__value_.__l.__data_;
                *(_DWORD *)&v163[3] = *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3);
                char v164 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v133 = sub_10040CA90((const void **)&v162);
              xpc_object_t v165 = xpc_int64_create(v133);
              if (!v165) {
                xpc_object_t v165 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v165, &v166);
              xpc_release(v166);
              xpc_object_t v166 = 0;
              xpc_release(v165);
              xpc_object_t v165 = 0;
              if (v164 < 0) {
                operator delete((void *)v162);
              }
              if (v132 < 0) {
                goto LABEL_272;
              }
            }
          }
        }
LABEL_273:
        if (v219) {
          v134 = sub_100080778;
        }
        else {
          v134 = 0;
        }
        if (!v134) {
          goto LABEL_309;
        }
        CFDictionaryRef v135 = (const __CFDictionary *)CFDictionaryGetValue(v219, @"CopyFileAttributes");
        CFDictionaryRef v136 = v135;
        if (!v135) {
          goto LABEL_309;
        }
        CFTypeID v137 = CFGetTypeID(v135);
        if (v137 != CFDictionaryGetTypeID()) {
          goto LABEL_309;
        }
        CFDictionaryGetValue(v136, @"NSFileOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v212 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v138 = &v212;
        }
        else {
          v138 = (std::string *)v212.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v160 = xpc_string_create((const char *)v138);
        if (!v160) {
          xpc_object_t v160 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileOwnerName";
        sub_100035E70((uint64_t)&buf, &v160, &v161);
        xpc_release(v161);
        xpc_object_t v161 = 0;
        xpc_release(v160);
        xpc_object_t v160 = 0;
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        CFDictionaryGetValue(v136, @"NSFileGroupOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v212 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v139 = &v212;
        }
        else {
          v139 = (std::string *)v212.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v158 = xpc_string_create((const char *)v139);
        if (!v158) {
          xpc_object_t v158 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileGroupName";
        sub_100035E70((uint64_t)&buf, &v158, &v159);
        xpc_release(v159);
        xpc_object_t v159 = 0;
        xpc_release(v158);
        xpc_object_t v158 = 0;
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        v140 = (int *)CFDictionaryGetValue(v136, @"NSFilePosixPermissions");
        v141 = v140;
        LODWORD(buf.__r_.__value_.__l.__data_) = 0;
        if (v140)
        {
          CFTypeID v142 = CFGetTypeID(v140);
          if (v142 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf, v141, v143);
          }
        }
        xpc_object_t v156 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
        if (!v156) {
          xpc_object_t v156 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobilePermissions";
        sub_100035E70((uint64_t)&buf, &v156, &v157);
        xpc_release(v157);
        xpc_object_t v157 = 0;
        xpc_release(v156);
        xpc_object_t v156 = 0;
        CFDictionaryGetValue(v136, @"NSFileProtectionKey");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        v144 = (void *)buf.__r_.__value_.__r.__words[0];
        LODWORD(v212.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                            + 3);
        int v145 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          if (!buf.__r_.__value_.__l.__size_)
          {
LABEL_308:
            operator delete(v144);
            goto LABEL_309;
          }
          sub_10004FC84(&v151, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
        }
        else
        {
          if (!*((unsigned char *)&buf.__r_.__value_.__s + 23))
          {
LABEL_309:
            v147 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(a2 + 23) >= 0) {
                std::string::size_type v148 = a2;
              }
              else {
                std::string::size_type v148 = *(void *)a2;
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v148;
              _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I Submitting event for bundle permissions for %s", (uint8_t *)&buf, 0xCu);
            }
            sub_100117418(&v150, &v218);
            (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v63 + 16))(v63, "CarrierBundlePermission", &v150);
            xpc_release(v150);
            xpc_object_t v150 = 0;
            if (v93 < 0) {
              operator delete(__src);
            }
            goto LABEL_316;
          }
          long long v151 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_DWORD *)v152 = v212.__r_.__value_.__l.__data_;
          *(_DWORD *)&v152[3] = *(_DWORD *)((char *)v212.__r_.__value_.__r.__words + 3);
          char v153 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        unsigned int v146 = sub_10040CA90((const void **)&v151);
        xpc_object_t v154 = xpc_int64_create(v146);
        if (!v154) {
          xpc_object_t v154 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v218;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileDataProtectionClass";
        sub_100035E70((uint64_t)&buf, &v154, &v155);
        xpc_release(v155);
        xpc_object_t v155 = 0;
        xpc_release(v154);
        xpc_object_t v154 = 0;
        if (v153 < 0) {
          operator delete((void *)v151);
        }
        if ((v145 & 0x80000000) == 0) {
          goto LABEL_309;
        }
        goto LABEL_308;
      }
      std::mutex::unlock(v56);
      if (v63) {
        goto LABEL_93;
      }
    }
    else
    {
      std::mutex::unlock(v56);
    }
LABEL_322:
    sub_100057D78((const void **)&v219);
    sub_100057D78((const void **)&theDict);
    if (SHIBYTE(v222) < 0) {
      operator delete(v221[0]);
    }
    sub_100057D78((const void **)&v223);
    if (SHIBYTE(v225) < 0) {
      operator delete(v224[0]);
    }
    sub_100057D78((const void **)&v226);
    if (SHIBYTE(v228) < 0) {
      operator delete(v227[0]);
    }
    sub_100057D78((const void **)&v229);
LABEL_329:
    if (v231) {
      sub_10004D2C8(v231);
    }
LABEL_331:
    sub_100057D78((const void **)&v232);
    sub_100127D74((const void **)&v233);
    goto LABEL_332;
  }
  long long v9 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Couldnt get filesystem interface", (uint8_t *)&buf, 2u);
  }
LABEL_332:
  if (v235) {
    sub_10004D2C8(v235);
  }
}

void sub_1006AE038(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_1006AE4B0@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2) {
    os_log_t v4 = sub_100080778;
  }
  else {
    os_log_t v4 = 0;
  }
  std::string::size_type v5 = (os_log_t *)(a1 + 8);
  std::string::size_type v6 = *(NSObject **)(a1 + 8);
  if (v4)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ================================= Lookup GSMA Configuration =================================", buf, 2u);
    }
    sub_100058198(&v26, a2);
    sub_1006A41E4(a1, (CFDictionaryRef *)&v26);
    sub_100057D78(&v26);
    uint64_t v25 = 0;
    long long v23 = 0u;
    memset(v24, 0, sizeof(v24));
    long long v9 = (Registry **)(a1 + 64);
    *(_OWORD *)std::string buf = 0u;
    sub_1007DE21C((uint64_t)buf, a1 + 64);
    *(void *)uint64_t v21 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v11 = *(__CFDictionary **)v21;
      *(void *)uint64_t v21 = Mutable;
      *(void *)&v19[0] = v11;
      sub_10005717C((const void **)v19);
    }
    sub_10010F3F0(*(__CFDictionary **)v21, (void *)qword_101B13EC0, @"OtherKnown.bundle");
    uint64_t v20 = 0;
    memset(v19, 0, sizeof(v19));
    sub_1007DE21C((uint64_t)v19, a1 + 64);
    sub_10004EFE4(&v18, (CFTypeRef *)v21);
    BOOL v12 = sub_1006A3488(a1, (const __CFDictionary **)&v18, 1, (uint64_t)buf, 1);
    sub_100057D78(&v18);
    if (v12)
    {
      sub_100058198(&v17, a2);
      if (SHIBYTE(v24[1]) < 0)
      {
        sub_10004FC84(__p, *((void **)&v24[0] + 1), *(unint64_t *)&v24[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)((char *)v24 + 8);
        uint64_t v16 = *((void *)&v24[1] + 1);
      }
      sub_1004D3D0C(v5, v9, &v17, (long long *)__p, (unsigned char *)a3);
      if (SHIBYTE(v16) < 0) {
        operator delete(__p[0]);
      }
      sub_100057D78(&v17);
    }
    else
    {
      std::string v14 = *v5;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find GSMA bundle.", (uint8_t *)__p, 2u);
      }
      sub_100058DB0((void *)a3, "");
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = 0;
    }
    sub_1007DE5C8((uint64_t)v19);
    sub_10005717C((const void **)v21);
    return (void *)sub_1007DE5C8((uint64_t)buf);
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Matching info missing.", buf, 2u);
    }
    __n128 result = sub_100058DB0((void *)a3, "");
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
  }
  return result;
}

void sub_1006AE794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,const void *a46,__int16 a47,char a48,char a49)
{
}

void sub_1006AE80C(uint64_t a1)
{
  uint64_t v34 = 0;
  long long v35 = 0;
  Registry::getMobileHelper(&v34, *(Registry **)(a1 + 64));
  if (v34)
  {
    *(void *)long long v31 = 0;
    std::string::size_type v32 = 0;
    uint64_t v33 = 0;
    sub_100058DB0(v31, "/var/mobile/Library/");
    uint64_t v2 = 0;
    while (1)
    {
      size_t v3 = off_1019F8C98[v2];
      v29[0] = 0;
      v29[1] = 0;
      int64_t v30 = 0;
      os_log_t v4 = (std::string *)sub_100058DB0(&buf, v3);
      if (v33 >= 0) {
        std::string::size_type v5 = v31;
      }
      else {
        std::string::size_type v5 = *(uint8_t **)v31;
      }
      if (v33 >= 0) {
        std::string::size_type v6 = HIBYTE(v33);
      }
      else {
        std::string::size_type v6 = v32;
      }
      std::string::size_type v7 = std::string::insert(v4, 0, (const std::string::value_type *)v5, v6);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      int64_t v30 = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)BOOL v29 = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v38) < 0) {
        operator delete((void *)buf);
      }
      if (!(*(unsigned int (**)(void, void **))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), v29))goto LABEL_22; {
      uint64_t v9 = v34;
      }
      if (v30 >= 0) {
        uint64_t v10 = (char *)v29;
      }
      else {
        uint64_t v10 = (char *)v29[0];
      }
      sub_100058DB0(&buf, v10);
      sub_100058DB0(&__p, "");
      char v11 = (*(uint64_t (**)(uint64_t, long long *, std::string *))(*(void *)v9 + 120))(v9, &buf, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v38) < 0)
      {
        operator delete((void *)buf);
        if ((v11 & 1) == 0)
        {
LABEL_21:
          BOOL v12 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            if (v30 >= 0) {
              CFDictionaryRef v13 = v29;
            }
            else {
              CFDictionaryRef v13 = (void **)v29[0];
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v13;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to remove %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      else if ((v11 & 1) == 0)
      {
        goto LABEL_21;
      }
LABEL_22:
      if (SHIBYTE(v30) < 0) {
        operator delete(v29[0]);
      }
      if (++v2 == 8)
      {
        v29[0] = 0;
        v29[1] = 0;
        int64_t v30 = 0;
        sub_100058DB0(v29, "/var/mobile/Library/Preferences/");
        uint64_t v14 = 0;
        while (1)
        {
          std::string v15 = off_1019F8CD8[v14];
          long long buf = 0uLL;
          long long v38 = 0;
          sub_100058DB0(&__p, v15);
          if (v30 >= 0) {
            uint64_t v16 = v29;
          }
          else {
            uint64_t v16 = (void **)v29[0];
          }
          if (v30 >= 0) {
            std::string::size_type v17 = HIBYTE(v30);
          }
          else {
            std::string::size_type v17 = (std::string::size_type)v29[1];
          }
          char v18 = std::string::insert(&__p, 0, (const std::string::value_type *)v16, v17);
          long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
          long long v38 = (std::__shared_weak_count *)v18->__r_.__value_.__r.__words[2];
          long long buf = v19;
          v18->__r_.__value_.__l.__size_ = 0;
          v18->__r_.__value_.__r.__words[2] = 0;
          v18->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (!(*(unsigned int (**)(void, long long *))(**(void **)(a1 + 48) + 208))(*(void *)(a1 + 48), &buf))goto LABEL_49; {
          uint64_t v20 = v34;
          }
          if (SHIBYTE(v38) >= 0) {
            p_long long buf = (char *)&buf;
          }
          else {
            p_long long buf = (char *)buf;
          }
          sub_100058DB0(&__p, p_buf);
          sub_100058DB0(v27, "");
          char v22 = (*(uint64_t (**)(uint64_t, std::string *, void **))(*(void *)v20 + 120))(v20, &__p, v27);
          if (v28 < 0) {
            operator delete(v27[0]);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if ((v22 & 1) == 0)
            {
LABEL_48:
              long long v23 = *(NSObject **)(a1 + 8);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              {
                if (SHIBYTE(v38) >= 0) {
                  uint32_t v24 = &buf;
                }
                else {
                  uint32_t v24 = (long long *)buf;
                }
                LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
                _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to remove %s", (uint8_t *)&__p, 0xCu);
              }
            }
          }
          else if ((v22 & 1) == 0)
          {
            goto LABEL_48;
          }
LABEL_49:
          if (SHIBYTE(v38) < 0) {
            operator delete((void *)buf);
          }
          if (++v14 == 15)
          {
            uint64_t v25 = v35;
            *(void *)&long long buf = a1;
            *((void *)&buf + 1) = v34;
            long long v38 = v35;
            if (v35) {
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            sub_1006AEDE4((uint64_t *)&buf, 1);
            sub_1006AEDE4((uint64_t *)&buf, 2);
            if (v25) {
              sub_10004D2C8(v25);
            }
            if (SHIBYTE(v30) < 0) {
              operator delete(v29[0]);
            }
            if (SHIBYTE(v33) < 0) {
              operator delete(*(void **)v31);
            }
            goto LABEL_67;
          }
        }
      }
    }
  }
  CFDictionaryRef v26 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long v31 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to create bundle directories, MobileHelper is not found", v31, 2u);
  }
LABEL_67:
  if (v35) {
    sub_10004D2C8(v35);
  }
}

void sub_1006AECF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a33) {
    sub_10004D2C8(a33);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006AEDE4(uint64_t *a1, int a2)
{
  uint64_t v4 = *a1;
  v18[0] = 0;
  v18[1] = 0;
  uint64_t v19 = 0;
  getUserBundleLocation(a2, v18);
  if ((*(unsigned int (**)(void, void **))(**(void **)(v4 + 48) + 208))(*(void *)(v4 + 48), v18))
  {
    uint64_t v5 = a1[1];
    if (v19 >= 0) {
      std::string::size_type v6 = (char *)v18;
    }
    else {
      std::string::size_type v6 = (char *)v18[0];
    }
    sub_100058DB0(&buf, v6);
    sub_100058DB0(__p, "");
    char v7 = (*(uint64_t (**)(uint64_t, std::string *, unsigned char *))(*(void *)v5 + 120))(v5, &buf, __p);
    if (v21 < 0) {
      operator delete(*(void **)__p);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if (v7) {
        goto LABEL_12;
      }
    }
    else if (v7)
    {
      goto LABEL_12;
    }
    long long v8 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = v18;
      if (v19 < 0) {
        uint64_t v14 = (void **)v18[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to remove %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_12:
  memset(&buf, 0, sizeof(buf));
  double UserBundlePrefsFilePath = getUserBundlePrefsFilePath(a2, &buf);
  if (!(*(unsigned int (**)(void, std::string *, double))(**(void **)(v4 + 48) + 208))(*(void *)(v4 + 48), &buf, UserBundlePrefsFilePath))goto LABEL_23; {
  uint64_t v10 = a1[1];
  }
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_std::string buf = &buf;
  }
  else {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  sub_100058DB0(__p, (char *)p_buf);
  sub_100058DB0(v16, "");
  char v12 = (*(uint64_t (**)(uint64_t, unsigned char *, void **))(*(void *)v10 + 120))(v10, __p, v16);
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  if (v21 < 0)
  {
    operator delete(*(void **)__p);
    if (v12) {
      goto LABEL_23;
    }
  }
  else if (v12)
  {
    goto LABEL_23;
  }
  CFDictionaryRef v13 = *(NSObject **)(v4 + 8);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    std::string v15 = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string v15 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to remove %s", __p, 0xCu);
  }
LABEL_23:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
}

void sub_1006AF0D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 41) < 0) {
    operator delete(*(void **)(v26 - 64));
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006AF150(uint64_t a1)
{
  uint64_t v2 = (char *)sub_1003F26A8();
  sub_100058DB0(&v36, v2);
  size_t v3 = (const char *)kUserCBDir;
  size_t v4 = strlen(kUserCBDir);
  uint64_t v5 = std::string::append(&v36, kUserCBDir, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  char v7 = (char *)kOverlayDir;
  sub_100058DB0(&__p, kOverlayDir);
  if ((v35 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v35 & 0x80u) == 0) {
    std::string::size_type v9 = v35;
  }
  else {
    std::string::size_type v9 = v34;
  }
  uint64_t v10 = std::string::append(&v37, p_p, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  int v12 = sub_1006AF50C(a1, (uint64_t *)(a1 + 144), (uint64_t)&v38);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if ((char)v35 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v36.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef v13 = (char *)sub_1003F26A8();
  sub_100058DB0(&v36, v13);
  size_t v14 = strlen(kUserCountryBundleDir);
  std::string v15 = std::string::append(&v36, kUserCountryBundleDir, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  sub_100058DB0(&__p, v7);
  if ((v35 & 0x80u) == 0) {
    char v17 = (const std::string::value_type *)&__p;
  }
  else {
    char v17 = (const std::string::value_type *)__p;
  }
  if ((v35 & 0x80u) == 0) {
    std::string::size_type v18 = v35;
  }
  else {
    std::string::size_type v18 = v34;
  }
  uint64_t v19 = std::string::append(&v37, v17, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  int v21 = sub_1006AF50C(a1, (uint64_t *)(a1 + 192), (uint64_t)&v38);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if ((char)v35 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v36.__r_.__value_.__l.__data_);
  }
  char v22 = (char *)sub_1003F26A8();
  sub_100058DB0(&v38, v22);
  size_t v23 = strlen(v3);
  uint32_t v24 = std::string::append(&v38, v3, v23);
  std::string v32 = *v24;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  int v25 = sub_1006AFBA4(a1, (uint64_t)&v32);
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  uint64_t v26 = (char *)sub_1003F26A8();
  sub_100058DB0(&v38, v26);
  size_t v27 = strlen(kUserCountryBundleDir);
  char v28 = std::string::append(&v38, kUserCountryBundleDir, v27);
  std::string v31 = *v28;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  unsigned int v29 = sub_1006AFBA4(a1, (uint64_t)&v31);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  return v12 | v21 | v25 | v29;
}

void sub_1006AF454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v40 - 57) < 0) {
    operator delete(*(void **)(v40 - 80));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006AF50C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v44 = (uint64_t)&v44;
  uint64_t v45 = &v44;
  uint64_t v46 = 0;
  if ((*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(a1 + 48) + 96))(*(void *)(a1 + 48), a2, &v44, 1))
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    char v6 = 0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        char v7 = a2;
      }
      else {
        char v7 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      long long v8 = "#I Unable to get user dir: %{public}s contents";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v8, buf, 0xCu);
      char v6 = 0;
    }
  }
  else
  {
    if (!v46)
    {
      uint64_t v5 = *(NSObject **)(a1 + 8);
      char v6 = 0;
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_82;
      }
      if (*((char *)a2 + 23) >= 0) {
        std::string::size_type v18 = a2;
      }
      else {
        std::string::size_type v18 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v18;
      long long v8 = "#I No contents in user dir: %{public}s contents";
      goto LABEL_7;
    }
    CFIndex v41 = 0;
    double v42 = 0;
    unint64_t v43 = 0;
    std::string::size_type v9 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Clearing Trial bundles in %{public}s:", buf, 0xCu);
    }
    long long v11 = v45;
    if (v45 == &v44)
    {
      char v6 = 0;
    }
    else
    {
      char v6 = 0;
      do
      {
        uint64_t v58 = 0;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        *(_OWORD *)std::string buf = 0u;
        sub_1007DE21C((uint64_t)buf, a1 + 64);
        int v12 = v11 + 2;
        sub_1007DE874((uint64_t)buf, (std::string *)(v11 + 2));
        if (sub_1007E2F64((uint64_t)buf))
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v40 = 0;
          sub_1007DF670((uint64_t)buf, &v38);
          long long v59 = 0uLL;
          uint64_t v60 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v59;
          uint64_t v40 = v60;
          sub_1000558F4(&v38);
          if (sub_1007E1374((uint64_t)buf))
          {
            CFDictionaryRef v13 = v42;
            if ((unint64_t)v42 >= v43)
            {
              char v17 = (unsigned char *)sub_1000D8CE8((uint64_t *)&v41, (long long *)__p);
            }
            else
            {
              if (SHIBYTE(v40) < 0)
              {
                sub_10004FC84(v42, __p[0], (unint64_t)__p[1]);
              }
              else
              {
                long long v14 = *(_OWORD *)__p;
                *((void *)v42 + 2) = v40;
                *CFDictionaryRef v13 = v14;
              }
              char v17 = (char *)v13 + 24;
            }
            double v42 = v17;
            char v6 = 1;
          }
          else
          {
            long long v16 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              if (*((char *)v11 + 39) < 0) {
                int v12 = (void *)*v12;
              }
              LODWORD(v59) = 136315138;
              *(void *)((char *)&v59 + 4) = v12;
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to remove bundle %s", (uint8_t *)&v59, 0xCu);
            }
          }
          if (SHIBYTE(v40) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          std::string v15 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v59) = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Not trial bundle", (uint8_t *)&v59, 2u);
          }
        }
        sub_1007DE5C8((uint64_t)buf);
        long long v11 = (uint64_t *)v11[1];
      }
      while (v11 != &v44);
    }
    if (v41 != v42)
    {
      *(void *)std::string buf = buf;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&long long v48 = 0;
      if ((*(uint64_t (**)(void, uint64_t, uint8_t *, uint64_t))(**(void **)(a1 + 48) + 96))(*(void *)(a1 + 48), a3, buf, 1))
      {
        BOOL v19 = (void)v48 == 0;
      }
      else
      {
        BOOL v19 = 0;
      }
      if (!v19)
      {
        long long v20 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) >= 0) {
            int v21 = a2;
          }
          else {
            int v21 = (uint64_t *)*a2;
          }
          LODWORD(v59) = 136446210;
          *(void *)((char *)&v59 + 4) = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Clearing Overlay files from: %{public}s", (uint8_t *)&v59, 0xCu);
        }
        for (uint64_t i = *(void *)&buf[8]; (uint8_t *)i != buf; uint64_t i = *(void *)(i + 8))
        {
          uint32_t v24 = v41;
          for (j = v42; v24 != j; v24 += 24)
          {
            if (*(char *)(i + 39) < 0)
            {
              uint64_t v26 = *(char **)(i + 16);
              uint64_t v25 = *(void *)(i + 24);
            }
            else
            {
              uint64_t v25 = *(unsigned __int8 *)(i + 39);
              uint64_t v26 = (char *)(i + 16);
            }
            int v27 = (char)v24[23];
            if (v27 >= 0) {
              char v28 = v24;
            }
            else {
              char v28 = *(char **)v24;
            }
            if (v27 >= 0) {
              int64_t v29 = v24[23];
            }
            else {
              int64_t v29 = *((void *)v24 + 1);
            }
            if (v29)
            {
              if (v25 >= v29)
              {
                int64_t v30 = &v26[v25];
                int v31 = *v28;
                std::string v32 = v26;
                do
                {
                  uint64_t v33 = v25 - v29;
                  if (v33 == -1) {
                    break;
                  }
                  std::string::size_type v34 = (char *)memchr(v32, v31, v33 + 1);
                  if (!v34) {
                    break;
                  }
                  unsigned __int8 v35 = v34;
                  if (!memcmp(v34, v28, v29))
                  {
                    if (v35 == v30 || v35 - v26 == -1) {
                      break;
                    }
                    goto LABEL_73;
                  }
                  std::string v32 = v35 + 1;
                  uint64_t v25 = v30 - (v35 + 1);
                }
                while (v25 >= v29);
              }
            }
            else
            {
LABEL_73:
              __p[0] = 0;
              __p[1] = 0;
              Registry::getMobileHelper((uint64_t *)__p, *(Registry **)(a1 + 64));
              if (__p[0])
              {
                long long v59 = 0uLL;
                uint64_t v60 = 0;
                (*(void (**)(void *, uint64_t, long long *))(*(void *)__p[0] + 120))(__p[0], i + 16, &v59);
                if (SHIBYTE(v60) < 0) {
                  operator delete((void *)v59);
                }
              }
              if (__p[1]) {
                sub_10004D2C8((std::__shared_weak_count *)__p[1]);
              }
            }
          }
        }
      }
      sub_1001257B0(buf);
    }
    *(void *)std::string buf = &v41;
    sub_100047F64((void ***)buf);
  }
LABEL_82:
  sub_1001257B0(&v44);
  return v6 & 1;
}

void sub_1006AFAE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char *a26)
{
  a26 = &a20;
  sub_100047F64((void ***)&a26);
  sub_1001257B0(&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_1006AFBA4(uint64_t a1, uint64_t a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v16 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  ctu::path_join_impl();
  uint64_t v12 = (uint64_t)&v12;
  CFDictionaryRef v13 = &v12;
  uint64_t v14 = 0;
  if ((*(uint64_t (**)(void, void **, uint64_t *, uint64_t))(**(void **)(a1 + 48) + 96))(*(void *)(a1 + 48), __dst, &v12, 1))
  {
    BOOL v3 = v14 == 0;
  }
  else
  {
    BOOL v3 = 0;
  }
  if (v3) {
    goto LABEL_25;
  }
  size_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = __dst;
    if (v16 < 0) {
      uint64_t v5 = (void **)__dst[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Re-installing bundle from %{public}s:", buf, 0xCu);
  }
  char v6 = v13;
  if (v13 == &v12)
  {
LABEL_25:
    LOBYTE(v7) = 0;
  }
  else
  {
    int v7 = 0;
    do
    {
      *(_OWORD *)std::string buf = 0uLL;
      uint64_t v8 = *(void *)(a1 + 40);
      if (*((char *)v6 + 39) < 0)
      {
        sub_10004FC84(__p, (void *)v6[2], v6[3]);
      }
      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)v6 + 1);
        uint64_t v11 = v6[4];
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v8 + 72))(buf, v8, __p);
      if (SHIBYTE(v11) < 0) {
        operator delete(__p[0]);
      }
      if (*(void *)buf) {
        v7 |= (*(uint64_t (**)(void))(**(void **)buf + 24))(*(void *)buf);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      char v6 = (uint64_t *)v6[1];
    }
    while (v6 != &v12);
  }
  sub_1001257B0(&v12);
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  return v7 & 1;
}

void sub_1006AFDF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const void **sub_1006AFE54(uint64_t a1)
{
  sub_1007DE5C8(a1 + 88);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  return sub_100057D78((const void **)a1);
}

void sub_1006AFEC0(uint64_t a1, unsigned __int8 a2, int a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v18 = 0;
  uint64_t v8 = sub_1006B005C(a1, &v18, a2, a3);
  if (!*v8)
  {
    std::string::size_type v9 = v8;
    uint64_t v10 = *a4;
    uint64_t v17 = 0;
    uint64_t v11 = (char *)operator new(0x138uLL);
    v16[0] = v11;
    v16[1] = a1 + 8;
    *((void *)v11 + 5) = *(void *)a5;
    *((void *)v11 + 4) = v10;
    *(void *)a5 = 0;
    *((_DWORD *)v11 + 12) = *(_DWORD *)(a5 + 8);
    *(_OWORD *)(v11 + 56) = *(_OWORD *)(a5 + 16);
    *((void *)v11 + 9) = *(void *)(a5 + 32);
    *(void *)(a5 + 16) = 0;
    *(void *)(a5 + 24) = 0;
    long long v12 = *(_OWORD *)(a5 + 40);
    *((void *)v11 + 12) = *(void *)(a5 + 56);
    *((_OWORD *)v11 + 5) = v12;
    *(void *)(a5 + 32) = 0;
    *(void *)(a5 + 40) = 0;
    *(void *)(a5 + 48) = 0;
    *(void *)(a5 + 56) = 0;
    long long v13 = *(_OWORD *)(a5 + 64);
    *((void *)v11 + 15) = *(void *)(a5 + 80);
    *(void *)(a5 + 64) = 0;
    *(void *)(a5 + 72) = 0;
    *(void *)(a5 + 80) = 0;
    *(_OWORD *)(v11 + 104) = v13;
    sub_1007DE310((uint64_t)(v11 + 128), a5 + 88);
    LOBYTE(v17) = 1;
    uint64_t v14 = v18;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v14;
    *std::string::size_type v9 = (uint64_t)v11;
    uint64_t v15 = **(void **)a1;
    if (v15)
    {
      *(void *)a1 = v15;
      uint64_t v11 = (char *)*v9;
    }
    sub_100046C90(*(uint64_t **)(a1 + 8), (uint64_t *)v11);
    ++*(void *)(a1 + 16);
    v16[0] = 0;
    sub_1006B00D4((uint64_t)v16);
  }
}

void sub_1006B0010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v9[127] < 0) {
    operator delete(*v13);
  }
  if (v9[103] < 0) {
    operator delete(*v12);
  }
  if (v9[79] < 0) {
    operator delete(*v11);
  }
  sub_100057D78(v10);
  sub_1006B00D4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006B005C(uint64_t a1, void *a2, unsigned __int8 a3, int a4)
{
  char v6 = *(uint64_t **)(a1 + 8);
  __n128 result = (uint64_t *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    while (1)
    {
      int v7 = v5;
      unsigned int v8 = *((unsigned __int8 *)v5 + 32);
      if (v8 == a3)
      {
        int v9 = *((_DWORD *)v7 + 9);
        BOOL v10 = v9 == a4;
        if (v9 <= a4)
        {
          if (v9 >= a4) {
            char v11 = 1;
          }
          else {
            char v11 = -1;
          }
          if (v10) {
            char v11 = 0;
          }
          if ((v11 & 0x80) == 0) {
            goto LABEL_21;
          }
          goto LABEL_18;
        }
LABEL_12:
        uint64_t v5 = (uint64_t *)*v7;
        __n128 result = v7;
        if (!*v7) {
          goto LABEL_21;
        }
      }
      else
      {
        if (v8 > a3) {
          goto LABEL_12;
        }
        if (v8 >= a3) {
          char v12 = 1;
        }
        else {
          char v12 = -1;
        }
        if ((v12 & 0x80) == 0) {
          goto LABEL_21;
        }
LABEL_18:
        __n128 result = v7 + 1;
        uint64_t v5 = (uint64_t *)v7[1];
        if (!v5) {
          goto LABEL_21;
        }
      }
    }
  }
  int v7 = result;
LABEL_21:
  *a2 = v7;
  return result;
}

void sub_1006B00D4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1006B012C((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

const void **sub_1006B012C(uint64_t a1)
{
  sub_1007DE5C8(a1 + 96);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  return sub_100057D78((const void **)(a1 + 8));
}

uint64_t sub_1006B0198(uint64_t a1, long long *a2, uint64_t a3)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  sub_1007DE310(a1 + 24, a3);
  return a1;
}

void sub_1006B01DC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1006B01F8(void *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

uint64_t sub_1006B0230(uint64_t result, const void **a2, uint64_t a3, char a4)
{
  unsigned int v8 = (const void **)result;
LABEL_2:
  uint64_t v9 = (uint64_t)v8;
  long long v75 = v8 + 10;
  long long v76 = v8 + 5;
  BOOL v10 = v8 + 1;
  CFURLRef v73 = v8 - 5;
  while (1)
  {
    uint64_t v11 = (uint64_t)a2 - v9;
    uint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a2 - v9) >> 3);
    if (!(!v5 & v4))
    {
      switch(v12)
      {
        case 0:
        case 1:
          return result;
        case 2:
          std::string::size_type v34 = a2 - 5;
          __n128 result = sub_1006B10C0(v34, (const void **)v9);
          if (result) {
            __n128 result = (uint64_t)sub_1006B0D24(v9, (uint64_t)v34);
          }
          break;
        case 3:
          __n128 result = (uint64_t)sub_1006B0DBC((const void **)v9, (const void **)(v9 + 40), a2 - 5);
          break;
        case 4:
          __n128 result = (uint64_t)sub_1006B14B4((const void **)v9, (const void **)(v9 + 40), (const void **)(v9 + 80), a2 - 5);
          break;
        case 5:
          __n128 result = (uint64_t)sub_1006B155C((const void **)v9, (const void **)(v9 + 40), (const void **)(v9 + 80), (const void **)(v9 + 120), a2 - 5);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 959) {
      break;
    }
    if (!a3)
    {
      if ((const void **)v9 != a2)
      {
        CFURLRef v74 = a2;
        int64_t v43 = (unint64_t)(v12 - 2) >> 1;
        int64_t v44 = v43;
        do
        {
          int64_t v45 = v44;
          if (v43 >= v44)
          {
            uint64_t v46 = (2 * v44) | 1;
            uint64_t v47 = (const void **)(v9 + 40 * v46);
            if (2 * v44 + 2 < v12 && sub_1006B10C0((const void **)(v9 + 40 * v46), v47 + 5))
            {
              v47 += 5;
              uint64_t v46 = 2 * v45 + 2;
            }
            long long v48 = (const void **)(v9 + 40 * v45);
            __n128 result = sub_1006B10C0(v47, v48);
            if ((result & 1) == 0)
            {
              uint64_t v83 = 0;
              long long v81 = 0u;
              long long v82 = 0u;
              sub_100119B5C((const void **)&v81, (const void **)(v9 + 40 * v45));
              uint64_t v49 = v9 + 40 * v45;
              uint64_t v50 = *(void *)(v49 + 8);
              LOBYTE(v82) = *(unsigned char *)(v49 + 16);
              *((void *)&v81 + 1) = v50;
              *((void *)&v82 + 1) = *(void *)(v49 + 24);
              long long v51 = *(std::__shared_weak_count **)(v49 + 32);
              uint64_t v83 = v51;
              if (v51) {
                atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              do
              {
                uint64_t v52 = (uint64_t)v47;
                sub_1006A5E9C((uint64_t)v48, (uint64_t)v47);
                if (v43 < v46) {
                  break;
                }
                uint64_t v53 = (2 * v46) | 1;
                uint64_t v47 = (const void **)(v9 + 40 * v53);
                uint64_t v46 = 2 * v46 + 2;
                if (v46 < v12)
                {
                  if (sub_1006B10C0((const void **)(v9 + 40 * v53), v47 + 5)) {
                    v47 += 5;
                  }
                  else {
                    uint64_t v46 = v53;
                  }
                }
                else
                {
                  uint64_t v46 = v53;
                }
                long long v48 = (const void **)v52;
              }
              while (!sub_1006B10C0(v47, (const void **)&v81));
              sub_1006A5E9C(v52, (uint64_t)&v81);
              if (v83) {
                sub_10004D2C8(v83);
              }
              __n128 result = (uint64_t)sub_1000FE824((const void **)&v81);
            }
          }
          int64_t v44 = v45 - 1;
        }
        while (v45);
        int64_t v54 = v11 / 0x28uLL;
        long long v55 = v74;
        do
        {
          if (v54 >= 2)
          {
            std::string::size_type v80 = 0;
            long long v78 = 0u;
            long long v79 = 0u;
            sub_100119B5C((const void **)&v78, (const void **)v9);
            uint64_t v56 = *(void *)(v9 + 8);
            LOBYTE(v79) = *(unsigned char *)(v9 + 16);
            *((void *)&v78 + 1) = v56;
            long long v57 = *(std::__shared_weak_count **)(v9 + 32);
            *((void *)&v79 + 1) = *(void *)(v9 + 24);
            std::string::size_type v80 = v57;
            if (v57) {
              atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v58 = 0;
            uint64_t v59 = v9;
            do
            {
              uint64_t v60 = v59 + 40 * v58 + 40;
              uint64_t v61 = (2 * v58) | 1;
              uint64_t v62 = 2 * v58 + 2;
              if (v62 < v54
                && sub_1006B10C0((const void **)(v59 + 40 * v58 + 40), (const void **)(v59 + 40 * v58 + 80)))
              {
                v60 += 40;
                uint64_t v61 = v62;
              }
              sub_1006A5E9C(v59, v60);
              uint64_t v59 = v60;
              uint64_t v58 = v61;
            }
            while (v61 <= (uint64_t)((unint64_t)(v54 - 2) >> 1));
            if ((const void **)v60 == v55 - 5)
            {
              sub_1006A5E9C(v60, (uint64_t)&v78);
            }
            else
            {
              sub_1006A5E9C(v60, (uint64_t)(v55 - 5));
              sub_1006A5E9C((uint64_t)(v55 - 5), (uint64_t)&v78);
              uint64_t v63 = v60 - v9 + 40;
              if (v63 >= 41)
              {
                unint64_t v64 = (v63 / 0x28uLL - 2) >> 1;
                xpc_object_t v65 = (const void **)(v9 + 40 * v64);
                if (sub_1006B10C0(v65, (const void **)v60))
                {
                  uint64_t v83 = 0;
                  long long v81 = 0u;
                  long long v82 = 0u;
                  sub_100119B5C((const void **)&v81, (const void **)v60);
                  uint64_t v66 = *(void *)(v60 + 8);
                  LOBYTE(v82) = *(unsigned char *)(v60 + 16);
                  *((void *)&v81 + 1) = v66;
                  *((void *)&v82 + 1) = *(void *)(v60 + 24);
                  uint64_t v67 = *(std::__shared_weak_count **)(v60 + 32);
                  uint64_t v83 = v67;
                  if (v67) {
                    atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  do
                  {
                    uint64_t v68 = (uint64_t)v65;
                    sub_1006A5E9C(v60, (uint64_t)v65);
                    if (!v64) {
                      break;
                    }
                    unint64_t v64 = (v64 - 1) >> 1;
                    xpc_object_t v65 = (const void **)(v9 + 40 * v64);
                    uint64_t v60 = v68;
                  }
                  while ((sub_1006B10C0(v65, (const void **)&v81) & 1) != 0);
                  sub_1006A5E9C(v68, (uint64_t)&v81);
                  if (v83) {
                    sub_10004D2C8(v83);
                  }
                  sub_1000FE824((const void **)&v81);
                }
              }
            }
            if (v80) {
              sub_10004D2C8(v80);
            }
            __n128 result = (uint64_t)sub_1000FE824((const void **)&v78);
          }
          v55 -= 5;
        }
        while ((unint64_t)v54-- > 2);
      }
      return result;
    }
    long long v13 = a2;
    uint64_t v14 = (const void **)(v9 + 40 * ((unint64_t)v12 >> 1));
    if ((unint64_t)v11 < 0x1401)
    {
      sub_1006B0DBC(v14, (const void **)v9, a2 - 5);
    }
    else
    {
      sub_1006B0DBC((const void **)v9, v14, a2 - 5);
      unint64_t v15 = v9 + 40 * ((unint64_t)v12 >> 1);
      sub_1006B0DBC(v76, (const void **)(v15 - 40), v13 - 10);
      sub_1006B0DBC(v75, (const void **)(v15 + 40), v13 - 15);
      sub_1006B0DBC((const void **)(v15 - 40), v14, (const void **)(v15 + 40));
      uint64_t v83 = 0;
      long long v81 = 0u;
      long long v82 = 0u;
      sub_100119B5C((const void **)&v81, (const void **)v9);
      uint64_t v16 = *v10;
      LOBYTE(v82) = *((unsigned char *)v10 + 8);
      *((void *)&v81 + 1) = v16;
      uint64_t v17 = *(std::__shared_weak_count **)(v9 + 32);
      *((void *)&v82 + 1) = *(void *)(v9 + 24);
      uint64_t v83 = v17;
      a2 = v13;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1006A5E9C(v9, (uint64_t)v14);
      sub_1006A5E9C((uint64_t)v14, (uint64_t)&v81);
      if (v83) {
        sub_10004D2C8(v83);
      }
      sub_1000FE824((const void **)&v81);
    }
    --a3;
    if ((a4 & 1) == 0 && (sub_1006B10C0(v73, (const void **)v9) & 1) == 0)
    {
      uint64_t v83 = 0;
      long long v81 = 0u;
      long long v82 = 0u;
      sub_100119B5C((const void **)&v81, (const void **)v9);
      uint64_t v29 = *(void *)(v9 + 8);
      LOBYTE(v82) = *(unsigned char *)(v9 + 16);
      *((void *)&v81 + 1) = v29;
      int64_t v30 = *(std::__shared_weak_count **)(v9 + 32);
      *((void *)&v82 + 1) = *(void *)(v9 + 24);
      uint64_t v83 = v30;
      if (v30) {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (sub_1006B10C0((const void **)&v81, v13 - 5))
      {
        unsigned int v8 = (const void **)v9;
        do
          v8 += 5;
        while ((sub_1006B10C0((const void **)&v81, v8) & 1) == 0);
      }
      else
      {
        int v31 = (const void **)(v9 + 40);
        do
        {
          unsigned int v8 = v31;
          if (v31 >= a2) {
            break;
          }
          int v32 = sub_1006B10C0((const void **)&v81, v31);
          int v31 = v8 + 5;
        }
        while (!v32);
      }
      uint64_t v33 = a2;
      if (v8 < a2)
      {
        uint64_t v33 = a2;
        do
          v33 -= 5;
        while ((sub_1006B10C0((const void **)&v81, v33) & 1) != 0);
      }
      while (v8 < v33)
      {
        sub_1006B0D24((uint64_t)v8, (uint64_t)v33);
        do
          v8 += 5;
        while (!sub_1006B10C0((const void **)&v81, v8));
        do
          v33 -= 5;
        while ((sub_1006B10C0((const void **)&v81, v33) & 1) != 0);
      }
      if (v8 - 5 != (const void **)v9) {
        sub_1006A5E9C(v9, (uint64_t)(v8 - 5));
      }
      sub_1006A5E9C((uint64_t)(v8 - 5), (uint64_t)&v81);
      if (v83) {
        sub_10004D2C8(v83);
      }
      __n128 result = (uint64_t)sub_1000FE824((const void **)&v81);
      a4 = 0;
      goto LABEL_2;
    }
    uint64_t v18 = a2;
    uint64_t v83 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    sub_100119B5C((const void **)&v81, (const void **)v9);
    BOOL v19 = *v10;
    LOBYTE(v82) = *((unsigned char *)v10 + 8);
    *((void *)&v81 + 1) = v19;
    long long v20 = *(std::__shared_weak_count **)(v9 + 32);
    *((void *)&v82 + 1) = *(void *)(v9 + 24);
    uint64_t v83 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = 0;
    do
    {
      char v22 = sub_1006B10C0((const void **)(v9 + v21 + 40), (const void **)&v81);
      v21 += 40;
    }
    while ((v22 & 1) != 0);
    size_t v23 = (const void **)(v9 + v21);
    uint32_t v24 = v18;
    BOOL v5 = v21 == 40;
    a2 = v18;
    if (v5)
    {
      uint32_t v24 = v18;
      do
      {
        if (v23 >= v24) {
          break;
        }
        v24 -= 5;
      }
      while ((sub_1006B10C0(v24, (const void **)&v81) & 1) == 0);
    }
    else
    {
      do
        v24 -= 5;
      while (!sub_1006B10C0(v24, (const void **)&v81));
    }
    if (v23 >= v24)
    {
      int v27 = v23 - 5;
    }
    else
    {
      uint64_t v25 = v23;
      uint64_t v26 = v24;
      do
      {
        sub_1006B0D24((uint64_t)v25, (uint64_t)v26);
        do
          v25 += 5;
        while ((sub_1006B10C0(v25, (const void **)&v81) & 1) != 0);
        do
          v26 -= 5;
        while (!sub_1006B10C0(v26, (const void **)&v81));
      }
      while (v25 < v26);
      int v27 = v25 - 5;
    }
    if (v27 != (const void **)v9) {
      sub_1006A5E9C(v9, (uint64_t)v27);
    }
    sub_1006A5E9C((uint64_t)v27, (uint64_t)&v81);
    if (v83) {
      sub_10004D2C8(v83);
    }
    sub_1000FE824((const void **)&v81);
    if (v23 < v24) {
      goto LABEL_43;
    }
    BOOL v28 = sub_1006B0E88((const void **)v9, v27);
    unsigned int v8 = v27 + 5;
    __n128 result = sub_1006B0E88(v27 + 5, v18);
    if (!result)
    {
      if (v28) {
        goto LABEL_2;
      }
LABEL_43:
      __n128 result = sub_1006B0230(v9, v27, a3, a4 & 1);
      a4 = 0;
      unsigned int v8 = v27 + 5;
      goto LABEL_2;
    }
    a2 = v27;
    if (v28) {
      return result;
    }
  }
  if (a4)
  {
    if ((const void **)v9 != a2)
    {
      unsigned __int8 v35 = (const void **)(v9 + 40);
      if ((const void **)(v9 + 40) != a2)
      {
        uint64_t v36 = 0;
        uint64_t v37 = v9;
        do
        {
          std::string v38 = v35;
          __n128 result = sub_1006B10C0(v35, (const void **)v37);
          if (result)
          {
            uint64_t v83 = 0;
            long long v81 = 0u;
            long long v82 = 0u;
            sub_100119B5C((const void **)&v81, v38);
            *((void *)&v81 + 1) = *(void *)(v37 + 48);
            LOBYTE(v82) = *(unsigned char *)(v37 + 56);
            BOOL v39 = *(std::__shared_weak_count **)(v37 + 72);
            *((void *)&v82 + 1) = *(void *)(v37 + 64);
            uint64_t v83 = v39;
            if (v39) {
              atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v40 = v36;
            while (1)
            {
              sub_1006A5E9C(v9 + v40 + 40, v9 + v40);
              if (!v40) {
                break;
              }
              char v41 = sub_1006B10C0((const void **)&v81, (const void **)(v9 + v40 - 40));
              v40 -= 40;
              if ((v41 & 1) == 0)
              {
                uint64_t v42 = v9 + v40 + 40;
                goto LABEL_84;
              }
            }
            uint64_t v42 = v9;
LABEL_84:
            sub_1006A5E9C(v42, (uint64_t)&v81);
            if (v83) {
              sub_10004D2C8(v83);
            }
            __n128 result = (uint64_t)sub_1000FE824((const void **)&v81);
          }
          unsigned __int8 v35 = v38 + 5;
          v36 += 40;
          uint64_t v37 = (uint64_t)v38;
        }
        while (v38 + 5 != a2);
      }
    }
  }
  else if ((const void **)v9 != a2)
  {
    long long v70 = (const void **)(v9 + 40);
    if ((const void **)(v9 + 40) != a2)
    {
      do
      {
        uint64_t v71 = v70;
        __n128 result = sub_1006B10C0(v70, (const void **)v9);
        if (result)
        {
          uint64_t v83 = 0;
          long long v81 = 0u;
          long long v82 = 0u;
          sub_100119B5C((const void **)&v81, v71);
          *((void *)&v81 + 1) = *(void *)(v9 + 48);
          LOBYTE(v82) = *(unsigned char *)(v9 + 56);
          long long v72 = *(std::__shared_weak_count **)(v9 + 72);
          *((void *)&v82 + 1) = *(void *)(v9 + 64);
          uint64_t v83 = v72;
          if (v72) {
            atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          do
          {
            sub_1006A5E9C(v9 + 40, v9);
            v9 -= 40;
          }
          while ((sub_1006B10C0((const void **)&v81, (const void **)v9) & 1) != 0);
          sub_1006A5E9C(v9 + 40, (uint64_t)&v81);
          if (v83) {
            sub_10004D2C8(v83);
          }
          __n128 result = (uint64_t)sub_1000FE824((const void **)&v81);
        }
        long long v70 = v71 + 5;
        uint64_t v9 = (uint64_t)v71;
      }
      while (v71 + 5 != a2);
    }
  }
  return result;
}

void sub_1006B0C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1006A5EFC((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_1006B0D24(uint64_t a1, uint64_t a2)
{
  unsigned int v8 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  sub_100119B5C((const void **)&v6, (const void **)a1);
  *((void *)&v6 + 1) = *(void *)(a1 + 8);
  LOBYTE(v7) = *(unsigned char *)(a1 + 16);
  char v4 = *(std::__shared_weak_count **)(a1 + 32);
  *((void *)&v7 + 1) = *(void *)(a1 + 24);
  unsigned int v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1006A5E9C(a1, a2);
  sub_1006A5E9C(a2, (uint64_t)&v6);
  if (v8) {
    sub_10004D2C8(v8);
  }
  return sub_1000FE824((const void **)&v6);
}

const void **sub_1006B0DBC(const void **a1, const void **a2, const void **a3)
{
  char v6 = sub_1006B10C0(a2, a1);
  __n128 result = (const void **)sub_1006B10C0(a3, a2);
  if (v6)
  {
    if (result)
    {
      uint64_t v8 = (uint64_t)a1;
    }
    else
    {
      sub_1006B0D24((uint64_t)a1, (uint64_t)a2);
      __n128 result = (const void **)sub_1006B10C0(a3, a2);
      if (!result) {
        return result;
      }
      uint64_t v8 = (uint64_t)a2;
    }
    uint64_t v9 = (uint64_t)a3;
  }
  else
  {
    if (!result) {
      return result;
    }
    sub_1006B0D24((uint64_t)a2, (uint64_t)a3);
    __n128 result = (const void **)sub_1006B10C0(a2, a1);
    if (!result) {
      return result;
    }
    uint64_t v8 = (uint64_t)a1;
    uint64_t v9 = (uint64_t)a2;
  }

  return sub_1006B0D24(v8, v9);
}

BOOL sub_1006B0E88(const void **a1, const void **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = (uint64_t)(a2 - 5);
      if (sub_1006B10C0(a2 - 5, a1)) {
        sub_1006B0D24((uint64_t)a1, v6);
      }
      return 1;
    case 3uLL:
      sub_1006B0DBC(a1, a1 + 5, a2 - 5);
      return 1;
    case 4uLL:
      sub_1006B14B4(a1, a1 + 5, a1 + 10, a2 - 5);
      return 1;
    case 5uLL:
      sub_1006B155C(a1, a1 + 5, a1 + 10, a1 + 15, a2 - 5);
      return 1;
    default:
      long long v7 = a1 + 10;
      sub_1006B0DBC(a1, a1 + 5, a1 + 10);
      uint64_t v8 = a1 + 15;
      if (a1 + 15 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    if (sub_1006B10C0(v8, v7))
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      sub_100119B5C((const void **)&v15, v8);
      *((void *)&v15 + 1) = v8[1];
      LOBYTE(v16) = *((unsigned char *)v8 + 16);
      uint64_t v11 = (std::__shared_weak_count *)v8[4];
      *((void *)&v16 + 1) = v8[3];
      uint64_t v17 = v11;
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v12 = v9;
      while (1)
      {
        sub_1006A5E9C((uint64_t)a1 + v12 + 120, (uint64_t)a1 + v12 + 80);
        if (v12 == -80) {
          break;
        }
        char v13 = sub_1006B10C0((const void **)&v15, (const void **)((char *)a1 + v12 + 40));
        v12 -= 40;
        if ((v13 & 1) == 0)
        {
          uint64_t v14 = (uint64_t)a1 + v12 + 120;
          goto LABEL_14;
        }
      }
      uint64_t v14 = (uint64_t)a1;
LABEL_14:
      sub_1006A5E9C(v14, (uint64_t)&v15);
      if (v17) {
        sub_10004D2C8(v17);
      }
      ++v10;
      sub_1000FE824((const void **)&v15);
      if (v10 == 8) {
        return v8 + 5 == a2;
      }
    }
    long long v7 = v8;
    v9 += 40;
    v8 += 5;
    if (v8 == a2) {
      return 1;
    }
  }
}

void sub_1006B1094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1006B10C0(const void **a1, const void **a2)
{
  double v2 = *((double *)a1 + 1);
  double v3 = *((double *)a2 + 1);
  if (v2 >= v3)
  {
    if (v2 > v3) {
      return 0;
    }
    int v27 = 0;
    BOOL v28 = 0;
    long long v7 = a1[3];
    if (v7)
    {
      uint64_t v8 = (__CFString *)(*(uint64_t (**)(const void *, const void *))(*(void *)v7 + 48))(v7, *a1);
      uint64_t v9 = v28;
      BOOL v28 = v8;
      __p[0] = v9;
      sub_1000558F4((const void **)__p);
      int v10 = (__CFString *)(*(uint64_t (**)(const void *, const void *))(*(void *)a1[3] + 48))(a1[3], *a2);
      uint64_t v11 = v27;
      int v27 = v10;
      __p[0] = v11;
      sub_1000558F4((const void **)__p);
    }
    else
    {
      sub_1006B141C();
      uint64_t v12 = qword_101B0D308;
      if (os_log_type_enabled((os_log_t)qword_101B0D308, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "No BundleUtilities", (uint8_t *)__p, 2u);
      }
    }
    if (v28) {
      char v13 = sub_1000810B8;
    }
    else {
      char v13 = 0;
    }
    if (v13)
    {
      if (v27) {
        uint64_t v14 = sub_1000810B8;
      }
      else {
        uint64_t v14 = 0;
      }
      if (v14)
      {
        uint64_t v15 = _CompareBundleVersionStrings(v28, v27);
        if (v15 == -1)
        {
          uint64_t v4 = 1;
          goto LABEL_42;
        }
        if (!v15)
        {
          if (*((unsigned char *)a1 + 16)) {
            BOOL v16 = *((unsigned char *)a2 + 16) == 0;
          }
          else {
            BOOL v16 = 0;
          }
          uint64_t v4 = v16;
          goto LABEL_42;
        }
        goto LABEL_40;
      }
      sub_1006B141C();
      long long v20 = qword_101B0D308;
      uint64_t v4 = 0;
      if (os_log_type_enabled((os_log_t)qword_101B0D308, OS_LOG_TYPE_DEFAULT))
      {
        sub_100119B5C((const void **)&v23, a2);
        asString(v23, (uint64_t)__p);
        if (v26 >= 0) {
          uint64_t v21 = __p;
        }
        else {
          uint64_t v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        int64_t v30 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No version in the other bundle %{public}s", buf, 0xCu);
        if (v26 < 0) {
          operator delete(__p[0]);
        }
        BOOL v19 = &v23;
LABEL_39:
        sub_1000FE824((const void **)v19);
LABEL_40:
        uint64_t v4 = 0;
      }
    }
    else
    {
      sub_1006B141C();
      uint64_t v17 = qword_101B0D308;
      uint64_t v4 = 0;
      if (os_log_type_enabled((os_log_t)qword_101B0D308, OS_LOG_TYPE_DEFAULT))
      {
        sub_100119B5C((const void **)&v24, a1);
        asString(v24, (uint64_t)__p);
        if (v26 >= 0) {
          uint64_t v18 = __p;
        }
        else {
          uint64_t v18 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        int64_t v30 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I No version in the bundle %{public}s", buf, 0xCu);
        if (v26 < 0) {
          operator delete(__p[0]);
        }
        BOOL v19 = &v24;
        goto LABEL_39;
      }
    }
LABEL_42:
    sub_1000558F4((const void **)&v27);
    sub_1000558F4((const void **)&v28);
    return v4;
  }
  return 1;
}

void sub_1006B13D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16)
{
}

void sub_1006B141C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D310, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D310))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D308, kCtLoggingSystemName, "cb.match.util");
    __cxa_guard_release(&qword_101B0D310);
  }
}

void sub_1006B149C(_Unwind_Exception *a1)
{
}

const void **sub_1006B14B4(const void **a1, const void **a2, const void **a3, const void **a4)
{
  sub_1006B0DBC(a1, a2, a3);
  BOOL result = (const void **)sub_1006B10C0(a4, a3);
  if (result)
  {
    sub_1006B0D24((uint64_t)a3, (uint64_t)a4);
    BOOL result = (const void **)sub_1006B10C0(a3, a2);
    if (result)
    {
      sub_1006B0D24((uint64_t)a2, (uint64_t)a3);
      BOOL result = (const void **)sub_1006B10C0(a2, a1);
      if (result)
      {
        return sub_1006B0D24((uint64_t)a1, (uint64_t)a2);
      }
    }
  }
  return result;
}

const void **sub_1006B155C(const void **a1, const void **a2, const void **a3, const void **a4, const void **a5)
{
  sub_1006B14B4(a1, a2, a3, a4);
  BOOL result = (const void **)sub_1006B10C0(a5, a4);
  if (result)
  {
    sub_1006B0D24((uint64_t)a4, (uint64_t)a5);
    BOOL result = (const void **)sub_1006B10C0(a4, a3);
    if (result)
    {
      sub_1006B0D24((uint64_t)a3, (uint64_t)a4);
      BOOL result = (const void **)sub_1006B10C0(a3, a2);
      if (result)
      {
        sub_1006B0D24((uint64_t)a2, (uint64_t)a3);
        BOOL result = (const void **)sub_1006B10C0(a2, a1);
        if (result)
        {
          return sub_1006B0D24((uint64_t)a1, (uint64_t)a2);
        }
      }
    }
  }
  return result;
}

void sub_1006B1630(void ***a1)
{
  uint64_t v1 = *a1;
  double v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    BOOL v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 40;
        sub_1006A5EFC(v4);
      }
      while ((void *)v4 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1006B16B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006B1734(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006B1770(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006B17A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1006B17D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1006B1820()
{
}

uint64_t sub_1006B1834(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8;
}

void sub_1006B1840(void *a1)
{
  if (a1)
  {
    sub_1006B1840(*a1);
    sub_1006B1840(a1[1]);
    sub_1006B012C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1006B1898()
{
}

void *sub_1006B18AC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F8EA0;
  result[1] = v3;
  return result;
}

uint64_t sub_1006B18F4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F8EA0;
  a2[1] = v2;
  return result;
}

void sub_1006B1920(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1006B1928(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006B1968()
{
}

void sub_1006B1974(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1006B1974(a1, *a2);
    sub_1006B1974(a1, a2[1]);
    sub_1006B19D0((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1006B19D0(uint64_t a1)
{
  sub_1007DE5C8(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_1006B1A20(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v12 = 0;
  BOOL v5 = sub_100046ED4(a1, &v12, a2);
  if (!*v5)
  {
    uint64_t v6 = v5;
    uint64_t v11 = 0;
    long long v7 = operator new(0xF0uLL);
    v10[0] = v7;
    v10[1] = a1 + 8;
    v7[2] = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    sub_1007DE310((uint64_t)v7 + 56, a3 + 24);
    LOBYTE(v11) = 1;
    uint64_t v8 = v12;
    *(void *)long long v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v8;
    *uint64_t v6 = v7;
    uint64_t v9 = **(void **)a1;
    if (v9)
    {
      *(void *)a1 = v9;
      long long v7 = (_OWORD *)*v6;
    }
    sub_100046C90(*(uint64_t **)(a1 + 8), (uint64_t *)v7);
    ++*(void *)(a1 + 16);
    v10[0] = 0;
    sub_1006B1B30((uint64_t)v10);
  }
}

void sub_1006B1B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(char *)(v9 + 55) < 0) {
    operator delete(*v10);
  }
  sub_1006B1B30((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1006B1B30(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1006B19D0((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t sub_1006B1B88(void *a1, uint64_t a2)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  uint64_t v4 = sub_10004B96C(v16, (uint64_t)"Matchs: ", 8);
  sub_1006A5C38(v14, a2 + 40);
  if ((v15 & 0x80u) == 0) {
    BOOL v5 = v14;
  }
  else {
    BOOL v5 = (void **)v14[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)v14[1];
  }
  long long v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  uint64_t v8 = sub_10004B96C(v7, (uint64_t)", ", 2);
  sub_1006A5C38(__p, a2);
  if ((v13 & 0x80u) == 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  if ((v13 & 0x80u) == 0) {
    uint64_t v10 = v13;
  }
  else {
    uint64_t v10 = (uint64_t)__p[1];
  }
  sub_10004B96C(v8, (uint64_t)v9, v10);
  if ((char)v13 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v15 < 0) {
    operator delete(v14[0]);
  }
  sub_10004BC98((uint64_t)v16 + 8, a1);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1006B1D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_1000C937C((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void *sub_1006B1DDC(void *a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeRef v3 = cf;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFURLGetTypeID()) {
      CFTypeRef cf = v3;
    }
    else {
      CFTypeRef cf = 0;
    }
  }

  return sub_1006B01F8(a1, cf);
}

uint64_t sub_1006B1E38(uint64_t a1, Registry **a2, const void **a3, const void **a4, double a5, double a6)
{
  sub_100119B5C(&v13, a3);
  sub_1006B1F0C(a1, a2, &v13, 0, a5);
  sub_1000FE824(&v13);
  sub_100119B5C(&v12, a4);
  sub_1006B1F0C(a1 + 40, a2, &v12, 1, a6);
  sub_1000FE824(&v12);
  return a1;
}

void sub_1006B1EE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000FE824(&a9);
  sub_1006A5EFC(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B1F0C(uint64_t a1, Registry **a2, const void **a3, char a4, double a5)
{
  uint64_t v9 = sub_100119B5C((const void **)a1, a3);
  *((double *)v9 + 1) = a5;
  *((unsigned char *)v9 + 16) = a4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned __int8 v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, &v20);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v11);
  *(void *)(a1 + 24) = v18;
  *(void *)(a1 + 32) = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
  }
  return a1;
}

void sub_1006B2000(_Unwind_Exception *a1)
{
  sub_1000FE824(v1);
  _Unwind_Resume(a1);
}

void sub_1006B2014(void *a1)
{
  if (a1)
  {
    sub_1006B2014(*a1);
    sub_1006B2014(a1[1]);
    sub_1006B2068((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1006B2068(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 24);
  CFTypeRef v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000FE824(v2);
  if (*(char *)(a1 + 23) < 0)
  {
    CFTypeID v4 = *(void **)a1;
    operator delete(v4);
  }
}

void sub_1006B20CC()
{
}

__n128 sub_1006B20E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019F8F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1006B2134(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F8F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1006B216C(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2) {
    uint64_t v2 = sub_1000FCC20;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2) {
    return;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (**(unsigned char **)(a1 + 16)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = *(unsigned char *)(a2 + 16) == 0;
  }
  if (v6)
  {
    v42[0] = 0;
    v42[1] = 0;
    uint64_t v43 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 64));
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v9;
    unsigned __int8 v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
LABEL_23:
    sub_100119B5C((const void **)&v41, (const void **)a2);
    asString(v41, (uint64_t)buf);
    if (v52 >= 0) {
      unint64_t v20 = buf;
    }
    else {
      unint64_t v20 = *(unsigned char **)buf;
    }
    *(void *)long long v48 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v15 + 24))(v15, v20);
    *(void *)std::string __p = *(void *)v48;
    sub_1000292E0((uint64_t)v42);
    sub_1000558F4((const void **)v48);
    if (v52 < 0) {
      operator delete(*(void **)buf);
    }
    sub_1000FE824((const void **)&v41);
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    uint64_t v21 = *(void *)(a1 + 8);
    long long v24 = *(void **)(v21 + 8);
    long long v22 = (uint64_t **)(v21 + 8);
    long long v23 = v24;
    if (!v24) {
      goto LABEL_40;
    }
    long long v25 = v22;
    do
    {
      char v26 = sub_100046FE8(v23 + 4, v42);
      if (v26 >= 0) {
        long long v27 = v23;
      }
      else {
        long long v27 = v23 + 1;
      }
      if (v26 >= 0) {
        long long v25 = (uint64_t **)v23;
      }
      long long v23 = (void *)*v27;
    }
    while (*v27);
    if (v25 == v22 || (sub_100046FE8(v42, (void **)v25 + 4) & 0x80) != 0) {
LABEL_40:
    }
      long long v25 = v22;
    long long v28 = *(uint64_t ***)(a1 + 8);
    if (v28 + 1 == v25)
    {
      uint64_t v36 = *(NSObject **)(v5 + 8);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        int v37 = SHIBYTE(v43);
        std::string v38 = (void **)v42[0];
        sub_1006A5C38(buf, a2);
        BOOL v39 = v42;
        if (v37 < 0) {
          BOOL v39 = v38;
        }
        if (v52 >= 0) {
          uint64_t v40 = buf;
        }
        else {
          uint64_t v40 = *(unsigned char **)buf;
        }
        *(_DWORD *)std::string __p = 136446466;
        *(void *)&__p[4] = v39;
        __int16 v45 = 2080;
        uint64_t v46 = v40;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Adding %{public}s to the bundle matches map from %s", __p, 0x16u);
        if (v52 < 0) {
          operator delete(*(void **)buf);
        }
        long long v28 = *(uint64_t ***)(a1 + 8);
      }
      *(void *)std::string buf = v42;
      unsigned __int8 v35 = sub_1006B26B0(v28, v42, (long long **)buf);
    }
    else
    {
      if (!sub_1006B10C0((const void **)v25 + 7, (const void **)a2)) {
        goto LABEL_65;
      }
      uint64_t v29 = *(NSObject **)(v5 + 8);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        sub_1006A5C38(buf, (uint64_t)(v25 + 7));
        int v30 = v52;
        int v31 = *(unsigned char **)buf;
        sub_1006A5C38(__p, a2);
        int v32 = buf;
        if (v30 < 0) {
          int v32 = v31;
        }
        if (v47 >= 0) {
          uint64_t v33 = __p;
        }
        else {
          uint64_t v33 = *(unsigned char **)__p;
        }
        *(_DWORD *)long long v48 = 136446466;
        *(void *)&v48[4] = v32;
        __int16 v49 = 2082;
        uint64_t v50 = v33;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Replacing the candidate %{public}s with %{public}s", v48, 0x16u);
        if (v47 < 0) {
          operator delete(*(void **)__p);
        }
        if (v52 < 0) {
          operator delete(*(void **)buf);
        }
      }
      std::string::size_type v34 = *(uint64_t ***)(a1 + 8);
      *(void *)std::string buf = v42;
      unsigned __int8 v35 = sub_1006B26B0(v34, v42, (long long **)buf);
    }
    sub_1006A5E9C((uint64_t)(v35 + 56), a2);
LABEL_65:
    if (SHIBYTE(v43) < 0) {
      operator delete(v42[0]);
    }
    return;
  }
  uint64_t v17 = *(NSObject **)(v5 + 8);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006A5C38(v42, a2);
    if (v43 >= 0) {
      long long v19 = v42;
    }
    else {
      long long v19 = (void **)v42[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Removing %s from bundle match as it is with cookie", buf, 0xCu);
    goto LABEL_65;
  }
}

void sub_1006B25CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006B2664(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006B26A4()
{
}

char *sub_1006B26B0(uint64_t **a1, void **a2, long long **a3)
{
  BOOL v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  long long v7 = (char **)(a1 + 1);
  uint64_t v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  long long v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (char **)v5;
      uint64_t v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      long long v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    long long v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    unsigned int v12 = *a3;
    uint64_t v19 = 0;
    unsigned __int8 v13 = (char *)operator new(0x60uLL);
    v18[0] = v13;
    v18[1] = v6;
    uint64_t v14 = v13 + 32;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
    }
    *((void *)v13 + 10) = 0;
    *((void *)v13 + 11) = 0;
    *((void *)v13 + 7) = 0;
    *((void *)v13 + 8) = 0;
    v13[72] = 0;
    LOBYTE(v19) = 1;
    *(void *)unsigned __int8 v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v8;
    void *v7 = v13;
    char v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      unsigned __int8 v13 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (char *)v18[0];
    v18[0] = 0;
    sub_1006B2824((uint64_t)v18);
  }
  return v11;
}

void sub_1006B2810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006B2824((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1006B2824(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1006B2068((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void *sub_1006B287C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1006B2900(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 223) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 200), *(void *)(a1 + 208));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 200);
      *(void *)&long long v34 = *(void *)(a1 + 216);
    }
    uint64_t v5 = __p;
    if (SBYTE7(v34) < 0) {
      uint64_t v5 = (void **)__p[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Loading carrier file %s", (uint8_t *)&buf, 0xCu);
    if (SBYTE7(v34) < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(void *)(a1 + 56)) {
    BOOL v6 = sub_100080778;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    long long v34 = 0u;
    long long v35 = 0u;
    *(_OWORD *)std::string __p = 0u;
    sub_100058198(&v32, (const void **)(a1 + 48));
    sub_100058198(&v31, (const void **)(a1 + 56));
    sub_100DBFA80(__p, a1, a1 + 8, v7, v8, a1 + 64);
    sub_100057D78(&v31);
    sub_100057D78(&v32);
    sub_100DBFAF4((capabilities::ct *)__p, (uint64_t)&buf);
    uint64_t v9 = (void **)(a1 + 432);
    if (*(char *)(a1 + 455) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(void *)(a1 + 448) = *((void *)&buf.__r_.__value_.__l + 2);
    char v10 = *(unsigned char *)(a1 + 455);
    if (v10 < 0) {
      uint64_t v11 = *(void *)(a1 + 440);
    }
    else {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 455);
    }
    uint64_t v14 = *(NSObject **)a1;
    BOOL v15 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
    if (!v11)
    {
      if (v15)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No overlay matching key, marking override not required", (uint8_t *)&buf, 2u);
      }
      uint64_t v13 = 0;
      goto LABEL_68;
    }
    if (v15)
    {
      if (v10 < 0) {
        uint64_t v9 = (void **)*v9;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Overlay key: '%s'", (uint8_t *)&buf, 0xCu);
    }
    int v30 = 0;
    sub_100DBFBAC((uint64_t)__p, (const void **)&v30);
    if (v30) {
      char v16 = sub_100080778;
    }
    else {
      char v16 = 0;
    }
    if (!v16)
    {
      uint64_t v21 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v13 = 2;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I No match for overlay", (uint8_t *)&buf, 2u);
      }
      else
      {
        uint64_t v13 = 2;
      }
      goto LABEL_67;
    }
    sub_100DBC65C(a1, (uint64_t)&v28);
    if (v29 < 0) {
      operator delete(v28);
    }
    CFTypeRef cf = 0;
    copyMergedDictionaries(*(const __CFDictionary **)(a1 + 56), v30, &cf);
    CFTypeRef cf2 = cf;
    if (cf) {
      CFRetain(cf);
    }
    if ((sub_100DBD048(a1) & 1) == 0)
    {
      uint64_t v17 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Comparing the already present plist with the overlay dict because we are using new signatures", (uint8_t *)&buf, 2u);
      }
      CFTypeRef cf1 = 0;
      uint64_t v18 = *(void *)(a1 + 24);
      sub_100DBCF70(a1, &buf);
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, std::string *))(*(void *)v18 + 152))(&cf1, v18, &buf);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (cf1) {
        uint64_t v19 = sub_100080778;
      }
      else {
        uint64_t v19 = 0;
      }
      if (v19)
      {
        int v20 = CFEqual(cf1, cf2);
        sub_100057D78(&cf1);
        if (v20) {
          goto LABEL_63;
        }
      }
      else
      {
        sub_100057D78(&cf1);
      }
    }
    if (!sub_100DBD1C4(a1, (uint64_t)cf2))
    {
      long long v22 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to generate overridden carrier plist", (uint8_t *)&buf, 2u);
      }
      uint64_t v13 = 4;
      goto LABEL_66;
    }
    if (*(char *)(a1 + 127) < 0) {
      sub_10004FC84(&buf, *(void **)(a1 + 104), *(void *)(a1 + 112));
    }
    else {
      std::string buf = *(std::string *)(a1 + 104);
    }
    sub_1007DE874(a1 + 64, &buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    long long v23 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Successfully generated the carrier plist", (uint8_t *)&buf, 2u);
    }
LABEL_63:
    *(_DWORD *)(a1 + 224) |= *(_DWORD *)(a1 + 40);
    sub_100DBCF70(a1, &buf);
    std::string::operator=((std::string *)(a1 + 200), &buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v13 = 3;
LABEL_66:
    sub_100057D78(&cf2);
    sub_100057D78(&cf);
LABEL_67:
    sub_100057D78((const void **)&v30);
LABEL_68:
    sub_10025B9C0((uint64_t)__p);
    goto LABEL_69;
  }
  unsigned int v12 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to load the base bundle carrier file itself, carrier info not present", (uint8_t *)__p, 2u);
  }
  uint64_t v13 = 1;
LABEL_69:
  sub_1007DE538(a2, a1 + 64);
  return v13;
}

void sub_1006B2EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  CFTypeID v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  BOOL v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v11 = va_arg(va3, const void *);
  uint64_t v13 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  sub_100057D78((const void **)va2);
  sub_10025B9C0((uint64_t)va3);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B2F60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1006B2FF8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006B306C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006B3148((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1006B3084(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006B30BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100DBC5D0(result);
    operator delete();
  }
  return result;
}

uint64_t sub_1006B3104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006B3148(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_100DBC5D0(result);
    operator delete();
  }
  return result;
}

void sub_1006B319C()
{
}

__n128 sub_1006B31B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F9028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1006B31FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F9028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1006B322C(uint64_t a1, const void **a2, uint64_t a3, unsigned __int8 *a4)
{
  BOOL v6 = *a2;
  uint64_t v11 = v6;
  unsigned int v12 = v6;
  *a2 = 0;
  int v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  if (v6) {
    CFRetain(v6);
  }
  BOOL v9 = sub_1006A3488(v8, (const __CFDictionary **)&v12, *(unsigned __int8 *)(a1 + 16), a3, v7 != 0);
  sub_100057D78(&v12);
  sub_100057D78(&v11);
  return v9;
}

void sub_1006B32B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1006B32D0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B3310()
{
}

void *sub_1006B331C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1006B33A4()
{
}

__n128 sub_1006B33B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F90B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1006B3404(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F90B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1006B3434(uint64_t a1, const void **a2, uint64_t a3, unsigned __int8 *a4)
{
  BOOL v6 = *a2;
  uint64_t v11 = v6;
  unsigned int v12 = v6;
  *a2 = 0;
  int v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  if (v6) {
    CFRetain(v6);
  }
  BOOL v9 = sub_1006A335C(v8, (CFDictionaryRef)v6, *(unsigned __int8 *)(a1 + 16), a3, v7 != 0);
  sub_100057D78(&v12);
  sub_100057D78(&v11);
  return v9;
}

void sub_1006B34C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1006B34E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B3524()
{
}

void sub_1006B3534()
{
}

void *sub_1006B3548()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_1019F9138;
  return result;
}

void sub_1006B3580(uint64_t a1, void *a2)
{
  *a2 = off_1019F9138;
}

void sub_1006B35A8(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeID v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CarrierBundleScan", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1006B3620(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B3660()
{
}

void sub_1006B3670()
{
}

void *sub_1006B3684()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_1019F91B8;
  return result;
}

void sub_1006B36BC(uint64_t a1, void *a2)
{
  *a2 = off_1019F91B8;
}

void sub_1006B36E4(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeID v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CountryBundleScan", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1006B375C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B379C()
{
}

uint64_t sub_1006B37A8(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_100057D78((const void **)(a1 + 56));
  sub_100057D78((const void **)(a1 + 48));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  os_signpost_id_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void *sub_1006B3804(void *a1)
{
  *a1 = off_1019F9238;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006B3850(void *a1)
{
  *a1 = off_1019F9238;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006B38BC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019F9238;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006B3920(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019F9238;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006B3960(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006B3970(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006B39B0(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = *a2;
  uint64_t v5 = *(void **)a3;
  int v6 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  int v7 = (std::__shared_weak_count *)a1[3];
  if (v7)
  {
    uint64_t v8 = a1[1];
    BOOL v9 = std::__shared_weak_count::lock(v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if (a1[2])
      {
        uint64_t v11 = *(NSObject **)(v8 + 8);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v12 = "success";
          if (!v4) {
            unsigned int v12 = "failed";
          }
          int v13 = 136315138;
          uint64_t v14 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ABC report %s for Carrier Bundles and/or Country Bundles folder recreated", (uint8_t *)&v13, 0xCu);
        }
      }
      sub_10004D2C8(v10);
    }
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_1006B3ABC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B3AFC()
{
}

CFDictionaryRef *sub_1006B3B08(CFDictionaryRef *a1, os_log_t *a2, const __CFString *a3)
{
  *a1 = 0;
  if (a3)
  {
    int v4 = sub_1006B3B68(a2, a3);
    if (v4)
    {
      uint64_t v5 = v4;
      *a1 = CFDictionaryCreateCopy(kCFAllocatorDefault, v4);
      CFRelease(v5);
    }
  }
  return a1;
}

__CFDictionary *sub_1006B3B68(os_log_t *a1, const __CFString *a2)
{
  if (!a2) {
    return 0;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a2, @"_");
  CFArrayRef theArray = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings) {
    int v4 = sub_100083F10;
  }
  else {
    int v4 = 0;
  }
  if (v4 && CFArrayGetCount(ArrayBySeparatingStrings) >= 1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    int v7 = ValueAtIndex;
    if (ValueAtIndex)
    {
      CFTypeID v8 = CFGetTypeID(ValueAtIndex);
      if (v8 == CFStringGetTypeID()) {
        BOOL v9 = v7;
      }
      else {
        BOOL v9 = 0;
      }
    }
    else
    {
      BOOL v9 = 0;
    }
    CFDictionaryAddValue(Mutable, (const void *)qword_101B13EC0, v9);
    long long v25 = a1;
    uint64_t v11 = qword_101B13E98;
    uint64_t v12 = qword_101B13EA0;
    CFIndex v13 = 2;
    char v26 = (void *)qword_101B13EB8;
    CFIndex range = qword_101B13EA8;
    while (1)
    {
      if (v13 > CFArrayGetCount(theArray)) {
        goto LABEL_12;
      }
      CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v13 - 1);
      CFStringRef v15 = v14;
      if (v14)
      {
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFStringGetTypeID())
        {
          v30.length = CFStringGetLength(v15);
          v30.location = 0;
          if (CFStringFindWithOptions(v15, @"GID1-", v30, 9uLL, 0))
          {
            *(void *)std::string buf = 0;
            v31.length = CFStringGetLength(v15) - v11;
            v31.location = v11;
            CFStringRef v17 = CFStringCreateWithSubstring(kCFAllocatorDefault, v15, v31);
            *(void *)std::string buf = v17;
            if (v17) {
              uint64_t v18 = sub_1000810B8;
            }
            else {
              uint64_t v18 = 0;
            }
            if (v18) {
              CFDictionaryAddValue(Mutable, @"GID1", v17);
            }
LABEL_38:
            sub_1000558F4((const void **)buf);
            goto LABEL_39;
          }
          v32.length = CFStringGetLength(v15);
          v32.location = 0;
          if (CFStringFindWithOptions(v15, @"GID2-", v32, 9uLL, 0))
          {
            *(void *)std::string buf = 0;
            v33.length = CFStringGetLength(v15) - v12;
            v33.location = v12;
            CFStringRef v19 = CFStringCreateWithSubstring(kCFAllocatorDefault, v15, v33);
            *(void *)std::string buf = v19;
            if (v19) {
              int v20 = sub_1000810B8;
            }
            else {
              int v20 = 0;
            }
            if (v20) {
              CFDictionaryAddValue(Mutable, @"GID2", v19);
            }
            goto LABEL_38;
          }
          v34.length = CFStringGetLength(v15);
          v34.location = 0;
          if (CFStringFindWithOptions(v15, @"ID-", v34, 9uLL, 0))
          {
            *(void *)std::string buf = 0;
            CFIndex Length = CFStringGetLength(v15);
            v35.location = range;
            v35.length = Length - range;
            CFStringRef v22 = CFStringCreateWithSubstring(kCFAllocatorDefault, v15, v35);
            *(void *)std::string buf = v22;
            if (v22) {
              long long v23 = sub_1000810B8;
            }
            else {
              long long v23 = 0;
            }
            if (v23) {
              CFDictionaryAddValue(Mutable, v26, v22);
            }
            goto LABEL_38;
          }
          long long v24 = *v25;
          if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Unable to parse carrier bundle name", buf, 2u);
          }
        }
      }
LABEL_39:
      ++v13;
    }
  }
  CFMutableDictionaryRef Mutable = 0;
LABEL_12:
  sub_100044D00((const void **)&theArray);
  return Mutable;
}

void sub_1006B3ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  CFTypeID v8 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_100044D00((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_1006B3F14(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
    *a1 = 0;
  }
  return a1;
}

double sub_1006B3F4C(CFDictionaryRef *a1, CFDictionaryRef *a2)
{
  CFDictionaryRef v3 = *a1;
  double v4 = 0.0;
  if (!v3) {
    return v4;
  }
  int v6 = (const void *)qword_101B13EC0;
  if (!CFDictionaryContainsKey(v3, (const void *)qword_101B13EC0) || !CFDictionaryContainsKey(*a2, v6)) {
    return v4;
  }
  memset(&__str, 0, sizeof(__str));
  CFDictionaryGetValue(*a2, v6);
  memset(&__dst, 0, sizeof(__dst));
  ctu::cf::assign();
  memset(&__str, 0, sizeof(__str));
  CFDictionaryGetValue(*a1, v6);
  memset(&__dst, 0, sizeof(__dst));
  ctu::cf::assign();
  *(_OWORD *)__n = 0uLL;
  uint64_t v64 = 0;
  for (uint64_t i = &__str; i != &__str; uint64_t i = (std::string *)((char *)i + 1))
    i->__r_.__value_.__s.__data_[0] = __tolower(i->__r_.__value_.__s.__data_[0]);
  if (v64 >= 0) {
    CFTypeID v8 = (std::string::size_type *)((char *)__n + HIBYTE(v64));
  }
  else {
    CFTypeID v8 = (std::string::size_type *)(__n[0] + __n[1]);
  }
  if (v64 >= 0) {
    BOOL v9 = __n;
  }
  else {
    BOOL v9 = (std::string::size_type *)__n[0];
  }
  while (v9 != v8)
  {
    *(unsigned char *)BOOL v9 = __tolower(*(char *)v9);
    BOOL v9 = (std::string::size_type *)((char *)v9 + 1);
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  double v4 = 0.0;
  if (!size) {
    goto LABEL_41;
  }
  if ((SHIBYTE(v64) & 0x80000000) == 0)
  {
    std::string::size_type v11 = HIBYTE(v64);
    if (!HIBYTE(v64))
    {
      int v12 = 2;
      goto LABEL_44;
    }
LABEL_22:
    std::string::basic_string(&__dst, &__str, 0, v11, (std::allocator<char> *)&v62);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v13 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v13 = __dst.__r_.__value_.__l.__size_;
    }
    std::string::size_type v14 = HIBYTE(v64);
    if (v64 < 0) {
      std::string::size_type v14 = __n[1];
    }
    if (v13 == v14)
    {
      if (v64 >= 0) {
        CFStringRef v15 = __n;
      }
      else {
        CFStringRef v15 = (std::string::size_type *)__n[0];
      }
      if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        CFStringRef v17 = (void *)__dst.__r_.__value_.__r.__words[0];
        int v18 = memcmp(__dst.__r_.__value_.__l.__data_, v15, __dst.__r_.__value_.__l.__size_);
        operator delete(v17);
        if (v18)
        {
LABEL_41:
          int v12 = 2;
          goto LABEL_42;
        }
      }
      else if (*((unsigned char *)&__dst.__r_.__value_.__s + 23))
      {
        uint64_t v16 = 0;
        while (__dst.__r_.__value_.__s.__data_[v16] == *((unsigned __int8 *)v15 + v16))
        {
          if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) == ++v16) {
            goto LABEL_72;
          }
        }
        goto LABEL_37;
      }
LABEL_72:
      memset(&__dst, 0, sizeof(__dst));
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = __str;
      }
      if (v64 >= 0) {
        std::string::size_type v44 = HIBYTE(v64);
      }
      else {
        std::string::size_type v44 = __n[1];
      }
      std::string::replace(&__dst, 0, v44, "", 0);
      std::string::size_type v45 = __dst.__r_.__value_.__l.__size_;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v45 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      double v46 = (double)v45;
      std::string::size_type v47 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v47 = __str.__r_.__value_.__l.__size_;
      }
      double v48 = (1.0 - v46 / (double)v47) * 9.0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      int v12 = 0;
      double v4 = v48 + 50.0;
LABEL_42:
      if ((SHIBYTE(v64) & 0x80000000) == 0) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
LABEL_37:
    if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    goto LABEL_41;
  }
  std::string::size_type v11 = __n[1];
  if (__n[1]) {
    goto LABEL_22;
  }
  int v12 = 2;
LABEL_43:
  operator delete((void *)__n[0]);
LABEL_44:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (v12) {
      return v4;
    }
  }
  else if (v12)
  {
    return v4;
  }
  CFDictionaryRef v19 = *a1;
  if (!*a1) {
    return 0.0;
  }
  CFDictionaryRef v20 = *a2;
  if (!*a2) {
    return 0.0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*a1, @"GID1");
  CFStringRef v22 = Value;
  if (Value)
  {
    CFTypeID v23 = CFGetTypeID(Value);
    if (v23 != CFStringGetTypeID()) {
      CFStringRef v22 = 0;
    }
  }
  CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(v19, @"GID2");
  CFStringRef v25 = v24;
  if (v24)
  {
    CFTypeID v26 = CFGetTypeID(v24);
    if (v26 != CFStringGetTypeID()) {
      CFStringRef v25 = 0;
    }
  }
  CFStringRef v27 = (const __CFString *)CFDictionaryGetValue(v20, @"GID1");
  CFStringRef v28 = v27;
  if (v27)
  {
    CFTypeID v29 = CFGetTypeID(v27);
    if (v29 != CFStringGetTypeID()) {
      CFStringRef v28 = 0;
    }
  }
  CFStringRef v30 = (const __CFString *)CFDictionaryGetValue(v20, @"GID2");
  CFStringRef v31 = v30;
  if (v30)
  {
    CFTypeID v32 = CFGetTypeID(v30);
    if (v32 != CFStringGetTypeID()) {
      CFStringRef v31 = 0;
    }
  }
  if (!v22 && !v28 && !v25 && !v31) {
    goto LABEL_66;
  }
  if (v22) {
    BOOL v36 = v28 == 0;
  }
  else {
    BOOL v36 = 1;
  }
  int v37 = !v36;
  if (v36)
  {
    if (v22) {
      return 0.0;
    }
    int v42 = 0;
    double v43 = 0.0;
  }
  else
  {
    if (!sub_1003F2ADC(v28, v22)) {
      return 0.0;
    }
    memset(&__dst, 0, sizeof(__dst));
    ctu::cf::assign();
    std::string::size_type v38 = __dst.__r_.__value_.__l.__size_;
    std::string __p = (void *)__dst.__r_.__value_.__r.__words[0];
    v67[0] = __dst.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v67 + 3) = *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3);
    int v39 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    memset(&__dst, 0, sizeof(__dst));
    ctu::cf::assign();
    long long v40 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
    v66[0] = __dst.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v66 + 3) = *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3);
    int v41 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if (v39 < 0)
    {
      sub_10004FC84(&__str, __p, v38);
    }
    else
    {
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      __str.__r_.__value_.__l.__size_ = v38;
      LODWORD(__str.__r_.__value_.__r.__words[2]) = v67[0];
      *(_DWORD *)((char *)&__str.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v67 + 3);
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = v39;
    }
    if (v41 < 0)
    {
      sub_10004FC84(__n, (void *)v40, *((unint64_t *)&v40 + 1));
    }
    else
    {
      *(_OWORD *)__n = v40;
      LODWORD(v64) = v66[0];
      *(_DWORD *)((char *)&v64 + 3) = *(_DWORD *)((char *)v66 + 3);
      HIBYTE(v64) = v41;
    }
    double v50 = sub_1006B47F8(&__str, (unsigned __int8 *)__n);
    if (SHIBYTE(v64) < 0) {
      operator delete((void *)__n[0]);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    if (v41 < 0) {
      operator delete((void *)v40);
    }
    if (v39 < 0) {
      operator delete(__p);
    }
    double v43 = v50 + 0.0;
    int v42 = 2;
  }
  if (v25 && v31)
  {
    if (sub_1003F2ADC(v31, v25))
    {
      if (v37) {
        int v42 = 3;
      }
      else {
        int v42 = 2;
      }
      memset(&__dst, 0, sizeof(__dst));
      ctu::cf::assign();
      long long v51 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
      v67[0] = __dst.__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v67 + 3) = *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3);
      int v52 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      memset(&__dst, 0, sizeof(__dst));
      ctu::cf::assign();
      long long v53 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
      v66[0] = __dst.__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v66 + 3) = *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3);
      int v54 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if (v52 < 0)
      {
        sub_10004FC84(&v62, (void *)v51, *((unint64_t *)&v51 + 1));
      }
      else
      {
        *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v51;
        LODWORD(v62.__r_.__value_.__r.__words[2]) = v67[0];
        *(_DWORD *)((char *)&v62.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v67 + 3);
        *((unsigned char *)&v62.__r_.__value_.__s + 23) = v52;
      }
      if (v54 < 0)
      {
        sub_10004FC84(&v59, (void *)v53, *((unint64_t *)&v53 + 1));
      }
      else
      {
        long long v59 = v53;
        *(_DWORD *)uint64_t v60 = v66[0];
        *(_DWORD *)&v60[3] = *(_DWORD *)((char *)v66 + 3);
        char v61 = v54;
      }
      double v55 = sub_1006B47F8(&v62, (unsigned __int8 *)&v59);
      if (v61 < 0) {
        operator delete((void *)v59);
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v62.__r_.__value_.__l.__data_);
        if ((v54 & 0x80000000) == 0)
        {
LABEL_134:
          if ((v52 & 0x80000000) == 0)
          {
LABEL_135:
            double v43 = v43 + v55;
            goto LABEL_136;
          }
LABEL_145:
          operator delete((void *)v51);
          goto LABEL_135;
        }
      }
      else if ((v54 & 0x80000000) == 0)
      {
        goto LABEL_134;
      }
      operator delete((void *)v53);
      if ((v52 & 0x80000000) == 0) {
        goto LABEL_135;
      }
      goto LABEL_145;
    }
    return 0.0;
  }
  if (v25) {
    return 0.0;
  }
LABEL_136:
  if (v42 == 2)
  {
    double v56 = 15.0;
  }
  else
  {
    if (v42 != 3) {
      goto LABEL_66;
    }
    double v56 = 30.0;
  }
  double v4 = v4 + v56 + v43;
LABEL_66:
  if (v4 != 0.0)
  {
    CFRange v33 = (const void *)qword_101B13EB8;
    CFStringRef v34 = (const __CFString *)CFDictionaryGetValue(*a1, (const void *)qword_101B13EB8);
    CFStringRef v35 = (const __CFString *)CFDictionaryGetValue(*a2, v33);
    if (v34 && v35)
    {
      if (sub_1003F2ADC(v35, v34)) {
        return v4 + 10.0;
      }
      else {
        return 0.0;
      }
    }
    else
    {
      if (v35) {
        BOOL v49 = 1;
      }
      else {
        BOOL v49 = v34 == 0;
      }
      if (!v49) {
        return 0.0;
      }
    }
  }
  return v4;
}

void sub_1006B46B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v47 < 0) {
    operator delete(v44);
  }
  if (v46 < 0) {
    operator delete(v45);
  }
  _Unwind_Resume(exception_object);
}

double sub_1006B47F8(std::string *__str, unsigned __int8 *a2)
{
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v5 = (std::string *)__str->__r_.__value_.__r.__words[0];
    double v4 = (std::string *)(__str->__r_.__value_.__r.__words[0] + __str->__r_.__value_.__l.__size_);
  }
  else
  {
    double v4 = (std::string *)((char *)__str + HIBYTE(__str->__r_.__value_.__r.__words[2]));
    uint64_t v5 = __str;
  }
  while (v5 != v4)
  {
    v5->__r_.__value_.__s.__data_[0] = __tolower(v5->__r_.__value_.__s.__data_[0]);
    uint64_t v5 = (std::string *)((char *)v5 + 1);
  }
  if ((char)a2[23] < 0)
  {
    int v7 = *(unsigned __int8 **)a2;
    int v6 = (unsigned __int8 *)(*(void *)a2 + *((void *)a2 + 1));
  }
  else
  {
    int v6 = &a2[a2[23]];
    int v7 = a2;
  }
  while (v7 != v6)
  {
    unsigned __int8 *v7 = __tolower((char)*v7);
    ++v7;
  }
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  else {
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  double v9 = 0.0;
  if (!size) {
    return v9;
  }
  if ((char)a2[23] < 0)
  {
    std::string::size_type v10 = *((void *)a2 + 1);
    if (!v10) {
      return v9;
    }
  }
  else
  {
    std::string::size_type v10 = a2[23];
    if (!a2[23]) {
      return v9;
    }
  }
  std::string::basic_string(&__p, __str, 0, v10, (std::allocator<char> *)&v25);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v11 = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v12 = a2[23];
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *((void *)a2 + 1);
  }
  if (v11 != v12) {
    goto LABEL_34;
  }
  if (v13 >= 0) {
    std::string::size_type v14 = a2;
  }
  else {
    std::string::size_type v14 = *(unsigned __int8 **)a2;
  }
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    uint64_t v16 = (void *)__p.__r_.__value_.__r.__words[0];
    int v17 = memcmp(__p.__r_.__value_.__l.__data_, v14, __p.__r_.__value_.__l.__size_);
    operator delete(v16);
    if (v17) {
      return v9;
    }
    goto LABEL_37;
  }
  if (!*((unsigned char *)&__p.__r_.__value_.__s + 23))
  {
LABEL_37:
    memset(&__p, 0, sizeof(__p));
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = *__str;
    }
    if ((char)a2[23] < 0) {
      std::string::size_type v18 = *((void *)a2 + 1);
    }
    else {
      std::string::size_type v18 = a2[23];
    }
    std::string::replace(&__p, 0, v18, "", 0);
    std::string::size_type v19 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v19 = __p.__r_.__value_.__l.__size_;
    }
    double v20 = (double)v19;
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      std::string::size_type v21 = __str->__r_.__value_.__l.__size_;
    }
    else {
      std::string::size_type v21 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    }
    double v22 = 1.0 - v20 / (double)v21;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return v22 * 4.0;
  }
  uint64_t v15 = 0;
  while (__p.__r_.__value_.__s.__data_[v15] == v14[v15])
  {
    if (HIBYTE(__p.__r_.__value_.__r.__words[2]) == ++v15) {
      goto LABEL_37;
    }
  }
LABEL_34:
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v9;
}

void sub_1006B4A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006B4A5C(uint64_t a1, void *a2, _OWORD *a3)
{
  *(void *)a1 = off_101AB2248;
  uint64_t v5 = (void *)(a1 + 8);
  int v6 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v5, v8);
  if (v6) {
    sub_10004D2C8(v6);
  }
  *(void *)a1 = off_1019F9340;
  *(_OWORD *)(a1 + 32) = *a3;
  return a1;
}

void sub_1006B4B00(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006B4B18(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == -2)
  {
    CFDictionaryRef v3 = *a2;
    BOOL v4 = 0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      double v9 = "UserInteractionRequired.xml";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Infinite validity of %s xml", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    BOOL v4 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
  return v4;
}

void sub_1006B4C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006B4C1C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1006B4C4C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1006B4C9C(void *a1@<X8>)
{
  v3[0] = off_1019F9508;
  v3[3] = v3;
  inactive = dispatch_workloop_create_inactive("DiagnosticsService");
  sub_100136200((uint64_t)v3, (uint64_t)inactive);
  dispatch_activate(inactive);
  sub_1001362D0(v3);
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1006B5200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 8))(a15);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v16);
  if (v15) {
    dispatch_release(v15);
  }
  _Unwind_Resume(a1);
}

void sub_1006B526C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_1006B5D38);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1006B52A0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (v1)
  {
    dispatch_release(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1006B52BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, char a20)
{
  std::__shared_weak_count::~__shared_weak_count(v25);
  operator delete(v26);
  CFStringRef v27 = *(std::__shared_weak_count **)(v21 + 160);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_1000346F8(v24, *(void **)(v21 + 136));
  sub_1006B5B38((void *)(v24 - 56));
  CFStringRef v28 = *(std::__shared_weak_count **)(v21 + 64);
  if (v28) {
    sub_10004D2C8(v28);
  }
  CFTypeID v29 = *(NSObject **)(v21 + 48);
  if (v29) {
    dispatch_release(v29);
  }
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  if (v20) {
    dispatch_release(v20);
  }
  operator delete();
}

void sub_1006B53C8(_Unwind_Exception *a1)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1006B53D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1001362D0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1006B53E4(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1006B53ECLL);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1006B53FC(uint64_t a1)
{
  *(void *)a1 = off_1019F93A0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 208);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFDictionaryRef v3 = *(std::__shared_weak_count **)(a1 + 192);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 176);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1000346F8(a1 + 128, *(void **)(a1 + 136));
  sub_1006B5B38((void *)(a1 + 72));
  int v6 = *(std::__shared_weak_count **)(a1 + 64);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (v7) {
    dispatch_release(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1006B54B0(uint64_t a1)
{
  sub_1006B53FC(a1);

  operator delete();
}

void sub_1006B54E8(void *a1, uint64_t a2)
{
  CFDictionaryRef v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        v13[2] = sub_1006B5668;
        v13[3] = &unk_1019F93B0;
        v13[4] = v5;
        std::string __p = 0;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        sub_100245E90(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
        CFTypeID v8 = (std::__shared_weak_count *)v5[2];
        if (!v8 || (uint64_t v9 = v5[1], (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        std::string::size_type v11 = v10;
        uint64_t v12 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1006B67C4;
        block[3] = &unk_1019F96E0;
        block[5] = v9;
        std::string::size_type v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (__p)
        {
          uint64_t v15 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1006B5650(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B5668(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 + 104 != a1 + 40) {
    sub_10008A534((char *)(v1 + 104), *(char **)(a1 + 40), *(void *)(a1 + 48), (uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 2);
  }
  uint64_t result = *(void *)(v1 + 96);
  if (result)
  {
    CFDictionaryRef v3 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v3();
  }
  return result;
}

void *sub_1006B56F4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = (void *)(a1 + 40);
  v2[2] = 0;
  return sub_100245E90(v2, *(const void **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 2);
}

void sub_1006B5710(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

uint64_t sub_1006B5728(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006B5744(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1006B5754(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 136);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = result + 136;
    do
    {
      int v4 = *(_DWORD *)(v1 + 28);
      BOOL v5 = v4 < 1;
      if (v4 >= 1) {
        int v6 = (uint64_t *)v1;
      }
      else {
        int v6 = (uint64_t *)(v1 + 8);
      }
      if (!v5) {
        uint64_t v3 = v1;
      }
      uint64_t v1 = *v6;
    }
    while (*v6);
    if (v3 != result + 136 && *(int *)(v3 + 28) <= 1)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(result + 152));
      CFTypeID v8 = ServiceMap;
      uint64_t v9 = "N3awd7metrics14MetricCountersE";
      if (((unint64_t)"N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
      {
        std::string::size_type v10 = (unsigned __int8 *)((unint64_t)"N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = (const char *)v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      int v17 = v9;
      int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v17);
      if (v13)
      {
        uint64_t v15 = v13[3];
        std::string::size_type v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
LABEL_19:
          sub_100BAA6EC(*(void *)(v15 + 448), *(_DWORD *)(v3 + 32));
          if ((v16 & 1) == 0) {
            sub_10004D2C8(v14);
          }
          uint64_t result = *(void *)(v2 + 184);
          if (result) {
            AWDModel::handleSignalBars((AWDModel *)result);
          }
          return result;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      std::string::size_type v14 = 0;
      char v16 = 1;
      goto LABEL_19;
    }
  }
  return result;
}

void sub_1006B5890(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006B58AC(uint64_t a1, NSObject **a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  int v4 = (AWDModel *)v3[23];
  if (v4)
  {
    BOOL v5 = *a2;
    dispatch_group_t group = v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    v6.var0.fObj = (dispatch_object_s *)&group;
    AWDModel::shutdown(v4, v6);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  uint64_t v7 = v3[25];
  if (v7)
  {
    CFTypeID v8 = *a2;
    if (v8)
    {
      dispatch_retain(v8);
      dispatch_group_enter(v8);
    }
    ctu::RestModule::disconnect((ctu::RestModule *)(v7 + 56));
    if (v8)
    {
      dispatch_group_leave(v8);
      dispatch_release(v8);
    }
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(v3 + 7));
}

void sub_1006B596C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006B59A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006B59C4(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1006B59D4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1006B5AA0(uint64_t a1)
{
  unsigned int v5 = -2;
  v4[0] = &v5;
  v4[1] = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1006B6F60;
  block[3] = &unk_1019F9790;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v2 = a1 + 24;
  char v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
  return v5;
}

void *sub_1006B5B38(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void sub_1006B5BD0()
{
}

void *sub_1006B5BE4()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019F9508;
  return result;
}

void sub_1006B5C1C(uint64_t a1, void *a2)
{
  *a2 = off_1019F9508;
}

void sub_1006B5C44(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_1006B5C50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006B5C90()
{
}

void sub_1006B5CA0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006B5CD8(uint64_t a1)
{
}

uint64_t sub_1006B5CF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006B5D38(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_1006B5D64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string::size_type v18 = a1;
  v19[0] = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 168))
  {
    Registry::getTimerService((uint64_t *)&v24, *(Registry **)(v2 + 152));
    uint64_t v3 = v24;
    sub_100058DB0(__p, "AWD Startup Metrics");
    uint64_t v5 = *(void *)(v2 + 152);
    uint64_t v4 = *(void *)(v2 + 160);
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    long long v33 = *(_OWORD *)__p;
    uint64_t v34 = v23;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    CFTypeID v26 = (void **)off_1019F9668;
    uint64_t v27 = v5;
    CFStringRef v28 = (void (*)(void *, uint64_t))v4;
    CFTypeID v29 = &v26;
    (*(void (**)(void *, long long *, void, uint64_t, void ***))(*(void *)v3 + 32))(v3, &v33, 0, 15000000, &v26);
    sub_10003B34C(&v26);
    if (SHIBYTE(v34) < 0) {
      operator delete((void *)v33);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    if (v25) {
      sub_10004D2C8(v25);
    }
    group_session v6 = *(std::__shared_weak_count **)(v2 + 16);
    if (v6)
    {
      uint64_t v7 = *(void *)(v2 + 8);
      CFTypeID v8 = std::__shared_weak_count::lock(v6);
      if (v8)
      {
        uint64_t v9 = v8;
        p_shared_weak_owners = &v8->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v8);
        CFTypeID v26 = _NSConcreteStackBlock;
        uint64_t v27 = 1174405120;
        CFStringRef v28 = sub_1006B54E8;
        CFTypeID v29 = (void ***)&unk_1019F93E0;
        uint64_t v30 = v2;
        uint64_t v31 = v7;
        CFTypeID v32 = v9;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        wis::WISServerConnection::registerCallBackForConfigChange();
        uint64_t v11 = *(NSObject **)(v2 + 24);
        dispatch_object_t v21 = v11;
        if (v11) {
          dispatch_retain(v11);
        }
        unsigned int v12 = *(NSObject **)(v2 + 32);
        dispatch_object_t object = v12;
        if (v12) {
          dispatch_retain(v12);
        }
        AWDModel::create((capabilities::abs *)&v21, &v33);
        long long v13 = v33;
        long long v33 = 0uLL;
        std::string::size_type v14 = *(std::__shared_weak_count **)(v2 + 192);
        *(_OWORD *)(v2 + 184) = v13;
        if (v14)
        {
          sub_10004D2C8(v14);
          if (*((void *)&v33 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
          }
        }
        if (object) {
          dispatch_release(object);
        }
        if (v21) {
          dispatch_release(v21);
        }
        uint64_t v15 = *(AWDModel **)(v2 + 184);
        if (v15) {
          AWDModel::enableMetricSubmissionInd(v15);
        }
        char v16 = *(NSObject **)(v2 + 24);
        v19[1] = (uint64_t)v16;
        if (v16) {
          dispatch_retain(v16);
        }
        sub_100E820A4();
      }
    }
    sub_100088B9C();
  }
  sub_1000E3958(v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_1006B60EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  CFStringRef v35 = *(std::__shared_weak_count **)(v33 - 104);
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (a32) {
    std::__shared_weak_count::__release_weak(a32);
  }
  std::__shared_weak_count::__release_weak(v32);
  sub_1000E3958(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1006B61DC(ServiceManager::Service *this)
{
  *(void *)this = off_1019F95E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1006B6238(ServiceManager::Service *this)
{
  *(void *)this = off_1019F95E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1006B62A8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DiagnosticsService");
}

unsigned char *sub_1006B62B8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1006B62F8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1006B59D4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1006B59D4(v4, 0);
}

uint64_t sub_1006B637C()
{
  return 0;
}

uint64_t sub_1006B6384()
{
  return 1;
}

uint64_t sub_1006B638C()
{
  return 0;
}

void sub_1006B6398(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B6478(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (!v1 || (uint64_t v2 = std::__shared_weak_count::lock(v1)) == 0) {
    sub_100088B9C();
  }
  uint64_t v3 = v2;
  uint64_t v4 = v2;
  atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  ServiceStage::scheduleAction();
  sub_10004D2C8(v4);
  sub_10004D2C8(v3);
}

void sub_1006B6544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void *sub_1006B6564(void *a1)
{
  *a1 = off_1019F9668;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1006B65B0(void *a1)
{
  *a1 = off_1019F9668;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1006B661C(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019F9668;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006B6678(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019F9668;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006B66B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1006B66C0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

uint64_t sub_1006B6700()
{
  return sub_100BC9F5C((wis::MetricFactory *)0x8004B);
}

uint64_t sub_1006B6778(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006B67B8()
{
}

uint64_t sub_1006B67C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1006B67D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006B67F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1006B6804()
{
}

__n128 sub_1006B6818(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F9720;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006B686C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F9720;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006B68A4(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  uint64_t v4 = a1[1];
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v5 = (uint64_t **)(v4 + 8);
  sub_1000346F8(v4, *(void **)(v4 + 8));
  *(void *)uint64_t v4 = v4 + 8;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v24, &object, 0);
    xpc_release(object);
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v23, &object, count);
    xpc_release(object);
    for (uint64_t i = v25; ; uint64_t i = ++v25)
    {
      if (i == v23[1] && v24 == v23[0])
      {
        xpc_release(v24);
        xpc_release(v24);
        goto LABEL_45;
      }
      xpc_object_t v22 = 0;
      xpc_object_t object = &v24;
      uint64_t v27 = i;
      sub_10003FBDC((uint64_t)&object, &v22);
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_43:
      xpc_release(v22);
    }
    memset(v21, 0, 12);
    xpc_object_t v8 = v22;
    if (v22)
    {
      xpc_retain(v22);
      xpc_object_t v29 = v8;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v29 = v8;
      if (!v8)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v8 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v8);
      xpc_object_t v9 = v8;
      goto LABEL_27;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_26:
    xpc_object_t v29 = v9;
LABEL_27:
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t object = &v29;
      uint64_t v27 = "first";
      sub_100048BAC((uint64_t)&object, &v28);
      xpc_type_t type = xpc_get_type(v28);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v30 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v30, (int *)&v28, v11);
        LODWORD(v21[0]) = v30;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        LODWORD(v21[0]) = xpc::dyn_cast_or_default((xpc *)&v28, 0, (uint64_t)v11);
      }
      xpc_release(v28);
      xpc_object_t object = &v29;
      uint64_t v27 = "second";
      sub_100048BAC((uint64_t)&object, &v28);
      read_rest_value();
      xpc_release(v28);
      xpc_object_t v9 = v29;
    }
    xpc_release(v9);
    xpc_release(v8);
    unsigned int v12 = *v5;
    long long v13 = (uint64_t **)(v4 + 8);
    std::string::size_type v14 = (uint64_t **)(v4 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          std::string::size_type v14 = (uint64_t **)v12;
          int v15 = *((_DWORD *)v12 + 7);
          if (v15 <= SLODWORD(v21[0])) {
            break;
          }
          unsigned int v12 = *v14;
          long long v13 = v14;
          if (!*v14) {
            goto LABEL_42;
          }
        }
        if (v15 >= SLODWORD(v21[0])) {
          break;
        }
        unsigned int v12 = v14[1];
        if (!v12)
        {
          long long v13 = v14 + 1;
          goto LABEL_42;
        }
      }
    }
    else
    {
LABEL_42:
      char v16 = operator new(0x30uLL);
      v16[7] = v21[0];
      *((void *)v16 + 4) = *(void *)((char *)v21 + 4);
      v16[10] = 0;
      sub_100046C38((uint64_t **)v4, (uint64_t)v14, v13, (uint64_t *)v16);
    }
    goto LABEL_43;
  }
LABEL_45:
  xpc_release(v3);
  int v17 = (uint64_t (*)(void *))a1[3];
  uint64_t v18 = a1[4];
  std::string::size_type v19 = (void *)(a1[2] + (v18 >> 1));
  if (v18) {
    int v17 = *(uint64_t (**)(void *))(*v19 + v17);
  }

  return v17(v19);
}

void sub_1006B6C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20,xpc_object_t a21)
{
  xpc_release(object);
  xpc_release(a16);
  xpc_release(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B6D74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006B6DB4()
{
}

uint64_t *sub_1006B6DC0(void *a1)
{
  v7[0] = (uint64_t)a1;
  uint64_t v1 = *(AWDModel **)(*a1 + 184);
  if (v1)
  {
    uint64_t v2 = a1[1];
    dispatch_group_t group = v2;
    if (v2)
    {
      dispatch_retain(v2);
      dispatch_group_enter(v2);
    }
    v3.var0.fObj = (dispatch_object_s *)&group;
    AWDModel::bootstrap(v1, v3);
  }
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4)
  {
    uint64_t v5 = a1[1];
    v7[1] = (uint64_t)v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    sub_100E82360(v4);
  }
  return sub_1003C2130(v7);
}

void sub_1006B6E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t a12)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_1003C2130(&a10);
  _Unwind_Resume(a1);
}

void sub_1006B6ED8(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = *(AWDModel **)(**(void **)a1 + 184);
  if (v1) {
    AWDModel::start(v1);
  }
  operator delete();
}

void sub_1006B6F34()
{
}

uint64_t sub_1006B6F60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(void *)(v2 + 200);
  if (v3)
  {
    uint64_t result = sub_100E836C4(v3);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)group_session v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No CellularHealth", v6, 2u);
    }
    uint64_t result = 4294967293;
  }
  **(_DWORD **)uint64_t v1 = result;
  return result;
}

void DDBControlImpl::create()
{
}

void sub_1006B7090()
{
}

uint64_t DDBControlImpl::DDBControlImpl(uint64_t a1, void *a2, NSObject **a3, void *a4, void *a5, char *a6, void *a7)
{
  *(void *)a1 = off_1019F9908;
  long long v13 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, a6);
  *long long v13 = 0;
  v13[1] = 0;
  std::string::size_type v14 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v14) {
    dispatch_retain(v14);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v32, (const OsLogContext *)buf);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v32);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v32);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  *(_DWORD *)(a1 + 56) = 1;
  *(void *)a1 = off_1019F97C0;
  *(void *)(a1 + 48) = off_1019F9888;
  *(void *)(a1 + 64) = off_1019F98E0;
  *(void *)(a1 + 72) = *a2;
  uint64_t v15 = a2[1];
  *(void *)(a1 + 80) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "DDBControl");
  char v16 = *(NSObject **)(a1 + 24);
  xpc_object_t v29 = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  ctu::RestModule::RestModule();
  if (v29) {
    dispatch_release(v29);
  }
  if (v31 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 104) = *a7;
  uint64_t v17 = a7[1];
  *(void *)(a1 + 112) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = *a4;
  uint64_t v18 = a4[1];
  *(void *)(a1 + 128) = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 136) = *a5;
  uint64_t v19 = a5[1];
  *(void *)(a1 + 144) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  double v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    uint64_t v22 = ***(void ***)(a1 + 120);
    char v25 = *(const char **)(v22 + 24);
    uint64_t v23 = (const char *)(v22 + 24);
    xpc_object_t v24 = v25;
    uint64_t v26 = *((unsigned __int8 *)v23 + 23);
    int v27 = (char)v26;
    if ((v26 & 0x80u) != 0) {
      uint64_t v26 = *((void *)v23 + 1);
    }
    if (v27 < 0) {
      uint64_t v23 = v24;
    }
    if (!v26) {
      uint64_t v23 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v34 = v21;
    __int16 v35 = 2080;
    BOOL v36 = " ";
    __int16 v37 = 2080;
    std::string::size_type v38 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%sCreated for %s", buf, 0x20u);
  }
  return a1;
}

void sub_1006B73BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1001FEC70(*(void **)(v21 + 176));
  char v25 = *(std::__shared_weak_count **)(v21 + 160);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 144);
  if (v26) {
    sub_10004D2C8(v26);
  }
  int v27 = *(std::__shared_weak_count **)(v21 + 128);
  if (v27) {
    sub_10004D2C8(v27);
  }
  xpc_object_t v28 = *(std::__shared_weak_count **)(v21 + 112);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  xpc_object_t v29 = *(std::__shared_weak_count **)(v21 + 96);
  if (v29) {
    sub_10004D2C8(v29);
  }
  int v30 = *(std::__shared_weak_count **)(v21 + 80);
  if (v30) {
    sub_10004D2C8(v30);
  }
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B7490(uint64_t a1)
{
  *(void *)a1 = off_1019F97C0;
  *(void *)(a1 + 48) = off_1019F9888;
  *(void *)(a1 + 64) = off_1019F98E0;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
  sub_1001FEC70(*(void **)(a1 + 176));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 112);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  group_session v6 = *(std::__shared_weak_count **)(a1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7) {
    sub_10004D2C8(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_1006B7584(uint64_t a1)
{
  return sub_1006B7490(a1 - 48);
}

uint64_t sub_1006B758C(uint64_t a1)
{
  return sub_1006B7490(a1 - 64);
}

void sub_1006B7594(uint64_t a1)
{
  sub_1006B7490(a1);

  operator delete();
}

void sub_1006B75CC(uint64_t a1)
{
  sub_1006B7490(a1 - 48);

  operator delete();
}

void sub_1006B7608(uint64_t a1)
{
  sub_1006B7490(a1 - 64);

  operator delete();
}

const void **sub_1006B7654@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v17 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v18 = v6;
  std::string::size_type v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, __CFString *, void, uint64_t))(*(void *)v12 + 24))(&v16, v12, ***(void ***)(a1 + 120) + 24, @"service-token", off_101B0ACC0, 0, 4);
  sub_1000C15D8(&v17, &v16);
  sub_1000577C4(&v16);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v17) {
    std::string::size_type v14 = sub_10008324C;
  }
  else {
    std::string::size_type v14 = 0;
  }
  if (v14)
  {
    long long v18 = 0uLL;
    uint64_t v19 = 0;
    ctu::cf::assign();
    std::string::size_type v14 = v19;
    *(_OWORD *)a2 = v18;
    *(void *)(a2 + 16) = v14;
    LOBYTE(v14) = 1;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 24) = (_BYTE)v14;
  return sub_100030068(&v17);
}

void sub_1006B7800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100030068(&a10);
  _Unwind_Resume(a1);
}

const void **sub_1006B784C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1006B7654(a1 - 48, a2);
}

void sub_1006B7854(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(unsigned __int8 *)(a3 + 24);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
  uint64_t v7 = ServiceMap;
  if (!v5)
  {
    if (v8 < 0)
    {
      char v16 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v8 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    std::string __p = (void *)v8;
    uint64_t v19 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__p);
    if (v19)
    {
      uint64_t v20 = v19[3];
      char v13 = (std::__shared_weak_count *)v19[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v21 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v7);
    char v13 = 0;
    char v21 = 1;
LABEL_29:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFString *, void, uint64_t))(*(void *)v20 + 32))(v20, ***(void ***)(a1 + 120) + 24, @"service-token", off_101B0ACC0, 0, 4);
    if (v21) {
      return;
    }
    goto LABEL_25;
  }
  if (v8 < 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__p);
  if (v12)
  {
    uint64_t v14 = v12[3];
    char v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  char v13 = 0;
  char v15 = 1;
LABEL_16:
  uint64_t v22 = ***(void ***)(a1 + 120);
  int v27 = 0;
  uint64_t v28 = 0;
  uint64_t v26 = 0;
  sub_10005C928(&v26, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  CFTypeID v32 = 0;
  uint64_t v33 = 0;
  char v31 = 0;
  sub_10005C928(&v31, v26, (uint64_t)v27, v27 - (unsigned char *)v26);
  int v30 = 0;
  std::string __p = 0;
  __int16 v35 = 0;
  uint64_t v36 = 0;
  sub_10005C928(&__p, v31, (uint64_t)v32, v32 - (unsigned char *)v31);
  __int16 v37 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v23 = v30;
    int v30 = v37;
    std::string::size_type v38 = v23;
    sub_100030068(&v38);
  }
  uint64_t v24 = v22 + 24;
  if (__p)
  {
    __int16 v35 = __p;
    operator delete(__p);
  }
  char v25 = v30;
  xpc_object_t v29 = v30;
  int v30 = 0;
  sub_100030068(&v30);
  if (v31)
  {
    CFTypeID v32 = v31;
    operator delete(v31);
  }
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, __CFString *, void, uint64_t, void))(*(void *)v14 + 16))(v14, v24, @"service-token", v25, off_101B0ACC0, 0, 4, 0);
  sub_100030068(&v29);
  if (v26)
  {
    int v27 = v26;
    operator delete(v26);
  }
  if ((v15 & 1) == 0) {
LABEL_25:
  }
    sub_10004D2C8(v13);
}

void sub_1006B7B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006B7BC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1006B7BCC(uint64_t a1)
{
  sub_10003E168(&v4, (void *)(a1 + 8));
  uint64_t v2 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B7CE4(uint64_t a1)
{
  sub_10003E168(&v4, (void *)(a1 + 8));
  uint64_t v2 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B7DFC(uint64_t a1, uint64_t a2, uint64_t a3, dispatch_object_t *a4)
{
  sub_10003E168(&v9, (void *)(a1 + 8));
  uint64_t v6 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *a4;
  if (*a4)
  {
    dispatch_retain(*a4);
    dispatch_group_enter(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B7F44(uint64_t a1)
{
  sub_10003E168(&v4, (void *)(a1 + 8));
  uint64_t v2 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B805C(uint64_t a1)
{
  sub_10003E168(&v4, (void *)(a1 + 8));
  uint64_t v2 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B8174(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006B8264(uint64_t a1)
{
}

void sub_1006B826C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v5;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%shandleEntitlementStatesChanged", (uint8_t *)&buf, 0x16u);
  }
  uint64_t v7 = (PersonalityInfo ****)(a1 + 120);
  uint64_t v6 = *(void *)(a1 + 120);
  *(_OWORD *)std::string __dst = 0u;
  long long v53 = 0u;
  uint64_t v8 = sub_100046F68(a2, (void **)(**(void **)v6 + 24));
  if ((void **)(a2 + 8) == v8) {
    goto LABEL_77;
  }
  if ((*((unsigned char *)v8 + 58) & 2) == 0) {
    goto LABEL_77;
  }
  uint64_t v9 = (char *)v8[9];
  if (!v9) {
    goto LABEL_77;
  }
  uint64_t v10 = v8 + 9;
  do
  {
    int v11 = *((_DWORD *)v9 + 7);
    BOOL v12 = v11 < 17;
    if (v11 >= 17) {
      char v13 = (void **)v9;
    }
    else {
      char v13 = (void **)(v9 + 8);
    }
    if (!v12) {
      uint64_t v10 = (void **)v9;
    }
    uint64_t v9 = (char *)*v13;
  }
  while (*v13);
  if (v10 == v8 + 9 || *((int *)v10 + 7) > 17 || *((_DWORD *)v10 + 8) != 2) {
    goto LABEL_77;
  }
  char v16 = (char *)v8[12];
  uint64_t v14 = v8 + 12;
  char v15 = v16;
  if (v16)
  {
    uint64_t v17 = v14;
    do
    {
      int v18 = *((_DWORD *)v15 + 8);
      BOOL v19 = v18 < 17;
      if (v18 >= 17) {
        uint64_t v20 = (void **)v15;
      }
      else {
        uint64_t v20 = (void **)(v15 + 8);
      }
      if (!v19) {
        uint64_t v17 = (void **)v15;
      }
      char v15 = (char *)*v20;
    }
    while (*v20);
    if (v17 != v14 && *((int *)v17 + 8) <= 17)
    {
      char v21 = (const std::string *)v17[8];
      if (v21 && v21[1].__r_.__value_.__s.__data_[0])
      {
        if (SHIBYTE(v21->__r_.__value_.__r.__words[2]) < 0) {
          std::string::size_type size = v21->__r_.__value_.__l.__size_;
        }
        else {
          std::string::size_type size = HIBYTE(v21->__r_.__value_.__r.__words[2]);
        }
        if (size)
        {
          sub_100179AF8((std::string *)__dst, v21);
          std::string::size_type v45 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_34;
          }
          std::string::size_type v46 = PersonalityInfo::logPrefix(***v7);
          int v47 = __dst;
          if (SBYTE7(v53) < 0) {
            int v47 = (void **)__dst[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v46;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          long long v57 = v47;
          char v25 = "#I %s%sAllowed with alternative url: %s";
          uint64_t v26 = v45;
          uint32_t v27 = 32;
          goto LABEL_33;
        }
        double v48 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v49 = PersonalityInfo::logPrefix(***v7);
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v49;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%sAllowed with alternative url, which is not yet given - waiting", (uint8_t *)&buf, 0x16u);
        }
LABEL_77:
        int v41 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_80;
        }
        std::string::size_type v50 = PersonalityInfo::logPrefix(***v7);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v50;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        double v43 = "#I %s%sservice is not allowed";
        goto LABEL_79;
      }
      char v23 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      std::string::size_type v44 = PersonalityInfo::logPrefix(***v7);
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v44;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      char v25 = "#I %s%sNo alt server given. Allowed with ES url";
LABEL_32:
      uint64_t v26 = v23;
      uint32_t v27 = 22;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, (uint8_t *)&buf, v27);
      goto LABEL_34;
    }
  }
  char v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v24 = PersonalityInfo::logPrefix(***v7);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v24;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    char v25 = "#I %s%sno details given - Allowed with ES url";
    goto LABEL_32;
  }
LABEL_34:
  if (BYTE8(v53)) {
    goto LABEL_42;
  }
  memset(&buf, 0, sizeof(buf));
  sub_100CE9A24(*(void *)(a1 + 136), (uint64_t)&buf);
  std::string::size_type v28 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  char v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v28 = buf.__r_.__value_.__l.__size_;
  }
  if (v28)
  {
    sub_100093B44((std::string *)__dst, &buf);
    char v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  }
  if (v29 < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (BYTE8(v53))
  {
LABEL_42:
    uint64_t v30 = *(void *)(a1 + 152);
    if (!v30) {
      goto LABEL_58;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v55 = 0;
    if (*(char *)(v30 + 423) < 0)
    {
      sub_10004FC84(__p, *(void **)(v30 + 400), *(void *)(v30 + 408));
    }
    else
    {
      uint64_t v31 = v30 + 400;
      *(_OWORD *)std::string __p = *(_OWORD *)v31;
      uint64_t v55 = *(void *)(v31 + 16);
    }
    if (!sub_10001D294((unsigned __int8 *)__dst, (unsigned __int8 *)__p))
    {
      CFTypeID v32 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v33 = PersonalityInfo::logPrefix(***v7);
        uint64_t v34 = __p;
        if (v55 < 0) {
          uint64_t v34 = (void **)__p[0];
        }
        __int16 v35 = __dst;
        if (SBYTE7(v53) < 0) {
          __int16 v35 = (void **)__dst[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v33;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        long long v57 = v34;
        __int16 v58 = 2080;
        long long v59 = v35;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%sserver address is changing from %s to %s", (uint8_t *)&buf, 0x2Au);
      }
      uint64_t v36 = *(std::__shared_weak_count **)(a1 + 160);
      *(void *)(a1 + 152) = 0;
      *(void *)(a1 + 160) = 0;
      if (v36) {
        sub_10004D2C8(v36);
      }
    }
    if (SHIBYTE(v55) < 0) {
      operator delete(__p[0]);
    }
    if (!*(void *)(a1 + 152))
    {
LABEL_58:
      __int16 v37 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v38 = PersonalityInfo::logPrefix(***v7);
        int v39 = __dst;
        if (SBYTE7(v53) < 0) {
          int v39 = (void **)__dst[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v38;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        long long v57 = v39;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%screating driver with url: %s", (uint8_t *)&buf, 0x20u);
      }
      long long v40 = *(NSObject **)(a1 + 24);
      if (v40) {
        dispatch_retain(v40);
      }
      sub_10003E168(__p, (void *)(a1 + 8));
      __p[0] = 0;
      __p[1] = 0;
      entitlements::CEHTTPDriver::create();
    }
    goto LABEL_82;
  }
  int v41 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v42 = PersonalityInfo::logPrefix(***v7);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v42;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    double v43 = "#W %s%sserver address is missing. Driver is not created";
LABEL_79:
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v43, (uint8_t *)&buf, 0x16u);
  }
LABEL_80:
  long long v51 = *(std::__shared_weak_count **)(a1 + 160);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  if (v51) {
    sub_10004D2C8(v51);
  }
LABEL_82:
  if (BYTE8(v53) && SBYTE7(v53) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1006B8B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23)
  {
    if (a22 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1006B8C30(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 152))
  {
    CFMutableDictionaryRef v15 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v5 = v15;
      CFMutableDictionaryRef v15 = Mutable;
      *(void *)std::string buf = v5;
      sub_10005717C((const void **)buf);
    }
    uint64_t v6 = v15;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)BOOL v12 = *(_OWORD *)a2;
      uint64_t v13 = *(void *)(a2 + 16);
    }
    if (SHIBYTE(v13) < 0)
    {
      sub_10004FC84(__p, v12[0], (unint64_t)v12[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v12;
      uint64_t v18 = v13;
    }
    char v16 = 0;
    if (SHIBYTE(v18) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v18;
    }
    BOOL v19 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v9 = v16;
      char v16 = v19;
      uint64_t v20 = v9;
      sub_1000558F4(&v20);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v10 = v16;
    uint64_t v14 = v16;
    char v16 = 0;
    sub_1000558F4(&v16);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
    CFDictionarySetValue(v6, @"service", v10);
    sub_1000558F4(&v14);
    if (SHIBYTE(v13) < 0) {
      operator delete(v12[0]);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_10004EFE4(&v20, (CFTypeRef *)&v15);
    __p[0] = *(void **)buf;
    int v11 = v20;
    uint64_t v20 = 0;
    *(void *)std::string buf = v11;
    sub_100057D78((const void **)__p);
    sub_100057D78(&v20);
    (*(void (**)(void, uint64_t, unsigned char *))(**(void **)(a1 + 152) + 200))(*(void *)(a1 + 152), 22, buf);
    (*(void (**)(void))(**(void **)(a1 + 152) + 352))(*(void *)(a1 + 152));
    sub_1000577C4((const void **)&buf[8]);
    sub_100057D78((const void **)buf);
    sub_10005717C((const void **)&v15);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sDriver is not yet created, maybe carrier doesnt support dedicated bearer", buf, 0x16u);
    }
  }
}

void sub_1006B8F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1006B8FA8(uint64_t a1, uint64_t a2, uint64_t a3, const void ****a4)
{
  if (!*(void *)(a1 + 152))
  {
    BOOL v12 = *(NSObject **)(a1 + 40);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    uint64_t v15 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    char v16 = "#I %s%sDriver is not yet created, maybe carrier doesnt support dedicated bearer";
    uint64_t v17 = v12;
    uint32_t v18 = 22;
    goto LABEL_21;
  }
  uint64_t v8 = sub_100046F68(a1 + 168, (void **)a2);
  if ((void **)(a1 + 176) == v8)
  {
    BOOL v19 = *(NSObject **)(a1 + 40);
    BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v20) {
      return result;
    }
    uint64_t v21 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v22 = (void *)a2;
    }
    else {
      uint64_t v22 = *(void **)a2;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    uint64_t v66 = v22;
    char v16 = "#I %s%sLink statistics is not yet available for service %s. Rejecting request";
LABEL_20:
    uint64_t v17 = v19;
    uint32_t v18 = 32;
LABEL_21:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    return 0;
  }
  if (!v8[7])
  {
    BOOL v19 = *(NSObject **)(a1 + 40);
    BOOL v23 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v23) {
      return result;
    }
    uint64_t v24 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    if (*(char *)(a2 + 23) >= 0) {
      char v25 = (void *)a2;
    }
    else {
      char v25 = *(void **)a2;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v24;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    uint64_t v66 = v25;
    char v16 = "#I %s%sServer do not support service %s";
    goto LABEL_20;
  }
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v10 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    *(void *)std::string buf = v10;
    sub_10005717C((const void **)buf);
  }
  CFDictionarySetValue(theDict, @"operation", @"enable");
  int v11 = theDict;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v58 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v58) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v62 = v58;
  }
  uint64_t v63 = 0;
  if (SHIBYTE(v62) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v62;
  }
  uint64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v26 = v63;
    uint64_t v63 = v64;
    int v54 = v26;
    sub_1000558F4((const void **)&v54);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  std::string value = v63;
  uint64_t v63 = 0;
  sub_1000558F4((const void **)&v63);
  if (SHIBYTE(v62) < 0) {
    operator delete(__p[0]);
  }
  CFDictionarySetValue(v11, @"service", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v58) < 0) {
    operator delete(__dst[0]);
  }
  CFMutableArrayRef theArray = 0;
  uint32_t v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v27)
  {
    CFMutableArrayRef v28 = theArray;
    CFMutableArrayRef theArray = v27;
    *(void *)std::string buf = v28;
    sub_1000440D4((const void **)buf);
  }
  char v29 = *a4;
  uint64_t v30 = a4[1];
  if (*a4 != v30)
  {
    do
    {
      __p[0] = 0;
      CFMutableDictionaryRef v31 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v31)
      {
        CFTypeID v32 = __p[0];
        __p[0] = v31;
        *(void *)std::string buf = v32;
        sub_10005717C((const void **)buf);
      }
      std::string::size_type v33 = *v29;
      uint64_t v34 = **v29;
      if (v34) {
        __int16 v35 = sub_1000810B8;
      }
      else {
        __int16 v35 = 0;
      }
      if (v35)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"src-ip", v34);
        std::string::size_type v33 = *v29;
      }
      uint64_t v36 = v33[1];
      if (v36) {
        __int16 v37 = sub_100083F10;
      }
      else {
        __int16 v37 = 0;
      }
      if (v37)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"src-port", v36);
        std::string::size_type v33 = *v29;
      }
      std::string::size_type v38 = v33[2];
      if (v38) {
        int v39 = sub_1000810B8;
      }
      else {
        int v39 = 0;
      }
      if (v39)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"remote-ip", v38);
        std::string::size_type v33 = *v29;
      }
      long long v40 = v33[3];
      if (v40) {
        int v41 = sub_100083F10;
      }
      else {
        int v41 = 0;
      }
      if (v41)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"remote-port", v40);
        std::string::size_type v33 = *v29;
      }
      std::string::size_type v42 = v33[4];
      if (v42)
      {
        if (v42 == (const void *)6)
        {
          CFStringRef v43 = @"tcp";
        }
        else
        {
          if (v42 != (const void *)17) {
            goto LABEL_69;
          }
          CFStringRef v43 = @"udp";
        }
      }
      else
      {
        CFStringRef v43 = @"ip";
      }
      CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"protocol", v43);
      std::string::size_type v33 = *v29;
LABEL_69:
      std::string::size_type v44 = v33[5];
      if (v44) {
        std::string::size_type v45 = sub_1000810B8;
      }
      else {
        std::string::size_type v45 = 0;
      }
      if (v45)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"traffic-class", v44);
        std::string::size_type v33 = *v29;
      }
      std::string::size_type v46 = v33[6];
      if (!v46)
      {
        CFStringRef v47 = @"UL";
        goto LABEL_78;
      }
      if (v46 == (const void *)1)
      {
        CFStringRef v47 = @"DL";
LABEL_78:
        CFDictionarySetValue((CFMutableDictionaryRef)__p[0], @"direction", v47);
      }
      CFArrayAppendValue(theArray, __p[0]);
      sub_10005717C((const void **)__p);
      v29 += 2;
    }
    while (v29 != v30);
  }
  CFDictionarySetValue(theDict, @"flow-rules", theArray);
  int v54 = 0;
  uint64_t v55 = 0;
  sub_10004EFE4(__p, (CFTypeRef *)&theDict);
  *(void *)std::string buf = v54;
  int v54 = __p[0];
  __p[0] = 0;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)__p);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v50, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string::size_type v50 = *(_OWORD *)a3;
    uint64_t v51 = *(void *)(a3 + 16);
  }
  if (SHIBYTE(v51) < 0)
  {
    sub_10004FC84(__p, v50[0], (unint64_t)v50[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v50;
    uint64_t v62 = v51;
  }
  std::string value = 0;
  if (SHIBYTE(v62) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v62;
  }
  uint64_t v63 = 0;
  if (ctu::cf::convert_copy())
  {
    double v48 = value;
    std::string value = v63;
    uint64_t v64 = v48;
    sub_1000558F4((const void **)&v64);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  std::string::size_type v49 = value;
  int v52 = value;
  std::string value = 0;
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v62) < 0) {
    operator delete(__p[0]);
  }
  long long v53 = v49;
  if (v49) {
    CFRetain(v49);
  }
  *(void *)std::string buf = v55;
  uint64_t v55 = v49;
  long long v53 = 0;
  sub_1000577C4((const void **)buf);
  sub_1000577C4(&v53);
  sub_1000558F4((const void **)&v52);
  if (SHIBYTE(v51) < 0) {
    operator delete(v50[0]);
  }
  (*(void (**)(void, uint64_t, void **))(**(void **)(a1 + 152) + 208))(*(void *)(a1 + 152), 23, &v54);
  (*(void (**)(void))(**(void **)(a1 + 152) + 352))(*(void *)(a1 + 152));
  sub_1000577C4(&v55);
  sub_100057D78((const void **)&v54);
  sub_1000440D4((const void **)&theArray);
  sub_10005717C((const void **)&theDict);
  return 1;
}

void sub_1006B9784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, const void *a19, uint64_t a20,const void *a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,const void *a29,const void *a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,char a38)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1000577C4((const void **)&a20);
  sub_100057D78(&a19);
  sub_1000440D4(&a21);
  sub_10005717C(&a29);
  _Unwind_Resume(a1);
}

BOOL sub_1006B98A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 152);
  if (v5)
  {
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v9 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      *(void *)std::string buf = v9;
      sub_10005717C((const void **)buf);
    }
    CFDictionarySetValue(theDict, @"operation", @"delete");
    CFMutableDictionaryRef v10 = theDict;
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a4;
      uint64_t v24 = *(void *)(a4 + 16);
    }
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v28 = v24;
    }
    char v29 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v28;
    }
    uint64_t v30 = 0;
    if (ctu::cf::convert_copy())
    {
      BOOL v13 = v29;
      char v29 = v30;
      uint64_t v21 = v13;
      sub_1000558F4((const void **)&v21);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    std::string value = v29;
    char v29 = 0;
    sub_1000558F4((const void **)&v29);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    CFDictionarySetValue(v10, @"session-id", value);
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v24) < 0) {
      operator delete(__dst[0]);
    }
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    sub_10004EFE4(__p, (CFTypeRef *)&theDict);
    *(void *)std::string buf = v21;
    uint64_t v21 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)__p);
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v17, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v17 = *(_OWORD *)a3;
      uint64_t v18 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v18) < 0)
    {
      sub_10004FC84(__p, v17[0], (unint64_t)v17[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v17;
      uint64_t v28 = v18;
    }
    std::string value = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v28;
    }
    char v29 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v14 = value;
      std::string value = v29;
      uint64_t v30 = v14;
      sub_1000558F4((const void **)&v30);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v15 = value;
    BOOL v19 = value;
    std::string value = 0;
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    BOOL v20 = v15;
    if (v15) {
      CFRetain(v15);
    }
    *(void *)std::string buf = v22;
    uint64_t v22 = v15;
    BOOL v20 = 0;
    sub_1000577C4((const void **)buf);
    sub_1000577C4(&v20);
    sub_1000558F4((const void **)&v19);
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    (*(void (**)(void, uint64_t, void **))(**(void **)(a1 + 152) + 208))(*(void *)(a1 + 152), 23, &v21);
    (*(void (**)(void))(**(void **)(a1 + 152) + 352))(*(void *)(a1 + 152));
    sub_1000577C4(&v22);
    sub_100057D78((const void **)&v21);
    sub_10005717C((const void **)&theDict);
  }
  else
  {
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%sDriver is not yet created, maybe carrier doesnt support dedicated bearer", buf, 0x16u);
    }
  }
  return v5 != 0;
}

void sub_1006B9CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,const void *a27,const void *a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1000577C4((const void **)&a19);
  sub_100057D78(&a18);
  sub_10005717C(&a27);
  _Unwind_Resume(a1);
}

const void **sub_1006B9DE4(const void **a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  uint64_t v4 = *a1;
  *a1 = v3;
  uint64_t v6 = v4;
  sub_1000570E8(&v6);
  return a1;
}

void sub_1006B9E38(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 40);
  CFTypeRef v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v18 = v4;
    __int16 v19 = 2080;
    BOOL v20 = " ";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s |--- Dedicated Bearer Controller:", buf, 0x16u);
    CFTypeRef v3 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
    uint64_t v6 = asStringBool(*(void *)(a1 + 152) != 0);
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v18 = v5;
    __int16 v19 = 2080;
    BOOL v20 = " ";
    __int16 v21 = 2080;
    uint64_t v22 = (void *)v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s | Has driver: %s", buf, 0x20u);
  }
  if (*(void *)(a1 + 184))
  {
    uint64_t v7 = *(void **)(a1 + 168);
    if (v7 != (void *)(a1 + 176))
    {
      do
      {
        uint64_t v8 = *v2;
        if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
        {
          CFMutableDictionaryRef v9 = v7 + 4;
          uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
          if (*((char *)v7 + 55) < 0) {
            CFMutableDictionaryRef v9 = (void *)*v9;
          }
          *(_DWORD *)std::string buf = 136315906;
          uint64_t v18 = v10;
          __int16 v19 = 2080;
          BOOL v20 = " ";
          __int16 v21 = 2080;
          uint64_t v22 = v9;
          __int16 v23 = 2080;
          uint64_t v24 = "TBD";
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s | links characteristics for '%s': %s", buf, 0x2Au);
        }
        int v11 = (void *)v7[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            int v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v7[2];
            BOOL v13 = *v12 == (void)v7;
            uint64_t v7 = v12;
          }
          while (!v13);
        }
        uint64_t v7 = v12;
      }
      while (v12 != (void *)(a1 + 176));
    }
  }
  else
  {
    uint64_t v14 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 120));
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v18 = v15;
      __int16 v19 = 2080;
      BOOL v20 = " ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s | No link characteristics", buf, 0x16u);
    }
  }
  uint64_t v16 = *(void *)(a1 + 152);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 328))(v16);
  }
  sub_100CEF66C(*(void *)(a1 + 120), v2);
}

void sub_1006BA148(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void **a5, const void **a6)
{
  uint64_t v9 = a4[1];
  uint64_t v10 = a1 - 48;
  v13[0] = *a4;
  v13[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v11, a6);
  sub_1006BA214(v10, a2, a3, (uint64_t)v13, &v12, &v11);
}

void sub_1006BA1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006BA214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5, const void **a6)
{
  uint64_t v9 = a1 + 8;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v10 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(void *)(a4 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v13, a6);
  sub_1006BC280(v9);
}

void sub_1006BA2FC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void **a5, const void **a6)
{
  uint64_t v9 = a4[1];
  uint64_t v10 = a1 - 48;
  v13[0] = *a4;
  v13[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v11, a6);
  sub_1006BA3C8(v10, a2, a3, (uint64_t)v13, &v12, &v11);
}

void sub_1006BA3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006BA3C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5, const void **a6)
{
  uint64_t v9 = a1 + 8;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v10 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(void *)(a4 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v13, a6);
  sub_1006BCD6C(v9);
}

void sub_1006BA4B0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void **a5, const void **a6)
{
  uint64_t v9 = a4[1];
  uint64_t v10 = a1 - 48;
  v13[0] = *a4;
  v13[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v11, a6);
  sub_1006BA57C(v10, a2, a3, (uint64_t)v13, &v12, &v11);
}

void sub_1006BA554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006BA57C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5, const void **a6)
{
  uint64_t v9 = a1 + 8;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v10 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(void *)(a4 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v13, a6);
  sub_1006BD74C(v9);
}

void sub_1006BA664(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void **a5, const void **a6)
{
  uint64_t v9 = a4[1];
  uint64_t v10 = a1 - 48;
  v13[0] = *a4;
  v13[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v11, a6);
  sub_1006BA730(v10, a2, a3, (uint64_t)v13, &v12, &v11);
}

void sub_1006BA708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1006BA730(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5, const void **a6)
{
  uint64_t v9 = a1 + 8;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v10 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(void *)(a4 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v12, a5);
  sub_1000584C8(&v13, a6);
  sub_1006BDA0C(v9);
}

BOOL sub_1006BA818(uint64_t a1)
{
  return *(void *)(a1 + 152) && *(unsigned char *)(***(void ***)(a1 + 120) + 48) != 0;
}

void sub_1006BA844(uint64_t a1@<X0>, void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = sub_100046F68(a1 + 168, a2);
  if ((void **)(a1 + 176) == v6)
  {
    sub_1006B8C30(a1, (uint64_t)a2);
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v7 = (atomic_ullong *)v6[8];
    *a3 = v6[7];
    a3[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    }
  }
}

uint64_t sub_1006BA8B4(uint64_t a1, uint64_t a2)
{
  return 1;
}

void sub_1006BA8D8(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

void sub_1006BA8E8(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1006BA8F8(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

void sub_1006BA908(void *a1@<X8>)
{
  *a1 = 0;
}

BOOL sub_1006BA914(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const void **)a1;
  if (v4) {
    uint64_t v5 = sub_100081E58;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(const void **)a2;
  if (v6) {
    uint64_t v7 = sub_100081E58;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((v5 == 0) == (v7 != 0) || v5 && CFEqual(v4, v6) != 1) {
    return 0;
  }
  uint64_t v8 = *(const void **)(a1 + 8);
  uint64_t v9 = v8 ? sub_100081E58 : 0;
  uint64_t v10 = *(const void **)(a2 + 8);
  uint64_t v11 = v10 ? sub_100081E58 : 0;
  if ((v9 == 0) == (v11 != 0) || v9 && CFEqual(v8, v10) != 1) {
    return 0;
  }
  uint64_t v12 = *(const void **)(a1 + 16);
  BOOL v13 = v12 ? sub_100081E58 : 0;
  uint64_t v14 = *(const void **)(a2 + 16);
  uint64_t v15 = v14 ? sub_100081E58 : 0;
  if ((v13 == 0) == (v15 != 0) || v13 && CFEqual(v12, v14) != 1) {
    return 0;
  }
  if (*(void *)(a1 + 24)) {
    uint64_t v16 = sub_100081E58;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(const void **)(a2 + 24);
  if (v17) {
    uint64_t v18 = sub_100081E58;
  }
  else {
    uint64_t v18 = 0;
  }
  BOOL result = (v16 == 0) == (v18 == 0);
  if (v16)
  {
    if (v18) {
      return CFEqual(*(CFTypeRef *)(a1 + 24), v17) == 1;
    }
  }
  return result;
}

void sub_1006BAA88(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006BAB54(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1006BAC2C);
  __cxa_rethrow();
}

void sub_1006BAB7C(_Unwind_Exception *a1)
{
}

void sub_1006BAB94(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006BABCC(uint64_t a1)
{
}

uint64_t sub_1006BABE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006BAC2C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_1006BAC58(void **a1)
{
  uint64_t v1 = *a1;
  uint32_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!v1[1])
      {
LABEL_38:
        sub_10004D2C8(v5);
        goto LABEL_39;
      }
      uint64_t v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sInitializing Dedicated Bearer Controller", buf, 0x16u);
      }
      uint64_t v8 = *(void **)(v3 + 120);
      sub_10003E168(buf, (void *)(v3 + 8));
      uint64_t v9 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)buf) {
        uint64_t v10 = *(void *)buf + 64;
      }
      else {
        uint64_t v10 = 0;
      }
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v11 = v8 + 63;
        BOOL v13 = (uint64_t *)v8[63];
        unint64_t v12 = v8[64];
        if ((unint64_t)v13 < v12)
        {
          *BOOL v13 = v10;
          v13[1] = (uint64_t)v9;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_14:
          uint64_t v14 = v13 + 2;
LABEL_34:
          void *v11 = v14;
          if (v9)
          {
            std::__shared_weak_count::__release_weak(v9);
            sub_10004D2C8(v9);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v11 = v8 + 63;
        BOOL v13 = (uint64_t *)v8[63];
        unint64_t v12 = v8[64];
        if ((unint64_t)v13 < v12)
        {
          *BOOL v13 = v10;
          v13[1] = 0;
          goto LABEL_14;
        }
      }
      uint64_t v15 = (uint64_t *)v8[62];
      uint64_t v16 = ((char *)v13 - (char *)v15) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        sub_10006A748();
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19 >> 60) {
        sub_10006A7CC();
      }
      BOOL v20 = (char *)operator new(16 * v19);
      __int16 v21 = (uint64_t *)&v20[16 * v16];
      *__int16 v21 = v10;
      v21[1] = (uint64_t)v9;
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v15 = (uint64_t *)v8[62];
        BOOL v13 = (uint64_t *)v8[63];
      }
      uint64_t v22 = &v20[16 * v19];
      uint64_t v14 = v21 + 2;
      if (v13 == v15)
      {
        v8[62] = v21;
        v8[63] = v14;
        v8[64] = v22;
      }
      else
      {
        do
        {
          long long v23 = *((_OWORD *)v13 - 1);
          v13 -= 2;
          *((_OWORD *)v21 - 1) = v23;
          v21 -= 2;
          *BOOL v13 = 0;
          v13[1] = 0;
        }
        while (v13 != v15);
        uint64_t v15 = (uint64_t *)v8[62];
        uint64_t v24 = (uint64_t *)v8[63];
        v8[62] = v21;
        v8[63] = v14;
        v8[64] = v22;
        while (v24 != v15)
        {
          char v25 = (std::__shared_weak_count *)*(v24 - 1);
          if (v25) {
            std::__shared_weak_count::__release_weak(v25);
          }
          v24 -= 2;
        }
      }
      if (v15) {
        operator delete(v15);
      }
      goto LABEL_34;
    }
  }
LABEL_39:
  sub_100004A84((uint64_t *)&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_1006BAEDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v13)
  {
    std::__shared_weak_count::__release_weak(v13);
    sub_10004D2C8(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006BAF28(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v13 = v7;
          __int16 v14 = 2080;
          uint64_t v15 = " ";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sStarting Dedicared Bearer Controller", buf, 0x16u);
        }
        uint64_t v8 = *(void *)(v3 + 152);
        if (v8) {
          (*(void (**)(uint64_t, void))(*(void *)v8 + 336))(v8, *(unsigned __int8 *)(***(void ***)(v3 + 120) + 48));
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1006BB070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006BB094(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
          uint64_t v8 = asStringBool(*(unsigned char *)(v1 + 24));
          *(_DWORD *)std::string buf = 136315650;
          uint64_t v14 = v7;
          __int16 v15 = 2080;
          uint64_t v16 = " ";
          __int16 v17 = 2080;
          uint64_t v18 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sactivate : %s", buf, 0x20u);
        }
        uint64_t v9 = *(void *)(v3 + 152);
        if (v9) {
          (*(void (**)(uint64_t, void))(*(void *)v9 + 336))(v9, *(unsigned __int8 *)(***(void ***)(v3 + 120) + 48));
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1006BB220(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_1006BB1F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_1006BB220(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006BB220(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 32);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 32);
      if (v3) {
        dispatch_release(v3);
      }
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1006BB28C(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(void *)(v3 + 152);
        if (v6) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 16))(v6, 4);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1006BB328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006BB34C(void **a1)
{
  uint64_t v1 = *a1;
  BOOL v20 = a1;
  __int16 v21 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!v1[1])
      {
LABEL_20:
        sub_10004D2C8(v5);
        goto LABEL_21;
      }
      uint64_t v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sToken might not be actual, cleaning the wallet", buf, 0x16u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 72));
      uint64_t v9 = ServiceMap;
      if (v10 < 0)
      {
        uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
      if (v14)
      {
        uint64_t v16 = v14[3];
        __int16 v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_14:
          (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFString *, void, uint64_t))(*(void *)v16 + 32))(v16, ***(void ***)(v3 + 120) + 24, @"service-token", off_101B0ACC0, 0, 4);
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          uint64_t v18 = *(void *)(v3 + 152);
          if (v18)
          {
            memset(buf, 0, sizeof(buf));
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 280))(v18, buf);
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              operator delete(*(void **)buf);
            }
            (*(void (**)(void, uint64_t))(**(void **)(v3 + 152) + 16))(*(void *)(v3 + 152), 3);
          }
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      __int16 v15 = 0;
      char v17 = 1;
      goto LABEL_14;
    }
  }
LABEL_21:
  sub_100004A84((uint64_t *)&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_1006BB5D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  sub_10004D2C8(v12);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1006BB63C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v2 + 120));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v20 = 2080;
    __int16 v21 = " ";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sCEContext changed", buf, 0x16u);
  }
  uint64_t v5 = *(void *)(v2 + 152);
  if (!v5) {
LABEL_23:
  }
    operator delete();
  if (*((_DWORD *)v1 + 2) != 1 || !*(unsigned char *)(*(void *)(v2 + 120) + 456))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, 4);
    goto LABEL_23;
  }
  uint64_t v18 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 72));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
LABEL_15:
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, __CFString *, void, uint64_t))(*(void *)v14 + 24))(&v17, v14, ***(void ***)(v2 + 120) + 24, @"service-token", off_101B0ACC0, 0, 4);
      sub_1000C15D8(&v18, &v17);
      sub_1000577C4(&v17);
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      if (v18) {
        uint64_t v16 = sub_10008324C;
      }
      else {
        uint64_t v16 = 0;
      }
      if (!v16) {
        (*(void (**)(void, uint64_t))(**(void **)(v2 + 152) + 280))(*(void *)(v2 + 152), *(void *)(v2 + 120) + 432);
      }
      sub_100030068(&v18);
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  goto LABEL_15;
}

void sub_1006BB8F8(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100030068((const void **)va);
  operator delete();
}

void sub_1006BB96C()
{
}

void *sub_1006BB980(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F9B30;
  result[1] = v3;
  return result;
}

uint64_t sub_1006BB9C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F9B30;
  a2[1] = v2;
  return result;
}

void sub_1006BB9F4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1006BBAD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006BBB18()
{
}

void sub_1006BBB28()
{
}

void *sub_1006BBB3C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F9BB0;
  result[1] = v3;
  return result;
}

uint64_t sub_1006BBB84(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F9BB0;
  a2[1] = v2;
  return result;
}

void sub_1006BBBB0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1006BBC94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006BBCD4()
{
}

void sub_1006BBCE0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F9C30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006BBD00(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F9C30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_1006BBD54(const void **a1)
{
  uint64_t v2 = a1 + 3;
  sub_1000570E8(a1 + 6);
  sub_1000570E8(a1 + 5);
  sub_1000570E8(a1 + 4);

  return sub_1000570E8(v2);
}

uint64_t *sub_1006BBDA8(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  int v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  int v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      uint64_t v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      int v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    int v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  __int16 v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    uint64_t v12 = *a3;
    uint64_t v19 = 0;
    unsigned int v13 = (uint64_t *)operator new(0x48uLL);
    v18[0] = v13;
    v18[1] = v6;
    uint64_t v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      v13[6] = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
    }
    v13[7] = 0;
    v13[8] = 0;
    LOBYTE(v19) = 1;
    *unsigned int v13 = 0;
    v13[1] = 0;
    void v13[2] = (uint64_t)v8;
    std::mutex *v7 = v13;
    uint64_t v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      unsigned int v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    __int16 v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_1001FEBC4((uint64_t)v18);
  }
  return v11;
}

void sub_1006BBEF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1006BBF0C()
{
}

void *sub_1006BBF20(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F9C80;
  result[1] = v3;
  return result;
}

uint64_t sub_1006BBF68(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F9C80;
  a2[1] = v2;
  return result;
}

void sub_1006BBF94(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1006BC078(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006BC0B8()
{
}

void sub_1006BC0C8()
{
}

void *sub_1006BC0DC(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F9D00;
  result[1] = v3;
  return result;
}

uint64_t sub_1006BC124(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F9D00;
  a2[1] = v2;
  return result;
}

void sub_1006BC150(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1006BC234(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006BC274()
{
}

void sub_1006BC280(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006BC384(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(std::__shared_weak_count **)(*a1 + 16);
  if (!v2 || (v3 = *(void *)v1, (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
LABEL_91:
  }
    sub_1006BCD00(v1);
  uint64_t v5 = v4;
  if (!*(void *)(v1 + 8))
  {
LABEL_90:
    sub_10004D2C8(v5);
    goto LABEL_91;
  }
  int v6 = *(_DWORD *)(v1 + 24);
  uint64_t v8 = *(void *)(v1 + 32);
  int v7 = *(std::__shared_weak_count **)(v1 + 40);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198((const void **)&theDict, (const void **)(v1 + 48));
  sub_1000584C8(&v65, (const void **)(v1 + 56));
  __int16 v9 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if ((v6 - 1) > 2) {
      __int16 v11 = "RequestCanceled";
    }
    else {
      __int16 v11 = off_1019F9D70[v6 - 1];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v70 = (uint8_t *)v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sgetLinkCharacteristics: Event cause is %s", buf, 0x20u);
    __int16 v9 = *(NSObject **)(v3 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%srequest: ", buf, 0x16u);
  }
  *(void *)std::string buf = off_1019F9B30;
  *(void *)&uint8_t buf[8] = v3;
  long long v70 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v68 = 0;
  CFStringRef Value = CFDictionaryGetValue(theDict, @"service");
  if (Value)
  {
    CFGetTypeID(Value);
    CFStringGetTypeID();
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v68 = *(void *)&buf[16];
  uint64_t v14 = sub_100046F68(v3 + 168, __p);
  if (v6 != 3)
  {
LABEL_86:
    if (SHIBYTE(v68) < 0) {
      operator delete(__p[0]);
    }
    sub_1000577C4(&v65);
    sub_100057D78((const void **)&theDict);
    if (v7) {
      sub_10004D2C8(v7);
    }
    goto LABEL_90;
  }
  int v15 = *(_DWORD *)v8;
  if (*(int *)v8 > 6005)
  {
    if (v15 != 6006 && v15 != 6300) {
      goto LABEL_86;
    }
  }
  else if ((v15 - 6003) >= 2)
  {
    if (v15 != 6000) {
      goto LABEL_86;
    }
    uint64_t v63 = v14;
    CFDictionaryRef v16 = **(const __CFDictionary ***)(v8 + 8);
    char v17 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sresponse: ", buf, 0x16u);
    }
    *(void *)std::string buf = off_1019F9BB0;
    *(void *)&uint8_t buf[8] = v3;
    long long v70 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
    uint64_t v19 = (BOOL *)CFDictionaryGetValue(v16, @"qos-flow-allowed");
    __int16 v21 = v19;
    if (v19)
    {
      CFTypeID v22 = CFGetTypeID(v19);
      if (v22 == CFBooleanGetTypeID()) {
        long long v23 = v21;
      }
      else {
        long long v23 = 0;
      }
    }
    else
    {
      long long v23 = 0;
    }
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, v23, v20);
    if (buf[0])
    {
      __int16 v35 = (char *)operator new(0x38uLL);
      *((void *)v35 + 1) = 0;
      *((void *)v35 + 2) = 0;
      *(void *)__int16 v35 = off_1019F9C30;
      *(_OWORD *)(v35 + 24) = 0u;
      uint64_t v64 = (const void **)(v35 + 24);
      *(_OWORD *)(v35 + 40) = 0u;
      __int16 v37 = CFDictionaryGetValue(v16, @"max-ul-bitrate");
      std::string::size_type v38 = v37;
      if (v37)
      {
        CFTypeID v39 = CFGetTypeID(v37);
        if (v39 == CFNumberGetTypeID()) {
          long long v40 = v38;
        }
        else {
          long long v40 = 0;
        }
      }
      else
      {
        long long v40 = 0;
      }
      *(void *)std::string buf = v40;
      sub_1006B9DE4(v64, (CFTypeRef *)buf);
      int v41 = CFDictionaryGetValue(v16, @"max-dl-bitrate");
      std::string::size_type v42 = v41;
      if (v41)
      {
        CFTypeID v43 = CFGetTypeID(v41);
        if (v43 == CFNumberGetTypeID()) {
          std::string::size_type v44 = v42;
        }
        else {
          std::string::size_type v44 = 0;
        }
      }
      else
      {
        std::string::size_type v44 = 0;
      }
      *(void *)std::string buf = v44;
      sub_1006B9DE4((const void **)v35 + 4, (CFTypeRef *)buf);
      std::string::size_type v45 = CFDictionaryGetValue(v16, @"guaranteed-ul-bitrate");
      std::string::size_type v46 = v45;
      if (v45)
      {
        CFTypeID v47 = CFGetTypeID(v45);
        if (v47 == CFNumberGetTypeID()) {
          double v48 = v46;
        }
        else {
          double v48 = 0;
        }
      }
      else
      {
        double v48 = 0;
      }
      *(void *)std::string buf = v48;
      sub_1006B9DE4((const void **)v35 + 5, (CFTypeRef *)buf);
      std::string::size_type v49 = CFDictionaryGetValue(v16, @"guaranteed-dl-bitrate");
      std::string::size_type v50 = v49;
      if (v49)
      {
        CFTypeID v51 = CFGetTypeID(v49);
        if (v51 == CFNumberGetTypeID()) {
          int v52 = v50;
        }
        else {
          int v52 = 0;
        }
      }
      else
      {
        int v52 = 0;
      }
      *(void *)std::string buf = v52;
      sub_1006B9DE4((const void **)v35 + 6, (CFTypeRef *)buf);
    }
    else
    {
      uint64_t v64 = 0;
      __int16 v35 = 0;
    }
    if ((void **)(v3 + 176) == v63
      || (uint64_t v53 = (uint64_t)v63[7], (v64 != 0) ^ (v53 != 0))
      || v64 && !sub_1006BA914(v53, (uint64_t)v64))
    {
      int v54 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
        double v56 = __p;
        if (v68 < 0) {
          double v56 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v55;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        long long v70 = (uint8_t *)v56;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s%snew link characteristics for %s received", buf, 0x20u);
      }
      *(void *)std::string buf = __p;
      long long v57 = sub_1006BBDA8((uint64_t **)(v3 + 168), __p, (long long **)buf);
      if (v35) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v35 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v58 = (std::__shared_weak_count *)v57[8];
      v57[7] = (uint64_t)v64;
      v57[8] = (uint64_t)v35;
      if (v58) {
        sub_10004D2C8(v58);
      }
      long long v59 = *(std::__shared_weak_count **)(v3 + 112);
      if (v59)
      {
        uint64_t v60 = std::__shared_weak_count::lock(v59);
        if (v60)
        {
          char v61 = v60;
          uint64_t v62 = *(void *)(v3 + 104);
          if (v62) {
            (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v62 + 16))(v62, ***(void ***)(v3 + 120) + 24, __p);
          }
          sub_10004D2C8(v61);
        }
      }
    }
    if (!v35) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  uint64_t v24 = v14;
  char v25 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    uint32_t v27 = __p;
    if (v68 < 0) {
      uint32_t v27 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v26;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v70 = (uint8_t *)v27;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%sServer rejects the device. Disable service at least for service %s", buf, 0x20u);
  }
  if ((void **)(v3 + 176) != v24 && !v24[7]) {
    goto LABEL_86;
  }
  uint64_t v28 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    uint64_t v30 = __p;
    if (v68 < 0) {
      uint64_t v30 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v29;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v70 = (uint8_t *)v30;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%snew link characteristics for %s received", buf, 0x20u);
  }
  *(void *)std::string buf = __p;
  CFMutableDictionaryRef v31 = sub_1006BBDA8((uint64_t **)(v3 + 168), __p, (long long **)buf);
  CFTypeID v32 = (std::__shared_weak_count *)v31[8];
  v31[7] = 0;
  uint8_t v31[8] = 0;
  if (v32) {
    sub_10004D2C8(v32);
  }
  std::string::size_type v33 = *(std::__shared_weak_count **)(v3 + 112);
  if (!v33) {
    goto LABEL_86;
  }
  uint64_t v34 = std::__shared_weak_count::lock(v33);
  if (!v34) {
    goto LABEL_86;
  }
  __int16 v35 = (char *)v34;
  uint64_t v36 = *(void *)(v3 + 104);
  if (v36) {
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v36 + 16))(v36, ***(void ***)(v3 + 120) + 24, __p);
  }
LABEL_85:
  sub_10004D2C8((std::__shared_weak_count *)v35);
  goto LABEL_86;
}

void sub_1006BCC20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_10004D2C8(v29);
  if (v28) {
    sub_10004D2C8(v28);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a11);
  sub_100057D78(&a12);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_10004D2C8(v26);
  sub_1006BCD00(v25);
}

void sub_1006BCD00(uint64_t a1)
{
  sub_1000577C4((const void **)(a1 + 56));
  sub_100057D78((const void **)(a1 + 48));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void sub_1006BCD6C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006BCE70(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(std::__shared_weak_count **)(*a1 + 16);
  if (!v2 || (v3 = *(void *)v1, (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
LABEL_74:
  }
    sub_1006BCD00(v1);
  uint64_t v5 = v4;
  if (!*(void *)(v1 + 8))
  {
LABEL_73:
    sub_10004D2C8(v5);
    goto LABEL_74;
  }
  int v6 = *(_DWORD *)(v1 + 24);
  uint64_t v8 = *(void *)(v1 + 32);
  int v7 = *(std::__shared_weak_count **)(v1 + 40);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198((const void **)&theDict, (const void **)(v1 + 48));
  sub_1000584C8(&cf, (const void **)(v1 + 56));
  __int16 v9 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    if ((v6 - 1) > 2) {
      __int16 v11 = "RequestCanceled";
    }
    else {
      __int16 v11 = off_1019F9D70[v6 - 1];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    int v52 = (uint8_t *)v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnhancedSession: Event cause is %s", buf, 0x20u);
    __int16 v9 = *(NSObject **)(v3 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%srequest: ", buf, 0x16u);
  }
  *(void *)std::string buf = off_1019F9C80;
  *(void *)&uint8_t buf[8] = v3;
  int v52 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  CFStringRef Value = CFDictionaryGetValue(theDict, @"operation");
  uint64_t v14 = Value;
  if (Value)
  {
    CFTypeID v15 = CFGetTypeID(Value);
    if (v15 == CFStringGetTypeID()) {
      CFDictionaryRef v16 = v14;
    }
    else {
      CFDictionaryRef v16 = 0;
    }
  }
  else
  {
    CFDictionaryRef v16 = 0;
  }
  int v17 = CFEqual(@"enable", v16);
  v48[0] = 0;
  v48[1] = 0;
  uint64_t v49 = 0;
  uint64_t v18 = CFDictionaryGetValue(theDict, @"service");
  if (v18)
  {
    CFGetTypeID(v18);
    CFStringGetTypeID();
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)double v48 = *(_OWORD *)buf;
  uint64_t v49 = *(void *)&buf[16];
  v46[0] = 0;
  v46[1] = 0;
  uint64_t v47 = 0;
  CFTypeRef v44 = cf;
  if (cf)
  {
    CFRetain(cf);
    std::string __p = (void *)v44;
    if (v44) {
      CFRetain(v44);
    }
  }
  else
  {
    std::string __p = 0;
  }
  std::string::size_type v50 = 0;
  *(void *)std::string buf = 0;
  sub_100056248(buf, (CFTypeRef *)&__p);
  if (*(void *)buf) {
    uint64_t v19 = sub_1000810B8;
  }
  else {
    uint64_t v19 = 0;
  }
  if (v19) {
    sub_100083EB8(&v50, (const void **)buf);
  }
  sub_1000558F4((const void **)buf);
  std::string::size_type v45 = v50;
  std::string::size_type v50 = 0;
  sub_1000558F4(&v50);
  sub_1000577C4((const void **)&__p);
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)std::string::size_type v46 = *(_OWORD *)buf;
  uint64_t v47 = *(void *)&buf[16];
  sub_1000558F4(&v45);
  sub_1000577C4(&v44);
  std::string __p = 0;
  long long v43 = 0uLL;
  if (v6 != 3) {
    goto LABEL_67;
  }
  int v20 = *(_DWORD *)v8;
  if (*(int *)v8 > 6005)
  {
    if (v20 != 6006)
    {
      if (v20 == 6201)
      {
        uint8_t v34 = 0;
LABEL_57:
        __int16 v35 = *(std::__shared_weak_count **)(v3 + 112);
        if (v35)
        {
          uint64_t v36 = std::__shared_weak_count::lock(v35);
          if (v36)
          {
            __int16 v37 = v36;
            std::string::size_type v38 = *(void **)(v3 + 104);
            if (v38)
            {
              if (v17 == 1) {
                CFTypeID v39 = (void (**)(void))(*v38 + 24);
              }
              else {
                CFTypeID v39 = (void (**)(void))(*v38 + 32);
              }
              (*v39)();
            }
            sub_10004D2C8(v37);
            uint8_t v34 = HIBYTE(v43);
          }
        }
        if ((v34 & 0x80) != 0) {
          operator delete(__p);
        }
        goto LABEL_67;
      }
      if (v20 != 6300)
      {
LABEL_67:
        if (SHIBYTE(v47) < 0) {
          operator delete(v46[0]);
        }
        if (SHIBYTE(v49) < 0) {
          operator delete(v48[0]);
        }
        sub_1000577C4(&cf);
        sub_100057D78((const void **)&theDict);
        if (v7) {
          sub_10004D2C8(v7);
        }
        goto LABEL_73;
      }
    }
  }
  else if ((v20 - 6003) >= 2)
  {
    if (v20 == 6000)
    {
      CFDictionaryRef v21 = **(const __CFDictionary ***)(v8 + 8);
      CFTypeID v22 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sresponse: ", buf, 0x16u);
      }
      *(void *)std::string buf = off_1019F9D00;
      *(void *)&uint8_t buf[8] = v3;
      int v52 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      uint64_t v24 = CFDictionaryGetValue(v21, @"session-id");
      if (v24)
      {
        CFGetTypeID(v24);
        CFStringGetTypeID();
      }
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      std::string __p = *(void **)buf;
      *(void *)&long long v43 = *(void *)&buf[8];
      *(void *)((char *)&v43 + 7) = *(void *)&buf[15];
      uint8_t v34 = buf[23];
      HIBYTE(v43) = buf[23];
      goto LABEL_57;
    }
    goto LABEL_67;
  }
  uint64_t v25 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
    uint32_t v27 = "disable";
    if (v17 == 1) {
      uint32_t v27 = "enable";
    }
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v28 = v48;
    *(void *)&uint8_t buf[4] = v26;
    if (v49 < 0) {
      uint64_t v28 = (void **)v48[0];
    }
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    int v52 = (uint8_t *)v27;
    __int16 v53 = 2080;
    int v54 = v28;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%sServer rejects the request to %s for service %s", buf, 0x2Au);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v3 + 112);
  if (v29)
  {
    uint64_t v30 = std::__shared_weak_count::lock(v29);
    if (v30)
    {
      CFMutableDictionaryRef v31 = v30;
      uint64_t v32 = *(void *)(v3 + 104);
      if (v32)
      {
        uint64_t v33 = ***(void ***)(v3 + 120) + 24;
        memset(buf, 0, sizeof(buf));
        if (v17 == 1) {
          (*(void (**)(uint64_t, uint64_t, void **, uint8_t *, void))(*(void *)v32 + 24))(v32, v33, v46, buf, 0);
        }
        else {
          (*(void (**)(uint64_t, uint64_t, void **, uint8_t *, void))(*(void *)v32 + 32))(v32, v33, v46, buf, 0);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
      sub_10004D2C8(v31);
    }
  }
  goto LABEL_67;
}

void sub_1006BD5FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  sub_10004D2C8(v45);
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_1000577C4(&a10);
  sub_100057D78(&a11);
  if (v44) {
    sub_10004D2C8(v44);
  }
  sub_10004D2C8(v43);
  sub_1006BCD00(v42);
}

void sub_1006BD74C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006BD850(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(std::__shared_weak_count **)(*a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        int v6 = *(_DWORD *)(v1 + 24);
        uint64_t v8 = *(int **)(v1 + 32);
        int v7 = *(std::__shared_weak_count **)(v1 + 40);
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&v13, (const void **)(v1 + 48));
        sub_1000584C8(&v12, (const void **)(v1 + 56));
        if (v6 == 3)
        {
          __int16 v9 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
            __int16 v11 = sub_100FB56F4(*v8);
            *(_DWORD *)std::string buf = 136315650;
            uint64_t v15 = v10;
            __int16 v16 = 2080;
            int v17 = " ";
            __int16 v18 = 2080;
            uint64_t v19 = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________   Process Authentication response with status: %s", buf, 0x20u);
          }
        }
        sub_1000577C4(&v12);
        sub_100057D78(&v13);
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1006BCD00(v1);
}

void sub_1006BD9CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a9);
  sub_100057D78(&a10);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v11);
  sub_1006BCD00(v10);
}

void sub_1006BDA0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006BDB10(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(std::__shared_weak_count **)(*a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        int v6 = *(std::__shared_weak_count **)(v1 + 40);
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&v10, (const void **)(v1 + 48));
        sub_1000584C8(&v9, (const void **)(v1 + 56));
        int v7 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 120));
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v12 = v8;
          __int16 v13 = 2080;
          uint64_t v14 = " ";
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "#E %s%sprocessActionResponse<ActionType::postAuthChallenge> SHOULD NEVER BE CALLED. Result reported via getAuthentication", buf, 0x16u);
        }
        sub_1000577C4(&v9);
        sub_100057D78(&v10);
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1006BCD00(v1);
}

void sub_1006BDC68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a9);
  sub_100057D78(&a10);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v11);
  sub_1006BCD00(v10);
}

void *sub_1006BDCA8(uint64_t a1)
{
  *(void *)a1 = off_1019F9D98;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000346F8(a1 + 128, *(void **)(a1 + 136));
  sub_1006C1110(*(void **)(a1 + 104));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10012577C((const void **)(a1 + 64));

  return sub_1002B4928((void *)a1);
}

void sub_1006BDD3C(uint64_t a1)
{
  sub_1006BDCA8(a1);

  operator delete();
}

uint64_t sub_1006BDD74(uint64_t a1, uint64_t *a2)
{
  if (!*(unsigned char *)(a1 + 123))
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)a2 + 32)) {
        uint64_t v5 = " with restricted access";
      }
      else {
        uint64_t v5 = "";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint32_t v27 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting up environment%s", buf, 0xCu);
    }
    *(unsigned char *)(a1 + 123) = 1;
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 160);
    *(void *)(a1 + 152) = v7;
    *(void *)(a1 + 160) = v6;
    if (v8) {
      sub_10004D2C8(v8);
    }
    uint64_t v10 = (char *)a2[2];
    uint64_t v9 = a2[3];
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    __int16 v11 = *(std::__shared_weak_count **)(a1 + 88);
    *(void *)(a1 + 80) = v10;
    *(void *)(a1 + 88) = v9;
    if (v11)
    {
      sub_10004D2C8(v11);
      uint64_t v10 = *(char **)(a1 + 80);
    }
    *(unsigned char *)(a1 + 184) = *((unsigned char *)a2 + 32);
    if (!v10)
    {
      __TUAssertTrigger();
      uint64_t v10 = *(char **)(a1 + 80);
    }
    if (*v10 == 2 || !*((void *)v10 + 3) || *((void *)v10 + 4) == *((void *)v10 + 5) || !*((void *)v10 + 7))
    {
      __TUAssertTrigger();
      uint64_t v10 = *(char **)(a1 + 80);
    }
    uint64_t v12 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v13 = *v10;
      if (v13 > 2) {
        uint64_t v14 = "???";
      }
      else {
        uint64_t v14 = off_1019F9DE0[v13];
      }
      *(_DWORD *)std::string buf = 136315138;
      uint32_t v27 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I SPSBucketId: %s", buf, 0xCu);
      uint64_t v10 = *(char **)(a1 + 80);
    }
    uint64_t v15 = (char *)*((void *)v10 + 1);
    if (v15 != v10 + 16)
    {
      do
      {
        __int16 v16 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v17 = v15[32];
          __int16 v18 = "???";
          if (v17 <= 2) {
            __int16 v18 = off_1019F9DE0[v17];
          }
          uint64_t v19 = v15 + 40;
          uint64_t v20 = v15[63];
          BOOL v21 = (v20 & 0x80u) != 0;
          if ((v20 & 0x80u) != 0) {
            uint64_t v20 = *((void *)v15 + 6);
          }
          if (v21) {
            uint64_t v19 = (const char *)*((void *)v15 + 5);
          }
          if (!v20) {
            uint64_t v19 = "<invalid>";
          }
          *(_DWORD *)std::string buf = 136315394;
          uint32_t v27 = v18;
          __int16 v28 = 2082;
          uint64_t v29 = v19;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [SimConfigId: %s, PersonalityId: %{public}s]", buf, 0x16u);
        }
        CFTypeID v22 = (char *)*((void *)v15 + 1);
        if (v22)
        {
          do
          {
            uint64_t v23 = v22;
            CFTypeID v22 = *(char **)v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v23 = (char *)*((void *)v15 + 2);
            BOOL v24 = *(void *)v23 == (void)v15;
            uint64_t v15 = v23;
          }
          while (!v24);
        }
        uint64_t v15 = v23;
      }
      while (v23 != v10 + 16);
    }
    sub_1006BE07C(a1);
  }
  return 1;
}

void sub_1006BE07C(uint64_t a1)
{
  long long v72 = 0;
  uint64_t v73 = 0;
  uint64_t v71 = &v72;
  uint64_t v2 = *(void **)(a1 + 152);
  if (!v2 || (v5 = (unsigned __int8 *)*v2, v3 = (unsigned __int8 *)(v2 + 1), uint64_t v4 = v5, v5 == v3))
  {
    uint64_t v16 = 0;
  }
  else
  {
    do
    {
      unsigned int v6 = sub_1006BE808(a1, v4 + 40);
      if (v6 != 2)
      {
        char v7 = v6;
        uint64_t v8 = &v72;
        uint64_t v9 = &v72;
        if (v72)
        {
          uint64_t v10 = v72;
          while (1)
          {
            while (1)
            {
              uint64_t v9 = (uint64_t **)v10;
              unsigned int v11 = *((unsigned __int8 *)v10 + 25);
              if (v11 <= v6) {
                break;
              }
              uint64_t v10 = *v9;
              uint64_t v8 = v9;
              if (!*v9) {
                goto LABEL_12;
              }
            }
            if (v11 >= v6) {
              break;
            }
            uint64_t v10 = v9[1];
            if (!v10)
            {
              uint64_t v8 = v9 + 1;
              goto LABEL_12;
            }
          }
        }
        else
        {
LABEL_12:
          uint64_t v12 = operator new(0x20uLL);
          v12[25] = v7;
          *(void *)uint64_t v12 = 0;
          *((void *)v12 + 1) = 0;
          *((void *)v12 + 2) = v9;
          *uint64_t v8 = (uint64_t *)v12;
          if (*v71)
          {
            uint64_t v71 = (uint64_t **)*v71;
            uint64_t v12 = *v8;
          }
          sub_100046C90(v72, (uint64_t *)v12);
          ++v73;
        }
      }
      unint64_t v13 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          unint64_t v13 = *(unsigned __int8 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v15 = *(void *)v14 == (void)v4;
          uint64_t v4 = v14;
        }
        while (!v15);
      }
      uint64_t v4 = v14;
    }
    while (v14 != v3);
    uint64_t v16 = v73;
  }
  unint64_t v17 = (uint64_t ***)(a1 + 128);
  uint64_t v18 = *(void *)(a1 + 144);
  if (v16 == v18)
  {
    uint64_t v19 = v71;
    if (v71 == &v72) {
      goto LABEL_131;
    }
    uint64_t v20 = *v17;
    while (*((unsigned __int8 *)v19 + 25) == *((unsigned __int8 *)v20 + 25))
    {
      BOOL v21 = v19[1];
      CFTypeID v22 = v19;
      if (v21)
      {
        do
        {
          uint64_t v19 = (uint64_t **)v21;
          BOOL v21 = (uint64_t *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v19 = (uint64_t **)v22[2];
          BOOL v15 = *v19 == (uint64_t *)v22;
          CFTypeID v22 = v19;
        }
        while (!v15);
      }
      uint64_t v23 = v20[1];
      if (v23)
      {
        do
        {
          BOOL v24 = (uint64_t **)v23;
          uint64_t v23 = (uint64_t *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          BOOL v24 = (uint64_t **)v20[2];
          BOOL v15 = *v24 == (uint64_t *)v20;
          uint64_t v20 = v24;
        }
        while (!v15);
      }
      uint64_t v20 = v24;
      if (v19 == &v72) {
        goto LABEL_131;
      }
    }
  }
  if (v17 != &v71)
  {
    uint64_t v25 = v71;
    if (v18)
    {
      uint32_t v27 = (uint64_t **)(a1 + 136);
      uint64_t v26 = *(void *)(a1 + 136);
      uint64_t v28 = *(void *)(a1 + 128);
      *(void *)(a1 + 128) = a1 + 136;
      *(void *)(v26 + 16) = 0;
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
      if (*(void *)(v28 + 8)) {
        uint64_t v29 = *(void *)(v28 + 8);
      }
      else {
        uint64_t v29 = v28;
      }
      if (v29)
      {
        uint64_t v30 = sub_1000EA590(v29);
        if (v25 == &v72)
        {
          uint64_t v32 = (void *)v29;
          uint64_t v25 = &v72;
        }
        else
        {
          CFMutableDictionaryRef v31 = v25;
          do
          {
            uint64_t v32 = v30;
            unsigned int v33 = *((unsigned __int8 *)v31 + 25);
            *(unsigned char *)(v29 + 25) = v33;
            uint8_t v34 = *v27;
            __int16 v35 = (uint64_t **)(a1 + 136);
            uint64_t v36 = (uint64_t **)(a1 + 136);
            if (*v27)
            {
              do
              {
                while (1)
                {
                  __int16 v35 = (uint64_t **)v34;
                  if (v33 >= *((unsigned __int8 *)v34 + 25)) {
                    break;
                  }
                  uint8_t v34 = (uint64_t *)*v34;
                  uint64_t v36 = v35;
                  if (!*v35) {
                    goto LABEL_53;
                  }
                }
                uint8_t v34 = (uint64_t *)v34[1];
              }
              while (v34);
              uint64_t v36 = v35 + 1;
            }
LABEL_53:
            sub_100046C38((uint64_t **)(a1 + 128), (uint64_t)v35, v36, (uint64_t *)v29);
            if (v30) {
              uint64_t v30 = sub_1000EA590((uint64_t)v30);
            }
            else {
              uint64_t v30 = 0;
            }
            __int16 v37 = v31[1];
            if (v37)
            {
              do
              {
                uint64_t v25 = (uint64_t **)v37;
                __int16 v37 = (uint64_t *)*v37;
              }
              while (v37);
            }
            else
            {
              do
              {
                uint64_t v25 = (uint64_t **)v31[2];
                BOOL v15 = *v25 == (uint64_t *)v31;
                CFMutableDictionaryRef v31 = v25;
              }
              while (!v15);
            }
            if (!v32) {
              break;
            }
            uint64_t v29 = (uint64_t)v32;
            CFMutableDictionaryRef v31 = v25;
          }
          while (v25 != &v72);
        }
        sub_1000346F8(a1 + 128, v32);
        if (!v30) {
          goto LABEL_71;
        }
        for (uint64_t i = (void *)v30[2]; i; uint64_t i = (void *)i[2])
          uint64_t v30 = i;
        uint64_t v38 = a1 + 128;
        CFTypeID v39 = v30;
      }
      else
      {
        uint64_t v38 = a1 + 128;
        CFTypeID v39 = 0;
      }
      sub_1000346F8(v38, v39);
    }
LABEL_71:
    if (v25 != &v72)
    {
      int v41 = (uint64_t **)(a1 + 136);
      do
      {
        unsigned int v42 = *((unsigned __int8 *)v25 + 25);
        long long v43 = (uint64_t *)operator new(0x20uLL);
        *((unsigned char *)v43 + 25) = v42;
        CFTypeRef v44 = *v41;
        std::string::size_type v45 = (uint64_t **)(a1 + 136);
        std::string::size_type v46 = (uint64_t **)(a1 + 136);
        if (*v41)
        {
          do
          {
            while (1)
            {
              std::string::size_type v45 = (uint64_t **)v44;
              if (*((unsigned __int8 *)v44 + 25) <= v42) {
                break;
              }
              CFTypeRef v44 = (uint64_t *)*v44;
              std::string::size_type v46 = v45;
              if (!*v45) {
                goto LABEL_79;
              }
            }
            CFTypeRef v44 = (uint64_t *)v44[1];
          }
          while (v44);
          std::string::size_type v46 = v45 + 1;
        }
LABEL_79:
        sub_100046C38((uint64_t **)(a1 + 128), (uint64_t)v45, v46, v43);
        uint64_t v47 = v25[1];
        if (v47)
        {
          do
          {
            double v48 = (uint64_t **)v47;
            uint64_t v47 = (uint64_t *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            double v48 = (uint64_t **)v25[2];
            BOOL v15 = *v48 == (uint64_t *)v25;
            uint64_t v25 = v48;
          }
          while (!v15);
        }
        uint64_t v25 = v48;
      }
      while (v48 != &v72);
    }
  }
  uint64_t v49 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v50 = **(char **)(a1 + 80);
    if (v50 > 2) {
      CFTypeID v51 = "???";
    }
    else {
      CFTypeID v51 = off_1019F9DE0[v50];
    }
    *(_DWORD *)std::string buf = 136315138;
    long long v75 = v51;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Selected SPSBucketId: %s", buf, 0xCu);
  }
  int v52 = *(void **)(a1 + 128);
  __int16 v53 = (void *)(a1 + 136);
  if (v52 != (void *)(a1 + 136))
  {
    do
    {
      int v54 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v55 = *((char *)v52 + 25);
        double v56 = "???";
        if (v55 <= 2) {
          double v56 = off_1019F9DE0[v55];
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v75 = v56;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I [Valid] SimConfigId: %s", buf, 0xCu);
      }
      long long v57 = (void *)v52[1];
      if (v57)
      {
        do
        {
          uint64_t v58 = v57;
          long long v57 = (void *)*v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          uint64_t v58 = (void *)v52[2];
          BOOL v15 = *v58 == (void)v52;
          int v52 = v58;
        }
        while (!v15);
      }
      int v52 = v58;
    }
    while (v58 != v53);
  }
  long long v59 = *(unsigned __int8 **)(a1 + 96);
  if (v59 != (unsigned __int8 *)(a1 + 104))
  {
    do
    {
      unsigned int v62 = sub_1006BE808(a1, v59 + 32);
      uint64_t v63 = *(void *)(a1 + 136);
      if (!v63) {
        goto LABEL_120;
      }
      uint64_t v64 = a1 + 136;
      do
      {
        unsigned int v65 = *(unsigned __int8 *)(v63 + 25);
        BOOL v66 = v65 >= v62;
        if (v65 >= v62) {
          uint64_t v67 = (uint64_t *)v63;
        }
        else {
          uint64_t v67 = (uint64_t *)(v63 + 8);
        }
        if (v66) {
          uint64_t v64 = v63;
        }
        uint64_t v63 = *v67;
      }
      while (*v67);
      if ((void *)v64 != v53 && v62 >= *(unsigned __int8 *)(v64 + 25))
      {
        uint64_t v60 = (unsigned __int8 *)*((void *)v59 + 1);
        if (v60)
        {
          do
          {
            char v61 = v60;
            uint64_t v60 = *(unsigned __int8 **)v60;
          }
          while (v60);
        }
        else
        {
          do
          {
            char v61 = (unsigned __int8 *)*((void *)v59 + 2);
            BOOL v15 = *(void *)v61 == (void)v59;
            long long v59 = v61;
          }
          while (!v15);
        }
      }
      else
      {
LABEL_120:
        uint64_t v68 = (unsigned __int8 *)*((void *)v59 + 1);
        long long v69 = v59;
        if (v68)
        {
          do
          {
            char v61 = v68;
            uint64_t v68 = *(unsigned __int8 **)v68;
          }
          while (v68);
        }
        else
        {
          do
          {
            char v61 = (unsigned __int8 *)*((void *)v69 + 2);
            BOOL v15 = *(void *)v61 == (void)v69;
            long long v69 = v61;
          }
          while (!v15);
        }
        if (*(unsigned __int8 **)(a1 + 96) == v59) {
          *(void *)(a1 + 96) = v61;
        }
        long long v70 = *(uint64_t **)(a1 + 104);
        --*(void *)(a1 + 112);
        sub_10005EE6C(v70, (uint64_t *)v59);
        sub_1006C1164((uint64_t)(v59 + 32));
        operator delete(v59);
      }
      long long v59 = v61;
    }
    while (v61 != (unsigned __int8 *)(a1 + 104));
  }
  if (!*(unsigned char *)(a1 + 184)) {
    sub_1006BE898(a1, 1);
  }
LABEL_131:
  sub_1000346F8((uint64_t)&v71, v72);
}

void sub_1006BE6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000346F8((uint64_t)va, v4);
  _Unwind_Resume(a1);
}

void sub_1006BE6F0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 184)) {
      uint64_t v3 = " for restricted access environment";
    }
    else {
      uint64_t v3 = "";
    }
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Teardown requested%s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t sub_1006BE7A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 123);
}

void sub_1006BE7B0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 160);
  *(void *)(a1 + 152) = v4;
  *(void *)(a1 + 160) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }

  sub_1006BE07C(a1);
}

uint64_t sub_1006BE808(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(unsigned __int8 **)(v2 + 8);
  uint64_t v4 = (unsigned __int8 *)(v2 + 16);
  if (v3 == (unsigned __int8 *)(v2 + 16)) {
    return 2;
  }
  while (!sub_10001D294(v3 + 40, a2))
  {
    unsigned int v6 = (unsigned __int8 *)*((void *)v3 + 1);
    if (v6)
    {
      do
      {
        char v7 = v6;
        unsigned int v6 = *(unsigned __int8 **)v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        char v7 = (unsigned __int8 *)*((void *)v3 + 2);
        BOOL v8 = *(void *)v7 == (void)v3;
        uint64_t v3 = v7;
      }
      while (!v8);
    }
    uint64_t v3 = v7;
    if (v7 == v4) {
      return 2;
    }
  }
  return v3[32];
}

void sub_1006BE898(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 120) != a2)
  {
    *(unsigned char *)(a1 + 120) = a2;
    if (a2)
    {
      if (*(unsigned char *)(a1 + 73)) {
        *(unsigned char *)(a1 + 73) = 0;
      }
      *(unsigned char *)(a1 + 121) = 0;
      sub_1006BEC64(a1, 0);
      uint64_t v3 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Resetting token to: <none>; Marking CarrierPigeonStartMessage not acked. Reason: New start due",
          v4,
          2u);
      }
    }
  }
}

void *sub_1006BE92C@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result[10];
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v5 = v4 + 16;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = v5;
  do
  {
    unsigned int v9 = *(unsigned __int8 *)(v6 + 32);
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      unsigned int v11 = (uint64_t *)v6;
    }
    else {
      unsigned int v11 = (uint64_t *)(v6 + 8);
    }
    if (v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 != v5 && *(unsigned __int8 *)(v8 + 32) <= a2)
  {
    if (*(char *)(v8 + 63) < 0)
    {
      BOOL result = sub_10004FC84((unsigned char *)a3, *(void **)(v8 + 40), *(void *)(v8 + 48));
    }
    else
    {
      long long v13 = *(_OWORD *)(v8 + 40);
      *(void *)(a3 + 16) = *(void *)(v8 + 56);
      *(_OWORD *)a3 = v13;
    }
    char v12 = 1;
  }
  else
  {
LABEL_12:
    char v12 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 24) = v12;
  return result;
}

uint64_t sub_1006BE9C8(uint64_t a1, int a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v6 = 0u;
  sub_10110D1DC((void **)(a1 + 152), a2, (uint64_t)__p);
  if (!BYTE8(v6)) {
    return 2;
  }
  uint64_t v3 = sub_1006BE808(a1, (unsigned __int8 *)__p);
  if (BYTE8(v6) && SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

uint64_t sub_1006BEA40(uint64_t a1, unsigned int a2)
{
  sub_1006BE92C((void *)a1, a2, (uint64_t)__p);
  if (!v7) {
    return 0;
  }
  uint64_t v3 = sub_10110D2A0((void **)(a1 + 152), (unsigned __int8 *)__p);
  if (v7 && v6 < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

uint64_t sub_1006BEAAC(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 121)) {
    return 0;
  }
  sub_10110D1DC((void **)(a1 + 152), a2, (uint64_t)__p);
  if (!v14) {
    return 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 176);
  if (v3 && (uint64_t v4 = std::__shared_weak_count::lock(v3)) != 0 && (v5 = *(void *)(a1 + 168), sub_10004D2C8(v4), v5))
  {
    uint64_t v6 = 0;
  }
  else
  {
    char v7 = sub_100046F68(a1 + 96, __p);
    if ((void **)(a1 + 104) == v7)
    {
      uint64_t v6 = 1;
    }
    else
    {
      unsigned int v8 = *((unsigned __int8 *)v7 + 56);
      BOOL v9 = v8 > 5;
      unsigned int v10 = (0x11u >> v8) & 1;
      if (v9) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = v10;
      }
    }
  }
  if (v14 && v13 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_1006BEB70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006BEB94@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t result = (uint64_t)sub_1006C11CC(a2, a1 + 128);
  uint64_t v5 = *(unsigned __int8 **)(a1 + 96);
  if (v5 != (unsigned __int8 *)(a1 + 104))
  {
    do
    {
      if (v5[56] == 5)
      {
        unsigned __int8 v9 = sub_1006BE808(a1, v5 + 32);
        uint64_t result = sub_1006C14E4((uint64_t)a2, &v9);
      }
      uint64_t v6 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          char v7 = v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          char v7 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != (unsigned __int8 *)(a1 + 104));
  }
  return result;
}

void sub_1006BEC4C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1006BEC64(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 122) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "false";
      if (a2) {
        uint64_t v5 = "true";
      }
      int v6 = 136315138;
      char v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Is SatSmsStartMessage due changed to: %s", (uint8_t *)&v6, 0xCu);
    }
    *(unsigned char *)(a1 + 122) = a2;
  }
}

void sub_1006BED34(uint64_t a1, const void **a2, unsigned __int8 a3)
{
  unsigned __int8 v11 = a3;
  v10[0] = a1;
  v10[1] = (uint64_t)a2;
  void v10[2] = (uint64_t)&v11;
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v3 = "New start is pending...";
  }
  else
  {
    uint64_t v4 = *a2;
    if (v4) {
      uint64_t v5 = sub_100136254;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5 && ((char v7 = *(const void **)(a1 + 64)) != 0 ? (v8 = sub_100136254) : (v8 = 0), v8 && CFEqual(v7, v4)))
    {
      if (!*(unsigned char *)(a1 + 73) || *(unsigned __int8 *)(a1 + 72) != v11)
      {
        *(_WORD *)(a1 + 72) = v11 | 0x100;
        uint64_t v3 = "New token";
        int v9 = 1;
        goto LABEL_17;
      }
      uint64_t v3 = "Duplicate";
    }
    else
    {
      uint64_t v3 = "LLC ID mismatch";
    }
  }
  int v9 = 0;
LABEL_17:
  sub_1006BEE1C(v10, v9, (uint64_t)v3);
}

void sub_1006BEE1C(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  char v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)a1[1], v16);
    int v8 = v17;
    int v9 = (void **)v16[0];
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), __p);
    unsigned __int8 v11 = v16;
    if (v8 < 0) {
      unsigned __int8 v11 = v9;
    }
    char v12 = "[Ignored]";
    if (a2) {
      char v12 = "[Token updated]";
    }
    *(_DWORD *)std::string buf = 136316162;
    uint64_t v19 = v12;
    __int16 v20 = 2082;
    if (v15 >= 0) {
      char v13 = __p;
    }
    else {
      char v13 = (void **)__p[0];
    }
    BOOL v21 = v11;
    __int16 v22 = 1024;
    int v23 = v10;
    __int16 v24 = 2082;
    uint64_t v25 = v13;
    __int16 v26 = 2080;
    uint64_t v27 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage][Attempted]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s], %s", buf, 0x30u);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }
}

void sub_1006BEF88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006BEFAC(uint64_t a1, const void **a2, int a3)
{
  char v7 = a3;
  v6[0] = a1;
  v6[1] = (uint64_t)a2;
  v6[2] = (uint64_t)&v7;
  if (sub_1006BF030(a1, a2, a3))
  {
    if (!*(unsigned char *)(a1 + 121))
    {
      *(unsigned char *)(a1 + 121) = 1;
      uint64_t v4 = "Updated environment";
      int v5 = 1;
      goto LABEL_7;
    }
    uint64_t v4 = "Nothing changed for this environment";
  }
  else
  {
    uint64_t v4 = "This LLC or token is not valid anymore";
  }
  int v5 = 0;
LABEL_7:
  sub_1006BF0B8(v6, v5, (uint64_t)v4);
}

uint64_t sub_1006BF030(uint64_t a1, const void **a2, int a3)
{
  uint64_t v3 = *a2;
  if (v3) {
    uint64_t v4 = sub_100136254;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4) {
    return 0;
  }
  uint64_t v6 = *(const void **)(a1 + 64);
  if (!(v6 ? sub_100136254 : 0)) {
    return 0;
  }
  uint64_t result = CFEqual(v6, v3);
  if (result) {
    return *(unsigned char *)(a1 + 73) && *(unsigned __int8 *)(a1 + 72) == a3;
  }
  return result;
}

void sub_1006BF0B8(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  char v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v8 = "[Accepted]";
    }
    else {
      int v8 = "[Ignored]";
    }
    int v9 = v18;
    sub_100BC8FAC((CFUUIDRef *)a1[1], v18);
    if (v19 < 0) {
      int v9 = (void **)v18[0];
    }
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), v16);
    int v11 = v17;
    char v12 = (void **)v16[0];
    sub_10026CCB8((unsigned __int8 *)(v6 + 72), &__p);
    char v13 = v16;
    if (v11 < 0) {
      char v13 = v12;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136316418;
    BOOL v21 = v8;
    __int16 v22 = 2082;
    int v23 = v9;
    __int16 v24 = 1024;
    int v25 = v10;
    __int16 v26 = 2082;
    uint64_t v27 = v13;
    __int16 v28 = 2082;
    uint64_t v29 = p_p;
    __int16 v30 = 2080;
    uint64_t v31 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage][Acked]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s, token: %{public}s], %s", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    if (v19 < 0) {
      operator delete(v18[0]);
    }
  }
}

void sub_1006BF25C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006BF298(uint64_t a1, const void **a2, int a3, unsigned __int8 a4, unsigned __int8 a5)
{
  unsigned __int8 v22 = a3;
  v21[0] = a1;
  v21[1] = (uint64_t)a2;
  void v21[2] = (uint64_t)&v22;
  uint64_t v9 = sub_1006BF030(a1, a2, a3);
  if (v9)
  {
    sub_1006BF3E8(v21, 1, (uint64_t)"Processing...");
    v16[0] = a4;
    LOBYTE(__p) = 0;
    char v19 = 0;
    v20[0] = 0;
    v20[72] = 0;
    sub_1006BF5C8(a1, a2, v22, 0, v16);
    sub_100273EC4((uint64_t)v20);
    if (v19 && __p)
    {
      uint64_t v18 = __p;
      operator delete(__p);
    }
    v11[0] = a5;
    LOBYTE(v12) = 0;
    char v14 = 0;
    v15[0] = 0;
    v15[72] = 0;
    sub_1006BF5C8(a1, a2, v22, 1u, v11);
    sub_100273EC4((uint64_t)v15);
    if (v14 && v12)
    {
      char v13 = v12;
      operator delete(v12);
    }
  }
  else
  {
    sub_1006BF3E8(v21, 0, (uint64_t)"This LLC or token is not valid anymore");
  }
  return v9;
}

void sub_1006BF3C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1006BF3E8(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  char v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v8 = "[Accepted]";
    }
    else {
      int v8 = "[Ignored]";
    }
    uint64_t v9 = v18;
    sub_100BC8FAC((CFUUIDRef *)a1[1], v18);
    if (v19 < 0) {
      uint64_t v9 = (void **)v18[0];
    }
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), v16);
    int v11 = v17;
    char v12 = (void **)v16[0];
    sub_10026CCB8((unsigned __int8 *)(v6 + 72), &__p);
    char v13 = v16;
    if (v11 < 0) {
      char v13 = v12;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136316418;
    BOOL v21 = v8;
    __int16 v22 = 2082;
    int v23 = v9;
    __int16 v24 = 1024;
    int v25 = v10;
    __int16 v26 = 2082;
    uint64_t v27 = v13;
    __int16 v28 = 2082;
    uint64_t v29 = p_p;
    __int16 v30 = 2080;
    uint64_t v31 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonSummaryMessage]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s, token: %{public}s], %s", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    if (v19 < 0) {
      operator delete(v18[0]);
    }
  }
}

void sub_1006BF58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006BF5C8(uint64_t a1, const void **a2, int a3, unsigned __int8 a4, unsigned __int8 *a5)
{
  char v13 = a3;
  unsigned __int8 v12 = a4;
  v11[0] = a1;
  v11[1] = (uint64_t)a2;
  _OWORD v11[2] = (uint64_t)&v13;
  v11[3] = (uint64_t)&v12;
  v11[4] = (uint64_t)a5;
  if (sub_1006BF030(a1, a2, a3))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v10 = 0u;
    sub_1006BE92C((void *)a1, v12, (uint64_t)__p);
    if (BYTE8(v10))
    {
      sub_1006BFD18(v11, 1, (uint64_t)"Updating auth context");
      char v14 = __p;
      char v7 = sub_1006C1560((uint64_t **)(a1 + 96), __p, (uint64_t)&unk_10144E20E, (long long **)&v14);
      *((unsigned char *)v7 + 56) = *a5;
      sub_1006C0E9C((uint64_t)(v7 + 8), (uint64_t)(a5 + 8));
      sub_1006C0F44((uint64_t)(v7 + 12), (uint64_t)(a5 + 40));
      int v8 = *a5;
      switch(v8)
      {
        case 5:
          sub_1006BE07C(a1);
          break;
        case 3:
          if (!a5[112]) {
            __TUAssertTrigger();
          }
          sub_1006BEC64(a1, 1);
          break;
        case 2:
          if (!a5[32]) {
            __TUAssertTrigger();
          }
          sub_1006BE898(a1, 1);
          break;
      }
    }
    else
    {
      sub_1006BFD18(v11, 0, (uint64_t)"SimConfigID doesn't map to a vaild personalityID");
    }
    if (BYTE8(v10))
    {
      if (SBYTE7(v10) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    sub_1006BFD18(v11, 0, (uint64_t)"This auth context is not valid anymore");
  }
}

void sub_1006BF750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006BF774(uint64_t a1)
{
  sub_100273EC4(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      *(void *)(a1 + 16) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void sub_1006BF7B8(uint64_t a1, const void **a2, int a3, unsigned __int8 a4, unsigned __int8 a5)
{
  unsigned __int8 v23 = a3;
  unsigned __int8 v22 = a4;
  unsigned __int8 v21 = a5;
  v20[0] = a1;
  v20[1] = (uint64_t)a2;
  xpc_object_t v20[2] = (uint64_t)&v23;
  v20[3] = (uint64_t)&v22;
  v20[4] = (uint64_t)&v21;
  if (sub_1006BF030(a1, a2, a3))
  {
    int v7 = v22;
    int v8 = v21;
    sub_1006BF930(v20, 1, (uint64_t)"Updating auth status to Authorized for valid SIM configs");
    uint64_t v9 = *(void **)(a1 + 128);
    if (v9 != (void *)(a1 + 136))
    {
      while (1)
      {
        int v10 = *((unsigned __int8 *)v9 + 25);
        int v11 = v7;
        if (!*((unsigned char *)v9 + 25)) {
          goto LABEL_6;
        }
        if (v10 == 1) {
          break;
        }
LABEL_10:
        unsigned __int8 v12 = (void *)v9[1];
        if (v12)
        {
          do
          {
            char v13 = v12;
            unsigned __int8 v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            char v13 = (void *)v9[2];
            BOOL v14 = *v13 == (void)v9;
            uint64_t v9 = v13;
          }
          while (!v14);
        }
        uint64_t v9 = v13;
        if (v13 == (void *)(a1 + 136)) {
          return;
        }
      }
      int v11 = v8;
LABEL_6:
      if (v11)
      {
        v15[0] = 4;
        LOBYTE(__p) = 0;
        char v18 = 0;
        v19[0] = 0;
        v19[72] = 0;
        sub_1006BF5C8(a1, a2, v23, v10, v15);
        sub_100273EC4((uint64_t)v19);
        if (v18)
        {
          if (__p)
          {
            char v17 = __p;
            operator delete(__p);
          }
        }
      }
      goto LABEL_10;
    }
  }
  else
  {
    sub_1006BF930(v20, 0, (uint64_t)"This message is not valid anymore");
  }
}

void sub_1006BF91C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006BF774((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1006BF930(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  int v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v8 = "[Accepted]";
    }
    else {
      int v8 = "[Ignored]";
    }
    sub_100BC8FAC((CFUUIDRef *)a1[1], v23);
    if (v24 >= 0) {
      uint64_t v9 = v23;
    }
    else {
      uint64_t v9 = (void **)v23[0];
    }
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), v21);
    int v11 = v22;
    unsigned __int8 v12 = (void **)v21[0];
    char v13 = (unsigned __int8 *)a1[4];
    int v14 = *(unsigned __int8 *)a1[3];
    int v15 = *v13;
    sub_10026CCB8((unsigned __int8 *)(v6 + 72), &__p);
    uint64_t v16 = v21;
    if (v11 < 0) {
      uint64_t v16 = v12;
    }
    __int16 v26 = v8;
    char v17 = "true";
    __int16 v28 = v9;
    if (v15) {
      char v18 = "true";
    }
    else {
      char v18 = "false";
    }
    *(_DWORD *)std::string buf = 136316930;
    __int16 v27 = 2082;
    if (!v14) {
      char v17 = "false";
    }
    __int16 v29 = 1024;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    int v30 = v10;
    __int16 v31 = 2082;
    uint64_t v32 = v16;
    __int16 v33 = 2082;
    uint8_t v34 = v17;
    __int16 v35 = 2080;
    uint64_t v36 = v18;
    __int16 v37 = 2080;
    uint64_t v38 = p_p;
    __int16 v39 = 2080;
    uint64_t v40 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [SatSmsStartMessage][Attempted]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s, token: %{public}s], hasResponseForSimConfig0: %s, hasResponseForSimConfig1: %s, %s", buf, 0x4Eu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v22 < 0) {
      operator delete(v21[0]);
    }
    if (v24 < 0) {
      operator delete(v23[0]);
    }
  }
}

void sub_1006BFB1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006BFB58(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  if (v3) {
    uint64_t v4 = sub_100136254;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    int v7 = (const void **)(a1 + 64);
    uint64_t v6 = *(const void **)(a1 + 64);
    int v8 = v6 ? sub_100136254 : 0;
    if (!v8 || !CFEqual(v6, v3))
    {
      sub_100224390(v7, a2);
      if (*(unsigned char *)(a1 + 73)) {
        *(unsigned char *)(a1 + 73) = 0;
      }
      *(unsigned char *)(a1 + 121) = 0;
      sub_1006BEC64(a1, 0);
      uint64_t v9 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        sub_100BC8FAC((CFUUIDRef *)v7, v15);
        int v10 = v16;
        int v11 = (void **)v15[0];
        sub_10026CCB8((unsigned __int8 *)(a1 + 72), &__p);
        unsigned __int8 v12 = v15;
        if (v10 < 0) {
          unsigned __int8 v12 = v11;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        char v18 = v12;
        __int16 v19 = 2080;
        __int16 v20 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I LLCEnvironmentID changed. Updated environment: [LLC ID: %{public}s, token: %s]", buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v16 < 0) {
          operator delete(v15[0]);
        }
      }
      sub_1006BE898(a1, 1);
    }
  }
}

void sub_1006BFCF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006BFD18(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  int v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v8 = "[Accepted]";
    }
    else {
      int v8 = "[Ignored]";
    }
    sub_100BC8FAC((CFUUIDRef *)a1[1], v25);
    if (v26 >= 0) {
      uint64_t v9 = v25;
    }
    else {
      uint64_t v9 = (void **)v25[0];
    }
    int v10 = *(unsigned __int8 *)a1[2];
    int v11 = v23;
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), v23);
    if (v24 < 0) {
      int v11 = (void **)v23[0];
    }
    sub_10026CCB8((unsigned __int8 *)(v6 + 72), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    unint64_t v13 = *(char *)a1[3];
    if (v13 > 2) {
      int v14 = "???";
    }
    else {
      int v14 = off_1019F9DE0[v13];
    }
    int v15 = (char *)a1[4];
    unint64_t v16 = *v15;
    if (v16 > 5) {
      char v17 = "???";
    }
    else {
      char v17 = off_1019F9DF8[v16];
    }
    int v18 = v15[32];
    int v19 = v15[112];
    if (v18) {
      __int16 v20 = "true";
    }
    else {
      __int16 v20 = "false";
    }
    *(_DWORD *)std::string buf = 136317442;
    if (v19) {
      unsigned __int8 v21 = "true";
    }
    else {
      unsigned __int8 v21 = "false";
    }
    __int16 v28 = v8;
    __int16 v29 = 2082;
    int v30 = v9;
    __int16 v31 = 1024;
    int v32 = v10;
    __int16 v33 = 2082;
    uint8_t v34 = v11;
    __int16 v35 = 2082;
    uint64_t v36 = p_p;
    __int16 v37 = 2080;
    uint64_t v38 = v14;
    __int16 v39 = 2080;
    uint64_t v40 = v17;
    __int16 v41 = 2080;
    unsigned int v42 = v20;
    __int16 v43 = 2080;
    CFTypeRef v44 = v21;
    __int16 v45 = 2080;
    uint64_t v46 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [HandleSimConfigAuthContext]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s, token: %{public}s], simConfigId: %s, context: [AuthStatus: %s, Resync: %s, ChallengeResponse: %s], %s", buf, 0x62u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v24 < 0) {
      operator delete(v23[0]);
    }
    if (v26 < 0) {
      operator delete(v25[0]);
    }
  }
}

void sub_1006BFF60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006BFF9C(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 121)
    || !*(unsigned char *)(a1 + 122)
    || (*(void *)(a1 + 64) ? (uint64_t v4 = sub_100136254) : (uint64_t v4 = 0), !v4 || !*(unsigned char *)(a1 + 73) || !*(void *)(a1 + 80)))
  {
LABEL_23:
    *a2 = 0;
    return;
  }
  int v5 = *(void **)(a1 + 96);
  if (v5 != (void *)(a1 + 104))
  {
    while (*((unsigned char *)v5 + 56) != 1)
    {
      uint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
      if (v7 == (void *)(a1 + 104)) {
        goto LABEL_17;
      }
    }
    goto LABEL_23;
  }
LABEL_17:
  std::string __p = 0;
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  sub_1006C0244((uint8_t *)&__p, (void *)a1, 0);
  unsigned __int8 v12 = 0;
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_1006C0244((uint8_t *)&v12, (void *)a1, 1u);
  if (__p != v16 || (uint64_t v9 = v12, v12 != v13))
  {
    *a2 = 0;
    operator new();
  }
  int v10 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v11 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "[Unexpected] Nothing to populate in SatSmsStart", v11, 2u);
  }
  *a2 = 0;
  if (v9)
  {
    unint64_t v13 = v9;
    operator delete(v9);
  }
  if (__p)
  {
    unint64_t v16 = __p;
    operator delete(__p);
  }
}

void sub_1006C01BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
}

void sub_1006C0244(uint8_t *a1, void *a2, unsigned int a3)
{
  uint64_t v4 = a2[17];
  if (!v4) {
    goto LABEL_29;
  }
  uint64_t v6 = a2 + 17;
  do
  {
    unsigned int v7 = *(unsigned __int8 *)(v4 + 25);
    BOOL v8 = v7 >= a3;
    if (v7 >= a3) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = (void *)v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != a2 + 17
    && *((unsigned __int8 *)v6 + 25) <= a3
    && (*(_OWORD *)__p = 0u, long long v22 = 0u, sub_1006BE92C(a2, a3, (uint64_t)__p), BYTE8(v22)))
  {
    int v10 = (void *)a2[13];
    if (!v10) {
      goto LABEL_31;
    }
    int v11 = (void **)(a2 + 13);
    do
    {
      char v12 = sub_100046FE8(v10 + 4, __p);
      if (v12 >= 0) {
        unint64_t v13 = v10;
      }
      else {
        unint64_t v13 = v10 + 1;
      }
      if (v12 >= 0) {
        int v11 = (void **)v10;
      }
      int v10 = (void *)*v13;
    }
    while (*v13);
    if (v11 == a2 + 13 || (sub_100046FE8(__p, v11 + 4) & 0x80) != 0 || !*((unsigned char *)v11 + 168))
    {
LABEL_31:
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
    }
    else
    {
      uint64_t v14 = a2[1];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int64_t v15 = (unsigned char *)v11[13] - (unsigned char *)v11[12];
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I AtRes size: %zu", buf, 0xCu);
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v24 = 0;
      sub_100240658((unint64_t *)buf, 0x30uLL);
      sub_10005C748((uint64_t)buf, *(char **)&buf[8], (char *)v11[12], (char *)v11[13], (unsigned char *)v11[13] - (unsigned char *)v11[12]);
      int v19 = 0;
      __int16 v20 = 0;
      (*(void (**)(char ***__return_ptr))(**(void **)(a2[10] + 56) + 32))(&v19);
      if (v19 && (unint64_t v16 = v19[1], v16 - *v19 == 32))
      {
        sub_10005C748((uint64_t)buf, *(char **)&buf[8], *v19, v16, 32);
        *(_OWORD *)a1 = *(_OWORD *)buf;
        *((void *)a1 + 2) = v24;
        a1 = buf;
      }
      else
      {
        uint64_t v17 = a2[1];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          v18[0] = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to generate AKA HMAC.", (uint8_t *)v18, 2u);
        }
      }
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
      if (v20) {
        sub_10004D2C8(v20);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }
    if (BYTE8(v22))
    {
      if (SBYTE7(v22) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
LABEL_29:
    *(void *)a1 = 0;
    *((void *)a1 + 1) = 0;
    *((void *)a1 + 2) = 0;
  }
}

void sub_1006C04F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *__p,uint64_t a21)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(a13);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C0550(void *a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  sub_1006BE92C(a1, a2, (uint64_t)__p);
  if (BYTE8(v7))
  {
    int v5 = sub_100046F68((uint64_t)(a1 + 12), __p);
    if (a1 + 13 != v5 && *((unsigned char *)v5 + 56) == 2 && *((unsigned char *)v5 + 88))
    {
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      sub_10005C928(a3, v5[8], (uint64_t)v5[9], (unsigned char *)v5[9] - (unsigned char *)v5[8]);
    }
    else
    {
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
    }
    if (BYTE8(v7))
    {
      if (SBYTE7(v7) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_1006C0608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C062C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 96);
  uint64_t v2 = (void *)(a1 + 104);
  if (v1 != (void *)(a1 + 104))
  {
    do
    {
      if (*((unsigned char *)v1 + 88))
      {
        uint64_t v4 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_7;
        }
        int v5 = v1 + 4;
        if (*((char *)v1 + 55) < 0) {
          int v5 = (void *)*v5;
        }
        *(_DWORD *)std::string buf = 136446210;
        int v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Clearing resync info for personality: %{public}s", buf, 0xCu);
        if (*((unsigned char *)v1 + 88))
        {
LABEL_7:
          uint64_t v6 = (void *)v1[8];
          if (v6)
          {
            v1[9] = v6;
            operator delete(v6);
          }
          *((unsigned char *)v1 + 88) = 0;
        }
      }
      long long v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          long long v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v9);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
}

void sub_1006C0764(uint64_t a1)
{
  sub_1002B486C(a1);
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 123)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] DidSetup: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 184)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsAccessRestricted: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)(a1 + 64), buf);
    int v5 = SHIBYTE(v51);
    uint64_t v6 = *(unsigned char **)buf;
    sub_10026CCB8((unsigned __int8 *)(a1 + 72), &__p);
    long long v7 = buf;
    if (v5 < 0) {
      long long v7 = v6;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)unint64_t v55 = 136446466;
    double v56 = v7;
    __int16 v57 = 2080;
    uint64_t v58 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] [LLC ID: %{public}s, token: %s]", v55, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 120)) {
      BOOL v9 = "true";
    }
    else {
      BOOL v9 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsCarrierPigeonStartMessageDue: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 121)) {
      int v10 = "true";
    }
    else {
      int v10 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsCarrierPigeonStartMessageAcked: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 122)) {
      int v11 = "true";
    }
    else {
      int v11 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsSatSmsStartMessageDue: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = **(char **)(a1 + 80);
    if (v12 > 2) {
      unint64_t v13 = "???";
    }
    else {
      unint64_t v13 = off_1019F9DE0[v12];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] SPSBucketId: %s", buf, 0xCu);
  }
  uint64_t v14 = *(void *)(a1 + 80);
  int64_t v15 = *(void **)(v14 + 8);
  unint64_t v16 = (void *)(v14 + 16);
  if (v15 != (void *)(v14 + 16))
  {
    do
    {
      uint64_t v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v18 = *((char *)v15 + 32);
        int v19 = "???";
        if (v18 <= 2) {
          int v19 = off_1019F9DE0[v18];
        }
        __int16 v20 = (const char *)(v15 + 5);
        uint64_t v21 = *((unsigned __int8 *)v15 + 63);
        BOOL v22 = (v21 & 0x80u) != 0;
        if ((v21 & 0x80u) != 0) {
          uint64_t v21 = v15[6];
        }
        if (v22) {
          __int16 v20 = (const char *)v15[5];
        }
        if (!v21) {
          __int16 v20 = "<invalid>";
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v19;
        __int16 v49 = 2082;
        unint64_t v50 = v20;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] [SimConfigId: %s, PersonalityId: %{public}s]", buf, 0x16u);
      }
      unsigned __int8 v23 = (void *)v15[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          unsigned __int8 v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v15[2];
          BOOL v25 = *v24 == (void)v15;
          int64_t v15 = v24;
        }
        while (!v25);
      }
      int64_t v15 = v24;
    }
    while (v24 != v16);
  }
  char v26 = *(void **)(a1 + 128);
  if (v26 != (void *)(a1 + 136))
  {
    do
    {
      __int16 v27 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v28 = *((char *)v26 + 25);
        __int16 v29 = "???";
        if (v28 <= 2) {
          __int16 v29 = off_1019F9DE0[v28];
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v29;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I [d] [Valid] SimConfigId: %s", buf, 0xCu);
      }
      int v30 = (void *)v26[1];
      if (v30)
      {
        do
        {
          __int16 v31 = v30;
          int v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          __int16 v31 = (void *)v26[2];
          BOOL v25 = *v31 == (void)v26;
          char v26 = v31;
        }
        while (!v25);
      }
      char v26 = v31;
    }
    while (v31 != (void *)(a1 + 136));
  }
  int v32 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v33 = *(std::__shared_weak_count **)(a1 + 176);
    if (v33)
    {
      uint8_t v34 = std::__shared_weak_count::lock(v33);
      if (v34 && *(void *)(a1 + 168))
      {
        __int16 v35 = "true";
        goto LABEL_77;
      }
    }
    else
    {
      uint8_t v34 = 0;
    }
    __int16 v35 = "false";
LABEL_77:
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I [d] SatSmsStartMessageTracker exists: %s", buf, 0xCu);
    if (v34) {
      sub_10004D2C8(v34);
    }
  }
  uint64_t v36 = *(void **)(a1 + 96);
  if (v36 != (void *)(a1 + 104))
  {
    do
    {
      __int16 v37 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = (const char *)v36[4];
        uint64_t v39 = *((unsigned __int8 *)v36 + 55);
        int v40 = (char)v39;
        if ((v39 & 0x80u) != 0) {
          uint64_t v39 = v36[5];
        }
        if (v40 >= 0) {
          uint64_t v38 = (const char *)(v36 + 4);
        }
        if (!v39) {
          uint64_t v38 = "<invalid>";
        }
        unint64_t v41 = *((char *)v36 + 56);
        unsigned int v42 = "???";
        if (v41 <= 5) {
          unsigned int v42 = off_1019F9DF8[v41];
        }
        if (*((unsigned char *)v36 + 88)) {
          __int16 v43 = "yes";
        }
        else {
          __int16 v43 = "no";
        }
        if (*((unsigned char *)v36 + 168)) {
          CFTypeRef v44 = "yes";
        }
        else {
          CFTypeRef v44 = "no";
        }
        *(_DWORD *)std::string buf = 136446978;
        *(void *)&uint8_t buf[4] = v38;
        __int16 v49 = 2080;
        unint64_t v50 = v42;
        __int16 v51 = 2080;
        int v52 = v43;
        __int16 v53 = 2080;
        int v54 = v44;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Personality: %{public}s, authContext: [AuthStatus: %s, HasResyncInfo: %s, HasChallengeResponse: %s]", buf, 0x2Au);
      }
      __int16 v45 = (void *)v36[1];
      if (v45)
      {
        do
        {
          uint64_t v46 = v45;
          __int16 v45 = (void *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          uint64_t v46 = (void *)v36[2];
          BOOL v25 = *v46 == (void)v36;
          uint64_t v36 = v46;
        }
        while (!v25);
      }
      uint64_t v36 = v46;
    }
    while (v46 != (void *)(a1 + 104));
  }
}

void sub_1006C0E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C0E9C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(char **)(a2 + 8);
      unint64_t v4 = (unint64_t)&v3[-*(void *)a2];
      int v5 = *(char **)a2;
      sub_10006E4A8((void *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v6 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v6;
      operator delete(v6);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_10005C928((void *)a1, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void sub_1006C0F44(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 72) == *(unsigned __int8 *)(a2 + 72))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 72))
    {
      sub_10006E4A8((void *)a1, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      sub_10006E4A8((void *)(a1 + 24), *(char **)(a2 + 24), *(char **)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
      unint64_t v4 = *(char **)(a2 + 48);
      int v5 = *(char **)(a2 + 56);
      sub_10006E4A8((void *)(a1 + 48), v4, v5, v5 - v4);
    }
  }
  else if (*(unsigned char *)(a1 + 72))
  {
    sub_1006C1004(a1);
  }
  else
  {
    sub_1006C1060((void *)a1, a2);
    *(unsigned char *)(a1 + 72) = 1;
  }
}

void sub_1006C1004(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      *(void *)(a1 + 32) = v3;
      operator delete(v3);
    }
    unint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
}

void *sub_1006C1060(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_10005C928(a1, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  sub_10005C928(a1 + 3, *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  sub_10005C928(a1 + 6, *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
  return a1;
}

void sub_1006C10DC(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  int v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C1110(void *a1)
{
  if (a1)
  {
    sub_1006C1110(*a1);
    sub_1006C1110(a1[1]);
    sub_1006C1164((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1006C1164(uint64_t a1)
{
  sub_100273EC4(a1 + 64);
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      *(void *)(a1 + 40) = v2;
      operator delete(v2);
    }
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *sub_1006C11CC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1006C1224(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_1006C120C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1006C1224(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    int v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_1006C12B0(v5, v6, v4 + 25, v4 + 25);
      long long v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          long long v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }
        while (!v9);
      }
      unint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1006C12B0(uint64_t **a1, uint64_t *a2, unsigned __int8 *a3, unsigned char *a4)
{
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v6 = sub_1006C133C(a1, a2, &v11, &v10, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    BOOL v8 = (uint64_t **)v6;
    long long v7 = (uint64_t *)operator new(0x20uLL);
    *((unsigned char *)v7 + 25) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_1006C133C(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned __int8 *a5)
{
  int v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((unsigned __int8 *)a2 + 25), v6 < v7))
  {
    BOOL v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      unint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((unsigned __int8 *)v10 + 25) < v15) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          unsigned int v18 = *(unsigned __int8 *)(v16 + 25);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          int v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        int v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    unint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      unint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    int v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      int v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((unsigned __int8 *)a4 + 25))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v21 = (uint64_t *)v20;
          unsigned int v22 = *(unsigned __int8 *)(v20 + 25);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      uint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_1006C14E4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(unsigned __int8 *)(v2 + 25);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unsigned int v7 = (uint64_t *)v2;
    }
    else {
      unsigned int v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(unsigned __int8 *)(v4 + 25)) {
    return 0;
  }
  sub_10006C514((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

uint64_t *sub_1006C1560(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  BOOL v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  unsigned int v7 = *v6;
  if (!*v6)
  {
    BOOL v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_1006C1618((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, v10[0]);
    unsigned int v7 = v10[0];
    v10[0] = 0;
    sub_1006C16D4((uint64_t)v10, 0);
  }
  return v7;
}

double sub_1006C1618@<D0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  BOOL v6 = (char *)operator new(0xB0uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  unsigned int v7 = v6 + 32;
  BOOL v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)unsigned int v7 = v9;
  }
  *((void *)v6 + 21) = 0;
  double result = 0.0;
  *(_OWORD *)(v6 + 152) = 0u;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1006C16BC(_Unwind_Exception *a1)
{
  sub_1006C16D4(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1006C16D4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1006C1164((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_1006C172C(uint64_t a1, Registry **a2, int a3, char *a4, uint64_t a5)
{
  long long v9 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v11, &v13);
  ctu::OsLogLogger::OsLogLogger(v9, (const ctu::OsLogLogger *)&v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019F9E38;
  *(_DWORD *)(a1 + 32) = a3;
  Registry::getNotificationSenderFactory(&v11, *a2);
  (*(void (**)(OsLogContext *__return_ptr))(*(void *)v11 + 48))(&v13);
  *(OsLogContext *)(a1 + 40) = v13;
  v13.var0 = 0;
  v13.var1.fRef = 0;
  if (v12) {
    sub_10004D2C8(v12);
  }
  *(void *)(a1 + 56) = a5;
  *(void *)(a1 + 64) = 850045863;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = -1;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 161) = 257;
  *(unsigned char *)(a1 + 163) = 0;
  return a1;
}

void sub_1006C1888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  BOOL v14 = (std::__shared_weak_count *)*((void *)v11 + 3);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  ctu::OsLogLogger::~OsLogLogger(v12);
  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C18EC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1006C18F4(std::mutex *a1)
{
  uint64_t v2 = a1 + 1;
  std::mutex::lock(a1 + 1);
  uint64_t v3 = sub_1006C194C((uint64_t)a1);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1006C1938(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C194C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 160)
    || !*(unsigned char *)(a1 + 161)
    || *(unsigned char *)(a1 + 163)
    || !(*(unsigned int (**)(uint64_t))(*(void *)a1 + 104))(a1))
  {
    return 4294967294;
  }
  else
  {
    return *(unsigned int *)(a1 + 128);
  }
}

void sub_1006C19BC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  if (*(unsigned char *)(a1 + 160)
    || !*(unsigned char *)(a1 + 161)
    || *(unsigned char *)(a1 + 163)
    || !(*(unsigned int (**)(uint64_t))(*(void *)a1 + 104))(a1))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    sub_10005C928(a2, *(const void **)(a1 + 136), *(void *)(a1 + 144), *(void *)(a1 + 144) - *(void *)(a1 + 136));
  }

  std::mutex::unlock(v4);
}

void sub_1006C1A70(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C1A84(uint64_t a1, int a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  int v5 = sub_1006C194C(a1);
  *(_DWORD *)(a1 + 128) = a2;
  if (sub_1006C194C(a1) != v5) {
    (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
  }

  std::mutex::unlock(v4);
}

void sub_1006C1B1C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C1B30(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  sub_10005C9A4(a1 + 136, a2);
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    std::string __p = 0;
    BOOL v6 = 0;
    uint64_t v7 = 0;
    sub_10005C928(&__p, *(const void **)(a1 + 136), *(void *)(a1 + 144), *(void *)(a1 + 144) - *(void *)(a1 + 136));
    sub_1002586D4((uint64_t)&__p);
    if (__p)
    {
      BOOL v6 = __p;
      operator delete(__p);
    }
  }
  (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 40) + 56))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 32), a1 + 136);
  std::mutex::unlock(v4);
}

void sub_1006C1BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  std::mutex::unlock(v11);
  _Unwind_Resume(a1);
}

void sub_1006C1C20(std::mutex *a1, char a2)
{
  uint64_t v4 = a1 + 1;
  std::mutex::lock(a1 + 1);
  int v5 = sub_1006C194C((uint64_t)a1);
  a1[2].__m_.__opaque[24] = a2;
  if (sub_1006C194C((uint64_t)a1) != v5) {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 96))(a1);
  }

  std::mutex::unlock(v4);
}

void sub_1006C1CB8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C1CCC(std::mutex *a1, char a2)
{
  uint64_t v4 = a1 + 1;
  std::mutex::lock(a1 + 1);
  int v5 = sub_1006C194C((uint64_t)a1);
  a1[2].__m_.__opaque[25] = a2;
  if (sub_1006C194C((uint64_t)a1) != v5) {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 96))(a1);
  }

  std::mutex::unlock(v4);
}

void sub_1006C1D64(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C1D78(std::mutex *a1, char a2)
{
  uint64_t v4 = a1 + 1;
  std::mutex::lock(a1 + 1);
  int v5 = sub_1006C194C((uint64_t)a1);
  a1[2].__m_.__opaque[27] = a2;
  if (sub_1006C194C((uint64_t)a1) != v5) {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 96))(a1);
  }

  std::mutex::unlock(v4);
}

void sub_1006C1E10(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C1E24(std::mutex *a1, char a2)
{
  uint64_t v4 = a1 + 1;
  std::mutex::lock(a1 + 1);
  int v5 = sub_1006C194C((uint64_t)a1);
  a1[2].__m_.__opaque[26] = a2;
  if (sub_1006C194C((uint64_t)a1) != v5) {
    (*(void (**)(std::mutex *))(a1->__m_.__sig + 96))(a1);
  }

  std::mutex::unlock(v4);
}

void sub_1006C1EBC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C1ED0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 162);
}

void sub_1006C1ED8(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006C194C(a1);
    uint64_t v4 = asString();
    uint64_t v5 = asString();
    BOOL v6 = "true";
    if (*(unsigned char *)(a1 + 160)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    if (*(unsigned char *)(a1 + 162)) {
      BOOL v8 = "true";
    }
    else {
      BOOL v8 = "false";
    }
    int v9 = *(unsigned __int8 *)(a1 + 163);
    if (*(unsigned char *)(a1 + 161)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    int v11 = 136316418;
    if (!v9) {
      BOOL v6 = "false";
    }
    uint64_t v12 = v4;
    __int16 v13 = 2080;
    uint64_t v14 = v5;
    __int16 v15 = 2080;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    unsigned int v18 = v8;
    __int16 v19 = 2080;
    uint64_t v20 = v10;
    __int16 v21 = 2080;
    unsigned int v22 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s [raw=%s, bb=%s, reg=%s, cell=%s, air=%s]", (uint8_t *)&v11, 0x3Eu);
  }
  std::mutex::unlock(v2);
}

void sub_1006C2014(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006C2030(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)Registry::getRegistryModel(*(Registry **)a2);
  sSetupOsLogSubsystem();
  (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 24))(&v52);
  pthread_mutex_lock(&stru_101B0A638);
  uint64_t v6 = xmmword_101B0A678;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A678 + 1);
  if (*((void *)&xmmword_101B0A678 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0A678 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A638);
  if (v6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Assertion that singleton is being created here was not correct");
  }
  long long v7 = v52;
  if (*((void *)&v52 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v52 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_lock(&stru_101B0A638);
  BOOL v8 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A678 + 1);
  xmmword_101B0A678 = v7;
  pthread_mutex_unlock(&stru_101B0A638);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v9 = v52;
  if (*((void *)&v52 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v52 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(v4 + 88);
  *(_OWORD *)(v4 + 80) = v9;
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (*((void *)&v52 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
  }
  uint64_t v11 = *a1;
  uint64_t v12 = *(void *)(a2 + 8);
  *(void *)&long long v55 = *(void *)a2;
  *((void *)&v55 + 1) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)v11 + 48))(&v52);
  __int16 v13 = *(std::__shared_weak_count **)(v4 + 72);
  *(_OWORD *)(v4 + 64) = v52;
  long long v52 = 0uLL;
  if (v13)
  {
    sub_10004D2C8(v13);
    if (*((void *)&v52 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
    }
  }
  if (*((void *)&v55 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v55 + 1));
  }
  (**(void (***)(long long *__return_ptr))*a1)(&v52);
  long long v14 = v52;
  long long v52 = 0uLL;
  __int16 v15 = *(std::__shared_weak_count **)(v4 + 8);
  *(_OWORD *)uint64_t v4 = v14;
  if (v15)
  {
    sub_10004D2C8(v15);
    if (*((void *)&v52 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
    }
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 32))(&v52);
  unint64_t v16 = *((void *)&v52 + 1);
  unint64_t v17 = v52;
  long long v52 = 0uLL;
  unsigned int v18 = *(std::__shared_weak_count **)(v4 + 24);
  *(_OWORD *)(v4 + 16) = __PAIR128__(v16, v17);
  if (v18)
  {
    sub_10004D2C8(v18);
    if (*((void *)&v52 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
    }
    unint64_t v17 = *(void *)(v4 + 16);
    unint64_t v16 = *(void *)(v4 + 24);
  }
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)&long long v52 = off_1019F9F20;
  *((void *)&v52 + 1) = v17;
  uint64_t v19 = v4 + 320;
  unint64_t v53 = v16;
  int v54 = (uint64_t (***)())&v52;
  if ((long long *)(v4 + 320) != &v52)
  {
    uint64_t v20 = off_1019F9F20;
    if (*(void *)(v4 + 344) == v19)
    {
      *(void *)&long long v55 = off_1019F9F20;
      *((void *)&v55 + 1) = v17;
      unint64_t v56 = v16;
      if (v16)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 16), 1uLL, memory_order_relaxed);
        uint64_t v20 = *v54;
      }
      v20[4]();
      int v54 = 0;
      (*(void (**)(void, long long *))(**(void **)(v4 + 344) + 24))(*(void *)(v4 + 344), &v52);
      (*(void (**)(void))(**(void **)(v4 + 344) + 32))(*(void *)(v4 + 344));
      *(void *)(v4 + 344) = 0;
      int v54 = (uint64_t (***)())&v52;
      (*(void (**)(long long *, uint64_t))(v55 + 24))(&v55, v4 + 320);
      (*(void (**)(long long *))(v55 + 32))(&v55);
    }
    else
    {
      *(void *)(v4 + 320) = off_1019F9F20;
      *(void *)(v4 + 328) = v17;
      *(void *)(v4 + 336) = v16;
      if (v16)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 16), 1uLL, memory_order_relaxed);
        uint64_t v20 = *v54;
      }
      v20[4]();
      int v54 = *(uint64_t (****)())(v4 + 344);
    }
    *(void *)(v4 + 344) = v19;
  }
  sub_1006C5CAC(&v52);
  __int16 v21 = (uint64_t (***)())(v4 + 352);
  *(void *)&long long v52 = off_1019F9FA0;
  int v54 = (uint64_t (***)())&v52;
  if ((long long *)(v4 + 352) != &v52)
  {
    unsigned int v22 = *(uint64_t (****)())(v4 + 376);
    if (v22 == v21)
    {
      *((void *)&v55 + 1) = 0;
      unint64_t v56 = 0;
      int v54 = 0;
      *(void *)&long long v55 = off_1019F9FA0;
      ((void (*)(uint64_t, long long *))(*v21)[3])(v4 + 352, &v52);
      (*(void (**)(void))(**(void **)(v4 + 376) + 32))(*(void *)(v4 + 376));
      *(void *)(v4 + 376) = 0;
      int v54 = (uint64_t (***)())&v52;
      (*(void (**)(long long *, uint64_t))(v55 + 24))(&v55, v4 + 352);
      (*(void (**)(long long *))(v55 + 32))(&v55);
    }
    else
    {
      *(void *)(v4 + 352) = off_1019F9FA0;
      int v54 = v22;
    }
    *(void *)(v4 + 376) = v21;
  }
  sub_1006C5E9C(&v52);
  uint64_t v24 = *(Registry **)a2;
  unint64_t v23 = *(void *)(a2 + 8);
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = v4 + 384;
  *(void *)&long long v52 = off_1019FA030;
  *((void *)&v52 + 1) = v24;
  unint64_t v53 = v23;
  int v54 = (uint64_t (***)())&v52;
  if ((long long *)(v4 + 384) != &v52)
  {
    char v26 = off_1019FA030;
    if (*(void *)(v4 + 408) == v25)
    {
      *(void *)&long long v55 = off_1019FA030;
      *((void *)&v55 + 1) = v24;
      unint64_t v56 = v23;
      if (v23)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 16), 1uLL, memory_order_relaxed);
        char v26 = *v54;
      }
      v26[4]();
      int v54 = 0;
      (*(void (**)(void, long long *))(**(void **)(v4 + 408) + 24))(*(void *)(v4 + 408), &v52);
      (*(void (**)(void))(**(void **)(v4 + 408) + 32))(*(void *)(v4 + 408));
      *(void *)(v4 + 408) = 0;
      int v54 = (uint64_t (***)())&v52;
      (*(void (**)(long long *, uint64_t))(v55 + 24))(&v55, v4 + 384);
      (*(void (**)(long long *))(v55 + 32))(&v55);
    }
    else
    {
      *(void *)(v4 + 384) = off_1019FA030;
      *(void *)(v4 + 392) = v24;
      *(void *)(v4 + 400) = v23;
      if (v23)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 16), 1uLL, memory_order_relaxed);
        char v26 = *v54;
      }
      v26[4]();
      int v54 = *(uint64_t (****)())(v4 + 408);
    }
    *(void *)(v4 + 408) = v25;
  }
  sub_1006C65E8(&v52);
  (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 64))(&v55);
  pthread_mutex_lock(&stru_101B0A688);
  uint64_t v27 = xmmword_101B0A6C8;
  unint64_t v28 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A6C8 + 1);
  if (*((void *)&xmmword_101B0A6C8 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0A6C8 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A688);
  if (v27)
  {
    double v48 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v48, "Assertion that singleton is being created here was not correct");
  }
  long long v29 = v55;
  if (*((void *)&v55 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v55 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_lock(&stru_101B0A688);
  int v30 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A6C8 + 1);
  xmmword_101B0A6C8 = v29;
  pthread_mutex_unlock(&stru_101B0A688);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
  __int16 v31 = "11CCXpcServer";
  if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
  {
    int v32 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v33 = 5381;
    do
    {
      __int16 v31 = (const char *)v33;
      unsigned int v34 = *v32++;
      uint64_t v33 = (33 * v33) ^ v34;
    }
    while (v34);
  }
  std::mutex::lock((std::mutex *)(v4 + 192));
  uint64_t v36 = (std::__shared_weak_count *)*((void *)&v55 + 1);
  uint64_t v35 = v55;
  long long v52 = v55;
  if (*((void *)&v55 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v55 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v51 = (unint64_t)v31;
  if (v35)
  {
    sub_100136784(v4 + 256, &v51, &v51, (uint64_t *)&v52);
    char v38 = v37 & 1;
    uint64_t v36 = (std::__shared_weak_count *)*((void *)&v52 + 1);
    if (!*((void *)&v52 + 1)) {
      goto LABEL_74;
    }
  }
  else
  {
    sub_100136C98((void *)(v4 + 256), &v51);
    char v38 = 1;
    if (!v36)
    {
LABEL_74:
      std::mutex::unlock((std::mutex *)(v4 + 192));
      if ((v38 & 1) == 0)
      {
        __int16 v49 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v49, "The given type is already in the map!");
      }
      if (*((void *)&v55 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v55 + 1));
      }
      long long v55 = 0uLL;
      (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 72))(&v55);
      if ((v39 & 0x8000000000000000) != 0)
      {
        int v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v41 = 5381;
        do
        {
          unint64_t v39 = v41;
          unsigned int v42 = *v40++;
          uint64_t v41 = (33 * v41) ^ v42;
        }
        while (v42);
      }
      std::mutex::lock((std::mutex *)(v4 + 192));
      CFTypeRef v44 = (std::__shared_weak_count *)*((void *)&v55 + 1);
      uint64_t v43 = v55;
      long long v52 = v55;
      if (*((void *)&v55 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v55 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v51 = v39;
      if (v43)
      {
        sub_100136784(v4 + 256, &v51, &v51, (uint64_t *)&v52);
        char v46 = v45 & 1;
        CFTypeRef v44 = (std::__shared_weak_count *)*((void *)&v52 + 1);
        if (!*((void *)&v52 + 1)) {
          goto LABEL_85;
        }
      }
      else
      {
        sub_100136C98((void *)(v4 + 256), &v51);
        char v46 = 1;
        if (!v44)
        {
LABEL_85:
          std::mutex::unlock((std::mutex *)(v4 + 192));
          if (v46)
          {
            (*(void (**)(unint64_t *__return_ptr))(*(void *)v55 + 16))(&v51);
            sub_1012B3354();
          }
          unint64_t v50 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v50, "The given type is already in the map!");
        }
      }
      sub_10004D2C8(v44);
      goto LABEL_85;
    }
  }
  sub_10004D2C8(v36);
  goto LABEL_74;
}

void sub_1006C2B90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C2C98(uint64_t a1, Registry **a2)
{
  uint64_t v3 = *(void *)Registry::getRegistryModel(*a2);
  (*(void (**)(long long *__return_ptr))(**(void **)a1 + 40))(&v6);
  long long v4 = v6;
  long long v6 = 0uLL;
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 56);
  *(_OWORD *)(v3 + 48) = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    if (*((void *)&v6 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
    }
  }
}

void sub_1006C2D2C(uint64_t a1, uint64_t a2)
{
  kdebug_trace();
  Registry::getRegistryModel(*(Registry **)a2);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100081F0C();
}

void sub_1006C52BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,char a25)
{
  if (a24) {
    sub_10004D2C8(a24);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006C57C4(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_1006C5820(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1006C5898((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1006C5898(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  v12[2] = &v14;
  v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v14 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_1006C5928((uint64_t)v12);
  return v10;
}

uint64_t sub_1006C5928(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1006C5960(a1);
  }
  return a1;
}

void sub_1006C5960(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    v1 += 16;
  }
}

void **sub_1006C59A4(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1006C59D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    long long v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      sub_10004D2C8(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

void *sub_1006C5A2C(void *a1)
{
  *a1 = off_1019F9F20;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006C5A78(void *a1)
{
  *a1 = off_1019F9F20;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1006C5AE4(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019F9F20;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006C5B40(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019F9F20;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006C5B78(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006C5B88(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006C5BC8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7)
    {
      ctu::RestDispatchListener::createConnector(*(ctu::RestDispatchListener **)(v7 + 40));
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
    }
    sub_10004D2C8(v6);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1006C5C4C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C5C60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006C5CA0()
{
}

void *sub_1006C5CAC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1006C5D34()
{
}

void *sub_1006C5D48()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019F9FA0;
  return result;
}

void sub_1006C5D80(uint64_t a1, void *a2)
{
  *a2 = off_1019F9FA0;
}

void sub_1006C5DA8()
{
  mach_service = xpc_connection_create_mach_service("com.apple.commcenter.mobile-helper-rest", 0, 2uLL);
  if (!mach_service) {
    mach_service = xpc_null_create();
  }
  xpc_object_t object = mach_service;
  xpc_object_t v1 = xpc_null_create();
  ctu::rest::RestXpcConnector::create((ctu::rest::RestXpcConnector *)&object, v3);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v1);
}

void sub_1006C5E24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C5E50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006C5E90()
{
}

void *sub_1006C5E9C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1006C5F20(void *a1)
{
  *a1 = off_1019FA030;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006C5F6C(void *a1)
{
  *a1 = off_1019FA030;
  xpc_object_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1006C5FD8(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019FA030;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006C6034(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019FA030;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006C606C(uint64_t a1)
{
  xpc_object_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006C607C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

uint64_t sub_1006C60BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006C60FC()
{
}

void sub_1006C610C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006C6144(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FA0F0)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

void sub_1006C6184(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA110;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006C61A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA110;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006C61F8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(Registry **)(a1 + 24);
      if (v5)
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        Registry::getTimerService(&v15, v5);
        uint64_t v6 = v15;
        if (v15)
        {
          if (*(char *)(a1 + 71) < 0)
          {
            sub_10004FC84(v13, *(void **)(a1 + 48), *(void *)(a1 + 56));
          }
          else
          {
            *(_OWORD *)long long v13 = *(_OWORD *)(a1 + 48);
            uint64_t v14 = *(void *)(a1 + 64);
          }
          uint64_t v7 = 1000000 * *(void *)(a1 + 40);
          uint64_t v9 = *(void *)(a1 + 72);
          uint64_t v8 = *(void *)(a1 + 80);
          if (v8) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
          }
          *(_OWORD *)std::string __p = *(_OWORD *)v13;
          uint64_t v10 = v14;
          v13[0] = 0;
          v13[1] = 0;
          uint64_t v14 = 0;
          uint64_t v18 = v10;
          v19[0] = off_1019FA160;
          v19[1] = v9;
          uint64_t v19[2] = v8;
          v19[3] = v19;
          (*(void (**)(uint64_t, void **, void, uint64_t, void *))(*(void *)v6 + 32))(v6, __p, 0, v7, v19);
          sub_10003B34C(v19);
          if (SHIBYTE(v18) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v14) < 0) {
            operator delete(v13[0]);
          }
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v4);
    }
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 80);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 32);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1006C63A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21)
{
  if (a2)
  {
    sub_10003B34C(&a21);
    if (a20 < 0) {
      operator delete(__p);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1006C63E8(void *a1)
{
  *a1 = off_1019FA160;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1006C6434(void *a1)
{
  *a1 = off_1019FA160;
  xpc_object_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1006C64A0(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019FA160;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006C64FC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019FA160;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006C6534(uint64_t a1)
{
  xpc_object_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1006C6544(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1006C6584(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_1006C659C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006C65DC()
{
}

void *sub_1006C65E8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1006C666C(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1006C66C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA1F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006C66E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA1F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006C6738(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1006C6760(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006C6780(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FA240;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006C67D4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1006C67FC()
{
  if ((byte_101B0D318 & 1) == 0)
  {
    byte_101B0D318 = 1;
    return __cxa_atexit((void (*)(void *))sub_1006C57C4, &stru_101B0A638, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1006C6838()
{
  if ((byte_101B0A6D8 & 1) == 0)
  {
    byte_101B0A6D8 = 1;
    return __cxa_atexit((void (*)(void *))sub_1006C581C, &stru_101B0A688, (void *)&_mh_execute_header);
  }
  return result;
}

BOOL sub_1006C6874()
{
  uint64_t v0 = +[NSCalendar currentCalendar];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v5 = CFDateCreate(kCFAllocatorDefault, Current);
  uint64_t v2 = [v0 components:252 fromDate:v5];
  BOOL v3 = (uint64_t)[v2 hour] >= 2 && (uint64_t)objc_msgSend(v2, "hour") < 4;

  sub_10007CA64((const void **)&v5);
  return v3;
}

void sub_1006C6920(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);

  _Unwind_Resume(a1);
}

CFAbsoluteTime sub_1006C6950(CFAbsoluteTime AbsoluteTime)
{
  uint64_t v2 = +[NSCalendar currentCalendar];
  CFDateRef v15 = CFDateCreate(kCFAllocatorDefault, AbsoluteTime);
  CFDateRef v3 = v15;
  uint64_t v4 = [v2 components:252 fromDate:v3];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v14 = CFDateCreate(kCFAllocatorDefault, Current);
  CFDateRef v6 = v14;
  uint64_t v7 = [v2 components:252 fromDate:v6];
  if ([(__CFDate *)v3 compare:v6] != (id)1
    || (uint64_t)[v4 hour] < 2
    || (uint64_t)[v4 hour] >= 4)
  {
    int v8 = rand();
    unsigned int v9 = v8 & 1;
    if (v8 < 0) {
      unsigned int v9 = -v9;
    }
    uint64_t v13 = 0x300000002;
    [v4 setHour:*((unsigned int *)&v13 + v9)];
    uint64_t v10 = [v2 dateFromComponents:v4];
    if ([v10 compare:v6] != (id)1)
    {
      objc_msgSend(v4, "setDay:", (char *)objc_msgSend(v7, "day") + 1);
      uint64_t v11 = [v2 dateFromComponents:v4];

      uint64_t v10 = (void *)v11;
    }
    AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v10);
  }
  sub_10007CA64((const void **)&v14);

  sub_10007CA64((const void **)&v15);
  return AbsoluteTime;
}

void sub_1006C6B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  unsigned int v9 = va_arg(va1, const void *);

  sub_10007CA64((const void **)va);
  sub_10007CA64((const void **)va1);

  _Unwind_Resume(a1);
}

void sub_1006C6B78(uint64_t a1@<X8>)
{
  id v2 = objc_alloc_init((Class)NSDateFormatter);
  CFDateRef v3 = +[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"];
  [v2 setLocale:v3];

  [v2 setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
  uint64_t v4 = +[NSDate date];
  CFDateRef v5 = [v2 stringFromDate:v4];

  ctu::cf::assign();
  *(_OWORD *)a1 = 0uLL;
  *(void *)(a1 + 16) = 0;
}

void sub_1006C6C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *sub_1006C6C90(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = "DATA.Connection.InternalDataProbe.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    uint64_t v12 = "DATA.Connection.InternalDataProbe.2";
  }
  CFDateRef v14 = "InternalDataProbe.X";
  if (v13 == 2) {
    CFDateRef v14 = "InternalDataProbe.2";
  }
  if (v13 == 1) {
    CFDateRef v15 = "DATA.Connection.InternalDataProbe.1";
  }
  else {
    CFDateRef v15 = v12;
  }
  if (v13 == 1) {
    unint64_t v16 = "InternalDataProbe.1";
  }
  else {
    unint64_t v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_1019FAD00, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_1019FA2C8;
  a1[8] = off_1019FA818;
  a1[9] = off_1019FAAA8;
  a1[10] = off_1019FAC98;
  return a1;
}

void sub_1006C6E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_1006C6E48(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019FAD00);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1006C6E78(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_1019FAD00);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1006C6EAC(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_1019FAD00);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1006C6EE0(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_1019FAD00);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1006C6F14(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019FAD00);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1006C6F58(uint64_t a1)
{
}

void sub_1006C6F60(uint64_t a1)
{
}

void sub_1006C6F68(uint64_t a1)
{
}

uint64_t sub_1006C6F70(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 1;
}

uint64_t sub_1006C6F7C(uint64_t a1, uint64_t a2)
{
  CFDateRef v3 = (capabilities::ct *)qword_101B14190;
  if (qword_101B14190)
  {
    CFDateRef v3 = (capabilities::ct *)std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    uint64_t v4 = (std::__shared_weak_count *)v3;
    if (v3) {
      uint64_t v5 = DataPlanManagerBootstrap::sInstance;
    }
    else {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v4 = 0;
  }
  unsigned int v6 = capabilities::ct::supportsDataPlanNotifications(v3);
  if (v5) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7 == 1)
  {
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = "";
    *(void *)(a2 + 16) = "";
    *(_DWORD *)(a2 + 24) = 0;
    *(unsigned char *)(a2 + 28) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    int v8 = *(std::__shared_weak_count **)(a2 + 48);
    *(void *)(a2 + 48) = 0;
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v7;
}

void sub_1006C7024(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C703C()
{
}

void sub_1006C70A8()
{
}

uint64_t sub_1006C70CC(uint64_t a1, void *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cs");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &v8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)a1 = off_1019FBA90;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 305) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(void *)(a1 + 328) = *a2;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 336) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 344) = 0;
  CFArrayRef v5 = CFArrayCreate(kCFAllocatorDefault, (const void **)&qword_101B0D328, 14, &kCFTypeArrayCallBacks);
  unsigned int v6 = *(char **)(a1 + 40);
  *(void *)(a1 + 40) = v5;
  v8.var0 = v6;
  sub_100044D00((const void **)&v8.var0);
  return a1;
}

void sub_1006C7264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10, const void **a11, const void **a12, const void **a13)
{
  unint64_t v23 = *(std::__shared_weak_count **)(v13 + 336);
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (*(char *)(v13 + 319) < 0) {
    operator delete(*(void **)(v13 + 296));
  }
  sub_100057D78(v19);
  if (*(char *)(v13 + 287) < 0) {
    operator delete(*(void **)(v13 + 264));
  }
  sub_100057D78(v17);
  if (*(char *)(v13 + 255) < 0) {
    operator delete(*(void **)(v13 + 232));
  }
  sub_100057D78(v16);
  if (*(char *)(v13 + 223) < 0) {
    operator delete(*(void **)(v13 + 200));
  }
  sub_100057D78(v18);
  sub_100057D78(v21);
  sub_100057D78(v20);
  if (*(char *)(v13 + 175) < 0) {
    operator delete(*(void **)(v13 + 152));
  }
  sub_100057D78(a10);
  if (*(char *)(v13 + 143) < 0) {
    operator delete(*(void **)(v13 + 120));
  }
  sub_100057D78(a11);
  if (*(char *)(v13 + 111) < 0) {
    operator delete(*(void **)(v13 + 88));
  }
  sub_100057D78(a12);
  if (*(char *)(v13 + 79) < 0) {
    operator delete(*(void **)(v13 + 56));
  }
  sub_100057D78(a13);
  sub_100044D00(v15);
  CarrierSettingsInterface::~CarrierSettingsInterface((CarrierSettingsInterface *)v13);
  sub_1006C7390(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C7390(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  id v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

const void **sub_1006C73C8@<X0>(const void **result@<X0>, const void *a2@<X1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2)
  {
    CFDateRef v3 = result;
    CFArrayRef v5 = (const __CFArray *)result[5];
    if (v5 ? sub_100083F10 : 0)
    {
      v11.length = CFArrayGetCount((CFArrayRef)result[5]);
      v11.location = 0;
      uint64_t result = (const void **)CFArrayContainsValue(v5, v11, a2);
      if (result)
      {
        (*((void (**)(const void **__return_ptr, const void **, void, const void *, void, void))*v3 + 4))(&v9, v3, kCarrierBundleId, a2, 0, 0);
        if (&v9 != a3)
        {
          OsLogContext v8 = *a3;
          *a3 = v9;
          unsigned int v9 = 0;
          uint64_t v10 = v8;
          sub_1000577C4(&v10);
        }
        return sub_1000577C4(&v9);
      }
    }
  }
  return result;
}

void sub_1006C74B8(_Unwind_Exception *a1)
{
  sub_1000577C4(v1);
  _Unwind_Resume(a1);
}

void sub_1006C74D4(uint64_t a1, const void *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0) {
    sub_10004FC84(&v112, *(void **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string v112 = *(std::string *)a3;
  }
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock(v4);
  CFArrayRef v5 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v6 = &v112;
    }
    else {
      unsigned int v6 = (std::string *)v112.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 138543618;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Reloading the %{public}@ preferences from file: %s", buf, 0x16u);
  }
  v116[0] = a1;
  v116[1] = (uint64_t)a2;
  if (CFEqual(a2, kCarrier1BundleId))
  {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 143);
    if (*(char *)(a1 + 143) < 0)
    {
      if (!*(void *)(a1 + 128)) {
        goto LABEL_54;
      }
    }
    else if (!*(unsigned char *)(a1 + 143))
    {
      goto LABEL_54;
    }
    if ((v7 & 0x80u) == 0) {
      uint64_t v9 = *(unsigned __int8 *)(a1 + 143);
    }
    else {
      uint64_t v9 = *(void *)(a1 + 128);
    }
    std::string::size_type size = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v112.__r_.__value_.__l.__size_;
    }
    if (v9 != size) {
      goto LABEL_54;
    }
    CFRange v11 = (const void **)(a1 + 120);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v12 = &v112;
    }
    else {
      uint64_t v12 = (std::string *)v112.__r_.__value_.__r.__words[0];
    }
    if ((v7 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 143))
      {
        uint64_t v13 = v12;
        while (*(unsigned __int8 *)v11 == v13->__r_.__value_.__s.__data_[0])
        {
          CFRange v11 = (const void **)((char *)v11 + 1);
          uint64_t v13 = (std::string *)((char *)v13 + 1);
          if (!--v7) {
            goto LABEL_58;
          }
        }
        goto LABEL_54;
      }
LABEL_58:
      unint64_t v23 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v115 = *(void *)&buf[16];
        uint64_t v24 = __p;
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v24 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Already have %s loaded for %{public}s operator preferences", buf, 0x16u);
        if (SHIBYTE(v115) < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)std::string buf = 0;
      __int16 v21 = sub_100058198((const void **)buf, (const void **)(a1 + 112));
      uint64_t v25 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = *(void *)buf;
      *(void *)std::string buf = v25;
      goto LABEL_57;
    }
    if (!memcmp(*v11, v12, *(void *)(a1 + 128))) {
      goto LABEL_58;
    }
LABEL_54:
    sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
    uint64_t v20 = (void *)(a1 + 48);
    if ((void **)(a1 + 48) != __p)
    {
      *(void *)std::string buf = *v20;
      void *v20 = __p[0];
      __p[0] = 0;
      sub_100057D78((const void **)buf);
    }
    __int16 v21 = (const void **)__p;
LABEL_57:
    sub_100057D78(v21);
    unsigned int v22 = (std::string *)(a1 + 56);
LABEL_134:
    std::string::operator=(v22, &v112);
    goto LABEL_135;
  }
  if (CFEqual(a2, kCarrier2BundleId))
  {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 175);
    if (*(char *)(a1 + 175) < 0)
    {
      if (!*(void *)(a1 + 160)) {
        goto LABEL_84;
      }
    }
    else if (!*(unsigned char *)(a1 + 175))
    {
      goto LABEL_84;
    }
    if ((v8 & 0x80u) == 0) {
      uint64_t v15 = *(unsigned __int8 *)(a1 + 175);
    }
    else {
      uint64_t v15 = *(void *)(a1 + 160);
    }
    std::string::size_type v16 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v16 = v112.__r_.__value_.__l.__size_;
    }
    if (v15 != v16) {
      goto LABEL_84;
    }
    unint64_t v17 = (const void **)(a1 + 152);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v18 = &v112;
    }
    else {
      uint64_t v18 = (std::string *)v112.__r_.__value_.__r.__words[0];
    }
    if ((v8 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 175))
      {
        uint64_t v19 = v18;
        while (*(unsigned __int8 *)v17 == v19->__r_.__value_.__s.__data_[0])
        {
          unint64_t v17 = (const void **)((char *)v17 + 1);
          uint64_t v19 = (std::string *)((char *)v19 + 1);
          if (!--v8) {
            goto LABEL_88;
          }
        }
        goto LABEL_84;
      }
LABEL_88:
      uint64_t v35 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v115 = *(void *)&buf[16];
        uint64_t v36 = __p;
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v36 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v36;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Already have %s loaded for %{public}s operator preferences", buf, 0x16u);
        if (SHIBYTE(v115) < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)std::string buf = 0;
      unsigned int v34 = sub_100058198((const void **)buf, (const void **)(a1 + 144));
      uint64_t v37 = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = *(void *)buf;
      *(void *)std::string buf = v37;
      goto LABEL_87;
    }
    if (!memcmp(*v17, v18, *(void *)(a1 + 160))) {
      goto LABEL_88;
    }
LABEL_84:
    sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
    uint64_t v33 = (void *)(a1 + 80);
    if ((void **)(a1 + 80) != __p)
    {
      *(void *)std::string buf = *v33;
      *uint64_t v33 = __p[0];
      __p[0] = 0;
      sub_100057D78((const void **)buf);
    }
    unsigned int v34 = (const void **)__p;
LABEL_87:
    sub_100057D78(v34);
    unsigned int v22 = (std::string *)(a1 + 88);
    goto LABEL_134;
  }
  if (CFEqual(a2, kOperator1BundleId))
  {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 79);
    if (*(char *)(a1 + 79) < 0)
    {
      if (!*(void *)(a1 + 64)) {
        goto LABEL_114;
      }
    }
    else if (!*(unsigned char *)(a1 + 79))
    {
      goto LABEL_114;
    }
    if ((v14 & 0x80u) == 0) {
      uint64_t v28 = *(unsigned __int8 *)(a1 + 79);
    }
    else {
      uint64_t v28 = *(void *)(a1 + 64);
    }
    std::string::size_type v29 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v29 = v112.__r_.__value_.__l.__size_;
    }
    if (v28 != v29) {
      goto LABEL_114;
    }
    int v30 = (const void **)(a1 + 56);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      __int16 v31 = &v112;
    }
    else {
      __int16 v31 = (std::string *)v112.__r_.__value_.__r.__words[0];
    }
    if ((v14 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 79))
      {
        int v32 = v31;
        while (*(unsigned __int8 *)v30 == v32->__r_.__value_.__s.__data_[0])
        {
          int v30 = (const void **)((char *)v30 + 1);
          int v32 = (std::string *)((char *)v32 + 1);
          if (!--v14) {
            goto LABEL_118;
          }
        }
        goto LABEL_114;
      }
LABEL_118:
      char v46 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v115 = *(void *)&buf[16];
        uint64_t v47 = __p;
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v47 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v47;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Already have %s loaded for %{public}s carrier preferences", buf, 0x16u);
        if (SHIBYTE(v115) < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)std::string buf = 0;
      char v45 = sub_100058198((const void **)buf, (const void **)(a1 + 48));
      uint64_t v48 = *(void *)(a1 + 112);
      *(void *)(a1 + 112) = *(void *)buf;
      *(void *)std::string buf = v48;
      goto LABEL_117;
    }
    if (!memcmp(*v30, v31, *(void *)(a1 + 64))) {
      goto LABEL_118;
    }
LABEL_114:
    sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
    CFTypeRef v44 = (void *)(a1 + 112);
    if ((void **)(a1 + 112) != __p)
    {
      *(void *)std::string buf = *v44;
      *CFTypeRef v44 = __p[0];
      __p[0] = 0;
      sub_100057D78((const void **)buf);
    }
    char v45 = (const void **)__p;
LABEL_117:
    sub_100057D78(v45);
    unsigned int v22 = (std::string *)(a1 + 120);
    goto LABEL_134;
  }
  if (CFEqual(a2, kOperator2BundleId))
  {
    uint64_t v26 = *(unsigned __int8 *)(a1 + 111);
    if (*(char *)(a1 + 111) < 0) {
      uint64_t v27 = *(void *)(a1 + 96);
    }
    else {
      uint64_t v27 = *(unsigned __int8 *)(a1 + 111);
    }
    if (v27)
    {
      if ((v26 & 0x80u) == 0) {
        uint64_t v39 = *(unsigned __int8 *)(a1 + 111);
      }
      else {
        uint64_t v39 = *(void *)(a1 + 96);
      }
      std::string::size_type v40 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
      if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v40 = v112.__r_.__value_.__l.__size_;
      }
      if (v39 == v40)
      {
        uint64_t v41 = (const void **)(a1 + 88);
        if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned int v42 = &v112;
        }
        else {
          unsigned int v42 = (std::string *)v112.__r_.__value_.__r.__words[0];
        }
        if ((v26 & 0x80) == 0)
        {
          if (*(unsigned char *)(a1 + 111))
          {
            uint64_t v43 = v42;
            while (*(unsigned __int8 *)v41 == v43->__r_.__value_.__s.__data_[0])
            {
              uint64_t v41 = (const void **)((char *)v41 + 1);
              uint64_t v43 = (std::string *)((char *)v43 + 1);
              if (!--v26) {
                goto LABEL_138;
              }
            }
            goto LABEL_130;
          }
LABEL_138:
          unint64_t v51 = *(NSObject **)(a1 + 32);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            uint64_t v115 = *(void *)&buf[16];
            long long v52 = __p;
            if ((buf[23] & 0x80u) != 0) {
              long long v52 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v42;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v52;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Already have %s loaded for %{public}s carrier preferences", buf, 0x16u);
            if (SHIBYTE(v115) < 0) {
              operator delete(__p[0]);
            }
          }
          *(void *)std::string buf = 0;
          unint64_t v50 = sub_100058198((const void **)buf, (const void **)(a1 + 80));
          uint64_t v53 = *(void *)(a1 + 144);
          *(void *)(a1 + 144) = *(void *)buf;
          *(void *)std::string buf = v53;
LABEL_133:
          sub_100057D78(v50);
          unsigned int v22 = (std::string *)(a1 + 152);
          goto LABEL_134;
        }
        if (!memcmp(*v41, v42, *(void *)(a1 + 96))) {
          goto LABEL_138;
        }
      }
    }
LABEL_130:
    sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
    __int16 v49 = (void *)(a1 + 144);
    if ((void **)(a1 + 144) != __p)
    {
      *(void *)std::string buf = *v49;
      *__int16 v49 = __p[0];
      __p[0] = 0;
      sub_100057D78((const void **)buf);
    }
    unint64_t v50 = (const void **)__p;
    goto LABEL_133;
  }
  if (!CFEqual(a2, kDefaultBundleId))
  {
    if (CFEqual(a2, kBootstrapBundleId))
    {
      sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
      char v38 = (void **)(a1 + 184);
      goto LABEL_126;
    }
    if (CFEqual(a2, kCarrier1CountryBundleId))
    {
      uint64_t v54 = *(unsigned __int8 *)(a1 + 287);
      if (*(char *)(a1 + 287) < 0) {
        uint64_t v55 = *(void *)(a1 + 272);
      }
      else {
        uint64_t v55 = *(unsigned __int8 *)(a1 + 287);
      }
      if (v55)
      {
        if ((v54 & 0x80u) == 0) {
          uint64_t v58 = *(unsigned __int8 *)(a1 + 287);
        }
        else {
          uint64_t v58 = *(void *)(a1 + 272);
        }
        std::string::size_type v59 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
        if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v59 = v112.__r_.__value_.__l.__size_;
        }
        if (v58 == v59)
        {
          uint64_t v60 = (const void **)(a1 + 264);
          if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v61 = &v112;
          }
          else {
            char v61 = (std::string *)v112.__r_.__value_.__r.__words[0];
          }
          if ((v54 & 0x80) == 0)
          {
            if (*(unsigned char *)(a1 + 287))
            {
              unsigned int v62 = v61;
              while (*(unsigned __int8 *)v60 == v62->__r_.__value_.__s.__data_[0])
              {
                uint64_t v60 = (const void **)((char *)v60 + 1);
                unsigned int v62 = (std::string *)((char *)v62 + 1);
                if (!--v54) {
                  goto LABEL_199;
                }
              }
              goto LABEL_188;
            }
LABEL_199:
            CFURLRef v74 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136446466;
              *(void *)&uint8_t buf[4] = v61;
              *(_WORD *)&unsigned char buf[12] = 2114;
              *(void *)&buf[14] = a2;
              _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I Already have %{public}s loaded for %{public}@ country operator1 preferences", buf, 0x16u);
            }
            *(void *)std::string buf = 0;
            long long v75 = sub_100058198((const void **)buf, (const void **)(a1 + 256));
            uint64_t v76 = *(void *)(a1 + 192);
            *(void *)(a1 + 192) = *(void *)buf;
            *(void *)std::string buf = v76;
            sub_100057D78(v75);
LABEL_202:
            unsigned int v22 = (std::string *)(a1 + 200);
            goto LABEL_134;
          }
          if (!memcmp(*v60, v61, *(void *)(a1 + 272))) {
            goto LABEL_199;
          }
        }
      }
LABEL_188:
      sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
      long long v70 = (const void **)(a1 + 192);
      if ((void **)(a1 + 192) != __p)
      {
        *(void *)std::string buf = *v70;
        *long long v70 = __p[0];
        __p[0] = 0;
        sub_100057D78((const void **)buf);
      }
      sub_100057D78((const void **)__p);
      if (*v70) {
        uint64_t v71 = sub_100080778;
      }
      else {
        uint64_t v71 = 0;
      }
      if (!v71)
      {
        __p[0] = 0;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          uint64_t v73 = __p[0];
          __p[0] = Mutable;
          *(void *)std::string buf = v73;
          sub_10005717C((const void **)buf);
        }
        sub_10004EFE4(&v113, (CFTypeRef *)__p);
        if (v70 != &v113)
        {
          *(void *)std::string buf = *v70;
          *long long v70 = v113;
          v113 = 0;
          sub_100057D78((const void **)buf);
        }
        sub_100057D78(&v113);
        sub_10005717C((const void **)__p);
      }
      goto LABEL_202;
    }
    if (CFEqual(a2, kCarrier2CountryBundleId))
    {
      uint64_t v56 = *(unsigned __int8 *)(a1 + 319);
      if (*(char *)(a1 + 319) < 0) {
        uint64_t v57 = *(void *)(a1 + 304);
      }
      else {
        uint64_t v57 = *(unsigned __int8 *)(a1 + 319);
      }
      if (v57)
      {
        if ((v56 & 0x80u) == 0) {
          uint64_t v65 = *(unsigned __int8 *)(a1 + 319);
        }
        else {
          uint64_t v65 = *(void *)(a1 + 304);
        }
        std::string::size_type v66 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
        if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v66 = v112.__r_.__value_.__l.__size_;
        }
        if (v65 == v66)
        {
          uint64_t v67 = (const void **)(a1 + 296);
          if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v68 = &v112;
          }
          else {
            uint64_t v68 = (std::string *)v112.__r_.__value_.__r.__words[0];
          }
          if ((v56 & 0x80) == 0)
          {
            if (*(unsigned char *)(a1 + 319))
            {
              long long v69 = v68;
              while (*(unsigned __int8 *)v67 == v69->__r_.__value_.__s.__data_[0])
              {
                uint64_t v67 = (const void **)((char *)v67 + 1);
                long long v69 = (std::string *)((char *)v69 + 1);
                if (!--v56) {
                  goto LABEL_235;
                }
              }
              goto LABEL_224;
            }
LABEL_235:
            long long v88 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136446466;
              *(void *)&uint8_t buf[4] = v68;
              *(_WORD *)&unsigned char buf[12] = 2114;
              *(void *)&buf[14] = a2;
              _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I Already have %{public}s loaded for %{public}@ country operator2 preferences", buf, 0x16u);
            }
            *(void *)std::string buf = 0;
            CFTypeRef v89 = sub_100058198((const void **)buf, (const void **)(a1 + 288));
            uint64_t v90 = *(void *)(a1 + 224);
            *(void *)(a1 + 224) = *(void *)buf;
            *(void *)std::string buf = v90;
            sub_100057D78(v89);
LABEL_238:
            unsigned int v22 = (std::string *)(a1 + 232);
            goto LABEL_134;
          }
          if (!memcmp(*v67, v68, *(void *)(a1 + 304))) {
            goto LABEL_235;
          }
        }
      }
LABEL_224:
      sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
      long long v84 = (const void **)(a1 + 224);
      if ((void **)(a1 + 224) != __p)
      {
        *(void *)std::string buf = *v84;
        *long long v84 = __p[0];
        __p[0] = 0;
        sub_100057D78((const void **)buf);
      }
      sub_100057D78((const void **)__p);
      if (*v84) {
        CFDictionaryRef v85 = sub_100080778;
      }
      else {
        CFDictionaryRef v85 = 0;
      }
      if (!v85)
      {
        __p[0] = 0;
        CFMutableDictionaryRef v86 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v86)
        {
          long long v87 = __p[0];
          __p[0] = v86;
          *(void *)std::string buf = v87;
          sub_10005717C((const void **)buf);
        }
        sub_10004EFE4(&v113, (CFTypeRef *)__p);
        if (v84 != &v113)
        {
          *(void *)std::string buf = *v84;
          *long long v84 = v113;
          v113 = 0;
          sub_100057D78((const void **)buf);
        }
        sub_100057D78(&v113);
        sub_10005717C((const void **)__p);
      }
      goto LABEL_238;
    }
    if (CFEqual(a2, kOperator1CountryBundleId))
    {
      uint64_t v63 = *(unsigned __int8 *)(a1 + 223);
      if (*(char *)(a1 + 223) < 0) {
        uint64_t v64 = *(void *)(a1 + 208);
      }
      else {
        uint64_t v64 = *(unsigned __int8 *)(a1 + 223);
      }
      if (v64)
      {
        if ((v63 & 0x80u) == 0) {
          uint64_t v79 = *(unsigned __int8 *)(a1 + 223);
        }
        else {
          uint64_t v79 = *(void *)(a1 + 208);
        }
        std::string::size_type v80 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
        if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v80 = v112.__r_.__value_.__l.__size_;
        }
        if (v79 == v80)
        {
          long long v81 = (const void **)(a1 + 200);
          if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v82 = &v112;
          }
          else {
            long long v82 = (std::string *)v112.__r_.__value_.__r.__words[0];
          }
          if ((v63 & 0x80) == 0)
          {
            if (*(unsigned char *)(a1 + 223))
            {
              uint64_t v83 = v82;
              while (*(unsigned __int8 *)v81 == v83->__r_.__value_.__s.__data_[0])
              {
                long long v81 = (const void **)((char *)v81 + 1);
                uint64_t v83 = (std::string *)((char *)v83 + 1);
                if (!--v63) {
                  goto LABEL_268;
                }
              }
              goto LABEL_257;
            }
LABEL_268:
            long long v100 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136446466;
              *(void *)&uint8_t buf[4] = v82;
              *(_WORD *)&unsigned char buf[12] = 2114;
              *(void *)&buf[14] = a2;
              _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I Already have %{public}s loaded for %{public}@ country carrier1 preferences", buf, 0x16u);
            }
            *(void *)std::string buf = 0;
            uint64_t v101 = sub_100058198((const void **)buf, (const void **)(a1 + 192));
            uint64_t v102 = *(void *)(a1 + 256);
            *(void *)(a1 + 256) = *(void *)buf;
            *(void *)std::string buf = v102;
            sub_100057D78(v101);
LABEL_271:
            unsigned int v22 = (std::string *)(a1 + 264);
            goto LABEL_134;
          }
          if (!memcmp(*v81, v82, *(void *)(a1 + 208))) {
            goto LABEL_268;
          }
        }
      }
LABEL_257:
      sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
      CFDictionaryRef v96 = (const void **)(a1 + 256);
      if ((void **)(a1 + 256) != __p)
      {
        *(void *)std::string buf = *v96;
        *CFDictionaryRef v96 = __p[0];
        __p[0] = 0;
        sub_100057D78((const void **)buf);
      }
      sub_100057D78((const void **)__p);
      if (*v96) {
        CFDictionaryRef v97 = sub_100080778;
      }
      else {
        CFDictionaryRef v97 = 0;
      }
      if (!v97)
      {
        __p[0] = 0;
        CFMutableDictionaryRef v98 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v98)
        {
          long long v99 = __p[0];
          __p[0] = v98;
          *(void *)std::string buf = v99;
          sub_10005717C((const void **)buf);
        }
        sub_10004EFE4(&v113, (CFTypeRef *)__p);
        if (v96 != &v113)
        {
          *(void *)std::string buf = *v96;
          *CFDictionaryRef v96 = v113;
          v113 = 0;
          sub_100057D78((const void **)buf);
        }
        sub_100057D78(&v113);
        sub_10005717C((const void **)__p);
      }
      goto LABEL_271;
    }
    if (!CFEqual(a2, kOperator2CountryBundleId)) {
      goto LABEL_135;
    }
    uint64_t v77 = *(unsigned __int8 *)(a1 + 255);
    if (*(char *)(a1 + 255) < 0) {
      uint64_t v78 = *(void *)(a1 + 240);
    }
    else {
      uint64_t v78 = *(unsigned __int8 *)(a1 + 255);
    }
    if (!v78) {
      goto LABEL_273;
    }
    if ((v77 & 0x80u) == 0) {
      uint64_t v91 = *(unsigned __int8 *)(a1 + 255);
    }
    else {
      uint64_t v91 = *(void *)(a1 + 240);
    }
    std::string::size_type v92 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v92 = v112.__r_.__value_.__l.__size_;
    }
    if (v91 != v92) {
      goto LABEL_273;
    }
    int v93 = (const void **)(a1 + 232);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v94 = &v112;
    }
    else {
      unsigned int v94 = (std::string *)v112.__r_.__value_.__r.__words[0];
    }
    if ((v77 & 0x80) != 0)
    {
      if (memcmp(*v93, v94, *(void *)(a1 + 240)))
      {
LABEL_273:
        sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
        CFTypeID v103 = (const void **)(a1 + 288);
        if ((void **)(a1 + 288) != __p)
        {
          *(void *)std::string buf = *v103;
          *CFTypeID v103 = __p[0];
          __p[0] = 0;
          sub_100057D78((const void **)buf);
        }
        sub_100057D78((const void **)__p);
        if (*v103) {
          CFNumberRef v104 = sub_100080778;
        }
        else {
          CFNumberRef v104 = 0;
        }
        if (!v104)
        {
          __p[0] = 0;
          CFMutableDictionaryRef v105 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v105)
          {
            int v106 = __p[0];
            __p[0] = v105;
            *(void *)std::string buf = v106;
            sub_10005717C((const void **)buf);
          }
          sub_10004EFE4(&v113, (CFTypeRef *)__p);
          if (v103 != &v113)
          {
            *(void *)std::string buf = *v103;
            *CFTypeID v103 = v113;
            v113 = 0;
            sub_100057D78((const void **)buf);
          }
          sub_100057D78(&v113);
          sub_10005717C((const void **)__p);
        }
        goto LABEL_287;
      }
    }
    else if (*(unsigned char *)(a1 + 255))
    {
      v95 = v94;
      while (*(unsigned __int8 *)v93 == v95->__r_.__value_.__s.__data_[0])
      {
        int v93 = (const void **)((char *)v93 + 1);
        v95 = (std::string *)((char *)v95 + 1);
        if (!--v77) {
          goto LABEL_284;
        }
      }
      goto LABEL_273;
    }
LABEL_284:
    unsigned int v107 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136446466;
      *(void *)&uint8_t buf[4] = v94;
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = a2;
      _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I Already have %{public}s loaded for %{public}@ country carrier2 preferences", buf, 0x16u);
    }
    *(void *)std::string buf = 0;
    v108 = sub_100058198((const void **)buf, (const void **)(a1 + 224));
    uint64_t v109 = *(void *)(a1 + 288);
    *(void *)(a1 + 288) = *(void *)buf;
    *(void *)std::string buf = v109;
    sub_100057D78(v108);
LABEL_287:
    unsigned int v22 = (std::string *)(a1 + 296);
    goto LABEL_134;
  }
  sub_1006CDDB0(__p, v116, (std::string::size_type)&v112);
  char v38 = (void **)(a1 + 176);
LABEL_126:
  if (v38 != __p)
  {
    *(void *)std::string buf = *v38;
    const char *v38 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
  }
  sub_100057D78((const void **)__p);
LABEL_135:
  os_unfair_lock_unlock(v4);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
}

void sub_1006C8610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15)
{
  if (a2)
  {
    sub_10005717C(&a15);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006C8688(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  int v5 = *(unsigned __int8 *)(a1 + 320);
  if (v5 != a2)
  {
    unsigned int v6 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = "true";
      if (v5) {
        uint64_t v8 = "true";
      }
      else {
        uint64_t v8 = "false";
      }
      if (!a2) {
        uint64_t v7 = "false";
      }
      int v9 = 136315394;
      uint64_t v10 = v8;
      __int16 v11 = 2080;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Bootstrap active is changing from %s to %s", (uint8_t *)&v9, 0x16u);
    }
    *(unsigned char *)(a1 + 320) = a2;
  }
  os_unfair_lock_unlock(v4);
}

uint64_t sub_1006C8788(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (*(unsigned char *)(a1 + 320))
  {
    int v5 = (uint64_t *)&kBootstrapBundleId;
  }
  else
  {
    int v5 = (uint64_t *)&kCarrier2BundleId;
    if (a2 != 2) {
      int v5 = (uint64_t *)&kCarrier1BundleId;
    }
  }
  uint64_t v6 = *v5;
  os_unfair_lock_unlock(v4);
  return v6;
}

uint64_t sub_1006C87FC(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t CFSimSlotBundlePrefsDomain = getCFSimSlotBundlePrefsDomain(a2, a3);
  __int16 v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24);

  return v11(a1, CFSimSlotBundlePrefsDomain, a4, a5, a6);
}

uint64_t sub_1006C8890(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1006C8788(a1, a2);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 32);

  return v8(a1, v7, a3, a4, 0);
}

uint64_t sub_1006C8910(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1006C8788(a1, a2);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 16);

  return v8(a1, v7, a3, a4, 0);
}

uint64_t sub_1006C8990(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1006C8788(a1, a2);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 40);

  return v8(a1, v7, a3, a4, 0);
}

uint64_t sub_1006C8A10(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1006C8788(a1, a2);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 24);

  return v8(a1, v7, a3, a4, 0);
}

void sub_1006C8A90(uint64_t a1@<X0>, const __CFString *a2@<X1>, const __CFArray *a3@<X2>, int a4@<W3>, const void **a5@<X8>)
{
  if (a2)
  {
    CFDictionaryRef theDict = 0;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
    if (!*(unsigned char *)(a1 + 344))
    {
      uint64_t v10 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 138543618;
        *(void *)&uint8_t buf[4] = a3;
        __int16 v51 = 2114;
        CFArrayRef v52 = (const __CFArray *)a2;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Initialization not yet complete when reading %{public}@ from bundle %{public}@", buf, 0x16u);
      }
    }
    sub_100057E00((const void **)&v49, a1, a2);
    CFDictionaryRef v11 = theDict;
    CFDictionaryRef theDict = v49;
    CFMutableDictionaryRef v49 = 0;
    *(void *)std::string buf = v11;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v49);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
    *a5 = 0;
    if (theDict) {
      uint64_t v12 = sub_100080778;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v12)
    {
      CFIndex Count = CFArrayGetCount(a3);
      CFMutableDictionaryRef v49 = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableDictionaryRef v15 = v49;
        CFMutableDictionaryRef v49 = Mutable;
        *(void *)std::string buf = v15;
        sub_10005717C((const void **)buf);
      }
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a3, i);
          CFStringRef Value = CFDictionaryGetValue(theDict, ValueAtIndex);
          if (Value) {
            CFDictionarySetValue(v49, ValueAtIndex, Value);
          }
        }
      }
      sub_10004EFE4(&v47, (CFTypeRef *)&v49);
      if (&v47 != a5)
      {
        *(void *)std::string buf = *a5;
        *a5 = v47;
        uint64_t v47 = 0;
        sub_100057D78((const void **)buf);
      }
      sub_100057D78(&v47);
      sub_10005717C((const void **)&v49);
LABEL_61:
      sub_100057D78((const void **)&theDict);
      return;
    }
    if (CFEqual(a2, kCellularDataBundleId))
    {
      CFStringRef v20 = (const __CFString *)kCarrier1BundleId;
LABEL_56:
      uint64_t v43 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 138543874;
        *(void *)&uint8_t buf[4] = a2;
        __int16 v51 = 2114;
        CFArrayRef v52 = a3;
        __int16 v53 = 2112;
        CFStringRef v54 = v20;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "Pref file not loaded for %{public}@, looking for key %{public}@, reading from %@", buf, 0x20u);
      }
      CFStringRef v44 = (const __CFString *)sub_1003F26E0();
      if (a4) {
        CFPreferencesSynchronize(v20, v44, kCFPreferencesAnyHost);
      }
      CFDictionaryRef v45 = CFPreferencesCopyMultiple(a3, v20, v44, kCFPreferencesAnyHost);
      char v46 = *a5;
      *a5 = v45;
      *(void *)std::string buf = v46;
      sub_100057D78((const void **)buf);
      goto LABEL_61;
    }
    if (CFEqual(a2, kCarrierBundleId))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
      unsigned int v22 = ServiceMap;
      if (v23 < 0)
      {
        uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v25 = 5381;
        do
        {
          uint64_t v23 = v25;
          unsigned int v26 = *v24++;
          uint64_t v25 = (33 * v25) ^ v26;
        }
        while (v26);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v23;
      uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
      if (v27)
      {
        uint64_t v29 = v27[3];
        uint64_t v28 = (std::__shared_weak_count *)v27[4];
        if (v28)
        {
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v22);
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v28);
          char v30 = 0;
          goto LABEL_40;
        }
      }
      else
      {
        uint64_t v29 = 0;
      }
      std::mutex::unlock(v22);
      uint64_t v28 = 0;
      char v30 = 1;
LABEL_40:
      if (v29)
      {
        int v39 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 776))(v29);
        std::string::size_type v40 = (const __CFString **)&kCarrier2BundleId;
        uint64_t v41 = (const __CFString **)&kCarrier1BundleId;
LABEL_48:
        if (v39 != 2) {
          std::string::size_type v40 = v41;
        }
        CFStringRef v20 = *v40;
        goto LABEL_54;
      }
      unsigned int v42 = *(NSObject **)(a1 + 32);
      CFStringRef v20 = a2;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
LABEL_53:
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#N DataServiceInterface not found.", buf, 2u);
        CFStringRef v20 = a2;
        goto LABEL_54;
      }
      goto LABEL_54;
    }
    CFStringRef v20 = a2;
    if (!CFEqual(a2, kOperatorBundleId)) {
      goto LABEL_56;
    }
    __int16 v31 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
    int v32 = v31;
    if (v33 < 0)
    {
      unsigned int v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v35 = 5381;
      do
      {
        uint64_t v33 = v35;
        unsigned int v36 = *v34++;
        uint64_t v35 = (33 * v35) ^ v36;
      }
      while (v36);
    }
    std::mutex::lock(v31);
    *(void *)std::string buf = v33;
    uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)buf);
    if (v37)
    {
      uint64_t v38 = v37[3];
      uint64_t v28 = (std::__shared_weak_count *)v37[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v32);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        goto LABEL_46;
      }
    }
    else
    {
      uint64_t v38 = 0;
    }
    std::mutex::unlock(v32);
    uint64_t v28 = 0;
    char v30 = 1;
LABEL_46:
    if (v38)
    {
      int v39 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 776))(v38);
      std::string::size_type v40 = (const __CFString **)&kOperator2BundleId;
      uint64_t v41 = (const __CFString **)&kOperator1BundleId;
      goto LABEL_48;
    }
    unsigned int v42 = *(NSObject **)(a1 + 32);
    CFStringRef v20 = a2;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      goto LABEL_53;
    }
LABEL_54:
    if ((v30 & 1) == 0) {
      sub_10004D2C8(v28);
    }
    goto LABEL_56;
  }
  uint64_t v19 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = a3;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid bundle identifier when querying for %{public}@", buf, 0xCu);
  }
  *a5 = 0;
}

void sub_1006C906C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  sub_100057D78(v3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1006C90E8(void *a1@<X0>, int a2@<W1>, int a3@<W2>, const __CFArray *a4@<X3>, const __CFArray *a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  uint64_t CFSimSlotBundlePrefsDomain = getCFSimSlotBundlePrefsDomain(a2, a3);
  if (!CFSimSlotBundlePrefsDomain)
  {
    __int16 v21 = a1[4];
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
LABEL_19:
      *a7 = 0;
      return;
    }
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = a4;
    unsigned int v22 = "Invalid bundle identifier for copying keys: %{public}@";
LABEL_22:
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
    goto LABEL_19;
  }
  uint64_t v13 = CFSimSlotBundlePrefsDomain;
  CFIndex Count = CFArrayGetCount(a4);
  if (Count != CFArrayGetCount(a5))
  {
    __int16 v21 = a1[4];
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = a4;
    unsigned int v22 = "Count of keys and defaults not the same, unable to proceed copying keys: %{public}@.";
    goto LABEL_22;
  }
  CFDictionaryRef theDict = 0;
  CFMutableArrayRef theArray = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr, void *, uint64_t, const __CFArray *, uint64_t))(*a1 + 152))(&theDict, a1, v13, a4, a6);
  if (theDict) {
    CFMutableDictionaryRef v15 = sub_100080778;
  }
  else {
    CFMutableDictionaryRef v15 = 0;
  }
  if (v15)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      CFMutableArrayRef v17 = theArray;
      CFMutableArrayRef theArray = Mutable;
      *(void *)std::string buf = v17;
      sub_1000440D4((const void **)buf);
    }
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a4, i);
        if (CFDictionaryContainsKey(theDict, ValueAtIndex)) {
          CFStringRef Value = CFDictionaryGetValue(theDict, ValueAtIndex);
        }
        else {
          CFStringRef Value = CFArrayGetValueAtIndex(a5, i);
        }
        CFArraySetValueAtIndex(theArray, i, Value);
      }
    }
  }
  sub_100044D6C(a7, (CFTypeRef *)&theArray);
  sub_100057D78((const void **)&theDict);
  sub_1000440D4((const void **)&theArray);
}

void sub_1006C932C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000440D4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1006C9358(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, const __CFArray *a4@<X3>, const __CFArray *a5@<X4>, int a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  void (**v25)(uint8_t **__return_ptr, uint64_t *, uint64_t, void **, const void *, uint64_t);
  __CFArray *v26;
  uint8_t *v27;
  NSObject *v28;
  const char *v29;
  void *__p[2];
  uint64_t v32;
  CFMutableArrayRef v33;
  uint8_t *context;
  uint8_t buf[16];
  uint64_t v36;
  CFRange v37;

  uint64_t CFSimSlotBundlePrefsDomain = getCFSimSlotBundlePrefsDomain(a2, a3);
  if (!CFSimSlotBundlePrefsDomain)
  {
    uint64_t v28 = a1[4];
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
LABEL_22:
      *a8 = 0;
      return;
    }
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = a4;
    uint64_t v29 = "Invalid bundle identifier when copying key hierarchies: %{public}@";
LABEL_25:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
    goto LABEL_22;
  }
  uint64_t v14 = CFSimSlotBundlePrefsDomain;
  CFIndex Count = CFArrayGetCount(a4);
  if (Count != CFArrayGetCount(a5))
  {
    uint64_t v28 = a1[4];
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = a4;
    uint64_t v29 = "Count of key hierarchies and defaults not the same, unable to proceed copying key hierarchies: %{public}@.";
    goto LABEL_25;
  }
  uint64_t v33 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFMutableArrayRef v17 = v33;
    uint64_t v33 = Mutable;
    *(void *)std::string buf = v17;
    sub_1000440D4((const void **)buf);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a4, i);
      CFArrayRef v20 = ValueAtIndex;
      int v32 = 0;
      long long v21 = 0uLL;
      *(_OWORD *)std::string __p = 0u;
      unsigned int v36 = 0;
      *(_OWORD *)std::string buf = 0u;
      context = buf;
      if (ValueAtIndex)
      {
        v37.length = CFArrayGetCount(ValueAtIndex);
        v37.location = 0;
        CFArrayApplyFunction(v20, v37, (CFArrayApplierFunction)sub_1002CED68, &context);
        long long v21 = *(_OWORD *)buf;
        uint64_t v22 = v36;
      }
      else
      {
        uint64_t v22 = 0;
      }
      *(_OWORD *)std::string __p = v21;
      int v32 = v22;
      uint64_t v23 = CFArrayGetValueAtIndex(a5, i);
      context = 0;
      uint64_t v24 = *a1;
      if (a6) {
        uint64_t v25 = (void (**)(uint8_t **__return_ptr, uint64_t *, uint64_t, void **, const void *, uint64_t))(v24 + 16);
      }
      else {
        uint64_t v25 = (void (**)(uint8_t **__return_ptr, uint64_t *, uint64_t, void **, const void *, uint64_t))(v24 + 24);
      }
      (*v25)(&context, a1, v14, __p, v23, a7);
      unsigned int v26 = v33;
      uint64_t v27 = context;
      *(void *)std::string buf = context;
      if (context)
      {
        CFRetain(context);
        CFArrayAppendValue(v26, v27);
      }
      sub_10010F494((const void **)buf);
      sub_1000577C4((const void **)&context);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
  }
  sub_100044D6C(a8, (CFTypeRef *)&v33);
  sub_1000440D4((const void **)&v33);
}

void sub_1006C962C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
}

void sub_1006C9694(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, const __CFArray *a4@<X3>, const __CFArray *a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  uint64_t CFSimSlotBundlePrefsDomain = getCFSimSlotBundlePrefsDomain(a2, a3);
  if (!CFSimSlotBundlePrefsDomain)
  {
    __int16 v51 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
LABEL_57:
      *a7 = 0;
      return;
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = a4;
    CFArrayRef v52 = "Invalid bundle identifier for copying keys: %{public}@";
LABEL_110:
    _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, v52, (uint8_t *)&buf, 0xCu);
    goto LABEL_57;
  }
  uint64_t v13 = (const void *)CFSimSlotBundlePrefsDomain;
  CFIndex Count = CFArrayGetCount(a4);
  if (Count != CFArrayGetCount(a5))
  {
    __int16 v51 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = a4;
    CFArrayRef v52 = "Count of keys and defaults not the same, unable to proceed copying keys: %{public}@.";
    goto LABEL_110;
  }
  CFDictionaryRef MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, Count, a5);
  *(void *)&long long buf = &buf;
  *((void *)&buf + 1) = &buf;
  uint64_t v98 = 0;
  CFDictionaryRef theDict = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, const void *, const __CFArray *, uint64_t))(*(void *)a1 + 152))(&theDict, a1, v13, a4, a6);
  if (theDict) {
    CFMutableDictionaryRef v15 = sub_100080778;
  }
  else {
    CFMutableDictionaryRef v15 = 0;
  }
  if (v15)
  {
    if (Count)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(a4, i);
        if (CFDictionaryContainsKey(theDict, ValueAtIndex))
        {
          CFStringRef Value = CFDictionaryGetValue(theDict, ValueAtIndex);
          CFArraySetValueAtIndex(MutableCopy, i, Value);
          if (!Value) {
            continue;
          }
          CFTypeID v19 = CFGetTypeID(Value);
          if (v19 != CFDictionaryGetTypeID()) {
            continue;
          }
        }
        CFArrayRef v20 = operator new(0x18uLL);
        v20[1] = &buf;
        xpc_object_t v20[2] = i;
        uint64_t v21 = buf;
        void *v20 = buf;
        *(void *)(v21 + 8) = v20;
        *(void *)&long long buf = v20;
        ++v98;
      }
    }
    if (!v98)
    {
      sub_100044D6C(a7, (CFTypeRef *)&MutableCopy);
      sub_100057D78((const void **)&theDict);
      goto LABEL_105;
    }
  }
  sub_100057D78((const void **)&theDict);
  CFStringRef CarrierOrOperatorBundleIDForBundleID = (const __CFString *)getCarrierOrOperatorBundleIDForBundleID((Registry **)(a1 + 328), v13);
  unsigned int v94 = 0;
  uint64_t CountryBundleIdFromCarrierOrOperatorBundleId = getCountryBundleIdFromCarrierOrOperatorBundleId(CarrierOrOperatorBundleIDForBundleID);
  if (CountryBundleIdFromCarrierOrOperatorBundleId)
  {
    CFArrayRef v93 = 0;
    (*(void (**)(const __CFArray **__return_ptr, uint64_t, uint64_t, const __CFArray *, uint64_t))(*(void *)a1 + 152))(&v93, a1, CountryBundleIdFromCarrierOrOperatorBundleId, a4, a6);
    if (v93) {
      uint64_t v24 = sub_100080778;
    }
    else {
      uint64_t v24 = 0;
    }
    if (v24)
    {
      CFDictionaryRef theDict = 0;
      CFDictionaryRef v91 = 0;
      uint64_t v92 = 0;
      uint64_t v25 = *((void *)&buf + 1);
      theArray[0] = a4;
      theArray[1] = v93;
      if (v93) {
        CFRetain(v93);
      }
      CFArrayRef v86 = MutableCopy;
      if (MutableCopy) {
        CFRetain(MutableCopy);
      }
      p_CFDictionaryRef theDict = &theDict;
      long long v87 = &theDict;
      if ((long long *)v25 != &buf)
      {
        do
        {
          CFIndex v27 = *(void *)(v25 + 16);
          uint64_t v28 = CFArrayGetValueAtIndex(theArray[0], v27);
          if (CFDictionaryContainsKey(theArray[1], v28))
          {
            CFDictionaryRef v29 = (const __CFDictionary *)CFDictionaryGetValue(theArray[1], v28);
            CFDictionaryRef v30 = v29;
            if (v29 && (CFTypeID v31 = CFGetTypeID(v29), v31 == CFDictionaryGetTypeID()))
            {
              CFDictionaryRef v32 = (const __CFDictionary *)CFArrayGetValueAtIndex(v86, v27);
              CFDictionaryRef v33 = v32;
              if (v32 && (CFTypeID v34 = CFGetTypeID(v32), v34 == CFDictionaryGetTypeID()))
              {
                CFDictionaryRef v96 = 0;
                copyMergedDictionaries(v33, v30, &v96);
                CFArraySetValueAtIndex(v86, v27, v96);
                sub_100057D78(&v96);
              }
              else
              {
                CFArraySetValueAtIndex(v86, v27, v30);
              }
            }
            else
            {
              uint64_t v35 = v87;
              unsigned int v36 = v87[1];
              CFDictionaryRef v37 = v87[2];
              if (v36 >= (void *)v37)
              {
                CFDictionaryRef v39 = *v87;
                uint64_t v40 = ((char *)v36 - (char *)*v87) >> 3;
                unint64_t v41 = v40 + 1;
                if ((unint64_t)(v40 + 1) >> 61) {
                  sub_10006A748();
                }
                uint64_t v42 = v37 - v39;
                if (v42 >> 2 > v41) {
                  unint64_t v41 = v42 >> 2;
                }
                if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v43 = v41;
                }
                if (v43)
                {
                  CFStringRef v44 = (char *)sub_10004EF74((uint64_t)(v87 + 2), v43);
                  CFDictionaryRef v39 = *v87;
                  unsigned int v36 = v87[1];
                }
                else
                {
                  CFStringRef v44 = 0;
                }
                CFDictionaryRef v45 = (CFIndex *)&v44[8 * v40];
                *CFDictionaryRef v45 = v27;
                CFDictionaryRef v38 = (const __CFDictionary *)(v45 + 1);
                while (v36 != (void *)v39)
                {
                  CFIndex v46 = *--v36;
                  *--CFDictionaryRef v45 = v46;
                }
                CFDictionaryRef *v35 = (CFDictionaryRef)v45;
                v35[1] = v38;
                v35[2] = (CFDictionaryRef)&v44[8 * v43];
                if (v39) {
                  operator delete(v39);
                }
              }
              else
              {
                *unsigned int v36 = v27;
                CFDictionaryRef v38 = (const __CFDictionary *)(v36 + 1);
              }
              v35[1] = v38;
              CFArraySetValueAtIndex(v86, v27, v30);
            }
          }
          uint64_t v25 = *(void *)(v25 + 8);
        }
        while ((long long *)v25 != &buf);
        p_CFDictionaryRef theDict = v87;
      }
      long long v88 = *(_OWORD *)theArray;
      CFArrayRef v47 = v86;
      theArray[1] = 0;
      CFArrayRef v86 = 0;
      v89[0] = v47;
      v89[1] = p_theDict;
      sub_1000440D4(v89);
      sub_100057D78((const void **)&v88 + 1);
      sub_1000440D4((const void **)&v86);
      sub_100057D78((const void **)&theArray[1]);
      CFDictionaryRef v48 = theDict;
      CFDictionaryRef v49 = v91;
      while (v48 != v49)
      {
        unint64_t v50 = *(const void **)v48;
        CFDictionaryRef v48 = (CFDictionaryRef)((char *)v48 + 8);
        CFDictionaryRef v96 = v50;
        sub_1006CD9A0(&buf, &v96);
      }
      if (!v98)
      {
        sub_100044D6C(a7, (CFTypeRef *)&MutableCopy);
        if (theDict)
        {
          CFDictionaryRef v91 = theDict;
          operator delete(theDict);
        }
        sub_100057D78((const void **)&v93);
        goto LABEL_103;
      }
      if (theDict)
      {
        CFDictionaryRef v91 = theDict;
        operator delete(theDict);
      }
    }
    sub_100057D78((const void **)&v93);
  }
  CFArrayRef v93 = 0;
  (*(void (**)(const __CFArray **__return_ptr, uint64_t, void, const __CFArray *, uint64_t))(*(void *)a1 + 152))(&v93, a1, kDefaultBundleId, a4, a6);
  if (v93) {
    __int16 v53 = sub_100080778;
  }
  else {
    __int16 v53 = 0;
  }
  if (v53)
  {
    CFDictionaryRef theDict = 0;
    CFDictionaryRef v91 = 0;
    uint64_t v92 = 0;
    uint64_t v54 = *((void *)&buf + 1);
    v80[0] = a4;
    v80[1] = v93;
    if (v93) {
      CFRetain(v93);
    }
    CFArrayRef v81 = MutableCopy;
    if (MutableCopy) {
      CFRetain(MutableCopy);
    }
    uint64_t v55 = &theDict;
    long long v82 = &theDict;
    if ((long long *)v54 != &buf)
    {
      do
      {
        CFIndex v56 = *(void *)(v54 + 16);
        uint64_t v57 = CFArrayGetValueAtIndex(a4, v56);
        if (CFDictionaryContainsKey(v80[1], v57))
        {
          CFDictionaryRef v58 = (const __CFDictionary *)CFDictionaryGetValue(v80[1], v57);
          CFDictionaryRef v59 = v58;
          if (v58
            && (CFTypeID v60 = CFGetTypeID(v58), v60 == CFDictionaryGetTypeID())
            && (CFDictionaryRef v61 = (const __CFDictionary *)CFArrayGetValueAtIndex(v81, v56), (v62 = v61) != 0)
            && (CFTypeID v63 = CFGetTypeID(v61), v63 == CFDictionaryGetTypeID()))
          {
            CFDictionaryRef v96 = 0;
            copyMergedDictionaries(v62, v59, &v96);
            CFArraySetValueAtIndex(v81, v56, v96);
            sub_100057D78(&v96);
          }
          else
          {
            CFArraySetValueAtIndex(v81, v56, v59);
          }
          uint64_t v64 = v82;
          uint64_t v65 = v82[1];
          CFDictionaryRef v66 = v82[2];
          if (v65 >= (void *)v66)
          {
            CFDictionaryRef v68 = *v82;
            uint64_t v69 = ((char *)v65 - (char *)*v82) >> 3;
            unint64_t v70 = v69 + 1;
            if ((unint64_t)(v69 + 1) >> 61) {
              sub_10006A748();
            }
            uint64_t v71 = v66 - v68;
            if (v71 >> 2 > v70) {
              unint64_t v70 = v71 >> 2;
            }
            if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v72 = v70;
            }
            if (v72)
            {
              uint64_t v73 = (char *)sub_10004EF74((uint64_t)(v82 + 2), v72);
              CFDictionaryRef v68 = *v82;
              uint64_t v65 = v82[1];
            }
            else
            {
              uint64_t v73 = 0;
            }
            CFURLRef v74 = (CFIndex *)&v73[8 * v69];
            *CFURLRef v74 = v56;
            CFDictionaryRef v67 = (const __CFDictionary *)(v74 + 1);
            while (v65 != (void *)v68)
            {
              CFIndex v75 = *--v65;
              *--CFURLRef v74 = v75;
            }
            *uint64_t v64 = (CFDictionaryRef)v74;
            v64[1] = v67;
            v64[2] = (CFDictionaryRef)&v73[8 * v72];
            if (v68) {
              operator delete(v68);
            }
          }
          else
          {
            void *v65 = v56;
            CFDictionaryRef v67 = (const __CFDictionary *)(v65 + 1);
          }
          v64[1] = v67;
        }
        uint64_t v54 = *(void *)(v54 + 8);
      }
      while ((long long *)v54 != &buf);
      uint64_t v55 = v82;
    }
    long long v83 = *(_OWORD *)v80;
    CFArrayRef v76 = v81;
    v80[1] = 0;
    CFArrayRef v81 = 0;
    v84[0] = v76;
    v84[1] = v55;
    sub_1000440D4(v84);
    sub_100057D78((const void **)&v83 + 1);
    sub_1000440D4((const void **)&v81);
    sub_100057D78((const void **)&v80[1]);
    CFDictionaryRef v77 = theDict;
    CFDictionaryRef v78 = v91;
    if (theDict != v91)
    {
      do
      {
        uint64_t v79 = *(const void **)v77;
        CFDictionaryRef v77 = (CFDictionaryRef)((char *)v77 + 8);
        CFDictionaryRef v96 = v79;
        sub_1006CD9A0(&buf, &v96);
      }
      while (v77 != v78);
      CFDictionaryRef v77 = theDict;
    }
    if (v77)
    {
      CFDictionaryRef v91 = v77;
      operator delete(v77);
    }
  }
  sub_100057D78((const void **)&v93);
  sub_100044D6C(a7, (CFTypeRef *)&MutableCopy);
LABEL_103:
  sub_1000577C4(&v94);
LABEL_105:
  sub_1006CDAA4(&buf);
  sub_1000440D4((const void **)&MutableCopy);
}

void sub_1006C9F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100057D78((const void **)(v29 - 160));
  sub_1000577C4((const void **)(v29 - 152));
  sub_1006CDAA4((void *)(v29 - 128));
  sub_1000440D4((const void **)(v29 - 144));
  _Unwind_Resume(a1);
}

BOOL sub_1006CA00C(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (a2 == 2)
  {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 111);
    size_t v6 = *(void *)(a1 + 96);
    if ((v5 & 0x80u) == 0) {
      uint64_t v7 = *(unsigned __int8 *)(a1 + 111);
    }
    else {
      uint64_t v7 = *(void *)(a1 + 96);
    }
    int v8 = *(char *)(a1 + 175);
    if (v8 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a1 + 175);
    }
    else {
      uint64_t v9 = *(void *)(a1 + 160);
    }
    if (v7 != v9) {
      goto LABEL_33;
    }
    uint64_t v10 = (const void **)(a1 + 88);
    uint64_t v13 = *(unsigned __int8 **)(a1 + 152);
    uint64_t v12 = (unsigned __int8 *)(a1 + 152);
    CFDictionaryRef v11 = v13;
    if (v8 >= 0) {
      uint64_t v14 = v12;
    }
    else {
      uint64_t v14 = v11;
    }
    if ((v5 & 0x80) == 0)
    {
      if (v5)
      {
        while (*(unsigned __int8 *)v10 == *v14)
        {
          uint64_t v10 = (const void **)((char *)v10 + 1);
          ++v14;
          if (!--v5) {
            goto LABEL_34;
          }
        }
        goto LABEL_33;
      }
LABEL_34:
      BOOL v21 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 79);
    size_t v6 = *(void *)(a1 + 64);
    if ((v15 & 0x80u) == 0) {
      uint64_t v16 = *(unsigned __int8 *)(a1 + 79);
    }
    else {
      uint64_t v16 = *(void *)(a1 + 64);
    }
    int v17 = *(char *)(a1 + 143);
    if (v17 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a1 + 143);
    }
    else {
      uint64_t v9 = *(void *)(a1 + 128);
    }
    if (v16 != v9) {
      goto LABEL_33;
    }
    uint64_t v10 = (const void **)(a1 + 56);
    CFArrayRef v20 = *(unsigned __int8 **)(a1 + 120);
    CFTypeID v19 = (unsigned __int8 *)(a1 + 120);
    uint64_t v18 = v20;
    if (v17 >= 0) {
      uint64_t v14 = v19;
    }
    else {
      uint64_t v14 = v18;
    }
    if ((v15 & 0x80) == 0)
    {
      if (v15)
      {
        while (*(unsigned __int8 *)v10 == *v14)
        {
          uint64_t v10 = (const void **)((char *)v10 + 1);
          ++v14;
          if (!--v15) {
            goto LABEL_34;
          }
        }
        goto LABEL_33;
      }
      goto LABEL_34;
    }
  }
  if (!memcmp(*v10, v14, v6)) {
    goto LABEL_34;
  }
LABEL_33:
  BOOL v21 = v9 != 0;
LABEL_35:
  os_unfair_lock_unlock(v4);
  return v21;
}

void sub_1006CA14C(uint64_t a1)
{
  id v2 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *(unsigned char *)(a1 + 344) = 1;
  CFDateRef v3 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v68) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Initialization complete", (uint8_t *)&v68, 2u);
  }
  char v4 = *(unsigned char *)(a1 + 79);
  if (v4 < 0) {
    uint64_t v5 = *(void *)(a1 + 64);
  }
  else {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 79);
  }
  size_t v6 = *(NSObject **)(a1 + 32);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_14;
    }
    int v8 = (void *)(a1 + 56);
    if (v4 < 0) {
      int v8 = (void *)*v8;
    }
    int v68 = 136315138;
    uint64_t v69 = v8;
    uint64_t v9 = "#I Carrier preferences path: %s";
    uint64_t v10 = v6;
    uint32_t v11 = 12;
  }
  else
  {
    if (!v7) {
      goto LABEL_14;
    }
    LOWORD(v68) = 0;
    uint64_t v9 = "#I Missing carrier preferences path";
    uint64_t v10 = v6;
    uint32_t v11 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v68, v11);
LABEL_14:
  char v12 = *(unsigned char *)(a1 + 111);
  if (v12 < 0) {
    uint64_t v13 = *(void *)(a1 + 96);
  }
  else {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 111);
  }
  uint64_t v14 = *(NSObject **)(a1 + 32);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (!v15) {
      goto LABEL_25;
    }
    uint64_t v16 = (void *)(a1 + 88);
    if (v12 < 0) {
      uint64_t v16 = (void *)*v16;
    }
    int v68 = 136315138;
    uint64_t v69 = v16;
    int v17 = "#I Carrier 2 preferences path: %s";
    uint64_t v18 = v14;
    uint32_t v19 = 12;
  }
  else
  {
    if (!v15) {
      goto LABEL_25;
    }
    LOWORD(v68) = 0;
    int v17 = "#I Missing carrier 2 preferences path";
    uint64_t v18 = v14;
    uint32_t v19 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v68, v19);
LABEL_25:
  char v20 = *(unsigned char *)(a1 + 143);
  if (v20 < 0) {
    uint64_t v21 = *(void *)(a1 + 128);
  }
  else {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 143);
  }
  uint64_t v22 = *(NSObject **)(a1 + 32);
  BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    if (!v23) {
      goto LABEL_36;
    }
    uint64_t v24 = (void *)(a1 + 120);
    if (v20 < 0) {
      uint64_t v24 = (void *)*v24;
    }
    int v68 = 136315138;
    uint64_t v69 = v24;
    uint64_t v25 = "#I Operator preferences path: %s";
    unsigned int v26 = v22;
    uint32_t v27 = 12;
  }
  else
  {
    if (!v23) {
      goto LABEL_36;
    }
    LOWORD(v68) = 0;
    uint64_t v25 = "#I Missing operator preferences path";
    unsigned int v26 = v22;
    uint32_t v27 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, (uint8_t *)&v68, v27);
LABEL_36:
  char v28 = *(unsigned char *)(a1 + 175);
  if (v28 < 0) {
    uint64_t v29 = *(void *)(a1 + 160);
  }
  else {
    uint64_t v29 = *(unsigned __int8 *)(a1 + 175);
  }
  CFDictionaryRef v30 = *(NSObject **)(a1 + 32);
  BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
  if (v29)
  {
    if (!v31) {
      goto LABEL_47;
    }
    CFDictionaryRef v32 = (void *)(a1 + 152);
    if (v28 < 0) {
      CFDictionaryRef v32 = (void *)*v32;
    }
    int v68 = 136315138;
    uint64_t v69 = v32;
    CFDictionaryRef v33 = "#I Operator 2 preferences path: %s";
    CFTypeID v34 = v30;
    uint32_t v35 = 12;
  }
  else
  {
    if (!v31) {
      goto LABEL_47;
    }
    LOWORD(v68) = 0;
    CFDictionaryRef v33 = "#I Missing operator 2 preferences path";
    CFTypeID v34 = v30;
    uint32_t v35 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)&v68, v35);
LABEL_47:
  char v36 = *(unsigned char *)(a1 + 223);
  if (v36 < 0) {
    uint64_t v37 = *(void *)(a1 + 208);
  }
  else {
    uint64_t v37 = *(unsigned __int8 *)(a1 + 223);
  }
  CFDictionaryRef v38 = *(NSObject **)(a1 + 32);
  BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
  if (v37)
  {
    if (!v39) {
      goto LABEL_58;
    }
    uint64_t v40 = (void *)(a1 + 200);
    if (v36 < 0) {
      uint64_t v40 = (void *)*v40;
    }
    int v68 = 136315138;
    uint64_t v69 = v40;
    unint64_t v41 = "#I Carrier country preferences path: %s";
    uint64_t v42 = v38;
    uint32_t v43 = 12;
  }
  else
  {
    if (!v39) {
      goto LABEL_58;
    }
    LOWORD(v68) = 0;
    unint64_t v41 = "#I Missing carrier country preferences path";
    uint64_t v42 = v38;
    uint32_t v43 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&v68, v43);
LABEL_58:
  char v44 = *(unsigned char *)(a1 + 255);
  if (v44 < 0) {
    uint64_t v45 = *(void *)(a1 + 240);
  }
  else {
    uint64_t v45 = *(unsigned __int8 *)(a1 + 255);
  }
  CFIndex v46 = *(NSObject **)(a1 + 32);
  BOOL v47 = os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT);
  if (v45)
  {
    if (!v47) {
      goto LABEL_69;
    }
    CFDictionaryRef v48 = (void *)(a1 + 232);
    if (v44 < 0) {
      CFDictionaryRef v48 = (void *)*v48;
    }
    int v68 = 136315138;
    uint64_t v69 = v48;
    CFDictionaryRef v49 = "#I Carrier 2 country preferences path: %s";
    unint64_t v50 = v46;
    uint32_t v51 = 12;
  }
  else
  {
    if (!v47) {
      goto LABEL_69;
    }
    LOWORD(v68) = 0;
    CFDictionaryRef v49 = "#I Missing carrier 2 country preferences path";
    unint64_t v50 = v46;
    uint32_t v51 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v49, (uint8_t *)&v68, v51);
LABEL_69:
  char v52 = *(unsigned char *)(a1 + 287);
  if (v52 < 0) {
    uint64_t v53 = *(void *)(a1 + 272);
  }
  else {
    uint64_t v53 = *(unsigned __int8 *)(a1 + 287);
  }
  uint64_t v54 = *(NSObject **)(a1 + 32);
  BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
  if (v53)
  {
    if (!v55) {
      goto LABEL_80;
    }
    CFIndex v56 = (void *)(a1 + 264);
    if (v52 < 0) {
      CFIndex v56 = (void *)*v56;
    }
    int v68 = 136315138;
    uint64_t v69 = v56;
    uint64_t v57 = "#I Operator country preferences path: %s";
    CFDictionaryRef v58 = v54;
    uint32_t v59 = 12;
  }
  else
  {
    if (!v55) {
      goto LABEL_80;
    }
    LOWORD(v68) = 0;
    uint64_t v57 = "#I Missing operator country preferences path";
    CFDictionaryRef v58 = v54;
    uint32_t v59 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, v57, (uint8_t *)&v68, v59);
LABEL_80:
  char v60 = *(unsigned char *)(a1 + 319);
  if (v60 < 0) {
    uint64_t v61 = *(void *)(a1 + 304);
  }
  else {
    uint64_t v61 = *(unsigned __int8 *)(a1 + 319);
  }
  CFDictionaryRef v62 = *(NSObject **)(a1 + 32);
  BOOL v63 = os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT);
  if (v61)
  {
    if (v63)
    {
      uint64_t v64 = (void *)(a1 + 296);
      if (v60 < 0) {
        uint64_t v64 = (void *)*v64;
      }
      int v68 = 136315138;
      uint64_t v69 = v64;
      uint64_t v65 = "#I Operator country 2 preferences path: %s";
      CFDictionaryRef v66 = v62;
      uint32_t v67 = 12;
      goto LABEL_90;
    }
  }
  else if (v63)
  {
    LOWORD(v68) = 0;
    uint64_t v65 = "#I Missing operator 2 country preferences path";
    CFDictionaryRef v66 = v62;
    uint32_t v67 = 2;
LABEL_90:
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, v65, (uint8_t *)&v68, v67);
  }
  os_unfair_lock_unlock(v2);
}

void sub_1006CA6E8(uint64_t a1, std::string::size_type a2)
{
  char v4 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v5 = a2;
    }
    else {
      std::string::size_type v5 = *(void *)a2;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Logging for path: %{public}s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v238 = 0;
  v239 = 0;
  Registry::getFileSystemInterface(&v238, *(Registry **)(a1 + 328));
  if (v238)
  {
    std::string::size_type v236 = 0;
    v237 = 0;
    (*(void (**)(std::string::size_type *__return_ptr))(*(void *)v238 + 248))(&v236);
    std::string::size_type v6 = v236;
    if (v236) {
      BOOL v7 = sub_100080778;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7 || ((uint64_t v10 = v237) != 0 ? (v11 = sub_10039195C) : (v11 = 0), !v11))
    {
      int v8 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I File attributes using CC: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_343;
    }
    char v12 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Error reading attributes using CC: %{public}@", (uint8_t *)&buf, 0xCu);
      char v12 = *(NSObject **)(a1 + 32);
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Using mobilehelper to get attributes", (uint8_t *)&buf, 2u);
    }
    uint64_t v234 = 0;
    v235 = 0;
    Registry::getMobileHelper(&v234, *(Registry **)(a1 + 328));
    if (!v234)
    {
      uint64_t v16 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Couldnt get MobileHelper", (uint8_t *)&buf, 2u);
      }
      goto LABEL_341;
    }
    CFDictionaryRef v233 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v234 + 168))(&v233);
    CFDictionaryRef v13 = v233;
    if (v233) {
      uint64_t v14 = sub_100080778;
    }
    else {
      uint64_t v14 = 0;
    }
    BOOL v15 = *(NSObject **)(a1 + 32);
    if (v14)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I File attributes using CCMH: %{public}@", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Error reading attributes using CCMH", (uint8_t *)&buf, 2u);
    }
    v231[0] = 0;
    v231[1] = 0;
    uint64_t v232 = 0;
    getCarrierBundleDir(v231);
    CFDictionaryRef v230 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v234 + 168))(&v230);
    CFDictionaryRef v17 = v230;
    if (v230) {
      uint64_t v18 = sub_100080778;
    }
    else {
      uint64_t v18 = 0;
    }
    uint32_t v19 = *(NSObject **)(a1 + 32);
    BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    if (v18)
    {
      if (!v20) {
        goto LABEL_47;
      }
      uint64_t v21 = v231;
      if (v232 < 0) {
        uint64_t v21 = (void **)v231[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
      uint64_t v22 = "#I File attributes of CB directory:%{public}s using CCMH: %{public}@";
      BOOL v23 = v19;
      uint32_t v24 = 22;
    }
    else
    {
      if (!v20) {
        goto LABEL_47;
      }
      uint64_t v25 = v231;
      if (v232 < 0) {
        uint64_t v25 = (void **)v231[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
      uint64_t v22 = "#I Failed to get File attributes of CB directory: %{public}s using CCMH";
      BOOL v23 = v19;
      uint32_t v24 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&buf, v24);
LABEL_47:
    v228[0] = 0;
    v228[1] = 0;
    uint64_t v229 = 0;
    getCountryBundleDir(v228);
    CFDictionaryRef v227 = 0;
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v234 + 168))(&v227);
    CFDictionaryRef v26 = v227;
    if (v227) {
      uint32_t v27 = sub_100080778;
    }
    else {
      uint32_t v27 = 0;
    }
    char v28 = *(NSObject **)(a1 + 32);
    BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
    if (v27)
    {
      if (!v29) {
        goto LABEL_60;
      }
      CFDictionaryRef v30 = v228;
      if (v229 < 0) {
        CFDictionaryRef v30 = (void **)v228[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v26;
      BOOL v31 = "#I File attributes of countrybundles directory:%{public}s using CCMH: %{public}@";
      CFDictionaryRef v32 = v28;
      uint32_t v33 = 22;
    }
    else
    {
      if (!v29) {
        goto LABEL_60;
      }
      CFTypeID v34 = v228;
      if (v229 < 0) {
        CFTypeID v34 = (void **)v228[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
      BOOL v31 = "#I Failed to get File attributes of countrybundles directory:%{public}s using CCMH";
      CFDictionaryRef v32 = v28;
      uint32_t v33 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&buf, v33);
LABEL_60:
    uint32_t v35 = (char *)sub_1003F26A8();
    v225[1] = 0;
    v225[0] = 0;
    uint64_t v226 = 0;
    sub_100058DB0(v225, v35);
    ctu::path_join_impl();
    CFDictionaryRef theDict = 0;
    (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v234 + 168))(&theDict);
    CFDictionaryRef v36 = theDict;
    if (theDict) {
      uint64_t v37 = sub_100080778;
    }
    else {
      uint64_t v37 = 0;
    }
    CFDictionaryRef v38 = *(NSObject **)(a1 + 32);
    BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    if (v37)
    {
      if (!v39) {
        goto LABEL_73;
      }
      uint64_t v40 = v225;
      if (v226 < 0) {
        uint64_t v40 = (void **)v225[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v36;
      unint64_t v41 = "#I File attributes of mobileLib directory:%{public}s using CCMH: %{public}@";
      uint64_t v42 = v38;
      uint32_t v43 = 22;
    }
    else
    {
      if (!v39) {
        goto LABEL_73;
      }
      char v44 = v225;
      if (v226 < 0) {
        char v44 = (void **)v225[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
      unint64_t v41 = "#I Failed to get File attributes of mobileLib directory: %{public}s using CCMH";
      uint64_t v42 = v38;
      uint32_t v43 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&buf, v43);
LABEL_73:
    CFDictionaryRef v223 = 0;
    uint64_t v45 = v234;
    CFIndex v46 = (char *)sub_1003F26A8();
    sub_100058DB0(&buf, v46);
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, std::string *))(*(void *)v45 + 168))(&v223, v45, &buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (v223) {
      BOOL v47 = sub_100080778;
    }
    else {
      BOOL v47 = 0;
    }
    CFDictionaryRef v48 = *(NSObject **)(a1 + 32);
    BOOL v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
    if (v47)
    {
      if (!v49) {
        goto LABEL_84;
      }
      uint64_t v50 = sub_1003F26A8();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v50;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v223;
      uint32_t v51 = "#I File attributes of mobile directory: %{public}s using CCMH: %{public}@";
      char v52 = v48;
      uint32_t v53 = 22;
    }
    else
    {
      if (!v49) {
        goto LABEL_84;
      }
      uint64_t v54 = sub_1003F26A8();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v54;
      uint32_t v51 = "#I Failed to get File attributes of mobile directory: %{public}s using CCMH";
      char v52 = v48;
      uint32_t v53 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, (uint8_t *)&buf, v53);
LABEL_84:
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
    CFIndex v56 = ServiceMap;
    if ((v57 & 0x8000000000000000) != 0)
    {
      CFDictionaryRef v58 = (unsigned __int8 *)(v57 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v59 = 5381;
      do
      {
        std::string::size_type v57 = v59;
        unsigned int v60 = *v58++;
        uint64_t v59 = (33 * v59) ^ v60;
      }
      while (v60);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v57;
    uint64_t v61 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)&buf);
    if (v61)
    {
      uint64_t v63 = v61[3];
      CFDictionaryRef v62 = (std::__shared_weak_count *)v61[4];
      if (v62)
      {
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v56);
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v62);
        if (!v63)
        {
LABEL_333:
          sub_10004D2C8(v62);
          goto LABEL_334;
        }
LABEL_93:
        uint64_t v64 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            std::string::size_type v65 = a2;
          }
          else {
            std::string::size_type v65 = *(void *)a2;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v65;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Submitting bundle load failure metrics for path: %s", (uint8_t *)&buf, 0xCu);
        }
        xpc_object_t v222 = 0;
        xpc_object_t v66 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v67 = v66;
        if (v66)
        {
          xpc_object_t v222 = v66;
        }
        else
        {
          xpc_object_t v67 = xpc_null_create();
          xpc_object_t v222 = v67;
          if (!v67)
          {
            xpc_object_t v68 = xpc_null_create();
            xpc_object_t v67 = 0;
            goto LABEL_105;
          }
        }
        if (xpc_get_type(v67) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v67);
          goto LABEL_106;
        }
        xpc_object_t v68 = xpc_null_create();
LABEL_105:
        xpc_object_t v222 = v68;
LABEL_106:
        xpc_release(v67);
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v221 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v69 = &v221;
        }
        else {
          uint64_t v69 = (std::string *)v221.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v219 = xpc_string_create((const char *)v69);
        if (!v219) {
          xpc_object_t v219 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"preference_domain";
        sub_100035E70((uint64_t)&buf, &v219, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v219);
        xpc_object_t v219 = 0;
        if (*(char *)(a2 + 23) >= 0) {
          unint64_t v70 = (const char *)a2;
        }
        else {
          unint64_t v70 = *(const char **)a2;
        }
        xpc_object_t v217 = xpc_string_create(v70);
        if (!v217) {
          xpc_object_t v217 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"file_name";
        sub_100035E70((uint64_t)&buf, &v217, &v218);
        xpc_release(v218);
        xpc_object_t v218 = 0;
        xpc_release(v217);
        xpc_object_t v217 = 0;
        CFErrorGetDomain(v237);
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v216 = buf;
        unsigned int Code = CFErrorGetCode(v237);
        memset(&v215, 0, sizeof(v215));
        (*(void (**)(std::string *__return_ptr))(*(void *)v238 + 120))(&v211);
        unint64_t v72 = std::string::insert(&v211, 0, "Failed to load file:", 0x14uLL);
        long long v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
        v212.__r_.__value_.__r.__words[2] = v72->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v73;
        v72->__r_.__value_.__l.__size_ = 0;
        v72->__r_.__value_.__r.__words[2] = 0;
        v72->__r_.__value_.__r.__words[0] = 0;
        CFURLRef v74 = std::string::append(&v212, ". Error Domain:", 0xFuLL);
        long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
        v213.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v213.__r_.__value_.__l.__data_ = v75;
        v74->__r_.__value_.__l.__size_ = 0;
        v74->__r_.__value_.__r.__words[2] = 0;
        v74->__r_.__value_.__r.__words[0] = 0;
        if ((v216.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFArrayRef v76 = &v216;
        }
        else {
          CFArrayRef v76 = (std::string *)v216.__r_.__value_.__r.__words[0];
        }
        if ((v216.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v216.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v216.__r_.__value_.__l.__size_;
        }
        CFDictionaryRef v78 = std::string::append(&v213, (const std::string::value_type *)v76, size);
        long long v79 = *(_OWORD *)&v78->__r_.__value_.__l.__data_;
        v214.__r_.__value_.__r.__words[2] = v78->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v214.__r_.__value_.__l.__data_ = v79;
        v78->__r_.__value_.__l.__size_ = 0;
        v78->__r_.__value_.__r.__words[2] = 0;
        v78->__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v80 = std::string::append(&v214, ", Error Code:", 0xDuLL);
        long long v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__r.__words[2] = v80->__r_.__value_.__r.__words[2];
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v81;
        v80->__r_.__value_.__l.__size_ = 0;
        v80->__r_.__value_.__r.__words[2] = 0;
        v80->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v210, Code);
        if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v82 = &v210;
        }
        else {
          long long v82 = (std::string *)v210.__r_.__value_.__r.__words[0];
        }
        if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v83 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v83 = v210.__r_.__value_.__l.__size_;
        }
        long long v84 = std::string::append(&buf, (const std::string::value_type *)v82, v83);
        long long v85 = *(_OWORD *)&v84->__r_.__value_.__l.__data_;
        v215.__r_.__value_.__r.__words[2] = v84->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v215.__r_.__value_.__l.__data_ = v85;
        v84->__r_.__value_.__l.__size_ = 0;
        v84->__r_.__value_.__r.__words[2] = 0;
        v84->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v210.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v214.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v213.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v213.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v212.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v211.__r_.__value_.__l.__data_);
        }
        if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFArrayRef v86 = &v215;
        }
        else {
          CFArrayRef v86 = (std::string *)v215.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v208 = xpc_string_create((const char *)v86);
        if (!v208) {
          xpc_object_t v208 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"failure_reason";
        sub_100035E70((uint64_t)&buf, &v208, &v209);
        xpc_release(v209);
        xpc_object_t v209 = 0;
        xpc_release(v208);
        xpc_object_t v208 = 0;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v233, @"CopyFileAttributes");
        CFDictionaryRef v88 = Value;
        if (!Value || (CFTypeID v89 = CFGetTypeID(Value), v89 != CFDictionaryGetTypeID()))
        {
LABEL_326:
          if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v215.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v216.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v216.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v221.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v221.__r_.__value_.__l.__data_);
          }
          xpc_release(v222);
          if (!v62) {
            goto LABEL_334;
          }
          goto LABEL_333;
        }
        CFDictionaryGetValue(v88, @"NSFileOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v214 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v90 = &v214;
        }
        else {
          uint64_t v90 = (std::string *)v214.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v206 = xpc_string_create((const char *)v90);
        if (!v206) {
          xpc_object_t v206 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"ownerName";
        sub_100035E70((uint64_t)&buf, &v206, &v207);
        xpc_release(v207);
        xpc_object_t v207 = 0;
        xpc_release(v206);
        xpc_object_t v206 = 0;
        if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v214.__r_.__value_.__l.__data_);
        }
        CFDictionaryGetValue(v88, @"NSFileGroupOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v214 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFDictionaryRef v91 = &v214;
        }
        else {
          CFDictionaryRef v91 = (std::string *)v214.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v204 = xpc_string_create((const char *)v91);
        if (!v204) {
          xpc_object_t v204 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"groupName";
        sub_100035E70((uint64_t)&buf, &v204, &v205);
        xpc_release(v205);
        xpc_object_t v205 = 0;
        xpc_release(v204);
        xpc_object_t v204 = 0;
        if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v214.__r_.__value_.__l.__data_);
        }
        uint64_t v92 = (int *)CFDictionaryGetValue(v88, @"NSFilePosixPermissions");
        CFArrayRef v93 = v92;
        LODWORD(buf.__r_.__value_.__l.__data_) = 0;
        if (v92)
        {
          CFTypeID v94 = CFGetTypeID(v92);
          if (v94 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf, v93, v95);
          }
        }
        xpc_object_t v202 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
        if (!v202) {
          xpc_object_t v202 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"permissions";
        sub_100035E70((uint64_t)&buf, &v202, &v203);
        xpc_release(v203);
        xpc_object_t v203 = 0;
        xpc_release(v202);
        xpc_object_t v202 = 0;
        CFDictionaryGetValue(v88, @"NSFileProtectionKey");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        CFDictionaryRef v96 = (void *)buf.__r_.__value_.__r.__words[0];
        LODWORD(v213.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v213.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                            + 3);
        int v97 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          if (!buf.__r_.__value_.__l.__size_) {
            goto LABEL_175;
          }
          sub_10004FC84(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
        }
        else
        {
          if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
            goto LABEL_175;
          }
          long long __p = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_DWORD *)xpc_object_t v198 = v213.__r_.__value_.__l.__data_;
          *(_DWORD *)&v198[3] = *(_DWORD *)((char *)v213.__r_.__value_.__r.__words + 3);
          char v199 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        unsigned int v98 = sub_10040CA90((const void **)&__p);
        xpc_object_t v200 = xpc_int64_create(v98);
        if (!v200) {
          xpc_object_t v200 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"DataProtectionClass";
        sub_100035E70((uint64_t)&buf, &v200, &v201);
        xpc_release(v201);
        xpc_object_t v201 = 0;
        xpc_release(v200);
        xpc_object_t v200 = 0;
        if (v199 < 0) {
          operator delete((void *)__p);
        }
LABEL_175:
        if (v230) {
          long long v99 = sub_100080778;
        }
        else {
          long long v99 = 0;
        }
        if (v99)
        {
          CFDictionaryRef v100 = (const __CFDictionary *)CFDictionaryGetValue(v230, @"CopyFileAttributes");
          CFDictionaryRef v101 = v100;
          if (v100)
          {
            CFTypeID v102 = CFGetTypeID(v100);
            if (v102 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v101, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFTypeID v103 = &v214;
              }
              else {
                CFTypeID v103 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v195 = xpc_string_create((const char *)v103);
              if (!v195) {
                xpc_object_t v195 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesOwnerName";
              sub_100035E70((uint64_t)&buf, &v195, &v196);
              xpc_release(v196);
              xpc_object_t v196 = 0;
              xpc_release(v195);
              xpc_object_t v195 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v101, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFNumberRef v104 = &v214;
              }
              else {
                CFNumberRef v104 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v193 = xpc_string_create((const char *)v104);
              if (!v193) {
                xpc_object_t v193 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesGroupName";
              sub_100035E70((uint64_t)&buf, &v193, &v194);
              xpc_release(v194);
              xpc_object_t v194 = 0;
              xpc_release(v193);
              xpc_object_t v193 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              CFMutableDictionaryRef v105 = (int *)CFDictionaryGetValue(v101, @"NSFilePosixPermissions");
              int v106 = v105;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v105)
              {
                CFTypeID v107 = CFGetTypeID(v105);
                if (v107 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v106, v108);
                }
              }
              xpc_object_t v191 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v191) {
                xpc_object_t v191 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesPermissions";
              sub_100035E70((uint64_t)&buf, &v191, &v192);
              xpc_release(v192);
              xpc_object_t v192 = 0;
              xpc_release(v191);
              xpc_object_t v191 = 0;
              CFDictionaryGetValue(v101, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              uint64_t v109 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v214.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v110 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_210:
                  operator delete(v109);
                  goto LABEL_211;
                }
                sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_211;
                }
                long long __dst = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)xpc_object_t v187 = v214.__r_.__value_.__l.__data_;
                *(_DWORD *)&v187[3] = *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3);
                char v188 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v111 = sub_10040CA90((const void **)&__dst);
              xpc_object_t v189 = xpc_int64_create(v111);
              if (!v189) {
                xpc_object_t v189 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCarrierBundlesDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v189, &v190);
              xpc_release(v190);
              xpc_object_t v190 = 0;
              xpc_release(v189);
              xpc_object_t v189 = 0;
              if (v188 < 0) {
                operator delete((void *)__dst);
              }
              if (v110 < 0) {
                goto LABEL_210;
              }
            }
          }
        }
LABEL_211:
        if (v227) {
          std::string v112 = sub_100080778;
        }
        else {
          std::string v112 = 0;
        }
        if (v112)
        {
          CFDictionaryRef v113 = (const __CFDictionary *)CFDictionaryGetValue(v227, @"CopyFileAttributes");
          CFDictionaryRef v114 = v113;
          if (v113)
          {
            CFTypeID v115 = CFGetTypeID(v113);
            if (v115 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v114, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFTypeID v116 = &v214;
              }
              else {
                CFTypeID v116 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v184 = xpc_string_create((const char *)v116);
              if (!v184) {
                xpc_object_t v184 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesOwnerName";
              sub_100035E70((uint64_t)&buf, &v184, &v185);
              xpc_release(v185);
              xpc_object_t v185 = 0;
              xpc_release(v184);
              xpc_object_t v184 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v114, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFNumberRef v117 = &v214;
              }
              else {
                CFNumberRef v117 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v182 = xpc_string_create((const char *)v117);
              if (!v182) {
                xpc_object_t v182 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesGroupName";
              sub_100035E70((uint64_t)&buf, &v182, &v183);
              xpc_release(v183);
              xpc_object_t v183 = 0;
              xpc_release(v182);
              xpc_object_t v182 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              v118 = (int *)CFDictionaryGetValue(v114, @"NSFilePosixPermissions");
              int v119 = v118;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v118)
              {
                CFTypeID v120 = CFGetTypeID(v118);
                if (v120 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v119, v121);
                }
              }
              xpc_object_t v180 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v180) {
                xpc_object_t v180 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesPermissions";
              sub_100035E70((uint64_t)&buf, &v180, &v181);
              xpc_release(v181);
              xpc_object_t v181 = 0;
              xpc_release(v180);
              xpc_object_t v180 = 0;
              CFDictionaryGetValue(v114, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              CFDictionaryRef v122 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v214.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v123 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_246:
                  operator delete(v122);
                  goto LABEL_247;
                }
                sub_10004FC84(&v175, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_247;
                }
                long long v175 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)xpc_object_t v176 = v214.__r_.__value_.__l.__data_;
                *(_DWORD *)&v176[3] = *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3);
                char v177 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v124 = sub_10040CA90((const void **)&v175);
              xpc_object_t v178 = xpc_int64_create(v124);
              if (!v178) {
                xpc_object_t v178 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryCountryBundlesDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v178, &v179);
              xpc_release(v179);
              xpc_object_t v179 = 0;
              xpc_release(v178);
              xpc_object_t v178 = 0;
              if (v177 < 0) {
                operator delete((void *)v175);
              }
              if (v123 < 0) {
                goto LABEL_246;
              }
            }
          }
        }
LABEL_247:
        if (theDict) {
          v125 = sub_100080778;
        }
        else {
          v125 = 0;
        }
        if (v125)
        {
          CFDictionaryRef v126 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CopyFileAttributes");
          CFDictionaryRef v127 = v126;
          if (v126)
          {
            CFTypeID v128 = CFGetTypeID(v126);
            if (v128 == CFDictionaryGetTypeID())
            {
              CFDictionaryGetValue(v127, @"NSFileOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFTypeID v129 = &v214;
              }
              else {
                CFTypeID v129 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v173 = xpc_string_create((const char *)v129);
              if (!v173) {
                xpc_object_t v173 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryOwnerName";
              sub_100035E70((uint64_t)&buf, &v173, &v174);
              xpc_release(v174);
              xpc_object_t v174 = 0;
              xpc_release(v173);
              xpc_object_t v173 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              CFDictionaryGetValue(v127, @"NSFileGroupOwnerAccountName");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string v214 = buf;
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                CFNumberRef v130 = &v214;
              }
              else {
                CFNumberRef v130 = (std::string *)v214.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v171 = xpc_string_create((const char *)v130);
              if (!v171) {
                xpc_object_t v171 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryGroupName";
              sub_100035E70((uint64_t)&buf, &v171, &v172);
              xpc_release(v172);
              xpc_object_t v172 = 0;
              xpc_release(v171);
              xpc_object_t v171 = 0;
              if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v214.__r_.__value_.__l.__data_);
              }
              v131 = (int *)CFDictionaryGetValue(v127, @"NSFilePosixPermissions");
              int v132 = v131;
              LODWORD(buf.__r_.__value_.__l.__data_) = 0;
              if (v131)
              {
                CFTypeID v133 = CFGetTypeID(v131);
                if (v133 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&buf, v132, v134);
                }
              }
              xpc_object_t v169 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
              if (!v169) {
                xpc_object_t v169 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryPermissions";
              sub_100035E70((uint64_t)&buf, &v169, &v170);
              xpc_release(v170);
              xpc_object_t v170 = 0;
              xpc_release(v169);
              xpc_object_t v169 = 0;
              CFDictionaryGetValue(v127, @"NSFileProtectionKey");
              memset(&buf, 0, sizeof(buf));
              ctu::cf::assign();
              CFDictionaryRef v135 = (void *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v214.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
              *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                                  + 3);
              int v136 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!buf.__r_.__value_.__l.__size_)
                {
LABEL_282:
                  operator delete(v135);
                  goto LABEL_283;
                }
                sub_10004FC84(&v164, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
              }
              else
              {
                if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
                  goto LABEL_283;
                }
                long long v164 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_DWORD *)xpc_object_t v165 = v214.__r_.__value_.__l.__data_;
                *(_DWORD *)&v165[3] = *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3);
                char v166 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              unsigned int v137 = sub_10040CA90((const void **)&v164);
              xpc_object_t v167 = xpc_int64_create(v137);
              if (!v167) {
                xpc_object_t v167 = xpc_null_create();
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileLibraryDataProtectionClass";
              sub_100035E70((uint64_t)&buf, &v167, &v168);
              xpc_release(v168);
              xpc_object_t v168 = 0;
              xpc_release(v167);
              xpc_object_t v167 = 0;
              if (v166 < 0) {
                operator delete((void *)v164);
              }
              if (v136 < 0) {
                goto LABEL_282;
              }
            }
          }
        }
LABEL_283:
        if (v223) {
          v138 = sub_100080778;
        }
        else {
          v138 = 0;
        }
        if (!v138) {
          goto LABEL_319;
        }
        CFDictionaryRef v139 = (const __CFDictionary *)CFDictionaryGetValue(v223, @"CopyFileAttributes");
        CFDictionaryRef v140 = v139;
        if (!v139) {
          goto LABEL_319;
        }
        CFTypeID v141 = CFGetTypeID(v139);
        if (v141 != CFDictionaryGetTypeID()) {
          goto LABEL_319;
        }
        CFDictionaryGetValue(v140, @"NSFileOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v214 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFTypeID v142 = &v214;
        }
        else {
          CFTypeID v142 = (std::string *)v214.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v162 = xpc_string_create((const char *)v142);
        if (!v162) {
          xpc_object_t v162 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileOwnerName";
        sub_100035E70((uint64_t)&buf, &v162, &v163);
        xpc_release(v163);
        xpc_object_t v163 = 0;
        xpc_release(v162);
        xpc_object_t v162 = 0;
        if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v214.__r_.__value_.__l.__data_);
        }
        CFDictionaryGetValue(v140, @"NSFileGroupOwnerAccountName");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string v214 = buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFNumberRef v143 = &v214;
        }
        else {
          CFNumberRef v143 = (std::string *)v214.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v160 = xpc_string_create((const char *)v143);
        if (!v160) {
          xpc_object_t v160 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileGroupName";
        sub_100035E70((uint64_t)&buf, &v160, &v161);
        xpc_release(v161);
        xpc_object_t v161 = 0;
        xpc_release(v160);
        xpc_object_t v160 = 0;
        if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v214.__r_.__value_.__l.__data_);
        }
        v144 = (int *)CFDictionaryGetValue(v140, @"NSFilePosixPermissions");
        int v145 = v144;
        LODWORD(buf.__r_.__value_.__l.__data_) = 0;
        if (v144)
        {
          CFTypeID v146 = CFGetTypeID(v144);
          if (v146 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf, v145, v147);
          }
        }
        xpc_object_t v158 = xpc_int64_create(SLODWORD(buf.__r_.__value_.__l.__data_));
        if (!v158) {
          xpc_object_t v158 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobilePermissions";
        sub_100035E70((uint64_t)&buf, &v158, &v159);
        xpc_release(v159);
        xpc_object_t v159 = 0;
        xpc_release(v158);
        xpc_object_t v158 = 0;
        CFDictionaryGetValue(v140, @"NSFileProtectionKey");
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string::size_type v148 = (void *)buf.__r_.__value_.__r.__words[0];
        LODWORD(v214.__r_.__value_.__l.__data_) = buf.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2]
                                                                            + 3);
        int v149 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          if (!buf.__r_.__value_.__l.__size_)
          {
LABEL_318:
            operator delete(v148);
            goto LABEL_319;
          }
          sub_10004FC84(&v153, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
        }
        else
        {
          if (!*((unsigned char *)&buf.__r_.__value_.__s + 23))
          {
LABEL_319:
            sub_100117418(&v152, &v222);
            (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v63 + 16))(v63, "carrierbundleloadfailure", &v152);
            xpc_release(v152);
            xpc_object_t v152 = 0;
            sub_1005ABCB0(*(Registry **)(a1 + 328), &buf);
            int v151 = (*(uint64_t (**)(std::string::size_type))(*(void *)buf.__r_.__value_.__l.__data_ + 16))(buf.__r_.__value_.__r.__words[0]);
            if (buf.__r_.__value_.__l.__size_) {
              sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
            }
            if (v151) {
              sub_1006CC900((void *)a1);
            }
            else {
              sub_1006CCCB0(a1, &v215);
            }
            if (v97 < 0) {
              operator delete(v96);
            }
            goto LABEL_326;
          }
          long long v153 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_DWORD *)xpc_object_t v154 = v214.__r_.__value_.__l.__data_;
          *(_DWORD *)&v154[3] = *(_DWORD *)((char *)v214.__r_.__value_.__r.__words + 3);
          char v155 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        unsigned int v150 = sub_10040CA90((const void **)&v153);
        xpc_object_t v156 = xpc_int64_create(v150);
        if (!v156) {
          xpc_object_t v156 = xpc_null_create();
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v222;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)"MobileDataProtectionClass";
        sub_100035E70((uint64_t)&buf, &v156, &v157);
        xpc_release(v157);
        xpc_object_t v157 = 0;
        xpc_release(v156);
        xpc_object_t v156 = 0;
        if (v155 < 0) {
          operator delete((void *)v153);
        }
        if ((v149 & 0x80000000) == 0) {
          goto LABEL_319;
        }
        goto LABEL_318;
      }
      std::mutex::unlock(v56);
      if (v63) {
        goto LABEL_93;
      }
    }
    else
    {
      std::mutex::unlock(v56);
    }
LABEL_334:
    sub_100057D78((const void **)&v223);
    sub_100057D78((const void **)&theDict);
    if (SHIBYTE(v226) < 0) {
      operator delete(v225[0]);
    }
    sub_100057D78((const void **)&v227);
    if (SHIBYTE(v229) < 0) {
      operator delete(v228[0]);
    }
    sub_100057D78((const void **)&v230);
    if (SHIBYTE(v232) < 0) {
      operator delete(v231[0]);
    }
    sub_100057D78((const void **)&v233);
LABEL_341:
    if (v235) {
      sub_10004D2C8(v235);
    }
LABEL_343:
    sub_100057D78((const void **)&v236);
    sub_100127D74((const void **)&v237);
    goto LABEL_344;
  }
  uint64_t v9 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Couldnt get filesystem interface", (uint8_t *)&buf, 2u);
  }
LABEL_344:
  if (v239) {
    sub_10004D2C8(v239);
  }
}

void sub_1006CC43C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006CC900(void *a1)
{
  uint64_t result = sub_1006CD08C((uint64_t)a1);
  if (result)
  {
    CFDateRef v3 = operator new(0x20uLL);
    v3[1] = 0;
    v3[2] = 0;
    void *v3 = off_101A73DC8;
    char v4 = v3 + 3;
    v3[3] = &off_101A73D60;
    global_queue = dispatch_get_global_queue(0, 0);
    std::string::size_type v6 = global_queue;
    if (global_queue) {
      dispatch_retain(global_queue);
    }
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    sub_100058DB0(v21, "Failed To load Bundle preferences");
    sub_100058DB0(v19, "Carrier Bundle settings set up failed.  Please file a radar");
    sub_100058DB0(v17, "Tap-To-Radar");
    sub_100058DB0(__p, "dismiss");
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    uint64_t v8 = a1[41];
    uint64_t v7 = a1[42];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (std::__shared_weak_count *)a1[2];
    if (v9)
    {
      uint64_t v10 = a1[1];
      uint32_t v11 = std::__shared_weak_count::lock(v9);
      if (v11)
      {
        char v12 = v11;
        atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        CFDictionaryRef v26 = 0;
        CFDictionaryRef v13 = operator new(0x30uLL);
        *CFDictionaryRef v13 = off_1019FBD00;
        v13[1] = a1;
        void v13[2] = v8;
        v13[3] = v7;
        v13[4] = v10;
        void v13[5] = v12;
        CFDictionaryRef v26 = v13;
        (*(void (**)(uint64_t *__return_ptr, void *, void **, void **, void **, void **, dispatch_object_t *, void *))(*v4 + 40))(&v23, v4, v21, v19, v17, __p, &object, v25);
        sub_1000DA3EC(v25);
        if (object) {
          dispatch_release(object);
        }
        if (v16 < 0) {
          operator delete(__p[0]);
        }
        if (v18 < 0) {
          operator delete(v17[0]);
        }
        if (v20 < 0) {
          operator delete(v19[0]);
        }
        if (v22 < 0) {
          operator delete(v21[0]);
        }
        if (v24) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
        }
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_1006CCBE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006CCCB0(uint64_t a1, const std::string *a2)
{
  if (!sub_1006CD08C(a1)) {
    return;
  }
  char v4 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Submitting ABC for bundle load failure", buf, 2u);
  }
  memset(&buf[8], 0, 32);
  long long v31 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  memset(&v33, 0, sizeof(v33));
  long long v32 = 0u;
  uint64_t v34 = 23;
  qmemcpy(&buf[23], "\tCBPreference", 13);
  qmemcpy(buf, "Telephony", 9);
  BYTE7(v31) = 12;
  sub_10003ECB8((std::string *)((char *)&v31 + 8), "CBPreferenceLoadFailure", 0x17uLL);
  std::string::operator=(&v33, a2);
  v34 |= 1uLL;
  std::string::size_type v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v5 || (uint64_t v6 = *(void *)(a1 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
  uint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    char v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v37 = v11;
  BOOL v15 = sub_10004D37C(&v10[1].__m_.__sig, &v37);
  if (v15)
  {
    uint64_t v17 = v15[3];
    char v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  char v16 = 0;
  char v18 = 1;
LABEL_14:
  sub_1000DB86C((char *)__dst, (long long *)buf);
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  BOOL v39 = 0;
  uint32_t v19 = operator new(0x20uLL);
  void *v19 = off_1019FBC80;
  v19[1] = a1;
  uint64_t v19[2] = v6;
  v19[3] = v8;
  BOOL v39 = v19;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v17 + 16))(v17, __dst, v38);
  sub_1000DBADC(v38);
  if (v29 < 0) {
    operator delete(__p);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v23 < 0) {
    operator delete(v22);
  }
  if (v21 < 0)
  {
    operator delete(__dst[0]);
    if (v18) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if ((v18 & 1) == 0) {
LABEL_24:
  }
    sub_10004D2C8(v16);
LABEL_25:
  std::__shared_weak_count::__release_weak(v8);
  if (SBYTE7(v36) < 0) {
    operator delete((void *)v35);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(*((void **)&v31 + 1));
  }
  if (SBYTE7(v31) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1006CD014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_1000DBADC((void *)(v30 - 120));
  sub_1001278A0((uint64_t)&a10);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  std::__shared_weak_count::__release_weak(v27);
  sub_1001278A0((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_1006CD08C(uint64_t a1)
{
  long long __p = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
  CFDateRef v3 = ServiceMap;
  if (v4 < 0)
  {
    std::string::size_type v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v10 + 208))(&__p, v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = HIBYTE(v41);
  if (v41 < 0) {
    uint64_t v12 = v40;
  }
  if (!v12)
  {
    uint64_t v23 = 0;
    goto LABEL_57;
  }
  uint64_t v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
  unsigned int v14 = v13;
  if (v15 < 0)
  {
    char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(v13);
  *(void *)std::string buf = v15;
  uint32_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_23:
    std::mutex::unlock(v14);
    char v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_55;
    }
    goto LABEL_24;
  }
  uint64_t v21 = v19[3];
  char v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (!v21)
  {
LABEL_55:
    uint64_t v34 = 0;
    uint64_t v23 = 0;
    if (v22) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
LABEL_24:
  CFDictionaryRef v38 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 40))(buf, v21, @"kBuildVersionForTTR", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100056248(&v38, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v38) {
    uint64_t v24 = sub_1000810B8;
  }
  else {
    uint64_t v24 = 0;
  }
  if (!v24)
  {
    sub_1000558F4(&v38);
    goto LABEL_52;
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v43 = 0;
  ctu::cf::assign();
  uint64_t v37 = v43;
  *(_OWORD *)__s1 = *(_OWORD *)buf;
  uint64_t v25 = v40;
  char v26 = HIBYTE(v43);
  if (v43 >= 0) {
    uint64_t v27 = HIBYTE(v43);
  }
  else {
    uint64_t v27 = *(void *)&buf[8];
  }
  if (v41 >= 0) {
    uint64_t v25 = HIBYTE(v41);
  }
  if (v27 == v25)
  {
    if (v41 >= 0) {
      p_p = (unsigned __int8 *)&__p;
    }
    else {
      p_p = (unsigned __int8 *)__p;
    }
    if (v43 < 0)
    {
      long long v32 = __s1[0];
      if (!memcmp(__s1[0], p_p, *(size_t *)&buf[8]))
      {
        int v31 = 0;
        goto LABEL_50;
      }
    }
    else
    {
      if (!HIBYTE(v43))
      {
        sub_1000558F4(&v38);
        goto LABEL_55;
      }
      char v29 = __s1;
      uint64_t v30 = HIBYTE(v43);
      while (*(unsigned __int8 *)v29 == *p_p)
      {
        char v29 = (void **)((char *)v29 + 1);
        ++p_p;
        if (!--v30)
        {
          int v31 = 0;
          goto LABEL_48;
        }
      }
    }
  }
  std::string v33 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Current build not matching saved build version.", buf, 2u);
  }
  int v31 = 1;
LABEL_48:
  if (v26 < 0)
  {
    long long v32 = __s1[0];
LABEL_50:
    operator delete(v32);
  }
  sub_1000558F4(&v38);
  if (!v31) {
    goto LABEL_55;
  }
LABEL_52:
  uint64_t v34 = 1;
  uint64_t v23 = 1;
  if ((v22 & 1) == 0)
  {
LABEL_56:
    sub_10004D2C8(v20);
    uint64_t v23 = v34;
  }
LABEL_57:
  if (SHIBYTE(v41) < 0) {
    operator delete(__p);
  }
  return v23;
}

void sub_1006CD444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a13);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006CD4C0(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  CFDateRef v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1006CD4FC(uint64_t a1)
{
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
  CFDateRef v3 = ServiceMap;
  if (v4 < 0)
  {
    std::string::size_type v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v10 + 208))(v30, v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = (void *)HIBYTE(v31);
  if (v31 < 0) {
    uint64_t v12 = v30[1];
  }
  if (v12)
  {
    uint64_t v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 328));
    unsigned int v14 = v13;
    if (v15 < 0)
    {
      char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(v13);
    *(void *)std::string buf = v15;
    uint32_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      char v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        if (!v21) {
          goto LABEL_20;
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    char v20 = 0;
    char v22 = 1;
    if (!v21)
    {
LABEL_20:
      uint64_t v23 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Error receiving preferences", buf, 2u);
      }
LABEL_44:
      if ((v22 & 1) == 0) {
        sub_10004D2C8(v20);
      }
      goto LABEL_46;
    }
LABEL_26:
    if (SHIBYTE(v31) < 0)
    {
      sub_10004FC84(v27, v30[0], (unint64_t)v30[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v27 = *(_OWORD *)v30;
      uint64_t v28 = v31;
    }
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(__p, v27[0], (unint64_t)v27[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v27;
      uint64_t v34 = v28;
    }
    long long v32 = 0;
    if (SHIBYTE(v34) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      uint64_t v36 = v34;
    }
    uint64_t v37 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v25 = v32;
      long long v32 = v37;
      CFDictionaryRef v38 = v25;
      sub_1000558F4(&v38);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)buf);
    }
    char v26 = v32;
    char v29 = v32;
    long long v32 = 0;
    sub_1000558F4(&v32);
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(v27[0]);
    }
    (*(void (**)(uint64_t, const __CFString *, const void *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v21 + 16))(v21, @"kBuildVersionForTTR", v26, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_1000558F4(&v29);
    goto LABEL_44;
  }
  uint64_t v24 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No current OS build version received. Cannot save to pref", buf, 2u);
  }
LABEL_46:
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[0]);
  }
}

void sub_1006CD8B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  sub_1000558F4(&a22);
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void sub_1006CD968(uint64_t a1)
{
  sub_1006CDB08(a1);

  operator delete();
}

void *sub_1006CD9A0(void *a1, void *a2)
{
  v13[0] = v13;
  v13[1] = v13;
  uint64_t v14 = 0;
  id v2 = (void *)a1[1];
  if (v2 != a1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2)
      {
        if (v4 == a1)
        {
          BOOL v6 = 1;
LABEL_9:
          uint64_t v4 = a1;
        }
        else
        {
          while (1)
          {
            BOOL v6 = v4[2] == v5;
            if (v4[2] != v5) {
              break;
            }
            uint64_t v4 = (void *)v4[1];
            if (v4 == a1) {
              goto LABEL_9;
            }
          }
        }
        if (v2 != v4)
        {
          unsigned int v7 = (void *)*v4;
          if (v13 != a1)
          {
            uint64_t v8 = 1;
            if (v7 != v2)
            {
              uint64_t v9 = v2;
              do
              {
                uint64_t v9 = (void *)v9[1];
                ++v8;
              }
              while (v9 != v7);
            }
            a1[2] -= v8;
            v3 += v8;
            uint64_t v14 = v3;
          }
          uint64_t v10 = *v2;
          *(void *)(v10 + 8) = v7[1];
          *(void *)v7[1] = v10;
          uint64_t v11 = v13[0];
          *(void *)(v13[0] + 8) = v2;
          *id v2 = v11;
          v13[0] = v7;
          v7[1] = v13;
        }
        if (!v6) {
          uint64_t v4 = (void *)v4[1];
        }
      }
      id v2 = v4;
    }
    while (v4 != a1);
  }
  return sub_1006CDAA4(v13);
}

void *sub_1006CDAA4(void *result)
{
  if (result[2])
  {
    xpc_object_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t sub_1006CDB08(uint64_t a1)
{
  *(void *)a1 = off_1019FBA90;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 336);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 319) < 0) {
    operator delete(*(void **)(a1 + 296));
  }
  sub_100057D78((const void **)(a1 + 288));
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  sub_100057D78((const void **)(a1 + 256));
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  sub_100057D78((const void **)(a1 + 224));
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  sub_100057D78((const void **)(a1 + 192));
  sub_100057D78((const void **)(a1 + 184));
  sub_100057D78((const void **)(a1 + 176));
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  sub_100057D78((const void **)(a1 + 144));
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  sub_100057D78((const void **)(a1 + 112));
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  sub_100057D78((const void **)(a1 + 80));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  sub_100057D78((const void **)(a1 + 48));
  sub_100044D00((const void **)(a1 + 40));
  CarrierSettingsInterface::~CarrierSettingsInterface((CarrierSettingsInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1006CDC48(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006CDCC8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006CDD04(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006CDD3C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1006CDD6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1006CDDB0(void *a1, uint64_t *a2, std::string::size_type a3)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *(unsigned __int8 *)(a3 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a3 + 8);
  }
  if (v6)
  {
    char v22 = 0;
    uint64_t v8 = (os_log_t *)(v5 + 32);
    sub_1007B946C((os_log_t *)(v5 + 32), (Registry **)(v5 + 328), (const UInt8 *)a3, &v22);
    uint64_t v9 = v22;
    if (v22) {
      uint64_t v10 = sub_100080778;
    }
    else {
      uint64_t v10 = 0;
    }
    if (!v10)
    {
      uint64_t v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a3 + 23) >= 0) {
          uint64_t v12 = (void *)a3;
        }
        else {
          uint64_t v12 = *(void **)a3;
        }
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not load domain as dictionary from file: %{public}s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v13 = (capabilities::ct *)checkFilePresentUsingMobileHelper((os_log_t *)(v5 + 32), (Registry **)(v5 + 328), (uint64_t *)a3);
      if (v13) {
        sub_1006CA6E8(v5, a3);
      }
      if (capabilities::ct::getCarrierBundleBaseDir(v13) == 1)
      {
        uint64_t v14 = *v8;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Trying mobile helper...", (uint8_t *)&buf, 2u);
        }
        Registry::getMobileHelper((uint64_t *)&buf, *(Registry **)(v5 + 328));
        uint64_t v15 = buf;
        if (*(char *)(a3 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)a3;
          uint64_t v20 = *(void *)(a3 + 16);
        }
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **))(*(void *)v15 + 40))(&cf, v15, __p);
        CFTypeRef v24 = cf;
        if (cf) {
          CFRetain(cf);
        }
        uint64_t v23 = 0;
        uint64_t v25 = 0;
        sub_10004EFE4(&v25, &v24);
        if (v25) {
          unsigned int v18 = sub_100080778;
        }
        else {
          unsigned int v18 = 0;
        }
        if (v18) {
          sub_100058140(&v23, &v25);
        }
        sub_100057D78(&v25);
        *a1 = v23;
        uint64_t v23 = 0;
        sub_100057D78(&v23);
        sub_1000577C4(&v24);
        sub_1000577C4(&cf);
        if (SHIBYTE(v20) < 0) {
          operator delete(__p[0]);
        }
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        goto LABEL_27;
      }
      uint64_t v9 = v22;
    }
    *a1 = v9;
    char v22 = 0;
LABEL_27:
    sub_100057D78(&v22);
    return;
  }
  char v16 = *(NSObject **)(v5 + 32);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v17 = *(void *)a3;
    if (v7 >= 0) {
      std::string::size_type v17 = a3;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Load plist: Received empty path: %s", (uint8_t *)&buf, 0xCu);
  }
  *a1 = 0;
}

void sub_1006CE0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    sub_10004D2C8(a27);
  }
  sub_100057D78(&a17);
  _Unwind_Resume(a1);
}

void *sub_1006CE134(void *a1)
{
  *a1 = off_1019FBC80;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006CE180(void *a1)
{
  *a1 = off_1019FBC80;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006CE1EC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019FBC80;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006CE250(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FBC80;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006CE290(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006CE2A0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006CE2E0(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = *a2;
  uint64_t v5 = *(void **)a3;
  int v6 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  int v7 = (std::__shared_weak_count *)a1[3];
  if (!v7) {
    goto LABEL_8;
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = std::__shared_weak_count::lock(v7);
  if (!v9) {
    goto LABEL_8;
  }
  uint64_t v10 = v9;
  if (a1[2])
  {
    uint64_t v11 = *(NSObject **)(v8 + 32);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = "success";
      if (!v4) {
        uint64_t v12 = "failed";
      }
      int v13 = 136315138;
      uint64_t v14 = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "ABC report %s for push load preferences failure", (uint8_t *)&v13, 0xCu);
      if (!v4) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    if (v4) {
LABEL_6:
    }
      sub_1006CD4FC(v8);
  }
LABEL_7:
  sub_10004D2C8(v10);
LABEL_8:
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_1006CE400(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006CE420(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006CE460()
{
}

void *sub_1006CE46C(void *a1)
{
  *a1 = off_1019FBD00;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1006CE4C4(void *a1)
{
  *a1 = off_1019FBD00;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

char *sub_1006CE53C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_1019FBD00;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006CE5B8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FBD00;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006CE610(uint64_t a1)
{
}

void sub_1006CE618(void *a1)
{
  sub_1006CE748((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1006CE654(void *a1, unsigned char *a2)
{
  if (*a2 == 1)
  {
    uint64_t v3 = a1[1];
    launchURL();
    uint64_t v4 = (std::__shared_weak_count *)a1[5];
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        int v6 = v5;
        int v7 = (os_unfair_lock_s *)a1[4];
        if (v7)
        {
          uint64_t v8 = v7 + 6;
          os_unfair_lock_lock(v7 + 6);
          sub_1006CD4FC(v3);
          os_unfair_lock_unlock(v8);
        }
        sub_10004D2C8(v6);
      }
    }
  }
}

uint64_t sub_1006CE6FC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006CE73C()
{
}

void sub_1006CE748(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

uint64_t *sub_1006CE798(void *a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  return sub_1000E3958((uint64_t *)&v2);
}

void sub_1006CE7F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1006CE804()
{
  qword_101B0D328 = @"LocationServicesDefault";
  unk_101B0D330 = @"LocationServicesAvailable";
  qword_101B0D338 = @"MapsAvailable";
  unk_101B0D340 = @"MapKitAvailable";
  qword_101B0D348 = @"MapsVisible";
  unk_101B0D350 = @"MapsVisibleGreenTea";
  qword_101B0D358 = @"MapsUserShiftingGreenTea";
  unk_101B0D360 = @"MapsUserShiftingNonGreenTea";
  qword_101B0D368 = @"MapKitAvailableGreenTea";
  unk_101B0D370 = @"MapKitUserShiftingGreenTea";
  qword_101B0D378 = @"MapKitUserShiftingNonGreenTea";
  unk_101B0D380 = @"AllowsVoIP";
  qword_101B0D388 = @"AllowsHighQualityVideoOver3G";
  unk_101B0D390 = kCarrierBundleAttachAPNKey;
}

uint64_t sub_1006CE8D4(os_log_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = sub_1006CE940(a1, a2, *a3, 0, 2);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return v4;
}

void sub_1006CE928(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006CE940(os_log_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_1005B6DE8())
  {
    uint64_t v9 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Bypassing validation for bundles dict", v11, 2u);
    }
    return 1;
  }
  else
  {
    return VerifyCarrierBundleVersionsXMLSignatureWithKeyType(a3, a4, a5, 1);
  }
}

const void **sub_1006CE9F8@<X0>(const void **a1@<X0>, Registry **a2@<X1>, const __CFDictionary **a3@<X2>, const __CFDictionary *a4@<X3>, void *a5@<X8>)
{
  *a5 = 0;
  *(void *)uint64_t v21 = 0;
  sub_1004D384C(a4, (const void **)v21);
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)key = 0u;
  memset(v17, 0, sizeof(v17));
  sub_1004D4824(a4, a1, a2, *(const __CFString **)v21, *a3, 1, v17);
  if (key[1]) {
    uint64_t v10 = sub_1000810B8;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v10)
  {
    __p[0] = (void *)CFDictionaryGetValue(*a3, key[1]);
    *(void *)&long long v22 = 0;
    uint64_t v11 = (const void **)sub_100056248(&v22, (CFTypeRef *)__p);
    *a5 = v22;
    *(void *)&long long v22 = 0;
    sub_1000558F4(v11);
    uint64_t v12 = *a1;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      long long v22 = 0uLL;
      uint64_t v23 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = v22;
      uint64_t v16 = v23;
      int v13 = __p;
      if (v23 < 0) {
        int v13 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v25 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Best match found is %{public}s", buf, 0xCu);
      if (SHIBYTE(v16) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (*((void *)&v20 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
  }
  sub_1000558F4((const void **)&key[1]);
  if (key[0]) {
    sub_10004D2C8((std::__shared_weak_count *)key[0]);
  }
  sub_1000558F4((const void **)v17);
  return sub_1000558F4((const void **)v21);
}

void sub_1006CEBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  if (*(char *)(v6 - 81) < 0) {
    operator delete(*(void **)(v6 - 104));
  }
  sub_1004D49EC((uint64_t)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4(v5);
  _Unwind_Resume(a1);
}

BOOL sub_1006CEC10(const __CFString *a1, const __CFString *a2)
{
  return _CompareBundleVersionStrings(a1, a2) == -1;
}

BOOL sub_1006CEC30(const __CFString **a1, const __CFString **a2)
{
  return _CompareBundleVersionStrings(*a1, *a2) == -1;
}

uint64_t sub_1006CEC58(os_log_t *a1, CFTypeRef cf1, const __CFString *a3, CFTypeRef cf2, const __CFString *a5)
{
  if (cf1 && a3)
  {
    if (CFEqual(cf1, cf2))
    {
      if (_CompareBundleVersionStrings(a5, a3) != 1) {
        return 0;
      }
      uint64_t v8 = *a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v12 = 0;
        uint64_t v9 = "#I Current bundle ID has a lower version than the one available";
        uint64_t v10 = (uint8_t *)&v12;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
      }
    }
    else
    {
      uint64_t v8 = *a1;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v9 = "#I Current bundle ID does not match with the one available";
        uint64_t v10 = buf;
        goto LABEL_11;
      }
    }
  }
  else
  {
    uint64_t v8 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v14 = 0;
      uint64_t v9 = "#I Either no current bundle ID or version";
      uint64_t v10 = (uint8_t *)&v14;
      goto LABEL_11;
    }
  }
  return 1;
}

const void **sub_1006CED64@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (const void **)capabilities::ct::getCarrierBundleBaseDir(a1);
  *a2 = 0;
  if (result == 2)
  {
    uint64_t v4 = &kWatchBundleDeviceClass;
  }
  else if (result == 1)
  {
    uint64_t v4 = &kPadBundleDeviceClass;
  }
  else
  {
    if (result) {
      return result;
    }
    uint64_t v4 = &kPhoneBundleDeviceClass;
  }
  *a2 = *v4;
  uint64_t v5 = 0;
  return sub_1000558F4(&v5);
}

void sub_1006CEDDC(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v18 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v18);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v13)
  {
    DevicePersistentCopyValue((uint64_t *)&v16, kServerURLOverride, 0);
    sub_100056248(&v17, &v16);
    if (&v17 != a2)
    {
      uint64_t v14 = *a2;
      *a2 = v17;
      uint64_t v17 = 0;
      uint64_t v18 = v14;
      sub_1000558F4((const void **)&v18);
    }
    sub_1000558F4((const void **)&v17);
    sub_1000577C4(&v16);
  }
  if (*a2) {
    uint64_t v15 = sub_1000810B8;
  }
  else {
    uint64_t v15 = 0;
  }
  if (!v15)
  {
    uint64_t v18 = kDefaultServerURL;
    sub_100013168((const void **)a2, (CFTypeRef *)&v18);
  }
}

void sub_1006CEF80(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

const void **sub_1006CEFC4@<X0>(void *a1@<X8>)
{
  *(void *)uint64_t v6 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    uint64_t v3 = *(__CFArray **)v6;
    *(void *)uint64_t v6 = Mutable;
    uint64_t v7 = v3;
    sub_1000440D4((const void **)&v7);
  }
  sub_1001C6B94(*(__CFArray **)v6, kCarrierBundleSignatures);
  sub_1001C6B94(*(__CFArray **)v6, kCountryBundlesSection);
  sub_1001C6B94(*(__CFArray **)v6, kCountryBundleSignatures);
  BOOL v4 = sub_1001C6B94(*(__CFArray **)v6, kCarrierBundlesSection);
  if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v4) != 2)
  {
    sub_1001C6B94(*(__CFArray **)v6, kMobileDeviceCarriersByCarrierID);
    sub_1001C6B94(*(__CFArray **)v6, kMobileDeviceCarriersByMccMnc);
    sub_1001C6B94(*(__CFArray **)v6, kMobileDeviceCarrierBundlesByProductVersion);
  }
  sub_100044D6C(a1, (CFTypeRef *)v6);
  return sub_1000440D4((const void **)v6);
}

void sub_1006CF0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_1006CF100(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(unsigned char **)a1;
    uint64_t v1 = (unsigned char *)(*(void *)a1 + *(void *)(a1 + 8));
  }
  else
  {
    uint64_t v1 = (unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 23));
    uint64_t v2 = (unsigned char *)a1;
  }
  for (; v2 != v1; ++v2)
    *uint64_t v2 = __tolower((char)*v2);
  sub_1000493DC(&v4, kBundleUpdatesUrlPrefix);
  return ctu::starts_with();
}

void sub_1006CF1AC(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, const void **a4@<X8>)
{
  *a4 = 0;
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v8 = sub_1006CE940(a1, a2, *a3, 1, 2);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if ((v8 & 1) == 0)
  {
    uint64_t v21 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(key[0]) = 0;
    long long v22 = "#I CarrierBundles versions format 2 section failed verification";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)key, 2u);
    return;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)*a3, kCarrierBundlesSection);
  CFDictionaryRef v10 = Value;
  if (!Value
    || (CFTypeID v11 = CFGetTypeID(Value), TypeID = (capabilities::ct *)CFDictionaryGetTypeID(),
                                  (capabilities::ct *)v11 != TypeID))
  {
    uint64_t v21 = *a1;
    if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(key[0]) = 0;
    long long v22 = "#I Carrier bundles section missing";
    goto LABEL_22;
  }
  key[0] = 0;
  sub_1006CED64(TypeID, key);
  if (key[0]) {
    int v13 = sub_1000810B8;
  }
  else {
    int v13 = 0;
  }
  if (v13)
  {
    CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(v10, key[0]);
    CFDictionaryRef v15 = v14;
    if (v14)
    {
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 == CFDictionaryGetTypeID())
      {
        uint64_t v17 = CFDictionaryGetValue(v15, kOtherKnownSettings);
        uint64_t v18 = v17;
        if (v17)
        {
          CFTypeID v19 = CFGetTypeID(v17);
          if (v19 == CFDictionaryGetTypeID()) {
            long long v20 = v18;
          }
          else {
            long long v20 = 0;
          }
        }
        else
        {
          long long v20 = 0;
        }
        v25[0] = v20;
        sub_100282490(a4, v25);
        goto LABEL_30;
      }
    }
    uint64_t v23 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      CFTypeRef v24 = "#I Empty device updates dict under Carrier bundles section";
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)v25, 2u);
    }
  }
  else
  {
    uint64_t v23 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25[0]) = 0;
      CFTypeRef v24 = "#I Missing device updates dict under Carrier bundles section";
      goto LABEL_27;
    }
  }
LABEL_30:
  sub_1000558F4((const void **)key);
}

void sub_1006CF3E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  sub_100057D78(v3);
  _Unwind_Resume(a1);
}

void sub_1006CF420(os_log_t *a1@<X0>, uint64_t a2@<X1>, CFDictionaryRef *a3@<X2>, const void **a4@<X8>)
{
  *a4 = 0;
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (sub_1005B6DE8())
  {
    char v8 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Bypassing validation for bundles dict", buf, 2u);
    }
    char v9 = 1;
    if (v7) {
      goto LABEL_7;
    }
  }
  else
  {
    char v9 = VerifyCountryBundleVersionsXMLSignatureWithKeyType();
    if (v7) {
LABEL_7:
    }
      sub_10004D2C8(v7);
  }
  if (v9)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*a3, kCountryBundlesSection);
    CFDictionaryRef v11 = Value;
    if (Value
      && (CFTypeID v12 = CFGetTypeID(Value),
          CFTypeID TypeID = (capabilities::ct *)CFDictionaryGetTypeID(),
          (capabilities::ct *)v12 == TypeID))
    {
      *(void *)long long buf = 0;
      sub_1006CED64(TypeID, buf);
      if (*(void *)buf) {
        CFDictionaryRef v14 = sub_1000810B8;
      }
      else {
        CFDictionaryRef v14 = 0;
      }
      if (v14)
      {
        CFDictionaryRef v15 = CFDictionaryGetValue(v11, *(const void **)buf);
        CFTypeID v16 = v15;
        if (v15)
        {
          CFTypeID v17 = CFGetTypeID(v15);
          if (v17 == CFDictionaryGetTypeID()) {
            uint64_t v18 = v16;
          }
          else {
            uint64_t v18 = 0;
          }
        }
        else
        {
          uint64_t v18 = 0;
        }
        v22[0] = v18;
        sub_100282490(a4, v22);
      }
      else
      {
        uint64_t v21 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v22[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Not valid device dict.", (uint8_t *)v22, 2u);
        }
      }
      sub_1000558F4((const void **)buf);
    }
    else
    {
      long long v20 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Country bundles section missing", buf, 2u);
      }
    }
  }
  else
  {
    CFTypeID v19 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "CountryBundles version xml format1 section failed verification", buf, 2u);
    }
  }
}

void sub_1006CF65C(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1006CF698(Registry **a1, int a2, int a3, const void **a4)
{
  if (a2 == 1)
  {
    sub_1006CFC20();
    uint64_t v4 = qword_101B0D3A0;
    uint64_t v5 = 0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Got a kUnknownError activation error, always consider kUnknownError as not matching not-subscriber error", buf, 2u);
      return 0;
    }
    return v5;
  }
  sub_100058198(&v36, a4);
  CFTypeRef cf = 0;
  if (v36) {
    char v9 = sub_100080778;
  }
  else {
    char v9 = 0;
  }
  if (!v9)
  {
    sub_100057D78(&v36);
    return a2 == 63;
  }
  *(void *)long long buf = 0;
  uint64_t v43 = 0;
  sub_1006D6404("CarrierSettingsXpcServer", buf);
  if (!*(void *)buf) {
    goto LABEL_14;
  }
  uint64_t valuePtr = *(void *)buf;
  BOOL v39 = v43;
  if (v43) {
    atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = sub_1006D6D4C((int)&valuePtr, @"com.apple.cellulardataplan", @"CellularDataPlanNotSubscribedError", &cf);
  if (v39) {
    sub_10004D2C8(v39);
  }
  CFDictionaryRef v10 = (uint64_t *)HIDWORD(v11);
  if (HIDWORD(v11))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D3B8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D3B8))
    {
      LogGroupName = (const char *)sGetLogGroupName();
      ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D3B0, kCtLoggingSystemName, LogGroupName);
      __cxa_guard_release(&qword_101B0D3B8);
    }
    CFDictionaryRef v15 = qword_101B0D3B0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3B0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v41 = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Error reading cellular data plan preferences", v41, 2u);
    }
    CFTypeRef cf = 0;
  }
  else
  {
LABEL_14:
    if (cf)
    {
      CFTypeID v12 = CFGetTypeID(cf);
      if (v12 == CFNumberGetTypeID())
      {
        CFArrayRef v13 = CFArrayCreate(kCFAllocatorDefault, &cf, 1, &kCFTypeArrayCallBacks);
        sub_1006CFC20();
        CFDictionaryRef v14 = qword_101B0D3A0;
        if (os_log_type_enabled((os_log_t)qword_101B0D3A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v41 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Found not-subscribed error in com.apple.cellulardataplan bundle", v41, 2u);
        }
        goto LABEL_42;
      }
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *a1);
  CFTypeID v17 = ServiceMap;
  if (v18 < 0)
  {
    CFTypeID v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v41 = v18;
  long long v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)v41);
  if (v22)
  {
    uint64_t v24 = v22[3];
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v23 = 0;
  char v25 = 1;
LABEL_33:
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v24 + 32))(&v37, v24, kCarrierBundleId, @"CellularDataPlanNotSubscribedErrors", 0, 0);
  char v26 = v37;
  uint64_t v37 = 0;
  CFTypeRef cf = v26;
  sub_1000577C4(&v37);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (!cf) {
    goto LABEL_41;
  }
  CFTypeID v27 = CFGetTypeID(cf);
  if (v27 != CFArrayGetTypeID())
  {
    CFRelease(cf);
LABEL_41:
    CFArrayRef v13 = 0;
    goto LABEL_42;
  }
  sub_1006CFC20();
  uint64_t v28 = qword_101B0D3A0;
  if (os_log_type_enabled((os_log_t)qword_101B0D3A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v41 = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N Found array of not-subscribed errors in com.apple.carrier bundle", v41, 2u);
  }
  CFArrayRef v13 = (const __CFArray *)cf;
LABEL_42:
  if (v43) {
    sub_10004D2C8(v43);
  }
  sub_100057D78(&v36);
  if (!v13) {
    return a2 == 63;
  }
  CFIndex Count = CFArrayGetCount(v13);
  if (Count < 1)
  {
LABEL_52:
    uint64_t v5 = 0;
  }
  else
  {
    CFIndex v30 = 0;
    while (1)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v13, v30);
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr))
      {
        int v32 = valuePtr;
        if (a3) {
          int v32 = gsmToCsiErrorWithCode();
        }
        if (v32 == a2) {
          break;
        }
      }
      if (Count == ++v30) {
        goto LABEL_52;
      }
    }
    sub_1006CFC20();
    std::string v33 = qword_101B0D3A0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#N Found matching not-subscriber error code during activate failure: %d", buf, 8u);
    }
    uint64_t v5 = 1;
  }
  CFRelease(v13);
  return v5;
}

void sub_1006CFB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

void sub_1006CFC20()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D3A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D3A8))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D3A0, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B0D3A8);
  }
}

void sub_1006CFCA4(_Unwind_Exception *a1)
{
}

uint64_t *sub_1006CFCBC(uint64_t a1)
{
  sub_100C62700(a1, "kCarrierSettingsGetProperty", (unint64_t)sub_1006CFD74, 1u);
  sub_100C62700(a1, "kCarrierSettingsIsUimRequired", (unint64_t)sub_1006D0244, 3u);
  sub_100C62700(a1, "kCarrierSettingsIsPhoneNumberCredentialValid", (unint64_t)sub_1006D042C, 3u);

  return sub_100C62700(a1, "kCarrierSettingsGetBundleInfo", (unint64_t)sub_1006D0528, 5u);
}

void sub_1006CFD74(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, const void **a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  char v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v40 = v10;
  CFDictionaryRef v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v40);
  if (!v14)
  {
    std::mutex::unlock(v9);
    return;
  }
  uint64_t v16 = v14[3];
  CFDictionaryRef v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
    std::mutex::unlock(v9);
    if (!v16) {
      return;
    }
LABEL_10:
    uint64_t v40 = (uint64_t)a4;
    uint64_t v41 = "kCarrierSettingsKey";
    xpc_object_t object = 0;
    sub_100048BAC((uint64_t)&v40, &object);
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_null) {
      goto LABEL_44;
    }
    BOOL v39 = 0;
    uint64_t v40 = _CFXPCCreateCFObjectFromXPCObject();
    sub_100225AE0(&v39, (CFTypeRef *)&v40);
    if (v39) {
      CFTypeID v17 = sub_1000810B8;
    }
    else {
      CFTypeID v17 = 0;
    }
    if (!v17)
    {
LABEL_43:
      sub_1000558F4(&v39);
LABEL_44:
      xpc_release(object);
      if (!v15) {
        return;
      }
      goto LABEL_45;
    }
    uint64_t v38 = 0;
    if (!sub_1012F6430(a4))
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t, const void *))(*(void *)v16 + 64))(&v37, v16, v39);
      uint64_t v40 = v38;
      uint64_t v29 = v37;
      uint64_t v37 = 0;
      uint64_t v38 = v29;
      sub_1000577C4((const void **)&v40);
      sub_1000577C4((const void **)&v37);
LABEL_32:
      xpc_object_t v32 = xpc_null_create();
      if (v38) {
        std::string v33 = sub_100080934;
      }
      else {
        std::string v33 = 0;
      }
      if (v33)
      {
        uint64_t v34 = _CFXPCCreateXPCObjectFromCFObject();
        if (!v34) {
          uint64_t v34 = (uint64_t)xpc_null_create();
        }
        xpc_release(v32);
        xpc_object_t v32 = (xpc_object_t)v34;
      }
      xpc_object_t v35 = v32;
      if (v32) {
        xpc_retain(v32);
      }
      else {
        xpc_object_t v35 = xpc_null_create();
      }
      uint64_t v40 = (uint64_t)*a5;
      uint64_t v41 = "kCarrierSettingsKey";
      sub_100035E70((uint64_t)&v40, &v35, &v36);
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_release(v35);
      xpc_object_t v35 = 0;
      xpc_release(v32);
      sub_1000577C4((const void **)&v38);
      goto LABEL_43;
    }
    uint64_t v18 = (std::mutex *)Registry::getServiceMap(*a1);
    CFTypeID v19 = v18;
    if ((v20 & 0x8000000000000000) != 0)
    {
      unsigned int v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        unint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(v18);
    uint64_t v40 = v20;
    uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)&v40);
    if (v24)
    {
      uint64_t v26 = v24[3];
      char v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v28 = 0;
        if (!v26) {
          goto LABEL_29;
        }
LABEL_26:
        if (capabilities::ct::supportsGemini(v27)
          && xpc_dictionary_get_value(*a4, "kUsePreferredDataSIM"))
        {
          uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 760))(v26);
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, const void *, void, void))(*(void *)v16 + 96))(&v37, v16, v30, 1, v39, 0, 0);
          goto LABEL_30;
        }
LABEL_29:
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void, const void *, void, void))(*(void *)v16 + 32))(&v37, v16, kCarrierBundleId, v39, 0, 0);
LABEL_30:
        uint64_t v40 = v38;
        uint64_t v31 = v37;
        uint64_t v37 = 0;
        uint64_t v38 = v31;
        sub_1000577C4((const void **)&v40);
        sub_1000577C4((const void **)&v37);
        if ((v28 & 1) == 0) {
          sub_10004D2C8(v25);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    char v25 = 0;
    char v28 = 1;
    if (!v26) {
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  if (v16) {
    goto LABEL_10;
  }
LABEL_45:
  sub_10004D2C8(v15);
}

void sub_1006D0198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  sub_1000577C4(&a12);
  sub_1000558F4(&a13);
  xpc_release(object);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

void sub_1006D0244(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    char v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v19);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    xpc_object_t v17 = xpc_BOOL_create(0);
    if (!v17) {
      xpc_object_t v17 = xpc_null_create();
    }
    unint64_t v19 = *a5;
    unint64_t v20 = "kCarrierSettingsIsUimRequired";
    sub_100035E70((uint64_t)&v19, &v17, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v17);
    xpc_object_t v17 = 0;
    if (v15) {
      return;
    }
LABEL_16:
    sub_10004D2C8(v13);
    return;
  }
LABEL_13:
  char v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 64))(v14);
  xpc_object_t v21 = xpc_BOOL_create(v16);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  unint64_t v19 = *a5;
  unint64_t v20 = "kCarrierSettingsIsUimRequired";
  sub_100035E70((uint64_t)&v19, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if ((v15 & 1) == 0) {
    goto LABEL_16;
  }
}

void sub_1006D0410(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006D042C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  uint64_t v6 = *(std::__shared_weak_count **)(a5 + 8);
  uint64_t v7 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::RestModule::getPropertyOnce();
  if (v9 < 0) {
    operator delete(__p);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1006D0500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1006D0528(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v50 = 0;
  uint32_t v51 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v17 = 1;
    if (!v15) {
      goto LABEL_20;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v17 = 0;
  if (!v15) {
    goto LABEL_20;
  }
LABEL_10:
  uint64_t v64 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  memset(v55, 0, sizeof(v55));
  *(_OWORD *)long long __p = 0u;
  long long v54 = 0u;
  *(_OWORD *)long long buf = 0u;
  uint64_t v18 = capabilities::ct::defaultVinylSlotID(v16);
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 208))(buf, v15, v18);
  if ((_BYTE)v64 && (_BYTE)v56)
  {
    BOOL v19 = BYTE1(v56) != 0;
LABEL_14:
    sub_1000C584C((uint64_t)&v55[14] + 8);
    LODWORD(v15) = v19;
    goto LABEL_15;
  }
  BOOL v19 = 0;
  LODWORD(v15) = 0;
  if ((_BYTE)v64) {
    goto LABEL_14;
  }
LABEL_15:
  if (LOBYTE(v55[14])) {
    sub_1000C584C((uint64_t)v55 + 8);
  }
  if (LOBYTE(v55[0]) && SHIBYTE(v54) < 0) {
    operator delete(__p[1]);
  }
LABEL_20:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v15)
  {
    sub_1006D1004();
    unint64_t v20 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Vinyl active, not providing any info to get bundle info", buf, 2u);
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    ctu::cf_to_xpc((uint64_t *)&v47, Mutable, v21);
    *(void *)long long buf = *a5;
    *(void *)&uint8_t buf[8] = "kCarrierSettingsBundleInfo";
    sub_100035E70((uint64_t)buf, &v47, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v47);
    xpc_object_t v47 = 0;
    sub_1000440D4((const void **)&Mutable);
    goto LABEL_53;
  }
  xpc_object_t v22 = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v23 = v22;
  if (v24 < 0)
  {
    char v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(v22);
  *(void *)long long buf = v24;
  char v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)buf);
  if (!v28)
  {
    uint64_t v30 = 0;
LABEL_34:
    std::mutex::unlock(v23);
    uint64_t v29 = 0;
    char v31 = 1;
    if (!v30) {
      goto LABEL_51;
    }
LABEL_35:
    xpc_object_t v32 = (std::__shared_weak_count *)a5[1];
    uint64_t v45 = *a5;
    CFIndex v46 = v32;
    if (v32) {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v30 + 256))(v30, &v45);
    if (v46) {
      sub_10004D2C8(v46);
    }
    std::string v33 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v34 = v33;
    if (v35 < 0)
    {
      xpc_object_t v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        uint64_t v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(v33);
    *(void *)long long buf = v35;
    BOOL v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
    if (v39)
    {
      uint64_t v41 = v39[3];
      uint64_t v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        char v42 = 0;
LABEL_47:
        char v43 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 32))(v41);
        if ((v42 & 1) == 0) {
          sub_10004D2C8(v40);
        }
        if ((v43 & 1) == 0) {
          (*(void (**)(uint64_t))(*(void *)v30 + 344))(v30);
        }
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v34);
    uint64_t v40 = 0;
    char v42 = 1;
    goto LABEL_47;
  }
  uint64_t v30 = v28[3];
  uint64_t v29 = (std::__shared_weak_count *)v28[4];
  if (!v29) {
    goto LABEL_34;
  }
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v23);
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v29);
  char v31 = 0;
  if (v30) {
    goto LABEL_35;
  }
LABEL_51:
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
LABEL_53:
  sub_10005717C(&v50);
  return sub_10005717C(&v51);
}

void sub_1006D0A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v10 = va_arg(va1, const void *);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  sub_10005717C((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1006D0AA4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v32 = 0;
  std::string v33 = 0;
  uint64_t v34 = 0;
  sub_100089CF0((uint64_t *)&v32, a2);
  uint64_t v3 = v32;
  if (v32 != v33)
  {
    while (*v3 != 1)
    {
      v3 += 42;
      if (v3 == v33) {
        goto LABEL_8;
      }
    }
  }
  if (v3 == v33)
  {
LABEL_8:
    sub_1006D1004();
    uint64_t v6 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Missing %s in sim info", buf, 0xCu);
    }
    xpc_object_t v30 = xpc_BOOL_create(0);
    if (!v30) {
      xpc_object_t v30 = xpc_null_create();
    }
    *(void *)long long buf = *(void *)(a1 + 32);
    *(void *)&uint8_t buf[8] = "kCarrierSettingsIsPhoneNumberCredentialValid";
    sub_100035E70((uint64_t)buf, &v30, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v30);
    xpc_object_t v30 = 0;
    goto LABEL_52;
  }
  int isSimPresent = subscriber::isSimPresent();
  if (isSimPresent) {
    int isSimReady = subscriber::isSimReady();
  }
  else {
    int isSimReady = 1;
  }
  sub_1006D1004();
  char v8 = qword_101B0D3C0;
  if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = subscriber::asString();
    uint64_t v10 = "false";
    if (isSimPresent) {
      uint64_t v11 = "true";
    }
    else {
      uint64_t v11 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v11;
    if (isSimReady) {
      uint64_t v10 = "true";
    }
    __int16 v36 = 2080;
    uint64_t v37 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SIM state: %s, present: %s, valid: %s", buf, 0x20u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(**(Registry ***)(a1 + 48));
  unsigned int v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_31:
    std::mutex::unlock(v13);
    BOOL v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_27;
    }
    goto LABEL_32;
  }
  uint64_t v20 = v18[3];
  BOOL v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_31;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (!v20)
  {
LABEL_27:
    sub_1006D1004();
    xpc_object_t v22 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Missing ActivationInterface", buf, 2u);
    }
    LOBYTE(isSimReady) = 0;
    goto LABEL_47;
  }
LABEL_32:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 64))(v20))
  {
    sub_1006D1004();
    isSimReady &= isSimPresent;
    unsigned int v23 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = "false";
      if (isSimReady) {
        uint64_t v24 = "true";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v24;
      char v25 = "#I UIM is required, phone calls allowed = %s";
LABEL_46:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v25, buf, 0xCu);
    }
  }
  else if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 160))(v20))
  {
    sub_1006D1004();
    unsigned int v23 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = "false";
      if (isSimReady) {
        uint64_t v26 = "true";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v26;
      char v25 = "#I UIM is not required, phone calls allowed = %s";
      goto LABEL_46;
    }
  }
  else
  {
    sub_1006D1004();
    isSimReady &= isSimPresent;
    unsigned int v23 = qword_101B0D3C0;
    if (os_log_type_enabled((os_log_t)qword_101B0D3C0, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v27 = "false";
      if (isSimReady) {
        unsigned int v27 = "true";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      char v25 = "#I UIM is not required, not service provisioned, phone calls allowed = %s";
      goto LABEL_46;
    }
  }
LABEL_47:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  xpc_object_t v28 = xpc_BOOL_create(isSimReady);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  *(void *)long long buf = *(void *)(a1 + 32);
  *(void *)&uint8_t buf[8] = "kCarrierSettingsIsPhoneNumberCredentialValid";
  sub_100035E70((uint64_t)buf, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
LABEL_52:
  *(void *)long long buf = &v32;
  sub_10008A88C((void ***)buf);
}

void sub_1006D0F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  a17 = (void **)&a14;
  sub_10008A88C(&a17);
  _Unwind_Resume(a1);
}

void sub_1006D1004()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D3C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D3C8))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D3C0, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B0D3C8);
  }
}

void sub_1006D1088(_Unwind_Exception *a1)
{
}

uint64_t sub_1006D10A0()
{
  return sub_100C624B8((uint64_t)&unk_101B0D39A, (uint64_t)sub_1006CFCBC);
}

uint64_t sub_1006D10BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1008E2E44(a3);
  if (!*(void *)(*(void *)(a3 + 8) + 8)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 8), (const std::string *)(a1 + 168));
  if (*(unsigned char *)a1)
  {
    if (!*(void *)(*(void *)(a3 + 8) + 72)) {
      operator new();
    }
    if (!*(unsigned char *)a1) {
      goto LABEL_85;
    }
    std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 72), (const std::string *)(a1 + 8));
  }
  if (*(unsigned char *)(a1 + 56))
  {
    if (!*(void *)(*(void *)(a3 + 8) + 32)) {
      operator new();
    }
    if (!*(unsigned char *)(a1 + 56)) {
      goto LABEL_85;
    }
    std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 32), (const std::string *)(a1 + 64));
  }
  if (!*(unsigned char *)(a1 + 88)) {
    goto LABEL_18;
  }
  if (!*(void *)(*(void *)(a3 + 8) + 40)) {
    operator new();
  }
  if (!*(unsigned char *)(a1 + 88)) {
LABEL_85:
  }
    __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
  std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 40), (const std::string *)(a1 + 96));
LABEL_18:
  int v6 = *(unsigned __int8 *)(a1 + 120);
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v7 = *(void *)(a3 + 8);
    *(unsigned char *)(v7 + 128) |= 2u;
    *(_DWORD *)(v7 + 116) = v6;
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 151);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 136);
  }
  if (v8)
  {
    if (!*(void *)(*(void *)(a3 + 8) + 48)) {
      operator new();
    }
    std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 48), (const std::string *)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 152))
  {
    uint64_t v9 = *(void *)(a3 + 8);
    int v10 = *(_DWORD *)(a1 + 156);
    *(unsigned char *)(v9 + 128) |= 4u;
    *(_DWORD *)(v9 + 120) = v10;
  }
  if (*(unsigned char *)(a1 + 160))
  {
    uint64_t v11 = *(void *)(a3 + 8);
    int v12 = *(_DWORD *)(a1 + 164);
    *(unsigned char *)(v11 + 128) |= 8u;
    *(_DWORD *)(v11 + 124) = v12;
  }
  if (*(unsigned char *)(a2 + 144))
  {
    uint64_t v13 = *(unsigned __int8 *)(a2 + 23);
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(a2 + 8);
    }
    if (v13)
    {
      uint64_t v14 = *(std::string **)(*(void *)(a3 + 8) + 24);
      if (!v14) {
        operator new();
      }
      std::string::operator=(v14, (const std::string *)a2);
    }
    uint64_t v15 = *(unsigned __int8 *)(a2 + 47);
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = *(void *)(a2 + 32);
    }
    if (v15)
    {
      uint64_t v16 = *(std::string **)(*(void *)(a3 + 8) + 16);
      if (!v16) {
        operator new();
      }
      std::string::operator=(v16, (const std::string *)(a2 + 24));
    }
    uint64_t v17 = *(unsigned __int8 *)(a2 + 71);
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = *(void *)(a2 + 56);
    }
    if (v17)
    {
      char v18 = *(std::string **)(*(void *)(a3 + 8) + 80);
      if (!v18) {
        operator new();
      }
      std::string::operator=(v18, (const std::string *)(a2 + 48));
    }
    uint64_t v19 = *(unsigned __int8 *)(a2 + 95);
    if ((v19 & 0x80u) != 0) {
      uint64_t v19 = *(void *)(a2 + 80);
    }
    if (v19)
    {
      uint64_t v20 = *(std::string **)(*(void *)(a3 + 8) + 64);
      if (!v20) {
        operator new();
      }
      std::string::operator=(v20, (const std::string *)(a2 + 72));
    }
    uint64_t v21 = *(unsigned __int8 *)(a2 + 119);
    if ((v21 & 0x80u) != 0) {
      uint64_t v21 = *(void *)(a2 + 104);
    }
    if (v21)
    {
      if (!*(void *)(*(void *)(a3 + 8) + 56)) {
        operator new();
      }
      std::string::operator=(*(std::string **)(*(void *)(a3 + 8) + 56), (const std::string *)(a2 + 96));
    }
  }
  xpc_object_t v22 = *(int **)(a1 + 200);
  if (*(int **)(a1 + 208) != v22)
  {
    long long v36 = 0u;
    long long v37 = 0u;
    char v31 = off_1019ED3F0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    uint64_t v35 = 0;
    memset(v30, 0, sizeof(v30));
    uint64_t v47 = 0;
    long long v46 = 0u;
    memset(v45, 0, sizeof(v45));
    long long v44 = 0u;
    if (*(unsigned char *)(a2 + 144))
    {
      uint64_t v24 = *(void *)(a2 + 120);
      uint64_t v23 = *(void *)(a2 + 128);
      sub_1000C5DA8((uint64_t)v39, (uint64_t)v22);
      if (v24 != v23)
      {
        do
        {
          if (v40 == *(_DWORD *)v24) {
            goto LABEL_67;
          }
          v24 += 80;
        }
        while (v24 != v23);
        uint64_t v24 = v23;
      }
LABEL_67:
      if (v43[24])
      {
        unsigned int v38 = (void **)v43;
        sub_1000C57C8(&v38);
      }
      if (v42 < 0) {
        operator delete(__p);
      }
      if (v24 != *(void *)(a2 + 128))
      {
        if ((_BYTE)v44)
        {
          sub_1003083C8((uint64_t)&v44 + 8, v24);
        }
        else
        {
          DWORD2(v44) = *(_DWORD *)v24;
          if (*(char *)(v24 + 31) < 0)
          {
            sub_10004FC84(v45, *(void **)(v24 + 8), *(void *)(v24 + 16));
          }
          else
          {
            long long v25 = *(_OWORD *)(v24 + 8);
            *(void *)&v45[1] = *(void *)(v24 + 24);
            v45[0] = v25;
          }
          if (*(char *)(v24 + 55) < 0)
          {
            sub_10004FC84((unsigned char *)&v45[1] + 8, *(void **)(v24 + 32), *(void *)(v24 + 40));
          }
          else
          {
            long long v26 = *(_OWORD *)(v24 + 32);
            *((void *)&v45[2] + 1) = *(void *)(v24 + 48);
            *(_OWORD *)((char *)&v45[1] + 8) = v26;
          }
          sub_100312438((uint64_t *)&v46, v24 + 56);
          LOBYTE(v44) = 1;
        }
      }
    }
    sub_100878924(v22, (uint64_t)v30, (uint64_t)&v44, (uint64_t)&v31);
    sub_1005E1110();
  }
  int v27 = *(_DWORD *)(a1 + 232);
  if (v27)
  {
    uint64_t v28 = *(void *)(a3 + 8);
    *(unsigned char *)(v28 + 128) |= 1u;
    *(_DWORD *)(v28 + 112) = v27;
  }
  return 1;
}

void sub_1006D17B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  if (*(char *)(v8 - 153) < 0) {
    operator delete(*(void **)(v8 - 176));
  }
  int v10 = (void ***)sub_1005E47DC((unsigned char *)(v8 - 192));
  *(void *)(v8 - 192) = va;
  sub_1005E4864(v10);
  sub_1005EA108((uint64_t)va1);
  _Unwind_Resume(a1);
}

BOOL sub_1006D180C(uint64_t a1, uint64_t a2, std::string *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    long long v64 = 0u;
    long long v62 = 0u;
    memset(v63, 0, sizeof(v63));
    long long v60 = 0u;
    *(_OWORD *)long long v61 = 0u;
    long long v58 = 0u;
    *(_OWORD *)long long v59 = 0u;
    long long v56 = 0u;
    *(_OWORD *)long long v57 = 0u;
    long long v54 = 0u;
    *(_OWORD *)BOOL v55 = 0u;
    *(_OWORD *)uint32_t v53 = 0u;
    uint64_t v7 = v3;
    uint64_t v8 = *(const std::string **)(v3 + 8);
    if (v8)
    {
      std::string::operator=((std::string *)&v63[1], v8);
      std::string::operator=((std::string *)v55, *(const std::string **)(*(void *)(a1 + 8) + 8));
      uint64_t v7 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v7 + 128)) {
        DWORD2(v64) = *(_DWORD *)(v7 + 112);
      }
    }
    uint64_t v9 = *(uint64_t **)(v7 + 88);
    int v10 = *(uint64_t **)(v7 + 96);
    if (v9 != v10)
    {
      uint64_t v11 = this + 5;
      do
      {
        uint64_t v12 = *v9;
        uint64_t v52 = 0;
        memset(v51, 0, sizeof(v51));
        *(_OWORD *)uint64_t v50 = 0u;
        memset(v49, 0, sizeof(v49));
        uint64_t v41 = 0;
        long long v43 = 0u;
        long long v39 = 0u;
        *(_OWORD *)long long __p = 0u;
        *(_OWORD *)unsigned int v38 = 0u;
        char v42 = &v43;
        sub_100878F5C(v12, (uint64_t)v49, (uint64_t)v38);
        std::string::size_type size = this[5].__r_.__value_.__l.__size_;
        std::string::size_type v13 = this[5].__r_.__value_.__r.__words[2];
        if (size >= v13)
        {
          unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(size - v11->__r_.__value_.__r.__words[0]) >> 4);
          unint64_t v17 = v16 + 1;
          if (v16 + 1 > 0x333333333333333) {
            sub_10006A748();
          }
          unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - v11->__r_.__value_.__r.__words[0]) >> 4);
          if (2 * v18 > v17) {
            unint64_t v17 = 2 * v18;
          }
          if (v18 >= 0x199999999999999) {
            unint64_t v19 = 0x333333333333333;
          }
          else {
            unint64_t v19 = v17;
          }
          CFDictionaryRef v48 = &this[5].__r_.__value_.__s.__data_[16];
          if (v19) {
            uint64_t v20 = (char *)sub_1001F7E24((uint64_t)&this[5].__r_.__value_.__r.__words[2], v19);
          }
          else {
            uint64_t v20 = 0;
          }
          long long v44 = v20;
          uint64_t v45 = &v20[80 * v16];
          uint64_t v46 = (uint64_t)v45;
          uint64_t v47 = &v20[80 * v19];
          sub_1006D303C((uint64_t)v45, (uint64_t)v38);
          v46 += 80;
          sub_1006D3114((uint64_t *)&this[5], &v44);
          std::string::size_type v15 = this[5].__r_.__value_.__l.__size_;
          sub_1006D3220((uint64_t)&v44);
        }
        else
        {
          sub_1006D303C(this[5].__r_.__value_.__l.__size_, (uint64_t)v38);
          std::string::size_type v15 = size + 80;
          this[5].__r_.__value_.__l.__size_ = v15;
        }
        this[5].__r_.__value_.__l.__size_ = v15;
        uint64_t v21 = (char *)v63[6];
        if (v63[6] >= v63[7])
        {
          xpc_object_t v22 = (void *)sub_1006D3270((uint64_t *)&v63[5], (uint64_t)v49);
        }
        else
        {
          sub_1000C5DA8((uint64_t)v63[6], (uint64_t)v49);
          xpc_object_t v22 = v21 + 88;
        }
        v63[6] = v22;
        sub_1000C5440((uint64_t)&v42, (void *)v43);
        if (SHIBYTE(v41) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(v38[1]);
        }
        if ((_BYTE)v52)
        {
          v38[0] = (char *)v51 + 8;
          sub_1000C57C8((void ***)v38);
        }
        if (SBYTE7(v51[0]) < 0) {
          operator delete(v50[0]);
        }
        ++v9;
      }
      while (v9 != v10);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    uint64_t v23 = *(const std::string **)(v7 + 72);
    if (v23)
    {
      sub_10032AFC0(v53, v23);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    uint64_t v24 = *(const std::string **)(v7 + 32);
    if (v24)
    {
      sub_10032AFC0((unsigned char *)&v56 + 8, v24);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    long long v25 = *(const std::string **)(v7 + 40);
    if (v25)
    {
      sub_10032AFC0((unsigned char *)&v58 + 8, v25);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    char v26 = *(unsigned char *)(v7 + 128);
    if ((v26 & 2) != 0)
    {
      unsigned int v27 = *(_DWORD *)(v7 + 116);
      if (v27 >= 0xA) {
        LOBYTE(v27) = 0;
      }
      BYTE8(v60) = v27;
    }
    uint64_t v28 = *(const std::string **)(v7 + 48);
    if (v28)
    {
      std::string::operator=((std::string *)v61, v28);
      uint64_t v7 = *(void *)(a1 + 8);
      char v26 = *(unsigned char *)(v7 + 128);
    }
    if ((v26 & 4) != 0)
    {
      HIDWORD(v62) = *(_DWORD *)(v7 + 120);
      BYTE8(v62) = 1;
      char v26 = *(unsigned char *)(v7 + 128);
    }
    if ((v26 & 8) != 0)
    {
      HIDWORD(v63[0]) = *(_DWORD *)(v7 + 124);
      LOBYTE(v63[0]) = 1;
    }
    xpc_object_t v29 = *(const std::string **)(v7 + 24);
    if (v29)
    {
      std::string::operator=(this, v29);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    xpc_object_t v30 = *(const std::string **)(v7 + 16);
    if (v30)
    {
      std::string::operator=(this + 1, v30);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    char v31 = *(const std::string **)(v7 + 80);
    if (v31)
    {
      std::string::operator=(this + 2, v31);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    long long v32 = *(const std::string **)(v7 + 64);
    if (v32)
    {
      std::string::operator=(this + 3, v32);
      uint64_t v7 = *(void *)(a1 + 8);
    }
    long long v33 = *(const std::string **)(v7 + 56);
    if (v33) {
      std::string::operator=(this + 4, v33);
    }
    if (*(unsigned char *)(a2 + 240))
    {
      sub_1003464A0(a2, (uint64_t)v53);
      cellplan::RemoteDeviceIdentifiers::operator=();
      long long v34 = (void **)(a2 + 168);
      if (*(char *)(a2 + 191) < 0) {
        operator delete(*v34);
      }
      *(_OWORD *)long long v34 = *(_OWORD *)&v63[1];
      *(void **)(a2 + 184) = v63[3];
      HIBYTE(v63[3]) = 0;
      LOBYTE(v63[1]) = 0;
      *(void **)(a2 + 192) = v63[4];
      sub_1003DB434((void **)(a2 + 200));
      *(_OWORD *)(a2 + 200) = *(_OWORD *)&v63[5];
      uint64_t v35 = v63[7];
      uint64_t v36 = v64;
      memset(&v63[5], 0, 24);
      *(void *)(a2 + 216) = v35;
      *(void *)(a2 + 224) = v36;
      *(_DWORD *)(a2 + 232) = DWORD2(v64);
    }
    else
    {
      sub_100312A60(a2, (uint64_t)v53);
      *(unsigned char *)(a2 + 240) = 1;
    }
    *(void *)&v49[0] = &v63[5];
    sub_1000C56F4((void ***)v49);
    if (SHIBYTE(v63[3]) < 0) {
      operator delete(v63[1]);
    }
    if (SBYTE7(v62) < 0) {
      operator delete(v61[0]);
    }
    if (BYTE8(v58))
    {
      if (SBYTE7(v60) < 0) {
        operator delete(v59[0]);
      }
      BYTE8(v58) = 0;
    }
    if (BYTE8(v56))
    {
      if (SBYTE7(v58) < 0) {
        operator delete(v57[0]);
      }
      BYTE8(v56) = 0;
    }
    if (SBYTE7(v56) < 0) {
      operator delete(v55[0]);
    }
    if (LOBYTE(v53[0]) && SHIBYTE(v54) < 0) {
      operator delete(v53[1]);
    }
  }
  return v3 != 0;
}

void sub_1006D1D1C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

std::string *sub_1006D1D84@<X0>(std::string *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (result[10].__r_.__value_.__s.__data_[0])
  {
    uint64_t v3 = result;
    uint64_t result = std::string::operator=((std::string *)a2, result + 7);
    std::string::size_type size = v3[8].__r_.__value_.__l.__size_;
    std::string::size_type v5 = v3[8].__r_.__value_.__r.__words[2];
    if (size != v5)
    {
      while (1)
      {
        int v6 = *(_DWORD *)(size + 4);
        uint64_t v7 = (_OWORD *)(a2 + 24);
        if (v6 == 1) {
          goto LABEL_6;
        }
        if (v6 == 2) {
          break;
        }
LABEL_7:
        size += 88;
        if (size == v5) {
          return result;
        }
      }
      uint64_t v7 = (_OWORD *)(a2 + 40);
LABEL_6:
      _OWORD *v7 = *(_OWORD *)(size + 16);
      goto LABEL_7;
    }
  }
  return result;
}

void sub_1006D1E10(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006D1E2C(uint64_t a1, uint64_t a2)
{
  sub_1008E2D98(a2);
  sub_101094578(*(void *)(a2 + 16));
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 8) + 24)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 8) + 24), (const std::string *)a1);
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 8) + 32)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 8) + 32), (const std::string *)(a1 + 24));
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 8) + 40)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 8) + 40), (const std::string *)(a1 + 48));
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 8) + 8)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 8) + 8), (const std::string *)(a1 + 72));
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 8) + 16)) {
    operator new();
  }
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 8) + 16), (const std::string *)(a1 + 96));
  sub_101094630(*(void *)(a2 + 16));
  if (*(unsigned char *)(a1 + 120))
  {
    if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 40)) {
      operator new();
    }
    if (!*(unsigned char *)(a1 + 120)) {
      goto LABEL_45;
    }
    std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 16) + 40), (const std::string *)(a1 + 128));
  }
  if (!*(unsigned char *)(a1 + 152)) {
    goto LABEL_21;
  }
  if (!*(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 32)) {
    operator new();
  }
  if (!*(unsigned char *)(a1 + 152)) {
LABEL_45:
  }
    __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
  std::string::operator=(*(std::string **)(*(void *)(*(void *)(a2 + 16) + 16) + 32), (const std::string *)(a1 + 160));
LABEL_21:
  uint64_t v4 = *(void *)(a1 + 184);
  if (*(void *)(a1 + 192) != v4)
  {
    uint64_t v8 = off_101A29570;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0uLL;
    if (*(_OWORD *)v4 != 0) {
      operator new();
    }
    if (*(char *)(v4 + 103) < 0)
    {
      if (!*(void *)(v4 + 88)) {
        goto LABEL_31;
      }
    }
    else if (!*(unsigned char *)(v4 + 103))
    {
      goto LABEL_31;
    }
    if (!(void)v10) {
      operator new();
    }
    std::string::operator=((std::string *)v10, (const std::string *)(v4 + 80));
LABEL_31:
    int v5 = *(unsigned __int8 *)(v4 + 104);
    BYTE12(v11) |= 1u;
    DWORD2(v11) = v5;
    if (*(unsigned char *)(v4 + 16))
    {
      if (!*((void *)&v10 + 1)) {
        operator new();
      }
      std::string::operator=(*((std::string **)&v10 + 1), (const std::string *)(v4 + 24));
    }
    if (*(unsigned char *)(v4 + 48)) {
      operator new();
    }
    if (*(unsigned char *)(v4 + 112))
    {
      if (!(void)v9) {
        operator new();
      }
      std::string::operator=((std::string *)v9, (const std::string *)(v4 + 120));
    }
    operator new();
  }
  int v6 = *(std::string **)(a1 + 208);
  if (v6 != *(std::string **)(a1 + 216))
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v8 = off_101A0F638;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    sub_1006D26A8(v6, (uint64_t)&v8);
    operator new();
  }
  return 1;
}

void sub_1006D25F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  sub_100A0C014((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *sub_1006D26A8(std::string *result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  if (*(_OWORD *)&result->__r_.__value_.__l.__data_ != 0)
  {
    uint64_t v4 = *(PB::Data **)(a2 + 16);
    if (!v4) {
      operator new();
    }
    uint64_t result = (std::string *)PB::Data::assign(v4, (const unsigned __int8 *)v3, (const unsigned __int8 *)(v3 + 16));
  }
  uint64_t v5 = *(unsigned __int8 *)(v3 + 39);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(v3 + 24);
  }
  if (v5)
  {
    int v6 = *(std::string **)(a2 + 32);
    if (!v6) {
      operator new();
    }
    uint64_t result = std::string::operator=(v6, (const std::string *)(v3 + 16));
  }
  uint64_t v7 = *(unsigned __int8 *)(v3 + 63);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(v3 + 48);
  }
  if (v7)
  {
    uint64_t v8 = *(std::string **)(a2 + 24);
    if (!v8) {
      operator new();
    }
    uint64_t result = std::string::operator=(v8, (const std::string *)(v3 + 40));
  }
  int v9 = *(unsigned __int8 *)(v3 + 64);
  char v10 = *(unsigned char *)(a2 + 64);
  *(unsigned char *)(a2 + 64) = v10 | 1;
  *(_DWORD *)(a2 + 56) = v9;
  int v11 = *(unsigned __int8 *)(v3 + 65);
  *(unsigned char *)(a2 + 64) = v10 | 3;
  *(_DWORD *)(a2 + 60) = v11;
  uint64_t v12 = *(unsigned __int8 *)(v3 + 119);
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(v3 + 104);
  }
  if (v12)
  {
    uint64_t v13 = *(std::string **)(a2 + 8);
    if (!v13) {
      operator new();
    }
    uint64_t result = std::string::operator=(v13, (const std::string *)(v3 + 96));
  }
  uint64_t v14 = *(unsigned __int8 *)(v3 + 143);
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *(void *)(v3 + 128);
  }
  if (v14)
  {
    std::string::size_type v15 = *(std::string **)(a2 + 48);
    if (!v15) {
      operator new();
    }
    uint64_t result = std::string::operator=(v15, (const std::string *)(v3 + 120));
  }
  uint64_t v16 = *(unsigned __int8 *)(v3 + 167);
  if ((v16 & 0x80u) != 0) {
    uint64_t v16 = *(void *)(v3 + 152);
  }
  if (v16)
  {
    unint64_t v17 = *(std::string **)(a2 + 40);
    if (!v17) {
      operator new();
    }
    return std::string::operator=(v17, (const std::string *)(v3 + 144));
  }
  return result;
}

uint64_t sub_1006D29C4(uint64_t a1, std::string *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void **)(v2 + 8);
  if (!v3) {
    return 0;
  }
  unint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v44 = 0u;
  memset(v43, 0, sizeof(v43));
  memset(v42, 0, sizeof(v42));
  memset(v41, 0, sizeof(v41));
  int v6 = (const std::string *)v3[3];
  if (v6)
  {
    std::string::operator=(v41, v6);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void **)(v2 + 8);
  }
  uint64_t v7 = (const std::string *)v3[4];
  if (v7)
  {
    std::string::operator=(&v41[1], v7);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void **)(v2 + 8);
  }
  uint64_t v8 = (const std::string *)v3[5];
  if (v8)
  {
    std::string::operator=(v42, v8);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void **)(v2 + 8);
  }
  int v9 = (const std::string *)v3[1];
  if (v9)
  {
    std::string::operator=(&v42[1], v9);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void **)(v2 + 8);
  }
  char v10 = (const std::string *)v3[2];
  if (v10)
  {
    std::string::operator=((std::string *)v43, v10);
    uint64_t v2 = *(void *)(a1 + 16);
  }
  int v11 = *(void **)(v2 + 16);
  if (v11)
  {
    uint64_t v12 = (const std::string *)v11[5];
    if (v12)
    {
      sub_10032AFC0(&v43[24], v12);
      int v11 = *(void **)(*(void *)(a1 + 16) + 16);
    }
    uint64_t v13 = (const std::string *)v11[4];
    if (v13)
    {
      sub_10032AFC0(&v43[56], v13);
      int v11 = *(void **)(*(void *)(a1 + 16) + 16);
    }
    uint64_t v14 = (uint64_t *)v11[6];
    std::string::size_type v15 = (uint64_t *)v11[7];
    if (v14 != v15)
    {
      do
      {
        uint64_t v16 = *v14;
        *(_OWORD *)long long __p = 0u;
        long long v38 = 0u;
        *(_OWORD *)uint64_t v35 = 0u;
        *(_OWORD *)uint64_t v36 = 0u;
        *(_OWORD *)long long v33 = 0u;
        *(_OWORD *)long long v34 = 0u;
        *(_OWORD *)char v31 = 0u;
        *(_OWORD *)long long v32 = 0u;
        long long v30 = 0u;
        if (*(unsigned char *)(v16 + 52)) {
          LOBYTE(v36[1]) = *(_DWORD *)(v16 + 48);
        }
        unint64_t v17 = *(const std::string **)(v16 + 24);
        if (v17) {
          std::string::operator=((std::string *)v35, v17);
        }
        unint64_t v18 = *(long long ***)(v16 + 16);
        if (v18 && v18[1] == (long long *)16) {
          long long v30 = **v18;
        }
        unint64_t v19 = *(const std::string **)(v16 + 32);
        if (v19) {
          sub_10032AFC0(v31, v19);
        }
        uint64_t v20 = *(const std::string **)(v16 + 40);
        if (v20) {
          sub_10032AFC0(v33, v20);
        }
        uint64_t v21 = *(const std::string **)(v16 + 8);
        if (v21) {
          sub_10032AFC0(__p, v21);
        }
        uint64_t v22 = v45;
        if ((unint64_t)v45 >= *((void *)&v45 + 1))
        {
          uint64_t v23 = sub_1006D3390((uint64_t *)&v44 + 1, (uint64_t)&v30);
        }
        else
        {
          sub_1003447D4(v45, (uint64_t)&v30);
          uint64_t v23 = v22 + 144;
        }
        *(void *)&long long v45 = v23;
        if (LOBYTE(__p[0]))
        {
          if (SHIBYTE(v38) < 0) {
            operator delete(__p[1]);
          }
          LOBYTE(__p[0]) = 0;
        }
        if (SHIBYTE(v36[0]) < 0) {
          operator delete(v35[0]);
        }
        if (LOBYTE(v33[0]))
        {
          if (SHIBYTE(v34[1]) < 0) {
            operator delete(v33[1]);
          }
          LOBYTE(v33[0]) = 0;
        }
        if (LOBYTE(v31[0]) && SHIBYTE(v32[1]) < 0) {
          operator delete(v31[1]);
        }
        ++v14;
      }
      while (v14 != v15);
      int v11 = *(void **)(*(void *)(a1 + 16) + 16);
    }
    uint64_t v24 = (std::string **)v11[1];
    for (CFIndex i = (std::string **)v11[2]; v24 != i; ++v24)
    {
      char v26 = *v24;
      uint64_t v40 = 0;
      long long v38 = 0u;
      *(_OWORD *)long long v39 = 0u;
      *(_OWORD *)uint64_t v36 = 0u;
      *(_OWORD *)long long __p = 0u;
      *(_OWORD *)long long v34 = 0u;
      *(_OWORD *)uint64_t v35 = 0u;
      *(_OWORD *)long long v32 = 0u;
      *(_OWORD *)long long v33 = 0u;
      long long v30 = 0u;
      *(_OWORD *)char v31 = 0u;
      sub_1006D2E54(v26, (uint64_t)&v30);
      uint64_t v27 = *((void *)&v46 + 1);
      if (*((void *)&v46 + 1) >= v47)
      {
        uint64_t v28 = sub_1006D3644((uint64_t *)&v46, (uint64_t)&v30);
      }
      else
      {
        sub_1003449E4(*((uint64_t *)&v46 + 1), (uint64_t)&v30);
        uint64_t v28 = v27 + 168;
      }
      *((void *)&v46 + 1) = v28;
      if (SHIBYTE(v40) < 0) {
        operator delete(v39[0]);
      }
      if (SHIBYTE(v38) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v36[0]);
      }
      if (SHIBYTE(v35[1]) < 0) {
        operator delete(v34[1]);
      }
      if (SHIBYTE(v33[1]) < 0) {
        operator delete(v32[1]);
      }
      if (SHIBYTE(v32[0]) < 0) {
        operator delete(v31[0]);
      }
    }
  }
  sub_1003D5B34(a2, v41);
  sub_10023F898((uint64_t)v41);
  return 1;
}

void sub_1006D2D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t sub_1006D2DCC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  if (*(unsigned char *)(a1 + 16))
  {
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    *(unsigned char *)(a1 + 16) = 0;
  }
  return a1;
}

std::string *sub_1006D2E54(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  std::string::size_type v4 = result->__r_.__value_.__r.__words[2];
  if (v4 && *(void *)(v4 + 8) == 16) {
    *(_OWORD *)a2 = *(_OWORD *)*(void *)v4;
  }
  std::string::size_type size = (const std::string *)result[1].__r_.__value_.__l.__size_;
  if (size) {
    uint64_t result = std::string::operator=((std::string *)(a2 + 16), size);
  }
  data = (const std::string *)v3[1].__r_.__value_.__l.__data_;
  if (data) {
    uint64_t result = std::string::operator=((std::string *)(a2 + 40), data);
  }
  std::string::value_type v7 = v3[2].__r_.__value_.__s.__data_[16];
  if (v7)
  {
    *(unsigned char *)(a2 + 64) = v3[2].__r_.__value_.__r.__words[1];
    std::string::value_type v7 = v3[2].__r_.__value_.__s.__data_[16];
  }
  if ((v7 & 2) != 0) {
    *(unsigned char *)(a2 + 65) = HIDWORD(v3[2].__r_.__value_.__r.__words[1]);
  }
  uint64_t v8 = (const std::string *)v3->__r_.__value_.__l.__size_;
  if (v8) {
    uint64_t result = std::string::operator=((std::string *)(a2 + 96), v8);
  }
  int v9 = (const std::string *)v3[2].__r_.__value_.__l.__data_;
  if (v9) {
    uint64_t result = std::string::operator=((std::string *)(a2 + 120), v9);
  }
  char v10 = (const std::string *)v3[1].__r_.__value_.__r.__words[2];
  if (v10)
  {
    return std::string::operator=((std::string *)(a2 + 144), v10);
  }
  return result;
}

BOOL sub_1006D2F20(os_log_t *a1, const unsigned __int8 **a2, uint64_t a3, std::string *a4)
{
  uint64_t v5 = *a2;
  int v6 = a2[1];
  if (v5 == v6) {
    return 0;
  }
  memset(&v15[1], 0, 32);
  v15[0] = &off_101A17F50;
  memset(v14, 0, sizeof(v14));
  PB::Reader::Reader((PB::Reader *)v14, v5, v6 - v5);
  if (sub_1008E296C((uint64_t)v15, (PB::Reader *)v14))
  {
    BOOL v10 = sub_1006D180C((uint64_t)v15, a3, a4);
  }
  else
  {
    int v11 = *a1;
    BOOL v10 = 0;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      v13[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E Invalid Record content", (uint8_t *)v13, 2u);
      BOOL v10 = 0;
    }
  }
  sub_1008E25A0((PB::Base *)v15);
  return v10;
}

void sub_1006D3028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1008E25A0((PB::Base *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D303C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  sub_100312438((uint64_t *)(a1 + 56), a2 + 56);
  return a1;
}

void sub_1006D30E0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006D3114(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1006D318C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1006D318C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 80;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 80;
    sub_1006D303C(v12, v10 + a3);
  }
  return a6;
}

uint64_t sub_1006D3220(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_1000C53DC(i - 80);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1006D3270(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10010C8A4(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[88 * v4];
  uint64_t v16 = &v10[88 * v9];
  sub_1000C5DA8((uint64_t)v14, a2);
  std::string::size_type v15 = v14 + 88;
  sub_10010C82C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10010C988((uint64_t)&v13);
  return v11;
}

void sub_1006D337C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010C988((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D3390(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1C71C71C71C71C7) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xE38E38E38E38E3) {
    unint64_t v9 = 0x1C71C71C71C71C7;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100344704(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[144 * v4];
  uint64_t v16 = &v10[144 * v9];
  sub_1003447D4((uint64_t)v14, a2);
  std::string::size_type v15 = v14 + 144;
  sub_1006D34B0(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1006D35F4((uint64_t)&v13);
  return v11;
}

void sub_1006D349C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006D35F4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1006D34B0(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 144;
    v4 -= 144;
    sub_1006D3544(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

__n128 sub_1006D3544(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(unsigned char *)(a1 + 16) = 0;
  if (*(unsigned char *)(a2 + 16))
  {
    long long v2 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v2;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 24) = 0;
    *(unsigned char *)(a1 + 16) = 1;
  }
  *(unsigned char *)(a1 + 48) = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    long long v3 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v3;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  __n128 result = *(__n128 *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(__n128 *)(a1 + 80) = result;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 80) = 0;
  *(unsigned char *)(a1 + 104) = *(unsigned char *)(a2 + 104);
  *(unsigned char *)(a1 + 112) = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    __n128 result = *(__n128 *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(__n128 *)(a1 + 120) = result;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 0;
    *(unsigned char *)(a1 + 112) = 1;
  }
  return result;
}

uint64_t sub_1006D35F4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 144;
    sub_10023FB0C(i - 144);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1006D3644(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x186186186186186) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCF3CF3CF3CF3CF3DLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xC30C30C30C30C3) {
    unint64_t v9 = 0x186186186186186;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10008A268(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[168 * v4];
  uint64_t v16 = &v10[168 * v9];
  sub_1003449E4((uint64_t)v14, a2);
  std::string::size_type v15 = v14 + 168;
  sub_1006D3764(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1006D38AC((uint64_t)&v13);
  return v11;
}

void sub_1006D3750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006D38AC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1006D3764(uint64_t *a1, void *a2)
{
  sub_1006D37DC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

__n128 sub_1006D37DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 72;
    do
    {
      *(_OWORD *)(v8 - 96) = *(_OWORD *)(a3 - 168);
      long long v9 = *(_OWORD *)(a3 - 152);
      *(void *)(v8 - 64) = *(void *)(a3 - 136);
      *(_OWORD *)(v8 - 80) = v9;
      *(void *)(a3 - 144) = 0;
      *(void *)(a3 - 136) = 0;
      *(void *)(a3 - 152) = 0;
      long long v10 = *(_OWORD *)(a3 - 128);
      *(void *)(v8 - 40) = *(void *)(a3 - 112);
      *(_OWORD *)(v8 - 56) = v10;
      *(void *)(a3 - 120) = 0;
      *(void *)(a3 - 112) = 0;
      *(void *)(a3 - 128) = 0;
      *(_WORD *)(v8 - 32) = *(_WORD *)(a3 - 104);
      long long v11 = *(_OWORD *)(a3 - 96);
      *(void *)(v8 - 8) = *(void *)(a3 - 80);
      *(_OWORD *)(v8 - 24) = v11;
      *(void *)(a3 - 88) = 0;
      *(void *)(a3 - 80) = 0;
      *(void *)(a3 - 96) = 0;
      long long v12 = *(_OWORD *)(a3 - 72);
      *(void *)(v8 + 16) = *(void *)(a3 - 56);
      *(_OWORD *)uint64_t v8 = v12;
      *(void *)(a3 - 64) = 0;
      *(void *)(a3 - 56) = 0;
      *(void *)(a3 - 72) = 0;
      long long v13 = *(_OWORD *)(a3 - 48);
      *(void *)(v8 + 40) = *(void *)(a3 - 32);
      *(_OWORD *)(v8 + 24) = v13;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 48) = 0;
      __n128 result = *(__n128 *)(a3 - 24);
      *(void *)(v8 + 64) = *(void *)(a3 - 8);
      *(__n128 *)(v8 + 48) = result;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      v7 -= 168;
      v8 -= 168;
      a3 -= 168;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t sub_1006D38AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 168;
    sub_10023F9F0(i - 168);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1006D38FC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1006D3974((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1006D3974(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    long long v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_1006D3A08((uint64_t)v13);
  return v11;
}

uint64_t sub_1006D3A08(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

uint64_t sub_1006D3A40(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1006D3AB8((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1006D3AB8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    long long v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_1006D3B4C((uint64_t)v13);
  return v11;
}

uint64_t sub_1006D3B4C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

void sub_1006D3B84(Registry **a1@<X1>, uint64_t a2@<X5>, void *a3@<X8>)
{
  void (***v13)(uint64_t *__return_ptr, void, void **);
  char v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  void *__p[2];
  uint64_t v18;

  long long v15 = 0;
  uint64_t v16 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    long long v13 = (void (***)(uint64_t *__return_ptr, void, void **))v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      long long v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    long long v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  long long v14 = 1;
LABEL_9:
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    unint64_t v18 = *(void *)(a2 + 16);
  }
  (**v13)(&v15, v13, __p);
  if (SHIBYTE(v18) < 0)
  {
    operator delete(__p[0]);
    if (v14) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if ((v14 & 1) == 0) {
LABEL_14:
  }
    sub_10004D2C8(v12);
LABEL_15:
  if (v15 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 488))(v15, 11) & 1) != 0) {
    operator new();
  }
  *a3 = 0;
  a3[1] = 0;
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_1006D3FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_object_t object, dispatch_object_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (v32) {
    sub_10004D2C8(v32);
  }
  uint64_t v35 = *(NSObject **)(v34 - 96);
  if (v35) {
    dispatch_release(v35);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (v32)
  {
    sub_10004D2C8(v32);
    if (!v31) {
LABEL_9:
    }
      operator delete();
  }
  else if (!v31)
  {
    goto LABEL_9;
  }
  dispatch_release(v31);
  goto LABEL_9;
}

void sub_1006D417C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (v28) {
    JUMPOUT(0x1006D4174);
  }
  JUMPOUT(0x1006D416CLL);
}

CellularPlanProvisioningMonitorModeInterface *sub_1006D419C(uint64_t a1)
{
  *(void *)a1 = off_1019FBF30;
  long long v2 = *(std::__shared_weak_count **)(a1 + 200);
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 152));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 232);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 216);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 200);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10030AAD0(a1 + 168, *(void **)(a1 + 176));
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 160);
  if (v6) {
    sub_10004D2C8(v6);
  }

  return sub_10045E9DC((CellularPlanProvisioningMonitorModeInterface *)a1);
}

void sub_1006D4248(uint64_t a1)
{
  sub_1006D419C(a1);

  operator delete();
}

void *sub_1006D4280(void *a1)
{
  if (a1[24])
  {
    long long v2 = a1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Assertion already exists!", (uint8_t *)__p, 2u);
    }
    return (void *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  }
  else
  {
    sub_100058DB0(__p, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v4 = (std::__shared_weak_count *)a1[25];
    *((_OWORD *)a1 + 12) = v5;
    if (v4) {
      sub_10004D2C8(v4);
    }
    __p[0] = off_1019FC028;
    __p[1] = a1;
    uint64_t v8 = __p;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(__p);
  }
}

void sub_1006D43D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_1006D4410(uint64_t a1)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 64);
    uint64_t v11 = *(void *)(a1 + 80);
  }
  long long v2 = sub_100046F68(a1 + 168, __p);
  if ((void **)(a1 + 176) != v2)
  {
    long long v5 = (char *)v2[9];
    uint64_t v3 = v2 + 9;
    uint64_t v4 = v5;
    if (v5)
    {
      uint64_t v6 = v3;
      do
      {
        int v7 = *((_DWORD *)v4 + 7);
        BOOL v8 = v7 < 11;
        if (v7 >= 11) {
          uint64_t v9 = (void **)v4;
        }
        else {
          uint64_t v9 = (void **)(v4 + 8);
        }
        if (!v8) {
          uint64_t v6 = (void **)v4;
        }
        uint64_t v4 = (char *)*v9;
      }
      while (*v9);
      if (v6 != v3 && *((int *)v6 + 7) <= 11)
      {
        switch(*((_DWORD *)v6 + 8))
        {
          case 1:
          case 6:
            sub_1006D4714(a1, 0);
            goto LABEL_18;
          case 2:
            sub_1006D4560((void *)a1);
            goto LABEL_18;
          case 3:
          case 4:
          case 5:
            break;
          default:
LABEL_18:
            sub_1006D495C();
            break;
        }
      }
    }
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006D4528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006D4560(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[27];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = a1[26];
      if (v4)
      {
        sub_10003E168(&v9, a1 + 1);
        uint64_t v6 = v9;
        long long v5 = v10;
        if (v10)
        {
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v5);
        }
        long long v12 = 0;
        int v7 = operator new(0x20uLL);
        void *v7 = off_1019FC228;
        v7[1] = a1;
        uint64_t v7[2] = v6;
        v7[3] = v5;
        long long v12 = v7;
        (*(void (**)(uint64_t, void *, void *))(*(void *)v4 + 32))(v4, a1 + 8, v11);
        sub_100060644(v11);
LABEL_11:
        sub_10004D2C8(v3);
        return;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  BOOL v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v9) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Delegate is not available", (uint8_t *)&v9, 2u);
  }
  sub_1006D4714((uint64_t)a1, 0);
  if (v3) {
    goto LABEL_11;
  }
}

void sub_1006D46D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100060644((uint64_t *)va);
  sub_10004D2C8(v4);
  _Unwind_Resume(a1);
}

void sub_1006D4714(uint64_t a1, int a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 200);
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (a2)
  {
    sub_10045EEC8(a1, 0x101u);
  }
  else if (*(unsigned char *)(a1 + 256))
  {
    long long v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User selection, do not disable profile", buf, 2u);
    }
    sub_10045EEC8(a1, 0x100u);
  }
  else
  {
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 216);
    if (v6)
    {
      int v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        BOOL v8 = v7;
        uint64_t v9 = *(void *)(a1 + 208);
        if (v9)
        {
          sub_100058DB0(__p, "");
          sub_10003E168(buf, (void *)(a1 + 8));
          uint64_t v11 = *(void *)buf;
          unsigned int v10 = v16;
          if (v16)
          {
            atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v10);
          }
          unint64_t v17 = 0;
          long long v12 = operator new(0x20uLL);
          *long long v12 = off_1019FC1A8;
          v12[1] = a1;
          v12[2] = v11;
          v12[3] = v10;
          unint64_t v17 = v12;
          (*(void (**)(uint64_t, uint64_t, void **, uint8_t *))(*(void *)v9 + 24))(v9, a1 + 240, __p, buf);
          sub_1000C6B58(buf);
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_1006D4904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  sub_1000C6B58(&a16);
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_1006D495C()
{
  sub_100058DB0(&__p, "/cc/props/carrier_entitlements_info");
  ctu::RestModule::unobserveProperty();
  if (v1 < 0) {
    operator delete(__p);
  }
}

void sub_1006D49B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006D49D4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006D4A0C(uint64_t a1)
{
}

uint64_t sub_1006D4A28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006D4A6C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1006D4A9C()
{
}

void *sub_1006D4AB0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FC028;
  result[1] = v3;
  return result;
}

uint64_t sub_1006D4AF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FC028;
  a2[1] = v2;
  return result;
}

void sub_1006D4B24(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    long long v12 = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&v10);
    uint64_t v3 = (std::__shared_weak_count *)v2[27];
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        long long v5 = v4;
        uint64_t v6 = v2[26];
        if (v6)
        {
          sub_10003E168(&v10, v2 + 1);
          uint64_t v8 = v10;
          int v7 = v11;
          if (v11)
          {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v7);
          }
          long long v12 = 0;
          uint64_t v9 = operator new(0x20uLL);
          *uint64_t v9 = off_1019FC0A8;
          v9[1] = v2;
          v9[2] = v8;
          v9[3] = v7;
          long long v12 = v9;
          (*(void (**)(uint64_t, void *, void *, uint64_t *))(*(void *)v6 + 24))(v6, v2 + 30, v2 + 8, &v10);
          sub_1000C6B58(&v10);
        }
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_1006D4C60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C6B58((uint64_t *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D4CA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D4CE8()
{
}

void *sub_1006D4CF4(void *a1)
{
  *a1 = off_1019FC0A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006D4D40(void *a1)
{
  *a1 = off_1019FC0A8;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006D4DAC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019FC0A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006D4E10(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FC0A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006D4E50(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006D4E60(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006D4EA0(void *a1, unsigned __int16 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    unsigned int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[2])
      {
        if (v4 >= 0x100)
        {
          uint64_t v9 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315138;
            uint64_t v13 = asString();
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Activate profile failed: %s", buf, 0xCu);
          }
          sub_1006D4714(v5, 0);
        }
        else
        {
          sub_100058DB0(&__p, "/cc/props/carrier_entitlements_info");
          uint64_t v8 = operator new(0x28uLL);
          *uint64_t v8 = off_1019FC118;
          v8[1] = v5 + 168;
          void v8[2] = v5;
          v8[3] = sub_1006D4410;
          v8[4] = 0;
          char v14 = v8;
          ctu::RestModule::observeProperty();
          sub_10003F600(buf);
          if (v11 < 0) {
            operator delete(__p);
          }
          (*(void (**)(void, uint64_t))(**(void **)(v5 + 224) + 304))(*(void *)(v5 + 224), 11);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1006D5048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D508C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D50CC()
{
}

void sub_1006D50DC()
{
}

__n128 sub_1006D50F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FC118;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006D5144(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FC118;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006D517C(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1006D51F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D5238()
{
}

void *sub_1006D5244(void *a1)
{
  *a1 = off_1019FC1A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006D5290(void *a1)
{
  *a1 = off_1019FC1A8;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006D52FC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019FC1A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006D5360(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FC1A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006D53A0(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006D53B0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006D53F0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2])
      {
        (*(void (**)(void, uint64_t))(**(void **)(v3 + 224) + 312))(*(void *)(v3 + 224), 11);
        sub_10045EEC8(v3, 0x100u);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1006D549C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D54B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D54F4()
{
}

void *sub_1006D5500(void *a1)
{
  *a1 = off_1019FC228;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006D554C(void *a1)
{
  *a1 = off_1019FC228;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006D55B8(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019FC228;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1006D561C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FC228;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006D565C(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006D566C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006D56AC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[2]) {
        sub_1006D4714(v5, v4 != 0);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1006D572C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D5740(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D5780()
{
}

void sub_1006D578C()
{
}

void *sub_1006D5814(uint64_t a1, __int16 a2, int a3)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  if (a3) {
    __int16 v4 = 256;
  }
  else {
    __int16 v4 = 0;
  }
  int v7 = off_1019FC380;
  __int16 v8 = v4 | a2;
  uint64_t v9 = &v7;
  sub_100043ED0((uint64_t)&v7, *v3);
  return sub_100043E48(&v7);
}

void sub_1006D58C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006D58E0(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  __int16 v4 = &_mh_execute_header;
  if (!a3) {
    __int16 v4 = 0;
  }
  v7[0] = off_1019FC400;
  v7[1] = (unint64_t)v4 | a2;
  v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_1006D5990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006D59AC(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  __int16 v4 = &_mh_execute_header;
  if (!a3) {
    __int16 v4 = 0;
  }
  v7[0] = off_1019FC480;
  v7[1] = (unint64_t)v4 | a2;
  v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_1006D5A5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006D5A78(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  __int16 v4 = &_mh_execute_header;
  if (!a3) {
    __int16 v4 = 0;
  }
  v7[0] = off_1019FC500;
  v7[1] = (unint64_t)v4 | a2;
  v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_1006D5B28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006D5B44(uint64_t a1, __int16 a2, int a3)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  if (a3) {
    __int16 v4 = 256;
  }
  else {
    __int16 v4 = 0;
  }
  int v7 = off_1019FC580;
  __int16 v8 = v4 | a2;
  uint64_t v9 = &v7;
  sub_100043ED0((uint64_t)&v7, *v3);
  return sub_100043E48(&v7);
}

void sub_1006D5BF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006D5C10(void *a1)
{
  *a1 = off_1019FC2A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1006D5C5C(void *a1)
{
  *a1 = off_1019FC2A8;
  char v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1006D5CC8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006D5D30(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006D5D6C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006D5DA4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1006D5DD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1006D5E1C()
{
}

_WORD *sub_1006D5E30(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_1019FC380;
  result[4] = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t sub_1006D5E7C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FC380;
  *(_WORD *)(a2 + 8) = *(_WORD *)(result + 8);
  return result;
}

id sub_1006D5EAC(uint64_t a1, id *a2)
{
  return [*a2 reliableNetworkFallbackChanged:*(unsigned __int8 *)(a1 + 8) userEnabled:*(unsigned __int8 *)(a1 + 9)];
}

uint64_t sub_1006D5EC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D5F00()
{
}

void sub_1006D5F10()
{
}

void *sub_1006D5F24(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FC400;
  result[1] = v3;
  return result;
}

uint64_t sub_1006D5F6C(uint64_t result, void *a2)
{
  *a2 = off_1019FC400;
  a2[1] = *(void *)(result + 8);
  return result;
}

void sub_1006D5F9C(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  id v3 = +[CTXPCPlaceholder simSlot:*(unsigned int *)(a1 + 8)];
  objc_msgSend(v2, "lowDataModeChanged:userEnabled:");
}

void sub_1006D6004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1006D6018(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D6058()
{
}

void sub_1006D6068()
{
}

void *sub_1006D607C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FC480;
  result[1] = v3;
  return result;
}

uint64_t sub_1006D60C4(uint64_t result, void *a2)
{
  *a2 = off_1019FC480;
  a2[1] = *(void *)(result + 8);
  return result;
}

void sub_1006D60F4(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  id v3 = +[CTXPCPlaceholder simSlot:*(unsigned int *)(a1 + 8)];
  objc_msgSend(v2, "smartDataModeChanged:userEnabled:");
}

void sub_1006D615C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1006D6170(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D61B0()
{
}

void sub_1006D61C0()
{
}

void *sub_1006D61D4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FC500;
  result[1] = v3;
  return result;
}

uint64_t sub_1006D621C(uint64_t result, void *a2)
{
  *a2 = off_1019FC500;
  a2[1] = *(void *)(result + 8);
  return result;
}

void sub_1006D624C(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  id v3 = +[CTXPCPlaceholder simSlot:*(unsigned int *)(a1 + 8)];
  objc_msgSend(v2, "interfaceCostExpensiveChanged:isExpensive:");
}

void sub_1006D62B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1006D62C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D6308()
{
}

void sub_1006D6318()
{
}

_WORD *sub_1006D632C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_1019FC580;
  result[4] = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t sub_1006D6378(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FC580;
  *(_WORD *)(a2 + 8) = *(_WORD *)(result + 8);
  return result;
}

id sub_1006D63A8(uint64_t a1, id *a2)
{
  return [*a2 privacyProxyChanged:*(unsigned __int16 *)(a1 + 8)];
}

uint64_t sub_1006D63B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006D63F8()
{
}

void sub_1006D6404(const char *a1@<X0>, void *a2@<X8>)
{
  xpc_object_t v18 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v6;
LABEL_9:
  xpc_release(v5);
  if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v16 = xpc_string_create("com.apple.commcenter.mobile-helper-xpc");
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    char v14 = &v18;
    uint64_t v15 = TelephonyXPC::kServiceXPCName;
    sub_100035E70((uint64_t)&v14, &v16, &v17);
    xpc_release(v17);
    xpc_object_t v17 = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
    xpc_object_t v12 = xpc_string_create("CommCenterMobileHelperNotification");
    if (!v12) {
      xpc_object_t v12 = xpc_null_create();
    }
    char v14 = &v18;
    uint64_t v15 = TelephonyXPC::kServiceNotificationName;
    sub_100035E70((uint64_t)&v14, &v12, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v12);
    xpc_object_t v12 = 0;
    xpc_object_t v10 = xpc_string_create("CommCenterMobileHelperServer");
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    char v14 = &v18;
    uint64_t v15 = TelephonyXPC::kServerHostName;
    sub_100035E70((uint64_t)&v14, &v10, &v11);
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_release(v10);
    xpc_object_t v10 = 0;
    xpc_object_t v8 = xpc_string_create(a1);
    if (!v8) {
      xpc_object_t v8 = xpc_null_create();
    }
    char v14 = &v18;
    uint64_t v15 = TelephonyXPC::kClientHostName;
    sub_100035E70((uint64_t)&v14, &v8, &v9);
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_release(v8);
    xpc_object_t v8 = 0;
  }
  *a2 = 0;
  a2[1] = 0;
  xpc_object_t v7 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  TelephonyXPC::Client::create();
  xpc_release(v7);
  xpc_release(v18);
}

void sub_1006D66B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, xpc_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_1006D6704(int a1, CFStringRef theString, const __CFString *a3, const void *a4)
{
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  *(_OWORD *)__s = 0u;
  long long v49 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u) || !CFStringGetCString(a3, __s, 256, 0x8000100u))
  {
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 2;
    return v8 & 0x700000000 | v9;
  }
  xpc_object_t v43 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v43 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v43 = v7;
    if (!v7)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_12;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_11:
  xpc_object_t v43 = v10;
LABEL_12:
  xpc_release(v7);
  xpc_object_t v42 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v42 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v42 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_20;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_19:
  xpc_object_t v42 = v13;
LABEL_20:
  xpc_release(v12);
  uint64_t v38 = 3760250881;
  long long v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  v36[0] = 0;
  v36[1] = 0;
  uint64_t v37 = 0;
  sub_100058DB0(v36, buffer);
  v34[0] = 0;
  v34[1] = 0;
  uint64_t v35 = 0;
  sub_100058DB0(v34, __s);
  if (v37 >= 0) {
    char v14 = v36;
  }
  else {
    char v14 = (void **)v36[0];
  }
  xpc_object_t v32 = xpc_string_create((const char *)v14);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  long long __p = &v43;
  uint64_t v24 = "AppID";
  sub_100035E70((uint64_t)&__p, &v32, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if (v35 >= 0) {
    uint64_t v15 = v34;
  }
  else {
    uint64_t v15 = (void **)v34[0];
  }
  xpc_object_t v30 = xpc_string_create((const char *)v15);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  long long __p = &v43;
  uint64_t v24 = "Key";
  sub_100035E70((uint64_t)&__p, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  if (!a4)
  {
    LOBYTE(bytes) = 0;
    xpc_object_t v26 = xpc_data_create(&bytes, 1uLL);
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    long long __p = &v43;
    uint64_t v24 = "ValueData";
    sub_100035E70((uint64_t)&__p, &v26, &v27);
    xpc_release(v27);
    xpc_object_t v27 = 0;
    xpc_release(v26);
    xpc_object_t v26 = 0;
    goto LABEL_38;
  }
  CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, a4, kCFPropertyListXMLFormat_v1_0, 0, 0);
  CFDataRef v17 = Data;
  if (Data)
  {
    BytePtr = CFDataGetBytePtr(Data);
    unsigned int Length = CFDataGetLength(v17);
    xpc_object_t v28 = xpc_data_create(BytePtr, Length);
    if (!v28) {
      xpc_object_t v28 = xpc_null_create();
    }
    long long __p = &v43;
    uint64_t v24 = "ValueData";
    sub_100035E70((uint64_t)&__p, &v28, &v29);
    xpc_release(v29);
    xpc_object_t v29 = 0;
    xpc_release(v28);
    xpc_object_t v28 = 0;
    CFRelease(v17);
LABEL_38:
    sub_100058DB0(&__p, "PreferencesSetValue");
    xpc_object_t v22 = v43;
    if (v43) {
      xpc_retain(v43);
    }
    else {
      xpc_object_t v22 = xpc_null_create();
    }
    TelephonyXPC::Client::performWithBlockingSyncReply();
    xpc_release(v22);
    if (v25 < 0) {
      operator delete(__p);
    }
    if (v38)
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        sub_100651340((uint64_t)&v38, &__p);
        uint64_t v21 = v25 >= 0 ? &__p : (void **)__p;
        int bytes = 136315394;
        long long v45 = "PreferencesSetValue";
        __int16 v46 = 2080;
        unint64_t v47 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", (uint8_t *)&bytes, 0x16u);
        if (v25 < 0) {
          operator delete(__p);
        }
      }
      uint64_t v8 = 0x500000000;
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v8 = 0;
    }
    goto LABEL_48;
  }
  uint64_t v8 = 0x500000000;
  uint64_t v9 = 2;
LABEL_48:
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v36[0]);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
  xpc_release(v42);
  xpc_release(v43);
  return v8 & 0x700000000 | v9;
}

void sub_1006D6C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,xpc_object_t object,xpc_object_t a44)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006D6D4C(int a1, CFStringRef theString, const __CFString *a3, CFPropertyListRef *a4)
{
  *a4 = 0;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  *(_OWORD *)__s = 0u;
  long long v41 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u) || !CFStringGetCString(a3, __s, 256, 0x8000100u))
  {
    uint64_t v8 = 0;
    uint64_t v9 = 2;
    return v8 & 0xF00000000 | v9;
  }
  xpc_object_t v38 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v38 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v38 = v7;
    if (!v7)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_12;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_11:
  xpc_object_t v38 = v10;
LABEL_12:
  xpc_release(v7);
  xpc_object_t v37 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v37 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v37 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_20;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_19:
  xpc_object_t v37 = v13;
LABEL_20:
  xpc_release(v12);
  uint64_t v33 = 3760250881;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  sub_100058DB0(v31, buffer);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_100058DB0(v29, __s);
  if (v32 >= 0) {
    char v14 = v31;
  }
  else {
    char v14 = (void **)v31[0];
  }
  xpc_object_t v27 = xpc_string_create((const char *)v14);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  __p[0] = &v38;
  __p[1] = "AppID";
  sub_100035E70((uint64_t)__p, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v30 >= 0) {
    uint64_t v15 = v29;
  }
  else {
    uint64_t v15 = (void **)v29[0];
  }
  xpc_object_t v25 = xpc_string_create((const char *)v15);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  __p[0] = &v38;
  __p[1] = "Key";
  sub_100035E70((uint64_t)__p, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  sub_100058DB0(__p, "PreferencesCopyValue");
  xpc_object_t v22 = v38;
  if (v38) {
    xpc_retain(v38);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v22);
  xpc_object_t v22 = 0;
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (v33)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v33, __p);
      unint64_t v19 = SHIBYTE(v24) >= 0 ? __p : (void **)__p[0];
      LODWORD(format[0]) = 136315394;
      *(CFPropertyListFormat *)((char *)format + 4) = (CFPropertyListFormat)"PreferencesCopyValue";
      WORD2(format[1]) = 2080;
      *(CFPropertyListFormat *)((char *)&format[1] + 6) = (CFPropertyListFormat)v19;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", (uint8_t *)format, 0x16u);
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 1;
    goto LABEL_50;
  }
  __p[0] = 0;
  __p[1] = 0;
  CFPropertyListFormat v24 = 0;
  v20[0] = &v37;
  v20[1] = "PreferencesCopyValue";
  sub_100048BAC((uint64_t)v20, &v21);
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)long long __p = *(_OWORD *)format;
  CFPropertyListFormat v24 = format[2];
  memset(format, 0, 24);
  xpc_release(v21);
  xpc_object_t v16 = __p[1];
  if (__p[1] == __p[0])
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    if (!__p[1]) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  if (!__p[0]) {
    goto LABEL_44;
  }
  CFDataRef v17 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)__p[0], (char *)__p[1] - (char *)__p[0], kCFAllocatorNull);
  if (v17)
  {
    format[0] = kCFPropertyListXMLFormat_v1_0;
    *a4 = CFPropertyListCreateWithData(kCFAllocatorDefault, v17, 0, format, 0);
    CFRelease(v17);
LABEL_44:
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    goto LABEL_48;
  }
  uint64_t v8 = 0xC00000000;
  uint64_t v9 = 1;
LABEL_48:
  xpc_object_t v16 = __p[0];
  if (__p[0])
  {
LABEL_49:
    __p[1] = v16;
    operator delete(v16);
  }
LABEL_50:
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  xpc_release(v37);
  xpc_release(v38);
  return v8 & 0xF00000000 | v9;
}

void sub_1006D7268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,xpc_object_t object,xpc_object_t a44)
{
  if (__p) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  xpc_release(object);
  xpc_release(a44);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D7390(int a1, CFStringRef theString, const __CFString *a3, CFPropertyListRef *a4)
{
  *a4 = 0;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  *(_OWORD *)__s = 0u;
  long long v41 = 0u;
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u) || !CFStringGetCString(a3, __s, 256, 0x8000100u))
  {
    uint64_t v8 = 0;
    uint64_t v9 = 2;
    return v8 & 0xF00000000 | v9;
  }
  xpc_object_t v38 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v38 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v38 = v7;
    if (!v7)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_12;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_11:
  xpc_object_t v38 = v10;
LABEL_12:
  xpc_release(v7);
  xpc_object_t v37 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v37 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v37 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_20;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_19:
  xpc_object_t v37 = v13;
LABEL_20:
  xpc_release(v12);
  uint64_t v33 = 3760250881;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  sub_100058DB0(v31, buffer);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_100058DB0(v29, __s);
  if (v32 >= 0) {
    char v14 = v31;
  }
  else {
    char v14 = (void **)v31[0];
  }
  xpc_object_t v27 = xpc_string_create((const char *)v14);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  __p[0] = &v38;
  __p[1] = "AppID";
  sub_100035E70((uint64_t)__p, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v30 >= 0) {
    uint64_t v15 = v29;
  }
  else {
    uint64_t v15 = (void **)v29[0];
  }
  xpc_object_t v25 = xpc_string_create((const char *)v15);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  __p[0] = &v38;
  __p[1] = "Key";
  sub_100035E70((uint64_t)__p, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  sub_100058DB0(__p, "PreferencesCopyAppValue");
  xpc_object_t v22 = v38;
  if (v38) {
    xpc_retain(v38);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v22);
  xpc_object_t v22 = 0;
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (v33)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v33, __p);
      unint64_t v19 = SHIBYTE(v24) >= 0 ? __p : (void **)__p[0];
      LODWORD(format[0]) = 136315394;
      *(CFPropertyListFormat *)((char *)format + 4) = (CFPropertyListFormat)"PreferencesCopyAppValue";
      WORD2(format[1]) = 2080;
      *(CFPropertyListFormat *)((char *)&format[1] + 6) = (CFPropertyListFormat)v19;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", (uint8_t *)format, 0x16u);
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 1;
    goto LABEL_50;
  }
  __p[0] = 0;
  __p[1] = 0;
  CFPropertyListFormat v24 = 0;
  v20[0] = &v37;
  v20[1] = "PreferencesCopyAppValue";
  sub_100048BAC((uint64_t)v20, &v21);
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)long long __p = *(_OWORD *)format;
  CFPropertyListFormat v24 = format[2];
  memset(format, 0, 24);
  xpc_release(v21);
  xpc_object_t v16 = __p[1];
  if (__p[1] == __p[0])
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    if (!__p[1]) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  if (!__p[0]) {
    goto LABEL_44;
  }
  CFDataRef v17 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)__p[0], (char *)__p[1] - (char *)__p[0], kCFAllocatorNull);
  if (v17)
  {
    format[0] = kCFPropertyListXMLFormat_v1_0;
    *a4 = CFPropertyListCreateWithData(kCFAllocatorDefault, v17, 0, format, 0);
    CFRelease(v17);
LABEL_44:
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    goto LABEL_48;
  }
  uint64_t v8 = 0xC00000000;
  uint64_t v9 = 1;
LABEL_48:
  xpc_object_t v16 = __p[0];
  if (__p[0])
  {
LABEL_49:
    __p[1] = v16;
    operator delete(v16);
  }
LABEL_50:
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  xpc_release(v37);
  xpc_release(v38);
  return v8 & 0xF00000000 | v9;
}

void sub_1006D78AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,xpc_object_t object,xpc_object_t a44)
{
  if (__p) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  xpc_release(object);
  xpc_release(a44);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D79D4(uint64_t a1, char *a2, char *a3, char *a4)
{
  xpc_object_t v41 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v41 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v41 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_9;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_8:
  xpc_object_t v41 = v9;
LABEL_9:
  xpc_release(v8);
  xpc_object_t v40 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    xpc_object_t v40 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v40 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v11);
    goto LABEL_17;
  }
  xpc_object_t v12 = xpc_null_create();
LABEL_16:
  xpc_object_t v40 = v12;
LABEL_17:
  xpc_release(v11);
  uint64_t v36 = 3760250881;
  xpc_object_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  v34[0] = 0;
  v34[1] = 0;
  uint64_t v35 = 0;
  if (a2) {
    sub_100058DB0(v34, a2);
  }
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  if (a3) {
    sub_100058DB0(v32, a3);
  }
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  if (a4) {
    sub_100058DB0(v30, a4);
  }
  if (v35 >= 0) {
    xpc_object_t v13 = v34;
  }
  else {
    xpc_object_t v13 = (void **)v34[0];
  }
  xpc_object_t v28 = xpc_string_create((const char *)v13);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  long long __p = &v41;
  xpc_object_t v22 = "Path";
  sub_100035E70((uint64_t)&__p, &v28, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (v33 >= 0) {
    char v14 = v32;
  }
  else {
    char v14 = (void **)v32[0];
  }
  xpc_object_t v26 = xpc_string_create((const char *)v14);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  long long __p = &v41;
  xpc_object_t v22 = "LinkPath";
  sub_100035E70((uint64_t)&__p, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v31 >= 0) {
    uint64_t v15 = v30;
  }
  else {
    uint64_t v15 = (void **)v30[0];
  }
  xpc_object_t v24 = xpc_string_create((const char *)v15);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  long long __p = &v41;
  xpc_object_t v22 = "Domain";
  sub_100035E70((uint64_t)&__p, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  sub_100058DB0(&__p, "DomainSymlink");
  xpc_object_t v20 = v41;
  if (v41) {
    xpc_retain(v41);
  }
  else {
    xpc_object_t v20 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v20);
  if (v23 < 0) {
    operator delete(__p);
  }
  if (v36)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v36, &__p);
      unint64_t v19 = v23 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      long long v43 = "DomainSymlink";
      __int16 v44 = 2080;
      long long v45 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v23 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v16 = 0x500000000;
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v16 = 0;
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[0]);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete(v37);
  }
  xpc_release(v40);
  xpc_release(v41);
  return v16 | v17;
}

void sub_1006D7E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D7F24(uint64_t a1, char *a2, char *a3)
{
  xpc_object_t v34 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v34 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v34 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v34 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v33 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v33 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v33 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_17;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_16:
  xpc_object_t v33 = v10;
LABEL_17:
  xpc_release(v9);
  uint64_t v29 = 3760250881;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  v27[0] = 0;
  v27[1] = 0;
  uint64_t v28 = 0;
  if (a2) {
    sub_100058DB0(v27, a2);
  }
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  if (a3) {
    sub_100058DB0(v25, a3);
  }
  if (v28 >= 0) {
    xpc_object_t v11 = v27;
  }
  else {
    xpc_object_t v11 = (void **)v27[0];
  }
  xpc_object_t v23 = xpc_string_create((const char *)v11);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  long long __p = &v34;
  unint64_t v19 = "Path";
  sub_100035E70((uint64_t)&__p, &v23, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v26 >= 0) {
    xpc_object_t v12 = v25;
  }
  else {
    xpc_object_t v12 = (void **)v25[0];
  }
  xpc_object_t v21 = xpc_string_create((const char *)v12);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  long long __p = &v34;
  unint64_t v19 = "LinkPath";
  sub_100035E70((uint64_t)&__p, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  sub_100058DB0(&__p, "BundleSymlink");
  xpc_object_t v17 = v34;
  if (v34) {
    xpc_retain(v34);
  }
  else {
    xpc_object_t v17 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v17);
  if (v20 < 0) {
    operator delete(__p);
  }
  if (v29)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v29, &__p);
      uint64_t v16 = v20 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      uint64_t v36 = "BundleSymlink";
      __int16 v37 = 2080;
      uint64_t v38 = v16;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v20 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v13 = 0x500000000;
    uint64_t v14 = 1;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v13 = 0;
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v30);
  }
  xpc_release(v33);
  xpc_release(v34);
  return v13 | v14;
}

void sub_1006D82C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D83B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v30 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v30 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v30 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v30 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v29 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v29 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_17;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_16:
  xpc_object_t v29 = v10;
LABEL_17:
  xpc_release(v9);
  uint64_t v25 = 3760250881;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  if (*(char *)(a2 + 23) >= 0) {
    xpc_object_t v11 = (const char *)a2;
  }
  else {
    xpc_object_t v11 = *(const char **)a2;
  }
  xpc_object_t v23 = xpc_string_create(v11);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  long long __p = &v30;
  unint64_t v19 = "Path";
  sub_100035E70((uint64_t)&__p, &v23, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (*(char *)(a3 + 23) >= 0) {
    xpc_object_t v12 = (const char *)a3;
  }
  else {
    xpc_object_t v12 = *(const char **)a3;
  }
  xpc_object_t v21 = xpc_string_create(v12);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  long long __p = &v30;
  unint64_t v19 = "Domain";
  sub_100035E70((uint64_t)&__p, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  sub_100058DB0(&__p, "Remove");
  xpc_object_t v17 = v30;
  if (v30) {
    xpc_retain(v30);
  }
  else {
    xpc_object_t v17 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v17);
  if (v20 < 0) {
    operator delete(__p);
  }
  if (v25)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v25, &__p);
      uint64_t v16 = v20 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = "Remove";
      __int16 v33 = 2080;
      xpc_object_t v34 = v16;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v20 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v13 = 0x500000000;
    uint64_t v14 = 1;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v13 = 0;
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v26);
  }
  xpc_release(v29);
  xpc_release(v30);
  return v13 | v14;
}

void sub_1006D86FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D87BC(uint64_t a1, char *a2, char *a3, char *a4, unsigned char *a5)
{
  uint64_t v5 = 22;
  uint64_t v6 = 1;
  if (!a4 || !a3 || !a2 || !a5) {
    return v6 | (v5 << 32);
  }
  xpc_object_t v46 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v46 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v46 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_13;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_12:
  xpc_object_t v46 = v13;
LABEL_13:
  xpc_release(v12);
  xpc_object_t v45 = 0;
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v15 = v14;
  if (v14)
  {
    xpc_object_t v45 = v14;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v45 = v15;
    if (!v15)
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v15 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v15);
    goto LABEL_21;
  }
  xpc_object_t v16 = xpc_null_create();
LABEL_20:
  xpc_object_t v45 = v16;
LABEL_21:
  xpc_release(v15);
  uint64_t v41 = 3760250881;
  long long v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  v39[0] = 0;
  v39[1] = 0;
  uint64_t v40 = 0;
  sub_100058DB0(v39, a2);
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v38 = 0;
  sub_100058DB0(v37, a3);
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  sub_100058DB0(v35, a4);
  if (v40 >= 0) {
    xpc_object_t v17 = v39;
  }
  else {
    xpc_object_t v17 = (void **)v39[0];
  }
  xpc_object_t v33 = xpc_string_create((const char *)v17);
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  long long __p = &v46;
  uint64_t v27 = "SourceDir";
  sub_100035E70((uint64_t)&__p, &v33, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  if (v38 >= 0) {
    xpc_object_t v18 = v37;
  }
  else {
    xpc_object_t v18 = (void **)v37[0];
  }
  xpc_object_t v31 = xpc_string_create((const char *)v18);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  long long __p = &v46;
  uint64_t v27 = "DestDir";
  sub_100035E70((uint64_t)&__p, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (v36 >= 0) {
    unint64_t v19 = v35;
  }
  else {
    unint64_t v19 = (void **)v35[0];
  }
  xpc_object_t v29 = xpc_string_create((const char *)v19);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  long long __p = &v46;
  uint64_t v27 = "Filename";
  sub_100035E70((uint64_t)&__p, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  sub_100058DB0(&__p, "CopyFile");
  xpc_object_t v25 = v46;
  if (v46) {
    xpc_retain(v46);
  }
  else {
    xpc_object_t v25 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v25);
  if (v28 < 0) {
    operator delete(__p);
  }
  if (v41)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v41, &__p);
      xpc_object_t v24 = v28 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "CopyFile";
      __int16 v48 = 2080;
      long long v49 = v24;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v28 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v5 = 5;
    goto LABEL_47;
  }
  long long __p = &v45;
  uint64_t v27 = "CopyFile";
  sub_100048BAC((uint64_t)&__p, buf);
  char v21 = xpc::dyn_cast_or_default((xpc *)buf, 0, v20);
  xpc_release(*(xpc_object_t *)buf);
  *a5 = v21;
  if ((v21 & 1) == 0)
  {
    long long __p = &v45;
    uint64_t v27 = "CopyFileError";
    sub_100048BAC((uint64_t)&__p, buf);
    uint64_t v5 = xpc::dyn_cast_or_default((xpc *)buf, 0, v22);
    xpc_release(*(xpc_object_t *)buf);
LABEL_47:
    uint64_t v6 = 1;
    goto LABEL_48;
  }
  uint64_t v6 = 0;
  uint64_t v5 = 0;
LABEL_48:
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
  if (SHIBYTE(v38) < 0) {
    operator delete(v37[0]);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(v39[0]);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(v42);
  }
  xpc_release(v45);
  xpc_release(v46);
  return v6 | (v5 << 32);
}

void sub_1006D8C70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D8DC0(uint64_t a1, std::string *a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v20 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v20 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v20 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_14;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_15;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_14:
  xpc_object_t v20 = v7;
LABEL_15:
  xpc_release(v6);
  uint64_t v16 = 3760250881;
  xpc_object_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_100058DB0(&__p, "GetCurrentCountryCode");
  xpc_object_t object = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v16)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v16, &__p);
      xpc_object_t v12 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "GetCurrentCountryCode";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 1;
  }
  else
  {
    memset(&__p, 0, sizeof(__p));
    *(void *)long long buf = &v20;
    *(void *)&uint8_t buf[8] = "GetCurrentCountryCode";
    sub_100048BAC((uint64_t)buf, &v13);
    xpc::dyn_cast_or_default((uint64_t *)&__p, (xpc *)&v13, (const object *)"", v10);
    xpc_release(v13);
    std::string::operator=(a2, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v9 = 0;
    uint64_t v8 = 0;
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v17);
  }
  xpc_release(v20);
  xpc_release(v4);
  return v8 | v9;
}

void sub_1006D9098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t object)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  xpc_release(object);
  xpc_release(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_1006D915C(uint64_t a1, char *a2, char *a3, char *a4, unsigned char *a5)
{
  uint64_t v5 = 0x1600000000;
  uint64_t v6 = 1;
  if (!a4 || !a3 || !a2 || !a5) {
    return v5 & 0x1F00000000 | v6;
  }
  xpc_object_t v45 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v45 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v45 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_13;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_12:
  xpc_object_t v45 = v13;
LABEL_13:
  xpc_release(v12);
  xpc_object_t v44 = 0;
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v15 = v14;
  if (v14)
  {
    xpc_object_t v44 = v14;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v44 = v15;
    if (!v15)
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v15 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v16 = xpc_null_create();
LABEL_20:
    xpc_object_t v44 = v16;
    goto LABEL_21;
  }
  xpc_retain(v15);
LABEL_21:
  xpc_release(v15);
  uint64_t v40 = 3760250881;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  v38[0] = 0;
  v38[1] = 0;
  uint64_t v39 = 0;
  sub_100058DB0(v38, a2);
  v36[0] = 0;
  v36[1] = 0;
  uint64_t v37 = 0;
  sub_100058DB0(v36, a3);
  v34[0] = 0;
  v34[1] = 0;
  uint64_t v35 = 0;
  sub_100058DB0(v34, a4);
  if (v39 >= 0) {
    xpc_object_t v17 = v38;
  }
  else {
    xpc_object_t v17 = (void **)v38[0];
  }
  xpc_object_t v32 = xpc_string_create((const char *)v17);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  std::string __p = &v45;
  uint64_t v26 = "SourceDir";
  sub_100035E70((uint64_t)&__p, &v32, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if (v37 >= 0) {
    uint64_t v18 = v36;
  }
  else {
    uint64_t v18 = (void **)v36[0];
  }
  xpc_object_t v30 = xpc_string_create((const char *)v18);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  std::string __p = &v45;
  uint64_t v26 = "DestDir";
  sub_100035E70((uint64_t)&__p, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  if (v35 >= 0) {
    uint64_t v19 = v34;
  }
  else {
    uint64_t v19 = (void **)v34[0];
  }
  xpc_object_t v28 = xpc_string_create((const char *)v19);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  std::string __p = &v45;
  uint64_t v26 = "Filename";
  sub_100035E70((uint64_t)&__p, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  sub_100058DB0(&__p, "MoveFileToDestPath");
  xpc_object_t v24 = v45;
  if (v45) {
    xpc_retain(v45);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v24);
  if (v27 < 0) {
    operator delete(__p);
  }
  if (v40)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v40, &__p);
      xpc_object_t v23 = v27 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "MoveFileToDestPath";
      __int16 v47 = 2080;
      __int16 v48 = v23;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v27 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v5 = 0x500000000;
    uint64_t v6 = 1;
  }
  else
  {
    std::string __p = &v44;
    uint64_t v26 = "MoveFileToDestPath";
    sub_100048BAC((uint64_t)&__p, buf);
    char v21 = xpc::dyn_cast_or_default((xpc *)buf, 0, v20);
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    *a5 = v21;
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v36[0]);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete(v38[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v41);
  }
  xpc_release(v44);
  xpc_release(v45);
  return v5 & 0x1F00000000 | v6;
}

void sub_1006D95D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D970C(uint64_t a1, char *a2, char *a3, unsigned char *a4)
{
  uint64_t v4 = 0x1600000000;
  uint64_t v5 = 1;
  if (!a3 || !a2 || !a4) {
    return v4 & 0x1F00000000 | v5;
  }
  xpc_object_t v38 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v38 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v38 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_12;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_11:
  xpc_object_t v38 = v11;
LABEL_12:
  xpc_release(v10);
  xpc_object_t v37 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v37 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v37 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v13) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v14 = xpc_null_create();
LABEL_19:
    xpc_object_t v37 = v14;
    goto LABEL_20;
  }
  xpc_retain(v13);
LABEL_20:
  xpc_release(v13);
  uint64_t v33 = 3760250881;
  xpc_object_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  sub_100058DB0(v31, a2);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_100058DB0(v29, a3);
  if (v32 >= 0) {
    xpc_object_t v15 = v31;
  }
  else {
    xpc_object_t v15 = (void **)v31[0];
  }
  xpc_object_t v27 = xpc_string_create((const char *)v15);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  std::string __p = &v38;
  xpc_object_t v23 = "IpccPath";
  sub_100035E70((uint64_t)&__p, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v30 >= 0) {
    xpc_object_t v16 = v29;
  }
  else {
    xpc_object_t v16 = (void **)v29[0];
  }
  xpc_object_t v25 = xpc_string_create((const char *)v16);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  std::string __p = &v38;
  xpc_object_t v23 = "DestDir";
  sub_100035E70((uint64_t)&__p, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  sub_100058DB0(&__p, "ExtractBundle");
  xpc_object_t v21 = v38;
  if (v38) {
    xpc_retain(v38);
  }
  else {
    xpc_object_t v21 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v21);
  if (v24 < 0) {
    operator delete(__p);
  }
  if (v33)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v33, &__p);
      BOOL v20 = v24 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "ExtractBundle";
      __int16 v40 = 2080;
      uint64_t v41 = v20;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v24 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v4 = 0x500000000;
    uint64_t v5 = 1;
  }
  else
  {
    std::string __p = &v37;
    xpc_object_t v23 = "ExtractBundle";
    sub_100048BAC((uint64_t)&__p, buf);
    char v18 = xpc::dyn_cast_or_default((xpc *)buf, 0, v17);
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v5 = 0;
    uint64_t v4 = 0;
    *a4 = v18;
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  xpc_release(v37);
  xpc_release(v38);
  return v4 & 0x1F00000000 | v5;
}

void sub_1006D9AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006D9C08(uint64_t a1, uint64_t a2, CFPropertyListRef *a3)
{
  if (!a3) {
    goto LABEL_7;
  }
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  if (!v4)
  {
LABEL_7:
    uint64_t v8 = 0x1600000000;
    uint64_t v9 = 1;
    return v8 & 0x1F00000000 | v9;
  }
  *a3 = 0;
  xpc_object_t v33 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v33 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v33 = v7;
    if (!v7)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_13;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_14;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_13:
  xpc_object_t v33 = v10;
LABEL_14:
  xpc_release(v7);
  xpc_object_t v32 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v32 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v32 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_21;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_22;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_21:
  xpc_object_t v32 = v13;
LABEL_22:
  xpc_release(v12);
  uint64_t v28 = 3760250881;
  xpc_object_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v27 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v27 = *(void *)(a2 + 16);
  }
  if (v27 >= 0) {
    xpc_object_t v14 = __dst;
  }
  else {
    xpc_object_t v14 = (void **)__dst[0];
  }
  xpc_object_t v24 = xpc_string_create((const char *)v14);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  __p[0] = &v33;
  __p[1] = "Path";
  sub_100035E70((uint64_t)__p, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  sub_100058DB0(__p, "LoadPlistAsDictionary");
  xpc_object_t v21 = v33;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v21 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  if (v28)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v28, __p);
      char v18 = SHIBYTE(v23) >= 0 ? __p : (void **)__p[0];
      LODWORD(format[0]) = 136315394;
      *(CFPropertyListFormat *)((char *)format + 4) = (CFPropertyListFormat)"LoadPlistAsDictionary";
      WORD2(format[1]) = 2080;
      *(CFPropertyListFormat *)((char *)&format[1] + 6) = (CFPropertyListFormat)v18;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", (uint8_t *)format, 0x16u);
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 1;
    goto LABEL_50;
  }
  __p[0] = 0;
  __p[1] = 0;
  CFPropertyListFormat v23 = 0;
  v19[0] = &v32;
  v19[1] = "LoadPlistAsDictionary";
  sub_100048BAC((uint64_t)v19, &v20);
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)format;
  CFPropertyListFormat v23 = format[2];
  memset(format, 0, sizeof(format));
  xpc_release(v20);
  xpc_object_t v15 = __p[1];
  if (__p[1] == __p[0])
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    if (!__p[1]) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  if (!__p[0]) {
    goto LABEL_44;
  }
  CFDataRef v16 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)__p[0], (char *)__p[1] - (char *)__p[0], kCFAllocatorNull);
  if (v16)
  {
    format[0] = kCFPropertyListXMLFormat_v1_0;
    *a3 = CFPropertyListCreateWithData(kCFAllocatorDefault, v16, 0, format, 0);
    CFRelease(v16);
LABEL_44:
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    goto LABEL_48;
  }
  uint64_t v8 = 0xC00000000;
  uint64_t v9 = 1;
LABEL_48:
  xpc_object_t v15 = __p[0];
  if (__p[0])
  {
LABEL_49:
    __p[1] = v15;
    operator delete(v15);
  }
LABEL_50:
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  xpc_release(v32);
  xpc_release(v33);
  return v8 & 0x1F00000000 | v9;
}

void sub_1006DA058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (__p) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  xpc_release(*(xpc_object_t *)(v35 - 96));
  xpc_release(*(xpc_object_t *)(v35 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1006DA154(uint64_t a1, const void *a2, const void *a3, void *a4)
{
  *a4 = 0;
  uint64_t v4 = 0x1600000000;
  uint64_t v5 = 1;
  if (!a2 || !a3) {
    return v4 & 0x7F00000000 | v5;
  }
  xpc_object_t v43 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v43 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v43 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_11;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_10:
  xpc_object_t v43 = v11;
LABEL_11:
  xpc_release(v10);
  xpc_object_t v42 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v42 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v42 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_19;
  }
  xpc_object_t v14 = xpc_null_create();
LABEL_18:
  xpc_object_t v42 = v14;
LABEL_19:
  xpc_release(v13);
  uint64_t v38 = 3760250881;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  theCFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, a3, kCFPropertyListXMLFormat_v1_0, 0, 0);
  BytePtr = CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(theData);
  xpc_object_t v34 = xpc_data_create(BytePtr, Length);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  __p[0] = &v43;
  __p[1] = "LabelsData";
  sub_100035E70((uint64_t)__p, &v34, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  BOOL v17 = CFDataGetBytePtr(Data);
  size_t v18 = CFDataGetLength(Data);
  xpc_object_t v32 = xpc_data_create(v17, v18);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  __p[0] = &v43;
  __p[1] = "LanguagesData";
  sub_100035E70((uint64_t)__p, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  sub_100058DB0(__p, "CopyBadgeLabels");
  xpc_object_t v29 = v43;
  if (v43) {
    xpc_retain(v43);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  if (v38)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v38, __p);
      xpc_object_t v25 = v31 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "CopyBadgeLabels";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v25;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v4 = 0x500000000;
    goto LABEL_31;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  v27[0] = (CFPropertyListFormat)&v42;
  v27[1] = (CFPropertyListFormat)"CopyBadgeLabels";
  sub_100048BAC((uint64_t)v27, &v28);
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v31 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  xpc_release(v28);
  uint64_t v19 = __p[1];
  if (__p[1] == __p[0])
  {
    uint64_t v4 = 0x5E00000000;
    uint64_t v5 = 1;
    if (!__p[1]) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  if (__p[0])
  {
    *(void *)long long buf = 0;
    CFDataRef v20 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)__p[0], (char *)__p[1] - (char *)__p[0], kCFAllocatorNull);
    *(void *)long long buf = v20;
    if (v20) {
      xpc_object_t v21 = sub_10008324C;
    }
    else {
      xpc_object_t v21 = 0;
    }
    if (v21)
    {
      v27[0] = kCFPropertyListXMLFormat_v1_0;
      CFPropertyListRef v22 = CFPropertyListCreateWithData(kCFAllocatorDefault, v20, 0, v27, 0);
      CFPropertyListFormat v23 = v22;
      if (v22)
      {
        CFTypeID v24 = CFGetTypeID(v22);
        if (v24 == CFArrayGetTypeID())
        {
          uint64_t v4 = 0;
          uint64_t v5 = 0;
          *a4 = v23;
          goto LABEL_55;
        }
        CFRelease(v23);
        uint64_t v4 = 0x900000000;
      }
      else
      {
        uint64_t v4 = 0x200000000;
      }
    }
    else
    {
      uint64_t v4 = 0xC00000000;
    }
    uint64_t v5 = 1;
LABEL_55:
    sub_100030068((const void **)buf);
    uint64_t v19 = __p[0];
    if (!__p[0]) {
      goto LABEL_57;
    }
LABEL_56:
    __p[1] = v19;
    operator delete(v19);
    goto LABEL_57;
  }
  uint64_t v4 = 0x5E00000000;
LABEL_31:
  uint64_t v5 = 1;
LABEL_57:
  sub_100030068((const void **)&Data);
  sub_100030068((const void **)&theData);
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
  xpc_release(v42);
  xpc_release(v43);
  return v4 & 0x7F00000000 | v5;
}

void sub_1006DA670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,const void *a24,const void *a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100030068(&a24);
  sub_100030068(&a25);
  if (a32 < 0) {
    operator delete(a27);
  }
  xpc_release(*(xpc_object_t *)(v32 - 112));
  xpc_release(*(xpc_object_t *)(v32 - 104));
  _Unwind_Resume(a1);
}

uint64_t sub_1006DA794(uint64_t a1, const void *a2, const void *a3, void *a4)
{
  *a4 = 0;
  uint64_t v4 = 0x1600000000;
  uint64_t v5 = 1;
  if (!a2 || !a3) {
    return v4 & 0x7F00000000 | v5;
  }
  xpc_object_t v43 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v43 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v43 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_11;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_10:
  xpc_object_t v43 = v11;
LABEL_11:
  xpc_release(v10);
  xpc_object_t v42 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v42 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v42 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_19;
  }
  xpc_object_t v14 = xpc_null_create();
LABEL_18:
  xpc_object_t v42 = v14;
LABEL_19:
  xpc_release(v13);
  uint64_t v38 = 3760250881;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  theCFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, a3, kCFPropertyListXMLFormat_v1_0, 0, 0);
  BytePtr = CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(theData);
  xpc_object_t v34 = xpc_data_create(BytePtr, Length);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  __p[0] = &v43;
  __p[1] = "LabelsData";
  sub_100035E70((uint64_t)__p, &v34, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  BOOL v17 = CFDataGetBytePtr(Data);
  size_t v18 = CFDataGetLength(Data);
  xpc_object_t v32 = xpc_data_create(v17, v18);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  __p[0] = &v43;
  __p[1] = "LanguagesData";
  sub_100035E70((uint64_t)__p, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  sub_100058DB0(__p, "CopyLocalizedLabels");
  xpc_object_t v29 = v43;
  if (v43) {
    xpc_retain(v43);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  if (v38)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v38, __p);
      xpc_object_t v25 = v31 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "CopyLocalizedLabels";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v25;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v4 = 0x500000000;
    goto LABEL_31;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  v27[0] = (CFPropertyListFormat)&v42;
  v27[1] = (CFPropertyListFormat)"CopyLocalizedLabels";
  sub_100048BAC((uint64_t)v27, &v28);
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v31 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  xpc_release(v28);
  uint64_t v19 = __p[1];
  if (__p[1] == __p[0])
  {
    uint64_t v4 = 0x5E00000000;
    uint64_t v5 = 1;
    if (!__p[1]) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  if (__p[0])
  {
    *(void *)long long buf = 0;
    CFDataRef v20 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)__p[0], (char *)__p[1] - (char *)__p[0], kCFAllocatorNull);
    *(void *)long long buf = v20;
    if (v20) {
      xpc_object_t v21 = sub_10008324C;
    }
    else {
      xpc_object_t v21 = 0;
    }
    if (v21)
    {
      v27[0] = kCFPropertyListXMLFormat_v1_0;
      CFPropertyListRef v22 = CFPropertyListCreateWithData(kCFAllocatorDefault, v20, 0, v27, 0);
      CFPropertyListFormat v23 = v22;
      if (v22)
      {
        CFTypeID v24 = CFGetTypeID(v22);
        if (v24 == CFArrayGetTypeID())
        {
          uint64_t v4 = 0;
          uint64_t v5 = 0;
          *a4 = v23;
          goto LABEL_55;
        }
        CFRelease(v23);
        uint64_t v4 = 0x900000000;
      }
      else
      {
        uint64_t v4 = 0x200000000;
      }
    }
    else
    {
      uint64_t v4 = 0xC00000000;
    }
    uint64_t v5 = 1;
LABEL_55:
    sub_100030068((const void **)buf);
    uint64_t v19 = __p[0];
    if (!__p[0]) {
      goto LABEL_57;
    }
LABEL_56:
    __p[1] = v19;
    operator delete(v19);
    goto LABEL_57;
  }
  uint64_t v4 = 0x5E00000000;
LABEL_31:
  uint64_t v5 = 1;
LABEL_57:
  sub_100030068((const void **)&Data);
  sub_100030068((const void **)&theData);
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
  xpc_release(v42);
  xpc_release(v43);
  return v4 & 0x7F00000000 | v5;
}

void sub_1006DACB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,const void *a24,const void *a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100030068(&a24);
  sub_100030068(&a25);
  if (a32 < 0) {
    operator delete(a27);
  }
  xpc_release(*(xpc_object_t *)(v32 - 112));
  xpc_release(*(xpc_object_t *)(v32 - 104));
  _Unwind_Resume(a1);
}

uint64_t sub_1006DADD4(uint64_t a1, char *a2, char *a3, unsigned char *a4)
{
  uint64_t v4 = 0x1600000000;
  uint64_t v5 = 1;
  if (!a2 || !a3) {
    return v4 & 0x1F00000000 | v5;
  }
  xpc_object_t v38 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v38 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v38 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_11;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_10:
  xpc_object_t v38 = v11;
LABEL_11:
  xpc_release(v10);
  xpc_object_t v37 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v37 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v37 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v13) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v14 = xpc_null_create();
LABEL_18:
    xpc_object_t v37 = v14;
    goto LABEL_19;
  }
  xpc_retain(v13);
LABEL_19:
  xpc_release(v13);
  uint64_t v33 = 3760250881;
  xpc_object_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  sub_100058DB0(v31, a2);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_100058DB0(v29, a3);
  if (v32 >= 0) {
    xpc_object_t v15 = v31;
  }
  else {
    xpc_object_t v15 = (void **)v31[0];
  }
  xpc_object_t v27 = xpc_string_create((const char *)v15);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  std::string __p = &v38;
  CFPropertyListFormat v23 = "From";
  sub_100035E70((uint64_t)&__p, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v30 >= 0) {
    CFDataRef v16 = v29;
  }
  else {
    CFDataRef v16 = (void **)v29[0];
  }
  xpc_object_t v25 = xpc_string_create((const char *)v16);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  std::string __p = &v38;
  CFPropertyListFormat v23 = "To";
  sub_100035E70((uint64_t)&__p, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  sub_100058DB0(&__p, "RemapContactsChannelIdentifier");
  xpc_object_t v21 = v38;
  if (v38) {
    xpc_retain(v38);
  }
  else {
    xpc_object_t v21 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v21);
  if (v24 < 0) {
    operator delete(__p);
  }
  if (v33)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v33, &__p);
      CFDataRef v20 = v24 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "RemapContactsChannelIdentifier";
      __int16 v40 = 2080;
      uint64_t v41 = v20;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v24 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v4 = 0x500000000;
    uint64_t v5 = 1;
  }
  else
  {
    std::string __p = &v37;
    CFPropertyListFormat v23 = "RemapContactsChannelIdentifier";
    sub_100048BAC((uint64_t)&__p, buf);
    char v18 = xpc::dyn_cast_or_default((xpc *)buf, 0, v17);
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v5 = 0;
    uint64_t v4 = 0;
    *a4 = v18;
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  xpc_release(v37);
  xpc_release(v38);
  return v4 & 0x1F00000000 | v5;
}

void sub_1006DB1C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006DB2CC(uint64_t a1, unsigned char *a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v21 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v21 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v21 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_14;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_15;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_14:
  xpc_object_t v21 = v7;
LABEL_15:
  xpc_release(v6);
  uint64_t v17 = 3760250881;
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_100058DB0(__p, "ResetNetworkSettings");
  xpc_object_t object = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(object);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (v17)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v17, __p);
      xpc_object_t v13 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)CFPropertyListRef v22 = 136315394;
      *(void *)&void v22[4] = "ResetNetworkSettings";
      __int16 v23 = 2080;
      char v24 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", v22, 0x16u);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v8 = 0x500000000;
    uint64_t v9 = 1;
  }
  else
  {
    __p[0] = &v21;
    __p[1] = "ResetNetworkSettings";
    sub_100048BAC((uint64_t)__p, v22);
    char v11 = xpc::dyn_cast_or_default((xpc *)v22, 0, v10);
    xpc_release(*(xpc_object_t *)v22);
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    *a2 = v11;
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v18);
  }
  xpc_release(v21);
  xpc_release(v4);
  return v8 | v9;
}

void sub_1006DB580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006DB63C(uint64_t a1, char *a2, unsigned char *a3)
{
  uint64_t v3 = 22;
  uint64_t v4 = 1;
  if (!a2 || !a3) {
    return v4 | (v3 << 32);
  }
  xpc_object_t v33 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v33 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v33 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_11;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_10:
  xpc_object_t v33 = v9;
LABEL_11:
  xpc_release(v8);
  xpc_object_t v32 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    xpc_object_t v32 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v32 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v12 = xpc_null_create();
LABEL_18:
    xpc_object_t v32 = v12;
    goto LABEL_19;
  }
  xpc_retain(v11);
LABEL_19:
  xpc_release(v11);
  uint64_t v28 = 3760250881;
  xpc_object_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  v26[0] = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  sub_100058DB0(v26, a2);
  if (v27 >= 0) {
    xpc_object_t v13 = v26;
  }
  else {
    xpc_object_t v13 = (void **)v26[0];
  }
  xpc_object_t v24 = xpc_string_create((const char *)v13);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  std::string __p = &v33;
  CFPropertyListRef v22 = "Dir";
  sub_100035E70((uint64_t)&__p, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  sub_100058DB0(&__p, "MakeDir");
  xpc_object_t v20 = v33;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v20 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v20);
  xpc_object_t v20 = 0;
  if (v23 < 0) {
    operator delete(__p);
  }
  if (v28)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v28, &__p);
      char v18 = v23 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "MakeDir";
      __int16 v35 = 2080;
      uint64_t v36 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v23 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v3 = 5;
    uint64_t v4 = 1;
  }
  else
  {
    *(void *)long long buf = 0;
    std::string __p = &v32;
    CFPropertyListRef v22 = "MakeDir";
    sub_10000CB28((uint64_t)&__p, buf);
    std::string __p = buf;
    CFPropertyListRef v22 = "MakeDirResult";
    sub_100048BAC((uint64_t)&__p, &v19);
    char v15 = xpc::dyn_cast_or_default((xpc *)&v19, 0, v14);
    xpc_release(v19);
    *a3 = v15;
    std::string __p = buf;
    CFPropertyListRef v22 = "MakeDirError";
    sub_100048BAC((uint64_t)&__p, &v19);
    uint64_t v3 = xpc::dyn_cast_or_default((xpc *)&v19, 0, v16);
    xpc_release(v19);
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v4 = 0;
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  xpc_release(v32);
  xpc_release(v33);
  return v4 | (v3 << 32);
}

void sub_1006DB9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006DBB04(uint64_t a1, unsigned char *a2)
{
  if (!a2)
  {
    uint64_t v5 = 0x1600000000;
    uint64_t v6 = 1;
    return v5 & 0x1F00000000 | v6;
  }
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v21 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v21 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v21 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v8) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v9 = xpc_null_create();
LABEL_16:
    xpc_object_t v21 = v9;
    goto LABEL_17;
  }
  xpc_retain(v8);
LABEL_17:
  xpc_release(v8);
  uint64_t v17 = 3760250881;
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_100058DB0(__p, "ReadAutomaticBundleUpdateUISetting");
  xpc_object_t object = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(object);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (v17)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v17, __p);
      xpc_object_t v13 = v16 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)CFPropertyListRef v22 = 136315394;
      *(void *)&void v22[4] = "ReadAutomaticBundleUpdateUISetting";
      __int16 v23 = 2080;
      xpc_object_t v24 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", v22, 0x16u);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v5 = 0x500000000;
    uint64_t v6 = 1;
  }
  else
  {
    __p[0] = &v21;
    __p[1] = "ReadAutomaticBundleUpdateUISetting";
    sub_100048BAC((uint64_t)__p, v22);
    char v11 = xpc::dyn_cast_or_default((xpc *)v22, 0, v10);
    xpc_release(*(xpc_object_t *)v22);
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    *a2 = v11;
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v18);
  }
  xpc_release(v21);
  xpc_release(v4);
  return v5 & 0x1F00000000 | v6;
}

void sub_1006DBDCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006DBE88(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (!a3)
  {
    uint64_t v7 = 0x1600000000;
    uint64_t v8 = 1;
    return v7 & 0x1F00000000 | v8;
  }
  xpc_object_t v31 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v31 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v31 = v6;
    if (!v6)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_11;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_10:
  xpc_object_t v31 = v9;
LABEL_11:
  xpc_release(v6);
  xpc_object_t v30 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    xpc_object_t v30 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v30 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v12 = xpc_null_create();
LABEL_18:
    xpc_object_t v30 = v12;
    goto LABEL_19;
  }
  xpc_retain(v11);
LABEL_19:
  xpc_release(v11);
  uint64_t v26 = 3760250881;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v25 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v25 = *(void *)(a2 + 16);
  }
  if (v25 >= 0) {
    xpc_object_t v13 = __dst;
  }
  else {
    xpc_object_t v13 = (void **)__dst[0];
  }
  xpc_object_t v22 = xpc_string_create((const char *)v13);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  std::string __p = &v31;
  uint64_t v20 = "Path";
  sub_100035E70((uint64_t)&__p, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  sub_100058DB0(&__p, "PathExists");
  xpc_object_t v18 = v31;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v18 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v18);
  if (v21 < 0) {
    operator delete(__p);
  }
  if (v26)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v26, &__p);
      uint64_t v17 = v21 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "PathExists";
      __int16 v33 = 2080;
      xpc_object_t v34 = v17;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v21 < 0) {
        operator delete(__p);
      }
    }
    uint64_t v7 = 0x500000000;
    uint64_t v8 = 1;
  }
  else
  {
    std::string __p = &v30;
    uint64_t v20 = "PathExists";
    sub_100048BAC((uint64_t)&__p, buf);
    char v15 = xpc::dyn_cast_or_default((xpc *)buf, 0, v14);
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v8 = 0;
    uint64_t v7 = 0;
    *a3 = v15;
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v27);
  }
  xpc_release(v30);
  xpc_release(v31);
  return v7 & 0x1F00000000 | v8;
}

void sub_1006DC200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006DC2E4(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (!v3)
  {
    uint64_t v9 = 0x1600000000;
    uint64_t v10 = 1;
    return v9 & 0x1F00000000 | v10;
  }
  uint64_t v6 = *(void *)a3;
  *(void *)a3 = 0;
  uint64_t v28 = v6;
  sub_100057D78((const void **)&v28);
  xpc_object_t v33 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v33 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v33 = v8;
    if (!v8)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_13;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_12:
  xpc_object_t v33 = v11;
LABEL_13:
  xpc_release(v8);
  xpc_object_t v32 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v32 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v32 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v13) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v14 = xpc_null_create();
LABEL_20:
    xpc_object_t v32 = v14;
    goto LABEL_21;
  }
  xpc_retain(v13);
LABEL_21:
  xpc_release(v13);
  uint64_t v28 = 3760250881;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v27 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v27 = *(void *)(a2 + 16);
  }
  if (v27 >= 0) {
    char v15 = __dst;
  }
  else {
    char v15 = (void **)__dst[0];
  }
  xpc_object_t v24 = xpc_string_create((const char *)v15);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  __p[0] = &v33;
  __p[1] = "Path";
  sub_100035E70((uint64_t)__p, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  sub_100058DB0(__p, "CopyFileAttributes");
  xpc_object_t v21 = v33;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v21 = xpc_null_create();
  }
  TelephonyXPC::Client::performWithBlockingSyncReply();
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  if (v28)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v28, __p);
      xpc_object_t v18 = v23 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "CopyFileAttributes";
      __int16 v35 = 2080;
      uint64_t v36 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Error performing command %s: [%s]", buf, 0x16u);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v9 = 0x500000000;
    uint64_t v10 = 1;
  }
  else
  {
    xpc_object_t v19 = v32;
    if (v32) {
      xpc_retain(v32);
    }
    else {
      xpc_object_t v19 = xpc_null_create();
    }
    xpc::bridge((uint64_t *)&v20, (xpc *)&v19, v16);
    sub_10004EFE4(buf, &v20);
    if (buf != a3)
    {
      __p[0] = *(void **)a3;
      *(void *)a3 = *(void *)buf;
      *(void *)long long buf = 0;
      sub_100057D78((const void **)__p);
    }
    sub_100057D78((const void **)buf);
    sub_1000577C4(&v20);
    xpc_release(v19);
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  xpc_release(v32);
  xpc_release(v33);
  return v9 & 0x1F00000000 | v10;
}

void sub_1006DC6C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, xpc_object_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1006DC7BC()
{
}

void sub_1006DC8B4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006DC920(uint64_t a1, void *a2, dispatch_object_t *a3, uint64_t *a4)
{
  xpc_object_t v8 = (void *)(a1 + 8);
  uint64_t v9 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v43, kCtLoggingSystemName, "set.cdma.ibi");
  if (v9)
  {
    dispatch_retain(v9);
    uint64_t v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v9);
    dispatch_retain(v9);
    xpc_object_t v11 = dispatch_queue_create_with_target_V2("IBICDMASettingsHandler", v10, v9);
  }
  else
  {
    xpc_object_t v12 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    xpc_object_t v11 = dispatch_queue_create("IBICDMASettingsHandler", v12);
  }
  xpc_object_t v13 = v11;
  *xpc_object_t v8 = 0;
  v8[1] = 0;
  *(void *)(a1 + 24) = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v9)
  {
    dispatch_release(v9);
    dispatch_release(v9);
    dispatch_release(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v39, &v43);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v39);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v43);
  if (v9) {
    dispatch_release(v9);
  }
  v42[0] = off_101999E18;
  v42[1] = sub_1006DD05C;
  v42[3] = v42;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v14) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v42);
  *(void *)a1 = off_1019FC600;
  *(void *)(a1 + 56) = *a2;
  uint64_t v15 = a2[1];
  *(void *)(a1 + 64) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "IBICDMASettingsHandler");
  char v16 = *(NSObject **)(a1 + 24);
  dispatch_object_t v36 = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  uint64_t v17 = *a3;
  dispatch_object_t object = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v36) {
    dispatch_release(v36);
  }
  if (v38 < 0) {
    operator delete(__p);
  }
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  uint64_t v18 = *a4;
  xpc_object_t v19 = *(NSObject **)(a1 + 24);
  dispatch_object_t v34 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  (*(void (**)(OsLogContext *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v18 + 24))(&v43, v18, &v34);
  *(OsLogContext *)(a1 + 152) = v43;
  v43.var0 = 0;
  v43.var1.fRef = 0;
  if (v34) {
    dispatch_release(v34);
  }
  (*(void (**)(void))(*(void *)*a4 + 16))();
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  uint64_t v20 = (uint64_t *)(a1 + 192);
  *(void *)(a1 + 184) = a1 + 192;
  subscriber::makeSimSlotRange();
  xpc_object_t v22 = v39;
  xpc_object_t v21 = v40;
  if (v39 != v40)
  {
    char v23 = v41;
    while ((v23(*v22) & 1) == 0)
    {
      if (++v22 == v21)
      {
        xpc_object_t v22 = v21;
        break;
      }
    }
    xpc_object_t v24 = v40;
LABEL_42:
    while (v22 != v24)
    {
      signed int v25 = *v22;
      LOBYTE(v43.var0) = 0;
      char v44 = 0;
      uint64_t v26 = (void *)(a1 + 192);
      uint64_t v27 = (void *)(a1 + 192);
      uint64_t v28 = *v20;
      if (*v20)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v27 = (void *)v28;
            signed int v29 = *(_DWORD *)(v28 + 32);
            if (v29 <= v25) {
              break;
            }
            uint64_t v28 = *v27;
            uint64_t v26 = v27;
            if (!*v27) {
              goto LABEL_50;
            }
          }
          if (v29 >= v25) {
            break;
          }
          uint64_t v28 = v27[1];
          if (!v28)
          {
            uint64_t v26 = v27 + 1;
            goto LABEL_50;
          }
        }
      }
      else
      {
LABEL_50:
        uint64_t v30 = operator new(0xB8uLL);
        v30[8] = v25;
        *((unsigned char *)v30 + 40) = 0;
        *((unsigned char *)v30 + 176) = 0;
        *(void *)uint64_t v30 = 0;
        *((void *)v30 + 1) = 0;
        *((void *)v30 + 2) = v27;
        *uint64_t v26 = v30;
        uint64_t v31 = **(void **)(a1 + 184);
        if (v31)
        {
          *(void *)(a1 + 184) = v31;
          uint64_t v30 = (_DWORD *)*v26;
        }
        sub_100046C90(*(uint64_t **)(a1 + 192), (uint64_t *)v30);
        ++*(void *)(a1 + 200);
      }
      sub_10057CA94((uint64_t)&v43);
      xpc_object_t v32 = v22 + 1;
      xpc_object_t v22 = v21;
      if (v32 != v21)
      {
        xpc_object_t v22 = v32;
        while ((v23(*v22) & 1) == 0)
        {
          if (++v22 == v21)
          {
            xpc_object_t v22 = v21;
            goto LABEL_42;
          }
        }
      }
    }
  }
  return a1;
}

void sub_1006DCE80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_1006DD05C(int a1)
{
  uint64_t v1 = "set.cdma.ibi.?";
  if (a1 == 2) {
    uint64_t v1 = "set.cdma.ibi.2";
  }
  if (a1 == 1) {
    return "set.cdma.ibi.1";
  }
  else {
    return v1;
  }
}

void sub_1006DD088(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DD188(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DD2A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DD388(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DD468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

BOOL sub_1006DD470(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_100F60D60(*(void *)(a1 + 120), a2, a3, a4, a5, a6);
}

void sub_1006DD478(uint64_t a1, unsigned int a2, int a3, CSIPhoneNumber *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
}

void sub_1006DD480(uint64_t a1, int a2)
{
}

BOOL sub_1006DD488(uint64_t a1, int a2, unsigned char *a3)
{
  return sub_100571328(*(void *)(a1 + 136), a2, a3);
}

void sub_1006DD490(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
}

BOOL sub_1006DD498(uint64_t a1, int a2, uint64_t a3)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = (uint64_t)&v8;
  uint64_t v7[2] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1006DFC1C(v7);
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1006E0084;
  v9[3] = &unk_1019FC978;
  v9[4] = a1 + 8;
  v9[5] = v7;
  uint64_t v10 = v9;
  uint64_t v6 = *(NSObject **)(a1 + 24);
  char v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    xpc_object_t v12 = sub_10005A124;
    xpc_object_t v13 = &unk_1019FC998;
    xpc_object_t v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_sync(v6, block);
  }
  else
  {
    xpc_object_t v12 = sub_10005AE88;
    xpc_object_t v13 = &unk_1019FC9B8;
    xpc_object_t v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_async_and_wait(v6, block);
  }
  return v16 != 0;
}

void sub_1006DD618(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DD70C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_1006DD7FC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned char *a5, unsigned char *a6, unsigned char *a7)
{
  *a7 = 0;
  uint64_t v10 = *(void *)(a1 + 192);
  if (v10)
  {
    uint64_t v12 = a1 + 192;
    do
    {
      int v13 = *(_DWORD *)(v10 + 32);
      BOOL v14 = v13 < (int)a2;
      if (v13 >= (int)a2) {
        uint64_t v15 = (uint64_t *)v10;
      }
      else {
        uint64_t v15 = (uint64_t *)(v10 + 8);
      }
      if (!v14) {
        uint64_t v12 = v10;
      }
      uint64_t v10 = *v15;
    }
    while (*v15);
    if (v12 != a1 + 192 && *(_DWORD *)(v12 + 32) <= (int)a2)
    {
      if (!*(unsigned char *)(v12 + 176))
      {
        uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Phone number not read yet; MDN not yet attempted: MDN read not attempted yet #pnr",
            (uint8_t *)&buf,
            2u);
        }
        return *a7 != 0;
      }
      xpc_object_t v19 = (CSIPhoneNumber *)(v12 + 40);
      *a5 = 1;
      if (*((char *)a3 + 23) < 0)
      {
        a3[1] = 0;
        a3 = (uint64_t *)*a3;
      }
      else
      {
        *((unsigned char *)a3 + 23) = 0;
      }
      *(unsigned char *)a3 = 0;
      *a6 = 0;
      *a7 = 1;
      CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, v19);
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
      {
        data = buf.var2.__r_.__value_.var0.var1.__data_;
        operator delete(*(void **)&buf.var0);
        if (data)
        {
LABEL_23:
          CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, v19);
          *((_DWORD *)&buf.var2.__r_.__value_.var0.var1 + 4) = 1;
          std::string::operator=((std::string *)a4, (const std::string *)&buf);
          *(_DWORD *)(a4 + 24) = *((_DWORD *)&buf.var2.__r_.__value_.var0.var1 + 4);
          if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
            operator delete(*(void **)&buf.var0);
          }
          return *a7 != 0;
        }
      }
      else if (buf.var2.__r_.__value_.var0.var0.__data_[15])
      {
        goto LABEL_23;
      }
      int v22 = subscriber::simSlotAsInstance();
      long long v72 = 0;
      char v23 = off_1019FC6D0[v22];
      CFStringRef v24 = kCFPreferencesCurrentUser;
      CFStringRef v25 = kCFPreferencesAnyHost;
      (*(void (**)(CSIPhoneNumber *__return_ptr))(**(void **)(a1 + 168) + 40))(&buf);
      sub_100056248(&v72, (CFTypeRef *)&buf);
      sub_1000577C4((const void **)&buf);
      long long v71 = 0;
      uint64_t v26 = off_1019FC6E0[v22];
      (*(void (**)(CSIPhoneNumber *__return_ptr))(**(void **)(a1 + 168) + 40))(&buf);
      sub_100056248(&v71, (CFTypeRef *)&buf);
      sub_1000577C4((const void **)&buf);
      if (v72) {
        uint64_t v27 = sub_1000810B8;
      }
      else {
        uint64_t v27 = 0;
      }
      if (!v27 || (v71 ? (uint64_t v28 = sub_1000810B8) : (uint64_t v28 = 0), !v28))
      {
        uint64_t v41 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        uint64_t v17 = 0;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Could not retrieve persisted CDMA phone number, bailing out #pnr", (uint8_t *)&buf, 2u);
          uint64_t v17 = 0;
        }
        goto LABEL_109;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      uint64_t v30 = ServiceMap;
      if (v31 < 0)
      {
        xpc_object_t v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v33 = 5381;
        do
        {
          uint64_t v31 = v33;
          unsigned int v34 = *v32++;
          uint64_t v33 = (33 * v33) ^ v34;
        }
        while (v34);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&buf.var0 = v31;
      __int16 v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)&buf);
      long long v65 = v23;
      if (v35)
      {
        dispatch_object_t v36 = v26;
        uint64_t v38 = v35[3];
        xpc_object_t v37 = (std::__shared_weak_count *)v35[4];
        if (v37)
        {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v30);
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v39 = v37;
          sub_10004D2C8(v37);
          char v40 = 0;
          uint64_t v26 = v36;
          CFStringRef v25 = kCFPreferencesAnyHost;
          CFStringRef v24 = kCFPreferencesCurrentUser;
          goto LABEL_45;
        }
        uint64_t v26 = v36;
        CFStringRef v25 = kCFPreferencesAnyHost;
        CFStringRef v24 = kCFPreferencesCurrentUser;
      }
      else
      {
        uint64_t v38 = 0;
      }
      std::mutex::unlock(v30);
      uint64_t v39 = 0;
      char v40 = 1;
LABEL_45:
      if (!v38)
      {
        long long v56 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.var0) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Could not get Subscriber SIM controller for getting persisted phone number", (uint8_t *)&buf, 2u);
        }
        uint64_t v17 = 0;
        goto LABEL_107;
      }
      __s1 = 0;
      size_t __n = 0;
      uint64_t v70 = 0;
      (*(void (**)(uint64_t, uint64_t, void, void **))(*(void *)v38 + 200))(v38, a2, 0, &__s1);
      size_t v42 = HIBYTE(v70);
      if (v70 < 0) {
        size_t v42 = __n;
      }
      if (v42)
      {
        memset(&buf, 0, 24);
        ctu::cf::assign();
        __str.__r_.__value_.__r.__words[2] = buf.var2.__r_.__value_.var0.var1.__size_;
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)&buf.var0;
        if (v70 >= 0) {
          size_t v43 = HIBYTE(v70);
        }
        else {
          size_t v43 = __n;
        }
        std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        int v45 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __str.__r_.__value_.__l.__size_;
        }
        if (v43 == size)
        {
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (v70 < 0)
          {
            BOOL v55 = memcmp(__s1, p_str, __n) == 0;
          }
          else if (HIBYTE(v70))
          {
            uint64_t v47 = HIBYTE(v70) - 1;
            p_s1 = &__s1;
            do
            {
              int v50 = *(unsigned __int8 *)p_s1;
              p_s1 = (void **)((char *)p_s1 + 1);
              int v49 = v50;
              int v52 = p_str->__r_.__value_.__s.__data_[0];
              p_str = (std::string *)((char *)p_str + 1);
              int v51 = v52;
              BOOL v54 = v47-- != 0;
              BOOL v55 = v49 == v51;
            }
            while (v49 == v51 && v54);
          }
          else
          {
            BOOL v55 = 1;
          }
        }
        else
        {
          BOOL v55 = 0;
        }
        if (v45 < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (v55)
        {
          long long v73 = 0uLL;
          uint64_t v74 = 0;
          ctu::cf::assign();
          long long v66 = (void *)v73;
          char v67 = HIBYTE(v74);
          CSIPhoneNumber::CSIPhoneNumber();
          CSIPhoneNumber::getFullNumber((uint64_t *)&__str, &buf);
          int v82 = 3;
          std::string::operator=((std::string *)a4, &__str);
          *(_DWORD *)(a4 + 24) = v82;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          if (v80 < 0) {
            operator delete(__p);
          }
          if (v78 < 0) {
            operator delete(v77);
          }
          if (v76 < 0) {
            operator delete(*(void **)&buf.var2.__r_.var0);
          }
          if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
            operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
          }
          if (v67 < 0) {
            operator delete(v66);
          }
          long long v58 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            asString();
            long long v59 = buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &buf : *(CSIPhoneNumber **)&buf.var0;
            LODWORD(__str.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Retrieved the CDMA Network phone number %s from persistent storage #pnr", (uint8_t *)&__str, 0xCu);
            if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              operator delete(*(void **)&buf.var0);
            }
          }
          uint64_t v17 = 1;
          goto LABEL_105;
        }
        long long v60 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#N Cannot validate the number as the ICCIDs are not matching, clearing out cache #pnr", (uint8_t *)&buf, 2u);
        }
        (*(void (**)(void, __CFString *, void, const __CFString *, CFStringRef, CFStringRef))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168), v65, 0, @"com.apple.commcenter", v24, v25);
        (*(void (**)(void, __CFString *, void, const __CFString *, CFStringRef, CFStringRef))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168), v26, 0, @"com.apple.commcenter", v24, v25);
        (*(void (**)(void, const __CFString *, CFStringRef, CFStringRef))(**(void **)(a1 + 168) + 48))(*(void *)(a1 + 168), @"com.apple.commcenter", v24, v25);
        long long v61 = *(std::__shared_weak_count **)(a1 + 96);
        if (v61)
        {
          long long v62 = std::__shared_weak_count::lock(v61);
          if (v62)
          {
            long long v63 = v62;
            uint64_t v64 = *(void *)(a1 + 88);
            if (v64) {
              (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*(void *)v64 + 304))(v64, a2, 1, "getPersistedPhoneNumber_sync");
            }
            sub_10004D2C8(v63);
          }
        }
      }
      else
      {
        long long v57 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        uint64_t v17 = 0;
        if (!os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_105;
        }
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#N Cached ICCID is available, but ICCID from subscriber is not available yet #pnr", (uint8_t *)&buf, 2u);
      }
      uint64_t v17 = 0;
LABEL_105:
      if (SHIBYTE(v70) < 0) {
        operator delete(__s1);
      }
LABEL_107:
      if ((v40 & 1) == 0) {
        sub_10004D2C8(v39);
      }
LABEL_109:
      sub_1000558F4(&v71);
      sub_1000558F4(&v72);
      return v17;
    }
  }
  char v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    buf.var0 = 136315138;
    *(void *)&buf.var1 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "cannot find model for slot %s", (uint8_t *)&buf, 0xCu);
  }
  return *a7 != 0;
}

void sub_1006DE1E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,const void *a25,__int16 a26,char a27,char a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_10004D2C8(v40);
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  sub_1000558F4(&a24);
  sub_1000558F4(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_1006DE310(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v12 = a2;
  v11[0] = a1;
  v11[1] = &v12;
  _OWORD v11[2] = a3;
  void v11[3] = a4;
  v11[4] = a5;
  uint64_t v11[5] = a6;
  v11[6] = a7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1006E0C20((uint64_t)v11);
    }
    BOOL v9 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  void v13[2] = sub_1006E0D8C;
  v13[3] = &unk_1019FC9D8;
  void v13[4] = a1 + 8;
  void v13[5] = v11;
  BOOL v14 = v13;
  uint64_t v10 = *(NSObject **)(a1 + 24);
  char v20 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v9)
  {
    char v16 = sub_10005A124;
    uint64_t v17 = &unk_1019FC998;
    uint64_t v18 = &v20;
    xpc_object_t v19 = &v14;
    dispatch_sync(v10, block);
  }
  else
  {
    char v16 = sub_10005AE88;
    uint64_t v17 = &unk_1019FC9B8;
    uint64_t v18 = &v20;
    xpc_object_t v19 = &v14;
    dispatch_async_and_wait(v10, block);
  }
  return v20 != 0;
}

void sub_1006DE498(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_10009DB3C((uint64_t)&v6, a4);
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006DE5F4(uint64_t a1, unsigned int *a2)
{
  if (a2[1] == 9)
  {
    uint64_t v4 = *(void *)(a1 + 192);
    uint64_t v5 = *a2;
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v6 = a1 + 192;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)v5;
      if (v7 >= (int)v5) {
        BOOL v9 = (uint64_t *)v4;
      }
      else {
        BOOL v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 192 && (int)v5 >= *(_DWORD *)(v6 + 32))
    {
      xpc_object_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      subscriber::sParseMdn();
      uint64_t v30 = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      *(_OWORD *)uint64_t v26 = 0u;
      *(_OWORD *)uint64_t v27 = 0u;
      long long v25 = 0u;
      memset(&v24, 0, sizeof(v24));
      CSIPhoneNumber::CSIPhoneNumber(&v24);
      CSIPhoneNumber::setBaseNumber();
      if (*(unsigned char *)(v6 + 176))
      {
        *(void *)(v6 + 40) = *(void *)&v24.var0;
        std::string::operator=((std::string *)(v6 + 48), (const std::string *)&v24.var2);
        std::string::operator=((std::string *)(v6 + 72), (const std::string *)&v24.var2.__r_.var0);
        *(_DWORD *)(v6 + 96) = DWORD2(v25);
        *(unsigned char *)(v6 + 100) = BYTE12(v25);
        std::string::operator=((std::string *)(v6 + 104), (const std::string *)v26);
        std::string::operator=((std::string *)(v6 + 128), (const std::string *)&v27[1]);
        *(_OWORD *)(v6 + 152) = v29;
        *(unsigned char *)(v6 + 168) = v30;
      }
      else
      {
        sub_10009DB3C(v6 + 40, (uint64_t)&v24);
        *(unsigned char *)(v6 + 176) = 1;
      }
      xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)__p, &v24);
        int v12 = v18 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        char v23 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Device Phone number is: %s", buf, 0xCu);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }
      int v13 = *(std::__shared_weak_count **)(a1 + 96);
      if (v13)
      {
        BOOL v14 = std::__shared_weak_count::lock(v13);
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = *(void *)(a1 + 88);
          if (v16) {
            (*(void (**)(uint64_t, void, uint64_t, const char *))(*(void *)v16 + 304))(v16, *a2, 1, "handleSimFileEvent");
          }
          sub_10004D2C8(v15);
        }
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(v27[1]);
      }
      if (SHIBYTE(v27[0]) < 0) {
        operator delete(v26[0]);
      }
      if (SBYTE7(v25) < 0) {
        operator delete(*(void **)&v24.var2.__r_.var0);
      }
      if (*((char *)&v24.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(v24.var2.__r_.__value_.var0.var1.__data_);
      }
      if (SHIBYTE(v21) < 0) {
        operator delete(v19);
      }
    }
    else
    {
LABEL_12:
      uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v24.var0 = 136315138;
        *(void *)&v24.var1 = subscriber::asString();
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "cannot find model for slot %s", (uint8_t *)&v24, 0xCu);
      }
    }
  }
}

void sub_1006DE940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  sub_10004D2C8(v20);
  sub_100087E24((uint64_t)&a20);
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1006DE990(uint64_t a1)
{
  sub_1006DEA38(a1);

  operator delete();
}

void sub_1006DE9E4(void *a1)
{
  if (a1)
  {
    sub_1006DE9E4(*a1);
    sub_1006DE9E4(a1[1]);
    sub_10057CA94((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void sub_1006DEA38(uint64_t a1)
{
  *(void *)a1 = off_1019FC600;
  sub_1006DE9E4(*(void **)(a1 + 192));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 160);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 144);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 128);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 112);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  BOOL v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    sub_10004D2C8(v8);
  }
  BOOL v9 = *(std::__shared_weak_count **)(a1 + 64);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CDMASettingsInterface::~CDMASettingsInterface((CDMASettingsInterface *)a1);
}

void sub_1006DEB34(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006DEC00(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1006DECD8);
  __cxa_rethrow();
}

void sub_1006DEC28(_Unwind_Exception *a1)
{
}

void sub_1006DEC40(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006DEC78(uint64_t a1)
{
}

uint64_t sub_1006DEC94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006DECD8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1006DED08()
{
}

uint64_t sub_1006DED1C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_1006DED28(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 104);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = *(void *)(v2 + 120);
  if (v4) {
    ctu::RestModule::disconnect((ctu::RestModule *)(v4 + 88));
  }
  uint64_t v5 = *(void *)(v2 + 136);
  if (v5) {
    ctu::RestModule::disconnect((ctu::RestModule *)(v5 + 72));
  }
  sub_100088C88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1006DEDB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1006DEDD0(uint64_t **a1)
{
  uint64_t v2 = **a1;
  uint64_t v1 = (*a1)[1];
  uint64_t v3 = (*a1)[2];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 96);
  *(void *)(v2 + 88) = v1;
  *(void *)(v2 + 96) = v3;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  Registry::getCommandDriversFactory((uint64_t *)&__p, *(Registry **)(v2 + 56));
  uint64_t v5 = __p;
  uint64_t v6 = *(NSObject **)(v2 + 24);
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  (*(void (**)(uint8_t *__return_ptr, void *, dispatch_object_t *))(*(void *)v5 + 248))(buf, v5, &object);
  int v7 = *(std::__shared_weak_count **)(v2 + 112);
  *(_OWORD *)(v2 + 104) = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  if (v7)
  {
    sub_10004D2C8(v7);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (object) {
    dispatch_release(object);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1006DF268((uint64_t)&__p, (void *)(v2 + 56), (NSObject **)(v2 + 24), v2 + 104);
}

void sub_1006DF15C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,void *a21)
{
  sub_1000346F8((uint64_t)&a20, a21);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  sub_1006DF1FC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006DF1FC(uint64_t *result)
{
  uint64_t v1 = *result;
  _WORD *result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 24);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 24);
      if (v3) {
        dispatch_release(v3);
      }
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete();
  }
  return result;
}

void sub_1006DF268(uint64_t a1, void *a2, NSObject **a3, uint64_t a4)
{
  int v7 = operator new(0xE8uLL);
  sub_1006DF2F4(v7, a2, a3, a4);
}

void sub_1006DF2E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1006DF2F4(void *a1, void *a2, NSObject **a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019FC868;
  sub_1006DF3EC(a1 + 3, a2, a3, a4);
}

void sub_1006DF33C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1006DF350(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FC868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006DF370(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FC868;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006DF3C4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1006DF3EC(void *a1, void *a2, NSObject **a3, uint64_t a4)
{
  int v7 = *a3;
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  uint64_t v8 = *(void *)(a4 + 8);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100F5F82C(a1, a2, &object);
}

void sub_1006DF47C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006DF4A0(void *a1@<X1>, NSObject **a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0xE0uLL);
  sub_1006DF534(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_1000B3BC8((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_1006DF520(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1006DF534(void *a1, void *a2, NSObject **a3, uint64_t *a4, uint64_t *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019FC8B8;
  sub_1006DF62C((uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_1006DF57C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1006DF590(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FC8B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006DF5B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FC8B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006DF604(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1006DF62C(uint64_t a1, void *a2, NSObject **a3, uint64_t *a4, uint64_t *a5)
{
  BOOL v9 = *a3;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  uint64_t v10 = *a4;
  xpc_object_t v11 = (std::__shared_weak_count *)a4[1];
  v16[0] = v10;
  v16[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *a5;
  int v13 = (std::__shared_weak_count *)a5[1];
  v15[0] = v12;
  v15[1] = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10057018C(a1, a2, &object, v16, v15);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (object) {
    dispatch_release(object);
  }
  return a1;
}

void sub_1006DF6E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006DF71C()
{
}

__n128 sub_1006DF730(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019FC908;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1006DF784(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FC908;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1006DF7BC(void *a1)
{
  uint64_t v5 = 0x2800000000;
  std::string __p = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p)
  {
    int v7 = __p;
    operator delete(__p);
  }
}

void sub_1006DF854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006DF870(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006DF8B0()
{
}

void sub_1006DF8BC(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[13];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = v1[15];
  if (v3) {
    sub_100F601D0(v3);
  }
  uint64_t v4 = v1[17];
  if (v4) {
    sub_10057089C(v4);
  }
  operator delete();
}

void sub_1006DF950()
{
}

void sub_1006DF97C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v3 = v19;
  uint64_t v2 = v20;
  if (v19 != v20)
  {
    uint64_t v4 = v21;
    do
    {
      if (v21(*v3)) {
        goto LABEL_6;
      }
      ++v3;
    }
    while (v3 != v20);
    uint64_t v3 = v20;
LABEL_6:
    uint64_t v5 = v20;
    while (v3 != v5)
    {
      signed int v6 = *v3;
      int v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *v3);
      uint64_t v8 = *(uint64_t **)(v1 + 192);
      if (!v8) {
LABEL_34:
      }
        sub_1000C14F0("map::at:  key not found");
      while (1)
      {
        while (1)
        {
          signed int v9 = *((_DWORD *)v8 + 8);
          if (v9 <= v6) {
            break;
          }
          uint64_t v8 = (uint64_t *)*v8;
          if (!v8) {
            goto LABEL_34;
          }
        }
        if (v9 >= v6) {
          break;
        }
        uint64_t v8 = (uint64_t *)v8[1];
        if (!v8) {
          goto LABEL_34;
        }
      }
      int v10 = *((unsigned __int8 *)v8 + 176);
      xpc_object_t v11 = *v7;
      BOOL v12 = os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v12)
        {
          CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(v8 + 5));
          int v13 = __p;
          if (v18 < 0) {
            int v13 = (void **)__p[0];
          }
          *(_DWORD *)CSIPhoneNumber buf = 136315138;
          char v23 = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I MDN: %s", buf, 0xCu);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
        }
      }
      else if (v12)
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I No MDN read", (uint8_t *)__p, 2u);
      }
      BOOL v14 = v3 + 1;
      uint64_t v3 = v2;
      if (v14 != v2)
      {
        uint64_t v3 = v14;
        do
        {
          if (v4(*v3)) {
            goto LABEL_28;
          }
          ++v3;
        }
        while (v3 != v2);
        uint64_t v3 = v2;
      }
LABEL_28:
      ;
    }
  }
  uint64_t v15 = *(void *)(v1 + 120);
  if (v15) {
    sub_100F61AF8(v15);
  }
  uint64_t v16 = *(void *)(v1 + 136);
  if (v16) {
    sub_100571904(v16);
  }
  operator delete();
}

void sub_1006DFBE0()
{
}

BOOL sub_1006DFC1C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*a1 + 192);
  uint64_t v4 = *(unsigned int *)a1[1];
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v5 = *a1 + 192;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < (int)v4;
    if (v6 >= (int)v4) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == *a1 + 192 || (int)v4 < *(_DWORD *)(v5 + 32))
  {
LABEL_11:
    signed int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "cannot find model for slot %s", buf, 0xCu);
    }
    return 0;
  }
  if (!*(unsigned char *)(v5 + 176))
  {
    CSIPhoneNumber v24 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48));
    BOOL v10 = 0;
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      return v10;
    }
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N VM number not read yet; MDN read not attempted yet #pnr",
      buf,
      2u);
    return 0;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(v5 + 40));
  BOOL v12 = (void *)HIBYTE(v31);
  if (v31 < 0) {
    BOOL v12 = __p[1];
  }
  BOOL v10 = v12 != 0;
  if (v12)
  {
    std::operator+<char>();
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[0]);
    }
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v31 = *(void *)&buf[16];
    CSIPhoneNumber::CSIPhoneNumber();
    uint64_t v13 = a1[2];
    *(void *)uint64_t v13 = *(void *)buf;
    BOOL v14 = (void **)(v13 + 8);
    if (*(char *)(v13 + 31) < 0) {
      operator delete(*v14);
    }
    long long v15 = *(_OWORD *)&buf[8];
    *(void *)(v13 + 24) = v35;
    *(_OWORD *)BOOL v14 = v15;
    HIBYTE(v35) = 0;
    uint8_t buf[8] = 0;
    uint64_t v16 = (void **)(v13 + 32);
    if (*(char *)(v13 + 55) < 0) {
      operator delete(*v16);
    }
    long long v17 = v36;
    *(void *)(v13 + 48) = v37;
    *(_OWORD *)uint64_t v16 = v17;
    HIBYTE(v37) = 0;
    LOBYTE(v36) = 0;
    char v18 = v39;
    *(_DWORD *)(v13 + 56) = v38;
    *(unsigned char *)(v13 + 60) = v18;
    xpc_object_t v19 = (void **)(v13 + 64);
    if (*(char *)(v13 + 87) < 0) {
      operator delete(*v19);
    }
    long long v20 = v40;
    *(void *)(v13 + 80) = v41;
    *(_OWORD *)xpc_object_t v19 = v20;
    HIBYTE(v41) = 0;
    LOBYTE(v40) = 0;
    uint64_t v21 = (_OWORD *)(v13 + 88);
    if (*(char *)(v13 + 111) < 0)
    {
      operator delete(*(void **)(v13 + 88));
      int v25 = SHIBYTE(v41);
      long long v26 = v42;
      *(void *)(v13 + 104) = v43;
      *uint64_t v21 = v26;
      HIBYTE(v43) = 0;
      LOBYTE(v42) = 0;
      char v27 = v45;
      *(_OWORD *)(v13 + 112) = v44;
      *(unsigned char *)(v13 + 128) = v27;
      if (v25 < 0) {
        operator delete((void *)v40);
      }
    }
    else
    {
      long long v22 = v42;
      *(void *)(v13 + 104) = v43;
      *uint64_t v21 = v22;
      HIBYTE(v43) = 0;
      LOBYTE(v42) = 0;
      char v23 = v45;
      *(_OWORD *)(v13 + 112) = v44;
      *(unsigned char *)(v13 + 128) = v23;
    }
    if (SHIBYTE(v37) < 0) {
      operator delete((void *)v36);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(*(void **)&buf[8]);
    }
    long long v28 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)a1[1]);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)a1[2]);
      long long v29 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)xpc_object_t v32 = 136315138;
      uint64_t v33 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N VoiceMailNumber = %s", v32, 0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  return v10;
}

void sub_1006E0054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006E0084(uint64_t a1)
{
  return sub_1006DFC1C(*(uint64_t **)(a1 + 40));
}

void sub_1006E008C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(void *)(v2 + 192);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    uint64_t v5 = v2 + 192;
    do
    {
      int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 < (int)v4;
      if (v6 >= (int)v4) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != v2 + 192 && (int)v4 >= *(_DWORD *)(v5 + 32))
    {
      if (*(unsigned char *)(v5 + 176) && subscriber::isSimAbsent())
      {
        signed int v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Clearing off the cached phone number and setting MDN requested to false", buf, 2u);
        }
        if (*(unsigned char *)(v5 + 176))
        {
          if (*(char *)(v5 + 151) < 0) {
            operator delete(*(void **)(v5 + 128));
          }
          if (*(char *)(v5 + 127) < 0) {
            operator delete(*(void **)(v5 + 104));
          }
          if (*(char *)(v5 + 95) < 0) {
            operator delete(*(void **)(v5 + 72));
          }
          if (*(char *)(v5 + 71) < 0) {
            operator delete(*(void **)(v5 + 48));
          }
          *(unsigned char *)(v5 + 176) = 0;
        }
        BOOL v10 = *(std::__shared_weak_count **)(v2 + 96);
        if (v10)
        {
          xpc_object_t v11 = std::__shared_weak_count::lock(v10);
          if (v11)
          {
            uint64_t v12 = *(void *)(v2 + 88);
            if (v12)
            {
              (*(void (**)(uint64_t, void, uint64_t, const char *))(*(void *)v12 + 304))(v12, *((unsigned int *)v1 + 2), 1, "handleSimState");
              goto LABEL_36;
            }
          }
        }
        else
        {
          xpc_object_t v11 = 0;
        }
        BOOL v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          if (!v11) {
            goto LABEL_32;
          }
          goto LABEL_36;
        }
        *(_WORD *)CSIPhoneNumber buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not get SettingsInterface to update phone numbers REST property", buf, 2u);
        if (v11) {
LABEL_36:
        }
          sub_10004D2C8(v11);
      }
LABEL_32:
      operator delete();
    }
  }
  else
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
  }
  uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CSIPhoneNumber buf = 136315138;
    uint64_t v16 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "cannot find model for slot %s", buf, 0xCu);
  }
  goto LABEL_32;
}

void sub_1006E037C()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_1006E03C4(unsigned int **a1)
{
  uint64_t v1 = *((void *)*a1 + 1);
  uint64_t v2 = **a1;
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  *(_OWORD *)long long v26 = 0u;
  long long v27 = 0u;
  __int16 v25 = 0;
  char v24 = 0;
  if (!sub_1006DD7FC(v1, v2, (uint64_t *)v28, (uint64_t)v26, (unsigned char *)&v25 + 1, &v25, &v24))
  {
    uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Not processing phone number, events phone number not ready", (uint8_t *)&buf, 2u);
    }
LABEL_56:
    if (SBYTE7(v27) < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
    operator delete();
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v23 = 0;
  if (SBYTE7(v27) < 0)
  {
    sub_10004FC84(__dst, v26[0], (unint64_t)v26[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v26;
    uint64_t v23 = v27;
  }
  CFTypeRef cf2 = 0;
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(v19, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)xpc_object_t v19 = *(_OWORD *)__dst;
    uint64_t v20 = v23;
  }
  if (SHIBYTE(v20) < 0)
  {
    sub_10004FC84(&__p, v19[0], (unint64_t)v19[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v19;
    uint64_t v32 = v20;
  }
  uint64_t v30 = 0;
  if (SHIBYTE(v32) < 0)
  {
    sub_10004FC84(&buf, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    long long buf = __p;
    uint64_t v34 = v32;
  }
  uint64_t v35 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v4 = v30;
    uint64_t v30 = v35;
    *(void *)long long v36 = v4;
    sub_1000558F4((const void **)v36);
  }
  if (SHIBYTE(v34) < 0) {
    operator delete((void *)buf);
  }
  CFTypeRef cf2 = v30;
  uint64_t v30 = 0;
  sub_1000558F4(&v30);
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  int v5 = subscriber::simSlotAsInstance();
  uint64_t v35 = 0;
  int v6 = off_1019FC6C0[v5];
  (*(void (**)(long long *__return_ptr, void, __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v1 + 168) + 40))(&buf, *(void *)(v1 + 168), v6, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100056248(&v35, (CFTypeRef *)&buf);
  sub_1000577C4((const void **)&buf);
  if (v35) {
    BOOL v7 = sub_1000810B8;
  }
  else {
    BOOL v7 = 0;
  }
  CFTypeRef v8 = cf2;
  if (v7)
  {
    if (cf2 ? sub_1000810B8 : 0)
    {
      if (CFEqual(v35, cf2))
      {
        BOOL v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Phone number has not changed, so not sending any change notification", (uint8_t *)&buf, 2u);
        }
        goto LABEL_43;
      }
      CFTypeRef v8 = cf2;
    }
  }
  (*(void (**)(void, __CFString *, CFTypeRef, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v1 + 168) + 16))(*(void *)(v1 + 168), v6, v8, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v1 + 168)
                                                                                           + 48))(*(void *)(v1 + 168), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 152) + 328))(*(void *)(v1 + 152), v2);
  xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    long long buf = 0uLL;
    uint64_t v34 = 0;
    ctu::cf::assign();
    long long __p = buf;
    uint64_t v32 = v34;
    uint64_t v12 = (void **)__dst[0];
    p_p = (long long *)buf;
    if (v34 >= 0) {
      p_p = &__p;
    }
    if (v23 >= 0) {
      uint64_t v12 = __dst;
    }
    *(_DWORD *)long long v36 = 136315394;
    *(void *)&v36[4] = p_p;
    __int16 v37 = 2080;
    int v38 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sent out Phone Number Changed notification: old (%s) new (%s)", v36, 0x16u);
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)__p);
    }
  }
LABEL_43:
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 152) + 312))(*(void *)(v1 + 152), v2);
  BOOL v14 = *(std::__shared_weak_count **)(v1 + 96);
  if (v14)
  {
    long long v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      uint64_t v16 = *(void *)(v1 + 88);
      if (v16)
      {
        long long v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Updating phone_numbers rest property", (uint8_t *)&buf, 2u);
        }
        long long buf = 0uLL;
        uint64_t v34 = 0;
        (*(void (**)(uint64_t, uint64_t, long long *, void **, void **, uint64_t))(*(void *)v16 + 432))(v16, v2, &buf, v26, v26, 1);
        if (SHIBYTE(v34) < 0) {
          operator delete((void *)buf);
        }
        goto LABEL_53;
      }
    }
  }
  else
  {
    long long v15 = 0;
  }
  char v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get SettingsInterface to update phone numbers REST property", (uint8_t *)&buf, 2u);
    if (!v15)
    {
LABEL_54:
      sub_1000558F4(&v35);
      sub_1000558F4(&cf2);
      if (SHIBYTE(v23) < 0) {
        operator delete(__dst[0]);
      }
      goto LABEL_56;
    }
  }
  else if (!v15)
  {
    goto LABEL_54;
  }
LABEL_53:
  sub_10004D2C8(v15);
  goto LABEL_54;
}

void sub_1006E0ADC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (*(char *)(v45 - 105) < 0) {
    operator delete(*(void **)(v45 - 128));
  }
  sub_10004D2C8(v44);
  sub_1000558F4((const void **)(v45 - 104));
  sub_1000558F4(&a17);
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  operator delete();
}

uint64_t sub_1006E0C20(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  BOOL v3 = sub_1006DD7FC(*(void *)a1, **(unsigned int **)(a1 + 8), *(uint64_t **)(a1 + 16), *(void *)(a1 + 24), *(unsigned char **)(a1 + 32), *(unsigned char **)(a1 + 40), *(unsigned char **)(a1 + 48));
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    if (v10 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    int v6 = "true";
    if (**(unsigned char **)(a1 + 48)) {
      BOOL v7 = "true";
    }
    else {
      BOOL v7 = "false";
    }
    if (!v3) {
      int v6 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v12 = p_p;
    __int16 v13 = 2080;
    BOOL v14 = v7;
    __int16 v15 = 2080;
    uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Returning phone number '%s'; was read=%s result=%s #pnr",
      buf,
      0x20u);
    if (v10 < 0) {
      operator delete(__p);
    }
  }
  return **(unsigned __int8 **)(a1 + 48);
}

uint64_t sub_1006E0D8C(uint64_t a1)
{
  return sub_1006E0C20(*(void *)(a1 + 40));
}

uint64_t *sub_1006E0D94(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v36 = a1;
  uint64_t v37 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v4 = (CSIPhoneNumber *)(v1 + 16);
  CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)(v1 + 16));
  if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    if (HIBYTE(v47)) {
      goto LABEL_3;
    }
LABEL_13:
    long long v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Ignoring empty number for writing phone number", buf, 2u);
    }
    goto LABEL_67;
  }
  uint64_t v16 = *(void *)&buf[8];
  operator delete(*(void **)buf);
  if (!v16) {
    goto LABEL_13;
  }
LABEL_3:
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    CFTypeRef v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  xpc_object_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_9;
      }
LABEL_17:
      v43[0] = 0;
      v43[1] = 0;
      uint64_t v44 = 0;
      (*(void (**)(uint64_t, uint64_t, void, void **))(*(void *)v13 + 200))(v13, v3, 0, v43);
      char v18 = (void *)HIBYTE(v44);
      if (v44 < 0) {
        char v18 = v43[1];
      }
      if (v18)
      {
        xpc_object_t v19 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          CSIPhoneNumber::getFullNumber((uint64_t *)buf, v4);
          uint64_t v20 = v47 >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)long long __dst = 136315138;
          *(void *)&__dst[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Saving the Network retrieved CDMA number %s into persistent storage #pnr", __dst, 0xCu);
          if (SHIBYTE(v47) < 0) {
            operator delete(*(void **)buf);
          }
        }
        unsigned int v21 = subscriber::simSlotAsInstance();
        uint64_t v22 = *(void *)(v2 + 168);
        uint64_t v23 = off_1019FC6D0[v21];
        CSIPhoneNumber::getFullNumber((uint64_t *)__p, v4);
        if (SHIBYTE(v42) < 0)
        {
          sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)__p;
          uint64_t v51 = v42;
        }
        __int16 v48 = 0;
        if (SHIBYTE(v51) < 0)
        {
          sub_10004FC84(buf, *(void **)__dst, *(unint64_t *)&__dst[8]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__dst;
          uint64_t v47 = v51;
        }
        int v49 = 0;
        if (ctu::cf::convert_copy())
        {
          __int16 v25 = v48;
          __int16 v48 = v49;
          v38[0] = v25;
          sub_1000558F4((const void **)v38);
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v45 = v48;
        __int16 v48 = 0;
        sub_1000558F4((const void **)&v48);
        if (SHIBYTE(v51) < 0) {
          operator delete(*(void **)__dst);
        }
        (*(void (**)(uint64_t, __CFString *, void *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v22 + 16))(v22, v23, v45, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        uint64_t v26 = v21;
        sub_1000558F4((const void **)&v45);
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v27 = *(void *)(v2 + 168);
        long long v28 = off_1019FC6E0[v26];
        if (SHIBYTE(v44) < 0)
        {
          sub_10004FC84(v38, v43[0], (unint64_t)v43[1]);
        }
        else
        {
          *(_OWORD *)int v38 = *(_OWORD *)v43;
          uint64_t v39 = v44;
        }
        if (SHIBYTE(v39) < 0)
        {
          sub_10004FC84(__dst, v38[0], (unint64_t)v38[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)v38;
          uint64_t v51 = v39;
        }
        uint64_t v45 = 0;
        if (SHIBYTE(v51) < 0)
        {
          sub_10004FC84(buf, *(void **)__dst, *(unint64_t *)&__dst[8]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__dst;
          uint64_t v47 = v51;
        }
        __int16 v48 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v29 = v45;
          uint64_t v45 = v48;
          int v49 = v29;
          sub_1000558F4((const void **)&v49);
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v30 = v45;
        long long v40 = v45;
        uint64_t v45 = 0;
        sub_1000558F4((const void **)&v45);
        if (SHIBYTE(v51) < 0) {
          operator delete(*(void **)__dst);
        }
        (*(void (**)(uint64_t, __CFString *, const void *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v27 + 16))(v27, v28, v30, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_1000558F4(&v40);
        if (SHIBYTE(v39) < 0) {
          operator delete(v38[0]);
        }
        (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v2 + 168)
                                                                                                 + 48))(*(void *)(v2 + 168), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        uint64_t v31 = *(std::__shared_weak_count **)(v2 + 96);
        if (v31)
        {
          uint64_t v32 = std::__shared_weak_count::lock(v31);
          if (v32)
          {
            uint64_t v33 = v32;
            uint64_t v34 = *(void *)(v2 + 88);
            if (v34) {
              (*(void (**)(uint64_t, uint64_t, uint64_t, const char *))(*(void *)v34 + 304))(v34, v3, 1, "setPhoneNumber_sync");
            }
            sub_10004D2C8(v33);
          }
        }
      }
      else
      {
        char v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Ignoring empty ICCID for writing phone number", buf, 2u);
        }
      }
      if (SHIBYTE(v44) < 0)
      {
        operator delete(v43[0]);
        if (v14) {
          goto LABEL_67;
        }
        goto LABEL_66;
      }
      goto LABEL_65;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (v13) {
    goto LABEL_17;
  }
LABEL_9:
  __int16 v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not get Subscriber SIM controller for writing phone number", buf, 2u);
    if (v14) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
LABEL_65:
  if ((v14 & 1) == 0) {
LABEL_66:
  }
    sub_10004D2C8(v12);
LABEL_67:
  sub_1006E15A8(&v37);
  return sub_100046B58((uint64_t *)&v36);
}

void sub_1006E1470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,char a39)
{
  sub_10004D2C8(v40);
  if (a30 < 0) {
    operator delete(__p);
  }
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  sub_1006E15A8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006E15A8(uint64_t *result)
{
  uint64_t v1 = *result;
  _WORD *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_1006E1630()
{
}

void sub_1006E1704(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E1738(uint64_t a1, void *a2, NSObject **a3, void *a4)
{
  CFTypeRef v8 = (void *)(a1 + 8);
  uint64_t v9 = (const char *)attachApnLogDomainName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v9);
  *CFTypeRef v8 = 0;
  v8[1] = 0;
  unsigned int v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v20, (const OsLogContext *)buf);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  *(void *)a1 = off_1019FCA08;
  *(void *)(a1 + 48) = off_1019FCAD0;
  *(void *)(a1 + 56) = off_1019FCB18;
  *(void *)(a1 + 64) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 72) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = (char *)subscriber::asString();
  *(void *)(a1 + 80) = v12;
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(*a4 + 64);
  sub_100058DB0(&__p, v12);
  uint64_t v13 = *(NSObject **)(a1 + 24);
  long long v17 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  ctu::RestModule::RestModule();
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 112) = 0;
  buf[0] = 0;
  sub_10019E2A8((void *)(a1 + 120), 5uLL, buf);
  *(void *)(a1 + 144) = 0;
  uint64_t v14 = *a4;
  *(void *)(a1 + 152) = *a4;
  uint64_t v15 = a4[1];
  *(void *)(a1 + 160) = v15;
  if (v15)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    uint64_t v14 = *(void *)(a1 + 152);
  }
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  if (!v14)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)
      || (*(_DWORD *)long long buf = 136315650,
          uint64_t v22 = "AttachApnManager does not have command driver",
          __int16 v23 = 2080,
          char v24 = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Settings/AttachApn/AttachApnManager.cpp",
          __int16 v25 = 1024,
          int v26 = 85,
          _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fCommandDriver\n %s\n at %s:%d\n**********", buf, 0x1Cu), !*(void *)(a1 + 152)))
    {
      __TUAssertTrigger();
    }
  }
  return a1;
}

void sub_1006E1A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  long long v28 = (std::__shared_weak_count *)*((void *)v21 + 22);
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = (std::__shared_weak_count *)*((void *)v21 + 20);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *((void *)v21 + 18);
  *((void *)v21 + 18) = 0;
  if (v30) {
    sub_1006E86C0(v30);
  }
  if (*v26) {
    operator delete(*v26);
  }
  uint64_t v31 = (std::__shared_weak_count *)*((void *)v21 + 13);
  if (v31) {
    sub_10004D2C8(v31);
  }
  uint64_t v32 = (std::__shared_weak_count *)*((void *)v21 + 9);
  if (v32) {
    sub_10004D2C8(v32);
  }
  AttachApnFSMDelegate::~AttachApnFSMDelegate(v25);
  AttachApnCommandDriverHelper::~AttachApnCommandDriverHelper(v24);
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  AttachApnManagerInterface::~AttachApnManagerInterface(v21);
  _Unwind_Resume(a1);
}

void sub_1006E1B00(void *a1)
{
  *a1 = off_1019FCA08;
  int v2 = (AttachApnCommandDriverHelper *)(a1 + 6);
  a1[6] = off_1019FCAD0;
  uint64_t v3 = (AttachApnFSMDelegate *)(a1 + 7);
  a1[7] = off_1019FCB18;
  uint64_t v4 = (std::__shared_weak_count *)a1[22];
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = (std::__shared_weak_count *)a1[20];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = a1[18];
  a1[18] = 0;
  if (v6) {
    sub_1006E86C0(v6);
  }
  uint64_t v7 = (void *)a1[15];
  if (v7) {
    operator delete(v7);
  }
  CFTypeRef v8 = (std::__shared_weak_count *)a1[13];
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[9];
  if (v9) {
    sub_10004D2C8(v9);
  }
  AttachApnFSMDelegate::~AttachApnFSMDelegate(v3);
  AttachApnCommandDriverHelper::~AttachApnCommandDriverHelper(v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  AttachApnManagerInterface::~AttachApnManagerInterface((AttachApnManagerInterface *)a1);
}

void sub_1006E1C0C(uint64_t a1)
{
}

void sub_1006E1C14(uint64_t a1)
{
}

void sub_1006E1C1C(void *a1)
{
  sub_1006E1B00(a1);

  operator delete();
}

void sub_1006E1C54(uint64_t a1)
{
  sub_1006E1B00((void *)(a1 - 48));

  operator delete();
}

void sub_1006E1C90(uint64_t a1)
{
  sub_1006E1B00((void *)(a1 - 56));

  operator delete();
}

void sub_1006E1CCC(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v3, *(Registry **)(a1 + 64));
  ctu::RestModule::connect();
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1006E201C((const void **)__p, a1, kCacheIPCU);
  AttachAPNDevicePersistentSaveValue((const __CFString *)__p[0], 0);
  sub_1000558F4((const void **)__p);
  uint64_t v2 = *(void *)(a1 + 152);
  if (v2) {
    *(void *)(v2 + 88) = a1 + 48;
  }
  operator new();
}

void sub_1006E1FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1006E201C(const void **a1, uint64_t a2, const __CFString *cf)
{
  CFStringRef theString2 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFStringRef v6 = theString2;
  }
  else
  {
    CFStringRef v6 = 0;
  }
  if (v6) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7 && *(_DWORD *)(a2 + 88) == 2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D3D0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D3D0))
    {
      qword_101B0D428 = 0;
      qword_101B0D420 = 0;
      qword_101B0D418 = (uint64_t)&qword_101B0D420;
      __cxa_atexit((void (*)(void *))sub_1006E8304, &qword_101B0D418, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D3D0);
    }
    uint64_t v9 = qword_101B0D420;
    if (qword_101B0D420)
    {
      unsigned int v10 = &qword_101B0D420;
      do
      {
        CFComparisonResult v11 = CFStringCompare(*(CFStringRef *)(v9 + 32), theString2, 0);
        uint64_t v12 = (uint64_t *)(v9 + 8);
        if (v11 != kCFCompareLessThan)
        {
          uint64_t v12 = (uint64_t *)v9;
          unsigned int v10 = (uint64_t *)v9;
        }
        uint64_t v9 = *v12;
      }
      while (*v12);
      if (v10 != &qword_101B0D420 && CFStringCompare(theString2, (CFStringRef)v10[4], 0) != kCFCompareLessThan)
      {
        sub_100083DA4(a1, (const void **)v10 + 5);
        return sub_1000558F4((const void **)&theString2);
      }
    }
    *a1 = 0;
    *a1 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-%d", cf, 2);
    uint64_t v13 = qword_101B0D420;
    if (qword_101B0D420)
    {
      uint64_t v14 = (void **)&qword_101B0D420;
      while (1)
      {
        while (1)
        {
          uint64_t v15 = (uint64_t *)v13;
          if (CFStringCompare(theString2, *(CFStringRef *)(v13 + 32), 0) != kCFCompareLessThan) {
            break;
          }
          uint64_t v13 = *v15;
          uint64_t v14 = (void **)v15;
          if (!*v15) {
            goto LABEL_29;
          }
        }
        if (CFStringCompare((CFStringRef)v15[4], theString2, 0) != kCFCompareLessThan) {
          break;
        }
        uint64_t v14 = (void **)(v15 + 1);
        uint64_t v13 = v15[1];
        if (!v13) {
          goto LABEL_29;
        }
      }
      uint64_t v16 = (const void **)*v14;
      if (*v14) {
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v14 = (void **)&qword_101B0D420;
      uint64_t v15 = &qword_101B0D420;
    }
LABEL_29:
    uint64_t v16 = (const void **)operator new(0x30uLL);
    sub_100083DA4(v16 + 4, (const void **)&theString2);
    v16[5] = 0;
    *uint64_t v16 = 0;
    v16[1] = 0;
    void v16[2] = v15;
    *uint64_t v14 = v16;
    long long v17 = (uint64_t *)v16;
    if (*(void *)qword_101B0D418)
    {
      qword_101B0D418 = *(void *)qword_101B0D418;
      long long v17 = (uint64_t *)*v14;
    }
    sub_100046C90((uint64_t *)qword_101B0D420, v17);
    ++qword_101B0D428;
LABEL_32:
    sub_100083EB8(v16 + 5, a1);
    return sub_1000558F4((const void **)&theString2);
  }
  *a1 = v6;
  CFStringRef theString2 = 0;
  return sub_1000558F4((const void **)&theString2);
}

void sub_1006E2298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006E22CC(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_1006E3580(&theDict, a1, kCacheCurrentType);
  if (theDict) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    CFDictionaryRef Value = (unsigned int *)CFDictionaryGetValue(theDict, kAttachAPNType);
    uint64_t v4 = Value;
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFNumberGetTypeID())
      {
        *(_DWORD *)long long buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v4, v6);
        uint64_t v7 = *(unsigned int *)buf;
        if (*(_DWORD *)buf <= 4u)
        {
          CFTypeRef v8 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v9 = asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v9;
            unsigned int v10 = "#I Current type read from kCacheCurrentType %s (legacy behavior)";
LABEL_22:
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, buf, 0xCu);
            goto LABEL_19;
          }
          goto LABEL_19;
        }
      }
    }
LABEL_17:
    long long v17 = *(NSObject **)(a1 + 40);
    uint64_t v7 = 0;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Current type not found returning kAttAPNTypeNormal (legacy behavior)", buf, 2u);
      uint64_t v7 = 0;
    }
    goto LABEL_19;
  }
  sub_1006E3580(&v20, a1, kCacheWritten);
  CFDictionaryRef v11 = theDict;
  CFDictionaryRef theDict = v20;
  *(void *)long long buf = v11;
  CFDictionaryRef v20 = 0;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)&v20);
  if (theDict) {
    uint64_t v12 = sub_100080778;
  }
  else {
    uint64_t v12 = 0;
  }
  if (!v12) {
    goto LABEL_17;
  }
  uint64_t v13 = (unsigned int *)CFDictionaryGetValue(theDict, kAttachAPNType);
  uint64_t v14 = v13;
  if (!v13) {
    goto LABEL_17;
  }
  CFTypeID v15 = CFGetTypeID(v13);
  if (v15 != CFNumberGetTypeID()) {
    goto LABEL_17;
  }
  *(_DWORD *)long long buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v14, v16);
  uint64_t v7 = *(unsigned int *)buf;
  if (*(_DWORD *)buf > 4u) {
    goto LABEL_17;
  }
  CFTypeRef v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    unsigned int v10 = "#I Current type read from kCacheWritten %s (legacy behavior)";
    goto LABEL_22;
  }
LABEL_19:
  sub_100057D78((const void **)&theDict);
  return v7;
}

void sub_1006E2534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006E2568(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_1006E3580(&theDict, a1, kCacheCurrentType);
  if (theDict) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    CFDictionaryRef Value = (unsigned int *)CFDictionaryGetValue(theDict, kAttachAPNTypeMask);
    uint64_t v4 = Value;
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFNumberGetTypeID())
      {
        LODWORD(__p[0]) = 0;
        ctu::cf::assign((ctu::cf *)__p, v4, v6);
        uint64_t v7 = LODWORD(__p[0]);
        if (LODWORD(__p[0]) <= 0x1F)
        {
          CFTypeRef v8 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_23;
          }
          sub_1006E285C(__p, v7);
          if (v20 >= 0) {
            uint64_t v9 = __p;
          }
          else {
            uint64_t v9 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v7;
          __int16 v23 = 2080;
          char v24 = v9;
          unsigned int v10 = "#I Current type-mask read from kCacheCurrentType 0x%x [%s]";
          goto LABEL_29;
        }
      }
    }
  }
  else
  {
    sub_1006E3580(buf, a1, kCacheWritten);
    __p[0] = theDict;
    CFDictionaryRef theDict = *(CFDictionaryRef *)buf;
    *(void *)long long buf = 0;
    sub_100057D78((const void **)__p);
    sub_100057D78((const void **)buf);
    if (theDict) {
      CFDictionaryRef v11 = sub_100080778;
    }
    else {
      CFDictionaryRef v11 = 0;
    }
    if (v11)
    {
      uint64_t v12 = (unsigned int *)CFDictionaryGetValue(theDict, kAttachAPNTypeMask);
      uint64_t v13 = v12;
      if (v12)
      {
        CFTypeID v14 = CFGetTypeID(v12);
        if (v14 == CFNumberGetTypeID())
        {
          LODWORD(__p[0]) = 0;
          ctu::cf::assign((ctu::cf *)__p, v13, v15);
          uint64_t v7 = LODWORD(__p[0]);
          if (LODWORD(__p[0]) <= 0x1F)
          {
            CFTypeRef v8 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_23;
            }
            sub_1006E285C(__p, v7);
            if (v20 >= 0) {
              char v18 = __p;
            }
            else {
              char v18 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 67109378;
            *(_DWORD *)&uint8_t buf[4] = v7;
            __int16 v23 = 2080;
            char v24 = v18;
            unsigned int v10 = "#I Current type-mask read from kCacheWritten 0x%x [%s]";
LABEL_29:
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, buf, 0x12u);
            if (v20 < 0) {
              operator delete(__p[0]);
            }
            goto LABEL_23;
          }
        }
      }
    }
  }
  CFNumberRef v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Current type-mask not found returning [kAttAPNTypeNormal]", (uint8_t *)__p, 2u);
  }
  uint64_t v7 = 1;
LABEL_23:
  sub_100057D78((const void **)&theDict);
  return v7;
}

void sub_1006E2828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006E285C(void *a1, unsigned int a2)
{
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v11 = 0u;
  memset(v9, 0, sizeof(v9));
  sub_10004DE24((uint64_t)v9);
  int v4 = 0;
  char v5 = 1;
  do
  {
    if ((a2 >> v4))
    {
      if ((v5 & 1) == 0) {
        sub_10004B96C(v9, (uint64_t)",", 1);
      }
      CFNumberRef v6 = (const char *)asString();
      size_t v7 = strlen(v6);
      sub_10004B96C(v9, (uint64_t)v6, v7);
      char v5 = 0;
    }
    ++v4;
  }
  while (v4 != 5);
  sub_10004BC98((uint64_t)v9 + 8, a1);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1006E2A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1006E2A2C(uint64_t a1)
{
  uint64_t result = ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 96));
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3) {
    *(void *)(v3 + 88) = 0;
  }
  return result;
}

void sub_1006E2A60(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  if (*(void *)(a1 + 152))
  {
    __p[0] = 0;
    __p[1] = 0;
    CFArrayRef v56 = 0;
    v72[0] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    uint64_t v9 = ServiceMap;
    uint64_t v11 = v10;
    if (v10 < 0)
    {
      long long v12 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    long long v15 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      long long v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v9);
    long long v16 = 0;
    char v18 = 1;
LABEL_12:
    uint64_t v20 = *(unsigned int *)(a1 + 88);
    long long v21 = operator new(0x10uLL);
    uint64_t v22 = kPcoOptionsKey;
    *(void *)&uint8_t buf[8] = v21 + 2;
    CFArrayRef v66 = (const __CFArray *)(v21 + 2);
    *long long v21 = kPcoOptionsKey;
    v21[1] = @"ContainerIds";
    *(void *)long long buf = v21;
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, uint8_t *, void, void))(*(void *)v17 + 88))(v72, v17, v20, 1, buf, 0, 0);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if ((v18 & 1) == 0) {
      sub_10004D2C8(v16);
    }
    CFArrayRef v23 = (const __CFArray *)v72[0];
    if (v72[0]) {
      char v24 = sub_100080934;
    }
    else {
      char v24 = 0;
    }
    if (v24)
    {
      long long v52 = 0u;
      if (v72[0])
      {
        CFTypeID v25 = CFGetTypeID(v72[0]);
        if (v25 == CFArrayGetTypeID())
        {
          memset(buf, 0, sizeof(buf));
          CFArrayRef v66 = 0;
          *(void *)&long long context = buf;
          v74.length = CFArrayGetCount(v23);
          v74.location = 0;
          CFArrayApplyFunction(v23, v74, (CFArrayApplierFunction)sub_1006E8728, &context);
          long long v52 = *(_OWORD *)buf;
          CFArrayRef v23 = v66;
        }
        else
        {
          CFArrayRef v23 = 0;
        }
      }
      if (__p[0]) {
        operator delete(__p[0]);
      }
      *(_OWORD *)long long __p = v52;
      CFArrayRef v56 = v23;
    }
    int v26 = sub_1000577C4(v72);
    if (!capabilities::ct::supportsPCOOptions((capabilities::ct *)v26))
    {
      __int16 v36 = 0;
      __int16 v37 = 0;
      goto LABEL_45;
    }
    uint64_t v27 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    long long v28 = v27;
    if (v10 < 0)
    {
      uint64_t v29 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v30 = 5381;
      do
      {
        uint64_t v10 = v30;
        unsigned int v31 = *v29++;
        uint64_t v30 = (33 * v30) ^ v31;
      }
      while (v31);
    }
    std::mutex::lock(v27);
    *(void *)long long buf = v10;
    uint64_t v32 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
    if (v32)
    {
      uint64_t v34 = v32[3];
      uint64_t v33 = (std::__shared_weak_count *)v32[4];
      if (v33)
      {
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v33);
        char v35 = 0;
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v34 = 0;
    }
    std::mutex::unlock(v28);
    uint64_t v33 = 0;
    char v35 = 1;
LABEL_37:
    uint64_t v38 = *(unsigned int *)(a1 + 88);
    uint64_t v39 = operator new(0x10uLL);
    CFArrayRef v66 = (const __CFArray *)(v39 + 2);
    *uint64_t v39 = v22;
    v39[1] = @"RequestMSISDN";
    *(void *)long long buf = v39;
    *(void *)&uint8_t buf[8] = v39 + 2;
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, uint8_t *, const CFBooleanRef, void))(*(void *)v34 + 88))(&context, v34, v38, 1, buf, kCFBooleanFalse, 0);
    long long v40 = (BOOL *)context;
    LOBYTE(v72[0]) = 0;
    if ((void)context)
    {
      CFTypeID v41 = CFGetTypeID((CFTypeRef)context);
      if (v41 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)v72, v40, v42);
      }
    }
    __int16 v37 = LOBYTE(v72[0]);
    sub_1000577C4((const void **)&context);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if ((v35 & 1) == 0) {
      sub_10004D2C8(v33);
    }
    __int16 v36 = 1;
LABEL_45:
    uint64_t v43 = *(void *)(a1 + 168);
    if (v43)
    {
      if (*(_DWORD *)(v43 + 68) != 2) {
        goto LABEL_75;
      }
      uint64_t v44 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset already granted. Push to baseband now", buf, 2u);
      }
      uint64_t v45 = *(void *)(a1 + 152);
      LOBYTE(v53) = 0;
      char v54 = 0;
      if (*(unsigned char *)(a2 + 8))
      {
        sub_100058198(&v53, (const void **)a2);
        char v54 = 1;
      }
      sub_1000F0058((uint64_t)v57, a4);
      AttachApnCommandDriver::AttachApnPushConfig::AttachApnPushConfig();
      (*(void (**)(uint64_t, const void **, uint8_t *))(*(void *)v45 + 48))(v45, &v53, buf);
      if (v68[1])
      {
        long long v69 = v68[1];
        operator delete(v68[1]);
      }
      sub_10003B34C(buf);
      sub_10003B34C(v57);
      if (!v54) {
        goto LABEL_75;
      }
      xpc_object_t v46 = &v53;
    }
    else
    {
      sub_100058DB0(buf, "/cc/assertions/prevent_baseband_reset");
      ctu::rest::AssertionHandle::create();
      if (SHIBYTE(v66) < 0) {
        operator delete(*(void **)buf);
      }
      long long v47 = context;
      long long context = 0uLL;
      __int16 v48 = *(std::__shared_weak_count **)(a1 + 176);
      *(_OWORD *)(a1 + 168) = v47;
      if (v48)
      {
        sub_10004D2C8(v48);
        if (*((void *)&context + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&context + 1));
        }
      }
      *(void *)&long long context = a1;
      BYTE8(context) = 0;
      char v59 = 0;
      if (*(unsigned char *)(a2 + 8))
      {
        sub_100058198((const void **)&context + 1, (const void **)a2);
        char v59 = 1;
      }
      char v60 = a3;
      v61[1] = 0;
      long long v62 = 0;
      v61[0] = 0;
      sub_1003A10E0(v61, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 1);
      __int16 v63 = v37 | (v36 << 8);
      sub_1000F0058((uint64_t)v64, a4);
      *(void *)long long buf = context;
      uint8_t buf[8] = 0;
      LOBYTE(v66) = 0;
      if (v59)
      {
        *(void *)&uint8_t buf[8] = *((void *)&context + 1);
        *((void *)&context + 1) = 0;
        LOBYTE(v66) = 1;
      }
      char v67 = v60;
      *(_OWORD *)long long v68 = *(_OWORD *)v61;
      long long v69 = v62;
      v61[1] = 0;
      long long v62 = 0;
      v61[0] = 0;
      __int16 v70 = v63;
      sub_1000DA470((uint64_t)v71, (uint64_t)v64);
      long long v73 = 0;
      int v49 = (char *)operator new(0x68uLL);
      int v50 = v49;
      uint64_t v51 = *(void *)buf;
      *(void *)int v49 = off_1019FCD30;
      *((void *)v49 + 1) = v51;
      v49[16] = 0;
      v49[24] = 0;
      if ((_BYTE)v66)
      {
        *((void *)v49 + 2) = *(void *)&buf[8];
        *(void *)&uint8_t buf[8] = 0;
        v49[24] = 1;
      }
      v49[32] = v67;
      *(_OWORD *)(v49 + 40) = *(_OWORD *)v68;
      *((void *)v49 + 7) = v69;
      v68[1] = 0;
      long long v69 = 0;
      v68[0] = 0;
      *((_WORD *)v49 + 32) = v70;
      sub_1000DA470((uint64_t)(v49 + 72), (uint64_t)v71);
      long long v73 = v50;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(v72);
      sub_10003B34C(v71);
      if (v68[0])
      {
        v68[1] = v68[0];
        operator delete(v68[0]);
      }
      if ((_BYTE)v66) {
        sub_100057D78((const void **)&buf[8]);
      }
      sub_10003B34C(v64);
      if (v61[0])
      {
        v61[1] = v61[0];
        operator delete(v61[0]);
      }
      if (!v59) {
        goto LABEL_75;
      }
      xpc_object_t v46 = (const void **)&context + 1;
    }
    sub_100057D78(v46);
LABEL_75:
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    return;
  }
  long long v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No AttachAPN command driver", buf, 2u);
  }
}

void sub_1006E31B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if ((_BYTE)a12) {
    sub_100057D78(&a11);
  }
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006E331C(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_100057D78((const void **)(a1 + 8));
  }
  return a1;
}

void *sub_1006E3368(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  return sub_10003B34C(a1);
}

void sub_1006E33AC(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
}

void sub_1006E33B4(uint64_t a1, void *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
    int v4 = std::locale::use_facet(v10, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
    std::locale::~locale(v10);
    char v5 = (void *)sub_10013EA34((uint64_t)a2);
    if ((*((unsigned char *)v5 + *(void *)(*v5 - 24) + 32) & 5) != 0) {
      break;
    }
    CFNumberRef v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (v9 >= 0) {
        size_t v7 = __p;
      }
      else {
        size_t v7 = (void **)__p[0];
      }
      LODWORD(v10[0].__locale_) = 136315138;
      *(std::locale::__imp **)((char *)&v10[0].__locale_ + 4) = (std::locale::__imp *)v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)v10, 0xCu);
    }
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006E354C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, std::locale a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006E3578(uint64_t a1, void *a2)
{
}

void sub_1006E3580(void *a1, uint64_t a2, const __CFString *a3)
{
  int v25 = *(_DWORD *)(a2 + 88);
  v24[0] = a2;
  v24[1] = &v25;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 64));
  size_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v22 = (const void *)v8;
  long long v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v22);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  if (CFEqual(a3, kCacheUI))
  {
    if (v14)
    {
      uint64_t v22 = 0;
      CFArrayRef v23 = 0;
      sub_10022EDC4(v14, &v22);
      if (sub_1006E39A0(a2) && v22)
      {
        (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v22 + 80))(&v20);
        sub_1006E3BF8((CFMutableDictionaryRef *)&v21, (uint64_t)v24, &v20);
        int v16 = 1;
      }
      else
      {
        int v16 = 0;
        long long v21 = 0;
      }
      sub_10004EFE4(a1, (CFTypeRef *)&v21);
      sub_10005717C((const void **)&v21);
      if (!v16) {
        goto LABEL_28;
      }
      uint64_t v17 = &v20;
      goto LABEL_27;
    }
LABEL_32:
    *a1 = 0;
    goto LABEL_33;
  }
  if (CFStringCompare(a3, kCacheSim, 0))
  {
    if (CFStringCompare(a3, kCacheIPCU, 0))
    {
      sub_1006E201C((const void **)&v21, a2, a3);
      AttachAPNDevicePersistentCopyValue((uint64_t *)&v22, v21, 0);
      sub_10004EFE4(a1, &v22);
      sub_1000577C4(&v22);
      sub_1000558F4((const void **)&v21);
      goto LABEL_33;
    }
    if (!v14) {
      goto LABEL_32;
    }
    uint64_t v22 = 0;
    CFArrayRef v23 = 0;
    sub_1006E4004(v14, &v22);
    if (v22)
    {
      (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v22 + 64))(&v18);
      sub_1006E3BF8((CFMutableDictionaryRef *)&v21, (uint64_t)v24, &v18);
      sub_10004EFE4(a1, (CFTypeRef *)&v21);
      sub_10005717C((const void **)&v21);
      uint64_t v17 = &v18;
      goto LABEL_27;
    }
    goto LABEL_30;
  }
  if (!v14) {
    goto LABEL_32;
  }
  uint64_t v22 = 0;
  CFArrayRef v23 = 0;
  sub_1006E3F34(v14, &v22);
  if (!v22 || !(*(unsigned int (**)(const void *))(*(void *)v22 + 96))(v22))
  {
LABEL_30:
    if (v23) {
      sub_10004D2C8(v23);
    }
    goto LABEL_32;
  }
  (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v22 + 80))(&v19);
  sub_1006E3BF8((CFMutableDictionaryRef *)&v21, (uint64_t)v24, &v19);
  sub_10004EFE4(a1, (CFTypeRef *)&v21);
  sub_10005717C((const void **)&v21);
  uint64_t v17 = &v19;
LABEL_27:
  sub_100057D78((const void **)v17);
LABEL_28:
  if (v23) {
    sub_10004D2C8(v23);
  }
LABEL_33:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1006E38D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, const void *a13, uint64_t a14, std::__shared_weak_count *a15)
{
  sub_10005717C(&a13);
  sub_100057D78(&a11);
  if (a15) {
    sub_10004D2C8(a15);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_1006E39A0(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 88);
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    CFNumberRef v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v11 + 96))(&cf, v11, v2, 1, @"AllowAttachAPNEditing", kCFBooleanFalse, 0);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  unint64_t v13 = (unint64_t)cf;
  buf[0] = 0;
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, (BOOL *)v13, v15);
      unint64_t v13 = buf[0] != 0;
    }
    else
    {
      unint64_t v13 = 0;
    }
  }
  char v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = asStringBool(v13);
    uint64_t v18 = subscriber::asString();
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    __int16 v22 = 2080;
    uint64_t v23 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Attach APN editing allowed: %s for sim %s", buf, 0x16u);
  }
  sub_1000577C4(&cf);
  return v13;
}

void sub_1006E3BBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1006E3BF8(CFMutableDictionaryRef *a1, uint64_t a2, CFDictionaryRef *a3)
{
  *a1 = 0;
  if (*a3) {
    int v4 = sub_100080778;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    CFDictionaryGetValue(*a3, @"apn");
    long long v10 = 0uLL;
    uint64_t v11 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0uLL;
    uint64_t v9 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v7 = Mutable;
    if (Mutable)
    {
      *a1 = Mutable;
      *(void *)&long long v10 = 0;
      sub_10005717C((const void **)&v10);
    }
    CFDictionaryAddValue(v7, k3GPP, *a3);
    CFDictionaryAddValue(v7, k3GPP2, *a3);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1006E3EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  sub_100057D78((const void **)&a9);
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10005717C(v23);
  _Unwind_Resume(a1);
}

void sub_1006E3F34(uint64_t a1@<X0>, void *a2@<X8>)
{
  lpsrc = 0;
  CFNumberRef v6 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&lpsrc);
  if (lpsrc
  {
    int v4 = v6;
    *a2 = v3;
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1006E4004(uint64_t a1@<X0>, void *a2@<X8>)
{
  lpsrc = 0;
  CFNumberRef v6 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&lpsrc);
  if (lpsrc
  {
    int v4 = v6;
    *a2 = v3;
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

uint64_t sub_1006E40D4(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_1006E3580(&theDict, a1, kCacheCurrentType);
  if (theDict) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, kAttachAPNIPCUPresent);
    CFBooleanRef v4 = Value;
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      CFTypeID TypeID = CFBooleanGetTypeID();
      goto LABEL_13;
    }
    goto LABEL_16;
  }
  sub_1006E3580(&v15, a1, kCacheWritten);
  CFDictionaryRef v7 = theDict;
  CFDictionaryRef theDict = v15;
  *(void *)long long buf = v7;
  CFDictionaryRef v15 = 0;
  sub_100057D78((const void **)buf);
  sub_100057D78((const void **)&v15);
  if (theDict) {
    unsigned int v8 = sub_100080778;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v8)
  {
    CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(theDict, kAttachAPNIPCUPresent);
    CFBooleanRef v4 = v9;
    if (v9)
    {
      CFTypeID v5 = CFGetTypeID(v9);
      CFTypeID TypeID = CFBooleanGetTypeID();
LABEL_13:
      if (v5 == TypeID) {
        CFBooleanRef v10 = v4;
      }
      else {
        CFBooleanRef v10 = 0;
      }
LABEL_17:
      if (v10) {
        BOOL v11 = kCFBooleanTrue == v10;
      }
      else {
        BOOL v11 = 0;
      }
      uint64_t v12 = v11;
      goto LABEL_23;
    }
LABEL_16:
    CFBooleanRef v10 = 0;
    goto LABEL_17;
  }
  CFTypeID v14 = *(NSObject **)(a1 + 40);
  uint64_t v12 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I IPCU profile was not present in cached config", buf, 2u);
    uint64_t v12 = 0;
  }
LABEL_23:
  sub_100057D78((const void **)&theDict);
  return v12;
}

void sub_1006E425C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1006E4278(const void **a1, uint64_t a2)
{
  *a1 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 64));
  CFTypeID v5 = ServiceMap;
  if (v6 < 0)
  {
    CFDictionaryRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v18 = v6;
  CFBooleanRef v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    BOOL v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  BOOL v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, uint64_t, void, void, void))(*(void *)v12 + 96))(v12, *(unsigned int *)(a2 + 88), 1, kCarrierBundleAttachAPNKey, 0, 0);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (*a1) {
    CFTypeID v14 = sub_100080934;
  }
  else {
    CFTypeID v14 = 0;
  }
  if (!v14)
  {
    getDefaultAttachApn();
    CFTypeRef v17 = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (&v17 != a1)
    {
      CFDictionaryRef v15 = *a1;
      CFTypeRef v17 = 0;
      uint64_t v18 = (uint64_t)v15;
      *a1 = cf;
      sub_1000577C4((const void **)&v18);
    }
    sub_1000577C4(&v17);
    sub_100057D78(&cf);
  }
}

void sub_1006E441C(_Unwind_Exception *a1)
{
  sub_1000577C4(v1);
  _Unwind_Resume(a1);
}

const void **sub_1006E4448(uint64_t a1, const void **a2)
{
  CFStringRef v3 = (const __CFString *)kCacheWritten;
  sub_100058198((const void **)&v5, a2);
  sub_1006E44B0(a1, v3, &v5);
  return sub_100057D78((const void **)&v5);
}

void sub_1006E449C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1006E44B0(uint64_t a1, const __CFString *a2, ctu **a3)
{
  if (*a3) {
    CFTypeID v5 = sub_100080778;
  }
  else {
    CFTypeID v5 = 0;
  }
  if (v5)
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    memset(v29, 0, sizeof(v29));
    *(_OWORD *)long long buf = 0u;
    sub_10004BD84((uint64_t)buf);
    CFDictionaryRef v7 = sub_10004B96C(v29, (uint64_t)"Updating the cache file ", 24);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v27 = 0;
    ctu::cf::assign();
    *(_OWORD *)char v24 = 0u;
    uint64_t v25 = 0;
    uint64_t v8 = sub_10004B96C(v7, (uint64_t)v24, 0);
    unsigned int v9 = sub_10004B96C(v8, (uint64_t)" ", 1);
    ctu::cf_to_xpc((uint64_t *)&object, *a3, v10);
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    if (v27 >= 0) {
      BOOL v11 = __p;
    }
    else {
      BOOL v11 = (void **)__p[0];
    }
    if (v27 >= 0) {
      uint64_t v12 = HIBYTE(v27);
    }
    else {
      uint64_t v12 = (uint64_t)__p[1];
    }
    sub_10004B96C(v9, (uint64_t)v11, v12);
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(object);
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    sub_1006E33B4(a1, buf);
    sub_1006E201C((const void **)__p, a1, a2);
    char v13 = *a3;
    __int16 v22 = v13;
    if (v13) {
      CFRetain(v13);
    }
    AttachAPNDevicePersistentSaveValue();
    sub_1000577C4((const void **)&v22);
    sub_1000558F4((const void **)__p);
    v29[0] = v14;
    if (SHIBYTE(v31) < 0) {
      operator delete(*((void **)&v30 + 1));
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
  }
  else
  {
    CFDictionaryRef v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)&unsigned char buf[12] = 0;
      v29[0] = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0u;
      uint64_t v27 = 0;
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = __p;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Removing all cached values from %s", buf, 0xCu);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1006E201C((const void **)buf, a1, a2);
    AttachAPNDevicePersistentSaveValue(*(const __CFString **)buf, 0);
    sub_1000558F4((const void **)buf);
  }
  if ((const __CFString *)kCacheWritten == a2)
  {
    int v16 = *(_DWORD *)(a1 + 112);
    if (*(_DWORD *)(a1 + 116) != v16)
    {
      *(_DWORD *)(a1 + 116) = v16;
      CFTypeRef v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I More WiFi Calling switch requests are pending - trigger another settings check", buf, 2u);
      }
      if (sub_1006E4C20(a1, 0, 0))
      {
        uint64_t v18 = dispatch_group_create();
        CFDictionaryRef v19 = v18;
        if (v18)
        {
          dispatch_retain(v18);
          dispatch_group_enter(v19);
          dispatch_release(v19);
          dispatch_retain(v19);
          dispatch_group_enter(v19);
        }
        CFDictionaryRef v20 = *(std::__shared_weak_count **)(a1 + 16);
        if (v20)
        {
          if (std::__shared_weak_count::lock(v20)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
    }
    long long v21 = *(std::__shared_weak_count **)(a1 + 176);
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    if (v21) {
      sub_10004D2C8(v21);
    }
  }
}

void sub_1006E4A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, xpc_object_t object, char a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1006E4B84(uint64_t a1, const void **a2)
{
  return sub_1006E4448(a1 - 56, a2);
}

const void **sub_1006E4B8C(uint64_t a1)
{
  CFBooleanRef v4 = 0;
  sub_1006E44B0(a1, kCacheWritten, &v4);
  sub_100057D78((const void **)&v4);
  CFStringRef v3 = 0;
  sub_1006E44B0(a1, kCacheCurrentType, &v3);
  return sub_100057D78((const void **)&v3);
}

void sub_1006E4BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **sub_1006E4C18(uint64_t a1)
{
  return sub_1006E4B8C(a1 - 56);
}

BOOL sub_1006E4C20(uint64_t a1, int a2, int a3)
{
  CFTypeRef cf = 0;
  int v6 = sub_1006E22CC(a1);
  int v7 = sub_1006E40D4(a1);
  if (v6)
  {
    unsigned int v8 = 1 << v6;
  }
  else
  {
    unsigned int v9 = sub_1006E2568(a1);
    unsigned int v8 = v9;
    uint64_t v10 = 0;
    *(_OWORD *)long long buf = xmmword_1014DD860;
    while (1)
    {
      int v6 = *(_DWORD *)&buf[v10];
      if ((v9 >> v6)) {
        break;
      }
      v10 += 4;
      if (v10 == 16)
      {
        int v6 = 0;
        break;
      }
    }
    BOOL v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      sub_1006E285C(&__p, v8);
      char v13 = v47 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I AttachAPN type %s from type-mask 0x%x [%s]", buf, 0x1Cu);
      if (v47 < 0) {
        operator delete(__p);
      }
    }
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_1006E5D5C((uint64_t)buf, a1, v8);
  xpc_object_t v14 = (const void *)k3GPP;
  CFDictionaryRef v15 = (const void *)k3GPP2;
  uint64_t v16 = *(void *)buf;
  if (*(void *)buf) {
    CFTypeRef v17 = sub_100080778;
  }
  else {
    CFTypeRef v17 = 0;
  }
  uint64_t v18 = (const void *)k3GPP2;
  CFDictionaryRef v19 = (const void *)k3GPP;
  if (!v17)
  {
    sub_1006E58FC((uint64_t)&__p, a1, v6);
    CFNumberRef v48 = *(CFNumberRef *)buf;
    *(void *)long long buf = __p;
    long long __p = 0;
    sub_100057D78((const void **)&v48);
    *(void *)&uint8_t buf[8] = v46;
    sub_100057D78((const void **)&__p);
    uint64_t v18 = 0;
    CFDictionaryRef v20 = (const void **)&kProvisioningProfile;
    switch(v6)
    {
      case 1:
        break;
      case 2:
        uint64_t v18 = 0;
        CFDictionaryRef v20 = (const void **)&kVoLTEProfile;
        break;
      case 3:
        uint64_t v18 = 0;
        CFDictionaryRef v20 = (const void **)&kWiFiCallingProfile;
        break;
      case 4:
        uint64_t v18 = 0;
        CFDictionaryRef v20 = (const void **)&kDataOffProfile;
        break;
      default:
        CFDictionaryRef v20 = (const void **)&k3GPP;
        uint64_t v18 = v15;
        break;
    }
    CFDictionaryRef v19 = *v20;
    uint64_t v16 = *(void *)buf;
  }
  if (v16) {
    long long v21 = sub_100080778;
  }
  else {
    long long v21 = 0;
  }
  if (v21) {
    BOOL v22 = 1;
  }
  else {
    BOOL v22 = v6 == 0;
  }
  if (!v22)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFNumberRef v48 = 0;
    CFMutableDictionaryRef theDict = Mutable;
    long long __p = (void *)1;
    CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &__p);
    uint64_t v25 = (const void *)kAttachAPNTypeMask;
    if (v24)
    {
      CFNumberRef v26 = v48;
      CFNumberRef v48 = v24;
      long long __p = v26;
      sub_1000570E8((const void **)&__p);
    }
    CFNumberRef v27 = v48;
    CFNumberRef v43 = v48;
    CFNumberRef v48 = 0;
    sub_1000570E8((const void **)&v48);
    CFDictionarySetValue(Mutable, v25, v27);
    sub_1000570E8((const void **)&v43);
    if (v7) {
      CFDictionarySetValue(theDict, kAttachAPNIPCUPresent, kCFBooleanTrue);
    }
    sub_10004EFE4(&v43, (CFTypeRef *)&theDict);
    sub_1006E44B0(a1, kCacheCurrentType, &v43);
    sub_100057D78((const void **)&v43);
    sub_1006E58FC((uint64_t)&__p, a1, 0);
    CFNumberRef v48 = *(CFNumberRef *)buf;
    *(void *)long long buf = __p;
    long long __p = 0;
    sub_100057D78((const void **)&v48);
    *(void *)&uint8_t buf[8] = v46;
    sub_100057D78((const void **)&__p);
    sub_10005717C((const void **)&theDict);
    uint64_t v16 = *(void *)buf;
    uint64_t v18 = v15;
    CFDictionaryRef v19 = v14;
  }
  CFMutableDictionaryRef v41 = 0;
  if (v16) {
    long long v28 = sub_100080778;
  }
  else {
    long long v28 = 0;
  }
  if (v28)
  {
    CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef v41 = v29;
    long long __p = 0;
    sub_10005717C((const void **)&__p);
    if (v19)
    {
      CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)buf, v19);
      if (Value) {
        CFDictionarySetValue(v29, v14, Value);
      }
    }
    if (v18)
    {
      long long v31 = CFDictionaryGetValue(*(CFDictionaryRef *)buf, v18);
      if (v31) {
        CFDictionarySetValue(v29, v15, v31);
      }
    }
  }
  sub_100057D78((const void **)buf);
  sub_10004EFE4(&cf, (CFTypeRef *)&v41);
  sub_10005717C((const void **)&v41);
  uint64_t v32 = *(void *)(a1 + 144);
  if (a2)
  {
    *(void *)long long buf = cf;
    if (cf) {
      CFRetain(cf);
    }
    uint8_t buf[8] = 0;
    sub_1006E9104(v32, (uint64_t)buf, 1);
  }
  else
  {
    *(void *)long long buf = cf;
    if (cf) {
      CFRetain(cf);
    }
    uint8_t buf[8] = a3;
    sub_1006E9A6C(v32, (uint64_t)buf, 1);
  }
  sub_100057D78((const void **)buf);
  uint64_t v33 = *(void *)(a1 + 144);
  if (*(unsigned char *)(v33 + 16))
  {
    if (*(void *)(v33 + 8)) {
      long long v34 = sub_100080778;
    }
    else {
      long long v34 = 0;
    }
    BOOL v35 = v34 != 0;
  }
  else
  {
    BOOL v35 = 0;
  }
  long long v36 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    long long v37 = "";
    long long v38 = " (forced!) ";
    long long v39 = "NO";
    if (!a2) {
      long long v38 = "";
    }
    if (v35) {
      long long v39 = "YES";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v38;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v39;
    if (a3) {
      long long v37 = " (forcedDetach!) ";
    }
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %sneed to push: %s %s", buf, 0x20u);
  }
  sub_100057D78(&cf);
  return v35;
}

void sub_1006E51F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006E5288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_1006E52B4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    CFBooleanRef v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFTypeID v5 = v4;
      uint64_t v6 = a1[5];
      if (v6)
      {
        int v7 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unsigned int v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Done with secondary pushing", v9, 2u);
        }
        unsigned int v8 = *(std::__shared_weak_count **)(v3 + 176);
        *(void *)(v3 + 168) = 0;
        *(void *)(v3 + 176) = 0;
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_1006E5358(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006E5374(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1006E5384(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006E53B4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1006E5404(uint64_t a1, int a2)
{
  memset(buf, 0, sizeof(buf));
  uint64_t v8 = 0;
  ctu::cf::assign();
  *(_OWORD *)CFTypeID v5 = 0u;
  uint64_t v6 = 0;
  uint64_t v3 = (std::__shared_weak_count *)operator new(0x38uLL);
  v3->__shared_weak_owners_ = 0;
  v3->__shared_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)off_1019FCE30;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019FCC58;
  v3[1].__shared_owners_ = (uint64_t)&v3[1];
  LODWORD(v3[2].__vftable) = a2;
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v3[1].__shared_weak_owners_ = (uint64_t)v3;
  sub_10004D2C8(v3);
  void v4[2] = 0;
  v4[3] = 0;
  v4[0] = v3 + 1;
  v4[1] = v3;
  atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_100F038BC((uint64_t *)v5, (uint64_t)v4, 0);
}

void sub_1006E5654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, std::exception a18, std::__shared_weak_count *a19, void **a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,long long buf,long long a28)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v30);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a18.__vftable = (std::exception_vtbl *)&off_101A6DFC8;
    __cxa_begin_catch(a1);
    uint64_t v33 = *(NSObject **)(v29 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      int v34 = a25;
      BOOL v35 = a20;
      sub_1006E285C(&__p, v28);
      long long v36 = (void **)&a20;
      if (v34 < 0) {
        long long v36 = v35;
      }
      if (a15 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = (void **)__p;
      }
      LODWORD(buf) = 136315650;
      *(void *)((char *)&buf + 4) = v36;
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = v28;
      WORD1(a28) = 2080;
      *(void *)((char *)&a28 + 4) = p_p;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Cannot parse AttachApn expression '%s' with type-mask 0x%x [%s]", (uint8_t *)&buf, 0x1Cu);
      if (a15 < 0) {
        operator delete(__p);
      }
    }
    std::exception::~exception(&a18);
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
    {
      if (a25 < 0) {
        operator delete(a20);
      }
      _Unwind_Resume(a1);
    }
    __cxa_get_exception_ptr(a1);
    a18.__vftable = (std::exception_vtbl *)&off_101A6DFF0;
    __cxa_begin_catch(a1);
    long long v38 = *(NSObject **)(v29 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      int v39 = a25;
      long long v40 = a20;
      sub_1006E285C(&__p, v28);
      CFMutableDictionaryRef v41 = (void **)&a20;
      if (v39 < 0) {
        CFMutableDictionaryRef v41 = v40;
      }
      if (a15 >= 0) {
        uint64_t v42 = &__p;
      }
      else {
        uint64_t v42 = (void **)__p;
      }
      LODWORD(buf) = 136315650;
      *(void *)((char *)&buf + 4) = v41;
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = v28;
      WORD1(a28) = 2080;
      *(void *)((char *)&a28 + 4) = v42;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Got TypeError while evaluating AttachApn expression '%s' with type-mask 0x%x [%s]", (uint8_t *)&buf, 0x1Cu);
      if (a15 < 0) {
        operator delete(__p);
      }
    }
    std::exception::~exception(&a18);
    __cxa_end_catch();
  }
  JUMPOUT(0x1006E5608);
}

const void **sub_1006E58FC(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeID v5 = 0;
  uint64_t v6 = (const void **)&kProvisioningProfile;
  switch(a3)
  {
    case 1:
      break;
    case 2:
      CFTypeID v5 = 0;
      uint64_t v6 = (const void **)&kVoLTEProfile;
      break;
    case 3:
      CFTypeID v5 = 0;
      uint64_t v6 = (const void **)&kWiFiCallingProfile;
      break;
    case 4:
      CFTypeID v5 = 0;
      uint64_t v6 = (const void **)&kDataOffProfile;
      break;
    default:
      CFTypeID v5 = (const void *)k3GPP2;
      uint64_t v6 = (const void **)&k3GPP;
      break;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *v6;
  cf[0] = (CFTypeRef)kCacheUI;
  cf[1] = (CFTypeRef)kCacheIPCU;
  cf[2] = (CFTypeRef)kCacheSim;
  while (1)
  {
    CFStringRef v9 = (const __CFString *)cf[v7];
    CFDictionaryRef theDict = 0;
    sub_1006E3580(&theDict, a2, v9);
    uint64_t v10 = theDict ? sub_100080778 : 0;
    if (v10 && (v8 && CFDictionaryContainsKey(theDict, v8) || v5 && CFDictionaryContainsKey(theDict, v5))) {
      break;
    }
    sub_100057D78((const void **)&theDict);
    if (++v7 == 3)
    {
      cf[0] = 0;
      sub_1006E4278(cf, a2);
      if (cf[0]) {
        BOOL v11 = sub_100080934;
      }
      else {
        BOOL v11 = 0;
      }
      if (v11)
      {
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(cf[0]))
        {
          v24[0] = 0;
          sub_10004EFE4(v24, cf);
          char v13 = *(NSObject **)(a2 + 40);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I dictionary of AttachAPN settings", buf, 2u);
          }
          if (v24[0]) {
            xpc_object_t v14 = sub_100080778;
          }
          else {
            xpc_object_t v14 = 0;
          }
          if (v14 && (v8 && CFDictionaryContainsKey(v24[0], v8) || v5 && CFDictionaryContainsKey(v24[0], v5)))
          {
            CFDictionaryRef v15 = *(NSObject **)(a2 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = asString();
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v16;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I CB has settings for %s", buf, 0xCu);
            }
            CFDictionaryRef v17 = v24[0];
            *(CFDictionaryRef *)long long buf = v24[0];
            if (v24[0]) {
              CFRetain(v24[0]);
            }
            memset(buf, 0, sizeof(buf));
            *(void *)a1 = v17;
            *(void *)(a1 + 8) = 0;
            goto LABEL_44;
          }
          sub_100057D78((const void **)v24);
        }
      }
      v24[0] = 0;
      *(_OWORD *)long long buf = 0u;
      *(_OWORD *)a1 = 0u;
LABEL_44:
      sub_100057D78((const void **)buf);
      sub_100057D78((const void **)v24);
      return sub_1000577C4(cf);
    }
  }
  uint64_t v18 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v33 = 0;
    ctu::cf::assign();
    uint64_t v25 = v33;
    *(_OWORD *)CFNumberRef v24 = *(_OWORD *)buf;
    int v19 = SHIBYTE(v33);
    CFDictionaryRef v20 = *(CFDictionaryRef **)buf;
    uint64_t v21 = asString();
    BOOL v22 = v24;
    if (v19 < 0) {
      BOOL v22 = v20;
    }
    *(_DWORD *)CFNumberRef v27 = 136315394;
    unsigned int v28 = v22;
    __int16 v29 = 2080;
    uint64_t v30 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s has settings for %s", v27, 0x16u);
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
  }
  sub_100058198((const void **)a1, (const void **)&theDict);
  *(void *)(a1 + 8) = v9;
  return sub_100057D78((const void **)&theDict);
}

void sub_1006E5CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16)
{
}

const void **sub_1006E5D5C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = 0;
  cf[0] = (CFTypeRef)kCacheUI;
  cf[1] = (CFTypeRef)kCacheIPCU;
  cf[2] = (CFTypeRef)kCacheSim;
  uint64_t v6 = (const void *)kApplies;
  uint64_t v7 = (const void *)k3GPP;
  uint64_t v8 = (const void *)k3GPP2;
  do
  {
    CFStringRef v9 = (const __CFString *)cf[v5];
    CFDictionaryRef theDict = 0;
    sub_1006E3580(&theDict, a2, v9);
    if (theDict) {
      uint64_t v10 = sub_100080778;
    }
    else {
      uint64_t v10 = 0;
    }
    if (v10)
    {
      if (CFDictionaryContainsKey(theDict, v6))
      {
        CFBooleanRef Value = CFDictionaryGetValue(theDict, v6);
        if (Value)
        {
          CFTypeID v12 = CFGetTypeID(Value);
          if (v12 == CFStringGetTypeID()) {
            sub_1006E5404(a2, a3);
          }
        }
      }
    }
    sub_100057D78((const void **)&theDict);
    ++v5;
  }
  while (v5 != 3);
  cf[0] = 0;
  sub_1006E4278(cf, a2);
  if (cf[0]) {
    char v13 = sub_100080934;
  }
  else {
    char v13 = 0;
  }
  if (!v13) {
    goto LABEL_39;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(cf[0])) {
    goto LABEL_39;
  }
  theArray[0] = 0;
  sub_100044D6C(theArray, cf);
  CFDictionaryRef v15 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I array of AttachAPN settings", (uint8_t *)buf, 2u);
  }
  CFIndex Count = CFArrayGetCount(theArray[0]);
  if (Count < 1)
  {
LABEL_38:
    sub_100044D00((const void **)theArray);
LABEL_39:
    long long __p = 0;
    *(_OWORD *)long long buf = 0u;
    *(_OWORD *)a1 = 0u;
    sub_100057D78(buf);
    sub_100057D78(&__p);
    return sub_1000577C4(cf);
  }
  for (CFIndex i = 0; i != Count; ++i)
  {
    CFDictionaryRef theDict = 0;
    buf[0] = CFArrayGetValueAtIndex(theArray[0], i);
    sub_10004EFE4(&theDict, buf);
    if (theDict) {
      uint64_t v18 = sub_100080778;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v18)
    {
      if (CFDictionaryContainsKey(theDict, v6))
      {
        int v19 = CFDictionaryGetValue(theDict, v6);
        if (v19)
        {
          CFTypeID v20 = CFGetTypeID(v19);
          if (v20 == CFStringGetTypeID()) {
            sub_1006E5404(a2, a3);
          }
        }
      }
    }
    sub_100057D78((const void **)&theDict);
  }
  CFIndex v21 = 0;
  while (1)
  {
    CFDictionaryRef theDict = 0;
    buf[0] = CFArrayGetValueAtIndex(theArray[0], v21);
    sub_10004EFE4(&theDict, buf);
    BOOL v22 = theDict ? sub_100080778 : 0;
    if (v22
      && !CFDictionaryContainsKey(theDict, v6)
      && (CFDictionaryContainsKey(theDict, v7) || CFDictionaryContainsKey(theDict, v8)))
    {
      break;
    }
    sub_100057D78((const void **)&theDict);
    if (Count == ++v21) {
      goto LABEL_38;
    }
  }
  CFNumberRef v24 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    sub_1006E285C(buf, a3);
    uint64_t v25 = (v31 & 0x80000000) == 0 ? (uint8_t *)buf : (uint8_t *)buf[0];
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = a3;
    __int16 __p_8 = 2080;
    __p_10 = v25;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I CB has settings for type-mask 0x%x [%s]", (uint8_t *)&__p, 0x12u);
    if (SBYTE3(v31) < 0) {
      operator delete((void *)buf[0]);
    }
  }
  CFDictionaryRef v26 = theDict;
  buf[0] = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  memset(buf, 0, sizeof(buf));
  *(void *)a1 = v26;
  *(void *)(a1 + 8) = 0;
  sub_100057D78(buf);
  sub_100057D78((const void **)&theDict);
  sub_100044D00((const void **)theArray);
  return sub_1000577C4(cf);
}

void sub_1006E635C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  CFBooleanRef v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, const void *);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  sub_100057D78((const void **)va1);
  sub_100044D00((const void **)va);
  sub_1000577C4((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_1006E6404(uint64_t a1, unsigned int a2)
{
  if (a2 > 8) {
    int v3 = 5;
  }
  else {
    int v3 = dword_1014DE564[a2];
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_1006E5D5C((uint64_t)&v10, a1, 1 << v3);
  CFBooleanRef v4 = v10;
  if (v10) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    sub_1006E58FC((uint64_t)v9, a1, v3);
    uint64_t v12 = v10;
    uint64_t v10 = v9[0];
    v9[0] = 0;
    sub_100057D78(&v12);
    uint64_t v11 = v9[1];
    sub_100057D78(v9);
    CFBooleanRef v4 = v10;
  }
  if (v4) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  BOOL v7 = v6 != 0;
  sub_100057D78(&v10);
  return v7;
}

void sub_1006E64EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1006E6500(uint64_t a1, BOOL a2, uint64_t a3)
{
  int v5 = sub_1006E40D4(a1);
  int v6 = sub_1006E22CC(a1);
  uint64_t v7 = 0;
  *(_OWORD *)long long buf = xmmword_1014DD860;
  while (1)
  {
    unint64_t v8 = *(unsigned int *)&buf[v7];
    if ((*(void *)(*(void *)(a1 + 120) + ((v8 >> 3) & 0x1FFFFFF8)) >> v8))
    {
      *(_OWORD *)uint64_t v44 = 0uLL;
      sub_1006E58FC((uint64_t)v44, a1, v8);
      CFStringRef v9 = *(void *)v44 ? sub_100080778 : 0;
      sub_100057D78((const void **)v44);
      if (v9) {
        break;
      }
    }
    v7 += 4;
    if (v7 == 16)
    {
      LODWORD(v8) = 0;
      break;
    }
  }
  if (v6 != 5 && v6) {
    unsigned int v10 = 1 << v6;
  }
  else {
    unsigned int v10 = sub_1006E2568(a1);
  }
  if (v8 != 5 && v8)
  {
    unsigned int v14 = 1 << v8;
  }
  else
  {
    unsigned int v11 = 0;
    for (unint64_t i = 1; i != 5; ++i)
    {
      if ((*(void *)(*(void *)(a1 + 120) + ((i >> 3) & 0x1FFFFFFFFFFFFFF8)) >> i)) {
        int v13 = 1 << i;
      }
      else {
        int v13 = 0;
      }
      v11 |= v13;
    }
    if (v11 <= 1) {
      unsigned int v14 = 1;
    }
    else {
      unsigned int v14 = v11;
    }
  }
  CFDictionaryRef v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = v44;
    sub_1006E285C(v44, v10);
    if (v45 < 0) {
      uint64_t v16 = *(uint8_t **)v44;
    }
    sub_1006E285C(__p, v14);
    if (v42 >= 0) {
      CFDictionaryRef v17 = __p;
    }
    else {
      CFDictionaryRef v17 = (void **)__p[0];
    }
    uint64_t v18 = asStringBool(a2);
    uint64_t v19 = asStringBool(v5);
    *(_DWORD *)long long buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = v10;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v16;
    __int16 v47 = 1024;
    unsigned int v48 = v14;
    __int16 v49 = 2082;
    int v50 = v17;
    __int16 v51 = 2080;
    uint64_t v52 = v18;
    __int16 v53 = 2080;
    uint64_t v54 = v19;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Current type-mask: 0x%x [%{public}s], new effective type-mask: 0x%x [%{public}s], externalReset: %s, ipcuPresent: %s", buf, 0x36u);
    if (v42 < 0) {
      operator delete(__p[0]);
    }
    if (v45 < 0) {
      operator delete(*(void **)v44);
    }
  }
  sub_1006E3580(buf, a1, kCacheIPCU);
  if (*(void *)buf) {
    CFTypeID v20 = sub_100080778;
  }
  else {
    CFTypeID v20 = 0;
  }
  BOOL v21 = v20 != 0;
  sub_100057D78((const void **)buf);
  int v22 = v5 ^ v21;
  if (v10 == v14 && v22 == 0)
  {
    unsigned int v32 = 0;
  }
  else
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef theDict = Mutable;
    *(void *)uint64_t v44 = 0;
    *(void *)long long buf = v14;
    CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
    CFDictionaryRef v26 = (const void *)kAttachAPNTypeMask;
    if (v25)
    {
      uint64_t v27 = *(void *)v44;
      *(void *)uint64_t v44 = v25;
      *(void *)long long buf = v27;
      sub_1000570E8((const void **)buf);
    }
    unsigned int v28 = *(const void **)v44;
    __p[0] = *(void **)v44;
    *(void *)uint64_t v44 = 0;
    sub_1000570E8((const void **)v44);
    CFDictionarySetValue(Mutable, v26, v28);
    sub_1000570E8((const void **)__p);
    if (v21) {
      CFDictionarySetValue(theDict, kAttachAPNIPCUPresent, kCFBooleanTrue);
    }
    sub_10004EFE4(&v39, (CFTypeRef *)&theDict);
    sub_1006E44B0(a1, kCacheCurrentType, &v39);
    sub_100057D78((const void **)&v39);
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_1006E5D5C((uint64_t)buf, a1, 0x10u);
    uint64_t v29 = *(void *)buf;
    if (*(void *)buf) {
      uint64_t v30 = sub_100080778;
    }
    else {
      uint64_t v30 = 0;
    }
    if (!v30)
    {
      sub_1006E58FC((uint64_t)v44, a1, 4);
      __p[0] = *(void **)buf;
      *(void *)long long buf = *(void *)v44;
      *(void *)uint64_t v44 = 0;
      sub_100057D78((const void **)__p);
      *(void *)&uint8_t buf[8] = *(void *)&v44[8];
      sub_100057D78((const void **)v44);
      uint64_t v29 = *(void *)buf;
    }
    if (v29) {
      uint64_t v31 = sub_100080778;
    }
    else {
      uint64_t v31 = 0;
    }
    if (v31) {
      unsigned int v32 = ((v14 & ~v10) >> 4) & 1;
    }
    else {
      unsigned int v32 = 0;
    }
    if (v22)
    {
      uint64_t v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        if ((v5 & !v21) != 0) {
          int v34 = "un";
        }
        else {
          int v34 = "";
        }
        *(_DWORD *)uint64_t v44 = 136315138;
        *(void *)&void v44[4] = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I IPCU is %sinstalled - ordering forced detach", v44, 0xCu);
      }
      unsigned int v32 = 1;
    }
    sub_100057D78((const void **)buf);
    sub_10005717C((const void **)&theDict);
  }
  BOOL v35 = sub_1006E4C20(a1, 0, v32 & !a2);
  if (v35)
  {
    sub_1000F0058((uint64_t)v43, a3);
    sub_1006E6AE8(a1, (uint64_t)v43);
    sub_10003B34C(v43);
  }
  else
  {
    uint64_t v36 = *(void *)(a3 + 24);
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 48))(v36);
    }
  }
  return v35;
}

void sub_1006E6A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,const void *a30)
{
}

void *sub_1006E6AE8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  sub_1000F0058((uint64_t)v4, a2);
  sub_1000F0058((uint64_t)v5, (uint64_t)v4);
  sub_1006EA43C(v2, (uint64_t)v5, 1);
  sub_10003B34C(v5);
  return sub_10003B34C(v4);
}

void sub_1006E6B70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_10003B34C((uint64_t *)va1);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1006E6B9C(uint64_t a1, char a2, int a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 120);
  uint64_t v6 = 1 << a2;
  int v7 = (*v5 & (1 << a2)) != 0;
  unint64_t v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7 == a3)
  {
    if (v9)
    {
      if (a3) {
        uint64_t v12 = "En";
      }
      else {
        uint64_t v12 = "Dis";
      }
      int v13 = 136315394;
      unsigned int v14 = v12;
      __int16 v15 = 2080;
      uint64_t v16 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %sabling %s mode - not changed", (uint8_t *)&v13, 0x16u);
    }
  }
  else
  {
    if (v9)
    {
      if (a3) {
        unsigned int v10 = "En";
      }
      else {
        unsigned int v10 = "Dis";
      }
      int v13 = 136315394;
      unsigned int v14 = v10;
      __int16 v15 = 2080;
      uint64_t v16 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %sabling %s mode", (uint8_t *)&v13, 0x16u);
      uint64_t v5 = *(uint64_t **)(a1 + 120);
    }
    if (a3) {
      uint64_t v11 = *v5 | v6;
    }
    else {
      uint64_t v11 = *v5 & ~v6;
    }
    *uint64_t v5 = v11;
  }
}

const void **sub_1006E6D2C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I PRI was pushed, need to clear kCacheWritten", buf, 2u);
  }
  CFBooleanRef v4 = 0;
  sub_1006E44B0(a1, kCacheWritten, &v4);
  return sub_100057D78((const void **)&v4);
}

void sub_1006E6DB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1006E6DC8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Preferred data sim was changed, need to clear kCacheWritten", buf, 2u);
  }
  CFBooleanRef v4 = 0;
  sub_1006E44B0(a1, kCacheWritten, &v4);
  return sub_100057D78((const void **)&v4);
}

void sub_1006E6E50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1006E6E64(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  switch(a2)
  {
    case 0:
      int v5 = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      char v9 = 1;
      goto LABEL_15;
    case 2:
      unsigned int v10 = *(unint64_t **)(a1 + 120);
      unint64_t v11 = *v10;
      uint64_t v12 = *v10 & 2;
      int v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        __int16 v15 = "disabled";
        if (!v12) {
          __int16 v15 = "enabled";
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v20 = v14;
        __int16 v21 = 2080;
        int v22 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Toggling %s mode to %s", buf, 0x16u);
        unsigned int v10 = *(unint64_t **)(a1 + 120);
        unint64_t v11 = *v10;
      }
      *unsigned int v10 = (v11 & 0xFFFFFFFFFFFFFFFDLL | v12) ^ 2;
      break;
    case 3:
      int v6 = 1;
      goto LABEL_10;
    case 4:
LABEL_10:
      char v9 = 2;
      int v5 = v6;
      goto LABEL_15;
    case 5:
      int v7 = 1;
      goto LABEL_12;
    case 6:
LABEL_12:
      sub_1006E6B9C(a1, 3, v7);
      ++*(_DWORD *)(a1 + 112);
      break;
    case 7:
      int v8 = 1;
      goto LABEL_14;
    case 8:
LABEL_14:
      char v9 = 4;
      int v5 = v8;
LABEL_15:
      sub_1006E6B9C(a1, v9, v5);
      break;
    default:
      break;
  }
  sub_1000F0058((uint64_t)v18, a3);
  BOOL v16 = sub_1006E6500(a1, 0, (uint64_t)v18);
  sub_10003B34C(v18);
  return v16;
}

void sub_1006E702C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1006E706C(uint64_t a1)
{
  return sub_1006EAC68(*(void *)(a1 + 144), (uint64_t)&v2, 1);
}

uint64_t sub_1006E7098(uint64_t a1)
{
  return sub_1006EAC68(*(void *)(a1 + 96), (uint64_t)&v2, 1);
}

uint64_t sub_1006E70C4(uint64_t a1)
{
  return sub_1006EAF28(*(void *)(a1 + 144), (uint64_t)&v2, 1);
}

uint64_t sub_1006E70F0(uint64_t a1)
{
  return sub_1006EAF28(*(void *)(a1 + 96), (uint64_t)&v2, 1);
}

uint64_t sub_1006E7120(uint64_t a1)
{
  return AttachApnManagerInterface::incSharedPushCount_sync((AttachApnManagerInterface *)(a1 - 48));
}

uint64_t sub_1006E7128(uint64_t a1, int a2, int a3, int a4, uint64_t a5)
{
  unsigned int v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v11)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E settings push failed!", buf, 2u);
    }
    uint64_t v12 = *(void *)(a1 + 144);
    if (a4) {
      sub_1006ECB98(v12, (uint64_t)buf, 1);
    }
    else {
      sub_1006ED044(v12, (uint64_t)buf, 1);
    }
  }
  else
  {
    if (v11)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I settings push complete!", buf, 2u);
    }
    sub_1006ED4CC(*(void *)(a1 + 144), (uint64_t)buf, 1);
    if (a3)
    {
      sub_100058DB0(&__p, "Resetting baseband after AttachAPN Push to force detach");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (v17 < 0) {
        operator delete(*(void **)buf);
      }
      if (v15 < 0) {
        operator delete(__p);
      }
    }
  }
  uint64_t result = *(void *)(a5 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
  }
  return result;
}

void sub_1006E7288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006E72BC(uint64_t a1, int a2, int a3, int a4, uint64_t a5)
{
  return sub_1006E7128(a1 - 48, a2, a3, a4, a5);
}

uint64_t sub_1006E72C4(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sim %s <<====================================", buf, 0xCu);
    char v2 = *(NSObject **)(a1 + 40);
  }
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    int PushCount_sync = AttachApnManagerInterface::getPushCount_sync((AttachApnManagerInterface *)v3);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = PushCount_sync;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I PushCFIndex Count = %u", buf, 8u);
  }
  uint64_t v68 = 0;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  memset(v55, 0, sizeof(v55));
  *(_OWORD *)long long buf = 0u;
  sub_10004BD84((uint64_t)buf);
  int v6 = sub_10004B96C(v55, (uint64_t)"fValueToPush ", 13);
  uint64_t v7 = *(void *)(a1 + 144);
  int v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(unsigned char *)(v7 + 16))
  {
    ctu::cf_to_xpc((uint64_t *)&object, *(ctu **)(v7 + 8), v5);
    xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&object);
  }
  else
  {
    sub_100058DB0(&__p, "empty");
  }
  if (v51 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v51 >= 0) {
    uint64_t v10 = HIBYTE(v51);
  }
  else {
    uint64_t v10 = v50;
  }
  BOOL v11 = sub_10004B96C(v6, (uint64_t)p_p, v10);
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(void *)(*v11 - 24)));
  uint64_t v12 = std::locale::use_facet(v46, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(v46);
  std::ostream::put();
  std::ostream::flush();
  if ((SHIBYTE(v51) & 0x80000000) == 0)
  {
    if (!v8) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  operator delete(__p);
  if (v8) {
LABEL_18:
  }
    xpc_release(object);
LABEL_19:
  sub_10004B96C(v55, (uint64_t)"fRecoveryResetPerformed ", 24);
  int v13 = (void *)std::ostream::operator<<();
  sub_10004B96C(v13, (uint64_t)", ", 2);
  uint64_t v14 = sub_10004B96C(v55, (uint64_t)"Prevent baseband reset assertion held: ", 39);
  char v15 = (const char *)asStringBool(*(void *)(a1 + 168) != 0);
  size_t v16 = strlen(v15);
  char v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
  sub_10004B96C(v17, (uint64_t)", ", 2);
  sub_10004B96C(v55, (uint64_t)"state ", 6);
  uint64_t v18 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  uint64_t v19 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v20 = 0;
  long long __p = (void *)kCacheCurrentType;
  uint64_t v50 = kCacheUI;
  uint64_t v51 = kCacheSim;
  uint64_t v52 = kCacheIPCU;
  uint64_t v53 = kCacheWritten;
  do
  {
    CFStringRef v21 = *(const __CFString **)((char *)&__p + v20);
    uint64_t v44 = 0;
    sub_1006E3580(&v44, a1, v21);
    v46[0].__locale_ = 0;
    v46[1].__locale_ = 0;
    uint64_t v47 = 0;
    ctu::cf::assign();
    *(_OWORD *)char v42 = *(_OWORD *)&v46[0].__locale_;
    uint64_t v43 = v47;
    if (v47 >= 0) {
      locale = v42;
    }
    else {
      locale = v46[0].__locale_;
    }
    if (v47 >= 0) {
      uint64_t v23 = HIBYTE(v47);
    }
    else {
      uint64_t v23 = (uint64_t)v46[1].__locale_;
    }
    CFNumberRef v24 = sub_10004B96C(v55, (uint64_t)locale, v23);
    CFDictionaryRef v26 = sub_10004B96C(v24, (uint64_t)": ", 2);
    if (v44) {
      uint64_t v27 = sub_100080778;
    }
    else {
      uint64_t v27 = 0;
    }
    if (v27)
    {
      ctu::cf_to_xpc((uint64_t *)&v41, v44, v25);
      xpc::object::to_string((uint64_t *)v46, (xpc::object *)&v41);
    }
    else
    {
      sub_100058DB0(v46, "empty");
    }
    if (v47 >= 0) {
      unsigned int v28 = v46;
    }
    else {
      unsigned int v28 = v46[0].__locale_;
    }
    if (v47 >= 0) {
      uint64_t v29 = HIBYTE(v47);
    }
    else {
      uint64_t v29 = (uint64_t)v46[1].__locale_;
    }
    uint64_t v30 = sub_10004B96C(v26, (uint64_t)v28, v29);
    std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24)));
    uint64_t v31 = std::locale::use_facet(&v48, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10);
    std::locale::~locale(&v48);
    std::ostream::put();
    std::ostream::flush();
    if (SHIBYTE(v47) < 0)
    {
      operator delete(v46[0].__locale_);
      if (!v27) {
        goto LABEL_43;
      }
LABEL_42:
      xpc_release(v41);
      goto LABEL_43;
    }
    if (v27) {
      goto LABEL_42;
    }
LABEL_43:
    if (SHIBYTE(v43) < 0) {
      operator delete(v42[0]);
    }
    sub_100057D78((const void **)&v44);
    v20 += 8;
  }
  while (v20 != 40);
  v42[0] = 0;
  sub_1006E4278((const void **)&__p, a1);
  sub_10004EFE4(v42, (CFTypeRef *)&__p);
  sub_1000577C4((const void **)&__p);
  uint64_t v33 = sub_10004B96C(v55, (uint64_t)"Carrier Bundle: ", 16);
  if (v42[0]) {
    int v34 = sub_100080778;
  }
  else {
    int v34 = 0;
  }
  if (v34)
  {
    ctu::cf_to_xpc((uint64_t *)&v48, v42[0], v32);
    xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&v48);
  }
  else
  {
    sub_100058DB0(&__p, "empty");
  }
  if (v51 >= 0) {
    BOOL v35 = &__p;
  }
  else {
    BOOL v35 = __p;
  }
  if (v51 >= 0) {
    uint64_t v36 = HIBYTE(v51);
  }
  else {
    uint64_t v36 = v50;
  }
  long long v37 = sub_10004B96C(v33, (uint64_t)v35, v36);
  std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*v37 - 24)));
  long long v38 = std::locale::use_facet(v46, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
  std::locale::~locale(v46);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(v51) < 0)
  {
    operator delete(__p);
    if (!v34) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  if (v34) {
LABEL_62:
  }
    xpc_release(v48.__locale_);
LABEL_63:
  sub_1006E33B4(a1, buf);
  (*(void (**)(void))(**(void **)(a1 + 152) + 56))(*(void *)(a1 + 152));
  sub_100057D78((const void **)v42);
  v55[0] = v39;
  if (SHIBYTE(v57) < 0) {
    operator delete(*((void **)&v56 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1006E7ADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, xpc_object_t a18, std::locale a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t object,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006E7C48(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1006E7CE4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1006E7CEC(uint64_t a1, ctu **a2)
{
  uint64_t v50 = 0;
  sub_1006E3580(&v50, a1, kCacheWritten);
  if (*a2) {
    int v4 = sub_100080778;
  }
  else {
    int v4 = 0;
  }
  if (v50) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v4)
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (!v5)
    {
      if (!v12)
      {
LABEL_24:
        uint64_t v8 = 0;
        goto LABEL_53;
      }
      *(_WORD *)long long buf = 0;
      char v9 = "#I no writtenCache and no candidate setting => nothing to do";
      uint64_t v10 = v11;
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, 2u);
      goto LABEL_24;
    }
    if (v12)
    {
      *(_WORD *)long long buf = 0;
      int v13 = "#I writtenCache present, but no candidate setting => mark as needs an empty push";
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
    }
LABEL_52:
    uint64_t v8 = 1;
    goto LABEL_53;
  }
  if (!v5)
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v13 = "#I no writtenCache; pushing candidate setting!";
      goto LABEL_17;
    }
    goto LABEL_52;
  }
  if (!CFEqual(*a2, v50))
  {
    xpc_object_t v49 = 0;
    ctu::cf_to_xpc((uint64_t *)buf, *a2, v6);
    uint64_t v14 = *(void **)buf;
    xpc_object_t v49 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v14);
    }
    else {
      xpc_object_t v49 = xpc_null_create();
    }
    xpc_release(*(xpc_object_t *)buf);
    ctu::cf_to_xpc((uint64_t *)buf, v50, v15);
    size_t v16 = *(void **)buf;
    xpc_object_t v48 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v16);
    }
    else {
      xpc_object_t v48 = xpc_null_create();
    }
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v47 = 0;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    *(_OWORD *)BOOL v35 = 0u;
    long long v36 = 0u;
    memset(v34, 0, sizeof(v34));
    *(_OWORD *)long long buf = 0u;
    sub_10004BD84((uint64_t)buf);
    char v17 = sub_10004B96C(v34, (uint64_t)"Candidate: ", 11);
    xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&v49);
    if ((v32 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v32 & 0x80u) == 0) {
      uint64_t v19 = v32;
    }
    else {
      uint64_t v19 = v31;
    }
    uint64_t v20 = sub_10004B96C(v17, (uint64_t)p_p, v19);
    std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
    CFStringRef v21 = std::locale::use_facet(&v51, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
    std::locale::~locale(&v51);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v32 < 0) {
      operator delete(__p);
    }
    int v22 = sub_10004B96C(v34, (uint64_t)"writtenCache: ", 14);
    xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&v48);
    if ((v32 & 0x80u) == 0) {
      uint64_t v23 = &__p;
    }
    else {
      uint64_t v23 = __p;
    }
    if ((v32 & 0x80u) == 0) {
      uint64_t v24 = v32;
    }
    else {
      uint64_t v24 = v31;
    }
    CFNumberRef v25 = sub_10004B96C(v22, (uint64_t)v23, v24);
    std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
    CFDictionaryRef v26 = std::locale::use_facet(&v51, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
    std::locale::~locale(&v51);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v32 < 0) {
      operator delete(__p);
    }
    sub_1006E33B4(a1, buf);
    uint64_t v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Candidate and writtenCache are different => need to update!", (uint8_t *)&__p, 2u);
    }
    *(void *)&v34[0] = v28;
    if (SHIBYTE(v36) < 0) {
      operator delete(v35[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    xpc_release(v48);
    xpc_release(v49);
    goto LABEL_52;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  uint64_t v8 = 0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    char v9 = "#I Candidate and writtenCache match => nothing to do";
    uint64_t v10 = v7;
    goto LABEL_23;
  }
LABEL_53:
  sub_100057D78((const void **)&v50);
  return v8;
}

void sub_1006E8260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  sub_10008248C((uint64_t)&a16);
  xpc_release(*(xpc_object_t *)(v16 - 80));
  xpc_release(*(xpc_object_t *)(v16 - 72));
  sub_100057D78((const void **)(v16 - 64));
  _Unwind_Resume(a1);
}

uint64_t sub_1006E82FC(uint64_t a1, ctu **a2)
{
  return sub_1006E7CEC(a1 - 56, a2);
}

uint64_t sub_1006E8304(uint64_t a1)
{
  return a1;
}

uint64_t sub_1006E8330(uint64_t a1, uint64_t a2)
{
  int v3 = 0;
  while (1)
  {
    int v4 = (const char *)asString();
    uint64_t v5 = v4;
    int v6 = *(char *)(a2 + 23);
    size_t v7 = v6 >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
    if (v7 == strlen(v4))
    {
      uint64_t v8 = v6 >= 0 ? (const void *)a2 : *(const void **)a2;
      uint64_t result = memcmp(v8, v5, v7);
      if (!result) {
        break;
      }
    }
    if (++v3 == 5) {
      return 2;
    }
  }
  return result;
}

void sub_1006E83BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 31);
  int v3 = (char)v2;
  unint64_t v4 = *(void *)(a2 + 16);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 16);
  }
  if (v2)
  {
    __p[0] = 0;
    __p[1] = 0;
    size_t v7 = (void **)(a2 + 8);
    uint64_t v15 = 0;
    if (v3 < 0)
    {
      sub_10004FC84(__p, *v7, v4);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v7;
      uint64_t v15 = *(void *)(a2 + 24);
    }
    int v8 = 0;
    while (1)
    {
      char v9 = (const char *)asString();
      uint64_t v10 = v9;
      char v11 = HIBYTE(v15);
      BOOL v12 = v15 >= 0 ? (void *)HIBYTE(v15) : __p[1];
      if (v12 == (void *)strlen(v9))
      {
        int v13 = v15 >= 0 ? __p : (void **)__p[0];
        if (!memcmp(v13, v10, (size_t)v12)) {
          break;
        }
      }
      if (++v8 == 5)
      {
        if ((v11 & 0x80) == 0) {
          return;
        }
        goto LABEL_20;
      }
    }
    sub_100F04328(a2, (*(_DWORD *)(a1 + 24) >> v8) & 1);
    if ((v15 & 0x8000000000000000) == 0) {
      return;
    }
LABEL_20:
    operator delete(__p[0]);
  }
}

void sub_1006E84D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006E84F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1006E85BC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1006E8694);
  __cxa_rethrow();
}

void sub_1006E85E4(_Unwind_Exception *a1)
{
}

void sub_1006E85FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006E8634(uint64_t a1)
{
}

uint64_t sub_1006E8650(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006E8694(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1006E86C0(uint64_t a1)
{
  sub_1000B3D68((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_100057D78((const void **)(a1 + 8));
  }

  operator delete();
}

void sub_1006E8728(void *a1, uint64_t *a2)
{
  __int16 v20 = 0;
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v20, (unsigned __int16 *)a1, v5);
    }
  }
  uint64_t v6 = *a2;
  size_t v7 = *(_WORD **)(v6 + 8);
  unint64_t v8 = *(void *)(v6 + 16);
  if ((unint64_t)v7 >= v8)
  {
    uint64_t v10 = *(_WORD **)v6;
    uint64_t v11 = (uint64_t)v7 - *(void *)v6;
    if (v11 <= -3) {
      sub_10006A748();
    }
    uint64_t v12 = v11 >> 1;
    unint64_t v13 = v8 - (void)v10;
    if (v13 <= (v11 >> 1) + 1) {
      unint64_t v14 = v12 + 1;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v13 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v15 = v14;
    }
    if (v15)
    {
      uint64_t v16 = (char *)sub_10006E5B8(v6 + 16, v15);
      uint64_t v10 = *(_WORD **)v6;
      size_t v7 = *(_WORD **)(v6 + 8);
    }
    else
    {
      uint64_t v16 = 0;
    }
    char v17 = &v16[2 * v12];
    uint64_t v18 = &v16[2 * v15];
    *(_WORD *)char v17 = v20;
    char v9 = v17 + 2;
    while (v7 != v10)
    {
      __int16 v19 = *--v7;
      *((_WORD *)v17 - 1) = v19;
      v17 -= 2;
    }
    *(void *)uint64_t v6 = v17;
    *(void *)(v6 + 8) = v9;
    *(void *)(v6 + 16) = v18;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    _WORD *v7 = v20;
    char v9 = v7 + 1;
  }
  *(void *)(v6 + 8) = v9;
}

uint64_t sub_1006E8840(uint64_t a1)
{
  *(void *)a1 = off_1019FCD30;
  sub_10003B34C((void *)(a1 + 72));
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 24)) {
    sub_100057D78((const void **)(a1 + 16));
  }
  return a1;
}

void sub_1006E88A4(uint64_t a1)
{
  *(void *)a1 = off_1019FCD30;
  sub_10003B34C((void *)(a1 + 72));
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 24)) {
    sub_100057D78((const void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1006E8928(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  *uint64_t v2 = off_1019FCD30;
  sub_1006E8BE8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1006E897C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006E8990(uint64_t a1, void *a2)
{
  *a2 = off_1019FCD30;
  return sub_1006E8BE8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1006E89BC(uint64_t a1)
{
}

void sub_1006E89C4(void *a1)
{
  sub_1006E8CB8((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_1006E8A00(const void **result, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v2 = result;
    int v3 = result[1];
    CFTypeID v4 = *((void *)v3 + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset granted. Push to baseband now", buf, 2u);
    }
    uint64_t v5 = *((void *)v3 + 19);
    LOBYTE(v6) = 0;
    char v7 = 0;
    if (*((unsigned char *)v2 + 24))
    {
      sub_100058198(&v6, v2 + 2);
      char v7 = 1;
    }
    sub_1000F0058((uint64_t)v8, (uint64_t)(v2 + 9));
    AttachApnCommandDriver::AttachApnPushConfig::AttachApnPushConfig();
    (*(void (**)(uint64_t, const void **, uint8_t *))(*(void *)v5 + 48))(v5, &v6, buf);
    if (__p)
    {
      uint64_t v11 = __p;
      operator delete(__p);
    }
    sub_10003B34C(buf);
    uint64_t result = (const void **)sub_10003B34C(v8);
    if (v7) {
      return sub_100057D78(&v6);
    }
  }
  return result;
}

void sub_1006E8B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_10003B34C(&a16);
  sub_10003B34C(&a12);
  if (a10) {
    sub_100057D78((const void **)&a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006E8B9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006E8BDC()
{
}

uint64_t sub_1006E8BE8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  if (*(unsigned char *)(a2 + 16))
  {
    sub_100058198((const void **)(a1 + 8), (const void **)(a2 + 8));
    *(unsigned char *)(a1 + 16) = 1;
  }
  char v4 = *(unsigned char *)(a2 + 24);
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 24) = v4;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1003A10E0((void *)(a1 + 32), *(const void **)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 1);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  sub_1000F0058(a1 + 64, a2 + 64);
  return a1;
}

void sub_1006E8C84(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  if (*(unsigned char *)(v1 + 16)) {
    sub_100057D78(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006E8CB8(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    sub_100057D78((const void **)(a1 + 8));
  }
}

uint64_t *sub_1006E8D18(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = (dispatch_group_t *)v1;
  int v3 = *(NSObject **)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  if (*(void *)v1)
  {
    dispatch_retain(*(dispatch_object_t *)v1);
    dispatch_group_enter(v3);
  }
  v7[0] = off_1019FCDB0;
  v7[1] = v3;
  uint64_t v7[3] = v7;
  sub_1006E6AE8(v2, (uint64_t)v7);
  sub_10003B34C(v7);
  sub_10062AF08(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1006E8DD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, dispatch_group_t *);
  sub_10003B34C((uint64_t *)va2);
  sub_10062AF08((dispatch_group_t **)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1006E8DF4(void *a1)
{
  *a1 = off_1019FCDB0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[1];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_1006E8E4C(void *a1)
{
  *a1 = off_1019FCDB0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[1];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

dispatch_group_t *sub_1006E8EC4(uint64_t a1)
{
  uint64_t v1 = (NSObject **)(a1 + 8);
  uint64_t v2 = (dispatch_group_t *)operator new(0x10uLL);
  *uint64_t v2 = (dispatch_group_t)off_1019FCDB0;
  sub_1006E8FD8(v2 + 1, v1);
  return v2;
}

dispatch_group_t *sub_1006E8F18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FCDB0;
  return sub_1006E8FD8((dispatch_group_t *)(a2 + 8), (NSObject **)(a1 + 8));
}

void sub_1006E8F44(uint64_t a1)
{
}

void sub_1006E8F4C(NSObject **a1)
{
  sub_1006E9018(a1 + 1);

  operator delete(a1);
}

uint64_t sub_1006E8F8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006E8FCC()
{
}

dispatch_group_t *sub_1006E8FD8(dispatch_group_t *a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3)
  {
    dispatch_retain(v3);
    if (*a1) {
      dispatch_group_enter(*a1);
    }
  }
  return a1;
}

void sub_1006E9018(NSObject **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *a1;
    if (*a1)
    {
      dispatch_release(v3);
    }
  }
}

void sub_1006E9068(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FCE30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006E9088(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FCE30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006E90DC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1006E9104(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112))
  {
    sub_100058198(&cf, (const void **)a2);
    char v5 = *(unsigned char *)(a2 + 8);
    char v15 = v5;
    uint64_t v6 = (std::exception_vtbl *)cf;
    *(void *)&long long v27 = cf;
    if (cf)
    {
      CFRetain(cf);
      char v5 = v15;
      BYTE8(v27) = v15;
      *(void *)&long long v32 = v6;
      CFRetain(v6);
      BYTE8(v32) = v5;
      *(void *)&long long v37 = v6;
      CFRetain(v6);
      BYTE8(v37) = v5;
      v42[0].__vftable = (std::exception_vtbl *)a1;
      v42[1].__vftable = v6;
      CFRetain(v6);
    }
    else
    {
      BYTE8(v27) = v5;
      *(void *)&long long v32 = 0;
      BYTE8(v32) = v5;
      *(void *)&long long v37 = 0;
      BYTE8(v37) = v5;
      v42[0].__vftable = (std::exception_vtbl *)a1;
      v42[1].__vftable = 0;
    }
    LOBYTE(v43) = v5;
    sub_100057D78((const void **)&v37);
    LOBYTE(v44) = 5;
    sub_100057D78((const void **)&v32);
    *(void *)&long long v16 = sub_1006E9104;
    *((void *)&v16 + 1) = 0;
    uint64_t v17 = a1;
    sub_100058198(&v18, (const void **)&v42[1].__vftable);
    char v19 = v43;
    char v20 = (char)v44;
    sub_100057D78((const void **)&v42[1].__vftable);
    sub_100057D78((const void **)&v27);
    long long v22 = v16;
    uint64_t v10 = v17;
    char v9 = v18;
    uint64_t v23 = v17;
    uint64_t v24 = v18;
    if (v18) {
      CFRetain(v18);
    }
    char v11 = v19;
    char v25 = v19;
    char v12 = v20;
    char v26 = v20;
    uint64_t v21 = 0;
    long long v27 = v22;
    uint64_t v28 = v10;
    uint64_t v29 = v9;
    if (v9)
    {
      CFRetain(v9);
      char v30 = v11;
      char v31 = v12;
      long long v32 = v27;
      uint64_t v33 = v10;
      int v34 = v9;
      CFRetain(v9);
      char v35 = v11;
      char v36 = v12;
      long long v37 = v32;
      uint64_t v38 = v10;
      long long v39 = v9;
      CFRetain(v9);
      char v40 = v11;
      char v41 = v12;
      *(_OWORD *)&v42[0].__vftable = v37;
      uint64_t v43 = v10;
      long long v44 = v9;
      CFRetain(v9);
    }
    else
    {
      long long v32 = v22;
      long long v37 = v22;
      char v30 = v19;
      char v31 = v20;
      uint64_t v33 = v10;
      int v34 = 0;
      char v35 = v19;
      char v36 = v20;
      uint64_t v38 = v10;
      long long v39 = 0;
      char v40 = v19;
      char v41 = v20;
      *(_OWORD *)&v42[0].__vftable = v22;
      uint64_t v43 = v10;
      long long v44 = 0;
    }
    char v45 = v11;
    char v46 = v12;
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v8 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 13])(a1, 0);
  std::exception::~exception(v42);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v8;
}

uint64_t sub_1006E9558(uint64_t result, _WORD *a2, int a3)
{
  char v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        sub_100057D78((const void **)(*(void *)a2 + 24));
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_9forcePushEhEENS0_5li"
                                        "st3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_9forcePushEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006E96A0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[40];
  char v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    char v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t *sub_1006E96D4(uint64_t *result)
{
  if (result[12])
  {
    uint64_t v1 = result;
    uint64_t v2 = (int64x2_t *)(result + 7);
    do
    {
      memset(v6, 0, sizeof(v6));
      uint64_t v3 = *(void *)(v1[8] + (((unint64_t)v1[11] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v1[11] & 0x7F);
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3)
      {
        *(void *)&v6[0] = *(void *)v3;
        if (v4)
        {
          long long v5 = *(_OWORD *)(v3 + 8);
          *((void *)&v6[1] + 1) = *(void *)(v3 + 24);
          *(_OWORD *)((char *)v6 + 8) = v5;
        }
        else
        {
          (*(void (**)(uint64_t, char *, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(v3 + 8, (char *)v6 + 8, 0);
        }
      }
      sub_1000983B4(v2);
      sub_100098420(v6);
      uint64_t result = sub_100098288((uint64_t *)v6);
    }
    while (v1[12]);
  }
  return result;
}

void sub_1006E9798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1006E97AC(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v6 = a1 + 4 * a2;
  *(_DWORD *)(v6 + 52) = 2;
  char v7 = (_DWORD *)(v6 + 52);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 40);
  if (v8)
  {
    char v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 32);
      if (v11) {
        (*(void (**)(uint64_t, const char *))(*(void *)v11 + 48))(v11, "FSM: exiting Pushing");
      }
      sub_10004D2C8(v10);
    }
  }
  _DWORD *v7 = 2;
  sub_1006E9894(a4, a1);
  _DWORD *v7 = 1;
  return 1;
}

void sub_1006E9880(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1006E9894(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 40);
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a2 + 32);
      if (v7)
      {
        sub_1006E9958(a2 + 8, (const void **)a1);
        *(unsigned char *)(a2 + 24) = *(unsigned char *)(a1 + 8);
        (*(void (**)(uint64_t, const char *))(*(void *)v7 + 48))(v7, "FSM: entered WaitToPush");
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1006E9944(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006E9958(uint64_t a1, const void **a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    sub_100058140((const void **)a1, a2);
  }
  else
  {
    sub_100058198((const void **)a1, a2);
    *(unsigned char *)(a1 + 8) = 1;
  }
  return a1;
}

uint64_t sub_1006E99A0(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 1;
  sub_1006E9894(a4, a1);
  *(_DWORD *)(v4 + 52) = 1;
  return 1;
}

uint64_t sub_1006E9A08(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 0;
  sub_1006E9894(a4, a1);
  *(_DWORD *)(v4 + 52) = 1;
  return 1;
}

uint64_t sub_1006E9A6C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112))
  {
    sub_100058198(&cf, (const void **)a2);
    char v5 = *(unsigned char *)(a2 + 8);
    char v15 = v5;
    uint64_t v6 = (std::exception_vtbl *)cf;
    *(void *)&long long v27 = cf;
    if (cf)
    {
      CFRetain(cf);
      char v5 = v15;
      BYTE8(v27) = v15;
      *(void *)&long long v32 = v6;
      CFRetain(v6);
      BYTE8(v32) = v5;
      *(void *)&long long v37 = v6;
      CFRetain(v6);
      BYTE8(v37) = v5;
      v42[0].__vftable = (std::exception_vtbl *)a1;
      v42[1].__vftable = v6;
      CFRetain(v6);
    }
    else
    {
      BYTE8(v27) = v5;
      *(void *)&long long v32 = 0;
      BYTE8(v32) = v5;
      *(void *)&long long v37 = 0;
      BYTE8(v37) = v5;
      v42[0].__vftable = (std::exception_vtbl *)a1;
      v42[1].__vftable = 0;
    }
    LOBYTE(v43) = v5;
    sub_100057D78((const void **)&v37);
    LOBYTE(v44) = 5;
    sub_100057D78((const void **)&v32);
    *(void *)&long long v16 = sub_1006E9A6C;
    *((void *)&v16 + 1) = 0;
    uint64_t v17 = a1;
    sub_100058198(&v18, (const void **)&v42[1].__vftable);
    char v19 = v43;
    char v20 = (char)v44;
    sub_100057D78((const void **)&v42[1].__vftable);
    sub_100057D78((const void **)&v27);
    long long v22 = v16;
    uint64_t v10 = v17;
    char v9 = v18;
    uint64_t v23 = v17;
    uint64_t v24 = v18;
    if (v18) {
      CFRetain(v18);
    }
    char v11 = v19;
    char v25 = v19;
    char v12 = v20;
    char v26 = v20;
    uint64_t v21 = 0;
    long long v27 = v22;
    uint64_t v28 = v10;
    uint64_t v29 = v9;
    if (v9)
    {
      CFRetain(v9);
      char v30 = v11;
      char v31 = v12;
      long long v32 = v27;
      uint64_t v33 = v10;
      int v34 = v9;
      CFRetain(v9);
      char v35 = v11;
      char v36 = v12;
      long long v37 = v32;
      uint64_t v38 = v10;
      long long v39 = v9;
      CFRetain(v9);
      char v40 = v11;
      char v41 = v12;
      *(_OWORD *)&v42[0].__vftable = v37;
      uint64_t v43 = v10;
      long long v44 = v9;
      CFRetain(v9);
    }
    else
    {
      long long v32 = v22;
      long long v37 = v22;
      char v30 = v19;
      char v31 = v20;
      uint64_t v33 = v10;
      int v34 = 0;
      char v35 = v19;
      char v36 = v20;
      uint64_t v38 = v10;
      long long v39 = 0;
      char v40 = v19;
      char v41 = v20;
      *(_OWORD *)&v42[0].__vftable = v22;
      uint64_t v43 = v10;
      long long v44 = 0;
    }
    char v45 = v11;
    char v46 = v12;
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v8 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 17])(a1, 0);
  std::exception::~exception(v42);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v8;
}

uint64_t sub_1006E9EC0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        sub_100057D78((const void **)(*(void *)a2 + 24));
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_19pushIfDifferentFrom"
                                        "EhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_19pushIfDifferentFromEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006EA008(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[40];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006EA03C(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v5) {
    return 2;
  }
  uint64_t v8 = std::__shared_weak_count::lock(v5);
  if (!v8) {
    return 2;
  }
  char v9 = v8;
  uint64_t v10 = *(void *)(a1 + 32);
  if (!v10)
  {
    sub_10004D2C8(v9);
    return 2;
  }
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a4);
  sub_10004D2C8(v9);
  uint64_t result = 2;
  if (v11)
  {
    uint64_t v13 = a1 + 4 * a2;
    *(_DWORD *)(v13 + 52) = 2;
    unint64_t v14 = (_DWORD *)(v13 + 52);
    char v15 = *(std::__shared_weak_count **)(a1 + 40);
    if (v15)
    {
      long long v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)(a1 + 32);
        if (v18) {
          (*(void (**)(uint64_t, const char *))(*(void *)v18 + 48))(v18, "FSM: exiting Pushing");
        }
        sub_10004D2C8(v17);
      }
    }
    *unint64_t v14 = 2;
    sub_1006EA190(a4, a1);
    uint64_t result = 1;
    *unint64_t v14 = 1;
  }
  return result;
}

void sub_1006EA178(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1006EA190(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 40);
  if (v3)
  {
    char v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a2 + 32);
      if (v7)
      {
        sub_1006E9958(a2 + 8, (const void **)a1);
        *(unsigned char *)(a2 + 24) = *(unsigned char *)(a1 + 8);
        (*(void (**)(uint64_t, const char *))(*(void *)v7 + 48))(v7, "FSM: entered WaitToPush");
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1006EA240(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EA254(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v5) {
    return 2;
  }
  uint64_t v8 = std::__shared_weak_count::lock(v5);
  if (!v8) {
    return 2;
  }
  char v9 = v8;
  uint64_t v10 = *(void *)(a1 + 32);
  if (!v10)
  {
    sub_10004D2C8(v9);
    return 2;
  }
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a4);
  sub_10004D2C8(v9);
  if (!v11) {
    return 2;
  }
  uint64_t v12 = a1 + 4 * a2;
  uint64_t v13 = 1;
  *(_DWORD *)(v12 + 52) = 1;
  sub_1006EA190(a4, a1);
  *(_DWORD *)(v12 + 52) = 1;
  return v13;
}

void sub_1006EA338(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EA34C(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v5);
    if (v8)
    {
      char v9 = v8;
      uint64_t v10 = *(void *)(a1 + 32);
      if (v10)
      {
        int v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a4);
        sub_10004D2C8(v9);
        if (v11)
        {
          uint64_t v12 = a1 + 4 * a2;
          *(_DWORD *)(v12 + 52) = 0;
          sub_1006EA190(a4, a1);
          uint64_t result = 1;
          *(_DWORD *)(v12 + 52) = 1;
          return result;
        }
      }
      else
      {
        sub_10004D2C8(v9);
      }
    }
  }
  return 2;
}

void sub_1006EA428(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EA43C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112))
  {
    sub_1000F0058((uint64_t)v7, a2);
    sub_1000F0058((uint64_t)&v16, (uint64_t)v7);
    sub_1000F0058((uint64_t)&v20, (uint64_t)&v16);
    sub_1000F0058((uint64_t)&v24, (uint64_t)&v20);
    v28[0].__vftable = (std::exception_vtbl *)a1;
    sub_1000F0058((uint64_t)&v28[1], (uint64_t)&v24);
    sub_10003B34C(&v24);
    char v31 = 5;
    sub_10003B34C(&v20);
    *(void *)&long long v8 = sub_1006EA43C;
    *((void *)&v8 + 1) = 0;
    char v9 = v28[0].__vftable;
    sub_1000F0058((uint64_t)v10, (uint64_t)&v28[1]);
    char v11 = v31;
    sub_10003B34C(&v28[1].__vftable);
    sub_10003B34C(&v16);
    long long v12 = v8;
    uint64_t v13 = v9;
    sub_1000F0058((uint64_t)v14, (uint64_t)v10);
    char v15 = v11;
    long long v16 = v12;
    uint64_t v17 = v13;
    sub_1000F0058((uint64_t)v18, (uint64_t)v14);
    char v19 = v15;
    long long v20 = v16;
    uint64_t v21 = v17;
    sub_1000F0058((uint64_t)v22, (uint64_t)v18);
    char v23 = v19;
    long long v24 = v20;
    char v25 = v21;
    sub_1000F0058((uint64_t)v26, (uint64_t)v22);
    char v27 = v23;
    *(_OWORD *)&v28[0].__vftable = v24;
    uint64_t v29 = v25;
    sub_1000F0058((uint64_t)&v30, (uint64_t)v26);
    char v32 = v27;
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 21])(a1, 0);
  std::exception::~exception(v28);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006EA8A0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        sub_10003B34C((void *)(*(void *)a2 + 24));
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_12pushSettingsEhEENS0"
                                        "_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_12pushSettingsEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_1006EA9CC()
{
}

uint64_t sub_1006EAA04(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006EAA38()
{
  return 0;
}

uint64_t sub_1006EAA40(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 800, "state == (current_state)");
  }
  return 1;
}

uint64_t sub_1006EAA7C(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v5 = a1 + 4 * a2;
  *(_DWORD *)(v5 + 52) = 1;
  uint64_t v6 = (_DWORD *)(v5 + 52);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 40);
  if (v7)
  {
    char v9 = std::__shared_weak_count::lock(v7);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 32);
      if (v11)
      {
        LOBYTE(v18) = 0;
        char v19 = 0;
        if (*(unsigned char *)(a1 + 16))
        {
          sub_100058198(&v18, (const void **)(a1 + 8));
          char v19 = 1;
        }
        int v12 = *(unsigned __int8 *)(a1 + 24);
        sub_1000F0058((uint64_t)v20, a4);
        (*(void (**)(uint64_t, const void **, BOOL, void *))(*(void *)v11 + 16))(v11, &v18, v12 != 0, v20);
        sub_10003B34C(v20);
        if (v19) {
          sub_100057D78(&v18);
        }
      }
      sub_10004D2C8(v10);
    }
    uint64_t v13 = *(std::__shared_weak_count **)(a1 + 40);
    *uint64_t v6 = 1;
    if (v13)
    {
      unint64_t v14 = std::__shared_weak_count::lock(v13);
      if (v14)
      {
        char v15 = v14;
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16) {
          (*(void (**)(uint64_t, const char *))(*(void *)v16 + 48))(v16, "FSM: entered Pushing via pushSettings");
        }
        sub_10004D2C8(v15);
      }
    }
  }
  else
  {
    *uint64_t v6 = 1;
  }
  *uint64_t v6 = 2;
  return 1;
}

void sub_1006EAC2C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EAC68(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112)) {
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 25])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006EADE0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_10setBBReadyEhEENS0_5"
                                        "list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_10setBBReadyEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006EAEEC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006EAF20()
{
  return 0;
}

uint64_t sub_1006EAF28(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112)) {
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 29])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006EB0A0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_5resetEhEENS0_5list3I"
                                        "NS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_5resetEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006EB1AC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006EB1E0()
{
  return 0;
}

uint64_t sub_1006EB1E8(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 2;
  uint64_t v5 = (_DWORD *)(v4 + 52);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v6) {
    goto LABEL_21;
  }
  std::exception v7 = std::__shared_weak_count::lock(v6);
  if (v7)
  {
    long long v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      (*(void (**)(uint64_t, const char *))(*(void *)v9 + 48))(v9, "FSM: exiting Pushing");
    }
    sub_10004D2C8(v8);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 40);
  *uint64_t v5 = 2;
  if (v10)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      int v12 = v11;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        (*(void (**)(void, const char *))(*(void *)v13 + 48))(*(void *)(a1 + 32), "FSM: handling Failure");
        if (!*(unsigned char *)(a1 + 48))
        {
          *(unsigned char *)(a1 + 48) = 1;
          sub_1006EB3D4((uint64_t)&event::activation::resetRequest, "Resetting baseband after Failure to Push");
        }
        if (*(unsigned char *)(a1 + 16))
        {
          sub_100057D78((const void **)(a1 + 8));
          *(unsigned char *)(a1 + 16) = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
      }
      sub_10004D2C8(v12);
    }
    unint64_t v14 = *(std::__shared_weak_count **)(a1 + 40);
    *uint64_t v5 = 2;
    if (v14)
    {
      char v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          (*(void (**)(uint64_t, const char *))(*(void *)v17 + 48))(v17, "FSM: entered Idle");
        }
        sub_10004D2C8(v16);
      }
    }
  }
  else
  {
LABEL_21:
    *uint64_t v5 = 2;
  }
  *uint64_t v5 = 0;
  return 1;
}

void sub_1006EB3B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1006EB3D4(uint64_t a1, const char *a2)
{
  sub_1006EB41C((uint64_t *)(a1 + 24), a2);
  uint64_t v4 = (uint64_t *)sub_1006EB5C4((uint64_t *)(a1 + 8));

  return sub_1006EB608(v4, (uint64_t)a2);
}

uint64_t sub_1006EB41C(uint64_t *a1, const char *a2)
{
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  memset(v8, 0, sizeof(v8));
  sub_10004DE24((uint64_t)v8);
  size_t v4 = strlen(a2);
  sub_10004B96C(v8, (uint64_t)a2, v4);
  sub_10004BC98((uint64_t)v8 + 8, __p);
  sub_1001AA668(a1, (uint64_t *)__p);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1006EB5AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EB5C4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_1006EB608(uint64_t *a1, uint64_t a2)
{
  uint64_t v24 = a2;
  long long v23 = 0uLL;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v3 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v27, v3);
  uint64_t v4 = a1[1];
  if (v4)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) == 1) {
      sub_1006EB884(a1, &v27, 0, 1);
    }
    uint64_t v5 = *a1;
    uint64_t v6 = a1[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = *a1;
  }
  long long v7 = v23;
  *(void *)&long long v23 = v5;
  *((void *)&v23 + 1) = v6;
  v26[0] = v7;
  sub_10000A740((atomic_uint **)v26 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v38 + 1));
  sub_10000A5F8(&v27);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  uint64_t v42 = 0;
  uint64_t v43 = 10;
  long long v44 = (char *)&v27 + 8;
  uint64_t v45 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  char v46 = &v24;
  long long v8 = (uint64_t *)sub_1006EB938((uint64_t *)&v23);
  v22[0] = &v27;
  v22[1] = a1;
  CFTypeRef v22[2] = sub_1006EBBA8(v8);
  uint64_t v9 = sub_1006EB938((uint64_t *)&v23);
  uint64_t v10 = sub_100060EA8((uint64_t *)(v9 + 16));
  long long v11 = (uint64_t *)sub_1006EB938((uint64_t *)&v23);
  uint64_t v12 = *(void *)(sub_1006EBBA8(v11) + 8);
  long long v13 = (uint64_t *)sub_1006EB938((uint64_t *)&v23);
  *(void *)&long long v20 = v12;
  *((void *)&v20 + 1) = sub_1006EBBA8(v13);
  *(void *)&long long v21 = &v27;
  *((void *)&v21 + 1) = *((void *)&v20 + 1);
  sub_1006EBE0C((uint64_t *)&v20);
  long long v14 = (uint64_t *)sub_1006EB938((uint64_t *)&v23);
  uint64_t v15 = sub_1006EBBA8(v14);
  long long v16 = (uint64_t *)sub_1006EB938((uint64_t *)&v23);
  *(void *)&long long v18 = v15;
  *((void *)&v18 + 1) = sub_1006EBBA8(v16);
  *(void *)&long long v19 = &v27;
  *((void *)&v19 + 1) = *((void *)&v18 + 1);
  sub_1006EBE0C((uint64_t *)&v18);
  v26[0] = v20;
  v26[1] = v21;
  v25[0] = v18;
  v25[1] = v19;
  sub_1006EBBEC(v10, (uint64_t *)v26, v25);
  sub_1006EC1CC((uint64_t)v22);
  sub_1006ECAA4((uint64_t)&v27);
  return sub_10000A740((atomic_uint **)&v23 + 1);
}

void sub_1006EB830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t *sub_1006EB884(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_1006EB938(a1);
  uint64_t v10 = sub_1006EBBA8(v9);
  long long v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_1006EB938(a1);
    long long v11 = *(uint64_t **)(sub_1006EBBA8(v12) + 8);
  }
  long long v14 = v11;
  return sub_1006EB97C(a1, a2, a3, &v14, a4);
}

uint64_t sub_1006EB938(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1006EB97C(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_1006EB938(a1);
  uint64_t result = (uint64_t *)sub_1006EBBA8(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_1006EBAB8(result + 2);
        sub_1006EBAFC(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_1006EBAB8(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        long long v16 = (uint64_t *)sub_1006EB938(a1);
        uint64_t v17 = sub_1006EBBA8(v16);
        uint64_t v18 = sub_1006EBAB8(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_1006EB938(a1);
      long long v20 = (uint64_t *)sub_1006EBBA8(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_1006EBAB8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1006EBAFC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_1006EBB64(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1006EBB64(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_1006EBBA8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1006EBBEC(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_1006EBC6C(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_1006EBE0C(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      *uint64_t v5 = 0;
    }
  }
}

unsigned char *sub_1006EBC6C(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_1006EBD28((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      *uint64_t v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_1006EBD28(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_1006EBAB8(a2);
  uint64_t v3 = (void *)(sub_1006EBB64((uint64_t *)(v2 + 32)) + 24);

  return sub_1006EBD74(v3);
}

uint64_t sub_1006EBD74(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_1006EBDF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_1006EBE0C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_1006EC068(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_1006EBAB8((uint64_t *)(*a1 + 16));
      sub_1006EC0AC(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_1006EBAB8((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 280);
      }
      else {
        ++*(_DWORD *)(v7 + 284);
      }
      uint64_t v8 = sub_1006EBAB8((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AB328(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_1006EC068((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AB328(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_1006EC02C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006EC068(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_1006EC0AC(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (unint64_t i = *(atomic_uint **)sub_1006EBB64((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1006EBB64(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_1006EC1A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EC1CC(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 284) > *(_DWORD *)(*(void *)a1 + 280)) {
    sub_1006EC210(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_1006EC210(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_1006EB938(a1);
  if (sub_1006EBBA8(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_1006EB938(a1);
    uint64_t v8 = *(uint64_t **)(sub_1006EBBA8(v7) + 8);
    sub_1006EB97C(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_1006EC35C()
{
}

void sub_1006EC3B0(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_1006EC470(&v2, a2);
}

uint64_t sub_1006EC42C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1006EC470(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1006EC4DC(&v2);
}

void sub_1006EC4C8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1006EC4DC(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1006EC54C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_1006EC560(_Unwind_Exception *a1)
{
}

void sub_1006EC578()
{
}

uint64_t sub_1006EC58C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1006EC5F0()
{
  return 0;
}

uint64_t sub_1006EC5F8()
{
  return 0;
}

uint64_t sub_1006EC600()
{
  return 0;
}

void sub_1006EC608()
{
}

void sub_1006EC684()
{
}

uint64_t sub_1006EC6A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1006EC834((uint64_t *)a1, a2);
  sub_1006EC8A0((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      _OWORD v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      long long v10 = (void *)v5[1];
      uint64_t v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          long long v16 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      long long v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          long long v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          long long v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1006EC80C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006EC834(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_1006EC88C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006EC8A0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1006EC8F0(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1006EC908(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1006EC974(&v2);
}

void sub_1006EC960(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1006EC974(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1006EC9E4(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1006EC9F8(_Unwind_Exception *a1)
{
}

void sub_1006ECA10()
{
}

uint64_t sub_1006ECA24(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1006ECA8C()
{
  return 0;
}

uint64_t sub_1006ECA94()
{
  return 0;
}

uint64_t sub_1006ECA9C()
{
  return 0;
}

uint64_t sub_1006ECAA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_1006ECB78(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006ECB98(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112)) {
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 33])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006ECD10(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_10pushFailedEhEENS0_5"
                                        "list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_10pushFailedEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006ECE1C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006ECE50()
{
  return 0;
}

uint64_t sub_1006ECE58(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 2;
  uint64_t v5 = (_DWORD *)(v4 + 52);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v6) {
    goto LABEL_21;
  }
  std::exception v7 = std::__shared_weak_count::lock(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      (*(void (**)(uint64_t, const char *))(*(void *)v9 + 48))(v9, "FSM: exiting Pushing");
    }
    sub_10004D2C8(v8);
  }
  long long v10 = *(std::__shared_weak_count **)(a1 + 40);
  *uint64_t v5 = 2;
  if (v10)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        (*(void (**)(void, const char *))(*(void *)v13 + 48))(*(void *)(a1 + 32), "FSM: handling Failure");
        if (!*(unsigned char *)(a1 + 48))
        {
          *(unsigned char *)(a1 + 48) = 1;
          sub_1006EB3D4((uint64_t)&event::activation::resetRequest, "Resetting baseband after Failure to Push");
        }
        if (*(unsigned char *)(a1 + 16))
        {
          sub_100057D78((const void **)(a1 + 8));
          *(unsigned char *)(a1 + 16) = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
      }
      sub_10004D2C8(v12);
    }
    BOOL v14 = *(std::__shared_weak_count **)(a1 + 40);
    *uint64_t v5 = 2;
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        long long v16 = v15;
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          (*(void (**)(uint64_t, const char *))(*(void *)v17 + 48))(v17, "FSM: entered Idle");
        }
        sub_10004D2C8(v16);
      }
    }
  }
  else
  {
LABEL_21:
    *uint64_t v5 = 2;
  }
  *uint64_t v5 = 0;
  return 1;
}

void sub_1006ED028(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006ED044(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112)) {
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 37])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006ED1BC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_19pushFailedSkipReset"
                                        "EhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_19pushFailedSkipResetEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006ED2C8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006ED2FC()
{
  return 0;
}

uint64_t sub_1006ED304(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 2;
  uint64_t v5 = (_DWORD *)(v4 + 52);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v6) {
    goto LABEL_19;
  }
  std::exception v7 = std::__shared_weak_count::lock(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      (*(void (**)(uint64_t, const char *))(*(void *)v9 + 48))(v9, "FSM: exiting Pushing");
    }
    sub_10004D2C8(v8);
  }
  long long v10 = *(std::__shared_weak_count **)(a1 + 40);
  *uint64_t v5 = 2;
  if (v10)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        (*(void (**)(void, const char *))(*(void *)v13 + 48))(*(void *)(a1 + 32), "FSM: handling Push Failure without resetting");
        if (*(unsigned char *)(a1 + 16))
        {
          sub_100057D78((const void **)(a1 + 8));
          *(unsigned char *)(a1 + 16) = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
      }
      sub_10004D2C8(v12);
    }
    BOOL v14 = *(std::__shared_weak_count **)(a1 + 40);
    *uint64_t v5 = 2;
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        long long v16 = v15;
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          (*(void (**)(uint64_t, const char *))(*(void *)v17 + 48))(v17, "FSM: entered Idle");
        }
        sub_10004D2C8(v16);
      }
    }
  }
  else
  {
LABEL_19:
    *uint64_t v5 = 2;
  }
  *uint64_t v5 = 0;
  return 1;
}

void sub_1006ED4B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006ED4CC(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 112)) {
    operator new();
  }
  *(unsigned char *)(a1 + 112) = 1;
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))qword_101B0D3D0[*(_DWORD *)(a1 + 52) + 41])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 112) = 0;
  if ((a3 & 6) == 0) {
    sub_1006E96D4((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1006ED644(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "I19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_12pushCompleteEhEENS0"
                                        "_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineI19AttachApn_FSM_FrontNS_9parameter5void_ESA_SA_SA_EERKNS8_12pushCompleteEhEENS0_5list3INS0_5valueIPSB_EENSH_ISC_EENSH_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1006ED750(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1006ED784()
{
  return 0;
}

uint64_t sub_1006ED78C(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 52) = 2;
  uint64_t v5 = (_DWORD *)(v4 + 52);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v6) {
    goto LABEL_18;
  }
  std::exception v7 = std::__shared_weak_count::lock(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      (*(void (**)(uint64_t, const char *))(*(void *)v9 + 48))(v9, "FSM: exiting Pushing");
    }
    sub_10004D2C8(v8);
  }
  long long v10 = *(std::__shared_weak_count **)(a1 + 40);
  *uint64_t v5 = 2;
  if (v10)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        sub_100058198(&v19, (const void **)(a1 + 8));
        (*(void (**)(uint64_t, const void **))(*(void *)v13 + 24))(v13, &v19);
        sub_100057D78(&v19);
        if (*(unsigned char *)(a1 + 16))
        {
          sub_100057D78((const void **)(a1 + 8));
          *(unsigned char *)(a1 + 16) = 0;
        }
      }
      sub_10004D2C8(v12);
    }
    BOOL v14 = *(std::__shared_weak_count **)(a1 + 40);
    *uint64_t v5 = 2;
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        long long v16 = v15;
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          (*(void (**)(uint64_t, const char *))(*(void *)v17 + 48))(v17, "FSM: entered Idle");
        }
        sub_10004D2C8(v16);
      }
    }
  }
  else
  {
LABEL_18:
    *uint64_t v5 = 2;
  }
  *uint64_t v5 = 0;
  return 1;
}

void sub_1006ED934(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1006ED95C(const void **a1)
{
  if (a1)
  {
    sub_1006ED95C(*a1);
    sub_1006ED95C(a1[1]);
    sub_1000558F4(a1 + 5);
    sub_1000558F4(a1 + 4);
    operator delete(a1);
  }
}

void sub_1006ED9BC()
{
  if ((byte_101B0D3D8 & 1) == 0)
  {
    byte_101B0D3D8 = 1;
    qword_101B0D448 = (uint64_t)sub_1006E97AC;
    qword_101B0D440 = (uint64_t)sub_1006E99A0;
    qword_101B0D438 = (uint64_t)sub_1006E9A08;
  }
}

void sub_1006EDA0C()
{
  if ((byte_101B0D3E0 & 1) == 0)
  {
    byte_101B0D3E0 = 1;
    qword_101B0D468 = (uint64_t)sub_1006EA03C;
    qword_101B0D460 = (uint64_t)sub_1006EA254;
    qword_101B0D458 = (uint64_t)sub_1006EA34C;
  }
}

void sub_1006EDA5C()
{
  if ((byte_101B0D3E8 & 1) == 0)
  {
    byte_101B0D3E8 = 1;
    qword_101B0D478 = (uint64_t)sub_1006EAA38;
    qword_101B0D488 = (uint64_t)sub_1006EAA40;
    qword_101B0D480 = (uint64_t)sub_1006EAA7C;
  }
}

void sub_1006EDAAC()
{
  if ((byte_101B0D3F0 & 1) == 0)
  {
    byte_101B0D3F0 = 1;
    qword_101B0D4A0 = (uint64_t)sub_1006EAF20;
    unk_101B0D4A8 = sub_1006EAF20;
    qword_101B0D498 = (uint64_t)sub_1006EAF20;
  }
}

void sub_1006EDAE0()
{
  if ((byte_101B0D3F8 & 1) == 0)
  {
    byte_101B0D3F8 = 1;
    qword_101B0D4B8 = (uint64_t)sub_1006EB1E0;
    unk_101B0D4C0 = sub_1006EB1E0;
    qword_101B0D4C8 = (uint64_t)sub_1006EB1E8;
  }
}

void sub_1006EDB20()
{
  if ((byte_101B0D400 & 1) == 0)
  {
    byte_101B0D400 = 1;
    qword_101B0D4D8 = (uint64_t)sub_1006ECE50;
    unk_101B0D4E0 = sub_1006ECE50;
    qword_101B0D4E8 = (uint64_t)sub_1006ECE58;
  }
}

void sub_1006EDB60()
{
  if ((byte_101B0D408 & 1) == 0)
  {
    byte_101B0D408 = 1;
    qword_101B0D4F8 = (uint64_t)sub_1006ED2FC;
    unk_101B0D500 = sub_1006ED2FC;
    qword_101B0D508 = (uint64_t)sub_1006ED304;
  }
}

void sub_1006EDBA0()
{
  if ((byte_101B0D410 & 1) == 0)
  {
    byte_101B0D410 = 1;
    qword_101B0D518 = (uint64_t)sub_1006ED784;
    unk_101B0D520 = sub_1006ED784;
    qword_101B0D528 = (uint64_t)sub_1006ED78C;
  }
}

id sub_1006EE040(uint64_t a1, uint64_t a2)
{
  return +[XMLParser copyDictionaryForXMLData:a1 error:a2];
}

void sub_1006EE1BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  _Unwind_Resume(a1);
}

void sub_1006EE4A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, dispatch_object_t object)
{
}

void sub_1006EE62C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
}

id sub_1006EE674(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "registerForRestProperties_sync");
}

void sub_1006EE6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1006EEDD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  sub_10003F600(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1006EF828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,const void *a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,const void *a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,uint64_t a47,const void *a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  sub_1000558F4(&a48);
  if (a54 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }

  sub_1000558F4(&a33);
  sub_1000558F4(&a38);
  if (a44 < 0) {
    operator delete(a39);
  }

  _Unwind_Resume(a1);
}

void sub_1006F0B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,int a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,uint64_t a60,void *a61,void *a62,uint64_t a63)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a22);
  }
  if (a67 < 0) {
    operator delete(a62);
  }

  sub_1006F0FA4((uint64_t)&a72);
  sub_100706DDC((uint64_t)&STACK[0x270], (const void **)STACK[0x278]);

  _Unwind_Resume(a1);
}

uint64_t sub_1006F0E90(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v4 = a1 + 112;
  sub_10023C008(a1 + 8, a2 + 8);
  if (*(char *)(a2 + 135) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 112);
    *(void *)(v4 + 16) = *(void *)(a2 + 128);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  uint64_t v6 = (unsigned char *)(a1 + 144);
  if (*(char *)(a2 + 167) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 144), *(void *)(a2 + 152));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  return a1;
}

void sub_1006F0F40(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 111) < 0) {
    operator delete(*(void **)(v1 + 88));
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*(void **)(v1 + 56));
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*(void **)(v1 + 32));
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006F0FA4(uint64_t a1)
{
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1006F121C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006F173C(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1006F1854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006F1C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t a11, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006F4648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t object,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,uint64_t a31,xpc_object_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,xpc_object_t a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,xpc_object_t a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  xpc_release(v57);
  xpc_release(object);
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a57 < 0) {
    operator delete(a52);
  }

  if (*(char *)(v60 - 225) < 0) {
    operator delete(*(void **)(v60 - 248));
  }
  if (*(char *)(v60 - 201) < 0) {
    operator delete(*(void **)(v60 - 224));
  }

  _Unwind_Resume(a1);
}

void sub_1006F537C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10)
{
}

void sub_1006F59B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  long long v31 = *(std::__shared_weak_count **)(v29 - 112);
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (*(char *)(v29 - 81) < 0) {
    operator delete(*(void **)(v29 - 104));
  }
  if (*(char *)(v26 + 23) < 0) {
    operator delete(*(void **)v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006F5DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006F6054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t a18, xpc_object_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1006F8C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,xpc_object_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  if (SLOBYTE(STACK[0x28F]) < 0) {
    operator delete((void *)STACK[0x278]);
  }
  xpc_release((xpc_object_t)STACK[0x2A8]);

  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }

  if (SLOBYTE(STACK[0x2DF]) < 0) {
    operator delete((void *)STACK[0x2C8]);
  }
  xpc_release((xpc_object_t)STACK[0x2E0]);
  xpc_release(a45);
  STACK[0x308] = (unint64_t)&STACK[0x2E8];
  sub_1001F1FAC((void ***)&STACK[0x308]);
  _Unwind_Resume(a1);
}

void sub_1006F9738(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 56) + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = a1 + 32;
      if (*(char *)(a1 + 55) < 0) {
        uint64_t v5 = *(void *)(a1 + 32);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = [v3 code];
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Adding incoming call %s failed due to error %ld", buf, 0x16u);
    }
    if ([v3 code] == (id)3 || objc_msgSend(v3, "code") == (id)4)
    {
      *(_OWORD *)uint64_t v8 = 0u;
      long long v9 = 0u;
      std::string::operator=((std::string *)v8, (const std::string *)(a1 + 32));
      BYTE8(v9) = [v3 code] == (id)3;
      BYTE9(v9) = [v3 code] == (id)4;
      id v6 = *(id *)(a1 + 56);
      xpc_object_t v13 = 0;
      write_rest_value();
      sub_100058DB0(&__p, "/cc/requests/send_to_voicemail");
      xpc_object_t object = v13;
      xpc_object_t v13 = xpc_null_create();
      id v7 = v6;
      *(void *)long long buf = off_1019FD0C0;
      *(void *)&uint8_t buf[8] = v7;
      uint64_t v15 = buf;
      ctu::RestModule::sendRequest();
      sub_10003F600(buf);
      xpc_release(object);
      xpc_object_t object = 0;
      if (v12 < 0) {
        operator delete(__p);
      }
      xpc_release(v13);

      if (SBYTE7(v9) < 0) {
        operator delete(v8[0]);
      }
    }
  }
}

void sub_1006F9948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24,char a25)
{
  _Unwind_Resume(a1);
}

id sub_1006F99E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 32;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(v4 + 16) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v4 = v5;
  }
  id result = *(id *)(a2 + 56);
  *(void *)(a1 + 56) = result;
  return result;
}

void sub_1006F9A44(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    operator delete(v2);
  }
}

uint64_t sub_1006F9A94(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

id *sub_1006F9AD0(id *a1)
{
  xpc_release(a1[2]);
  a1[2] = 0;
  xpc_release(a1[1]);
  a1[1] = 0;

  return a1;
}

void sub_1006F9C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  *(void *)(v2 - 24) = va;
  sub_100702C2C((void ***)(v2 - 24));
  sub_100087E24((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1006FA19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  sub_1000577C4(&a10);
  sub_1000577C4(&a11);
  sub_1000577C4(&a12);
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a16)
  {
    a17 = (uint64_t)a16;
    operator delete(a16);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(a1);
}

void sub_1006FA9F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,uint64_t a22,xpc_object_t a23,xpc_object_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,xpc_object_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006FAF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, char *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  long long __p = &a18;
  sub_100047F64((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1006FB55C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  a17 = &a20;
  sub_100702E5C((void ***)&a17);

  _Unwind_Resume(a1);
}

void sub_1006FB874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, xpc_object_t object, char a14)
{
  char v18 = v14;

  sub_100030068(&a12);
  xpc_release(object);
  sub_1006FB8F8((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1006FB8F8(uint64_t a1)
{
  *(void *)(a1 + 24) = 0;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1006FBBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

void sub_1006FC1B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1006FC268(uint64_t a1, void *a2)
{
  id v3 = a2;
  __s1 = 0;
  size_t __n = 0;
  uint64_t v19 = 0;
  uint64_t v4 = [v3 UUID];
  sub_100848F68(v4, &__s1);

  uint64_t v5 = HIBYTE(v19);
  char v6 = HIBYTE(v19);
  if (v19 >= 0) {
    size_t v7 = HIBYTE(v19);
  }
  else {
    size_t v7 = __n;
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 63);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 48);
  }
  if (v7 != v8) {
    goto LABEL_22;
  }
  if (v9 >= 0) {
    long long v10 = (unsigned __int8 *)(a1 + 40);
  }
  else {
    long long v10 = *(unsigned __int8 **)(a1 + 40);
  }
  if (SHIBYTE(v19) < 0)
  {
    char v12 = __s1;
    if (memcmp(__s1, v10, __n))
    {
LABEL_24:
      operator delete(v12);
      goto LABEL_25;
    }
    goto LABEL_17;
  }
  if (!HIBYTE(v19))
  {
LABEL_17:
    xpc_object_t v13 = **(NSObject ***)(*(void *)(a1 + 32) + 8);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = [v3 UUID];
      uint64_t v15 = (void *)v14;
      long long v16 = *(uint64_t **)(a1 + 64);
      if (*((char *)v16 + 23) < 0) {
        long long v16 = (uint64_t *)*v16;
      }
      *(_DWORD *)long long buf = 138412546;
      uint64_t v21 = v14;
      __int16 v22 = 2080;
      long long v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I **** Action %@ failed with call %s! ****", buf, 0x16u);
    }
    [v3 fail];
    char v6 = HIBYTE(v19);
    goto LABEL_22;
  }
  p_s1 = &__s1;
  while (*(unsigned __int8 *)p_s1 == *v10)
  {
    p_s1 = (void **)((char *)p_s1 + 1);
    ++v10;
    if (!--v5) {
      goto LABEL_17;
    }
  }
LABEL_22:
  if (v6 < 0)
  {
    char v12 = __s1;
    goto LABEL_24;
  }
LABEL_25:
}

void sub_1006FC40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1006FC560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006FC6F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006FD1BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,xpc_object_t a31,xpc_object_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,xpc_object_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,xpc_object_t object,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (*(unsigned char *)(v50 - 136) && *(char *)(v50 - 137) < 0) {
    operator delete(*(void **)(v50 - 160));
  }

  if (a50 < 0) {
    operator delete(__p);
  }
  *(void *)(v50 - 160) = v50 - 216;
  sub_1001F1FAC((void ***)(v50 - 160));
  _Unwind_Resume(a1);
}

void sub_1006FD614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006FE458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  STACK[0x230] = (unint64_t)&a64;
  sub_10070345C((void ***)&STACK[0x230]);

  _Unwind_Resume(a1);
}

uint64_t sub_1006FE7FC(void ***a1, void **a2)
{
  char v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    uint64_t v10 = (uint64_t)(v7 - (void)*a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      sub_10006A748();
    }
    uint64_t v11 = (char *)v5 - (char *)*a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v26 = v4;
    if (v13) {
      uint64_t v14 = (char *)sub_10004EF74(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = (void **)&v14[8 * v10];
    long long v16 = (void **)&v14[8 * v13];
    long long v25 = v16;
    sub_100454C2C(v15, a2);
    int v9 = v15 + 1;
    v24.i64[1] = (uint64_t)(v15 + 1);
    char v18 = *a1;
    unint64_t v17 = (unint64_t)a1[1];
    if ((void **)v17 == *a1)
    {
      int64x2_t v21 = vdupq_n_s64(v17);
    }
    else
    {
      unint64_t v19 = (unint64_t)a1[1];
      do
      {
        long long v20 = *(void **)(v19 - 8);
        v19 -= 8;
        *--uint64_t v15 = v20;
        *(void *)(v17 - 8) = xpc_null_create();
        unint64_t v17 = v19;
      }
      while ((void **)v19 != v18);
      int64x2_t v21 = *(int64x2_t *)a1;
      int v9 = (void **)v24.i64[1];
      long long v16 = v25;
    }
    *a1 = v15;
    a1[1] = v9;
    int64x2_t v24 = v21;
    __int16 v22 = a1[2];
    a1[2] = v16;
    long long v25 = v22;
    uint64_t v23 = v21.i64[0];
    uint64_t result = sub_1007031C4((uint64_t)&v23);
  }
  else
  {
    uint64_t result = (uint64_t)sub_100454C2C(*(void ***)(v4 - 8), a2);
    int v9 = (void **)(v7 + 8);
  }
  a1[1] = v9;
  return result;
}

uint64_t sub_1006FE934(uint64_t a1)
{
  id v3 = (void **)(a1 + 24);
  sub_10070345C(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1006FEF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t object,uint64_t a28,xpc_object_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,xpc_object_t a36,char a37)
{
  _Unwind_Resume(a1);
}

void sub_1006FF3DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006FF6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  _Unwind_Resume(a1);
}

void sub_1006FF924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006FFB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006FFDA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100700044(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100700280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007004B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100700B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100700F30(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100701308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25,xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100701548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007016F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100701904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100701E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,xpc_object_t a25,xpc_object_t object,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100702260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10070252C(xpc_object_t **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    id v3 = a1[1];
    char v4 = *a1;
    if (v3 != v1)
    {
      do
        sub_1001F1F7C(--v3);
      while (v3 != v1);
      char v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void **sub_100702594(void **a1, void **a2)
{
  id v3 = *a2;
  *a1 = *a2;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

uint64_t sub_1007025D8(uint64_t a1)
{
  return a1;
}

void sub_100702604(uint64_t a1)
{
  operator delete();
}

void *sub_100702650(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_1019FD0C0;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1007026A8(uint64_t a1, void *a2)
{
  *a2 = off_1019FD0C0;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1007026F0(uint64_t a1)
{
}

void sub_1007026F8(id *a1)
{
  operator delete(a1);
}

void sub_100702734(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = "failed.";
    if (v4) {
      char v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sending to voicemail due to DND or Blocked %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070281C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070284C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD120)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070288C()
{
  return &off_1019FD120;
}

void sub_100702898(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  int v9 = *(void **)a1;
  if (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_100702A18((void **)a1);
    if (a4 > 0x1E1E1E1E1E1E1E1) {
      sub_10006A748();
    }
    unint64_t v10 = 0xE1E1E1E1E1E1E1E2 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0xF0F0F0F0F0F0F0) {
      unint64_t v11 = 0x1E1E1E1E1E1E1E1;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_1003A0BE0((void *)a1, v11);
    uint64_t v12 = sub_100702A80(v8, a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
    sub_100702B7C((uint64_t)&v17, a2, v13, (uint64_t)v9);
    uint64_t v12 = sub_100702A80(v8, v13, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_100702B7C((uint64_t)&v18, a2, a3, (uint64_t)v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 136;
      sub_100702B04(v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_100702A08(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100702A10(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100702A18(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    int v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 136;
        sub_100702B04(v3);
      }
      while ((void *)v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100702A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_10009DB3C(a4 + v7, a2 + v7);
      v7 += 136;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100702AE0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 136;
    do
    {
      sub_100702B04(v4 + v2);
      v2 -= 136;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100702B04(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t sub_100702B7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(void *)a4 = *(void *)v5;
    std::string::operator=((std::string *)(a4 + 8), (const std::string *)(v5 + 8));
    std::string::operator=((std::string *)(a4 + 32), (const std::string *)(v5 + 32));
    char v7 = *(unsigned char *)(v5 + 60);
    *(_DWORD *)(a4 + 56) = *(_DWORD *)(v5 + 56);
    *(unsigned char *)(a4 + 60) = v7;
    std::string::operator=((std::string *)(a4 + 64), (const std::string *)(v5 + 64));
    std::string::operator=((std::string *)(a4 + 88), (const std::string *)(v5 + 88));
    char v8 = *(unsigned char *)(v5 + 128);
    *(_OWORD *)(a4 + 112) = *(_OWORD *)(v5 + 112);
    *(unsigned char *)(a4 + 128) = v8;
    a4 += 136;
    v5 += 136;
  }
  while (v5 != v6);
  return v6;
}

void sub_100702C2C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 136;
        sub_100702B04(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_100702CB0(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10034235C(result, a4);
    id result = (void *)sub_100702D38((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100702D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100702E5C(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100702D38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100702DBC((char *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 56;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100702D98(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 56;
    do
    {
      sub_1000FECD4(v4 + v2);
      v2 -= 56;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100702DBC(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  uint64_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *((void *)__dst + 6) = *((void *)a2 + 6);
  return __dst;
}

void sub_100702E40(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100702E5C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        sub_1000FECD4(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100702EE0(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  char v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100341ECC(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[56 * v4];
  uint64_t v16 = &v10[56 * v9];
  sub_100703000(v14, a2);
  uint64_t v15 = v14 + 56;
  sub_1007030A0(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100703144((uint64_t)&v13);
  return v11;
}

void sub_100702FEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100703144((uint64_t)va);
  _Unwind_Resume(a1);
}

char *sub_100703000(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  unint64_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)unint64_t v5 = v6;
  }
  *((void *)__dst + 6) = *((void *)a2 + 6);
  return __dst;
}

void sub_100703084(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1007030A0(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 56;
      long long v6 = *(_OWORD *)(v3 - 56);
      *(void *)(v4 - 40) = *(void *)(v3 - 40);
      *(_OWORD *)(v4 - 56) = v6;
      *(void *)(v3 - 48) = 0;
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 56) = 0;
      long long v7 = *(_OWORD *)(v3 - 32);
      *(void *)(v4 - 16) = *(void *)(v3 - 16);
      *(_OWORD *)(v4 - 32) = v7;
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      v3 -= 56;
      v4 -= 56;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v8 = *result;
  uint64_t *result = v5;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100703144(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_1000FECD4(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100703194(xpc_object_t *a1)
{
  *a1 = 0;
}

uint64_t sub_1007031C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_100703194((xpc_object_t *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100703214(void ***a1, xpc_object_t *a2, xpc_object_t *a3, unint64_t a4)
{
  long long v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  uint64_t v9 = *a1;
  if (a4 <= (v8 - (uint64_t)*a1) >> 3)
  {
    unint64_t v15 = a1[1] - v9;
    if (v15 >= a4)
    {
      unint64_t v19 = sub_1007033E0(a2, a3, v9);
      for (uint64_t i = a1[1]; i != v19; sub_100703194(i))
        --i;
      a1[1] = v19;
    }
    else
    {
      uint64_t v16 = &a2[v15];
      sub_1007033E0(a2, v16, v9);
      char v17 = a1[1];
      if (v16 != a3)
      {
        char v18 = a1[1];
        do
        {
          sub_10070339C(v18++, v16++);
          ++v17;
        }
        while (v16 != a3);
      }
      a1[1] = v17;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v10 = a1[1];
      uint64_t v11 = *a1;
      if (v10 != v9)
      {
        do
          sub_100703194(--v10);
        while (v10 != v9);
        uint64_t v11 = *a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      sub_10006A748();
    }
    uint64_t v12 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v12 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    sub_10004EF30(a1, v13);
    uint64_t v14 = a1[1];
    while (v6 != a3)
      sub_10070339C(v14++, v6++);
    a1[1] = v14;
  }
}

void **sub_10070339C(void **a1, void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

void **sub_1007033E0(xpc_object_t *a1, xpc_object_t *a2, void **a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      xpc_object_t v6 = *v5;
      if (*v5) {
        xpc_retain(*v5);
      }
      else {
        xpc_object_t v6 = xpc_null_create();
      }
      long long v7 = *a3;
      *a3 = v6;
      xpc_release(v7);
      ++v5;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_10070345C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (xpc_object_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (xpc_object_t *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_100703194(--v4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1007034E0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 176;
        sub_100703564(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100703564(uint64_t a1)
{
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void sub_1007035FC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1007035FC(a1, *a2);
    sub_1007035FC(a1, a2[1]);
    sub_100703658((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100703658(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_1007036B8(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1007036B8(a1, *(void *)a2);
    sub_1007036B8(a1, *((void *)a2 + 1));
    uint64_t v4 = (void **)(a2 + 40);
    sub_100702C2C(&v4);
    operator delete(a2);
  }
}

void sub_100703718(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100703718(a1, *(void *)a2);
    sub_100703718(a1, *((void *)a2 + 1));
    uint64_t v4 = (void **)(a2 + 40);
    sub_100702E5C(&v4);
    operator delete(a2);
  }
}

void sub_100703778(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100703778(a1, *(void *)a2);
    sub_100703778(a1, *((void *)a2 + 1));
    uint64_t v4 = (void **)(a2 + 40);
    sub_100047F64(&v4);
    operator delete(a2);
  }
}

void sub_1007037D8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  *uint64_t v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

uint64_t sub_10070382C(uint64_t a1)
{
  return a1;
}

void sub_100703858(uint64_t a1)
{
  operator delete();
}

void *sub_1007038A4(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD140;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_1007038FC(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD140;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100703944(uint64_t a1)
{
}

void sub_10070394C(id *a1)
{
  operator delete(a1);
}

void sub_100703988(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  long long v5 = *(_OWORD *)v3;
  uint64_t v6 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_1001F299C(v3, a2);
  v7[0] = (void **)(*(void *)(a1 + 16) + 64);
  v7[1] = (void **)1;
  ctu::UnfairLock::lock((ctu::UnfairLock *)v7[0]);
  sub_100703AB0(*(void *)(a1 + 16) + 72, *(xpc_object_t **)(*(void *)(a1 + 16) + 96), *(xpc_object_t **)(*(void *)(a1 + 16) + 104), (uint64_t)(*(void *)(*(void *)(a1 + 16) + 104) - *(void *)(*(void *)(a1 + 16) + 96)) >> 3);
  sub_100056724((uint64_t)v7);
  [*(id *)(a1 + 16) handleCallStatusChangedWithOldCalls:&v5];
  objc_msgSend(*(id *)(a1 + 16), "checkBasebandAssertions", v5, v6);
  v7[0] = (void **)&v5;
  sub_1001F1FAC(v7);
}

void sub_100703A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  sub_100056724((uint64_t)&a12);
  *(void *)(v12 - 24) = &a9;
  sub_1001F1FAC((void ***)(v12 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100703A64(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD1A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100703AA4()
{
  return &off_1019FD1A0;
}

void sub_100703AB0(uint64_t a1, xpc_object_t *a2, xpc_object_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = *(void ***)a1;
  if (a4 <= (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)
  {
    unint64_t v13 = (uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 3;
    if (v13 >= a4)
    {
      sub_100703C14((uint64_t)&v21, a2, a3, v8);
      char v18 = v17;
      unint64_t v19 = *(xpc_object_t **)(a1 + 8);
      if (v19 != v17)
      {
        do
          sub_1001F1F7C(--v19);
        while (v19 != v18);
      }
      *(void *)(a1 + 8) = v18;
    }
    else
    {
      uint64_t v14 = &a2[v13];
      sub_100703C14((uint64_t)&v20, a2, v14, v8);
      uint64_t v15 = *(void *)(a1 + 8);
      if (v14 != a3)
      {
        uint64_t v16 = *(void ***)(a1 + 8);
        do
        {
          sub_1001F1F38(v16++, v14++);
          v15 += 8;
        }
        while (v14 != a3);
      }
      *(void *)(a1 + 8) = v15;
    }
  }
  else
  {
    sub_10070252C((xpc_object_t **)a1);
    if (a4 >> 61) {
      sub_10006A748();
    }
    uint64_t v9 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10004EF30((void *)a1, v11);
    uint64_t v12 = *(void ***)(a1 + 8);
    while (v6 != a3)
      sub_1001F1F38(v12++, v6++);
    *(void *)(a1 + 8) = v12;
  }
}

xpc_object_t *sub_100703C14(uint64_t a1, xpc_object_t *a2, xpc_object_t *a3, void **a4)
{
  long long v5 = a2;
  if (a2 != a3)
  {
    do
    {
      xpc_object_t v7 = *v5;
      if (*v5) {
        xpc_retain(*v5);
      }
      else {
        xpc_object_t v7 = xpc_null_create();
      }
      uint64_t v8 = *a4;
      *a4 = v7;
      xpc_release(v8);
      ++v5;
      ++a4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t sub_100703C98(uint64_t a1)
{
  return a1;
}

void sub_100703CC4(uint64_t a1)
{
  operator delete();
}

void *sub_100703D10(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD1C0;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100703D68(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD1C0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100703DB0(uint64_t a1)
{
}

void sub_100703DB8(id *a1)
{
  operator delete(a1);
}

void sub_100703DF4(uint64_t a1, xpc_object_t *a2)
{
  sub_1004556BC(*(void *)(a1 + 8), a2);
  [*(id *)(a1 + 16) handleCallCapabilitiesChanged];
}

uint64_t sub_100703E40(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD220)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100703E80()
{
  return &off_1019FD220;
}

uint64_t sub_100703E8C(uint64_t a1)
{
  return a1;
}

void sub_100703EB8(uint64_t a1)
{
  operator delete();
}

void *sub_100703F04(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD240;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100703F5C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD240;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100703FA4(uint64_t a1)
{
}

void sub_100703FAC(id *a1)
{
  operator delete(a1);
}

void sub_100703FE8(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v41 = 0;
  uint64_t v42 = 0;
  long long v40 = &v41;
  sub_1007044CC((uint64_t)&v40, a2);
  uint64_t v4 = (void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 8);
  long long v37 = *(uint64_t **)v3;
  long long v38 = (char *)v5;
  uint64_t v39 = *(void *)(v3 + 16);
  if (v39)
  {
    *(void *)(v5 + 16) = &v38;
    *(void *)uint64_t v3 = v4;
    *uint64_t v4 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    long long v37 = (uint64_t *)&v38;
  }
  xpc_object_t v7 = v40;
  uint64_t v6 = v41;
  long long v35 = v40;
  v36[0] = v41;
  v36[1] = v42;
  if (v42)
  {
    *((void *)v41 + 2) = v36;
    long long v40 = &v41;
    long long v41 = 0;
    uint64_t v42 = 0;
    if (v7 != v36)
    {
      do
      {
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        v55[0] = v7 + 4;
        uint64_t v8 = (std::string **)(sub_10008CC40((uint64_t **)v3, (int *)v7 + 8, (uint64_t)&unk_10144E20E, v55) + 5);
        if (v8 != &v52) {
          sub_10005CA3C((uint64_t)v8, v52, v53, 0xAAAAAAAAAAAAAAABLL * (((char *)v53 - (char *)v52) >> 3));
        }
        uint64_t v10 = (uint64_t)v7[5];
        uint64_t v9 = v7[6];
        while ((char *)v10 != v9)
        {
          uint64_t v51 = 0;
          long long v49 = 0u;
          long long v50 = 0u;
          *(_OWORD *)uint64_t v47 = 0u;
          *(_OWORD *)uint64_t v48 = 0u;
          long long v46 = 0u;
          memset(&v45, 0, sizeof(v45));
          sub_10009DB3C((uint64_t)&v45, v10);
          v55[0] = v7 + 4;
          unint64_t v11 = sub_10008CC40((uint64_t **)v3, (int *)v7 + 8, (uint64_t)&unk_10144E20E, v55);
          CSIPhoneNumber::getFullNumber((uint64_t *)__p, &v45);
          uint64_t v12 = v11[7];
          unint64_t v13 = v11[6];
          if (v13 >= v12)
          {
            uint64_t v15 = v11[5];
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v13 - v15);
            unint64_t v17 = v16 + 1;
            if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v12 - v15);
            if (2 * v18 > v17) {
              unint64_t v17 = 2 * v18;
            }
            if (v18 >= 0x555555555555555) {
              unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v19 = v17;
            }
            uint8_t v55[4] = v11 + 7;
            if (v19) {
              char v20 = sub_10004812C((uint64_t)(v11 + 7), v19);
            }
            else {
              char v20 = 0;
            }
            char v21 = &v20[6 * v16];
            v55[0] = v20;
            v55[1] = v21;
            v55[3] = &v20[6 * v19];
            long long v22 = *(_OWORD *)__p;
            *((void *)v21 + 2) = v44;
            *(_OWORD *)char v21 = v22;
            __p[1] = 0;
            uint64_t v44 = 0;
            __p[0] = 0;
            v55[2] = v21 + 6;
            sub_100048204((uint64_t *)v11 + 5, v55);
            uint64_t v23 = v11[6];
            sub_100048174((uint64_t)v55);
            int v24 = SHIBYTE(v44);
            v11[6] = v23;
            if (v24 < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            long long v14 = *(_OWORD *)__p;
            void v13[2] = v44;
            *(_OWORD *)unint64_t v13 = v14;
            v11[6] = v13 + 3;
          }
          if (SHIBYTE(v49) < 0) {
            operator delete(v48[1]);
          }
          if (SHIBYTE(v48[0]) < 0) {
            operator delete(v47[0]);
          }
          if (SBYTE7(v46) < 0) {
            operator delete(*(void **)&v45.var2.__r_.var0);
          }
          if (*((char *)&v45.var2.__r_.__value_.var0.var1 + 23) < 0) {
            operator delete(v45.var2.__r_.__value_.var0.var1.__data_);
          }
          v10 += 136;
        }
        *(void *)&v45.var0 = &v52;
        sub_100047F64((void ***)&v45);
        long long v25 = v7[1];
        if (v25)
        {
          do
          {
            uint64_t v26 = (char **)v25;
            long long v25 = *(char **)v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            uint64_t v26 = (char **)v7[2];
            BOOL v27 = *v26 == (char *)v7;
            xpc_object_t v7 = v26;
          }
          while (!v27);
        }
        xpc_object_t v7 = v26;
      }
      while (v26 != v36);
      uint64_t v6 = (char *)v36[0];
    }
  }
  else
  {
    long long v35 = (char **)v36;
  }
  sub_1007036B8((uint64_t)&v35, v6);
  if (v39 != *(void *)(v3 + 16))
  {
LABEL_56:
    [*(id *)(a1 + 16) handleEmergencyNumbersChanged];
    goto LABEL_57;
  }
  char v28 = v37;
  if (v37 != (uint64_t *)&v38)
  {
    uint64_t v29 = *(uint64_t **)v3;
    while ((sub_100704DA4((uint64_t)&v45, (uint64_t)(v28 + 4), (uint64_t)(v29 + 4)) & 1) != 0)
    {
      long long v30 = (uint64_t *)v28[1];
      long long v31 = v28;
      if (v30)
      {
        do
        {
          char v28 = v30;
          long long v30 = (uint64_t *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          char v28 = (uint64_t *)v31[2];
          BOOL v27 = *v28 == (void)v31;
          long long v31 = v28;
        }
        while (!v27);
      }
      long long v32 = (uint64_t *)v29[1];
      if (v32)
      {
        do
        {
          long long v33 = v32;
          long long v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          long long v33 = (uint64_t *)v29[2];
          BOOL v27 = *v33 == (void)v29;
          uint64_t v29 = v33;
        }
        while (!v27);
      }
      uint64_t v29 = v33;
      if (v28 == (uint64_t *)&v38) {
        goto LABEL_57;
      }
    }
    goto LABEL_56;
  }
LABEL_57:
  sub_100703778((uint64_t)&v37, v38);
  sub_1007036B8((uint64_t)&v40, v41);
}

void sub_1007043E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, char *a17, uint64_t a18, char a19, char *a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28)
{
}

uint64_t sub_100704480(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD2A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007044C0()
{
  return &off_1019FD2A0;
}

void sub_1007044CC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1007036B8(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v9, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v11; i != v9[1] || v10 != v9[0]; uint64_t i = ++v11)
    {
      xpc_object_t v8 = 0;
      object[0] = &v10;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        *(_OWORD *)xpc_object_t object = 0u;
        long long v7 = 0u;
        uint64_t v12 = (void **)v8;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          uint64_t v12 = (void **)xpc_null_create();
        }
        sub_10070477C((uint64_t *)object, (xpc_object_t *)&v12);
        xpc_release(v12);
        sub_1000FFA68((uint64_t **)a1, (int *)object, (uint64_t)object);
        uint64_t v12 = &object[1];
        sub_100702C2C(&v12);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_1007046DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16)
{
  xpc_release(object);
  xpc_release(a16);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void sub_10070477C(uint64_t *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v6 = &v9;
    long long v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *(_DWORD *)a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *(_DWORD *)a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    uint64_t v6 = &v9;
    long long v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    sub_100704930(a1 + 1, &object);
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1007048DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_100704930(uint64_t *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v5 = *a1;
  for (uint64_t i = a1[1]; i != v5; sub_100702B04(i))
    i -= 136;
  a1[1] = v5;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v13, object, 0);
    xpc_release(object[0]);
    v11[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      v11[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, v11, count);
    xpc_release(v11[0]);
    for (j = v14; j != object[1] || v13 != object[0]; j = ++v14)
    {
      v11[0] = &v13;
      v11[1] = j;
      unint64_t v8 = a1[1];
      if (v8 >= a1[2])
      {
        uint64_t v9 = sub_100704B8C(a1);
      }
      else
      {
        CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a1[1]);
        uint64_t v9 = v8 + 136;
        a1[1] = v9;
      }
      a1[1] = v9;
      sub_1000492E0((uint64_t)v11, &v10);
      read_rest_value((CSIPhoneNumber *)(v9 - 136), (const object *)&v10);
      xpc_release(v10);
    }
    xpc_release(v13);
    xpc_release(v13);
  }
  xpc_release(v3);
}

void sub_100704B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100704B8C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xF0F0F0F0F0F0F0F1 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x1E1E1E1E1E1E1E1) {
    sub_10006A748();
  }
  uint64_t v5 = (uint64_t)(a1 + 2);
  unint64_t v6 = 0xF0F0F0F0F0F0F0F1 * ((a1[2] - v2) >> 3);
  if (2 * v6 > v4) {
    unint64_t v4 = 2 * v6;
  }
  if (v6 >= 0xF0F0F0F0F0F0F0) {
    unint64_t v7 = 0x1E1E1E1E1E1E1E1;
  }
  else {
    unint64_t v7 = v4;
  }
  uint64_t v15 = a1 + 2;
  if (v7) {
    unint64_t v8 = (char *)sub_100320E18(v5, v7);
  }
  else {
    unint64_t v8 = 0;
  }
  unint64_t v11 = v8;
  uint64_t v12 = (CSIPhoneNumber *)&v8[136 * v3];
  long long v14 = &v8[136 * v7];
  CSIPhoneNumber::CSIPhoneNumber(v12);
  p_var0 = &v12[2].var2.var0;
  sub_100704C84(a1, &v11);
  uint64_t v9 = a1[1];
  sub_100704D54((uint64_t)&v11);
  return v9;
}

void sub_100704C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100704D54((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100704C84(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 136);
    v2 -= 136;
    *(void *)(v4 - 136) = v5;
    v4 -= 136;
    long long v6 = *(_OWORD *)(v2 + 8);
    *(void *)(v4 + 24) = *(void *)(v2 + 24);
    *(_OWORD *)(v4 + 8) = v6;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
    *(void *)(v2 + 8) = 0;
    long long v7 = *(_OWORD *)(v2 + 32);
    *(void *)(v4 + 48) = *(void *)(v2 + 48);
    *(_OWORD *)(v4 + 32) = v7;
    *(void *)(v2 + 40) = 0;
    *(void *)(v2 + 48) = 0;
    *(void *)(v2 + 32) = 0;
    *(void *)(v4 + 56) = *(void *)(v2 + 56);
    long long v8 = *(_OWORD *)(v2 + 64);
    *(void *)(v4 + 80) = *(void *)(v2 + 80);
    *(_OWORD *)(v4 + 64) = v8;
    *(void *)(v2 + 72) = 0;
    *(void *)(v2 + 80) = 0;
    *(void *)(v2 + 64) = 0;
    long long v9 = *(_OWORD *)(v2 + 88);
    *(void *)(v4 + 104) = *(void *)(v2 + 104);
    *(_OWORD *)(v4 + 88) = v9;
    *(void *)(v2 + 96) = 0;
    *(void *)(v2 + 104) = 0;
    *(void *)(v2 + 88) = 0;
    long long v10 = *(_OWORD *)(v2 + 112);
    *(unsigned char *)(v4 + 128) = *(unsigned char *)(v2 + 128);
    *(_OWORD *)(v4 + 112) = v10;
  }
  a2[1] = v4;
  uint64_t v11 = *result;
  uint64_t *result = v4;
  a2[1] = v11;
  uint64_t v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100704D54(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 136;
    sub_100702B04(i - 136);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100704DA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a2 != *(_DWORD *)a3) {
    return 0;
  }
  uint64_t v3 = *(unsigned __int8 **)(a2 + 8);
  uint64_t v4 = *(unsigned __int8 **)(a2 + 16);
  uint64_t v5 = *(unsigned __int8 **)(a3 + 8);
  if (v4 - v3 != *(void *)(a3 + 16) - (void)v5) {
    return 0;
  }
  if (v3 == v4) {
    return 1;
  }
  do
  {
    uint64_t result = sub_1000609C0((uint64_t)&v7, v3, v5);
    if (!result) {
      break;
    }
    v3 += 24;
    v5 += 24;
  }
  while (v3 != v4);
  return result;
}

uint64_t sub_100704E34(uint64_t a1)
{
  return a1;
}

void sub_100704E60(uint64_t a1)
{
  operator delete();
}

void *sub_100704EAC(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD2C0;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100704F04(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD2C0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100704F4C(uint64_t a1)
{
}

void sub_100704F54(id *a1)
{
  operator delete(a1);
}

void sub_100704F90(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v35 = *(void *)(a1 + 8);
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v4 = (uint64_t **)(v35 + 8);
  sub_100703718(v35, *(char **)(v35 + 8));
  *(void *)uint64_t v35 = v35 + 8;
  *(void *)(v35 + 16) = 0;
  *(void *)(v35 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    uint64_t v48 = (xpc_object_t *)v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      uint64_t v48 = (xpc_object_t *)xpc_null_create();
    }
    sub_100048BF4(&v39, (void **)&v48, 0);
    xpc_release(v48);
    uint64_t v48 = (xpc_object_t *)v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      uint64_t v48 = (xpc_object_t *)xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v38, (void **)&v48, count);
    xpc_release(v48);
    for (uint64_t i = v40; ; uint64_t i = ++v40)
    {
      if (i == v38[1] && v39 == v38[0])
      {
        xpc_release(v39);
        xpc_release(v39);
        goto LABEL_84;
      }
      xpc_object_t object = 0;
      uint64_t v48 = &v39;
      v49.i64[0] = (uint64_t)i;
      sub_10003FBDC((uint64_t)&v48, &object);
      if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_82:
      xpc_release(object);
    }
    memset(v36, 0, sizeof(v36));
    xpc_object_t v7 = object;
    if (object)
    {
      xpc_retain(object);
      xpc_object_t v43 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v43 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v48 = &v43;
        v49.i64[0] = (uint64_t)"first";
        sub_100048BAC((uint64_t)&v48, v46);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v46);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          LODWORD(v45[0]) = v36[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v45, v46, v10);
          LODWORD(v36[0]) = v45[0];
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(v36[0]) = xpc::dyn_cast_or_default((xpc *)v46, 0, (uint64_t)v10);
        }
        xpc_release(*(xpc_object_t *)v46);
        v41[0] = &v43;
        v41[1] = "second";
        sub_100048BAC((uint64_t)v41, &v42);
        xpc_object_t v11 = v42;
        if (v42 && xpc_get_type(v42) == (xpc_type_t)&_xpc_type_array) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t v11 = xpc_null_create();
        }
        uint64_t v12 = *((void *)&v36[0] + 1);
        for (uint64_t j = *(void *)&v36[1]; j != v12; sub_1000FECD4(j))
          j -= 56;
        *(void *)&v36[1] = v12;
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
        {
          uint64_t v48 = (xpc_object_t *)v11;
          if (v11) {
            xpc_retain(v11);
          }
          else {
            uint64_t v48 = (xpc_object_t *)xpc_null_create();
          }
          sub_100048BF4((void **)v46, (void **)&v48, 0);
          xpc_release(v48);
          uint64_t v48 = (xpc_object_t *)v11;
          if (v11) {
            xpc_retain(v11);
          }
          else {
            uint64_t v48 = (xpc_object_t *)xpc_null_create();
          }
          if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array) {
            long long v14 = (void *)xpc_array_get_count(v11);
          }
          else {
            long long v14 = 0;
          }
          sub_100048BF4(v45, (void **)&v48, v14);
          xpc_release(v48);
          for (k = v47; k != v45[1] || *(void **)v46 != v45[0]; k = ++v47)
          {
            v44[0] = v46;
            v44[1] = k;
            uint64_t v16 = *(void *)&v36[1];
            if (*(void *)&v36[1] >= *((void *)&v36[1] + 1))
            {
              uint64_t v18 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v36[1] - *((void *)&v36[0] + 1)) >> 3);
              unint64_t v19 = v18 + 1;
              if ((unint64_t)(v18 + 1) > 0x492492492492492) {
                sub_10006A748();
              }
              if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*((void *)&v36[1] + 1) - *((void *)&v36[0] + 1)) >> 3) > v19) {
                unint64_t v19 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*((void *)&v36[1] + 1) - *((void *)&v36[0] + 1)) >> 3);
              }
              if ((unint64_t)(0x6DB6DB6DB6DB6DB7
                                    * ((uint64_t)(*((void *)&v36[1] + 1) - *((void *)&v36[0] + 1)) >> 3)) >= 0x249249249249249)
                unint64_t v20 = 0x492492492492492;
              else {
                unint64_t v20 = v19;
              }
              uint64_t v51 = (char *)&v36[1] + 8;
              if (v20) {
                char v21 = (xpc_object_t *)sub_100341ECC((uint64_t)&v36[1] + 8, v20);
              }
              else {
                char v21 = 0;
              }
              uint64_t v48 = v21;
              v49.i64[0] = (uint64_t)&v21[7 * v18];
              v49.i64[1] = v49.i64[0];
              long long v50 = &v21[7 * v20];
              sub_100705844(v49.i64[0]);
              uint64_t v22 = v49.i64[0];
              uint64_t v17 = v49.i64[1] + 56;
              v49.i64[1] += 56;
              uint64_t v24 = *((void *)&v36[0] + 1);
              uint64_t v23 = *(void *)&v36[1];
              if (*(void *)&v36[1] == *((void *)&v36[0] + 1))
              {
                int64x2_t v27 = vdupq_n_s64(*(unint64_t *)&v36[1]);
              }
              else
              {
                do
                {
                  long long v25 = *(_OWORD *)(v23 - 56);
                  *(void *)(v22 - 40) = *(void *)(v23 - 40);
                  *(_OWORD *)(v22 - 56) = v25;
                  *(void *)(v23 - 48) = 0;
                  *(void *)(v23 - 40) = 0;
                  *(void *)(v23 - 56) = 0;
                  long long v26 = *(_OWORD *)(v23 - 32);
                  *(void *)(v22 - 16) = *(void *)(v23 - 16);
                  *(_OWORD *)(v22 - 32) = v26;
                  *(void *)(v23 - 24) = 0;
                  *(void *)(v23 - 16) = 0;
                  *(void *)(v23 - 32) = 0;
                  *(void *)(v22 - 8) = *(void *)(v23 - 8);
                  v22 -= 56;
                  v23 -= 56;
                }
                while (v23 != v24);
                int64x2_t v27 = *(int64x2_t *)((char *)v36 + 8);
                uint64_t v17 = v49.i64[1];
              }
              *((void *)&v36[0] + 1) = v22;
              *(void *)&v36[1] = v17;
              int64x2_t v49 = v27;
              char v28 = (char *)*((void *)&v36[1] + 1);
              *((void *)&v36[1] + 1) = v50;
              long long v50 = (xpc_object_t *)v28;
              uint64_t v48 = (xpc_object_t *)v27.i64[0];
              sub_100703144((uint64_t)&v48);
            }
            else
            {
              sub_100705844(*(uint64_t *)&v36[1]);
              uint64_t v17 = v16 + 56;
            }
            *(void *)&v36[1] = v17;
            sub_1000492E0((uint64_t)v44, &v48);
            read_rest_value();
            xpc_release(v48);
          }
          xpc_release(*(xpc_object_t *)v46);
          xpc_release(*(xpc_object_t *)v46);
        }
        xpc_release(v11);
        xpc_release(v42);
        xpc_object_t v8 = v43;
      }
      xpc_release(v8);
      xpc_release(v7);
      uint64_t v29 = *v4;
      long long v30 = (uint64_t **)(v35 + 8);
      long long v31 = (uint64_t **)(v35 + 8);
      if (*v4)
      {
        while (1)
        {
          while (1)
          {
            long long v31 = (uint64_t **)v29;
            int v32 = *((_DWORD *)v29 + 8);
            if (v32 <= SLODWORD(v36[0])) {
              break;
            }
            uint64_t v29 = *v31;
            long long v30 = v31;
            if (!*v31) {
              goto LABEL_80;
            }
          }
          if (v32 >= SLODWORD(v36[0])) {
            break;
          }
          uint64_t v29 = v31[1];
          if (!v29)
          {
            long long v30 = v31 + 1;
            goto LABEL_80;
          }
        }
      }
      else
      {
LABEL_80:
        long long v33 = (char *)operator new(0x40uLL);
        *((_DWORD *)v33 + 8) = v36[0];
        *(_OWORD *)(v33 + 40) = *(_OWORD *)((char *)v36 + 8);
        *((void *)v33 + 7) = *((void *)&v36[1] + 1);
        memset((char *)v36 + 8, 0, 24);
        sub_100046C38((uint64_t **)v35, (uint64_t)v31, v30, (uint64_t *)v33);
      }
      uint64_t v48 = (xpc_object_t *)v36 + 1;
      sub_100702E5C(&v48);
      goto LABEL_82;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v43 = v8;
    goto LABEL_27;
  }
LABEL_84:
  xpc_release(v3);
  [*(id *)(a1 + 16) handleDisambiguationEmergencyNumbersChanged];
}

void sub_100705664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t object,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29)
{
  xpc_release(*(xpc_object_t *)(v29 - 128));
  *(void *)(v29 - 128) = 0;
  xpc_release(object);
  xpc_release(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1007057F8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD320)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100705838()
{
  return &off_1019FD320;
}

uint64_t sub_100705844(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v2 = sub_100058DB0((void *)a1, "");
  sub_100058DB0(v2 + 3, "");
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 52) = 0;
  return a1;
}

void sub_10070589C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007058B8(uint64_t a1)
{
  return a1;
}

void sub_1007058E4(uint64_t a1)
{
  operator delete();
}

void *sub_100705930(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD340;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100705988(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD340;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_1007059D0(uint64_t a1)
{
}

void sub_1007059D8(id *a1)
{
  operator delete(a1);
}

void sub_100705A14(uint64_t a1, const object *a2)
{
  read_rest_value(*(CallFrequencyData **)(a1 + 8), a2);
  [*(id *)(a1 + 16) handleCallFrequencyDataChanged];
}

uint64_t sub_100705A60(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD3A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100705AA0()
{
  return &off_1019FD3A0;
}

uint64_t sub_100705AAC(uint64_t a1)
{
  return a1;
}

void sub_100705AD8(uint64_t a1)
{
  operator delete();
}

void *sub_100705B24(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD3C0;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100705B7C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD3C0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100705BC4(uint64_t a1)
{
}

void sub_100705BCC(id *a1)
{
  operator delete(a1);
}

void sub_100705C08(uint64_t a1, xpc_object_t *a2)
{
  sub_10003447C(*(void *)(a1 + 8), a2);
  [*(id *)(a1 + 16) handleThumperHandoffAvailabilityChanged];
}

uint64_t sub_100705C54(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD420)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100705C94()
{
  return &off_1019FD420;
}

uint64_t sub_100705CA0(uint64_t a1)
{
  return a1;
}

void sub_100705CCC(uint64_t a1)
{
  operator delete();
}

void *sub_100705D18(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD440;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100705D70(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD440;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100705DB8(uint64_t a1)
{
}

void sub_100705DC0(id *a1)
{
  operator delete(a1);
}

void sub_100705DFC(uint64_t a1, xpc_object_t *a2)
{
  sub_100A5892C(*(void *)(a1 + 8), a2, "PersonalityID", "State");
  [*(id *)(a1 + 16) handleThumperAccountIdChanged];
}

uint64_t sub_100705E58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD4A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100705E98()
{
  return &off_1019FD4A0;
}

uint64_t sub_100705EA4(uint64_t a1)
{
  return a1;
}

void sub_100705ED0(uint64_t a1)
{
  operator delete();
}

void *sub_100705F1C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_1019FD4C0;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_100705F74(uint64_t a1, void *a2)
{
  *a2 = off_1019FD4C0;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100705FBC(uint64_t a1)
{
}

void sub_100705FC4(id *a1)
{
  operator delete(a1);
}

void sub_100706000(uint64_t a1)
{
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  read_rest_value();
  [*(id *)(a1 + 8) handleCallControlFailure:v3];
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  xpc_object_t v8 = (void **)&v5;
  sub_100047F64(&v8);
  if (SBYTE7(v4) < 0) {
    operator delete(v3[0]);
  }
}

void sub_100706098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  *(void *)(v25 - 40) = v24;
  sub_100047F64((void ***)(v25 - 40));
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007060D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD520)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100706110()
{
  return &off_1019FD520;
}

uint64_t sub_10070611C(uint64_t a1)
{
  return a1;
}

void sub_100706148(uint64_t a1)
{
  operator delete();
}

void *sub_100706194(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_1019FD540;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1007061EC(uint64_t a1, void *a2)
{
  *a2 = off_1019FD540;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100706234(uint64_t a1)
{
}

void sub_10070623C(id *a1)
{
  operator delete(a1);
}

void sub_100706278(uint64_t a1)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v4 = 0;
  read_rest_value();
  [*(id *)(a1 + 8) handleCallToneComplete:__p];
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007062DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007062F8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD5A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100706338()
{
  return &off_1019FD5A0;
}

uint64_t sub_100706344(uint64_t a1)
{
  return a1;
}

void sub_100706370(uint64_t a1)
{
  operator delete();
}

void *sub_1007063BC(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD5C0;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100706414(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD5C0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_10070645C(uint64_t a1)
{
}

void sub_100706464(id *a1)
{
  operator delete(a1);
}

void sub_1007064A0(uint64_t a1, SubscriptionInfo *a2, const object *a3)
{
  rest::read_rest_value(*(rest **)(a1 + 8), a2, a3);
  [*(id *)(a1 + 16) handleSubscriptionInfoChanged];
}

uint64_t sub_1007064EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD620)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070652C()
{
  return &off_1019FD620;
}

uint64_t sub_100706538(uint64_t a1)
{
  return a1;
}

void sub_100706564(uint64_t a1)
{
  operator delete();
}

void *sub_1007065B0(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD640;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100706608(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD640;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100706650(uint64_t a1)
{
}

void sub_100706658(id *a1)
{
  operator delete(a1);
}

void sub_100706694(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  long long v7 = (void **)*v3;
  xpc_object_t v8 = v5;
  if (v3[2])
  {
    v5[2] = &v8;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    long long v7 = &v8;
  }
  sub_1006662F8((uint64_t)v3, a2);
  [*(id *)(a1 + 16) handleLastKnownHomePlmnChanged:&v7];
  sub_10019D5B8((uint64_t)&v7, v8);
}

void sub_100706724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10070673C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD6A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070677C()
{
  return &off_1019FD6A0;
}

uint64_t sub_100706788(uint64_t a1)
{
  return a1;
}

void sub_1007067B4(uint64_t a1)
{
  operator delete();
}

void *sub_100706800(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_1019FD6C0;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_100706858(uint64_t a1, void *a2)
{
  *a2 = off_1019FD6C0;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1007068A0(uint64_t a1)
{
}

void sub_1007068A8(id *a1)
{
  operator delete(a1);
}

void sub_1007068E4(uint64_t a1, xpc_object_t *a2)
{
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  xpc_object_t v3 = *a2;
  xpc_object_t v10 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v10 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v8[0] = &v10;
    v8[1] = "first";
    sub_100048BAC((uint64_t)v8, &object);
    uint64_t v13 = 0;
    long long v14 = 0;
    uint64_t v15 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v15) < 0) {
      operator delete(v13);
    }
    *(_OWORD *)long long __p = *(_OWORD *)v11;
    *(void *)&long long v7 = v12;
    xpc_release(object);
    uint64_t v13 = &v10;
    long long v14 = "second";
    sub_100048BAC((uint64_t)&v13, v11);
    BYTE8(v7) = xpc::dyn_cast_or_default((xpc *)v11, 0, v4);
    xpc_release(v11[0]);
    xpc_object_t v3 = v10;
  }
  xpc_release(v3);
  [*(id *)(a1 + 8) handleDownlinkDtmfEvent:__p dtmf:SBYTE8(v7)];
  if (SBYTE7(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100706A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18, xpc_object_t a19, xpc_object_t object)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100706ABC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD720)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100706AFC()
{
  return &off_1019FD720;
}

uint64_t sub_100706B08(uint64_t a1)
{
  return a1;
}

void sub_100706B34(uint64_t a1)
{
  operator delete();
}

void *sub_100706B80(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(void **)(a1 + 16);
  *uint64_t v2 = off_1019FD740;
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100706BD8(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(void **)(a1 + 16);
  *a2 = off_1019FD740;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100706C20(uint64_t a1)
{
}

void sub_100706C28(id *a1)
{
  operator delete(a1);
}

void sub_100706C64(uint64_t a1, ActiveSubscriptions *a2, const object *a3)
{
  rest::read_rest_value(*(rest **)(a1 + 8), a2, a3);
  [*(id *)(a1 + 16) handleSubscriptionInfoChanged];
}

uint64_t sub_100706CB0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD7A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100706CF0()
{
  return &off_1019FD7A0;
}

void sub_100706D00()
{
}

void *sub_100706D14(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FD7C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100706D5C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FD7C0;
  a2[1] = v2;
  return result;
}

void sub_100706D88(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100706D90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100706DD0()
{
}

void sub_100706DDC(uint64_t a1, const void **a2)
{
  if (a2)
  {
    sub_100706DDC(a1, *a2);
    sub_100706DDC(a1, a2[1]);
    sub_1000558F4(a2 + 5);
    operator delete(a2);
  }
}

BOOL sub_100706E38(uint64_t a1)
{
  xpc_object_t object = 0;
  sub_100048BAC(a1, &object);
  xpc_type_t type = xpc_get_type(object);
  xpc_release(object);
  return type == (xpc_type_t)&_xpc_type_null;
}

void sub_100706E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

id *sub_100706EA8(id *a1)
{
  xpc_release(a1[2]);
  a1[2] = 0;
  xpc_release(a1[1]);
  a1[1] = 0;

  return a1;
}

uint64_t sub_100706EFC(uint64_t a1)
{
  *(void *)a1 = off_1019FD840;

  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  return a1;
}

void sub_100706F6C(uint64_t a1)
{
  *(void *)a1 = off_1019FD840;

  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_100706FFC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_1019FD840;
  sub_100707214(v2 + 1, v1);
  return v2;
}

void *sub_100707050(uint64_t a1, void *a2)
{
  *a2 = off_1019FD840;
  return sub_100707214(a2 + 1, a1 + 8);
}

void sub_10070707C(uint64_t a1)
{
}

void sub_100707084(void **a1)
{
  sub_100707294(a1 + 1);

  operator delete(a1);
}

void sub_1007070C0(void *a1, xpc_object_t *a2)
{
  xpc_object_t v7 = *a2;
  *a2 = xpc_null_create();
  if (xpc::dyn_cast_or_default((xpc *)&v7, 0, v3))
  {
    long long v5 = (void *)a1[1];
    int v4 = (void *)a1[2];
    xpc_object_t v9 = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      xpc_object_t v9 = xpc_null_create();
    }
    long long v6 = (void *)a1[3];
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    [v5 evaluateAndSendCallUpdateWithCallInfo:&v9 previousCallInfo:&object appendCallUpdate:a1[4]];
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v9);
  }
  xpc_release(v7);
}

void sub_10070717C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t sub_1007071C8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD8A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100707208()
{
  return &off_1019FD8A0;
}

void *sub_100707214(void *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  long long v5 = *(void **)(a2 + 8);
  *a1 = v4;
  a1[1] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    a1[1] = xpc_null_create();
  }
  long long v6 = *(void **)(a2 + 16);
  a1[2] = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    a1[2] = xpc_null_create();
  }
  a1[3] = *(id *)(a2 + 24);
  return a1;
}

void sub_100707294(void **a1)
{
  xpc_release(a1[2]);
  a1[2] = 0;
  xpc_release(a1[1]);
  a1[1] = 0;
  uint64_t v2 = *a1;
}

void sub_1007072F0(uint64_t a1)
{
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_10070735C(uint64_t a1)
{
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  operator delete();
}

uint64_t sub_1007073DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

uint64_t *sub_100707400(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((*(unsigned char *)(v2 + 136) & 1) == 0)
    {
      v6.__ptr_ = 0;
      uint64_t v3 = *(void *)(v2 + 16);
      std::exception_ptr::~exception_ptr(&v6);
      uint64_t v2 = *a1;
      if (!v3 && *(uint64_t *)(v2 + 8) >= 1)
      {
        v7.__cat_ = std::future_category();
        *(void *)&v7.__val_ = 4;
        std::future_error::future_error(&v5, v7);
        sub_1007074E4(&v5);
      }
    }
    if (!atomic_fetch_add((atomic_ullong *volatile)(v2 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    }
  }
  return a1;
}

void sub_1007074E4(const std::logic_error *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x20uLL);
  uint64_t v3 = std::logic_error::logic_error(exception, a1);
  v3[1] = a1[1];
}

void sub_100707550(void *a1)
{
}

uint64_t sub_100707570(uint64_t a1)
{
  return a1;
}

void sub_10070759C(uint64_t a1)
{
  operator delete();
}

void *sub_1007075E8(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  *uint64_t v2 = off_1019FD908;
  id v3 = *(id *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  v2[1] = v3;
  v2[2] = v4;
  return v2;
}

id sub_100707644(uint64_t a1, void *a2)
{
  *a2 = off_1019FD908;
  id result = *(id *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  a2[1] = result;
  a2[2] = v5;
  return result;
}

void sub_100707694(uint64_t a1)
{
}

void sub_10070769C(id *a1)
{
  operator delete(a1);
}

void sub_1007076D8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    std::exception_ptr v6 = "did not handle";
    if (v4) {
      std::exception_ptr v6 = "handled";
    }
    std::error_code v7 = " CSD will retry actions individually.";
    if (v4) {
      std::error_code v7 = "";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v12 = 2080;
    uint64_t v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Transaction: Call module %s the transaction collectively.%s", buf, 0x16u);
  }
  uint64_t v8 = **(void **)(a1 + 16);
  if (!v8) {
    sub_1007078E4(3u);
  }
  std::mutex::lock((std::mutex *)(v8 + 24));
  if ((*(unsigned char *)(v8 + 136) & 1) != 0
    || (*(void *)long long buf = 0,
        uint64_t v9 = *(void *)(v8 + 16),
        std::exception_ptr::~exception_ptr((std::exception_ptr *)buf),
        v9))
  {
    sub_1007078E4(2u);
  }
  *(unsigned char *)(v8 + 140) = v4;
  *(_DWORD *)(v8 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(v8 + 88));
  std::mutex::unlock((std::mutex *)(v8 + 24));
  xpc_release(object);
}

void sub_100707858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100707898(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD968)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007078D8()
{
  return &off_1019FD968;
}

void sub_1007078E4(unsigned int a1)
{
  exception = (std::future_error *)__cxa_allocate_exception(0x20uLL);
  v3.__cat_ = std::future_category();
  *(void *)&v3.__val_ = a1;
  std::future_error::future_error(exception, v3);
}

void sub_100707938(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10070794C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  int v3 = *(_DWORD *)(a1 + 136);
  if ((v3 & 2) != 0) {
    sub_1007078E4(1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 8), 1uLL, memory_order_relaxed);
  *(_DWORD *)(a1 + 136) = v3 | 2;

  std::mutex::unlock(v2);
}

void sub_1007079B4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id **sub_1007079C8(id *a1)
{
  uint64_t v22 = a1;
  xpc_object_t v32 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v32 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v32 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t v32 = v4;
LABEL_9:
  xpc_release(v3);
  [a1[1] asDictionary:&v32];
  long long v28 = 0u;
  uint64_t v29 = 0;
  *(_OWORD *)int64x2_t v27 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  memset(__p, 0, sizeof(__p));
  uint64_t v30 = 1;
  uint64_t v31 = 0;
  xpc_object_t object = &v32;
  uint64_t v24 = "kPhoneNumber";
  sub_100048BAC((uint64_t)&object, &v33);
  memset(buf, 0, sizeof(buf));
  xpc::dyn_cast_or_default();
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  *(_OWORD *)&__p[1] = v34;
  __p[3] = v35;
  HIBYTE(v35) = 0;
  LOBYTE(v34) = 0;
  xpc_release(v33);
  *(void *)long long buf = &v32;
  *(void *)&uint8_t buf[8] = "kCallSourceMode";
  sub_100048BAC((uint64_t)buf, &v34);
  HIDWORD(v28) = xpc::dyn_cast_or_default((xpc *)&v34, 0, v5);
  xpc_release((xpc_object_t)v34);
  xpc_object_t object = &v32;
  uint64_t v24 = "kUuid";
  sub_100048BAC((uint64_t)&object, &v33);
  memset(buf, 0, sizeof(buf));
  xpc::dyn_cast_or_default();
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v25[0]);
  }
  *(_OWORD *)uint64_t v25 = v34;
  __p[0] = v35;
  HIBYTE(v35) = 0;
  LOBYTE(v34) = 0;
  xpc_release(v33);
  *(void *)long long buf = &v32;
  *(void *)&uint8_t buf[8] = "kIsTTY";
  sub_100048BAC((uint64_t)buf, &v34);
  LODWORD(v29) = xpc::dyn_cast_or_default((xpc *)&v34, 0, v6);
  xpc_release((xpc_object_t)v34);
  *(void *)long long buf = &v32;
  *(void *)&uint8_t buf[8] = "kCallSimSlot";
  sub_100048BAC((uint64_t)buf, &v34);
  uint64_t v8 = (subscriber *)xpc::dyn_cast_or_default((xpc *)&v34, 0, v7);
  xpc_release((xpc_object_t)v34);
  LODWORD(v30) = subscriber::instanceAsSimSlot(v8, v9);
  *(void *)long long buf = &v32;
  *(void *)&uint8_t buf[8] = "kIsEmergencyCall";
  sub_100048BAC((uint64_t)buf, &v34);
  BYTE4(v30) = xpc::dyn_cast_or_default((xpc *)&v34, 0, v10);
  xpc_release((xpc_object_t)v34);
  xpc_object_t v11 = **((void **)*a1 + 1);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = BYTE4(v30);
    int v13 = SHIBYTE(__p[0]);
    long long v14 = (void **)v25[0];
    uint64_t v15 = subscriber::asString();
    uint64_t v16 = v25;
    if (v13 < 0) {
      uint64_t v16 = v14;
    }
    uint64_t v17 = "n emergency";
    *(_DWORD *)long long buf = 136315650;
    if (!v12) {
      uint64_t v17 = " normal";
    }
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v16;
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v37 = (uint8_t *)v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I CSD requests to dial a%s call %s on slot %s", buf, 0x20u);
  }
  id v18 = a1[1];
  id v19 = *a1;
  xpc_object_t object = 0;
  write_rest_value();
  sub_100058DB0(&v34, "/cc/requests/dial");
  xpc_object_t v33 = object;
  xpc_object_t object = xpc_null_create();
  id v20 = v19;
  *(void *)long long buf = off_1019FD988;
  *(void *)&uint8_t buf[8] = v18;
  *(void *)&uint8_t buf[16] = v20;
  long long v37 = buf;
  ctu::RestModule::sendRequest();
  sub_10003F600(buf);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)v34);
  }
  xpc_release(object);

  if (SBYTE7(v28) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v25[0]);
  }
  xpc_release(v32);
  return sub_10003B50C(&v22);
}

void sub_100707E38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, xpc_object_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100707FEC(uint64_t a1)
{
  return a1;
}

void sub_100708020(uint64_t a1)
{
  operator delete();
}

void *sub_100708074(uint64_t a1)
{
  xpc_object_t v2 = operator new(0x18uLL);
  *xpc_object_t v2 = off_1019FD988;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_1007080D8(uint64_t a1, void *a2)
{
  *a2 = off_1019FD988;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100708130(uint64_t a1)
{
  xpc_object_t v2 = *(void **)(a1 + 8);
}

void sub_10070816C(id *a1)
{
  operator delete(a1);
}

void sub_1007081B0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "did not handle";
    if (v4) {
      uint64_t v6 = "handled";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Call module %s the dial with rest", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_1007082BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1007082EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FD9E8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070832C()
{
  return &off_1019FD9E8;
}

id **sub_100708338(id *a1)
{
  uint64_t v8 = a1;
  memset(v9, 0, sizeof(v9));
  id v2 = *a1;
  if (v2) {
    [v2 getCurrentCalls];
  }
  *(_OWORD *)uint64_t v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)long long __p = 0u;
  BOOL v3 = [a1[1] callUUID];
  sub_100848F68(v3, v17);
  if (SHIBYTE(v15[0]) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)long long __p = *(_OWORD *)v17;
  v15[0] = v18;
  HIBYTE(v18) = 0;
  LOBYTE(v17[0]) = 0;

  id v4 = a1[1];
  id v5 = *a1;
  xpc_object_t v13 = 0;
  write_rest_value();
  sub_100058DB0(&v11, "/cc/requests/answer");
  xpc_object_t object = v13;
  xpc_object_t v13 = xpc_null_create();
  id v6 = v5;
  v17[0] = off_1019FDA08;
  v17[1] = v4;
  id v18 = v6;
  id v19 = v17;
  ctu::RestModule::sendRequest();
  sub_10003F600(v17);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v12 < 0) {
    operator delete(v11);
  }
  xpc_release(v13);

  if (SHIBYTE(v16) < 0) {
    operator delete(v15[1]);
  }
  if (SHIBYTE(v15[0]) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = v9;
  sub_1001F1FAC((void ***)__p);
  return sub_10003B50C(&v8);
}

void sub_100708794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,__int16 *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  a24 = &a11;
  sub_1001F1FAC((void ***)&a24);
  sub_10003B50C(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100708964(uint64_t a1)
{
  return a1;
}

void sub_100708998(uint64_t a1)
{
  operator delete();
}

void *sub_1007089EC(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDA08;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100708A50(uint64_t a1, void *a2)
{
  *a2 = off_1019FDA08;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100708AA8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_100708AE4(id *a1)
{
  operator delete(a1);
}

void sub_100708B28(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Answer with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_100708C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100708C64(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDA68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100708CA4()
{
  return &off_1019FDA68;
}

uint64_t sub_100708CB0(uint64_t a1)
{
  return a1;
}

void sub_100708CE4(uint64_t a1)
{
  operator delete();
}

void *sub_100708D38(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDA88;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100708D9C(uint64_t a1, void *a2)
{
  *a2 = off_1019FDA88;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100708DF4(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_100708E30(id *a1)
{
  operator delete(a1);
}

void sub_100708E74(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N End Call with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_100708F80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100708FB0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDAE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100708FF0()
{
  return &off_1019FDAE8;
}

uint64_t sub_100708FFC(uint64_t a1)
{
  return a1;
}

void sub_100709030(uint64_t a1)
{
  operator delete();
}

void *sub_100709084(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDB08;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_1007090E8(uint64_t a1, void *a2)
{
  *a2 = off_1019FDB08;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100709140(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_10070917C(id *a1)
{
  operator delete(a1);
}

void sub_1007091C0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Hold/UnHold call with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_1007092CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1007092FC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDB68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070933C()
{
  return &off_1019FDB68;
}

uint64_t sub_100709348(uint64_t a1)
{
  return a1;
}

void sub_10070937C(uint64_t a1)
{
  operator delete();
}

void *sub_1007093D0(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDB88;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100709434(uint64_t a1, void *a2)
{
  *a2 = off_1019FDB88;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_10070948C(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_1007094C8(id *a1)
{
  operator delete(a1);
}

void sub_10070950C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Merge/UnMerge call with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_100709618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100709648(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDBE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100709688()
{
  return &off_1019FDBE8;
}

uint64_t sub_100709694(uint64_t a1)
{
  return a1;
}

void sub_1007096C8(uint64_t a1)
{
  operator delete();
}

void *sub_10070971C(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDC08;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100709780(uint64_t a1, void *a2)
{
  *a2 = off_1019FDC08;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_1007097D8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_100709814(id *a1)
{
  operator delete(a1);
}

void sub_100709858(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed. Failing action.";
    if (v4) {
      id v6 = "succeeded. Fulfilling action.";
    }
    *(_DWORD *)long long buf = 136315138;
    char v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N SendDTMF with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ![v7 isComplete])
  {
    unsigned int v9 = *(void **)(a1 + 8);
    if (v4) {
      [v9 fulfill];
    }
    else {
      [v9 fail];
    }
  }
  else
  {
    uint64_t v8 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not fulfilling CXPlayDTMFCallAction since it's already complete or nil!", buf, 2u);
    }
  }
  xpc_release(object);
}

void sub_1007099B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1007099E8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDC68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100709A28()
{
  return &off_1019FDC68;
}

uint64_t sub_100709A34(uint64_t a1)
{
  return a1;
}

void sub_100709A68(uint64_t a1)
{
  operator delete();
}

void *sub_100709ABC(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDC88;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100709B20(uint64_t a1, void *a2)
{
  *a2 = off_1019FDC88;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100709B78(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_100709BB4(id *a1)
{
  operator delete(a1);
}

void sub_100709BF8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed. Failing action.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N SetRelaying action with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_100709D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100709D34(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDCE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100709D74()
{
  return &off_1019FDCE8;
}

uint64_t sub_100709D80(uint64_t a1)
{
  return a1;
}

void sub_100709DB4(uint64_t a1)
{
  operator delete();
}

void *sub_100709E08(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDD08;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100709E6C(uint64_t a1, void *a2)
{
  *a2 = off_1019FDD08;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100709EC4(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_100709F00(id *a1)
{
  operator delete(a1);
}

void sub_100709F44(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed. Failing action.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N SetScreening action with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ((v4 | [v7 isComplete]) & 1) == 0) {
    [*(id *)(a1 + 8) fail];
  }
  xpc_release(object);
}

void sub_10070A050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070A080(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDD68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070A0C0()
{
  return &off_1019FDD68;
}

uint64_t sub_10070A0CC(uint64_t a1)
{
  return a1;
}

void sub_10070A100(uint64_t a1)
{
  operator delete();
}

void *sub_10070A154(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDD88;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_10070A1B8(uint64_t a1, void *a2)
{
  *a2 = off_1019FDD88;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_10070A210(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_10070A24C(id *a1)
{
  operator delete(a1);
}

void sub_10070A290(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    xpc_object_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Pull call action with rest %s", buf, 0xCu);
  }
  unsigned int v7 = *(void **)(a1 + 8);
  if (v7 && ![v7 isComplete])
  {
    if ((v4 & 1) == 0) {
      [*(id *)(a1 + 8) fail];
    }
  }
  else
  {
    uint64_t v8 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not fulfilling CXPullCallAction since it's already complete or nil!", buf, 2u);
    }
  }
  xpc_release(object);
}

void sub_10070A3E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070A418(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDDE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070A458()
{
  return &off_1019FDDE8;
}

uint64_t sub_10070A464(uint64_t a1)
{
  return a1;
}

void sub_10070A498(uint64_t a1)
{
  operator delete();
}

void *sub_10070A4EC(uint64_t a1)
{
  id v2 = operator new(0x18uLL);
  *id v2 = off_1019FDE08;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_10070A550(uint64_t a1, void *a2)
{
  *a2 = off_1019FDE08;
  a2[1] = *(id *)(a1 + 8);
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_10070A5A8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
}

void sub_10070A5E4(id *a1)
{
  operator delete(a1);
}

void sub_10070A628(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed";
    uint64_t v7 = *(void *)(a1 + 8);
    if (v4) {
      id v6 = "succeeded";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v13 = v7;
    __int16 v14 = 2080;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CXSendMMIOrUSSDCodeAction %@ (CallDialRequest) with rest %s", buf, 0x16u);
  }
  uint64_t v8 = *(void **)(a1 + 8);
  if (v8 && ![v8 isComplete])
  {
    BOOL v10 = *(void **)(a1 + 8);
    if (v4) {
      [v10 fulfill];
    }
    else {
      [v10 fail];
    }
  }
  else
  {
    unsigned int v9 = **(NSObject ***)(*(void *)(a1 + 16) + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Not fulfilling CXSendMMIOrUSSDCodeAction since it's already complete or nil!", buf, 2u);
    }
  }
  xpc_release(object);
}

void sub_10070A798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070A7C8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDE68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070A808()
{
  return &off_1019FDE68;
}

uint64_t sub_10070A814(uint64_t a1)
{
  return a1;
}

void sub_10070A840(uint64_t a1)
{
  operator delete();
}

void *sub_10070A88C(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_1019FDE88;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10070A8E4(uint64_t a1, void *a2)
{
  *a2 = off_1019FDE88;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_10070A92C(uint64_t a1)
{
}

void sub_10070A934(id *a1)
{
  operator delete(a1);
}

void sub_10070A970(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Starting media with rest %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070AA58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070AA88(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDEE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070AAC8()
{
  return &off_1019FDEE8;
}

uint64_t sub_10070AAD4(uint64_t a1)
{
  return a1;
}

void sub_10070AB00(uint64_t a1)
{
  operator delete();
}

void *sub_10070AB4C(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_1019FDF08;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10070ABA4(uint64_t a1, void *a2)
{
  *a2 = off_1019FDF08;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_10070ABEC(uint64_t a1)
{
}

void sub_10070ABF4(id *a1)
{
  operator delete(a1);
}

void sub_10070AC30(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Stopping media with rest %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070AD18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070AD48(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDF68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070AD88()
{
  return &off_1019FDF68;
}

uint64_t sub_10070AD94(uint64_t a1)
{
  return a1;
}

void sub_10070ADC0(uint64_t a1)
{
  operator delete();
}

void *sub_10070AE0C(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_1019FDF88;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10070AE64(uint64_t a1, void *a2)
{
  *a2 = off_1019FDF88;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_10070AEAC(uint64_t a1)
{
}

void sub_10070AEB4(id *a1)
{
  operator delete(a1);
}

void sub_10070AEF0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Updating call to TTY with rest %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070AFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070B008(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FDFE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070B048()
{
  return &off_1019FDFE8;
}

uint64_t sub_10070B054(uint64_t a1)
{
  return a1;
}

void sub_10070B080(uint64_t a1)
{
  operator delete();
}

void *sub_10070B0CC(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_1019FE008;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10070B124(uint64_t a1, void *a2)
{
  *a2 = off_1019FE008;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_10070B16C(uint64_t a1)
{
}

void sub_10070B174(id *a1)
{
  operator delete(a1);
}

void sub_10070B1B0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Ending this call with rest due to provider reset %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070B298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070B2C8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FE068)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070B308()
{
  return &off_1019FE068;
}

uint64_t sub_10070B314(uint64_t a1)
{
  return a1;
}

void sub_10070B340(uint64_t a1)
{
  operator delete();
}

void *sub_10070B38C(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_1019FE088;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10070B3E4(uint64_t a1, void *a2)
{
  *a2 = off_1019FE088;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_10070B42C(uint64_t a1)
{
}

void sub_10070B434(id *a1)
{
  operator delete(a1);
}

void sub_10070B470(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  id v5 = **(NSObject ***)(*(void *)(a1 + 8) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "failed.";
    if (v4) {
      id v6 = "succeeded.";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Ending all calls with rest due to provider reset %s", buf, 0xCu);
  }
  xpc_release(object);
}

void sub_10070B558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10070B588(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FE0E8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10070B5C8()
{
  return &off_1019FE0E8;
}

void sub_10070B5D4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10070B650()
{
}

void sub_10070B674(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10070B774(uint64_t a1, void *a2)
{
  int v4 = (void *)(a1 + 8);
  sub_1001D4D94("UsageAlertAlgorithm", &object);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "cu.algo");
  *int v4 = 0;
  v4[1] = 0;
  id v5 = object;
  *(void *)(a1 + 24) = object;
  if (v5) {
    dispatch_retain(v5);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v12);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  if (v5) {
    dispatch_release(v5);
  }
  *(void *)a1 = off_1019FE150;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 144) = dispatch_queue_create("com.apple.commcenter.walltimer", 0);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 173) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(unsigned char *)(a1 + 216) = 0;
  sub_100058DB0(&__p, "UsageAlertAlgorithm");
  id v6 = *(NSObject **)(a1 + 24);
  unsigned int v9 = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::RestModule::RestModule();
  if (v9) {
    dispatch_release(v9);
  }
  if (v11 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 240) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 248) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10070B95C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  if (object) {
    dispatch_release(object);
  }
  if (a11) {
    dispatch_release(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1005506C0(v24);
  sub_10005D144(*v26);
  sub_10005D144(*v25);
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  UsageAlertAlgorithmInterface::~UsageAlertAlgorithmInterface(v21);
  _Unwind_Resume(a1);
}

void sub_10070BA08(uint64_t a1)
{
  *(void *)a1 = off_1019FE150;
  sub_10070BABC(a1);

  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 232);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1005506C0(a1 + 144);
  sub_10005D144(*(void **)(a1 + 112));
  sub_10005D144(*(void **)(a1 + 88));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  UsageAlertAlgorithmInterface::~UsageAlertAlgorithmInterface((UsageAlertAlgorithmInterface *)a1);
}

void sub_10070BABC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing off all the loaded data", (uint8_t *)v5, 2u);
  }
  sub_10005D144(*(void **)(a1 + 88));
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  sub_10005D144(*(void **)(a1 + 112));
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;

  *(void *)(a1 + 136) = 0;
  int v4 = *(NSObject **)(a1 + 144);
  uint64_t v3 = a1 + 144;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10055099C;
  v5[3] = &unk_1019E2FC8;
  void v5[4] = v3;
  dispatch_async(v4, v5);

  *(void *)(v3 - 80) = 0;
}

void sub_10070BBC0(uint64_t a1)
{
  sub_10070BA08(a1);

  operator delete();
}

void sub_10070BBF8(NSObject *a1)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Erasing saved thresholds", (uint8_t *)__p, 2u);
  }
  uint64_t v2 = (uint64_t **)sub_100365D74();
  sub_100058DB0(__p, "UsageAlertAlgorithm::DailyThresholdAlertShown");
  sub_1003660FC(v2, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v3 = (uint64_t **)sub_100365D74();
  sub_100058DB0(__p, "UsageAlertAlgorithm::PerDayUsageThreshold");
  sub_1003660FC(v3, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  int v4 = (uint64_t **)sub_100365D74();
  sub_100058DB0(__p, "UsageAlertAlgorithm::AlertThresholdFactor");
  sub_1003660FC(v4, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10070BCF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10070BD14(void *a1, int a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_10070BE30;
  void v8[3] = &unk_1019FE1A8;
  _OWORD v8[4] = a1;
  int v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  char v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v4;
  char v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_10070BE30(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 72);
  int v4 = *(_DWORD *)(a1 + 40);
  id v5 = *(NSObject **)(v2 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3 == v4)
  {
    if (v6)
    {
      int v7 = 67109120;
      int v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Current sub tag is already: %d", (uint8_t *)&v7, 8u);
    }
  }
  else
  {
    if (v6)
    {
      int v7 = 67109120;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Initializing current workspace for subscriber tag: %d", (uint8_t *)&v7, 8u);
      int v4 = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(v2 + 72) = v4;
    sub_10070BF3C(v2);
  }
}

void sub_10070BF3C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 72))
  {
    uint64_t v52 = 0;
    ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v52);
    *(void *)&long long v53 = 0;
    ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v53);
    uint64_t v2 = +[NSCalendar currentCalendar];
    id v3 = (id)objc_opt_new();
    [v3 setYear:-1];
    int v4 = [(NSCalendar *)v2 dateByAddingComponents:v3 toDate:+[NSDate date] options:0];
    id v5 = [*(id *)(a1 + 56) removeEntitiesMatching:+[NSPredicate predicateWithFormat:](NSPredicate, "predicateWithFormat:", @"(kind != %@) AND (timeStamp <= %@)", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 256), v4)];
    BOOL v6 = *(NSObject **)(a1 + 40);
    uint64_t v48 = (os_log_t *)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = [(NSString *)[(NSDate *)v4 description] UTF8String];
      *(_DWORD *)long long buf = 134218242;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removed %zu since %s", buf, 0x16u);
    }
    [*(id *)(a1 + 48) save];
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v53);
    sub_10070BABC(a1);
    sub_10070D3FC(a1, (uint64_t *)(a1 + 184), (uint64_t *)(a1 + 192), (uint64_t *)(a1 + 200), a1 + 208, 1);
    int v8 = +[NSDate date];

    *(void *)(a1 + 136) = v8;
    obuint64_t j = [*(id *)(a1 + 56) fetchEntityDictionariesWithProperties:&off_101AE7E68, +[NSPredicate predicateWithFormat:](NSPredicate, "predicateWithFormat:", @"(tag == %@) AND (metadata == %@)", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 72)), +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", -[NSTimeZone secondsFromGMT](+[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"), "secondsFromGMT"))) predicate];
    id v51 = sub_100710504(-1, 23, 59, 59);
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    id v9 = [obj countByEnumeratingWithState:&v53 objects:buf count:16];
    if (v9)
    {
      uint64_t v50 = *(void *)v54;
      do
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v54 != v50) {
            objc_enumerationMutation(obj);
          }
          char v11 = *(void **)(*((void *)&v53 + 1) + 8 * i);
          id v12 = [v11 objectForKeyedSubscript:@"timeStamp"];
          id v13 = [v11 objectForKeyedSubscript:@"wwanIN"];
          id v14 = [v11 objectForKeyedSubscript:@"wwanOUT"];
          unsigned int v15 = sub_10070D7F0((uint64_t)v12);
          *(_DWORD *)long long v62 = v15;
          id v16 = [v12 compare:v51];
          id v17 = [v13 unsignedLongLongValue];
          id v18 = [v14 unsignedLongLongValue];
          if (v16 == (id)-1) {
            id v19 = (uint64_t **)(a1 + 80);
          }
          else {
            id v19 = (uint64_t **)(a1 + 104);
          }
          id v20 = sub_1007111A4(v19, v15, v62);
          uint64_t v20[5] = (uint64_t *)((char *)v20[5] + (uint64_t)v17 + (void)v18);
          if ([v12 compare:*(void *)(a1 + 136)] == (id)-1)
          {

            *(void *)(a1 + 136) = v12;
          }
        }
        id v9 = [obj countByEnumeratingWithState:&v53 objects:buf count:16];
      }
      while (v9);
    }
    char v21 = *v48;
    if (os_log_type_enabled(*v48, OS_LOG_TYPE_DEFAULT))
    {
      id v22 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "description"), "UTF8String");
      *(_DWORD *)long long v62 = 136315138;
      *(void *)&v62[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Oldest record has a timestamp: %s", v62, 0xCu);
    }
    [+[NSDate date] timeIntervalSinceDate:*(void *)(a1 + 136)];
    unint64_t v24 = (uint64_t)(v23 / 86400.0 + 1.0);
    uint64_t v25 = *v48;
    if (os_log_type_enabled(*v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v62 = 134217984;
      *(void *)&v62[4] = v24;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Number of days of data we have: %zu", v62, 0xCu);
    }
    int64x2_t v27 = (void *)(a1 + 80);
    long long v26 = *(void **)(a1 + 80);
    long long v28 = (void *)(a1 + 88);
    if (v26 != (void *)(a1 + 88))
    {
      do
      {
        v26[5] /= v24;
        uint64_t v29 = (void *)v26[1];
        if (v29)
        {
          do
          {
            uint64_t v30 = v29;
            uint64_t v29 = (void *)*v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            uint64_t v30 = (void *)v26[2];
            BOOL v31 = *v30 == (void)v26;
            long long v26 = v30;
          }
          while (!v31);
        }
        long long v26 = v30;
      }
      while (v30 != v28);
    }
    sub_10070D884(v48, (uint64_t)"Hourly usage records", (void *)(a1 + 80));
    sub_10070D884(v48, (uint64_t)"Today's usage records", (void *)(a1 + 104));
    xpc_object_t v32 = (void *)*v27;
    if ((void *)*v27 != v28)
    {
      uint64_t v33 = *(void *)(a1 + 128);
      do
      {
        long long v34 = (void *)v32[1];
        uint64_t v35 = v32;
        if (v34)
        {
          do
          {
            long long v36 = v34;
            long long v34 = (void *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            long long v36 = (void *)v35[2];
            BOOL v31 = *v36 == (void)v35;
            uint64_t v35 = v36;
          }
          while (!v31);
        }
        v33 += v32[5];
        xpc_object_t v32 = v36;
      }
      while (v36 != v28);
      *(void *)(a1 + 128) = v33;
    }
    long long v37 = *v48;
    if (os_log_type_enabled(*v48, OS_LOG_TYPE_DEFAULT))
    {
      sub_1001D44F4(*(void *)(a1 + 128), v62);
      long long v38 = v63 >= 0 ? v62 : *(unsigned char **)v62;
      *(_DWORD *)long long v64 = 136315138;
      long long v65 = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Calculated daily usage average: %s", v64, 0xCu);
      if (v63 < 0) {
        operator delete(*(void **)v62);
      }
    }
    id v39 = sub_100710504(1, 0, 0, 0);
    long long v40 = +[NSDate date];
    objc_msgSend(v39, "timeIntervalSinceDate:", +[NSDate date](NSDate, "date"));
    double v42 = v41;
    xpc_object_t v43 = *v48;
    if (os_log_type_enabled(*v48, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = [(NSString *)[(NSDate *)v40 description] UTF8String];
      id v45 = objc_msgSend(objc_msgSend(v39, "description"), "UTF8String");
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v44;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v45;
      *(_WORD *)&unsigned char buf[22] = 2048;
      long long v58 = (void *)v42;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Scheduling record shift, now: %s, midnight: %s, with gap: %llu", buf, 0x20u);
    }
    long long v46 = *(NSObject **)(a1 + 144);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10055086C;
    long long v58 = &unk_1019E2FA8;
    uint64_t v59 = a1 + 144;
    unsigned int v60 = (v42 * 1000.0);
    int v61 = 0;
    dispatch_async(v46, buf);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v52);
  }
  else
  {
    uint64_t v47 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Current subscriber tag is unknown to start", buf, 2u);
    }
  }
}

void sub_10070C678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void sub_10070C6D0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_10070C7E8;
  uint64_t v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  id v5 = v4;
  BOOL v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v3;
  id v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_10070C7E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v15 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v15);
  id v2 = [*(id *)(v1 + 56) fetchEntitiesFreeForm:0 sortDesc:0];
  id v3 = [v2 count];
  int v4 = *(NSObject **)(v1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      id v6 = [v2 count];
      int v7 = *(_DWORD *)(v1 + 72);
      *(_DWORD *)long long buf = 134218240;
      id v18 = v6;
      __int16 v19 = 1024;
      int v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Fixing %zu usage records with tag: %d", buf, 0x12u);
    }
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v8 = [v2 countByEnumeratingWithState:&v11 objects:v16 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v12;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v12 != v9) {
            objc_enumerationMutation(v2);
          }
          objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * i), "setTag:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v1 + 72)));
        }
        id v8 = [v2 countByEnumeratingWithState:&v11 objects:v16 count:16];
      }
      while (v8);
    }
    [*(id *)(v1 + 48) save];
    sub_10070BF3C(v1);
  }
  else if (v5)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I There are 0 usage records in alert database", buf, 2u);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v15);
}

void sub_10070C9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void sub_10070C9F0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  uint64_t v7[2] = sub_10070CB08;
  uint64_t v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  id v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  BOOL v5 = v4;
  id v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_10070CB08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v15 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v15);
  id v2 = [*(id *)(v1 + 56) fetchEntitiesFreeForm:0 sortDesc:0];
  if ([v2 count])
  {
    uint64_t v3 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [+[NSTimeZone localTimeZone] secondsFromGMT]);
    int v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [v2 count];
      unsigned int v6 = [(NSNumber *)v3 intValue];
      *(_DWORD *)long long buf = 134218240;
      id v18 = v5;
      __int16 v19 = 1024;
      unsigned int v20 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Fixing %zu usage records with meta data: %d", buf, 0x12u);
    }
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v7 = [v2 countByEnumeratingWithState:&v11 objects:v16 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v12;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v12 != v8) {
            objc_enumerationMutation(v2);
          }
          [*(id *)(*((void *)&v11 + 1) + 8 * i) setMetadata:v3];
        }
        id v7 = [v2 countByEnumeratingWithState:&v11 objects:v16 count:16];
      }
      while (v7);
    }
    [*(id *)(v1 + 48) save];
    sub_10070BF3C(v1);
  }
  else
  {
    BOOL v10 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I There are 0 usage records in alert database", buf, 2u);
    }
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v15);
}

void sub_10070CD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void sub_10070CD3C(void *a1, int a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_10070CE58;
  void v8[3] = &unk_1019FE1A8;
  _OWORD v8[4] = a1;
  int v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v6 = v5;
  id v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v4;
  long long v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_10070CE58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v6 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v6);
  id v3 = [*(id *)(v2 + 56) removeEntitiesMatching:+[NSPredicate predicateWithFormat:](NSPredicate, "predicateWithFormat:", @"tag == %@", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 40)))];
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)long long buf = 134218240;
    id v8 = v3;
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Removed %zu live usage records with tag: %d", buf, 0x12u);
  }
  [*(id *)(v2 + 48) save];
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v6);
}

void sub_10070CF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_10070CF88(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  id v3 = ServiceMap;
  if (v4 < 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v4;
  id v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&buf);
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = v8[3];
  __int16 v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
LABEL_8:
    std::mutex::unlock(v3);
    __int16 v9 = 0;
    char v11 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
LABEL_9:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10))
  {
    long long buf = 0uLL;
    uint64_t v21 = 0;
    sub_100058DB0(&buf, "Unexpected Usage Alert DB Error");
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v19 = 0;
    sub_100058DB0(__p, "Please file a radar against Telephony | iOS");
    (*(void (**)(uint64_t, long long *, void **))(*(void *)v10 + 24))(v10, &buf, __p);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0)
    {
      operator delete((void *)buf);
      if (v11) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  if ((v11 & 1) == 0) {
LABEL_14:
  }
    sub_10004D2C8(v9);
LABEL_15:
  if (sub_10121F67C())
  {
    long long v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v13 = sub_1001D3CD8();
      long long v14 = "false";
      if (v13) {
        long long v14 = "true";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Internal build, dumping logs and databases, result: %s", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_10070D2C8(a1);
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Database seem to have got corrupt, resetting the entire database", (uint8_t *)&buf, 2u);
  }
  id v16 = [*(id *)(a1 + 56) removeEntitiesMatching:0];
  id v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v16;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Resetting the database, removed %zu usage records", (uint8_t *)&buf, 0xCu);
  }
  [*(id *)(a1 + 48) save];
  sub_10070BBF8(*(NSObject **)(a1 + 40));
  sub_10070BF3C(a1);
}

void sub_10070D264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_10070D2C8(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 40);
  id v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 128);
    uint64_t v6 = *(void *)(a1 + 184);
    uint64_t v7 = *(void *)(a1 + 192);
    uint64_t v8 = *(void *)(a1 + 200);
    uint64_t v9 = *(void *)(a1 + 208);
    if (*(unsigned char *)(a1 + 216)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    v11[0] = 67110658;
    v11[1] = v4;
    __int16 v12 = 2048;
    uint64_t v13 = v5;
    __int16 v14 = 2048;
    uint64_t v15 = v6;
    __int16 v16 = 2048;
    uint64_t v17 = v7;
    __int16 v18 = 2048;
    uint64_t v19 = v8;
    __int16 v20 = 2048;
    uint64_t v21 = v9;
    __int16 v22 = 2080;
    double v23 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fCurrentSubTag: %u, fDailyUsageAverage: %llu, fPerDayUsageThreshold: %llu, fPerDayUsageAllowance: %llu, fAlertThresholdFactor: %llu, fAlertThresholdFactorGrowthRate: %llu, fUsageAlertShown: %s", (uint8_t *)v11, 0x44u);
  }
  sub_10070D884(v2, (uint64_t)"Hourly usage records", (void *)(a1 + 80));
  sub_10070D884(v2, (uint64_t)"Today's usage records", (void *)(a1 + 104));
}

uint64_t sub_10070D3FC(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, char a6)
{
  __int16 v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Reading thresholds from CSI Data if present", buf, 2u);
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  uint64_t v15 = sub_10070D56C;
  __int16 v16 = &unk_1019FE1C8;
  uint64_t v17 = a1;
  char v18 = a6;
  sub_10070D56C((uint64_t)v14, @"kCTCellularUsagePerDayUsageThreshold", "UsageAlertAlgorithm::PerDayUsageThreshold", (void *)0xC800000, a2);
  v15((uint64_t)v14, @"kCTCellularUsagePerDayUsageAllowance", 0, (void *)50331648, a3);
  v15((uint64_t)v14, @"kCTCellularUsageAlertThresholdFactor", "UsageAlertAlgorithm::AlertThresholdFactor", (void *)5, a4);
  return ((uint64_t (*)(void *, const __CFString *, void, uint64_t, uint64_t))v15)(v14, @"kCTCellularUsageAlertThresholdFactorGrowthRate", 0, 5, a5);
}

void sub_10070D56C(uint64_t a1, uint64_t a2, char *a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = *(void *)(a1 + 32);
  memset(__p, 0, sizeof(__p));
  ctu::cf::assign();
  *(_OWORD *)uint64_t v25 = 0u;
  uint64_t v26 = 0;
  if (a3 && *(unsigned char *)(a1 + 40))
  {
    uint64_t v10 = sub_100365D74();
    sub_100058DB0(__p, a3);
    BOOL v11 = sub_100225FC8(v10, __p, a5);
    BOOL v12 = v11;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (v12) {
        goto LABEL_5;
      }
    }
    else if (v11)
    {
LABEL_5:
      uint64_t v13 = *(NSObject **)(v9 + 40);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_21;
      }
      __int16 v14 = (void *)*a5;
      uint64_t v15 = v25;
      if (v26 < 0) {
        uint64_t v15 = (void **)v25[0];
      }
      LODWORD(__p[0]) = 134218242;
      *(void **)((char *)__p + 4) = v14;
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = v15;
      __int16 v16 = "#I Using current value %llu for %s";
      uint64_t v17 = v13;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)__p, 0x16u);
      goto LABEL_21;
    }
  }
  uint64_t v18 = sub_100365D74();
  BOOL v19 = sub_100225FC8(v18, v25, a5);
  __int16 v20 = *(NSObject **)(v9 + 40);
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (!v21) {
      goto LABEL_21;
    }
    __int16 v22 = (void *)*a5;
    double v23 = v25;
    if (v26 < 0) {
      double v23 = (void **)v25[0];
    }
    LODWORD(__p[0]) = 134218242;
    *(void **)((char *)__p + 4) = v22;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = v23;
    __int16 v16 = "#I Using overridden value %llu for %s";
    uint64_t v17 = v20;
    goto LABEL_15;
  }
  if (v21)
  {
    unint64_t v24 = v25;
    if (v26 < 0) {
      unint64_t v24 = (void **)v25[0];
    }
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = v24;
    WORD2(__p[1]) = 2048;
    *(void **)((char *)&__p[1] + 6) = a4;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Value for %s is not overridden, using default %llu", (uint8_t *)__p, 0x16u);
  }
  *a5 = (uint64_t)a4;
LABEL_21:
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
}

void sub_10070D7A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10070D7F0(uint64_t a1)
{
  uint64_t v2 = +[NSTimeZone localTimeZone];
  int v3 = [(NSTimeZone *)v2 secondsFromGMT];
  if (v3 >= 0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = -v3;
  }
  return ((int)([(NSDateComponents *)[+[NSCalendar currentCalendar] componentsInTimeZone:v2 fromDate:a1] hour]+ v4 / 0xE10)% 24);
}

void sub_10070D884(os_log_t *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a3[2];
  uint64_t v7 = *a1;
  BOOL v8 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = a2;
      __int16 v19 = 2048;
      uint64_t v20 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s has %zu entries", buf, 0x16u);
    }
    BOOL v11 = (void *)*a3;
    uint64_t v9 = a3 + 1;
    uint64_t v10 = v11;
    if (v11 != v9)
    {
      do
      {
        BOOL v12 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = *((_DWORD *)v10 + 8);
          sub_1001D44F4(v10[5], buf);
          __int16 v14 = v21 >= 0 ? buf : *(unsigned char **)buf;
          *(_DWORD *)__int16 v22 = 67109378;
          int v23 = v13;
          __int16 v24 = 2080;
          uint64_t v25 = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Index: %u, Value: %s", v22, 0x12u);
          if (v21 < 0) {
            operator delete(*(void **)buf);
          }
        }
        uint64_t v15 = (void *)v10[1];
        if (v15)
        {
          do
          {
            __int16 v16 = v15;
            uint64_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            __int16 v16 = (void *)v10[2];
            BOOL v17 = *v16 == (void)v10;
            uint64_t v10 = v16;
          }
          while (!v17);
        }
        uint64_t v10 = v16;
      }
      while (v16 != v9);
    }
  }
  else if (v8)
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: no usage", buf, 0xCu);
  }
}

uint64_t sub_10070DA78(uint64_t a1)
{
  if (sub_10070E2D4(a1))
  {
    if (sub_10121F67C())
    {
      uint64_t v2 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v3 = sub_1001D3CD8();
        unsigned int v4 = "false";
        if (v3) {
          unsigned int v4 = "true";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v4;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Internal build, dumping logs result: %s", buf, 0xCu);
      }
    }
    v19[0] = 0;
    v19[1] = 0;
    uint64_t v20 = 0;
    sub_100058DB0(v19, "Cellular data usage is higher than normal");
    CFStringRef alertHeader = 0;
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v19;
      uint64_t v17 = v20;
    }
    if (SHIBYTE(v17) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v23 = v17;
    }
    CFStringRef v24 = 0;
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)long long buf = __dst;
      uint64_t v27 = v23;
    }
    CFStringRef v25 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v7 = v24;
      CFStringRef v24 = v25;
      v14[0] = (void *)v7;
      sub_1000558F4((const void **)v14);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(*(void **)buf);
    }
    CFStringRef alertHeader = v24;
    CFStringRef v24 = 0;
    sub_1000558F4((const void **)&v24);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(__p[0]);
    }
    v14[0] = 0;
    v14[1] = 0;
    uint64_t v15 = 0;
    sub_100058DB0(v14, "You can change Cellular Data preferences in Settings");
    if (SHIBYTE(v15) < 0)
    {
      sub_10004FC84(v11, v14[0], (unint64_t)v14[1]);
    }
    else
    {
      *(_OWORD *)BOOL v11 = *(_OWORD *)v14;
      uint64_t v12 = v15;
    }
    if (SHIBYTE(v12) < 0)
    {
      sub_10004FC84(&__dst, v11[0], (unint64_t)v11[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)v11;
      uint64_t v23 = v12;
    }
    CFStringRef v21 = 0;
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)long long buf = __dst;
      uint64_t v27 = v23;
    }
    CFStringRef v24 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v8 = v21;
      CFStringRef v21 = v24;
      CFStringRef v25 = v8;
      sub_1000558F4((const void **)&v25);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(*(void **)buf);
    }
    CFStringRef v9 = v21;
    CFStringRef v13 = v21;
    CFStringRef v21 = 0;
    sub_1000558F4((const void **)&v21);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[0]);
    }
    if (sub_1001D3C48(a1 + 240, alertHeader, v9, @"Dismiss", @"Settings", (uint64_t)"prefs:root=MOBILE_DATA_SETTINGS_ID&path=SHOW_ALL", 15))
    {
      uint64_t v6 = 1;
    }
    else
    {
      uint64_t v6 = 2;
    }
    sub_1000558F4((const void **)&v13);
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[0]);
    }
    sub_1000558F4((const void **)&alertHeader);
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    uint64_t v6 = 0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Usage alert has been disabled, not alerting the user", buf, 2u);
      return 0;
    }
  }
  return v6;
}

void sub_10070DE20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,const void *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  sub_1000558F4((const void **)(v35 - 104));
  if (*(char *)(v35 - 73) < 0) {
    operator delete(*(void **)(v35 - 96));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_1000558F4(&a29);
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(a1);
}

void sub_10070DF1C(NSObject *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5, unsigned int a6)
{
  BOOL v12 = os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT);
  if (v12)
  {
    CFStringRef v13 = v37;
    sub_1001D44F4(a3, v37);
    if (v38 < 0) {
      CFStringRef v13 = (void **)v37[0];
    }
    sub_1001D44F4(a4, v35);
    int v14 = v36;
    uint64_t v15 = (void **)v35[0];
    sub_1001D44F4(a5, __p);
    __int16 v16 = v35;
    if (v14 < 0) {
      __int16 v16 = v15;
    }
    if (v34 >= 0) {
      uint64_t v17 = __p;
    }
    else {
      uint64_t v17 = (void **)__p[0];
    }
    if (a6 > 2) {
      uint64_t v18 = "Usage Alert Response Unknown";
    }
    else {
      uint64_t v18 = off_1019FE588[a6];
    }
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v40 = 2080;
    double v41 = v13;
    __int16 v42 = 2080;
    xpc_object_t v43 = v16;
    __int16 v44 = 2080;
    id v45 = v17;
    __int16 v46 = 2080;
    uint64_t v47 = v18;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Usage alert metric with - Reason: %u, Today's usage so far: %s, Projected usage for the rest of the day: %s, Threshold: %s, User response: %s", buf, 0x30u);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    if (v36 < 0) {
      operator delete(v35[0]);
    }
    if (v38 < 0) {
      operator delete(v37[0]);
    }
  }
  CFStringRef v24 = _NSConcreteStackBlock;
  uint64_t v25 = 3221225472;
  uint64_t v26 = sub_100710498;
  uint64_t v27 = &unk_1019FE288;
  unint64_t v28 = a3;
  unint64_t v29 = a4;
  unint64_t v30 = a5;
  int v31 = a2;
  unsigned int v32 = a6;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v12);
  uint64_t v20 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8007Bu);
  *(void *)long long buf = v20;
  if (v20)
  {
    CFStringRef v21 = sub_10001C8F4(8);
    uint64_t v23 = *v21;
    __int16 v22 = (std::__shared_weak_count *)v21[1];
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v23) {
      operator new();
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v20)
    {
      wis::MetricContainer::~MetricContainer(v20);
      operator delete();
    }
  }
}

void sub_10070E218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,wis::MetricContainer *a33)
{
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_100129880(&a33, 0);
  _Unwind_Resume(a1);
}

BOOL sub_10070E2D4(uint64_t a1)
{
  BOOL v8 = sub_10121F67C() != 0;
  uint64_t v2 = sub_100365D74();
  sub_100058DB0(__p, "UsageAlertAlgorithm::ShowUsageAlert");
  BOOL v3 = sub_1002260B0(v2, (void **)__p, &v8);
  BOOL v4 = v3;
  if (v10 < 0)
  {
    operator delete(*(void **)__p);
    if (v4) {
      return v8;
    }
  }
  else if (v3)
  {
    return v8;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (v8) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User preference for show usage alert is not stored, assuming %s", __p, 0xCu);
  }
  return v8;
}

void sub_10070E3EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10070E410(void *a1, uint64_t a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10070E52C;
  xpc_object_t v9[3] = &unk_1019BB7D8;
  _OWORD v9[4] = a1;
  v9[5] = a2;
  void v9[6] = a3;
  BOOL v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  CFStringRef v7 = v6;
  BOOL v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v5;
  BOOL v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
}

void sub_10070E52C(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v103 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v103);
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = +[NSDate date];
  uint64_t v6 = *(void **)(v2 + 64);
  if (!v6) {
    goto LABEL_7;
  }
  int v7 = *(_DWORD *)(v2 + 72);
  if (objc_msgSend(objc_msgSend(*(id *)(v2 + 64), "tag"), "unsignedIntValue") != v7) {
    goto LABEL_7;
  }
  objc_msgSend(objc_msgSend(v6, "timeStamp"), "timeIntervalSinceDate:", v5);
  unsigned int v9 = (int)v8;
  if ((int)v8 < 0) {
    unsigned int v9 = -v9;
  }
  if (v9 > 0xE0F
    || (int v10 = sub_10070D7F0((uint64_t)v5), v10 != sub_10070D7F0((uint64_t)[v6 timeStamp])))
  {
LABEL_7:

    id v11 = [*(id *)(v2 + 56) createEntity];
    *(void *)(v2 + 64) = v11;
    if (!v11)
    {
      unint64_t v29 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v112.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#E Failed to create usage record", (uint8_t *)&v112, 2u);
      }
      goto LABEL_80;
    }
    [v11 setTimeStamp:v5];
    objc_msgSend(*(id *)(v2 + 64), "setKind:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 256));
    objc_msgSend(*(id *)(v2 + 64), "setTag:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v2 + 72)));
    objc_msgSend(*(id *)(v2 + 64), "setMetadata:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", -[NSTimeZone secondsFromGMT](+[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"), "secondsFromGMT")));
  }
  BOOL v12 = *(void **)(v2 + 64);
  if (v12)
  {
    objc_msgSend(v12, "setWwanIN:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", (char *)objc_msgSend(objc_msgSend(*(id *)(v2 + 64), "wwanIN"), "unsignedLongLongValue") + v3));
    objc_msgSend(v12, "setWwanOUT:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", (char *)objc_msgSend(objc_msgSend(v12, "wwanOUT"), "unsignedLongLongValue") + v4));
    [*(id *)(v2 + 48) save];
    if (objc_msgSend(objc_msgSend(v12, "timeStamp"), "compare:", sub_100710504(-1, 23, 59, 59)) == (id)1)
    {
      unsigned int v104 = sub_10070D7F0((uint64_t)[v12 timeStamp]);
      CFStringRef v13 = sub_1007111A4((uint64_t **)(v2 + 104), v104, &v104);
      void v13[5] = (uint64_t *)((char *)v13[5] + v4 + v3);
      unint64_t v14 = qword_101B0D558 + v4 + v3;
      qword_101B0D558 = v14;
      if (v14 >= 0x100000)
      {
        uint64_t v15 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          sub_1001D44F4(v14, &v112);
          int v16 = SHIBYTE(v112.__r_.__value_.__r.__words[2]);
          std::string::size_type v17 = v112.__r_.__value_.__r.__words[0];
          sub_1001D44F4(0x100000uLL, __p);
          uint64_t v18 = &v112;
          if (v16 < 0) {
            uint64_t v18 = (std::string *)v17;
          }
          if (v107 >= 0) {
            __int16 v19 = __p;
          }
          else {
            __int16 v19 = *(unsigned char **)__p;
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v109 = v18;
          __int16 v110 = 2080;
          unsigned int v111 = v19;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I The running counter: %s for data usage has hit the threshold: %s, warranting the usage alert check", buf, 0x16u);
          if (v107 < 0) {
            operator delete(*(void **)__p);
          }
          if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v112.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v20 = *(void **)(v2 + 104);
        if (v20 == (void *)(v2 + 112))
        {
          unint64_t v21 = 0;
        }
        else
        {
          unint64_t v21 = 0;
          do
          {
            __int16 v22 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              int v23 = *((_DWORD *)v20 + 8);
              sub_1001D44F4(v20[5], &v112);
              CFStringRef v24 = (v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? &v112
                  : (std::string *)v112.__r_.__value_.__r.__words[0];
              *(_DWORD *)long long __p = 67109378;
              *(_DWORD *)&__p[4] = v23;
              *(_WORD *)&__p[8] = 2080;
              *(void *)&__p[10] = v24;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Adding up todays usage record from index: %d with record: %s", __p, 0x12u);
              if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v112.__r_.__value_.__l.__data_);
              }
            }
            uint64_t v25 = v20[5];
            uint64_t v26 = (void *)v20[1];
            if (v26)
            {
              do
              {
                uint64_t v27 = v26;
                uint64_t v26 = (void *)*v26;
              }
              while (v26);
            }
            else
            {
              do
              {
                uint64_t v27 = (void *)v20[2];
                BOOL v28 = *v27 == (void)v20;
                uint64_t v20 = v27;
              }
              while (!v28);
            }
            v21 += v25;
            uint64_t v20 = v27;
          }
          while (v27 != (void *)(v2 + 112));
        }
        unint64_t v30 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          sub_1001D44F4(v21, &v112);
          int v31 = (v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v112
              : (std::string *)v112.__r_.__value_.__r.__words[0];
          *(_DWORD *)long long __p = 136315138;
          *(void *)&__p[4] = v31;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Today's data usage so far %s", __p, 0xCu);
          if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v112.__r_.__value_.__l.__data_);
          }
        }
        unsigned int v32 = (void *)(v2 + 184);
        unint64_t v33 = *(void *)(v2 + 184);
        if (v21 >= v33)
        {
          id v39 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            sub_1001D44F4(v33, &v112);
            __int16 v40 = (v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &v112
                : (std::string *)v112.__r_.__value_.__r.__words[0];
            *(_DWORD *)long long __p = 136315138;
            *(void *)&__p[4] = v40;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Today's data usage so far is more than: %s, alerting the user", __p, 0xCu);
            if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v112.__r_.__value_.__l.__data_);
            }
          }
          int v41 = sub_10070DA78(v2);
          unsigned int v42 = v41 - 1;
          if (v41 == 2) {
            unsigned int v43 = 2;
          }
          else {
            unsigned int v43 = v41 == 1;
          }
          sub_10070DF1C(*(NSObject **)(v2 + 40), 0, v21, 0, *(void *)(v2 + 184), v43);
          if (v42 <= 1)
          {
            __int16 v44 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v112.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Remembering that daily usage threshold alert was shown to the user", (uint8_t *)&v112, 2u);
            }
            id v45 = (uint64_t **)sub_100365D74();
            sub_100058DB0(&v112, "UsageAlertAlgorithm::DailyThresholdAlertShown");
            __p[0] = 1;
            sub_1002264FC(v45, &v112, __p);
            if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v112.__r_.__value_.__l.__data_);
            }
          }
          unint64_t v46 = *(void *)(v2 + 208) * *(void *)(v2 + 184);
          *(void *)(v2 + 184) = v46;
          uint64_t v47 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            sub_1001D44F4(v46, &v112);
            uint64_t v48 = (v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &v112
                : (std::string *)v112.__r_.__value_.__r.__words[0];
            *(_DWORD *)long long __p = 136315138;
            *(void *)&__p[4] = v48;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Per day threshold has been increased to %s", __p, 0xCu);
            if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v112.__r_.__value_.__l.__data_);
            }
          }
          int64x2_t v49 = (uint64_t **)sub_100365D74();
          sub_100058DB0(&v112, "UsageAlertAlgorithm::PerDayUsageThreshold");
          sub_100226428(v49, &v112, v32);
        }
        else
        {
          BOOL v105 = 0;
          uint64_t v34 = sub_100365D74();
          sub_100058DB0(&v112, "UsageAlertAlgorithm::DailyThresholdAlertShown");
          sub_1002260B0(v34, (void **)&v112.__r_.__value_.__l.__data_, &v105);
          if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v112.__r_.__value_.__l.__data_);
          }
          if (v105)
          {
            uint64_t v35 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v112.__r_.__value_.__l.__data_) = 0;
              char v36 = "#I Daily usage threshold alert has been already shown, not predicting the usage for the rest of the day";
              long long v37 = v35;
              uint32_t v38 = 2;
LABEL_78:
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v36, (uint8_t *)&v112, v38);
              goto LABEL_79;
            }
            goto LABEL_79;
          }
          uint64_t v50 = +[NSDate date];
          [(NSDate *)v50 timeIntervalSinceDate:*(void *)(v2 + 136)];
          double v52 = v51;
          if (v51 < 604800.0)
          {
            long long v53 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              long long v54 = [(NSString *)[(NSDate *)v50 description] UTF8String];
              id v55 = objc_msgSend(objc_msgSend(*(id *)(v2 + 136), "description"), "UTF8String");
              LODWORD(v112.__r_.__value_.__l.__data_) = 136315650;
              *(std::string::size_type *)((char *)v112.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
              WORD2(v112.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v112.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v55;
              HIWORD(v112.__r_.__value_.__r.__words[2]) = 2048;
              unint64_t v113 = (unint64_t)v52;
              char v36 = "#I The sample size is small, not generating alerts, now: %s, oldest date: %s, with gap: %llu";
              long long v37 = v53;
              uint32_t v38 = 32;
              goto LABEL_78;
            }
LABEL_79:
            qword_101B0D558 = 0;
            goto LABEL_80;
          }
          long long v57 = (void *)(v2 + 88);
          uint64_t v56 = *(void *)(v2 + 88);
          if (!v56) {
            goto LABEL_92;
          }
          unsigned int v58 = *(_DWORD *)(v2 + 120);
          uint64_t v59 = (void *)(v2 + 88);
          do
          {
            unsigned int v60 = *(_DWORD *)(v56 + 32);
            BOOL v61 = v60 >= v58;
            if (v60 >= v58) {
              long long v62 = (uint64_t *)v56;
            }
            else {
              long long v62 = (uint64_t *)(v56 + 8);
            }
            if (v61) {
              uint64_t v59 = (void *)v56;
            }
            uint64_t v56 = *v62;
          }
          while (*v62);
          if (v59 != v57 && *((_DWORD *)v59 + 8) <= v58)
          {
            unint64_t v63 = 0;
            do
            {
              CFDictionaryRef v88 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                int v89 = *((_DWORD *)v59 + 8);
                sub_1001D44F4(v59[5], &v112);
                uint64_t v90 = &v112;
                if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v90 = (std::string *)v112.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)long long __p = 67109378;
                *(_DWORD *)&__p[4] = v89;
                *(_WORD *)&__p[8] = 2080;
                *(void *)&__p[10] = v90;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I Adding up todays usage record from index: %d with record: %s from past records", __p, 0x12u);
                if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v112.__r_.__value_.__l.__data_);
                }
              }
              uint64_t v91 = v59[5];
              uint64_t v92 = (void *)v59[1];
              if (v92)
              {
                do
                {
                  CFArrayRef v93 = v92;
                  uint64_t v92 = (void *)*v92;
                }
                while (v92);
              }
              else
              {
                do
                {
                  CFArrayRef v93 = (void *)v59[2];
                  BOOL v28 = *v93 == (void)v59;
                  uint64_t v59 = v93;
                }
                while (!v28);
              }
              v63 += v91;
              uint64_t v59 = v93;
            }
            while (v93 != v57);
          }
          else
          {
LABEL_92:
            unint64_t v63 = 0;
          }
          long long v64 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            sub_1001D44F4(v21, &v112);
            int v65 = SHIBYTE(v112.__r_.__value_.__r.__words[2]);
            std::string::size_type v66 = v112.__r_.__value_.__r.__words[0];
            sub_1001D44F4(v63, __p);
            long long v67 = &v112;
            if (v65 < 0) {
              long long v67 = (std::string *)v66;
            }
            if (v107 >= 0) {
              uint64_t v68 = __p;
            }
            else {
              uint64_t v68 = *(unsigned char **)__p;
            }
            *(_DWORD *)long long buf = 136315394;
            uint64_t v109 = v67;
            __int16 v110 = 2080;
            unsigned int v111 = v68;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Today's usage so far: %s, past usage for the rest of the day: %s", buf, 0x16u);
            if (v107 < 0) {
              operator delete(*(void **)__p);
            }
            if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v112.__r_.__value_.__l.__data_);
            }
            long long v64 = *(NSObject **)(v2 + 40);
          }
          unint64_t v69 = v63 + v21;
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            sub_1001D44F4(v63 + v21, &v112);
            int v70 = SHIBYTE(v112.__r_.__value_.__r.__words[2]);
            std::string::size_type v71 = v112.__r_.__value_.__r.__words[0];
            sub_1001D44F4(*(void *)(v2 + 128), __p);
            long long v72 = &v112;
            if (v70 < 0) {
              long long v72 = (std::string *)v71;
            }
            if (v107 >= 0) {
              long long v73 = __p;
            }
            else {
              long long v73 = *(unsigned char **)__p;
            }
            *(_DWORD *)long long buf = 136315394;
            uint64_t v109 = v72;
            __int16 v110 = 2080;
            unsigned int v111 = v73;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Projected total: %s with daily usage average being: %s", buf, 0x16u);
            if (v107 < 0) {
              operator delete(*(void **)__p);
            }
            if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v112.__r_.__value_.__l.__data_);
            }
          }
          unint64_t v74 = *(void *)(v2 + 192);
          if (v69 > v74)
          {
            unint64_t v75 = *(void *)(v2 + 128) * *(void *)(v2 + 200);
            char v76 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
            {
              sub_1001D44F4(v75, &v112);
              int v77 = SHIBYTE(v112.__r_.__value_.__r.__words[2]);
              std::string::size_type v78 = v112.__r_.__value_.__r.__words[0];
              sub_1001D4874(__p);
              long long v79 = &v112;
              if (v77 < 0) {
                long long v79 = (std::string *)v78;
              }
              if (v107 >= 0) {
                char v80 = __p;
              }
              else {
                char v80 = *(unsigned char **)__p;
              }
              *(_DWORD *)long long buf = 136315394;
              uint64_t v109 = v79;
              __int16 v110 = 2080;
              unsigned int v111 = v80;
              _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Current threshold: %s, and projected total is %s times the threshold", buf, 0x16u);
              if (v107 < 0) {
                operator delete(*(void **)__p);
              }
              if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v112.__r_.__value_.__l.__data_);
              }
            }
            if (v69 > v75)
            {
              long long v81 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v112.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I User is using more data today than usual", (uint8_t *)&v112, 2u);
              }
              unsigned int v82 = sub_10070DA78(v2);
              if (v82 == 2) {
                unsigned int v83 = 2;
              }
              else {
                unsigned int v83 = v82 == 1;
              }
              sub_10070DF1C(*(NSObject **)(v2 + 40), 1, v21, v63, v75, v83);
              long long v84 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
              {
                if (v82 > 2) {
                  long long v85 = "Usage Alert Response Unknown";
                }
                else {
                  long long v85 = off_1019FE588[v82];
                }
                LODWORD(v112.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)v112.__r_.__value_.__r.__words + 4) = (std::string::size_type)v85;
                _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I User's response for the alert was %s", (uint8_t *)&v112, 0xCu);
              }
              while (1)
              {
                *(void *)(v2 + 200) *= *(void *)(v2 + 208);
                CFTypeID v94 = (uint64_t **)sub_100365D74();
                sub_100058DB0(&v112, "UsageAlertAlgorithm::AlertThresholdFactor");
                sub_100226428(v94, &v112, (void *)(v2 + 200));
                if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v112.__r_.__value_.__l.__data_);
                }
                std::string::size_type v95 = *(void *)(v2 + 200);
                unint64_t v96 = *(void *)(v2 + 128) * v95;
                int v97 = *(NSObject **)(v2 + 40);
                BOOL v98 = os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT);
                if (v75 >= v96) {
                  break;
                }
                if (v98)
                {
                  LODWORD(v112.__r_.__value_.__l.__data_) = 134218240;
                  *(std::string::size_type *)((char *)v112.__r_.__value_.__r.__words + 4) = v95;
                  WORD2(v112.__r_.__value_.__r.__words[1]) = 2048;
                  *(std::string::size_type *)((char *)&v112.__r_.__value_.__r.__words[1] + 6) = v96;
                  _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Increasing the threshold factor to %llu, current threshold is %llu", (uint8_t *)&v112, 0x16u);
                }
                unint64_t v75 = v96;
                if (v69 <= v96) {
                  goto LABEL_79;
                }
              }
              if (v98)
              {
                sub_1001D44F4(v96, &v112);
                int v99 = SHIBYTE(v112.__r_.__value_.__r.__words[2]);
                std::string::size_type v100 = v112.__r_.__value_.__r.__words[0];
                sub_1001D44F4(v75, __p);
                CFDictionaryRef v101 = &v112;
                if (v99 < 0) {
                  CFDictionaryRef v101 = (std::string *)v100;
                }
                if (v107 >= 0) {
                  CFTypeID v102 = __p;
                }
                else {
                  CFTypeID v102 = *(unsigned char **)__p;
                }
                *(_DWORD *)long long buf = 136315394;
                uint64_t v109 = v101;
                __int16 v110 = 2080;
                unsigned int v111 = v102;
                _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Next threshold: %s has a lower value than current threshold: %s", buf, 0x16u);
                if (v107 < 0) {
                  operator delete(*(void **)__p);
                }
                if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v112.__r_.__value_.__l.__data_);
                }
              }
              sub_10070CF88(v2);
            }
            goto LABEL_79;
          }
          CFArrayRef v86 = *(NSObject **)(v2 + 40);
          if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_79;
          }
          sub_1001D44F4(v74, &v112);
          if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v87 = &v112;
          }
          else {
            long long v87 = (std::string *)v112.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long __p = 136315138;
          *(void *)&__p[4] = v87;
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I But today's projected total usage is less than the per day usage limit of %s, not showing the alert", __p, 0xCu);
        }
        if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v112.__r_.__value_.__l.__data_);
        }
        goto LABEL_79;
      }
    }
  }
LABEL_80:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v103);
}

void sub_10070F360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a11);
  _Unwind_Resume(a1);
}

BOOL sub_10070F3C0(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_10070F530;
  v4[3] = &unk_1019FE1E8;
  void v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _OWORD v6[2] = sub_100711274;
  uint64_t v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  int v7 = v6;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    int v10 = sub_10005AEC4;
    id v11 = &unk_10199E470;
    BOOL v12 = &v14;
    CFStringRef v13 = &v7;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    int v10 = sub_10005A160;
    id v11 = &unk_10199E470;
    BOOL v12 = &v14;
    CFStringRef v13 = &v7;
    dispatch_sync(v1, &block);
  }
  return v14 != 0;
}

BOOL sub_10070F530(uint64_t a1)
{
  return sub_10070E2D4(*(void *)(a1 + 32));
}

void sub_10070F538(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_10070F654;
  void v8[3] = &unk_1019BB378;
  _OWORD v8[4] = a1;
  char v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  int v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v4;
  id v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_10070F654(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&__p, "UsageAlertAlgorithm::ShowUsageAlert");
  uint64_t v4 = (unsigned char *)(a1 + 40);
  int v5 = sub_1002264FC(v3, &__p, (unsigned __int8 *)(a1 + 40));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v6 = *(NSObject **)(v2 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      return;
    }
    if (*v4) {
      double v8 = "true";
    }
    else {
      double v8 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
    char v9 = "#I Saving the preference of show usage alert to %s";
    int v10 = v6;
    uint32_t v11 = 12;
  }
  else
  {
    if (!v7) {
      return;
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    char v9 = "#E Failed to save the preference of show usage alert";
    int v10 = v6;
    uint32_t v11 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&__p, v11);
}

void sub_10070F788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10070F7AC(uint64_t a1, const void **a2)
{
  uint64_t v3 = a1 + 8;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _OWORD v6[2] = sub_10070F8A0;
  uint64_t v6[3] = &unk_1019FE208;
  v6[4] = a1;
  sub_100058198(&v7, a2);
  double v8 = v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  void block[2] = sub_100711288;
  block[3] = &unk_10199E470;
  block[4] = v3;
  block[5] = &v8;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
  return sub_100057D78(&v7);
}

void sub_10070F8A0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40));
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = @"kCTCellularUsagePerDayUsageThreshold";
  v4[1] = @"kCTCellularUsagePerDayUsageAllowance";
  void v4[2] = @"kCTCellularUsageAlertThresholdFactor";
  v4[3] = @"kCTCellularUsageAlertThresholdFactorGrowthRate";
  if (Count > 0)
  {
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = (const void *)v4[v5];
      memset(&__p, 0, sizeof(__p));
      memset(&buf, 0, sizeof(buf));
      ctu::cf::assign();
      std::string __p = buf;
      CFBooleanRef Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v6);
      double v8 = Value;
      if (Value && (CFTypeID v9 = CFGetTypeID(Value), v9 == CFNumberGetTypeID()))
      {
        std::string::size_type v26 = 0;
        buf.__r_.__value_.__r.__words[0] = 0;
        ctu::cf::assign((ctu::cf *)&buf, v8, v10);
        std::string::size_type v26 = buf.__r_.__value_.__r.__words[0];
        uint32_t v11 = (uint64_t **)sub_100365D74();
        int v12 = sub_100226428(v11, &__p, &v26);
        CFStringRef v13 = v2[5];
        BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
        if (!v12)
        {
          if (!v14) {
            goto LABEL_18;
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
          int v16 = v13;
          std::string::size_type v17 = "#E Setting value for %s has failed";
LABEL_16:
          uint32_t v18 = 12;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&buf, v18);
          goto LABEL_18;
        }
        if (v14)
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v15 = &__p;
          }
          else {
            uint64_t v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v26;
          int v16 = v13;
          std::string::size_type v17 = "#I Value for %s has been set to %llu";
          uint32_t v18 = 22;
          goto LABEL_17;
        }
      }
      else
      {
        __int16 v19 = v2[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v20 = &__p;
          }
          else {
            uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
          int v16 = v19;
          std::string::size_type v17 = "#I Value for %s is not present in the dictionary";
          goto LABEL_16;
        }
      }
LABEL_18:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (++v5 == 4) {
        goto LABEL_36;
      }
    }
  }
  for (uint64_t i = 0; i != 32; i += 8)
  {
    memset(&__p, 0, sizeof(__p));
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __p = buf;
    int v23 = (uint64_t **)sub_100365D74();
    sub_1003660FC(v23, (void **)&__p.__r_.__value_.__l.__data_);
    CFStringRef v24 = v2[5];
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v25 = &__p;
      }
      else {
        uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Value for %s has been reset", (uint8_t *)&buf, 0xCu);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
LABEL_36:
  sub_10070BF3C((uint64_t)v2);
  sub_10070FC64(v2);
  operator delete(v4);
}

void sub_10070FC14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  operator delete(v27);
  _Unwind_Resume(a1);
}

void sub_10070FC64(void *a1)
{
  uint64_t v2 = a1[5];
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    sub_1001D44F4(a1[24], v17);
    int v4 = v18;
    uint64_t v5 = (void **)v17[0];
    sub_1001D44F4(a1[23], __p);
    uint64_t v6 = v17;
    if (v4 < 0) {
      uint64_t v6 = v5;
    }
    if (v16 >= 0) {
      BOOL v7 = __p;
    }
    else {
      BOOL v7 = (void **)__p[0];
    }
    uint64_t v9 = a1[25];
    uint64_t v8 = a1[26];
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v20 = 2080;
    unint64_t v21 = v7;
    __int16 v22 = 2048;
    uint64_t v23 = v8;
    __int16 v24 = 2048;
    uint64_t v25 = v9;
    __int16 v26 = 2048;
    uint64_t v27 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Threshold metric with: Per-day usage allowance: %s, Per-day threshold: %s, Per-day threshold growth rate: %llu, Alert threshold factor: %llu, Alert threshold factor growth rate: %llu", buf, 0x34u);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18 < 0) {
      operator delete(v17[0]);
    }
  }
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
  uint32_t v11 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8007Cu);
  *(void *)std::string buf = v11;
  if (v11)
  {
    int v12 = sub_10001C8F4(8);
    uint64_t v14 = *v12;
    CFStringRef v13 = (std::__shared_weak_count *)v12[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v14) {
      operator new();
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
    wis::MetricContainer::~MetricContainer(v11);
    operator delete();
  }
}

void sub_10070FEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,wis::MetricContainer *a24)
{
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100129880(&a24, 0);
  _Unwind_Resume(a1);
}

const void **sub_10070FF94@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _OWORD v6[2] = sub_10071012C;
  uint64_t v6[3] = &unk_1019FE268;
  v6[4] = a1;
  BOOL v7 = v6;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10071129C;
  xpc_object_t v9[3] = &unk_1019FE568;
  _OWORD v9[4] = a1 + 8;
  v9[5] = &v7;
  CFNumberRef v10 = v9;
  uint64_t v4 = a1 + 24;
  BOOL v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    uint64_t v8 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 3221225472;
    CFStringRef v13 = sub_100711328;
    uint64_t v14 = &unk_10199E470;
    uint64_t v15 = &v8;
    char v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    uint64_t v8 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 3221225472;
    CFStringRef v13 = sub_1007112B0;
    uint64_t v14 = &unk_10199E470;
    uint64_t v15 = &v8;
    char v16 = &v10;
    dispatch_sync(v3, &block);
  }
  sub_10004EFE4(a2, &v8);
  return sub_10005717C(&v8);
}

void sub_100710118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10071012C(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  *a2 = 0;
  *a2 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  std::string __p = 0;
  CFNumberRef v10 = 0;
  uint64_t v11 = 0;
  sub_10059C2D8(&__p, 4uLL);
  sub_10070D3FC(v3, (uint64_t *)__p, (uint64_t *)__p + 1, (uint64_t *)__p + 2, (uint64_t)__p + 24, 0);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3321888768;
  uint64_t v5 = sub_1007102E8;
  uint64_t v6 = &unk_1019FE238;
  uint64_t v7 = v3;
  sub_100057240(&v8, a2);
  sub_1007102E8((uint64_t)v4, @"kCTCellularUsagePerDayUsageThreshold", *(void *)__p);
  v5((uint64_t)v4, @"kCTCellularUsagePerDayUsageAllowance", *((void *)__p + 1));
  v5((uint64_t)v4, @"kCTCellularUsageAlertThresholdFactor", *((void *)__p + 2));
  v5((uint64_t)v4, @"kCTCellularUsageAlertThresholdFactorGrowthRate", *((void *)__p + 3));
  sub_10005717C(&v8);
  if (__p)
  {
    CFNumberRef v10 = __p;
    operator delete(__p);
  }
}

void sub_1007102AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10005717C(v17);
  _Unwind_Resume(a1);
}

const void **sub_1007102E8(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v17 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v13 = 0;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = __p;
    __int16 buf_12 = 2048;
    uint64_t buf_14 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Value for %s is set to %llu", buf, 0x16u);
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = 0;
  *(void *)std::string buf = a3;
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
  if (v7)
  {
    uint64_t v8 = __p[0];
    __p[0] = v7;
    *(void *)std::string buf = v8;
    sub_1000570E8((const void **)buf);
  }
  uint64_t v9 = __p[0];
  uint64_t v11 = __p[0];
  __p[0] = 0;
  sub_1000570E8((const void **)__p);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, v9);
  return sub_1000570E8((const void **)&v11);
}

void sub_10071044C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100710484(uint64_t a1, uint64_t a2)
{
  return sub_100057240((const void **)(a1 + 40), (const void **)(a2 + 40));
}

const void **sub_100710490(uint64_t a1)
{
  return sub_10005717C((const void **)(a1 + 40));
}

uint64_t sub_100710498(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(result + 56);
  *(void *)(a2 + 16) = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 40);
  uint64_t v3 = *(void *)(result + 48);
  *(_DWORD *)(a2 + 52) = v2 | 0x1E;
  *(void *)(a2 + 40) = v3;
  LODWORD(v3) = *(_DWORD *)(result + 60);
  *(_DWORD *)(a2 + 52) = v2 | 0x3E;
  *(_DWORD *)(a2 + 36) = v3;
  return result;
}

int8x16_t sub_1007104D8(uint64_t a1, int8x16_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __int32 v3 = a2[3].i32[3];
  int8x16_t result = vextq_s8(*(int8x16_t *)(v2 + 184), *(int8x16_t *)(v2 + 184), 8uLL);
  a2[1] = result;
  uint64_t v7 = v2 + 200;
  uint64_t v5 = *(void *)(v2 + 200);
  uint64_t v6 = *(void *)(v7 + 8);
  a2[2].i64[0] = v6;
  a2[2].i64[1] = v5;
  a2[3].i32[3] = v3 | 0x3E;
  a2[3].i64[0] = v6;
  return result;
}

id sub_100710504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = +[NSDate date];
  id v9 = objc_alloc_init((Class)NSDateComponents);
  [v9 setDay:a1];
  id v10 = [objc_alloc((Class)NSCalendar) initWithCalendarIdentifier:NSCalendarIdentifierGregorian];
  objc_msgSend(v10, "setTimeZone:", +[NSTimeZone localTimeZone](NSTimeZone, "localTimeZone"));
  id v11 = objc_msgSend(v10, "components:fromDate:", 28, objc_msgSend(v10, "dateByAddingComponents:toDate:options:", v9, v8, 0));
  id v12 = [v11 year];
  id v13 = [v11 month];
  id v14 = [v11 day];

  return sub_1001D4A20((uint64_t)v12, (uint64_t)v13, (uint64_t)v14, a2, a3, a4);
}

void sub_100710614(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007106E0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1007107B8);
  __cxa_rethrow();
}

void sub_100710708(_Unwind_Exception *a1)
{
}

void sub_100710720(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100710758(uint64_t a1)
{
}

uint64_t sub_100710774(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007107B8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007107E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1007107F4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100710810(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100710820(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(uint64_t **)v1;
  uint64_t v25 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v25);
  __int32 v3 = v2[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Initializing workspace for usage alert algorithm", buf, 2u);
  }
  uint64_t v4 = (std::__shared_weak_count *)v2[2];
  if (!v4 || (v5 = v2[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  p_shared_weak_owners = &v6->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v23[5] = _NSConcreteStackBlock;
  _OWORD v23[6] = 3321888768;
  v23[7] = sub_100710CC8;
  v23[8] = &unk_1019FE438;
  v23[9] = v2;
  v23[10] = v5;
  __int16 v24 = v7;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_10017B514();
  id v9 = objc_alloc((Class)AnalyticsWorkspace);
  sub_100058DB0(buf, "UsageAlert");
  if (SHIBYTE(v30) >= 0) {
    id v10 = buf;
  }
  else {
    id v10 = *(uint8_t **)buf;
  }
  id v11 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10, v19, v20);
  id v12 = sub_1001D2EC8();
  if (*((char *)v12 + 23) >= 0) {
    id v13 = v12;
  }
  else {
    id v13 = *(long long **)v12;
  }
  v2[6] = (uint64_t)objc_msgSend(v9, "initWorkspaceWithName:atPath:useReadOnly:", v11, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13), 0);
  if (SHIBYTE(v30) < 0) {
    operator delete(*(void **)buf);
  }
  v2[7] = (uint64_t)[objc_alloc((Class)UsageAnalytics) initWithWorkspace:v2[6] withCache:0];
  uint64_t v14 = v2[3];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  xpc_object_t v23[2] = sub_100710EBC;
  v23[3] = &unk_1019A1BF8;
  uint64_t v15 = v2[18];
  v23[4] = v2;
  *(void *)std::string buf = _NSConcreteStackBlock;
  uint64_t v29 = 0x40000000;
  unint64_t v30 = sub_1005507EC;
  int v31 = &unk_1019E2F88;
  unsigned int v32 = v23;
  unint64_t v33 = v2 + 18;
  uint64_t v34 = v14;
  dispatch_sync(v15, buf);
  Registry::createRestModuleOneTimeUseConnection(&v21, *(Registry **)(v1 + 8));
  ctu::RestModule::connect();
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  char v16 = operator new(0x20uLL);
  *char v16 = off_1019FE478;
  v16[1] = v2;
  void v16[2] = sub_10070D2C8;
  v16[3] = 0;
  int v31 = v16;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/significant_time_change");
  __int16 v17 = operator new(0x20uLL);
  void *v17 = off_1019FE4F8;
  v17[1] = v2;
  _OWORD v17[2] = sub_10070BF3C;
  v17[3] = 0;
  int v31 = v17;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  sub_10070D3FC((uint64_t)v2, v2 + 23, v2 + 24, v2 + 25, (uint64_t)(v2 + 26), 1);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  std::__shared_weak_count::__release_weak(v7);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v25);
  sub_100046B58(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100710C18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_10003F600((void *)(v32 - 128));
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  std::__shared_weak_count::__release_weak(v31);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a25);
  sub_100046B58(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100710CC8(uint64_t a1)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3321888768;
  v9[2] = sub_100710E08;
  xpc_object_t v9[3] = &unk_1019FE408;
  long long v1 = *(_OWORD *)(a1 + 32);
  long long v10 = v1;
  uint64_t v2 = v1;
  __int32 v3 = *(std::__shared_weak_count **)(a1 + 48);
  id v11 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v4 || (v5 = *(void *)(v1 + 8), (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(NSObject **)(v2 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1007107E4;
  block[3] = &unk_1019FE3D8;
  block[5] = v5;
  id v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_100710E08(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    __int32 v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5]) {
        sub_10070FC64(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100710E7C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100710E90(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100710EAC(uint64_t a1)
{
  long long v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100710EBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int32 v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Record shift timer has fired, restarting the algorithm", v3, 2u);
    uint64_t v2 = *(NSObject **)(v1 + 40);
  }
  sub_10070BBF8(v2);
  sub_10070BF3C(v1);
}

void sub_100710F38()
{
}

__n128 sub_100710F4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019FE478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100710FA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FE478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100710FD8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  __int32 v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100711020(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100711060()
{
}

void sub_100711070()
{
}

__n128 sub_100711084(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019FE4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1007110D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FE4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100711110(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  __int32 v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100711158(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100711198()
{
}

uint64_t **sub_1007111A4(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    id v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 8) = *a3;
    void v7[5] = 0;
    std::__shared_weak_count *v7 = 0;
    v7[1] = 0;
    uint64_t v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    long long v10 = (uint64_t *)**a1;
    id v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      id v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_100711274(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void *sub_100711288(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_10071129C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

const void **sub_1007112B0(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    __int32 v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_10005717C(&v6);
  }
  return sub_10005717C(&v5);
}

const void **sub_100711328(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    __int32 v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_10005717C(&v6);
  }
  return sub_10005717C(&v5);
}

void sub_1007113A0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10071140C()
{
}

void *sub_100711430(void *a1, void *a2)
{
  uint64_t v4 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "cb.lockdown");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_1019FE5B0;
  a1[4] = *a2;
  uint64_t v5 = a2[1];
  a1[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = 0;
  return a1;
}

void sub_100711510(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  CarrierBundleLockdownInterface::~CarrierBundleLockdownInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100711544(void *a1)
{
  *a1 = off_1019FE5B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  __int32 v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  CarrierBundleLockdownInterface::~CarrierBundleLockdownInterface((CarrierBundleLockdownInterface *)a1);
}

void sub_1007115B8(void *a1)
{
  sub_100711544(a1);

  operator delete();
}

void sub_1007115F0(uint64_t a1, void *a2, uint64_t a3)
{
  if (*a2 && *(void *)(a3 + 24))
  {
    unsigned int v8 = _NSConcreteStackBlock;
    uint64_t v9 = 1174405120;
    long long v10 = sub_100711788;
    id v11 = &unk_1019FE5E8;
    uint64_t v12 = a1;
    sub_1000F0058((uint64_t)v13, a3);
    int v4 = lockdown_checkin_xpc();
    if (v4)
    {
      uint64_t v5 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v7[0] = 67109120;
        v7[1] = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to checkin with lockdown: 0x%08x", (uint8_t *)v7, 8u);
      }
    }
    sub_10003B34C(v13);
  }
  else
  {
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, " Invalid params for lockdown checkin.", (uint8_t *)v7, 2u);
    }
  }
}

void sub_10071176C(_Unwind_Exception *a1)
{
  sub_10003B34C(v1);
  _Unwind_Resume(a1);
}

void sub_100711788(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(NSObject **)(v3 + 8);
  if (a2 && a3)
  {
    if (os_log_type_enabled(*(os_log_t *)(v3 + 8), OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      uint64_t v10 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received connection from: %@", (uint8_t *)&v9, 0xCu);
    }
    *(void *)(v3 + 48) = a2;
    uint64_t v8 = *(void *)(a1 + 64);
    if (!v8) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v8 + 48))(v8);
  }
  else if (os_log_type_enabled(*(os_log_t *)(v3 + 8), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v9) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Lockdown connection failed.", (uint8_t *)&v9, 2u);
  }
}

uint64_t sub_1007118BC(uint64_t a1, uint64_t a2)
{
  return sub_1000F0058(a1 + 40, a2 + 40);
}

void *sub_1007118C8(uint64_t a1)
{
  return sub_10003B34C((void *)(a1 + 40));
}

void sub_1007118D0(uint64_t a1@<X0>, void *a2@<X8>)
{
  OsLogContext v7 = 0;
  *a2 = 0;
  int v4 = lockdown_receive_message();
  CFTypeRef v6 = v7;
  *(void *)std::string buf = 0;
  sub_100084068(buf, &v6);
  *a2 = *(void *)buf;
  *(void *)std::string buf = 0;
  sub_100057D78((const void **)buf);
  if (v4 || !v7)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Error receiving message: 0x%08x", buf, 8u);
    }
  }
}

void sub_1007119CC(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1007119E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  int v4 = *(NSObject **)(a1 + 8);
  if (!v3)
  {
    BOOL result = os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v15) = 0;
    uint64_t v12 = "Not a valid message. Not sending this message.";
    id v13 = v4;
    uint32_t v14 = 2;
    goto LABEL_12;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 138412290;
    uint64_t v16 = v2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending message to lockdown: %@", (uint8_t *)&v15, 0xCu);
  }
  int v7 = lockdown_send_message();
  if (v7)
  {
    int v8 = v7;
    int v9 = *(NSObject **)(a1 + 8);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v11 = *a2;
    int v15 = 138412546;
    uint64_t v16 = v11;
    __int16 v17 = 1024;
    int v18 = v8;
    uint64_t v12 = "Failed to send message:%@ with error: 0x%08x";
    id v13 = v9;
    uint32_t v14 = 18;
LABEL_12:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v15, v14);
    return 0;
  }
  return 1;
}

uint64_t sub_100711B64(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 48))
  {
    uint64_t v2 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Disconnecting.", v3, 2u);
    }
    BOOL result = lockdown_disconnect();
  }
  *(void *)(v1 + 48) = 0;
  return result;
}

void sub_100711BE8(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    *(void *)std::string buf = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    ctu::MallocZone::MallocZone((ctu::MallocZone *)buf, "CarrierBundleMallocZone", 0);
    CFAllocatorRef allocator = 0;
    ctu::cf::create_allocator((uint64_t *)&allocator, (ctu::cf *)buf, 0, v6);
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(allocator, a2);
    theCFDataRef Data = Mutable;
    if (Mutable) {
      int v8 = sub_100711DE8;
    }
    else {
      int v8 = 0;
    }
    if (v8)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      unint64_t v10 = 0;
      while (1)
      {
        CFIndex v11 = lockdown_recv();
        if (v11 < 1) {
          break;
        }
        CFDataAppendBytes(theData, &MutableBytePtr[v10], v11);
        v10 += v11;
        if (v10 >= a2)
        {
          if (v10 != a2) {
            break;
          }
          if (theData)
          {
            CFTypeID v12 = CFGetTypeID(theData);
            if (v12 == CFDataGetTypeID()) {
              CFMutableDataRef v13 = theData;
            }
            else {
              CFMutableDataRef v13 = 0;
            }
          }
          else
          {
            CFMutableDataRef v13 = 0;
          }
          sub_1000C163C(a3, v13);
          goto LABEL_20;
        }
      }
    }
    else
    {
      int v15 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Unable to allocate data buffer to receive file.", v16, 2u);
      }
    }
    *a3 = 0;
LABEL_20:
    sub_100711DF0((const void **)&theData);
    sub_100711E24((const void **)&allocator);
    if (v20) {
      sub_10004D2C8(v20);
    }
  }
  else
  {
    uint32_t v14 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I File length is not valid.", buf, 2u);
    }
    *a3 = 0;
  }
}

void sub_100711DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100711DE8(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_100711DF0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_100711E24(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_100711E58(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100711ED8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100711F14(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100711F4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100711F7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100711FC0(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  int v4 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1006441D4(&v5);
  *a2 = v5;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100712020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100712038(BiometricKitFactoryInterface *this)
{
  *(void *)this = off_1019FE708;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  BiometricKitFactoryInterface::~BiometricKitFactoryInterface(this);
}

void sub_100712094(BiometricKitFactoryInterface *this)
{
  *(void *)this = off_1019FE708;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BiometricKitFactoryInterface::~BiometricKitFactoryInterface(this);

  operator delete();
}

void sub_100712104()
{
}

void sub_100712208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
    if (!v9)
    {
LABEL_3:
      if (v10) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v9)
  {
    goto LABEL_3;
  }
  dispatch_release(v9);
  if (v10) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void *sub_100712274(void *a1, void *a2, dispatch_object_t *a3, uint64_t *a4)
{
  int v8 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v19, kCtLoggingSystemName, "pp.cb");
  *int v8 = 0;
  v8[1] = 0;
  int v9 = *a3;
  a1[3] = *a3;
  if (v9) {
    dispatch_retain(v9);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &v19);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  v18[0] = off_101999E18;
  v18[1] = sub_1007126B4;
  v18[3] = v18;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v18);
  *a1 = off_1019FE748;
  a1[7] = *a2;
  uint64_t v11 = a2[1];
  a1[8] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *a4;
  *a4 = 0;
  a1[9] = v12;
  sub_100058DB0(&__p, "ActivationCarrierInfo");
  uint32_t v14 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  a1[14] = 0;
  a1[13] = 0;
  a1[12] = a1 + 13;
  return a1;
}

void sub_100712554(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_1007126B4(int a1)
{
  uint64_t v1 = "pp.cb.?";
  if (a1 == 2) {
    uint64_t v1 = "pp.cb.2";
  }
  if (a1 == 1) {
    return "pp.cb.1";
  }
  else {
    return v1;
  }
}

void sub_1007126E0(uint64_t a1)
{
  *(void *)a1 = off_1019FE748;
  sub_100088048(a1 + 96, *(void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  ActivationCarrierBundleInterface::~ActivationCarrierBundleInterface((ActivationCarrierBundleInterface *)a1);
}

void sub_1007127C8(uint64_t a1)
{
  sub_1007126E0(a1);

  operator delete();
}

void sub_100712800(uint64_t a1)
{
}

void sub_100712810(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_10071285C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100712874(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 80));
}

void sub_10071287C(uint64_t a1@<X0>, uint64_t a2@<X1>, CFDictionaryRef *a3@<X2>, int a4@<W3>, __CFDictionary **a5@<X8>)
{
  int v10 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  *a5 = 0;
  *a5 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *a3);
  uint64_t v11 = (const void *)kCTPostponementInfoIMSI;
  CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(*a3, kCTPostponementInfoIMSI);
  CFStringRef v13 = v12;
  if (!v12) {
    goto LABEL_71;
  }
  CFTypeID v14 = CFGetTypeID(v12);
  if (v14 != CFStringGetTypeID()) {
    goto LABEL_71;
  }
  value.__r_.__value_.__r.__words[0] = 0;
  if (CFDictionaryGetValueIfPresent(*a3, kCTPostponementInfoIMSIOverride, (const void **)&value.__r_.__value_.__l.__data_))
  {
    CFBooleanRef v15 = (const __CFBoolean *)value.__r_.__value_.__r.__words[0];
    if (value.__r_.__value_.__r.__words[0])
    {
      CFTypeID v16 = CFGetTypeID(value.__r_.__value_.__l.__data_);
      if (v16 == CFBooleanGetTypeID() && CFBooleanGetValue(v15) == 1)
      {
        CFTypeID TypeID = (__CFString *)CFDictionaryGetValue(*a3, kCTPostponementInfoMEID);
        CFStringRef v18 = TypeID;
        if (TypeID)
        {
          CFTypeID v19 = CFGetTypeID(TypeID);
          CFTypeID TypeID = (__CFString *)CFStringGetTypeID();
          if ((__CFString *)v19 != TypeID) {
            CFStringRef v18 = 0;
          }
        }
        int v20 = capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)TypeID);
        if (v18) {
          int v21 = v20;
        }
        else {
          int v21 = 0;
        }
        if (v21 == 1 && CFStringGetLength(v18) >= 1)
        {
          sub_10010F3F0(*a5, @"MCC", @"101");
          sub_100715710(*a5, (void *)qword_101B13EC0, @"101FAC");
          __int16 v22 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            uint64_t v23 = "#I Overriding IMSI to 101FAC";
LABEL_43:
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&buf, 2u);
          }
        }
        else
        {
          sub_10010F3F0(*a5, @"MCC", @"000");
          sub_100715710(*a5, (void *)qword_101B13EC0, @"000FAC");
          __int16 v22 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            uint64_t v23 = "#I Overriding IMSI to 000FAC";
            goto LABEL_43;
          }
        }
        sub_10010F3F0(*a5, @"MNC", @"FAC");
        goto LABEL_71;
      }
    }
  }
  if (a4)
  {
    sub_100057240((const void **)&theDict, (const void **)a5);
    __int16 v24 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    memset(&__dst, 0, sizeof(__dst));
    memset(&v102, 0, sizeof(v102));
    sub_10071377C(a1, a2, (uint64_t)&__dst, (uint64_t)&v102);
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_39;
    }
    std::string::size_type v26 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v26 = v102.__r_.__value_.__l.__size_;
    }
    if (!v26)
    {
LABEL_39:
      uint64_t v34 = *v24;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#E 1X Subscriber Info could not be retrieved", (uint8_t *)&buf, 2u);
      }
      goto LABEL_62;
    }
    CFDictionaryGetValue(theDict, v11);
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __s1 = buf;
    std::string::size_type v27 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
    char v28 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
    char v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v30 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v30 = buf.__r_.__value_.__l.__size_;
    }
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v27 = v102.__r_.__value_.__l.__size_;
    }
    if (v30 != v27) {
      goto LABEL_46;
    }
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v31 = &v102;
    }
    else {
      int v31 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (memcmp(__s1.__r_.__value_.__l.__data_, v31, buf.__r_.__value_.__l.__size_))
      {
LABEL_46:
        uint64_t v35 = *v24;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I IMSI from Activation Info and 1X Subscriber Info are not matching", (uint8_t *)&buf, 2u);
        }
        goto LABEL_60;
      }
    }
    else if (*((unsigned char *)&buf.__r_.__value_.__s + 23))
    {
      p_s1 = &__s1;
      uint64_t v33 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      while (p_s1->__r_.__value_.__s.__data_[0] == v31->__r_.__value_.__s.__data_[0])
      {
        p_s1 = (std::string *)((char *)p_s1 + 1);
        int v31 = (std::string *)((char *)v31 + 1);
        if (!--v33) {
          goto LABEL_48;
        }
      }
      goto LABEL_46;
    }
LABEL_48:
    char v36 = *v24;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I IMSI from Activation Info and 1X Subscriber Info are matching, Adding 1x IMSI and GW IMSI", (uint8_t *)&buf, 2u);
      char v28 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
    }
    long long v37 = theDict;
    if (v28 < 0) {
      sub_10004FC84(&buf, v102.__r_.__value_.__l.__data_, v102.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v102;
    }
    sub_100715860(v37, @"1xIMSI");
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint32_t v38 = theDict;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __dst;
    }
    sub_100715860(v38, @"GwIMSI");
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
LABEL_60:
    if (v29 < 0) {
      operator delete(__s1.__r_.__value_.__l.__data_);
    }
LABEL_62:
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v102.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    sub_10005717C((const void **)&theDict);
  }
  buf.__r_.__value_.__r.__words[0] = 0;
  __dst.__r_.__value_.__r.__words[0] = 0;
  _CFStringCopyMCCMNCFromIMSI(v13, (const __CFString **)&buf, (CFStringRef *)&__dst);
  if (buf.__r_.__value_.__r.__words[0])
  {
    sub_10010F3F0(*a5, @"MCC", (uint64_t)buf.__r_.__value_.__l.__data_);
    CFRelease(buf.__r_.__value_.__l.__data_);
  }
  if (__dst.__r_.__value_.__r.__words[0])
  {
    sub_10010F3F0(*a5, @"MNC", (uint64_t)__dst.__r_.__value_.__l.__data_);
    CFRelease(__dst.__r_.__value_.__l.__data_);
  }
LABEL_71:
  if (!a4) {
    return;
  }
  sub_100057240((const void **)&v92, (const void **)a5);
  id v39 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  memset(&v102, 0, sizeof(v102));
  memset(&__s1, 0, sizeof(__s1));
  sub_10071377C(a1, a2, (uint64_t)&v102, (uint64_t)&__s1);
  std::string::size_type v40 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v40 = v102.__r_.__value_.__l.__size_;
  }
  if (!v40) {
    goto LABEL_93;
  }
  std::string::size_type v41 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v41 = __s1.__r_.__value_.__l.__size_;
  }
  if (!v41)
  {
LABEL_93:
    uint64_t v48 = *v39;
    int v49 = 0;
    if (os_log_type_enabled(*v39, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#E Failed to retrieve 1x Subscriber Info", (uint8_t *)&buf, 2u);
      int v49 = 0;
    }
    goto LABEL_100;
  }
  CFDictionaryGetValue(v92, v11);
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string __dst = buf;
  std::string::size_type v42 = __s1.__r_.__value_.__l.__size_;
  char v43 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v44 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v44 = __dst.__r_.__value_.__l.__size_;
  }
  if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v42 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  }
  if (v44 != v42) {
    goto LABEL_96;
  }
  if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v45 = &__s1;
  }
  else {
    id v45 = (std::string *)__s1.__r_.__value_.__r.__words[0];
  }
  if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (memcmp(__dst.__r_.__value_.__l.__data_, v45, buf.__r_.__value_.__l.__size_)) {
      goto LABEL_96;
    }
  }
  else if (*((unsigned char *)&buf.__r_.__value_.__s + 23))
  {
    p_dst = &__dst;
    uint64_t v47 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    while (p_dst->__r_.__value_.__s.__data_[0] == v45->__r_.__value_.__s.__data_[0])
    {
      p_dst = (std::string *)((char *)p_dst + 1);
      id v45 = (std::string *)((char *)v45 + 1);
      if (!--v47) {
        goto LABEL_197;
      }
    }
LABEL_96:
    uint64_t v50 = *v39;
    int v49 = 0;
    if (os_log_type_enabled(*v39, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I All values are not available to compare or they are different", (uint8_t *)&buf, 2u);
      int v49 = 0;
    }
    if (v43 < 0) {
      goto LABEL_99;
    }
    goto LABEL_100;
  }
LABEL_197:
  CFArrayRef v86 = *v39;
  if (os_log_type_enabled(*v39, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I IMSI from Activation Info and 1X Subscriber Info are matching, not adding GIDs from Subscriber", (uint8_t *)&buf, 2u);
  }
  int v49 = 1;
  if (v43 < 0) {
LABEL_99:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_100:
  CFDictionaryGetValue(v92, kCTPostponementInfoICCID);
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  long long v51 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  v100[0] = buf.__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v100 + 3) = *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[2] + 3);
  unsigned __int8 v52 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  long long v53 = *(void **)(a1 + 96);
  LODWORD(buf.__r_.__value_.__l.__data_) = a2;
  int v91 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&buf.__r_.__value_.__s.__data_[8], (void *)v51, buf.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = v51;
    *(_DWORD *)BOOL v98 = v100[0];
    *(_DWORD *)&v98[3] = *(_DWORD *)((char *)v100 + 3);
    unsigned __int8 v99 = v52;
  }
  int v54 = v49;
  id v55 = v39;
  uint64_t v56 = (void *)(a1 + 104);
  if (v53 == (void *)(a1 + 104))
  {
    if ((v99 & 0x80) != 0) {
LABEL_130:
    }
      operator delete((void *)buf.__r_.__value_.__l.__size_);
  }
  else
  {
    int data = (int)buf.__r_.__value_.__l.__data_;
    unsigned __int8 v58 = v99;
    if ((v99 & 0x80u) == 0) {
      std::string::size_type v59 = v99;
    }
    else {
      std::string::size_type v59 = buf.__r_.__value_.__r.__words[2];
    }
    if ((v99 & 0x80u) == 0) {
      p_std::string::size_type size = &buf.__r_.__value_.__l.__size_;
    }
    else {
      p_std::string::size_type size = (std::string::size_type *)buf.__r_.__value_.__l.__size_;
    }
    do
    {
      if (*((_DWORD *)v53 + 10) == data)
      {
        uint64_t v61 = *((unsigned __int8 *)v53 + 135);
        uint64_t v62 = (v61 & 0x80u) == 0 ? *((unsigned __int8 *)v53 + 135) : v53[15];
        if (v62 == v59)
        {
          if ((v61 & 0x80) != 0)
          {
            if (!memcmp((const void *)v53[14], p_size, v53[15])) {
              goto LABEL_129;
            }
          }
          else
          {
            if (!*((unsigned char *)v53 + 135)) {
              goto LABEL_129;
            }
            uint64_t v63 = 0;
            while (*((unsigned __int8 *)v53 + v63 + 112) == *((unsigned __int8 *)p_size + v63))
            {
              if (v61 == ++v63) {
                goto LABEL_129;
              }
            }
          }
        }
      }
      long long v64 = (void *)v53[1];
      if (v64)
      {
        do
        {
          int v65 = v64;
          long long v64 = (void *)*v64;
        }
        while (v64);
      }
      else
      {
        do
        {
          int v65 = (void *)v53[2];
          BOOL v66 = *v65 == (void)v53;
          long long v53 = v65;
        }
        while (!v66);
      }
      long long v53 = v65;
    }
    while (v65 != v56);
    long long v53 = v56;
LABEL_129:
    if ((v58 & 0x80) != 0) {
      goto LABEL_130;
    }
  }
  if (v53 != v56)
  {
    memset(&value, 0, sizeof(value));
    memset(&v95, 0, sizeof(v95));
    long long v67 = (_DWORD *)v53[7];
    uint64_t v68 = (_DWORD *)v53[8];
    unint64_t v69 = (void *)v51;
    if (v67 == v68)
    {
      memset(&__p, 0, sizeof(__p));
    }
    else
    {
      int v70 = (_DWORD *)v53[7];
      while (*v70 != 1)
      {
        if (++v70 == v68)
        {
          int v70 = (_DWORD *)v53[8];
          break;
        }
      }
      if (v70 != v68) {
        goto LABEL_143;
      }
      std::string::size_type v71 = (_DWORD *)v53[7];
      while (*v71 != 2)
      {
        if (++v71 == v68)
        {
          std::string::size_type v71 = (_DWORD *)v53[8];
          break;
        }
      }
      if (v71 != v68)
      {
LABEL_143:
        std::string::operator=(&value, (const std::string *)(v53 + 20));
        std::string::operator=(&v95, (const std::string *)(v53 + 23));
        goto LABEL_156;
      }
      memset(&__p, 0, sizeof(__p));
      long long v87 = (char *)subscriber::asString();
      sub_10003ED78(&__p, v87);
      for (uint64_t i = v67 + 1; i != v68; ++i)
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 1;
        strcpy((char *)&__dst, ",");
        std::string::append(&__p, (const std::string::value_type *)&__dst, 1uLL);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        int v89 = (const char *)subscriber::asString();
        size_t v90 = strlen(v89);
        std::string::append(&__p, v89, v90);
      }
    }
    unint64_t v74 = *v55;
    if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#N Not copying GID1/GID2 for GW SIM type %s", (uint8_t *)&__dst, 0xCu);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
LABEL_156:
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
    {
      if (value.__r_.__value_.__l.__size_)
      {
        char v76 = v92;
        if (v54) {
          long long v79 = off_101A32348;
        }
        else {
          long long v79 = off_101A32300;
        }
        sub_10004FC84(&__dst, value.__r_.__value_.__l.__data_, value.__r_.__value_.__l.__size_);
        std::string::size_type v78 = *v79;
LABEL_166:
        sub_1007157A4(v76, v78);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        goto LABEL_170;
      }
    }
    else if (*((unsigned char *)&value.__r_.__value_.__s + 23))
    {
      char v76 = v92;
      int v77 = off_101A32348;
      if (!v54) {
        int v77 = off_101A32300;
      }
      std::string::size_type v78 = *v77;
      std::string __dst = value;
      goto LABEL_166;
    }
    char v80 = *v55;
    if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I GID1 is empty", (uint8_t *)&__dst, 2u);
    }
LABEL_170:
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v95.__r_.__value_.__l.__size_)
      {
        long long v81 = v92;
        if (v54) {
          long long v84 = off_101A32350;
        }
        else {
          long long v84 = off_101A32308;
        }
        sub_10004FC84(&__dst, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
        unsigned int v83 = *v84;
LABEL_180:
        int v73 = v91;
        sub_1007157A4(v81, v83);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        goto LABEL_184;
      }
    }
    else if (*((unsigned char *)&v95.__r_.__value_.__s + 23))
    {
      long long v81 = v92;
      unsigned int v82 = off_101A32350;
      if (!v54) {
        unsigned int v82 = off_101A32308;
      }
      unsigned int v83 = *v82;
      std::string __dst = v95;
      goto LABEL_180;
    }
    long long v85 = *v55;
    int v73 = v91;
    if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I GID2 is empty", (uint8_t *)&__dst, 2u);
    }
LABEL_184:
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v95.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(value.__r_.__value_.__l.__data_);
      if ((v73 & 0x80000000) == 0) {
        goto LABEL_189;
      }
      goto LABEL_188;
    }
    goto LABEL_187;
  }
  long long v72 = *v55;
  unint64_t v69 = (void *)v51;
  int v73 = v91;
  if (os_log_type_enabled(*v55, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Could not find SIM info for adding gids", (uint8_t *)&__dst, 2u);
    if (v91 < 0) {
      goto LABEL_188;
    }
    goto LABEL_189;
  }
LABEL_187:
  if (v73 < 0) {
LABEL_188:
  }
    operator delete(v69);
LABEL_189:
  if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s1.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v102.__r_.__value_.__l.__data_);
  }
  sub_10005717C((const void **)&v92);
}

void sub_1007135E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, void *a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  sub_10005717C(v50);
  _Unwind_Resume(a1);
}

void sub_10071377C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  int v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v10;
  CFTypeID v14 = sub_10004D37C(&v9[1].__m_.__sig, &v20);
  if (v14)
  {
    uint64_t v16 = v14[3];
    CFBooleanRef v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_7;
      }
LABEL_11:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 200))(v16, a2, 3, a3);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 200))(v16, a2, 12, a4);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  CFBooleanRef v15 = 0;
  char v17 = 1;
  if (v16) {
    goto LABEL_11;
  }
LABEL_7:
  CFStringRef v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFTypeID v19 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get SubscriberSimController", v19, 2u);
  }
LABEL_12:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_10071394C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10071396C(uint64_t a1, int a2, CFDictionaryRef *a3)
{
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *a3);
  CFMutableDictionaryRef theDict = MutableCopy;
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Handling %s carrier info", buf, 0xCu);
    CFDictionaryRef MutableCopy = theDict;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"SubscriberIdentityModules");
  if (Value)
  {
    CFDictionaryRemoveValue(theDict, @"SubscriberIdentityModules");
    if (a2 == 3)
    {
      sub_10010F3F0(theDict, kCTPostponementInfoAvailable, @"CarrierInfo");
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v9 = *(void *)(a1 + 72);
      unint64_t v10 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v10;
      if (v10) {
        dispatch_retain(v10);
      }
      (*(void (**)(unsigned char *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v9 + 40))(buf, v9, &object);
      if (object) {
        dispatch_release(object);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      uint64_t v12 = ServiceMap;
      if (v13 < 0)
      {
        CFTypeID v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          uint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      std::string::size_type v44 = (void **)v13;
      char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v44);
      if (v17)
      {
        uint64_t v19 = v17[3];
        CFStringRef v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
LABEL_42:
          sub_10004EFE4(&v38, (CFTypeRef *)&theDict);
          uint64_t v31 = *(void *)buf;
          uint64_t v30 = *(void *)&buf[8];
          if (*(void *)&buf[8]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
          }
          long long v51 = 0;
          uint64_t v32 = operator new(0x20uLL);
          void *v32 = off_1019FE9C8;
          v32[1] = a1;
          v32[2] = v31;
          v32[3] = v30;
          long long v51 = v32;
          (*(void (**)(uint64_t, const void **, uint64_t, void *))(*(void *)v19 + 16))(v19, &v38, 1, v50);
          sub_100687CB0(v50);
          sub_100057D78(&v38);
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          return sub_10005717C((const void **)&theDict);
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      CFStringRef v18 = 0;
      char v20 = 1;
      goto LABEL_42;
    }
    CFTypeRef v37 = 0;
    sub_100058198((const void **)&v36, (const void **)a3);
    CFTypeRef cf = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFTypeRef v23 = cf;
      CFTypeRef cf = Mutable;
      *(void *)std::string buf = v23;
      sub_10005717C((const void **)buf);
    }
    CFDictionaryRef v24 = v36;
    std::string::size_type v44 = _NSConcreteStackBlock;
    uint64_t v45 = 1174405120;
    unint64_t v46 = sub_100714C9C;
    uint64_t v47 = &unk_1019FE878;
    uint64_t v48 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)std::string buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1007154C0;
    long long v53 = &unk_1019FE8E0;
    int v54 = &v44;
    long long context = buf;
    CFDictionaryApplyFunction(v24, (CFDictionaryApplierFunction)sub_100715568, &context);
    sub_10004EFE4(&v37, &cf);
    sub_10005717C((const void **)&v48);
    sub_10005717C(&cf);
    sub_100057D78((const void **)&v36);
    CFDictionaryRef v35 = Value;
    CFRetain(Value);
    CFTypeRef v34 = v37;
    if (v37) {
      CFRetain(v37);
    }
    CFIndex Count = CFDictionaryGetCount(v35);
    std::string::size_type v26 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v27 = "s";
      if (Count == 1) {
        std::string::size_type v27 = "";
      }
      *(_DWORD *)std::string buf = 134218242;
      *(void *)&uint8_t buf[4] = Count;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Handling carrier bundle matching info for %zu SIM%s", buf, 0x16u);
    }
    if (Count)
    {
      long long context = 0;
      char v43 = 0;
      uint64_t v28 = *(void *)(a1 + 72);
      char v29 = *(NSObject **)(a1 + 24);
      dispatch_object_t v41 = v29;
      if (v29) {
        dispatch_retain(v29);
      }
      (*(void (**)(unsigned char **__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v28 + 40))(&context, v28, &v41);
      if (v41) {
        dispatch_release(v41);
      }
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_1007140F8;
      long long v53 = &unk_1019FE780;
      int v54 = (void ***)a1;
      v55[0] = v34;
      if (v34) {
        CFRetain(v34);
      }
      int v57 = a2;
      v55[1] = context;
      uint64_t v56 = v43;
      if (v43) {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::string::size_type v44 = _NSConcreteStackBlock;
      uint64_t v45 = 0x40000000;
      unint64_t v46 = sub_1007154C0;
      uint64_t v47 = &unk_1019FE8E0;
      uint64_t v48 = buf;
      CFTypeRef cf = &v44;
      CFDictionaryApplyFunction(v35, (CFDictionaryApplierFunction)sub_100715568, &cf);
      if (v56) {
        sub_10004D2C8(v56);
      }
      sub_100057D78(v55);
      if (v43) {
        sub_10004D2C8(v43);
      }
    }
    else
    {
      sub_100358C28((uint64_t)&event::activation::basebandActivated, 0);
    }
    sub_100057D78(&v34);
    sub_100057D78((const void **)&v35);
    sub_100057D78(&v37);
  }
  else
  {
    int v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Missing SIMs key in carrier info dictionary", buf, 2u);
    }
  }
  return sub_10005717C((const void **)&theDict);
}

void sub_100713FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,dispatch_object_t a23,char a24,dispatch_object_t object,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007140F8(uint64_t a1, char *a2, CFTypeRef *a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (a2[23] >= 0) {
    int v7 = (subscriber *)a2;
  }
  else {
    int v7 = *(subscriber **)a2;
  }
  uint64_t v8 = subscriber::fromString(v7, a2);
  uint64_t v9 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), v8);
  unint64_t v10 = (os_log_t *)v9;
  if v8 == 1 || (capabilities::ct::supportsGemini(v9))
  {
    CFTypeID v11 = CFGetTypeID(*a3);
    if (v11 == CFDictionaryGetTypeID())
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)*a3);
      CFTypeRef cf = MutableCopy;
      CFMutableDictionaryRef v61 = MutableCopy;
      if (MutableCopy) {
        CFRetain(MutableCopy);
      }
      sub_100058198((const void **)&theDict, (const void **)(a1 + 40));
      CFDictionaryRef v13 = theDict;
      if (theDict) {
        CFTypeID v14 = sub_100080778;
      }
      else {
        CFTypeID v14 = 0;
      }
      if (v14)
      {
        *(void *)std::string buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 1174405120;
        long long v72 = sub_100715270;
        int v73 = &unk_1019FE8A8;
        CFTypeRef v74 = cf;
        if (cf) {
          CFRetain(cf);
        }
        int v75 = v8;
        uint64_t v62 = _NSConcreteStackBlock;
        uint64_t v63 = 0x40000000;
        long long v64 = sub_1007154C0;
        int v65 = &unk_1019FE8E0;
        BOOL v66 = buf;
        context.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
        CFDictionaryApplyFunction(v13, (CFDictionaryApplierFunction)sub_100715568, &context);
        sub_10005717C(&v74);
      }
      sub_100057D78((const void **)&theDict);
      sub_10005717C(&cf);
      CFTypeRef v58 = 0;
      if (a2[23] >= 0) {
        unsigned int v16 = (subscriber *)a2;
      }
      else {
        unsigned int v16 = *(subscriber **)a2;
      }
      uint64_t v17 = subscriber::fromString(v16, v15);
      sub_10004EFE4(&v57, (CFTypeRef *)&v61);
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const void **, uint64_t))(*(void *)v6 + 40))(&v58, v6, v17, &v57, 1);
      sub_100057D78(&v57);
      uint64_t v56 = 0;
      CFTypeRef cf1 = 0;
      *(void *)std::string buf = CFPreferencesCopyValue(@"IMSIOverride", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100225AE0(&cf1, (CFTypeRef *)buf);
      CFStringRef v18 = (os_log_t *)(v6 + 40);
      if (cf1) {
        uint64_t v19 = sub_1000810B8;
      }
      else {
        uint64_t v19 = 0;
      }
      if (!v19) {
        goto LABEL_27;
      }
      if (CFEqual(cf1, @"Reset Carrier Bundle"))
      {
        char v20 = *v18;
        if (os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I IMSI Override is set to Reset Carrier Bundle, clearing off the key", buf, 2u);
        }
        CFPreferencesSetValue(@"IMSIOverride", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_1003F2A04();
        goto LABEL_27;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v6 + 56));
      std::string::size_type v27 = ServiceMap;
      if (v28 < 0)
      {
        char v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v30 = 5381;
        do
        {
          uint64_t v28 = v30;
          unsigned int v31 = *v29++;
          uint64_t v30 = (33 * v30) ^ v31;
        }
        while (v31);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v28;
      uint64_t v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
      if (v32)
      {
        uint64_t v34 = v32[3];
        uint64_t v33 = (std::__shared_weak_count *)v32[4];
        if (v33)
        {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v27);
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v33);
          char v35 = 0;
LABEL_72:
          if ((*(unsigned int (**)(uint64_t))(*(void *)v34 + 16))(v34))
          {
            uint64_t v62 = 0;
            uint64_t v63 = 0;
            long long v64 = 0;
            sub_100058DB0(&v62, "IMSI Override Set");
            memset(&context, 0, sizeof(context));
            sub_100058DB0(&context, "IMSI Override has been set to '");
            memset(buf, 0, sizeof(buf));
            long long v72 = 0;
            ctu::cf::assign();
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            uint64_t v68 = v72;
            if (SHIBYTE(v72) >= 0) {
              uint64_t v50 = __p;
            }
            else {
              uint64_t v50 = (void **)__p[0];
            }
            if (SHIBYTE(v68) >= 0) {
              std::string::size_type v51 = HIBYTE(v68);
            }
            else {
              std::string::size_type v51 = (std::string::size_type)__p[1];
            }
            std::string::append(&context, (const std::string::value_type *)v50, v51);
            if (SHIBYTE(v68) < 0) {
              operator delete(__p[0]);
            }
            std::string::append(&context, "'. It overrides the SIM card and cellular features may not work.\n\n", 0x42uLL);
            std::string::append(&context, "Reset it Settings > Internal Settings > (Low Level) Baseband > Carrier Bundle > Reset Carrier Bundle.", 0x65uLL);
            (*(void (**)(uint64_t, void **, std::string *))(*(void *)v34 + 24))(v34, &v62, &context);
            if (SHIBYTE(context.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(context.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v64) < 0) {
              operator delete(v62);
            }
          }
          if ((v35 & 1) == 0) {
            sub_10004D2C8(v33);
          }
          unsigned __int8 v52 = *v18;
          if (os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I IMSI override has been provided, parsing CB Information", buf, 2u);
          }
          long long v53 = sub_1006B3B68((os_log_t *)(v6 + 40), (const __CFString *)cf1);
          *(void *)std::string buf = v53;
          if (v53) {
            int v54 = sub_100080778;
          }
          else {
            int v54 = 0;
          }
          if (v54)
          {
            uint64_t v56 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v53);
            sub_10010F3F0(v56, kCTPostponementInfoIMSI, @"0000000000000000");
            sub_10010F3F0(v56, kCTPostponementInfoICCID, @"0000000000000000");
            sub_100057D78((const void **)buf);
            goto LABEL_28;
          }
          sub_100057D78((const void **)buf);
LABEL_27:
          uint64_t v56 = 0;
LABEL_28:
          sub_1000558F4(&cf1);
          if (v56) {
            int v21 = sub_1000C06D0;
          }
          else {
            int v21 = 0;
          }
          if (v21) {
            sub_100715468(&v58, (const void **)&v56);
          }
          switch(*(_DWORD *)(a1 + 64))
          {
            case 0:
              __int16 v22 = *v18;
              if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
              {
                uint64_t v23 = asString();
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v23;
                _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Not handling %s carrier info", buf, 0xCu);
              }
              goto LABEL_68;
            case 1:
              sub_10010F3F0((__CFDictionary *)v58, kCTPostponementInfoAvailable, @"DefaultCarrierInfo");
              goto LABEL_49;
            case 2:
              sub_10010F3F0((__CFDictionary *)v58, kCTPostponementInfoAvailable, @"SIMCarrierInfo");
              goto LABEL_49;
            case 3:
              sub_10010F3F0((__CFDictionary *)v58, kCTPostponementInfoAvailable, @"CarrierInfo");
              goto LABEL_49;
            default:
LABEL_49:
              CFTypeRef v55 = v58;
              if (v58) {
                CFRetain(v58);
              }
              uint64_t v37 = *(void *)(a1 + 48);
              CFDictionaryRef v36 = *(std::__shared_weak_count **)(a1 + 56);
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v38 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), v8);
              id v39 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v6 + 56));
              std::string::size_type v40 = v39;
              if (v41 < 0)
              {
                std::string::size_type v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v43 = 5381;
                do
                {
                  uint64_t v41 = v43;
                  unsigned int v44 = *v42++;
                  uint64_t v43 = (33 * v43) ^ v44;
                }
                while (v44);
              }
              std::mutex::lock(v39);
              *(void *)std::string buf = v41;
              uint64_t v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
              if (v45)
              {
                uint64_t v47 = v45[3];
                unint64_t v46 = (std::__shared_weak_count *)v45[4];
                if (v46)
                {
                  atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v40);
                  atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v46);
                  char v48 = 0;
                  goto LABEL_61;
                }
              }
              else
              {
                uint64_t v47 = 0;
              }
              std::mutex::unlock(v40);
              unint64_t v46 = 0;
              char v48 = 1;
LABEL_61:
              sub_10004EFE4(&v62, &v55);
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              int v73 = 0;
              int v49 = operator new(0x30uLL);
              *int v49 = off_1019FEA58;
              v49[1] = v6;
              _OWORD v49[2] = v38;
              v49[3] = v37;
              v49[4] = v36;
              *((_DWORD *)v49 + 10) = v8;
              int v73 = v49;
              (*(void (**)(uint64_t, void **, uint64_t, uint8_t *))(*(void *)v47 + 16))(v47, &v62, v8, buf);
              sub_100687CB0(buf);
              sub_100057D78((const void **)&v62);
              if ((v48 & 1) == 0) {
                sub_10004D2C8(v46);
              }
              if (v36) {
                sub_10004D2C8(v36);
              }
              sub_10005717C(&v55);
LABEL_68:
              sub_10005717C((const void **)&v56);
              sub_10005717C(&v58);
              sub_10005717C((const void **)&v61);
              break;
          }
          return;
        }
      }
      else
      {
        uint64_t v34 = 0;
      }
      std::mutex::unlock(v27);
      uint64_t v33 = 0;
      char v35 = 1;
      goto LABEL_72;
    }
    CFDictionaryRef v24 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Expected a dictionary type for matching information", buf, 2u);
    }
  }
  else
  {
    uint64_t v25 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N Ignoring SIM matching info", buf, 2u);
    }
  }
}

void sub_100714A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, const void *a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,const void *a47)
{
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a46 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if ((v48 & 1) == 0) {
    sub_10004D2C8(v47);
  }
  sub_1000558F4(&a47);
  sub_10005717C(&a16);
  sub_10005717C(&a25);
  _Unwind_Resume(a1);
}

const void **sub_100714C14(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100058198((const void **)(a1 + 40), (const void **)(a2 + 40));
  uint64_t v5 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

const void **sub_100714C5C(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100057D78((const void **)(a1 + 40));
}

void sub_100714C9C(uint64_t a1, unsigned __int8 *a2, const void **a3)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v62 = 0;
  ctu::cf::assign();
  uint64_t v60 = 0;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v6 = a2[23];
  if ((v6 & 0x80u) == 0) {
    int v7 = (void *)a2[23];
  }
  else {
    int v7 = (void *)*((void *)a2 + 1);
  }
  uint64_t v8 = (void *)HIBYTE(v60);
  if (v60 < 0) {
    uint64_t v8 = __p[1];
  }
  if (v7 == v8)
  {
    uint64_t v9 = __p;
    if ((v6 & 0x80) != 0)
    {
      BOOL v18 = memcmp(*(const void **)a2, __p, *((void *)a2 + 1)) == 0;
    }
    else if (a2[23])
    {
      uint64_t v10 = v6 - 1;
      CFTypeID v11 = a2;
      do
      {
        int v13 = *v11++;
        int v12 = v13;
        int v15 = *(unsigned __int8 *)v9;
        uint64_t v9 = (void **)((char *)v9 + 1);
        int v14 = v15;
        BOOL v16 = v10-- != 0;
        char v17 = v16;
        BOOL v18 = v12 == v14;
      }
      while (v12 == v14 && (v17 & 1) != 0);
    }
    else
    {
      BOOL v18 = 1;
    }
  }
  else
  {
    BOOL v18 = 0;
  }
  if (v18)
  {
    uint64_t v19 = *(void *)(a1 + 32);
    if (((char)a2[23] & 0x80000000) == 0)
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v62 = *((void *)a2 + 2);
      goto LABEL_107;
    }
    goto LABEL_106;
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v62 = 0;
  ctu::cf::assign();
  uint64_t v60 = v62;
  *(_OWORD *)std::string __p = *(_OWORD *)__dst;
  uint64_t v20 = a2[23];
  if ((v20 & 0x80u) == 0) {
    int v21 = (void *)a2[23];
  }
  else {
    int v21 = (void *)*((void *)a2 + 1);
  }
  __int16 v22 = (void *)HIBYTE(v60);
  int v23 = SHIBYTE(v60);
  if (v60 < 0) {
    __int16 v22 = __p[1];
  }
  if (v21 != v22)
  {
    BOOL v32 = 0;
    if ((SHIBYTE(v60) & 0x80000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_50;
  }
  if (v60 >= 0) {
    CFDictionaryRef v24 = __p;
  }
  else {
    CFDictionaryRef v24 = (void **)__p[0];
  }
  if ((v20 & 0x80) != 0)
  {
    BOOL v32 = memcmp(*(const void **)a2, v24, *((void *)a2 + 1)) == 0;
    goto LABEL_44;
  }
  if (a2[23])
  {
    uint64_t v25 = v20 - 1;
    std::string::size_type v26 = a2;
    do
    {
      int v28 = *v26++;
      int v27 = v28;
      int v30 = *(unsigned __int8 *)v24;
      CFDictionaryRef v24 = (void **)((char *)v24 + 1);
      int v29 = v30;
      BOOL v16 = v25-- != 0;
      char v31 = v16;
      BOOL v32 = v27 == v29;
    }
    while (v27 == v29 && (v31 & 1) != 0);
LABEL_44:
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_50;
  }
  BOOL v32 = 1;
  if ((SHIBYTE(v60) & 0x80000000) == 0)
  {
LABEL_45:
    if (v32) {
      goto LABEL_46;
    }
    goto LABEL_51;
  }
LABEL_50:
  operator delete(__p[0]);
  if (v32)
  {
LABEL_46:
    uint64_t v19 = *(void *)(a1 + 32);
    if (((char)a2[23] & 0x80000000) == 0)
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v62 = *((void *)a2 + 2);
      goto LABEL_107;
    }
    goto LABEL_106;
  }
LABEL_51:
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v62 = 0;
  ctu::cf::assign();
  uint64_t v60 = v62;
  *(_OWORD *)std::string __p = *(_OWORD *)__dst;
  uint64_t v33 = a2[23];
  if ((v33 & 0x80u) == 0) {
    uint64_t v34 = (void *)a2[23];
  }
  else {
    uint64_t v34 = (void *)*((void *)a2 + 1);
  }
  char v35 = (void *)HIBYTE(v60);
  int v36 = SHIBYTE(v60);
  if (v60 < 0) {
    char v35 = __p[1];
  }
  if (v34 != v35)
  {
    BOOL v45 = 0;
    if ((SHIBYTE(v60) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_78;
  }
  if (v60 >= 0) {
    uint64_t v37 = __p;
  }
  else {
    uint64_t v37 = (void **)__p[0];
  }
  if ((v33 & 0x80) != 0)
  {
    BOOL v45 = memcmp(*(const void **)a2, v37, *((void *)a2 + 1)) == 0;
    goto LABEL_72;
  }
  if (a2[23])
  {
    uint64_t v38 = v33 - 1;
    id v39 = a2;
    do
    {
      int v41 = *v39++;
      int v40 = v41;
      int v43 = *(unsigned __int8 *)v37;
      uint64_t v37 = (void **)((char *)v37 + 1);
      int v42 = v43;
      BOOL v16 = v38-- != 0;
      char v44 = v16;
      BOOL v45 = v40 == v42;
    }
    while (v40 == v42 && (v44 & 1) != 0);
LABEL_72:
    if ((v36 & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_78;
  }
  BOOL v45 = 1;
  if ((SHIBYTE(v60) & 0x80000000) == 0)
  {
LABEL_73:
    if (v45) {
      goto LABEL_74;
    }
    goto LABEL_79;
  }
LABEL_78:
  operator delete(__p[0]);
  if (v45)
  {
LABEL_74:
    uint64_t v19 = *(void *)(a1 + 32);
    if (((char)a2[23] & 0x80000000) == 0)
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v62 = *((void *)a2 + 2);
      goto LABEL_107;
    }
    goto LABEL_106;
  }
LABEL_79:
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v62 = 0;
  ctu::cf::assign();
  uint64_t v60 = v62;
  *(_OWORD *)std::string __p = *(_OWORD *)__dst;
  uint64_t v46 = a2[23];
  if ((v46 & 0x80u) == 0) {
    uint64_t v47 = (void *)a2[23];
  }
  else {
    uint64_t v47 = (void *)*((void *)a2 + 1);
  }
  char v48 = (void *)HIBYTE(v60);
  int v49 = SHIBYTE(v60);
  if (v60 < 0) {
    char v48 = __p[1];
  }
  if (v47 == v48)
  {
    if (v60 >= 0) {
      uint64_t v50 = __p;
    }
    else {
      uint64_t v50 = (void **)__p[0];
    }
    if ((v46 & 0x80) != 0)
    {
      BOOL v58 = memcmp(*(const void **)a2, v50, *((void *)a2 + 1)) == 0;
    }
    else if (a2[23])
    {
      uint64_t v51 = v46 - 1;
      unsigned __int8 v52 = a2;
      do
      {
        int v54 = *v52++;
        int v53 = v54;
        int v56 = *(unsigned __int8 *)v50;
        uint64_t v50 = (void **)((char *)v50 + 1);
        int v55 = v56;
        BOOL v16 = v51-- != 0;
        char v57 = v16;
        BOOL v58 = v53 == v55;
      }
      while (v53 == v55 && (v57 & 1) != 0);
    }
    else
    {
      BOOL v58 = 1;
    }
  }
  else
  {
    BOOL v58 = 0;
  }
  if (v49 < 0)
  {
    operator delete(__p[0]);
    if (!v58) {
      return;
    }
  }
  else if (!v58)
  {
    return;
  }
  uint64_t v19 = *(void *)(a1 + 32);
  if (((char)a2[23] & 0x80000000) == 0)
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v62 = *((void *)a2 + 2);
    goto LABEL_107;
  }
LABEL_106:
  sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
LABEL_107:
  sub_1007151D4(v19, (uint64_t)__dst, *a3);
  if (SHIBYTE(v62) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100715184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1007151C0(uint64_t a1, uint64_t a2)
{
  return sub_100057240((const void **)(a1 + 32), (const void **)(a2 + 32));
}

const void **sub_1007151CC(uint64_t a1)
{
  return sub_10005717C((const void **)(a1 + 32));
}

const void **sub_1007151D4(uint64_t a1, uint64_t a2, const void *a3)
{
  ctu::cf::convert_copy();
  key = 0;
  uint64_t v6 = a3;
  if (a3) {
    CFRetain(a3);
  }
  sub_10010F494(&v6);
  return sub_10010F494((const void **)&key);
}

void sub_10071524C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_100715270(uint64_t a1, unsigned __int8 *a2, const void **a3)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v23 = 0;
  ctu::cf::assign();
  uint64_t v21 = 0;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v6 = a2[23];
  if ((v6 & 0x80u) == 0) {
    int v7 = (void *)a2[23];
  }
  else {
    int v7 = (void *)*((void *)a2 + 1);
  }
  uint64_t v8 = (void *)HIBYTE(v21);
  if (v21 < 0) {
    uint64_t v8 = __p[1];
  }
  if (v7 == v8)
  {
    uint64_t v9 = __p;
    if ((v6 & 0x80) != 0)
    {
      BOOL v18 = memcmp(*(const void **)a2, __p, *((void *)a2 + 1)) == 0;
    }
    else if (a2[23])
    {
      uint64_t v10 = v6 - 1;
      CFTypeID v11 = a2;
      do
      {
        int v13 = *v11++;
        int v12 = v13;
        int v15 = *(unsigned __int8 *)v9;
        uint64_t v9 = (void **)((char *)v9 + 1);
        int v14 = v15;
        BOOL v17 = v10-- != 0;
        BOOL v18 = v12 == v14;
      }
      while (v12 == v14 && v17);
    }
    else
    {
      BOOL v18 = 1;
    }
  }
  else
  {
    BOOL v18 = 0;
  }
  if (v18)
  {
    uint64_t v19 = *(void *)(a1 + 32);
    if (((char)a2[23] & 0x80000000) == 0)
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v23 = *((void *)a2 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 40) != 1) {
      return;
    }
    uint64_t v19 = *(void *)(a1 + 32);
    if (((char)a2[23] & 0x80000000) == 0)
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v23 = *((void *)a2 + 2);
      goto LABEL_27;
    }
  }
  sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
LABEL_27:
  sub_1007151D4(v19, (uint64_t)__dst, *a3);
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100715440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100715468(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = 0;
    sub_100057240(&v5, a2);
    uint64_t v3 = *a1;
    *a1 = v5;
    uint64_t v5 = v3;
    sub_10005717C(&v5);
  }
  return a1;
}

void sub_1007154C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  ctu::cf::assign();
  uint64_t v7 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v5 = *(void (**)(uint64_t, void **, long long *))(v4 + 16);
  *(void *)&long long v8 = a3;
  v5(v4, __p, &v8);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100715538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100715568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

void sub_100715584(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100715604(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100715640(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100715678(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007156A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007156F0()
{
}

uint64_t sub_100715704(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

const void **sub_100715710(__CFDictionary *a1, void *cf, CFTypeRef a3)
{
  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v6 = a3;
  if (a3)
  {
    CFRetain(a3);
    if (key) {
      CFDictionarySetValue(a1, key, a3);
    }
  }
  sub_10010F494(&v6);
  return sub_10010F494((const void **)&key);
}

void sub_100715780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1007157A4(__CFDictionary *a1, CFTypeRef cf)
{
  uint64_t v7 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v8 = 0;
  ctu::cf::convert_copy();
  uint64_t v6 = 0;
  if (v7) {
    BOOL v3 = v8 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3) {
    CFDictionarySetValue(a1, v7, 0);
  }
  sub_10010F494(&v6);
  sub_10010F494(&v7);
  return v4;
}

void sub_10071583C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  BOOL v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100715860(__CFDictionary *a1, CFTypeRef cf)
{
  uint64_t v7 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v8 = 0;
  ctu::cf::convert_copy();
  uint64_t v6 = 0;
  if (v7) {
    BOOL v3 = v8 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3) {
    CFDictionaryAddValue(a1, v7, 0);
  }
  sub_10010F494(&v6);
  sub_10010F494(&v7);
  return v4;
}

void sub_1007158F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  BOOL v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

void *sub_10071591C(void *a1)
{
  *a1 = off_1019FE9C8;
  char v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100715968(void *a1)
{
  *a1 = off_1019FE9C8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_1007159D4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019FE9C8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100715A38(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FE9C8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100715A78(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100715A88(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100715AC8(void *a1, long long *a2)
{
  long long v13 = *a2;
  uint64_t v14 = *((void *)a2 + 2);
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  long long v15 = v3;
  uint64_t v16 = *((void *)a2 + 5);
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  uint64_t v18 = *((void *)a2 + 8);
  long long v17 = a2[3];
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  long long v4 = *(long long *)((char *)a2 + 72);
  uint64_t v20 = *((void *)a2 + 11);
  long long v19 = v4;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  long long v5 = a2[6];
  uint64_t v22 = *((void *)a2 + 14);
  long long v21 = v5;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  char v23 = *((unsigned char *)a2 + 120);
  uint64_t v6 = *((void *)a2 + 18);
  long long v24 = a2[8];
  *((void *)a2 + 16) = 0;
  *((void *)a2 + 17) = 0;
  long long v7 = *(long long *)((char *)a2 + 152);
  uint64_t v8 = *((void *)a2 + 21);
  uint64_t v25 = v6;
  uint64_t v27 = v8;
  long long v26 = v7;
  *((void *)a2 + 18) = 0;
  *((void *)a2 + 19) = 0;
  *((void *)a2 + 20) = 0;
  *((void *)a2 + 21) = 0;
  long long v9 = a2[11];
  uint64_t v29 = *((void *)a2 + 24);
  long long v28 = v9;
  *((void *)a2 + 22) = 0;
  *((void *)a2 + 23) = 0;
  *((void *)a2 + 24) = 0;
  char v30 = *((unsigned char *)a2 + 200);
  uint64_t v10 = a1[1];
  uint64_t v31 = v10;
  sub_10000BE9C((uint64_t)v32, (uint64_t)&v13);
  v32[200] = v30;
  uint64_t v11 = a1[3];
  uint64_t v33 = a1[2];
  uint64_t v34 = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  int v12 = *(std::__shared_weak_count **)(v10 + 16);
  if (v12)
  {
    if (std::__shared_weak_count::lock(v12)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100715DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100715DC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100715E04()
{
}

uint64_t *sub_100715E10(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), 1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v8 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Carrier Bundle match result: %s", buf, 0xCu);
  }
  uint64_t v3 = *(void *)(v1 + 216);
  sub_10000BE9C((uint64_t)buf, v1 + 8);
  char v9 = *(unsigned char *)(v1 + 208);
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 16))(v3, 1, buf);
  sub_10000BDF8((uint64_t)buf);
  sub_100715F7C(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100715F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t *sub_100715F7C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 224);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_10000BDF8(v1 + 8);
    operator delete();
  }
  return result;
}

void *sub_100715FD8(void *a1)
{
  *a1 = off_1019FEA58;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100716024(void *a1)
{
  *a1 = off_1019FEA58;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100716090(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_1019FEA58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
  return result;
}

uint64_t sub_1007160FC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019FEA58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(result + 40);
  return result;
}

void sub_100716144(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100716154(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100716194(uint64_t a1, long long *a2)
{
  long long v12 = *a2;
  uint64_t v13 = *((void *)a2 + 2);
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  long long v14 = v3;
  uint64_t v15 = *((void *)a2 + 5);
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  uint64_t v17 = *((void *)a2 + 8);
  long long v16 = a2[3];
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  long long v4 = *(long long *)((char *)a2 + 72);
  uint64_t v19 = *((void *)a2 + 11);
  long long v18 = v4;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  long long v5 = a2[6];
  uint64_t v21 = *((void *)a2 + 14);
  long long v20 = v5;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  char v22 = *((unsigned char *)a2 + 120);
  long long v6 = a2[8];
  uint64_t v24 = *((void *)a2 + 18);
  long long v23 = v6;
  *((void *)a2 + 16) = 0;
  *((void *)a2 + 17) = 0;
  long long v7 = *(long long *)((char *)a2 + 152);
  uint64_t v26 = *((void *)a2 + 21);
  long long v25 = v7;
  *((void *)a2 + 18) = 0;
  *((void *)a2 + 19) = 0;
  *((void *)a2 + 20) = 0;
  *((void *)a2 + 21) = 0;
  long long v8 = a2[11];
  uint64_t v28 = *((void *)a2 + 24);
  *((void *)a2 + 22) = 0;
  *((void *)a2 + 23) = 0;
  *((void *)a2 + 24) = 0;
  char v29 = *((unsigned char *)a2 + 200);
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v30 = *(void *)(a1 + 16);
  long long v27 = v8;
  sub_10000BE9C((uint64_t)v31, (uint64_t)&v12);
  v31[200] = v29;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v32 = *(void *)(a1 + 24);
  uint64_t v33 = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  int v34 = *(_DWORD *)(a1 + 40);
  uint64_t v11 = *(std::__shared_weak_count **)(v9 + 16);
  if (v11)
  {
    if (std::__shared_weak_count::lock(v11)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100716484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10071649C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007164DC()
{
}

uint64_t *sub_1007164E8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = **(NSObject ***)v1;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v9 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Carrier Bundle match result: %s", buf, 0xCu);
  }
  uint64_t v3 = *(void *)(v1 + 216);
  uint64_t v4 = *(unsigned int *)(v1 + 232);
  sub_10000BE9C((uint64_t)buf, v1 + 8);
  char v10 = *(unsigned char *)(v1 + 208);
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 16))(v3, v4, buf);
  sub_10000BDF8((uint64_t)buf);
  sub_10071662C(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100716600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t *sub_10071662C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 224);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_10000BDF8(v1 + 8);
    operator delete();
  }
  return result;
}

void sub_1007167B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)WiFiPathObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1007168F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10071699C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100717248(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100717284()
{
}

void sub_100717290()
{
}

void sub_100717298()
{
  v5[0] = v2;
  sub_100047F64(v5);
  if (v3 < 0) {
    operator delete(v2[3]);
  }
  v5[0] = &v4;
  sub_100047F64(v5);

  JUMPOUT(0x100717394);
}

void sub_1007172A0()
{
  JUMPOUT(0x100717388);
}

void sub_1007172D4()
{
}

void sub_1007172F4()
{
}

void sub_1007172FC()
{
}

void sub_100717304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100717338(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void **a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  a37 = (void **)&a19;
  sub_100047F64(&a37);
  JUMPOUT(0x100717354);
}

void sub_1007174F0()
{
}

void sub_10071754C()
{
}

void *sub_100717570(void *a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "DATA.wifi");
  sub_10071763C(a1 + 1, "DataNetworkMonitor", QOS_CLASS_UTILITY, &v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_1019FEAD8;
  a1[6] = "DataNetworkMonitor";
  a1[7] = 0;
  return a1;
}

void sub_100717618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  DataNetworkMonitorInterface::~DataNetworkMonitorInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_10071763C(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_1007176A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_1007176DC(void *a1)
{
  *a1 = off_1019FEAD8;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[7] = 0;

    uint64_t v2 = (void *)a1[7];
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  DataNetworkMonitorInterface::~DataNetworkMonitorInterface((DataNetworkMonitorInterface *)a1);
}

void sub_10071775C(void *a1)
{
  sub_1007176DC(a1);

  operator delete();
}

void sub_100717794(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100717808;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_10071857C((uint64_t *)(a1 + 8), v1);
}

void sub_100717808(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  OsLogContext v3 = [WiFiPathObserver alloc];
  uint64_t v4 = (std::__shared_weak_count *)v1[2];
  if (!v4 || (v5 = v1[1], (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v5;
  uint64_t v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  uint64_t v7 = [(WiFiPathObserver *)v3 initWithMonitor:&v12 logger:v1 + 5];
  long long v8 = (void *)v1[7];
  v1[7] = v7;

  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v9 = (void *)v1[7];
  if (v9)
  {
    [v9 doStartObserving];
  }
  else
  {
    char v10 = v1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I failed to create WiFiPathObserver", v11, 2u);
    }
  }
}

void sub_1007178FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100717914(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _OWORD v6[2] = sub_100717ABC;
  uint64_t v6[3] = &unk_1019FE1E8;
  v6[4] = a1;
  uint64_t v7 = objc_retainBlock(v6);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1007186A4;
  void v8[3] = &unk_10199E4C0;
  _OWORD v8[4] = v2;
  void v8[5] = &v7;
  uint64_t v9 = objc_retainBlock(v8);
  OsLogContext v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_1007186F4;
    uint64_t v13 = &unk_10199E470;
    long long v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_1007186B8;
    uint64_t v13 = &unk_10199E470;
    long long v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_sync(v3, &block);
  }
  BOOL v4 = v16 != 0;

  return v4;
}

id sub_100717ABC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v3 = [*(id *)(v1 + 56) isWifiAvailable];
  return v3;
}

void sub_100717AFC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1 + 8;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _OWORD v6[2] = sub_100717CA0;
  uint64_t v6[3] = &unk_1019BB398;
  v6[4] = a1;
  uint64_t v7 = objc_retainBlock(v6);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_100718730;
  void v8[3] = &unk_1019ADCC0;
  _OWORD v8[4] = v4;
  void v8[5] = &v7;
  uint64_t v9 = objc_retainBlock(v8);
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_1007187A8;
    uint64_t v13 = &unk_10199E470;
    long long v14 = a2;
    uint64_t v15 = &v9;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_100718744;
    uint64_t v13 = &unk_10199E470;
    long long v14 = a2;
    uint64_t v15 = &v9;
    dispatch_sync(v5, &block);
  }
}

void sub_100717CA0(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v5 = [*(id *)(v3 + 56) getInterfaceName];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  ctu::cf::assign();
}

void sub_100717D10(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }

  _Unwind_Resume(a1);
}

void sub_100717D30(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  [*(id *)(v1 + 56) doUpdateWifiAvailability];
}

void sub_100717D74(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_1007180B0(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100166B08((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        long long v8 = *(_DWORD **)sub_1001675B8((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_1001675B8(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_1001675B8(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100166B08((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100166B08((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_1007180B0(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100718058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007180B0(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_1007180F0(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_100166AC4(v2);
    if (sub_100167E28(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_100166AC4(v2);
      uint64_t v9 = *(uint64_t **)(sub_100167E28(v7) + 8);
      sub_100166D2C(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_10071825C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007182B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_10071838C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1007183AC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100718478(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100718550);
  __cxa_rethrow();
}

void sub_1007184A0(_Unwind_Exception *a1)
{
}

void sub_1007184B8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007184F0(uint64_t a1)
{
}

uint64_t sub_10071850C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100718550(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10071857C(uint64_t *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (!v4 || (v5 = *a1, (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  long long v8 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_100718668;
  block[3] = &unk_1019FEC10;
  uint64_t v12 = v5;
  uint64_t v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  id v9 = v3;
  id v11 = v9;
  dispatch_async(v8, block);

  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
}

uint64_t sub_100718668(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100718678(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100718694(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_1007186A4(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1007186B8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1007186F4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100718730(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
}

__n128 sub_100718744(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

__n128 sub_1007187A8(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

void sub_10071880C()
{
}

void TelephonyAnalyticsCache::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100718B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100718CBC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  __n128 v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100718DBC(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::string::size_type a5, std::string::size_type a6)
{
  std::string::size_type v63 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 48));
  uint64_t v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      std::string::size_type v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  v65[0].__r_.__value_.__r.__words[0] = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v65);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_9:
    std::mutex::unlock(v13);
    long long v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v20 = v18[3];
  long long v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20)
  {
LABEL_10:
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v20 + 80))(&__dst, v20, a3, a4, @"CarrierName", 0, 0);
    sub_100056248(&__p, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
    v65[0].__r_.__value_.__r.__words[0] = v63;
    std::string::size_type v63 = __p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v65[0].__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
  }
LABEL_11:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  memset(&__p, 0, sizeof(__p));
  if (v63) {
    long long v22 = sub_1000810B8;
  }
  else {
    long long v22 = 0;
  }
  if (v22)
  {
    memset(v65, 0, 24);
    ctu::cf::assign();
    std::string v61 = v65[0];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D560, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D560))
    {
      sub_100719B0C(v65);
      sub_100719B68(v66);
      sub_100719BC4(v67);
      sub_100719C20(v68);
      sub_100719C7C(v69, "中国移动", "China Mobile");
      sub_100719C7C(v70, "中国联通", "China Unicom");
      sub_100719CD0(v71);
      sub_100719D2C(v72);
      sub_100719D88(v73);
      sub_100637AF8(v74, "中華電信", "Chunghwa Telecom");
      sub_100719C7C(v75, "中國聯通", "China Unicom");
      sub_100719DE4(v76);
      sub_100719E40((char *)v65, 12);
      for (unint64_t i = 528; i != -48; i -= 48)
        sub_1001085D8((uint64_t)&v65[i / 0x18]);
      __cxa_atexit((void (*)(void *))sub_100719AE0, &qword_101B0D568, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D560);
    }
    memset(&__dst, 0, sizeof(__dst));
    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v61.__r_.__value_.__l.__data_, v61.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v61;
    }
    long long v24 = sub_100046F68((uint64_t)&qword_101B0D568, (void **)&v61.__r_.__value_.__l.__data_);
    if (v24 != (void **)&qword_101B0D570) {
      std::string::operator=(&__dst, (const std::string *)(v24 + 7));
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = __dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v61.__r_.__value_.__l.__data_);
    }
    LODWORD(v22) = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  else
  {
    std::string::size_type size = 0;
  }
  std::string::size_type v25 = v22;
  if ((char)v22 < 0) {
    std::string::size_type v25 = size;
  }
  if (v25 != 7)
  {
    if (!v25)
    {
      long long v26 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a5 + 23) >= 0) {
          std::string::size_type v57 = a5;
        }
        else {
          std::string::size_type v57 = *(void *)a5;
        }
        if (*(char *)(a6 + 23) >= 0) {
          std::string::size_type v58 = a6;
        }
        else {
          std::string::size_type v58 = *(void *)a6;
        }
        LODWORD(v65[0].__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v65[0].__r_.__value_.__r.__words + 4) = v57;
        WORD2(v65[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v65[0].__r_.__value_.__r.__words[1] + 6) = v58;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "CarrierName is empty, returning null for mcc = %s, mnc =  %s", (uint8_t *)v65, 0x16u);
      }
      *a1 = __p;
      memset(&__p, 0, sizeof(__p));
      goto LABEL_88;
    }
LABEL_41:
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if ((v22 & 0x80) != 0) {
      sub_10004FC84(a1, __p.__r_.__value_.__l.__data_, size);
    }
    else {
      *a1 = __p;
    }
    uint64_t v31 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 48));
    uint64_t v32 = v31;
    if ((v33 & 0x8000000000000000) != 0)
    {
      int v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v35 = 5381;
      do
      {
        std::string::size_type v33 = v35;
        unsigned int v36 = *v34++;
        uint64_t v35 = (33 * v35) ^ v36;
      }
      while (v36);
    }
    std::mutex::lock(v31);
    v65[0].__r_.__value_.__r.__words[0] = v33;
    uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)v65);
    if (v37)
    {
      uint64_t v39 = v37[3];
      uint64_t v38 = (std::__shared_weak_count *)v37[4];
      if (v38)
      {
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v32);
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v38);
        char v40 = 0;
        if (!v39) {
          goto LABEL_72;
        }
LABEL_53:
        memset(v65, 0, 24);
        (*(void (**)(std::string *__return_ptr, uint64_t, std::string::size_type))(*(void *)v39 + 24))(v65, v39, a5);
        if (SHIBYTE(v65[0].__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::size_type v41 = v65[0].__r_.__value_.__l.__size_;
          if (v65[0].__r_.__value_.__l.__size_)
          {
            int v42 = (std::string *)v65[0].__r_.__value_.__r.__words[0];
            goto LABEL_58;
          }
        }
        else
        {
          std::string::size_type v41 = HIBYTE(v65[0].__r_.__value_.__r.__words[2]);
          if (*((unsigned char *)&v65[0].__r_.__value_.__s + 23))
          {
            int v42 = v65;
LABEL_58:
            int v43 = (std::string *)((char *)v42 + v41);
            while (v42 != v43)
            {
              v42->__r_.__value_.__s.__data_[0] = __toupper(v42->__r_.__value_.__s.__data_[0]);
              int v42 = (std::string *)((char *)v42 + 1);
            }
            std::operator+<char>();
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_dst = &__dst;
            }
            else {
              p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v45 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v45 = __dst.__r_.__value_.__l.__size_;
            }
            std::string::append(a1, (const std::string::value_type *)p_dst, v45);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            goto LABEL_71;
          }
        }
        uint64_t v46 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(a5 + 23) >= 0) {
            std::string::size_type v59 = a5;
          }
          else {
            std::string::size_type v59 = *(void *)a5;
          }
          LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v59;
          _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Unable to infer ISO Alpha2 country code for mcc = %s", (uint8_t *)&__dst, 0xCu);
        }
LABEL_71:
        if (SHIBYTE(v65[0].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v65[0].__r_.__value_.__l.__data_);
          if (v40) {
            goto LABEL_88;
          }
LABEL_73:
          sub_10004D2C8(v38);
          goto LABEL_88;
        }
LABEL_72:
        if (v40) {
          goto LABEL_88;
        }
        goto LABEL_73;
      }
    }
    else
    {
      uint64_t v39 = 0;
    }
    std::mutex::unlock(v32);
    uint64_t v38 = 0;
    char v40 = 1;
    if (!v39) {
      goto LABEL_72;
    }
    goto LABEL_53;
  }
  p_p = &__p;
  if ((char)v22 < 0) {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int data = (int)p_p->__r_.__value_.__l.__data_;
  int v29 = *(_DWORD *)((char *)p_p->__r_.__value_.__r.__words + 3);
  if (data != 1920098627 || v29 != 1919248754) {
    goto LABEL_41;
  }
  std::operator+<char>();
  uint64_t v47 = std::string::append(&v61, ", mnc = ", 8uLL);
  long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v48;
  v47->__r_.__value_.__l.__size_ = 0;
  v47->__r_.__value_.__r.__words[2] = 0;
  v47->__r_.__value_.__r.__words[0] = 0;
  int v49 = *(char *)(a6 + 23);
  if (v49 >= 0) {
    uint64_t v50 = (const std::string::value_type *)a6;
  }
  else {
    uint64_t v50 = *(const std::string::value_type **)a6;
  }
  if (v49 >= 0) {
    std::string::size_type v51 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    std::string::size_type v51 = *(void *)(a6 + 8);
  }
  unsigned __int8 v52 = std::string::append(&__dst, v50, v51);
  long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  v65[0].__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v65[0].__r_.__value_.__l.__data_ = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  int v54 = std::string::append(v65, ")", 1uLL);
  long long v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
  a1->__r_.__value_.__r.__words[2] = v54->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v55;
  v54->__r_.__value_.__l.__size_ = 0;
  v54->__r_.__value_.__r.__words[2] = 0;
  v54->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v65[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v65[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
LABEL_88:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return sub_1000558F4((const void **)&v63);
}

void sub_1007195B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  for (uint64_t i = 528; i != -48; i -= 48)
    sub_1001085D8(v35 + i);
  __cxa_guard_abort(&qword_101B0D560);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_1000558F4(&a22);
  _Unwind_Resume(a1);
}

void sub_100719754(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  uint64_t v7[2] = sub_10071A72C;
  uint64_t v7[3] = &unk_1019FEEF8;
  _DWORD v7[4] = a1 + 8;
  void v7[5] = &v5;
  long long v8 = v7;
  uint64_t v4 = a1 + 24;
  id v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    id v11 = sub_10071A8A4;
    uint64_t v12 = &unk_1019FEF38;
    uint64_t v13 = a3;
    std::string::size_type v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    id v11 = sub_100003EC4;
    uint64_t v12 = &unk_1019FEF18;
    uint64_t v13 = a3;
    std::string::size_type v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_100719880(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  uint64_t v7[2] = sub_10071A908;
  uint64_t v7[3] = &unk_1019FEF58;
  _DWORD v7[4] = a1 + 8;
  void v7[5] = &v5;
  long long v8 = v7;
  uint64_t v4 = a1 + 24;
  id v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    id v11 = sub_10071A8A4;
    uint64_t v12 = &unk_1019FEF38;
    uint64_t v13 = a3;
    std::string::size_type v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    id v11 = sub_100003EC4;
    uint64_t v12 = &unk_1019FEF18;
    uint64_t v13 = a3;
    std::string::size_type v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_1007199AC(uint64_t a1)
{
  *(void *)a1 = off_1019FEC50;
  sub_10019D5B8(a1 + 104, *(void **)(a1 + 112));
  sub_10003FB28(a1 + 80, *(void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  TelephonyAnalyticsCacheInterface::~TelephonyAnalyticsCacheInterface((TelephonyAnalyticsCacheInterface *)a1);
}

void sub_100719A3C(uint64_t a1)
{
  *(void *)a1 = off_1019FEC50;
  sub_10019D5B8(a1 + 104, *(void **)(a1 + 112));
  sub_10003FB28(a1 + 80, *(void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  TelephonyAnalyticsCacheInterface::~TelephonyAnalyticsCacheInterface((TelephonyAnalyticsCacheInterface *)a1);

  operator delete();
}

uint64_t sub_100719AE0(uint64_t a1)
{
  return a1;
}

void *sub_100719B0C(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "ソフトバンク");
  sub_100058DB0(v2 + 3, "Softbank");
  return a1;
}

void sub_100719B4C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719B68(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "ドコモ");
  sub_100058DB0(v2 + 3, "DoCoMo");
  return a1;
}

void sub_100719BA8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719BC4(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "ワイモバイル");
  sub_100058DB0(v2 + 3, "YMobile");
  return a1;
}

void sub_100719C04(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719C20(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "中国电信");
  sub_100058DB0(v2 + 3, "China Telecom");
  return a1;
}

void sub_100719C60(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719C7C(void *a1, char *a2, char *a3)
{
  uint64_t v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100719CB4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719CD0(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "台灣大哥大");
  sub_100058DB0(v2 + 3, "Taiwan Mobile");
  return a1;
}

void sub_100719D10(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719D2C(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "遠傳電信");
  sub_100058DB0(v2 + 3, "Far EasTone");
  return a1;
}

void sub_100719D6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719D88(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "台灣之星");
  sub_100058DB0(v2 + 3, "Taiwan Star Telecom");
  return a1;
}

void sub_100719DC8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100719DE4(void *a1)
{
  uint64_t v2 = sub_100058DB0(a1, "中国广电");
  sub_100058DB0(v2 + 3, "China Broadnet");
  return a1;
}

void sub_100719E24(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100719E40(char *result, uint64_t a2)
{
  qword_101B0D578 = 0;
  qword_101B0D570 = 0;
  qword_101B0D568 = (uint64_t)&qword_101B0D570;
  if (a2)
  {
    uint64_t v2 = (void **)result;
    uint64_t v3 = 48 * a2;
    do
    {
      __n128 result = sub_100346C24((uint64_t **)&qword_101B0D568, (uint64_t)&qword_101B0D570, v2, (long long *)v2);
      v2 += 6;
      v3 -= 48;
    }
    while (v3);
  }
  return result;
}

void sub_100719EAC(_Unwind_Exception *a1)
{
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100719EC8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100719F00(uint64_t a1)
{
}

uint64_t sub_100719F1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100719F60(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100719F8C(ServiceManager::Service *this)
{
  *(void *)this = off_1019FED88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100719FE8(ServiceManager::Service *this)
{
  *(void *)this = off_1019FED88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10071A058@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TelephonyAnalyticsCache");
}

unsigned char *sub_10071A068@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10071A0A8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100718CBC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100718CBC(v4, 0);
}

uint64_t sub_10071A12C()
{
  return 0;
}

uint64_t sub_10071A134()
{
  return 1;
}

uint64_t sub_10071A13C()
{
  return 0;
}

void sub_10071A14C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_10071A260(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Boostrapping...", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&__p, "/cc/props/reg_serving_network");
  *(void *)std::string buf = off_1019FEE08;
  uint64_t v12 = v2 + 80;
  uint64_t v13 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p);
  }
  sub_10071A3EC(v2 + 104);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10071A39C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_10071A3EC(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/mcc_mnc_computed_info");
  v4[0] = off_1019FEE88;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10071A4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10071A4D0()
{
}

void *sub_10071A4E4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FEE08;
  result[1] = v3;
  return result;
}

uint64_t sub_10071A52C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FEE08;
  a2[1] = v2;
  return result;
}

void sub_10071A558(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10071A560(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10071A5A0()
{
}

void sub_10071A5B0()
{
}

void *sub_10071A5C4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FEE88;
  result[1] = v3;
  return result;
}

uint64_t sub_10071A60C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FEE88;
  a2[1] = v2;
  return result;
}

void sub_10071A638(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10071A640(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10071A680()
{
}

uint64_t *sub_10071A68C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down...", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 64));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10071A710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_10071A72C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  uint64_t v17 = 0;
  v18[0] = 0;
  v18[1] = 0;
  sub_1002998C4(&v17, v4 + 104);
  memset(&v16, 0, sizeof(v16));
  memset(&v15, 0, sizeof(v15));
  uint64_t v5 = v18[0];
  if (v18[0])
  {
    int v6 = *(_DWORD *)(v3 + 8);
    uint64_t v7 = v18;
    do
    {
      long long v8 = v5;
      id v9 = v7;
      int v10 = *((_DWORD *)v5 + 8);
      id v11 = v5 + 1;
      if (v10 >= v6)
      {
        id v11 = v8;
        uint64_t v7 = (void **)v8;
      }
      uint64_t v5 = (void *)*v11;
    }
    while (v5);
    if (v7 != v18)
    {
      uint64_t v12 = v10 >= v6 ? v8 : v9;
      if (v6 >= *((_DWORD *)v12 + 8))
      {
        if (v10 >= v6) {
          uint64_t v13 = (const std::string *)(v8 + 5);
        }
        else {
          uint64_t v13 = (const std::string *)(v9 + 5);
        }
        std::string::operator=(&v16, v13);
        if (v10 >= v6) {
          std::string::size_type v14 = (const std::string *)(v8 + 8);
        }
        else {
          std::string::size_type v14 = (const std::string *)(v9 + 8);
        }
        std::string::operator=(&v15, v14);
      }
    }
  }
  sub_100718DBC(a2, v4, *(unsigned int *)(v3 + 8), 1, (std::string::size_type)&v16, (std::string::size_type)&v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  sub_10019D5B8((uint64_t)&v17, v18[0]);
}

void sub_10071A868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_10019D5B8((uint64_t)&a22, a23);
  _Unwind_Resume(a1);
}

__n128 sub_10071A8A4(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

void sub_10071A908(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  uint64_t v25 = 0;
  v26[0] = 0;
  v26[1] = 0;
  sub_1005BD15C(&v25, v4 + 80);
  long long v23 = 0uLL;
  uint64_t v24 = 0;
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  uint64_t v5 = v26[0];
  if (v26[0])
  {
    int v6 = *(_DWORD *)(v3 + 8);
    uint64_t v7 = v26;
    do
    {
      long long v8 = v5;
      id v9 = v7;
      int v10 = *((_DWORD *)v5 + 8);
      id v11 = v5 + 1;
      if (v10 >= v6)
      {
        id v11 = v8;
        uint64_t v7 = (void **)v8;
      }
      uint64_t v5 = (void *)*v11;
    }
    while (v5);
    if (v7 != v26)
    {
      uint64_t v12 = v10 >= v6 ? v8 : v9;
      if (v6 >= *((_DWORD *)v12 + 8))
      {
        uint64_t v13 = (MCCAndMNC *)(v9 + 5);
        std::string::size_type v14 = (MCCAndMNC *)(v8 + 5);
        if (v10 >= v6) {
          std::string v15 = v14;
        }
        else {
          std::string v15 = v13;
        }
        MCCAndMNC::getMcc(&v16, v15);
        MCC::getStringValue((uint64_t *)&v19, (MCC *)&v16);
        if (SHIBYTE(v24) < 0) {
          operator delete((void *)v23);
        }
        long long v23 = v19;
        uint64_t v24 = v20;
        HIBYTE(v20) = 0;
        LOBYTE(v19) = 0;
        if (v18 < 0) {
          operator delete(__p);
        }
        MCCAndMNC::getMnc(&v16, v15);
        MCC::getStringValue((uint64_t *)&v19, (MCC *)&v16);
        if (SHIBYTE(v22) < 0) {
          operator delete(v21[0]);
        }
        *(_OWORD *)char v21 = v19;
        uint64_t v22 = v20;
        HIBYTE(v20) = 0;
        LOBYTE(v19) = 0;
        if (v18 < 0) {
          operator delete(__p);
        }
      }
    }
  }
  sub_100718DBC(a2, v4, *(unsigned int *)(v3 + 8), 2, (std::string::size_type)&v23, (std::string::size_type)v21);
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete((void *)v23);
  }
  sub_10003FB28((uint64_t)&v25, v26[0]);
}

void sub_10071AAB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (*(char *)(v25 - 57) < 0) {
    operator delete(*(void **)(v25 - 80));
  }
  sub_10003FB28(v25 - 56, *(void **)(v25 - 48));
  _Unwind_Resume(a1);
}

void sub_10071AB10(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10071AE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_10071AF50(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10071B058(uint64_t a1)
{
  sub_10071B114(a1);

  operator delete();
}

void *sub_10071B090(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10071B114(uint64_t a1)
{
  *(void *)a1 = off_1019FEF88;
  sub_10071B1CC((NotifySubscription **)(a1 + 184), 0);
  sub_10071B1CC((NotifySubscription **)(a1 + 176), 0);
  sub_10071B1CC((NotifySubscription **)(a1 + 168), 0);
  sub_10071B1CC((NotifySubscription **)(a1 + 160), 0);
  sub_10030AB98((void *)(a1 + 120));
  sub_10071B090((void *)(a1 + 80));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SetupAssistantHelperInterface::~SetupAssistantHelperInterface((SetupAssistantHelperInterface *)a1);
}

NotifySubscription *sub_10071B1CC(NotifySubscription **a1, NotifySubscription *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    NotifySubscription::~NotifySubscription(result);
    operator delete();
  }
  return result;
}

void sub_10071B220(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10071B258(uint64_t a1)
{
}

uint64_t sub_10071B274(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10071B2B8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10071B2E4(ServiceManager::Service *this)
{
  *(void *)this = off_1019FF0B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10071B340(ServiceManager::Service *this)
{
  *(void *)this = off_1019FF0B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10071B3B0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SetupAssistantHelper");
}

unsigned char *sub_10071B3C0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10071B400(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10071AF50(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10071AF50(v4, 0);
}

uint64_t sub_10071B484()
{
  return 0;
}

uint64_t sub_10071B48C()
{
  return 1;
}

uint64_t sub_10071B494()
{
  return 0;
}

void sub_10071B4A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10071B580(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_10071B694(uint64_t *a1)
{
  uint64_t v1 = *a1;
  id v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = (NotifySubscription *)v2[20];
  if (v4) {
    NotifySubscription::cancel(v4);
  }
  uint64_t v5 = (NotifySubscription *)v2[21];
  if (v5) {
    NotifySubscription::cancel(v5);
  }
  int v6 = (NotifySubscription *)v2[22];
  if (v6) {
    NotifySubscription::cancel(v6);
  }
  uint64_t v7 = (NotifySubscription *)v2[23];
  if (v7) {
    NotifySubscription::cancel(v7);
  }
  sub_100088C88(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10071B740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10071B75C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string::size_type v45 = a1;
  uint64_t v46 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v47, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v48) {
    sub_10004D2C8(v48);
  }
  uint64_t v4 = (uint8_t *)(v2 + 80);
  *(void *)std::string buf = off_1019FF138;
  uint64_t v50 = v2 + 64;
  unsigned __int8 v52 = buf;
  if (buf != (uint8_t *)(v2 + 80))
  {
    uint64_t v5 = *(uint8_t **)(v2 + 104);
    if (v5 == v4)
    {
      v55[1] = v2 + 64;
      v55[2] = 0;
      v55[0] = off_1019FF138;
      unsigned __int8 v52 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 24))(v2 + 80, buf);
      (*(void (**)(void))(**(void **)(v2 + 104) + 32))(*(void *)(v2 + 104));
      *(void *)(v2 + 104) = 0;
      unsigned __int8 v52 = buf;
      (*(void (**)(void *, uint64_t))(v55[0] + 24))(v55, v2 + 80);
      (*(void (**)(void *))(v55[0] + 32))(v55);
    }
    else
    {
      *(void *)(v2 + 80) = off_1019FF138;
      *(void *)(v2 + 88) = v2 + 64;
      unsigned __int8 v52 = v5;
    }
    *(void *)(v2 + 104) = v4;
  }
  sub_10071B090(buf);
  uint64_t v6 = *(void *)(v2 + 104);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v2 + 112);
  }
  *(void *)std::string buf = off_1019FF1C8;
  uint64_t v50 = v2 + 64;
  unsigned __int8 v52 = buf;
  sub_100318874(buf, (void *)(v2 + 120));
  sub_10030AB98(buf);
  uint64_t v7 = *(void *)(v2 + 144);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v2 + 152);
  }
  if (CFStringGetCStringPtr(BYSetupAssistantFinishedDarwinNotification, 0x8000100u)) {
    operator new();
  }
  long long v8 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Could not create finished notification subscription", buf, 2u);
  }
  if (CFStringGetCStringPtr(BYSetupAssistantExitedDarwinNotification, 0x8000100u)) {
    operator new();
  }
  id v9 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Could not create exited notification subscription", buf, 2u);
  }
  if (CFStringGetCStringPtr(BYSetupAssistantLaunchedDarwinNotification, 0x8000100u)) {
    operator new();
  }
  uint64_t v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Could not create launched notification subscription", buf, 2u);
  }
  if (CFStringGetCStringPtr(BYSetupAssistantDidCompleteLanguageLocaleNotification, 0x8000100u)) {
    operator new();
  }
  id v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not create language selection subscription", buf, 2u);
  }
  uint64_t v12 = *(void *)(v2 + 168);
  if (v12)
  {
    uint64_t v13 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v13) {
      goto LABEL_55;
    }
    uint64_t v14 = *(void *)(v2 + 8);
    std::string v15 = std::__shared_weak_count::lock(v13);
    if (!v15) {
      goto LABEL_55;
    }
    uint64_t v16 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    NotifySubscription::cancel((NotifySubscription *)v12);
    uint64_t v17 = (std::__shared_weak_count *)operator new(0x30uLL);
    v17->__shared_weak_owners_ = 0;
    v17->__shared_owners_ = 0;
    v17->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF278;
    v17[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
    v17[1].__shared_owners_ = v14;
    v17[1].__shared_weak_owners_ = (uint64_t)v16;
    char v18 = *(const char **)v12;
    long long v19 = *(NSObject **)(v12 + 8);
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v50 = 3321888768;
    std::string::size_type v51 = sub_10071C4F4;
    unsigned __int8 v52 = (uint8_t *)&unk_1019FF238;
    long long v53 = v17 + 1;
    int v54 = v17;
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v18, (int *)(v12 + 16), v19, buf);
    if (v54) {
      sub_10004D2C8(v54);
    }
    sub_10004D2C8(v17);
  }
  uint64_t v20 = *(void *)(v2 + 160);
  if (v20)
  {
    char v21 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v21) {
      goto LABEL_55;
    }
    uint64_t v22 = *(void *)(v2 + 8);
    long long v23 = std::__shared_weak_count::lock(v21);
    if (!v23) {
      goto LABEL_55;
    }
    uint64_t v24 = v23;
    atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v23);
    NotifySubscription::cancel((NotifySubscription *)v20);
    uint64_t v25 = (std::__shared_weak_count *)operator new(0x30uLL);
    v25->__shared_weak_owners_ = 0;
    v25->__shared_owners_ = 0;
    v25->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF2F8;
    v25[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
    v25[1].__shared_owners_ = v22;
    v25[1].__shared_weak_owners_ = (uint64_t)v24;
    long long v26 = *(const char **)v20;
    long long v27 = *(NSObject **)(v20 + 8);
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v50 = 3321888768;
    std::string::size_type v51 = sub_10071C688;
    unsigned __int8 v52 = (uint8_t *)&unk_1019FF2B8;
    long long v53 = v25 + 1;
    int v54 = v25;
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v26, (int *)(v20 + 16), v27, buf);
    if (v54) {
      sub_10004D2C8(v54);
    }
    sub_10004D2C8(v25);
  }
  uint64_t v28 = *(void *)(v2 + 176);
  if (v28)
  {
    int v29 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v29) {
      goto LABEL_55;
    }
    uint64_t v30 = *(void *)(v2 + 8);
    uint64_t v31 = std::__shared_weak_count::lock(v29);
    if (!v31) {
      goto LABEL_55;
    }
    uint64_t v32 = v31;
    atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v31);
    NotifySubscription::cancel((NotifySubscription *)v28);
    std::string::size_type v33 = (std::__shared_weak_count *)operator new(0x30uLL);
    v33->__shared_weak_owners_ = 0;
    v33->__shared_owners_ = 0;
    v33->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF378;
    v33[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
    v33[1].__shared_owners_ = v30;
    v33[1].__shared_weak_owners_ = (uint64_t)v32;
    int v34 = *(const char **)v28;
    uint64_t v35 = *(NSObject **)(v28 + 8);
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v50 = 3321888768;
    std::string::size_type v51 = sub_10071C81C;
    unsigned __int8 v52 = (uint8_t *)&unk_1019FF338;
    long long v53 = v33 + 1;
    int v54 = v33;
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v34, (int *)(v28 + 16), v35, buf);
    if (v54) {
      sub_10004D2C8(v54);
    }
    sub_10004D2C8(v33);
  }
  uint64_t v36 = *(void *)(v2 + 184);
  if (!v36) {
    goto LABEL_54;
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v37 || (v38 = *(void *)(v2 + 8), (uint64_t v39 = std::__shared_weak_count::lock(v37)) == 0)) {
LABEL_55:
  }
    sub_100088B9C();
  char v40 = v39;
  atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v39);
  NotifySubscription::cancel((NotifySubscription *)v36);
  std::string::size_type v41 = (std::__shared_weak_count *)operator new(0x30uLL);
  v41->__shared_weak_owners_ = 0;
  v41->__shared_owners_ = 0;
  v41->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF3F8;
  v41[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v41[1].__shared_owners_ = v38;
  v41[1].__shared_weak_owners_ = (uint64_t)v40;
  int v42 = *(const char **)v36;
  int v43 = *(NSObject **)(v36 + 8);
  *(void *)std::string buf = _NSConcreteStackBlock;
  uint64_t v50 = 3321888768;
  std::string::size_type v51 = sub_10071C9B0;
  unsigned __int8 v52 = (uint8_t *)&unk_1019FF3B8;
  long long v53 = v41 + 1;
  int v54 = v41;
  atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v42, (int *)(v36 + 16), v43, buf);
  if (v54) {
    sub_10004D2C8(v54);
  }
  sub_10004D2C8(v41);
LABEL_54:
  sub_100088C88(&v46);
  return sub_100046B58((uint64_t *)&v45);
}

void sub_10071C09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071C158()
{
}

void *sub_10071C16C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FF138;
  result[1] = v3;
  return result;
}

uint64_t sub_10071C1B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FF138;
  a2[1] = v2;
  return result;
}

void sub_10071C1E0(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/buddy_state");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_10071C294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10071C2D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10071C318()
{
}

void sub_10071C328()
{
}

void *sub_10071C33C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FF1C8;
  result[1] = v3;
  return result;
}

uint64_t sub_10071C384(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FF1C8;
  a2[1] = v2;
  return result;
}

void sub_10071C3B0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/setup_language_selection_done");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10071C460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10071C4A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10071C4E8()
{
}

void sub_10071C4F4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  xpc_object_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)xpc_object_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setup Assistant exited", v9, 2u);
        }
        *(_DWORD *)(v3 + 112) = 2;
        uint64_t v7 = v3 + 112;
        uint64_t v8 = *(void *)(v7 - 8);
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10071C5C0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10071C5D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10071C5F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10071C600(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF278;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10071C620(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF278;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10071C674(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10071C688(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)xpc_object_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setup Assistant finished", v9, 2u);
        }
        *(_DWORD *)(v3 + 112) = 3;
        uint64_t v7 = v3 + 112;
        uint64_t v8 = *(void *)(v7 - 8);
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10071C754(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10071C768(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10071C784(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10071C794(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF2F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10071C7B4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF2F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10071C808(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10071C81C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)xpc_object_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setup Assistant launched", v9, 2u);
        }
        *(_DWORD *)(v3 + 112) = 1;
        uint64_t v7 = v3 + 112;
        uint64_t v8 = *(void *)(v7 - 8);
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10071C8E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10071C8FC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10071C918(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10071C928(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF378;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10071C948(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10071C99C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10071C9B0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)xpc_object_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setup language selection done", v9, 2u);
        }
        *(unsigned char *)(v3 + 152) = 1;
        uint64_t v7 = v3 + 152;
        uint64_t v8 = *(void *)(v7 - 8);
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10071CA7C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10071CA90(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10071CAAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10071CABC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF3F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10071CADC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF3F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10071CB30(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10071CB44(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 16))(v1)) {
    int v3 = 1;
  }
  else {
    int v3 = 3;
  }
  *(_DWORD *)(v1 + 112) = v3;
  uint64_t v4 = *(void *)(v1 + 104);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v1 + 112);
  }
  char v5 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asString();
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Initial state is: %s", buf, 0xCu);
  }
  operator delete();
}

void sub_10071CCC0()
{
}

void sub_10071CCEC(Registry **a1, uint64_t a2, void (**a3)(void *, xpc_object_t *))
{
  xpc_object_t v35 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    xpc_object_t v7 = v6;
    xpc_object_t v35 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v35 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  xpc_object_t v35 = v8;
LABEL_9:
  xpc_release(v7);
  *(void *)std::string buf = a2;
  std::string::size_type v33 = "kPeriods";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v10 = xpc::dyn_cast_or_default((xpc *)&object, 0, v9);
  xpc_release(object);
  if (!v10)
  {
    xpc_object_t v30 = xpc_int64_create(22);
    if (!v30) {
      xpc_object_t v30 = xpc_null_create();
    }
    *(void *)std::string buf = &v35;
    std::string::size_type v33 = "kPosixError";
    sub_100035E70((uint64_t)buf, &v30, &v31);
    xpc_release(v31);
    xpc_object_t v31 = 0;
    xpc_release(v30);
    xpc_object_t v29 = v35;
    xpc_object_t v30 = 0;
    if (v35) {
      xpc_retain(v35);
    }
    else {
      xpc_object_t v29 = xpc_null_create();
    }
    a3[2](a3, &v29);
    xpc_release(v29);
    xpc_object_t v29 = 0;
    goto LABEL_44;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_16;
      }
LABEL_28:
      if (a3) {
        a3 = (void (**)(void *, xpc_object_t *))_Block_copy(a3);
      }
      xpc_object_t v22 = v35;
      xpc_object_t v27 = v35;
      if (v35)
      {
        xpc_retain(v35);
        if (a3)
        {
LABEL_32:
          long long v23 = _Block_copy(a3);
          goto LABEL_35;
        }
      }
      else
      {
        xpc_object_t v22 = xpc_null_create();
        xpc_object_t v27 = v22;
        if (a3) {
          goto LABEL_32;
        }
      }
      long long v23 = 0;
LABEL_35:
      uint64_t v37 = 0;
      v36[0] = off_1019FF468;
      v36[1] = v22;
      xpc_object_t v27 = xpc_null_create();
      aBlock = 0;
      _OWORD v36[2] = v23;
      uint64_t v37 = v36;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v19 + 176))(v19, v10, v36);
      sub_10071E5C0(v36);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      if (a3) {
        _Block_release(a3);
      }
      if ((v20 & 1) == 0) {
        goto LABEL_43;
      }
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
  if (v19) {
    goto LABEL_28;
  }
LABEL_16:
  char v21 = *(NSObject **)getDataUsageLog();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Data usage controller is not valid", buf, 2u);
  }
  xpc_object_t v25 = xpc_int64_create(2);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  std::string::size_type v33 = "kPosixError";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v24 = v35;
  xpc_object_t v25 = 0;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  a3[2](a3, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if ((v20 & 1) == 0) {
LABEL_43:
  }
    sub_10004D2C8(v18);
LABEL_44:
  xpc_release(v35);
}

void sub_10071D0F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, char a12, uint64_t a13, xpc_object_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,xpc_object_t a21,char a22)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10071D208(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

void sub_10071D24C(Registry **a1, xpc_object_t *a2, int a3, uint64_t a4)
{
  xpc_object_t v76 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  if (v8)
  {
    xpc_object_t v9 = v8;
    xpc_object_t v76 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v76 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_9;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_8:
  xpc_object_t v76 = v10;
LABEL_9:
  xpc_release(v9);
  CFURLRef v75 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    std::mutex::unlock(v12);
    goto LABEL_93;
  }
  uint64_t v18 = v17[3];
  uint64_t v19 = (std::__shared_weak_count *)v17[4];
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v12);
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v19);
    if (!v18) {
      goto LABEL_92;
    }
  }
  else
  {
    std::mutex::unlock(v12);
    if (!v18) {
      goto LABEL_93;
    }
  }
  CFTypeRef v74 = 0;
  (*(void (**)(ctu **__return_ptr, uint64_t))(*(void *)v18 + 8))(&v74, v18);
  if (v74) {
    xpc_object_t v22 = sub_100080778;
  }
  else {
    xpc_object_t v22 = 0;
  }
  if (a3)
  {
    if (!v22) {
      goto LABEL_91;
    }
    CFStringRef filePath = 0;
    int v73 = &off_101A0BD40;
    std::string::size_type v71 = 0;
    std::string __p = 0;
    *(void *)&long long v82 = 0;
    std::string::size_type v58 = v19;
    if (ctu::cf::convert_copy((ctu::cf *)&v82, (const __CFString **)"DataUsage", (const char *)0x8000100, kCFAllocatorDefault, v21))
    {
      long long v23 = __p;
      std::string __p = (void *)v82;
      *(void *)std::string buf = v23;
      sub_1000558F4((const void **)buf);
    }
    std::string::size_type v71 = __p;
    std::string __p = 0;
    sub_1000558F4((const void **)&__p);
    std::string __p = 0;
    long long v70 = 0uLL;
    do
    {
      while (1)
      {
        xpc_object_t v24 = NSTemporaryDirectory();
        xpc_object_t v25 = v71;
        uint64_t v26 = rand();
        CFStringRef v27 = CFStringCreateWithFormat(0, 0, @"%@%@.%d.sqlite", v24, v25, v26);
        CFStringRef v28 = filePath;
        CFStringRef filePath = v27;
        *(void *)std::string buf = v28;
        sub_1000558F4((const void **)buf);
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        xpc_object_t v29 = *(void ***)buf;
        *(void *)&long long v82 = *(void *)&buf[8];
        *(void *)((char *)&v82 + 7) = *(void *)&buf[15];
        int v30 = (char)buf[23];
        if (SHIBYTE(v70) < 0) {
          operator delete(__p);
        }
        std::string __p = v29;
        *(void *)&long long v70 = v82;
        *(void *)((char *)&v70 + 7) = *(void *)((char *)&v82 + 7);
        HIBYTE(v70) = v30;
        xpc_object_t v31 = (char *)(v30 >= 0 ? &__p : v29);
        sub_100058DB0(buf, v31);
        unsigned __int8 v32 = sub_1007ECCD4((uint64_t)&v73, (uint64_t *)buf);
        unsigned __int8 v33 = v32;
        if ((char)buf[23] < 0) {
          break;
        }
        if ((v32 & 1) == 0) {
          goto LABEL_35;
        }
      }
      operator delete(*(void **)buf);
    }
    while ((v33 & 1) != 0);
LABEL_35:
    uint64_t v19 = v58;
    if ((*(uint64_t (**)(uint64_t, void **))(*(void *)v18 + 160))(v18, &__p))
    {
      CFURLRef v34 = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 0);
      CFURLRef v35 = v75;
      CFURLRef v75 = v34;
      *(void *)std::string buf = v35;
      sub_1000FE824((const void **)buf);
      int v36 = 1;
    }
    else
    {
      CFStringRef v68 = 0;
      uint64_t v47 = sub_1001D2EC8();
      if (*((char *)v47 + 23) < 0)
      {
        sub_10004FC84(v66, *(void **)v47, *((void *)v47 + 1));
      }
      else
      {
        long long v48 = *v47;
        uint64_t v67 = *((void *)v47 + 2);
        *(_OWORD *)BOOL v66 = v48;
      }
      if (SHIBYTE(v67) < 0)
      {
        sub_10004FC84(&v82, v66[0], (unint64_t)v66[1]);
      }
      else
      {
        long long v82 = *(_OWORD *)v66;
        uint64_t v83 = v67;
      }
      CFStringRef v77 = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(buf, (void *)v82, *((unint64_t *)&v82 + 1));
      }
      else
      {
        *(_OWORD *)std::string buf = v82;
        *(void *)&uint8_t buf[16] = v83;
      }
      CFStringRef v78 = 0;
      if (ctu::cf::convert_copy())
      {
        CFStringRef v50 = v77;
        CFStringRef v77 = v78;
        *(void *)long long v79 = v50;
        sub_1000558F4((const void **)v79);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      CFStringRef v68 = v77;
      CFStringRef v77 = 0;
      sub_1000558F4((const void **)&v77);
      if (SHIBYTE(v83) < 0) {
        operator delete((void *)v82);
      }
      if (SHIBYTE(v67) < 0) {
        operator delete(v66[0]);
      }
      std::string::size_type v51 = v68 ? sub_1000810B8 : 0;
      if (v51 && (v71 ? (unsigned __int8 v52 = sub_1000810B8) : (unsigned __int8 v52 = 0), v52))
      {
        CFStringRef v78 = 0;
        CFStringRef v78 = CFStringCreateWithFormat(0, 0, @"%@/%@.sqlite", v68, v71);
        long long v53 = *(NSObject **)getDataUsageLog();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          long long v82 = *(_OWORD *)buf;
          uint64_t v83 = *(void *)&buf[16];
          p_p = __p;
          std::string::size_type v57 = *(long long **)buf;
          if ((buf[23] & 0x80u) == 0) {
            std::string::size_type v57 = &v82;
          }
          if (v70 >= 0) {
            p_p = &__p;
          }
          *(_DWORD *)long long v79 = 136315394;
          *(void *)&v79[4] = v57;
          __int16 v80 = 2080;
          long long v81 = p_p;
          _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "failed to copy DB %s to %s", v79, 0x16u);
          if (SHIBYTE(v83) < 0) {
            operator delete((void *)v82);
          }
        }
        sub_1000558F4((const void **)&v78);
      }
      else
      {
        int v54 = *(NSObject **)getDataUsageLog();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          long long v55 = &__p;
          if (v70 < 0) {
            long long v55 = __p;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v55;
          _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "failed to copy DB <empty> to %s", buf, 0xCu);
        }
      }
      sub_1000558F4((const void **)&v68);
      int v36 = 0;
    }
    if (SHIBYTE(v70) < 0) {
      operator delete(__p);
    }
    sub_1000558F4((const void **)&v71);
    sub_1000558F4((const void **)&filePath);
    FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v73);
    if (!v36)
    {
LABEL_91:
      sub_100057D78((const void **)&v74);
      if (v19) {
LABEL_92:
      }
        sub_10004D2C8(v19);
LABEL_93:
      xpc_object_t v60 = xpc_int64_create(2);
      if (!v60) {
        xpc_object_t v60 = xpc_null_create();
      }
      *(void *)std::string buf = &v76;
      *(void *)&uint8_t buf[8] = "kPosixError";
      sub_100035E70((uint64_t)buf, &v60, &v61);
      xpc_release(v61);
      xpc_object_t v61 = 0;
      xpc_release(v60);
      uint64_t v49 = 0;
      xpc_object_t v60 = 0;
      goto LABEL_96;
    }
  }
  else if (!v22)
  {
    goto LABEL_91;
  }
  ctu::cf_to_xpc((uint64_t *)&v64, v74, v20);
  *(void *)std::string buf = &v76;
  *(void *)&uint8_t buf[8] = "kCUWorkspaceInfo";
  sub_100035E70((uint64_t)buf, &v64, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v64);
  xpc_object_t v64 = 0;
  uint64_t v37 = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v38 = v37;
  uint64_t v39 = "11CCXpcServer";
  if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
  {
    char v40 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = 5381;
    do
    {
      uint64_t v39 = (const char *)v41;
      unsigned int v42 = *v40++;
      uint64_t v41 = (33 * v41) ^ v42;
    }
    while (v42);
  }
  std::mutex::lock(v37);
  *(void *)std::string buf = v39;
  int v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)buf);
  if (v43)
  {
    uint64_t v44 = v43[3];
    std::string::size_type v45 = (std::__shared_weak_count *)v43[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v38);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v46 = 0;
      if (!v44) {
        goto LABEL_56;
      }
LABEL_47:
      memset(buf, 0, sizeof(buf));
      sub_100C663EC(a2, (uint64_t)buf);
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)buf;
        uint64_t v63 = *(void *)&buf[16];
      }
      (*(void (**)(uint64_t, void **))(*(void *)v18 + 264))(v18, __dst);
      if (SHIBYTE(v63) < 0) {
        operator delete(__dst[0]);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v38);
  std::string::size_type v45 = 0;
  char v46 = 1;
  if (v44) {
    goto LABEL_47;
  }
LABEL_56:
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  sub_100057D78((const void **)&v74);
  if (v19) {
    sub_10004D2C8(v19);
  }
  uint64_t v49 = 1;
LABEL_96:
  xpc_object_t v59 = v76;
  if (v76) {
    xpc_retain(v76);
  }
  else {
    xpc_object_t v59 = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *, CFURLRef, uint64_t))(a4 + 16))(a4, &v59, v75, v49);
  xpc_release(v59);
  xpc_object_t v59 = 0;
  sub_1000FE824((const void **)&v75);
  xpc_release(v76);
}

void sub_10071DB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, xpc_object_t object, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,const void *a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,const void *a42,const void *a43,__int16 a44,char a45,char a46,int a47,const void *a48,const void *a49)
{
  if (*(char *)(v49 - 105) < 0) {
    operator delete(*(void **)(v49 - 128));
  }
  sub_1000558F4((const void **)(v49 - 200));
  sub_1000558F4(&a35);
  if (a41 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a42);
  sub_1000558F4(&a43);
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a44);
  sub_100057D78(&a48);
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_1000FE824(&a49);
  xpc_release(*(xpc_object_t *)(v49 - 216));
  _Unwind_Resume(a1);
}

void sub_10071DD28(Registry **a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  if (v5)
  {
    xpc_object_t v6 = v5;
    xpc_object_t v24 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v24 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v24 = v7;
LABEL_9:
  xpc_release(v6);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v9 = ServiceMap;
  if (v10 < 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_21:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_15;
    }
LABEL_22:
    (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
    goto LABEL_23;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_21;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
    goto LABEL_22;
  }
LABEL_15:
  uint64_t v18 = *(NSObject **)getDataUsageLog();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Data usage controller is not valid", buf, 2u);
  }
  xpc_object_t v22 = xpc_int64_create(2);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)std::string buf = &v24;
  CFAllocatorRef v21 = "kPosixError";
  sub_100035E70((uint64_t)buf, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
LABEL_23:
  xpc_object_t v19 = v24;
  if (v24) {
    xpc_retain(v24);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(a3 + 16))(a3, &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  xpc_release(v24);
}

void sub_10071DF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10071DFF4(uint64_t a1)
{
  *(void *)a1 = off_1019FF468;
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    _Block_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_10071E054(uint64_t a1)
{
  *(void *)a1 = off_1019FF468;
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    _Block_release(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;

  operator delete();
}

xpc_object_t *sub_10071E0D4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (xpc_object_t *)operator new(0x18uLL);
  *uint64_t v2 = off_1019FF468;
  sub_10071E4A4(v2 + 1, v1);
  return v2;
}

xpc_object_t *sub_10071E128(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FF468;
  return sub_10071E4A4((xpc_object_t *)(a2 + 8), a1 + 8);
}

void sub_10071E154(uint64_t a1)
{
}

void sub_10071E15C(void *a1)
{
  sub_10071E500((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10071E198(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v4 = (xpc_object_t *)(a1 + 8);
  if ((*a3 & 0xFF00000000) != 0)
  {
    xpc_object_t v10 = xpc_int64_create((int)*a3);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
LABEL_4:
    *(void *)&long long buf = v4;
    *((void *)&buf + 1) = "kPosixError";
    sub_100035E70((uint64_t)&buf, &v10, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v10);
    xpc_object_t v10 = 0;
    goto LABEL_5;
  }
  uint64_t v5 = *a2;
  if (!*a2)
  {
    xpc_object_t v8 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Got empty data usage", (uint8_t *)&buf, 2u);
    }
    xpc_object_t v10 = xpc_int64_create(45);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    goto LABEL_4;
  }
  xpc_object_t object = 0;
  xpc_object_t v6 = +[NSKeyedArchiver archivedDataWithRootObject:v5 requiringSecureCoding:1 error:&object];
  if (object)
  {
    xpc_object_t v7 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = object;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Error encoding data usage: %@", (uint8_t *)&buf, 0xCu);
    }
    xpc_object_t v9 = xpc_int64_create(92);
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    *(void *)&long long buf = v4;
    *((void *)&buf + 1) = "kPosixError";
    sub_100035E70((uint64_t)&buf, &v9, &v10);
    xpc_release(v10);
    xpc_object_t v10 = 0;
    xpc_release(v9);
    xpc_object_t v9 = 0;
  }
  else
  {
    xpc_dictionary_set_data(*v4, "kDeviceDataUsage", [(NSData *)v6 bytes], [(NSData *)v6 length]);
  }
LABEL_5:
  sub_10071E540((uint64_t *)(a1 + 16), v4);
}

void sub_10071E3F4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10071E458(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10071E498()
{
}

xpc_object_t *sub_10071E4A4(xpc_object_t *a1, uint64_t a2)
{
  xpc_object_t v4 = *(xpc_object_t *)a2;
  *a1 = *(xpc_object_t *)a2;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *a1 = xpc_null_create();
  }
  uint64_t v5 = *(void **)(a2 + 8);
  if (v5) {
    uint64_t v5 = _Block_copy(v5);
  }
  a1[1] = v5;
  return a1;
}

void sub_10071E500(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

void sub_10071E540(uint64_t *a1, void **a2)
{
  uint64_t v2 = *a1;
  int v3 = *a2;
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(v2 + 16))(v2, &object);
  xpc_release(object);
}

void sub_10071E5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void *sub_10071E5C0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_10071E644(uint64_t a1)
{
  sub_100C62700(a1, "kCUGetWorkspaceInfo", (unint64_t)sub_10071E7D4, 0xAu);
  sub_100C62700(a1, "kCUGetRecordsStartDate", (unint64_t)sub_10071E888, 0xAu);
  sub_100C62700(a1, "kCUEraseRecords", (unint64_t)sub_10071EAE4, 0xAu);
  sub_100C62700(a1, "kCUGetShowUsageAlert", (unint64_t)nullsub_1826, 0xAu);
  sub_100C62700(a1, "kCUSetShowUsageAlert", (unint64_t)nullsub_1827, 0xAu);
  sub_100C62700(a1, "kCUSetAlertParameters", (unint64_t)nullsub_1828, 0xAu);
  sub_100C62700(a1, "kCUGetAlertParameters", (unint64_t)nullsub_1829, 0xAu);
  sub_100C62700(a1, "kCUGetDataUsageForSubscriber", (unint64_t)sub_10071EBA0, 0xAu);
  sub_100C62700(a1, "kCUGetWorkspaceInfoEx", (unint64_t)sub_10071EF80, 0xAu);

  return sub_100C62700(a1, "kCUEraseRecordsEx", (unint64_t)sub_10071F12C, 0xAu);
}

void sub_10071E7D4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _OWORD v6[2] = sub_10071F2E0;
  uint64_t v6[3] = &unk_1019FF518;
  uint64_t v5 = (std::__shared_weak_count *)a5[1];
  v6[4] = *a5;
  xpc_object_t v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10071D24C(a1, a4, 0, (uint64_t)v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_10071E870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071E888(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    xpc_object_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, v20);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    uint64_t v16 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Data usage controller is not valid", (uint8_t *)v20, 2u);
    }
    goto LABEL_21;
  }
LABEL_11:
  CFDateRef theDate = 0;
  (*(void (**)(CFDateRef *__return_ptr, uint64_t))(*(void *)v14 + 48))(&theDate, v14);
  if (theDate) {
    char v17 = sub_1001908E4;
  }
  else {
    char v17 = 0;
  }
  if (v17)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
    xpc_object_t v21 = xpc_double_create(AbsoluteTime);
    if (!v21) {
      xpc_object_t v21 = xpc_null_create();
    }
    v20[0] = *a5;
    v20[1] = (unint64_t)"kCURecordsStartDate";
    sub_100035E70((uint64_t)v20, &v21, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v21);
    xpc_object_t v21 = 0;
  }
  else
  {
    xpc_object_t v19 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to get start date of usage records", (uint8_t *)v20, 2u);
    }
  }
  sub_10007CA64((const void **)&theDate);
LABEL_21:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_10071EAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10007CA64((const void **)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void sub_10071EAE4(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _OWORD v6[2] = sub_10071F3C4;
  uint64_t v6[3] = &unk_1019FF548;
  uint64_t v5 = (std::__shared_weak_count *)a5[1];
  v6[4] = *a5;
  char v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10071DD28(a1, a2, (uint64_t)v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_10071EB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071EBA0(Registry **a1, uint64_t a2, uint64_t a3, const __CFNumber *a4, void *a5)
{
  std::string __p = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  v29[0] = a4;
  v29[1] = (const __CFNumber *)"kCUGetDataUsageSubscriberID";
  sub_100048BAC((uint64_t)v29, &object);
  *(void *)long long buf = 0;
  CFURLRef v35 = 0;
  uint64_t v36 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v36) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object);
  uint64_t v7 = HIBYTE(v33);
  if (v33 < 0) {
    uint64_t v7 = v32;
  }
  if (!v7)
  {
    char v20 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Subscriber ID is not valid", buf, 2u);
    }
    goto LABEL_28;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v9 = ServiceMap;
  if (v10 < 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_17:
    std::mutex::unlock(v9);
    char v15 = 0;
    char v17 = 1;
    if (!v16)
    {
LABEL_12:
      uint64_t v18 = *(NSObject **)getDataUsageLog();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        xpc_object_t v19 = "Data Usage Controller not found";
        goto LABEL_32;
      }
      goto LABEL_26;
    }
    goto LABEL_18;
  }
  uint64_t v16 = v14[3];
  char v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_12;
  }
LABEL_18:
  v29[0] = 0;
  xpc_object_t object = 0;
  int v28 = 0;
  if (((*(uint64_t (**)(uint64_t, void **, const __CFNumber **, xpc_object_t *, int *))(*(void *)v16 + 64))(v16, &__p, v29, &object, &v28) & 1) == 0)
  {
    uint64_t v18 = *(NSObject **)getDataUsageLog();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      xpc_object_t v19 = "Subscriber ID not found";
LABEL_32:
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v19, buf, 2u);
      if (v17) {
        goto LABEL_28;
      }
LABEL_27:
      sub_10004D2C8(v15);
      goto LABEL_28;
    }
LABEL_26:
    if (v17) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v26 = Mutable;
  CFTypeRef cf = Mutable;
  if (Mutable) {
    CFRetain(Mutable);
  }
  sub_10071F4A8(&v26, @"kCTCellularUsageTotalDataUsed", v29[0]);
  sub_10005717C((const void **)&v26);
  CFTypeRef v25 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_10071F4A8((CFMutableDictionaryRef *)&v25, @"kCTCellularUsageRoamingDataUsed", (const __CFNumber *)object);
  sub_10005717C(&v25);
  ctu::cf_to_xpc((uint64_t *)&v23, (ctu *)cf, v22);
  *(void *)long long buf = *a5;
  CFURLRef v35 = "kCUGetDataUsageParameters";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  sub_10005717C(&cf);
  if ((v17 & 1) == 0) {
    goto LABEL_27;
  }
LABEL_28:
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
}

void sub_10071EEDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10071EF80(Registry **a1, uint64_t a2, uint64_t a3, void **a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v22);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_18;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_18;
  }
LABEL_10:
  char v17 = *a4;
  xpc_object_t object = v17;
  if (v17) {
    xpc_retain(v17);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v18 = (std::__shared_weak_count *)a5[1];
  uint64_t v19 = *a5;
  char v20 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, xpc_object_t *, uint64_t *))(*(void *)v15 + 72))(v15, &object, &v19);
  if (v20) {
    sub_10004D2C8(v20);
  }
  xpc_release(object);
  xpc_object_t object = 0;
LABEL_18:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_10071F0F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, xpc_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  xpc_release(object);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(a1);
}

void sub_10071F12C(Registry **a1, uint64_t a2, uint64_t a3, void **a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v22);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_18;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_18;
  }
LABEL_10:
  char v17 = *a4;
  xpc_object_t object = v17;
  if (v17) {
    xpc_retain(v17);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v18 = (std::__shared_weak_count *)a5[1];
  uint64_t v19 = *a5;
  char v20 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *, uint64_t *))(*(void *)v15 + 56))(v15, "kCUEraseRecordsEx", &object, &v19);
  if (v20) {
    sub_10004D2C8(v20);
  }
  xpc_release(object);
  xpc_object_t object = 0;
LABEL_18:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_10071F2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, xpc_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  xpc_release(object);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(a1);
}

void sub_10071F2E0(uint64_t a1, void **a2)
{
  int v3 = *a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _OWORD v6[2] = sub_10071F394;
  uint64_t v6[3] = &unk_1019FF4E8;
  uint64_t v5 = *(void *)(a1 + 32);
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  v6[4] = v5;
  uint64_t v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_apply(v3, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_10071F37C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10071F394(uint64_t a1, const char *a2, void *a3)
{
  int v3 = *(void ***)(a1 + 32);
  if (v3) {
    xpc_object_t v4 = *v3;
  }
  else {
    xpc_object_t v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

void sub_10071F3C4(uint64_t a1, void **a2)
{
  int v3 = *a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _OWORD v6[2] = sub_10071F478;
  uint64_t v6[3] = &unk_1019FF4E8;
  uint64_t v5 = *(void *)(a1 + 32);
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  v6[4] = v5;
  uint64_t v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_apply(v3, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_10071F460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10071F478(uint64_t a1, const char *a2, void *a3)
{
  int v3 = *(void ***)(a1 + 32);
  if (v3) {
    xpc_object_t v4 = *v3;
  }
  else {
    xpc_object_t v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

const void **sub_10071F4A8(CFMutableDictionaryRef *a1, const void *a2, const __CFNumber *a3)
{
  CFNumberRef v10 = 0;
  CFNumberRef valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v10;
    CFNumberRef v10 = v5;
    CFNumberRef valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v7 = v10;
  CFNumberRef v9 = v10;
  CFNumberRef v10 = 0;
  sub_1000570E8((const void **)&v10);
  CFDictionarySetValue(*a1, a2, v7);
  return sub_1000570E8((const void **)&v9);
}

void sub_10071F538(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10071F558()
{
  return sub_100C624B8((uint64_t)&unk_101B0D580, (uint64_t)sub_10071E644);
}

uint64_t sub_10071F574(uint64_t a1, long long *a2, long long *a3)
{
  CFNumberRef v5 = (uint64_t **)(a1 + 24);
  if ((void **)(a1 + 32) == sub_100046F68(a1 + 24, (void **)a3))
  {
    uint64_t v11 = a3;
    CFNumberRef v6 = sub_100720DBC(v5, (void **)a3, &v11);
    sub_1000D8B1C((uint64_t)(v6 + 7), 0, 0, 0);
  }
  CFNumberRef v7 = (uint64_t *)sub_10005DDEC((uint64_t)v5, (void **)a3);
  unint64_t v8 = v7;
  unint64_t v9 = v7[1];
  if (v9 >= v7[2])
  {
    uint64_t result = sub_100048008(v7, a2);
  }
  else
  {
    sub_1000D87F8(v7, a2);
    uint64_t result = v9 + 24;
  }
  v8[1] = result;
  return result;
}

uint64_t sub_10071F624(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  CFNumberRef v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)CFNumberRef v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  return a1;
}

void sub_10071F6A8(Registry **a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  unint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    CFNumberRef v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_9:
  char v17 = *a2;
  uint64_t v18 = *a2;
  if (!v15)
  {
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to parse resource lists XML - client factory not present", buf, 2u);
    }
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 88) = 0;
    if ((v16 & 1) == 0) {
      goto LABEL_29;
    }
    return;
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Decoding resource lists XML document using BlastDoor", buf, 2u);
  }
  int v19 = *((char *)a3 + 23);
  if (v19 >= 0) {
    char v20 = a3;
  }
  else {
    char v20 = (uint64_t *)*a3;
  }
  if (v19 >= 0) {
    uint64_t v21 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v21 = a3[1];
  }
  unint64_t v22 = +[NSData nonOwningDataWithBytes:v20 length:v21];
  CFURLRef v34 = 0;
  CFURLRef v35 = 0;
  uint64_t v33 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v15 + 16))(&v33, v15);
  long long v31 = 0u;
  long long v32 = 0u;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = &v35;
  (*(void (**)(long long *__return_ptr))(*(void *)v33 + 64))(&v31);
  sub_100128064((const void **)buf);
  xpc_object_t v23 = v35;
  if (v35) {
    xpc_object_t v24 = sub_10039195C;
  }
  else {
    xpc_object_t v24 = 0;
  }
  if (v24)
  {
    CFTypeRef v25 = *a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
LABEL_23:
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 88) = 0;
      goto LABEL_24;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v23;
    int v28 = "Failed to unpack resource lists: %@";
    xpc_object_t v29 = v25;
    uint32_t v30 = 12;
LABEL_41:
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, buf, v30);
    goto LABEL_23;
  }
  if (!BYTE8(v32))
  {
    CFStringRef v27 = *a2;
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_WORD *)long long buf = 0;
    int v28 = "resource lists unpack succeeded, but returned nil!";
    xpc_object_t v29 = v27;
    uint32_t v30 = 2;
    goto LABEL_41;
  }
  memset(v38, 0, sizeof(v38));
  *(_OWORD *)long long buf = 0u;
  sub_1000302C0((char *)v38 + 8, (long long *)v31, *((long long **)&v31 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v31 + 1) - v31) >> 3));
  int v43 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  *(_OWORD *)a4 = *(_OWORD *)buf;
  *(void *)(a4 + 16) = *(void *)&v38[0];
  memset(buf, 0, sizeof(buf));
  *(_OWORD *)(a4 + 24) = *(_OWORD *)((char *)v38 + 8);
  uint64_t v26 = *((void *)&v38[1] + 1);
  memset((char *)v38 + 8, 0, 24);
  *(void *)(a4 + 40) = v26;
  *(void *)(a4 + 48) = 0;
  *(void *)(a4 + 56) = 0;
  *(void *)(a4 + 64) = 0;
  *(void *)&v38[0] = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  *(_DWORD *)(a4 + 80) = 0;
  *(void *)(a4 + 72) = 0;
  *(unsigned char *)(a4 + 88) = 1;
  uint64_t v36 = (void **)v38 + 1;
  sub_100047F64(&v36);
  if (SBYTE7(v38[0]) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_24:
  if (BYTE8(v32))
  {
    *(void *)long long buf = &v31;
    sub_100047F64((void ***)buf);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  sub_100127D74(&v35);

  if ((v16 & 1) == 0) {
LABEL_29:
  }
    sub_10004D2C8(v14);
}

void sub_10071FA88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, std::__shared_weak_count *a14, const void *a15, uint64_t a16, uint64_t *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a12)
  {
    std::string __p = &a9;
    sub_100047F64((void ***)&__p);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100127D74(&a15);

  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_10071FB34(Registry **a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  unint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    CFNumberRef v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&buf);
  if (v13)
  {
    uint64_t v14 = v13[3];
    uint64_t v15 = (std::__shared_weak_count *)v13[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v16 = 1;
LABEL_9:
  char v17 = *a2;
  uint64_t v18 = *a2;
  if (v14)
  {
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Decoding conference info XML document using BlastDoor", (uint8_t *)&buf, 2u);
    }
    int v19 = *((char *)a3 + 23);
    if (v19 >= 0) {
      char v20 = a3;
    }
    else {
      char v20 = (uint64_t *)*a3;
    }
    if (v19 >= 0) {
      uint64_t v21 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v21 = a3[1];
    }
    unint64_t v22 = +[NSData nonOwningDataWithBytes:v20 length:v21];
    BOOL v66 = 0;
    uint64_t v67 = 0;
    uint64_t v65 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v14 + 16))(&v65, v14);
    uint64_t v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &v67;
    (*(void (**)(long long *__return_ptr))(*(void *)v65 + 56))(&v58);
    sub_100128064((const void **)&buf);
    xpc_object_t v23 = v67;
    if (v67) {
      char v24 = sub_10039195C;
    }
    else {
      char v24 = 0;
    }
    if (v24)
    {
      CFTypeRef v25 = *a2;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
LABEL_23:
        *(unsigned char *)a4 = 0;
        *(unsigned char *)(a4 + 144) = 0;
LABEL_78:
        sub_100720CAC((uint64_t)&v58);
        if (v66) {
          sub_10004D2C8(v66);
        }
        sub_100127D74(&v67);

        goto LABEL_81;
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v23;
      int v43 = "Failed to unpack conference info: %@";
      uint64_t v44 = v25;
      uint32_t v45 = 12;
LABEL_85:
      _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v43, (uint8_t *)&buf, v45);
      goto LABEL_23;
    }
    if (!(_BYTE)v64)
    {
      uint64_t v42 = *a2;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      LOWORD(buf) = 0;
      int v43 = "conference info unpack succeeded, but returned nil!";
      uint64_t v44 = v42;
      uint32_t v45 = 2;
      goto LABEL_85;
    }
    *(void *)&long long buf = (char *)&buf + 8;
    *((void *)&buf + 1) = 0;
    CFURLRef v75 = 0;
    uint64_t v76 = 0;
    uint64_t v73 = 0;
    CFTypeRef v74 = &v75;
    CFStringRef v77 = &v78;
    CFStringRef v78 = 0;
    memset(v80, 0, sizeof(v80));
    long long v81 = 0u;
    uint64_t v79 = 0;
    uint64_t v82 = 0;
    std::string::size_type v57 = v15;
    char v56 = v16;
    long long v55 = v22;
    if ((_BYTE)v62 && BYTE8(v59) && BYTE8(v61))
    {
      sub_100720B70((char *)__dst, &v58, &v60);
      sub_10071F624((uint64_t)&v80[1] + 8, (long long *)__dst);
      if (v71 < 0) {
        operator delete(__p);
      }
      if (v69 < 0) {
        operator delete(__dst[0]);
      }
    }
    CFStringRef v27 = (uint64_t *)*((void *)&v62 + 1);
    uint64_t v26 = (uint64_t *)v63;
LABEL_36:
    if (v27 == v26)
    {
      uint64_t v39 = *((void *)&buf + 1);
      *(void *)a4 = buf;
      *(void *)(a4 + 8) = v39;
      uint64_t v40 = a4 + 8;
      uint64_t v41 = v73;
      *(void *)(a4 + 16) = v73;
      if (v41)
      {
        *(void *)(v39 + 16) = v40;
        *(void *)&long long buf = (char *)&buf + 8;
        *((void *)&buf + 1) = 0;
        uint64_t v73 = 0;
      }
      else
      {
        *(void *)a4 = v40;
      }
      uint64_t v15 = v57;
      char v16 = v56;
      unint64_t v22 = v55;
      uint64_t v47 = v74;
      char v46 = v75;
      *(void *)(a4 + 32) = v75;
      uint64_t v48 = a4 + 32;
      *(void *)(a4 + 24) = v47;
      uint64_t v49 = v76;
      *(void *)(a4 + 40) = v76;
      if (v49)
      {
        int v46[2] = v48;
        CFTypeRef v74 = &v75;
        CFURLRef v75 = 0;
        uint64_t v76 = 0;
      }
      else
      {
        *(void *)(a4 + 24) = v48;
      }
      std::string::size_type v51 = (uint64_t *)v77;
      CFStringRef v50 = v78;
      *(void *)(a4 + 56) = v78;
      uint64_t v52 = a4 + 56;
      *(void *)(a4 + 48) = v51;
      uint64_t v53 = v79;
      *(void *)(a4 + 64) = v79;
      if (v53)
      {
        *((void *)v50 + 2) = v52;
        CFStringRef v77 = &v78;
        CFStringRef v78 = 0;
        uint64_t v79 = 0;
      }
      else
      {
        *(void *)(a4 + 48) = v52;
      }
      *(void *)(a4 + 88) = *(void *)&v80[1];
      uint64_t v54 = v82;
      *(void *)(a4 + 112) = *((void *)&v80[2] + 1);
      *(_OWORD *)(a4 + 72) = v80[0];
      memset(v80, 0, 24);
      *(_OWORD *)(a4 + 96) = *(_OWORD *)((char *)&v80[1] + 8);
      *(_OWORD *)((char *)&v80[1] + 8) = 0uLL;
      *(_OWORD *)(a4 + 120) = v81;
      *(void *)(a4 + 136) = v54;
      *((void *)&v80[2] + 1) = 0;
      long long v81 = 0uLL;
      uint64_t v82 = 0;
      *(unsigned char *)(a4 + 144) = 1;
      __dst[0] = v80;
      sub_100047F64((void ***)__dst);
      sub_10005CD2C((uint64_t)&v77, v78);
      sub_100720C08((uint64_t)&v74, v75);
      sub_100720C08((uint64_t)&buf, *((void **)&buf + 1));
      goto LABEL_78;
    }
    uint64_t v29 = *v27;
    uint64_t v28 = v27[1];
    while (1)
    {
      if (v29 == v28)
      {
        v27 += 3;
        goto LABEL_36;
      }
      if (*(unsigned char *)(v29 + 24) && *(unsigned char *)(v29 + 36))
      {
        int v30 = *(_DWORD *)(v29 + 32);
        if (*(unsigned char *)(v29 + 72) && *(unsigned char *)(v29 + 64))
        {
          if (v30 == 9)
          {
            sub_10071F574((uint64_t)&buf, (long long *)v29, (long long *)(v29 + 40));
            goto LABEL_64;
          }
          if (v30 == 6)
          {
            if ((void **)((char *)&buf + 8) == sub_100046F68((uint64_t)&buf, (void **)(v29 + 40)))
            {
              __dst[0] = (void *)(v29 + 40);
              long long v31 = sub_100720DBC((uint64_t **)&buf, (void **)(v29 + 40), (long long **)__dst);
              sub_1000D8B1C((uint64_t)(v31 + 7), 0, 0, 0);
            }
            long long v32 = (uint64_t *)sub_10005DDEC((uint64_t)&buf, (void **)(v29 + 40));
            uint64_t v33 = v32;
            unint64_t v34 = v32[1];
            if (v34 >= v32[2])
            {
              uint64_t v35 = sub_100048008(v32, (long long *)v29);
            }
            else
            {
              sub_1000D87F8(v32, (long long *)v29);
              uint64_t v35 = v34 + 24;
            }
            v33[1] = v35;
            if (!*(unsigned char *)(v29 + 24)) {
              sub_10016C840();
            }
          }
        }
        else if (v30 == 9)
        {
          if (*(unsigned char *)(v29 + 84) && *(_DWORD *)(v29 + 80) == 1) {
            sub_10071F574((uint64_t)&buf, (long long *)v29, (long long *)v29);
          }
          else {
            sub_100046BAC((uint64_t **)&v77, (void **)v29, v29);
          }
          goto LABEL_64;
        }
        uint64_t v36 = (long long *)*((void *)&v80[0] + 1);
        if (*((void *)&v80[0] + 1) >= *(void *)&v80[1])
        {
          uint64_t v38 = sub_100048008((uint64_t *)v80, (long long *)v29);
        }
        else
        {
          if (*(char *)(v29 + 23) < 0)
          {
            sub_10004FC84(*((unsigned char **)&v80[0] + 1), *(void **)v29, *(void *)(v29 + 8));
          }
          else
          {
            long long v37 = *(_OWORD *)v29;
            *(void *)(*((void *)&v80[0] + 1) + 16) = *(void *)(v29 + 16);
            *uint64_t v36 = v37;
          }
          uint64_t v38 = (uint64_t)v36 + 24;
        }
        *((void *)&v80[0] + 1) = v38;
      }
LABEL_64:
      v29 += 88;
    }
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to parse conference info XML - client factory not present", (uint8_t *)&buf, 2u);
  }
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 144) = 0;
LABEL_81:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1007201DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, int a13, char a14, std::__shared_weak_count *a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,const void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a30) {
    sub_10004D2C8(a30);
  }
  sub_100127D74(&a31);

  if ((a14 & 1) == 0) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007202B4(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  int v3 = (void **)(a1 + 72);
  sub_100047F64(&v3);
  sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  sub_100720C08(a1 + 24, *(void **)(a1 + 32));
  sub_100720C08(a1, *(void **)(a1 + 8));
  return a1;
}

std::string *sub_100720334@<X0>(std::string *__str@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t result = std::string::operator=((std::string *)a2, __str);
  if (__str[1].__r_.__value_.__s.__data_[4]) {
    *(unsigned char *)(a2 + 24) = LODWORD(__str[1].__r_.__value_.__l.__data_) == 200;
  }
  return result;
}

void sub_100720384(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_1007203A0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(void *)(a1 + 32) == *(void *)(a1 + 24))
  {
    *(_DWORD *)(a2 + 32) = 0;
    double result = 0.0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  else
  {
    uint64_t v27 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    memset(v14, 0, sizeof(v14));
    long long v13 = 0u;
    sub_10004BD84((uint64_t)&v13);
    sub_100058DB0(__p, "<?xml version=\"1.0\" encoding=\"utf-8\"?>");
    sub_1010E716C((uint64_t)&v13, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "<resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\" xmlns:cp=\"urn:ietf:params:xml:ns:copycontrol\">");
    sub_1010E716C((uint64_t)&v13, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "  <list>");
    sub_1010E716C((uint64_t)&v13, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v4 = *(void *)(a1 + 24);
    for (uint64_t i = *(void *)(a1 + 32); v4 != i; v4 += 24)
    {
      __p[0] = 0;
      __p[1] = 0;
      std::string::size_type v12 = 0;
      std::operator+<char>();
      long long v6 = std::string::append(&v10, "\" cp:copyControl=\"to\" />", 0x18uLL);
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      std::string::size_type v12 = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v10.__r_.__value_.__l.__data_);
      }
      sub_1010E716C((uint64_t)&v13, (uint64_t)__p);
      if (SHIBYTE(v12) < 0) {
        operator delete(__p[0]);
      }
    }
    sub_100058DB0(__p, "  </list>");
    sub_1010E716C((uint64_t)&v13, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    sub_10004B96C(v14, (uint64_t)"</resource-lists>", 17);
    sub_10004BC98((uint64_t)v14 + 8, __p);
    sub_100CC8650((void *)a2, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    *(void *)((char *)&v14[-1]
    *(void *)&v14[0] = v8;
    if (SHIBYTE(v16) < 0) {
      operator delete(*((void **)&v15 + 1));
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
  }
  return result;
}

void sub_1007206C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a23);
  _Unwind_Resume(a1);
}

double sub_100720734@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  if (!v3) {
    goto LABEL_38;
  }
  uint64_t v5 = *(unsigned __int8 *)(a1 + 47);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  if (v5)
  {
    uint64_t v39 = 0;
    long long __dst = 0u;
    long long v38 = 0u;
    std::operator+<char>();
    long long v6 = std::string::append(&v34, "\">\n <group-data>\n\t<request target=\"subject\">\n\t\t<action>set</action>\n\t\t<data><subject>", 0x55uLL);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    int v8 = *(char *)(a1 + 23);
    if (v8 >= 0) {
      uint64_t v9 = (const std::string::value_type *)a1;
    }
    else {
      uint64_t v9 = *(const std::string::value_type **)a1;
    }
    if (v8 >= 0) {
      std::string::size_type v10 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      std::string::size_type v10 = *(void *)(a1 + 8);
    }
    uint64_t v11 = std::string::append(&v35, v9, v10);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v36.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    long long v13 = std::string::append(&v36, "</subject></data>\n\t</request>\n </group-data>\n</cpm-group-management>", 0x44uLL);
    *(_OWORD *)std::string __p = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    *(void *)&v20[0] = *((void *)&v13->__r_.__value_.__l + 2);
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    sub_100CC8650(&__dst, (uint64_t)__p);
    if (SBYTE7(v20[0]) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    uint64_t v33 = 0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    *(_OWORD *)long long v21 = 0u;
    long long v22 = 0u;
    memset(v20, 0, sizeof(v20));
    *(_OWORD *)std::string __p = 0u;
    sub_10004BD84((uint64_t)__p);
    sub_1000BE8E8((uint64_t)__p, "Content-Type", off_101A8C278);
    if ((SBYTE7(v38) & 0x80u) == 0) {
      unint64_t v14 = BYTE7(v38);
    }
    else {
      unint64_t v14 = *((void *)&__dst + 1);
    }
    std::to_string(&v36, v14);
    sub_1000BE9C4((uint64_t)__p, "Content-Length", &v36);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    sub_10004B96C(v20, (uint64_t)"\r\n", 2);
    if ((SBYTE7(v38) & 0x80u) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (long long *)__dst;
    }
    if ((SBYTE7(v38) & 0x80u) == 0) {
      uint64_t v16 = BYTE7(v38);
    }
    else {
      uint64_t v16 = *((void *)&__dst + 1);
    }
    sub_10004B96C(v20, (uint64_t)p_dst, v16);
    sub_10004BC98((uint64_t)v20 + 8, &v36);
    sub_100CC8650((void *)a2, (uint64_t)&v36);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    *(void **)((char *)__p
    *(void *)&v20[0] = v17;
    if (SHIBYTE(v22) < 0) {
      operator delete(v21[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    if (SBYTE7(v38) < 0) {
      operator delete((void *)__dst);
    }
  }
  else
  {
LABEL_38:
    *(_DWORD *)(a2 + 32) = 0;
    double result = 0.0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  return result;
}

void sub_100720AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 - 105) < 0) {
    operator delete(*(void **)(v14 - 128));
  }
  sub_10008248C((uint64_t)&__p);
  if (*(char *)(v14 - 73) < 0) {
    operator delete(*(void **)(v14 - 96));
  }
  _Unwind_Resume(a1);
}

char *sub_100720B70(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v5;
  }
  long long v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)long long v6 = v7;
  }
  return __dst;
}

void sub_100720BEC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100720C08(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100720C08(a1, *a2);
    sub_100720C08(a1, a2[1]);
    sub_100720C64((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100720C64(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  sub_100047F64(&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t sub_100720CAC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(void ***)(a1 + 72);
    if (v2)
    {
      uint64_t v3 = *(void ***)(a1 + 80);
      uint64_t v4 = *(void **)(a1 + 72);
      if (v3 != v2)
      {
        long long v5 = *(void ***)(a1 + 80);
        do
        {
          long long v7 = (void **)*(v5 - 3);
          v5 -= 3;
          long long v6 = v7;
          if (v7)
          {
            int v8 = (void **)*(v3 - 2);
            uint64_t v9 = v6;
            if (v8 != v6)
            {
              do
              {
                if (*((unsigned char *)v8 - 16) && *((unsigned char *)v8 - 24) && *((char *)v8 - 25) < 0) {
                  operator delete(*(v8 - 6));
                }
                if (*((unsigned char *)v8 - 64) && *((char *)v8 - 65) < 0) {
                  operator delete(*(v8 - 11));
                }
                v8 -= 11;
              }
              while (v8 != v6);
              uint64_t v9 = *v5;
            }
            *(v3 - 2) = v6;
            operator delete(v9);
          }
          uint64_t v3 = v5;
        }
        while (v5 != v2);
        uint64_t v4 = *(void **)(a1 + 72);
      }
      *(void *)(a1 + 80) = v2;
      operator delete(v4);
    }
    if (*(unsigned char *)(a1 + 64))
    {
      if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
        operator delete(*(void **)(a1 + 32));
      }
      if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
    }
  }
  return a1;
}

uint64_t *sub_100720DBC(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v16 = 0;
  long long v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v16, a2);
  long long v6 = *v5;
  if (!*v5)
  {
    long long v7 = v5;
    int v8 = *a3;
    uint64_t v15 = 0;
    uint64_t v9 = operator new(0x50uLL);
    v14[0] = v9;
    v14[1] = a1 + 1;
    std::string::size_type v10 = v9 + 4;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v10, *(void **)v8, *((void *)v8 + 1));
      long long v12 = (uint64_t *)v14[0];
    }
    else
    {
      long long v11 = *v8;
      void v9[6] = *((void *)v8 + 2);
      *(_OWORD *)std::string::size_type v10 = v11;
      long long v12 = v9;
    }
    void v9[7] = 0;
    unsigned char v9[8] = 0;
    v9[9] = 0;
    LOBYTE(v15) = 1;
    sub_100046C38(a1, v16, v7, v12);
    long long v6 = (uint64_t *)v14[0];
    v14[0] = 0;
    sub_100720EB4((uint64_t)v14, 0);
  }
  return v6;
}

void sub_100720E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100720EB4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100720C64((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_100720F0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  if (a3 && (*(unsigned int (**)(uint64_t))(*(void *)a3 + 48))(a3))
  {
    uint64_t v13 = *(void *)(a4 + 24);
    if (!v13) {
      sub_10007B600();
    }
    uint64_t v14 = *(uint64_t (**)(void))(*(void *)v13 + 48);
    return v14();
  }
  else
  {
    uint64_t result = *(void *)(a5 + 24);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
    }
    if (*a6)
    {
      uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a7 + 23) < 0) {
          a7 = (uint64_t *)*a7;
        }
        int v17 = 136315138;
        long long v18 = a7;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Canceling scheduled Term-SMS send [ %s ]", (uint8_t *)&v17, 0xCu);
      }
      uint64_t result = *a6;
      *a6 = 0;
      if (result)
      {
        (*(void (**)(uint64_t))(*(void *)result + 8))(result);
        uint64_t result = *a6;
        *a6 = 0;
        if (result) {
          return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
      }
    }
  }
  return result;
}

uint64_t sub_100721134(uint64_t a1, int a2, uint64_t a3)
{
  v47[0] = 0;
  v47[1] = 0;
  uint64_t v48 = 0;
  uint64_t v32 = 0;
  long long v30 = 0u;
  *(_OWORD *)long long v31 = 0u;
  *(_OWORD *)long long v28 = 0u;
  *(_OWORD *)long long v29 = 0u;
  *(_OWORD *)long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)long long v22 = 0u;
  *(_OWORD *)long long v23 = 0u;
  memset(&v53, 0, sizeof(v53));
  long long v51 = 0u;
  memset(v52, 0, sizeof(v52));
  long long __str = 0u;
  memset(__str_16, 0, sizeof(__str_16));
  uint64_t v6 = *(void *)(a1 + 312);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = a1 + 312;
  do
  {
    int v8 = *(_DWORD *)(v6 + 32);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      std::string::size_type v10 = (uint64_t *)v6;
    }
    else {
      std::string::size_type v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 != a1 + 312 && *(_DWORD *)(v7 + 32) <= a2)
  {
    long long __str = *(_OWORD *)(v7 + 40);
    if (&__str != (long long *)(v7 + 40))
    {
      sub_10008A534((char *)__str_16, *(char **)(v7 + 56), *(void *)(v7 + 64), (uint64_t)(*(void *)(v7 + 64) - *(void *)(v7 + 56)) >> 2);
      sub_10008A640((uint64_t *)&__str_16[1] + 1, *(void *)(v7 + 80), *(void *)(v7 + 88), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v7 + 88) - *(void *)(v7 + 80)) >> 3));
    }
    LODWORD(__str_16[3]) = *(_DWORD *)(v7 + 104);
    WORD2(__str_16[3]) = *(_WORD *)(v7 + 108);
    std::string::operator=((std::string *)((char *)&__str_16[3] + 8), (const std::string *)(v7 + 112));
    std::string::operator=((std::string *)&v51, (const std::string *)(v7 + 136));
    std::string::operator=((std::string *)((char *)v52 + 8), (const std::string *)(v7 + 160));
    long long v11 = (const std::string *)(v7 + 184);
  }
  else
  {
LABEL_11:
    long long __str = 0uLL;
    sub_10008A534((char *)__str_16, 0, 0, 0);
    sub_10008A640((uint64_t *)&__str_16[1] + 1, *((uint64_t *)&v24 + 1), v25, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - *((void *)&v24 + 1)) >> 3));
    LODWORD(__str_16[3]) = v26[0];
    WORD2(__str_16[3]) = WORD2(v26[0]);
    std::string::operator=((std::string *)((char *)&__str_16[3] + 8), (const std::string *)&v26[1]);
    std::string::operator=((std::string *)&v51, (const std::string *)v28);
    std::string::operator=((std::string *)((char *)v52 + 8), (const std::string *)&v29[1]);
    long long v11 = (const std::string *)v31;
  }
  std::string::operator=(&v53, v11);
  *(_OWORD *)uint64_t v33 = __str;
  *(_OWORD *)std::string v34 = __str_16[0];
  memset(__str_16, 0, 48);
  long long v36 = *(_OWORD *)((char *)&__str_16[1] + 8);
  uint64_t v35 = *(void *)&__str_16[1];
  uint64_t v37 = *((void *)&__str_16[2] + 1);
  __int16 v39 = WORD2(__str_16[3]);
  int v38 = __str_16[3];
  uint64_t v41 = *((void *)&__str_16[4] + 1);
  long long v40 = *(_OWORD *)((char *)&__str_16[3] + 8);
  memset((char *)&__str_16[3] + 8, 0, 24);
  *(_OWORD *)uint64_t v42 = v51;
  long long v51 = 0uLL;
  uint64_t v43 = *(void *)&v52[0];
  uint64_t v45 = *((void *)&v52[1] + 1);
  long long v44 = *(_OWORD *)((char *)v52 + 8);
  memset(v52, 0, sizeof(v52));
  std::string __p = v53;
  memset(&v53, 0, sizeof(v53));
  uint64_t v54 = (void **)&__str_16[1] + 1;
  sub_10002E39C(&v54);
  if (*(void *)&__str_16[0])
  {
    *((void *)&__str_16[0] + 1) = *(void *)&__str_16[0];
    operator delete(*(void **)&__str_16[0]);
  }
  *(_OWORD *)uint64_t v47 = v40;
  uint64_t v48 = v41;
  uint64_t v41 = 0;
  long long v40 = 0uLL;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)v44);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  *(void *)&long long __str = &v36;
  sub_10002E39C((void ***)&__str);
  if (v34[0])
  {
    v34[1] = v34[0];
    operator delete(v34[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[1]);
  }
  if (SHIBYTE(v29[0]) < 0) {
    operator delete(v28[0]);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[1]);
  }
  *(void *)&long long __str = (char *)&v24 + 8;
  sub_10002E39C((void ***)&__str);
  if (v23[0])
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
  v33[0] = 0;
  v33[1] = 0;
  v34[0] = 0;
  uint64_t v12 = a1 + 224;
  long long __str = 0uLL;
  *(void *)&__str_16[0] = 0;
  sub_100721718((std::string *)v33, v12, a2, (std::string *)&__str);
  if (SBYTE7(__str_16[0]) < 0) {
    operator delete((void *)__str);
  }
  v22[0] = 0;
  v22[1] = 0;
  v23[0] = 0;
  if (a2 > 3) {
    int v13 = 0;
  }
  else {
    int v13 = dword_1014E74D0[a2];
  }
  long long __str = 0uLL;
  *(void *)&__str_16[0] = 0;
  sub_100721718((std::string *)v22, v12, v13, (std::string *)&__str);
  if (SBYTE7(__str_16[0]) < 0) {
    operator delete((void *)__str);
  }
  uint64_t v14 = (void *)HIBYTE(v48);
  int v15 = SHIBYTE(v48);
  if (v48 < 0) {
    uint64_t v14 = v47[1];
  }
  if (!v14) {
    goto LABEL_53;
  }
  uint64_t v16 = (void *)HIBYTE(v34[0]);
  if (SHIBYTE(v34[0]) < 0) {
    uint64_t v16 = v33[1];
  }
  if (v16)
  {
    sub_1007252F8((char *)&__str, (long long *)v47, (long long *)v33, (long long *)v22);
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = __str;
    *(void *)(a3 + 16) = *(void *)&__str_16[0];
    BYTE7(__str_16[0]) = 0;
    LOBYTE(__str) = 0;
    int v17 = (void **)(a3 + 24);
    if (*(char *)(a3 + 47) < 0) {
      operator delete(*v17);
    }
    *(_OWORD *)int v17 = *(_OWORD *)((char *)__str_16 + 8);
    *(void *)(a3 + 4sub_100720EB4((uint64_t)&a9, 0) = *((void *)&__str_16[1] + 1);
    HIBYTE(__str_16[1]) = 0;
    BYTE8(__str_16[0]) = 0;
    long long v18 = (void **)(a3 + 48);
    if (*(char *)(a3 + 71) < 0)
    {
      operator delete(*v18);
      int v20 = SHIBYTE(__str_16[1]);
      *(_OWORD *)long long v18 = __str_16[2];
      *(void *)(a3 + 64) = *(void *)&__str_16[3];
      BYTE7(__str_16[3]) = 0;
      LOBYTE(__str_16[2]) = 0;
      if (v20 < 0) {
        operator delete(*((void **)&__str_16[0] + 1));
      }
    }
    else
    {
      *(_OWORD *)long long v18 = __str_16[2];
      *(void *)(a3 + 64) = *(void *)&__str_16[3];
      BYTE7(__str_16[3]) = 0;
      LOBYTE(__str_16[2]) = 0;
    }
    if (SBYTE7(__str_16[0]) < 0) {
      operator delete((void *)__str);
    }
    uint64_t v19 = 1;
  }
  else
  {
LABEL_53:
    uint64_t v19 = 0;
  }
  if (SHIBYTE(v23[0]) < 0) {
    operator delete(v22[0]);
  }
  if (SHIBYTE(v34[0]) < 0)
  {
    operator delete(v33[0]);
    if ((v15 & 0x80000000) == 0) {
      return v19;
    }
LABEL_68:
    operator delete(v47[0]);
    return v19;
  }
  if (v15 < 0) {
    goto LABEL_68;
  }
  return v19;
}

void sub_100721698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v61 < 0) {
    operator delete(a34);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  _Unwind_Resume(a1);
}

double sub_100721718(std::string *a1, uint64_t a2, int a3, std::string *__str)
{
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v5 = a2 + 8;
  uint64_t v6 = v7;
  memset(&v15, 0, sizeof(v15));
  if (v7)
  {
    uint64_t v8 = v5;
    do
    {
      int v9 = *(_DWORD *)(v6 + 32);
      BOOL v10 = v9 < a3;
      if (v9 >= a3) {
        long long v11 = (uint64_t *)v6;
      }
      else {
        long long v11 = (uint64_t *)(v6 + 8);
      }
      if (!v10) {
        uint64_t v8 = v6;
      }
      uint64_t v6 = *v11;
    }
    while (*v11);
    if (v8 != v5)
    {
      int v12 = *(_DWORD *)(v8 + 32);
      int v13 = (std::string *)(v8 + 40);
      if (v12 <= a3) {
        long long __str = v13;
      }
    }
  }
  std::string::operator=(&v15, __str);
  double result = *(double *)&v15.__r_.__value_.__l.__data_;
  *a1 = v15;
  return result;
}

void sub_1007217A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TerminalRegistrationController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100721EC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t a14, uint64_t a15, dispatch_object_t object, dispatch_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

const char *sub_10072222C(int a1)
{
  uint64_t v1 = "msg.term.ctr.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.term.ctr.2";
  }
  if (a1 == 1) {
    return "msg.term.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_100722258(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/prefs-nb/meid");
  v4[0] = off_1019FF880;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10072230C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100722338(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 280);
  char v3 = (void *)(a1 + 288);
  if (v2 != (void *)(a1 + 288))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          long long v11 = (uint64_t *)v6;
        }
        else {
          long long v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((rest::operator==() & 1) == 0)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        uint64_t v12 = a1;
        uint64_t v13 = (uint64_t)(v2 + 5);
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          std::string v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          std::string v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_16:
    uint64_t v13 = (uint64_t)(v2 + 5);
    uint64_t v12 = a1;
LABEL_17:
    sub_10072773C(v12, v7, v13);
    goto LABEL_18;
  }
}

uint64_t sub_100722428(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 304);
  char v3 = (void *)(result + 312);
  if (v2 != (void *)(result + 312))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          long long v11 = (uint64_t *)v6;
        }
        else {
          long long v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      double result = BasicSimInfo::operator==();
      if ((result & 1) == 0)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        uint64_t v12 = v4;
        uint64_t v13 = (uint64_t)(v2 + 5);
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          std::string v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          std::string v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return result;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_16:
    uint64_t v13 = (uint64_t)(v2 + 5);
    uint64_t v12 = v4;
LABEL_17:
    double result = (uint64_t)sub_100727D40(v12, v7, v13);
    goto LABEL_18;
  }
  return result;
}

uint64_t sub_100722518(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 328);
  char v3 = (void *)(result + 336);
  if (v2 != (void *)(result + 336))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    long long v24 = (uint64_t **)(result + 72);
    uint64_t v6 = (uint64_t **)(result + 160);
    while (1)
    {
      uint64_t v7 = *v5;
      int v8 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      uint64_t v13 = v2 + 4;
      if (*((_DWORD *)v9 + 8) != *((_DWORD *)v2 + 8)) {
        goto LABEL_14;
      }
LABEL_29:
      long long v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          long long v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v23);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return result;
      }
    }
    uint64_t v13 = v2 + 4;
LABEL_14:
    unsigned int v27 = *((_DWORD *)v2 + 7);
    double result = subscriber::isValidSimSlot();
    if (result)
    {
      uint64_t v14 = *v3;
      if (*v3)
      {
        std::string v15 = v3;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v8;
          if (v16 >= v8) {
            long long v18 = (uint64_t *)v14;
          }
          else {
            long long v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            std::string v15 = (void *)v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 != v3 && *((_DWORD *)v15 + 7) <= v8)
        {
          *((_DWORD *)sub_100256E84(v24, v27, &v27)[5] + 43) = *v13;
          uint64_t v19 = v27;
          v30[0] = off_101A00010;
          v30[1] = v13;
          long long v31 = v30;
          v29[0] = off_101A00090;
          v29[1] = v4;
          v29[2] = &v27;
          v29[3] = v29;
          v28[3] = 0;
          int v20 = sub_1002C74D0(v6, v27, &v27);
          sub_100058DB0(__p, "Current RAT doesn't allow Term-SMS");
          sub_100720F0C(v4, v19, (uint64_t)v31, (uint64_t)v29, (uint64_t)v28, (uint64_t *)v20 + 5, (uint64_t *)__p);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          sub_10003B34C(v28);
          sub_10003B34C(v29);
          double result = (uint64_t)sub_100727CBC(v30);
        }
      }
    }
    goto LABEL_29;
  }
  return result;
}

void sub_100722774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_1007227B8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 352);
  char v3 = (void *)(result + 360);
  if (v2 != (void *)(result + 360))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    long long v24 = (uint64_t **)(result + 72);
    uint64_t v6 = (uint64_t **)(result + 160);
    while (1)
    {
      uint64_t v7 = *v5;
      int v8 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      uint64_t v13 = v2 + 4;
      if (*((unsigned __int8 *)v9 + 32) != *((unsigned __int8 *)v2 + 32)) {
        goto LABEL_14;
      }
LABEL_29:
      long long v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          long long v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v23);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return result;
      }
    }
    uint64_t v13 = v2 + 4;
LABEL_14:
    unsigned int v27 = *((_DWORD *)v2 + 7);
    double result = subscriber::isValidSimSlot();
    if (result)
    {
      uint64_t v14 = *v3;
      if (*v3)
      {
        std::string v15 = v3;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v8;
          if (v16 >= v8) {
            long long v18 = (uint64_t *)v14;
          }
          else {
            long long v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            std::string v15 = (void *)v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 != v3 && *((_DWORD *)v15 + 7) <= v8)
        {
          *((unsigned char *)sub_100256E84(v24, v27, &v27)[5] + 167) = *v13;
          uint64_t v19 = v27;
          v30[0] = off_101A00110;
          v30[1] = v13;
          long long v31 = v30;
          v29[0] = off_101A00190;
          v29[1] = v4;
          v29[2] = &v27;
          v29[3] = v29;
          v28[3] = 0;
          int v20 = sub_1002C74D0(v6, v27, &v27);
          sub_100058DB0(__p, "Not CS attached");
          sub_100720F0C(v4, v19, (uint64_t)v31, (uint64_t)v29, (uint64_t)v28, (uint64_t *)v20 + 5, (uint64_t *)__p);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          sub_10003B34C(v28);
          sub_10003B34C(v29);
          double result = (uint64_t)sub_100727CBC(v30);
        }
      }
    }
    goto LABEL_29;
  }
  return result;
}

void sub_100722A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_100722A58(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 376);
  char v3 = (void *)(result + 384);
  if (v2 != (void *)(result + 384))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    long long v24 = (uint64_t **)(result + 72);
    uint64_t v6 = (uint64_t **)(result + 160);
    while (1)
    {
      uint64_t v7 = *v5;
      int v8 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      uint64_t v13 = v2 + 4;
      if (*((unsigned __int8 *)v9 + 32) != *((unsigned __int8 *)v2 + 32)) {
        goto LABEL_14;
      }
LABEL_29:
      long long v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          long long v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v23);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return result;
      }
    }
    uint64_t v13 = v2 + 4;
LABEL_14:
    unsigned int v27 = *((_DWORD *)v2 + 7);
    double result = subscriber::isValidSimSlot();
    if (result)
    {
      uint64_t v14 = *v3;
      if (*v3)
      {
        std::string v15 = v3;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v8;
          if (v16 >= v8) {
            long long v18 = (uint64_t *)v14;
          }
          else {
            long long v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            std::string v15 = (void *)v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 != v3 && *((_DWORD *)v15 + 7) <= v8)
        {
          *((unsigned char *)sub_100256E84(v24, v27, &v27)[5] + 166) = *v13;
          uint64_t v19 = v27;
          v30[0] = off_101A00210;
          v30[1] = v13;
          long long v31 = v30;
          v29[0] = off_101A00290;
          v29[1] = v4;
          v29[2] = &v27;
          v29[3] = v29;
          v28[3] = 0;
          int v20 = sub_1002C74D0(v6, v27, &v27);
          sub_100058DB0(__p, "SMSC not available");
          sub_100720F0C(v4, v19, (uint64_t)v31, (uint64_t)v29, (uint64_t)v28, (uint64_t *)v20 + 5, (uint64_t *)__p);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          sub_10003B34C(v28);
          sub_10003B34C(v29);
          double result = (uint64_t)sub_100727CBC(v30);
        }
      }
    }
    goto LABEL_29;
  }
  return result;
}

void sub_100722CB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_100722CF8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 400);
  char v3 = (void *)(result + 408);
  if (v2 != (void *)(result + 408))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    long long v24 = (uint64_t **)(result + 72);
    uint64_t v6 = (uint64_t **)(result + 160);
    while (1)
    {
      uint64_t v7 = *v5;
      int v8 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      uint64_t v13 = v2 + 4;
      if (*((unsigned __int8 *)v9 + 32) != *((unsigned __int8 *)v2 + 32)) {
        goto LABEL_14;
      }
LABEL_29:
      long long v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          long long v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v23);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return result;
      }
    }
    uint64_t v13 = v2 + 4;
LABEL_14:
    unsigned int v27 = *((_DWORD *)v2 + 7);
    double result = subscriber::isValidSimSlot();
    if (result)
    {
      uint64_t v14 = *v3;
      if (*v3)
      {
        std::string v15 = v3;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v8;
          if (v16 >= v8) {
            long long v18 = (uint64_t *)v14;
          }
          else {
            long long v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            std::string v15 = (void *)v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 != v3 && *((_DWORD *)v15 + 7) <= v8)
        {
          *((unsigned char *)sub_100256E84(v24, v27, &v27)[5] + 165) = *v13;
          uint64_t v19 = v27;
          v30[0] = off_101A00310;
          v30[1] = v13;
          long long v31 = v30;
          v29[0] = off_101A00390;
          v29[1] = v4;
          v29[2] = &v27;
          v29[3] = v29;
          v28[3] = 0;
          int v20 = sub_1002C74D0(v6, v27, &v27);
          sub_100058DB0(__p, "SMS not online");
          sub_100720F0C(v4, v19, (uint64_t)v31, (uint64_t)v29, (uint64_t)v28, (uint64_t *)v20 + 5, (uint64_t *)__p);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          sub_10003B34C(v28);
          sub_10003B34C(v29);
          double result = (uint64_t)sub_100727CBC(v30);
        }
      }
    }
    goto LABEL_29;
  }
  return result;
}

void sub_100722F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC(&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_100722F98(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 424);
  char v3 = (void *)(result + 432);
  if (v2 != (void *)(result + 432))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    long long v24 = (uint64_t **)(result + 72);
    uint64_t v6 = (uint64_t **)(result + 160);
    while (1)
    {
      uint64_t v7 = *v5;
      int v8 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 7)) {
        break;
      }
      uint64_t v13 = v2 + 4;
      if (*((_DWORD *)v9 + 8) != *((_DWORD *)v2 + 8)) {
        goto LABEL_14;
      }
LABEL_29:
      long long v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          long long v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v23);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return result;
      }
    }
    uint64_t v13 = v2 + 4;
LABEL_14:
    unsigned int v27 = *((_DWORD *)v2 + 7);
    double result = subscriber::isValidSimSlot();
    if (result)
    {
      uint64_t v14 = *v3;
      if (*v3)
      {
        std::string v15 = v3;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v8;
          if (v16 >= v8) {
            long long v18 = (uint64_t *)v14;
          }
          else {
            long long v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            std::string v15 = (void *)v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 != v3 && *((_DWORD *)v15 + 7) <= v8)
        {
          *((unsigned char *)sub_100256E84(v24, v27, &v27)[5] + 168) = *v13 == 5;
          uint64_t v19 = v27;
          v30[0] = off_101A00410;
          v30[1] = v13;
          long long v31 = v30;
          v29[0] = off_101A00490;
          v29[1] = v4;
          v29[2] = &v27;
          v29[3] = v29;
          v28[3] = 0;
          int v20 = sub_1002C74D0(v6, v27, &v27);
          sub_100058DB0(__p, "Device is not in home country");
          sub_100720F0C(v4, v19, (uint64_t)v31, (uint64_t)v29, (uint64_t)v28, (uint64_t *)v20 + 5, (uint64_t *)__p);
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          sub_10003B34C(v28);
          sub_10003B34C(v29);
          double result = (uint64_t)sub_100727CBC(v30);
        }
      }
    }
    goto LABEL_29;
  }
  return result;
}

void sub_1007231FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC(&a25);
  _Unwind_Resume(a1);
}

void sub_100723240(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 448);
  char v3 = (void *)(a1 + 456);
  if (v2 != (void *)(a1 + 456))
  {
    uint64_t v6 = (void **)(a2 + 8);
    do
    {
      uint64_t v7 = (long long *)(v2 + 4);
      int v8 = sub_100046F68(a2, (void **)v2 + 4);
      if (v6 == v8)
      {
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(&__dst, (void *)v2[4], v2[5]);
        }
        else
        {
          long long __dst = *v7;
          uint64_t v16 = v2[6];
        }
        sub_100728D4C(a1, (uint64_t)&__dst, (uint64_t)(v2 + 7));
        if ((SHIBYTE(v16) & 0x80000000) == 0) {
          goto LABEL_16;
        }
        p_dst = (void **)&__dst;
      }
      else
      {
        if (sub_10047161C((uint64_t)(v8 + 7), (uint64_t)(v2 + 7))) {
          goto LABEL_16;
        }
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(&v13, (void *)v2[4], v2[5]);
        }
        else
        {
          long long v13 = *v7;
          uint64_t v14 = v2[6];
        }
        sub_100728D4C(a1, (uint64_t)&v13, (uint64_t)(v2 + 7));
        if ((SHIBYTE(v14) & 0x80000000) == 0) {
          goto LABEL_16;
        }
        p_dst = (void **)&v13;
      }
      operator delete(*p_dst);
LABEL_16:
      int v10 = (void *)v2[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v2[2];
          BOOL v12 = *v11 == (void)v2;
          uint64_t v2 = v11;
        }
        while (!v12);
      }
      uint64_t v2 = v11;
    }
    while (v11 != v3);
  }
}

void sub_100723390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007233C4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 72);
  uint64_t v2 = (void *)(a1 + 80);
  if (v1 != (void *)(a1 + 80))
  {
    do
    {
      uint64_t v3 = v1[5];
      if (v3) {
        sub_100BD30E4(v3);
      }
      uint64_t v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
    }
    while (v5 != v2);
  }
}

void sub_100723434(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100723534(void **a1, uint64_t a2)
{
  int v43 = a2;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  if (!subscriber::isValidSimSlot()) {
    return 0;
  }
  if (sub_1002C74D0(a1 + 23, a2, &v43)[5])
  {
    uint64_t v5 = *v4;
    uint64_t v6 = 0;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v7 = "#I Term-SMS already issued";
LABEL_56:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
      return 0;
    }
  }
  else
  {
    int v8 = a1 + 9;
    int v9 = sub_100256E84(a1 + 9, a2, &v43);
    if (sub_100BD4634((uint64_t)v9[5]))
    {
      if (*((_DWORD *)sub_100256E84(a1 + 9, a2, &v43)[5] + 40) >= 3u)
      {
        uint64_t v5 = *v4;
        uint64_t v6 = 0;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v7 = "#I Max retries done";
          goto LABEL_56;
        }
      }
      else
      {
        long long v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        std::string __p = 0;
        uint64_t v38 = 0;
        uint64_t v39 = 0;
        (*(void (**)(void *, uint64_t, uint64_t, void **))(*a1[16] + 200))(a1[16], a2, 3, &v40);
        (*(void (**)(void *, uint64_t, uint64_t, void **))(*a1[16] + 200))(a1[16], a2, 12, &__p);
        uint64_t v10 = HIBYTE(v42);
        if (v42 < 0) {
          uint64_t v10 = v41;
        }
        uint64_t v36 = v10;
        if (v39 >= 0) {
          uint64_t v11 = HIBYTE(v39);
        }
        else {
          uint64_t v11 = v38;
        }
        sub_100256E84(a1 + 9, a2, &v43);
        unsigned int v12 = asWirelessTechnology();
        BOOL v13 = (v12 & 0xE4) != 0 && (v12 & 8) == 0;
        int v14 = *((unsigned __int8 *)sub_100256E84(v8, a2, &v43)[5] + 168);
        int v15 = *((unsigned __int8 *)sub_100256E84(v8, a2, &v43)[5] + 165);
        int v16 = *((unsigned __int8 *)sub_100256E84(v8, a2, &v43)[5] + 166);
        BOOL v17 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          long long v18 = "false";
          if ((v12 & 8) != 0) {
            uint64_t v19 = "true";
          }
          else {
            uint64_t v19 = "false";
          }
          if (v13) {
            int v20 = "true";
          }
          else {
            int v20 = "false";
          }
          *(_DWORD *)long long buf = 136316418;
          uint64_t v45 = v19;
          if (v36) {
            long long v21 = "true";
          }
          else {
            long long v21 = "false";
          }
          __int16 v46 = 2080;
          uint64_t v47 = v20;
          if (v11) {
            long long v22 = "true";
          }
          else {
            long long v22 = "false";
          }
          __int16 v48 = 2080;
          uint64_t v49 = v21;
          if (v16) {
            BOOL v23 = "true";
          }
          else {
            BOOL v23 = "false";
          }
          __int16 v50 = 2080;
          long long v51 = v22;
          if (v15) {
            long long v18 = "true";
          }
          __int16 v52 = 2080;
          std::string v53 = v23;
          __int16 v54 = 2080;
          long long v55 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Term Status 3GPP2 RAT: %s, 3GPP RAT: %s, GW-IMSI: %s, 1X-IMSI: %s, SMSC: %s, SMS Online: %s", buf, 0x3Eu);
        }
        if (v14) {
          BOOL v24 = v13;
        }
        else {
          BOOL v24 = 0;
        }
        int v25 = (v14 != 0) & (v12 >> 3);
        if (!v11) {
          int v25 = 0;
        }
        if (v15) {
          int v26 = v25;
        }
        else {
          int v26 = 0;
        }
        if (v36) {
          BOOL v27 = v24;
        }
        else {
          BOOL v27 = 0;
        }
        if (v16) {
          BOOL v28 = v15 != 0;
        }
        else {
          BOOL v28 = 0;
        }
        if (v14)
        {
          if (*((unsigned char *)sub_100256E84(v8, a2, &v43)[5] + 164)) {
            BOOL v29 = v28;
          }
          else {
            BOOL v29 = 0;
          }
        }
        else
        {
          BOOL v29 = 0;
        }
        int v31 = v27 && v28;
        uint64_t v32 = *v4;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = "false";
          if (v26) {
            std::string v34 = "true";
          }
          else {
            std::string v34 = "false";
          }
          if (v31) {
            uint64_t v35 = "true";
          }
          else {
            uint64_t v35 = "false";
          }
          *(_DWORD *)long long buf = 136315650;
          uint64_t v45 = v34;
          __int16 v46 = 2080;
          uint64_t v47 = v35;
          if (v29) {
            uint64_t v33 = "true";
          }
          __int16 v48 = 2080;
          uint64_t v49 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Can Issue Term-SMS [3GPP2: %s 3GPP: %s IMS: %s]", buf, 0x20u);
        }
        *((unsigned char *)sub_100256E84(v8, a2, &v43)[5] + 169) = v29;
        if (SHIBYTE(v39) < 0) {
          operator delete(__p);
        }
        uint64_t v6 = v26 | v31 | v29;
        if (SHIBYTE(v42) < 0) {
          operator delete(v40);
        }
      }
    }
    else
    {
      uint64_t v5 = *v4;
      uint64_t v6 = 0;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v7 = "#I No Terminal Registration SMS support";
        goto LABEL_56;
      }
    }
  }
  return v6;
}

void sub_1007239F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100723A3C(uint64_t a1, uint64_t a2)
{
  int v35 = a2;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (subscriber::isValidSimSlot())
  {
    uint64_t v34 = 0;
    long long v32 = 0u;
    *(_OWORD *)uint64_t v33 = 0u;
    *(_OWORD *)long long v30 = 0u;
    *(_OWORD *)int v31 = 0u;
    int v5 = sub_100721134(a1, a2, (uint64_t)v30);
    int v6 = sub_100723534((void **)a1, a2);
    uint64_t v7 = sub_100256E84((uint64_t **)(a1 + 72), a2, &v35);
    int v8 = sub_100BD3418((uint64_t)v7[5], (const void **)v30);
    int v9 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v5;
      LOWORD(v37) = 1024;
      *(_DWORD *)((char *)&v37 + 2) = v6;
      HIWORD(v37) = 1024;
      int v38 = v8 ^ 1;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Term Id Valid:%d, can Issue:%d, Identifier changed:%d", buf, 0x14u);
    }
    if (((v5 & v6 ^ 1 | v8) & 1) == 0)
    {
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v10 || (v11 = *(void *)(a1 + 8), (unsigned int v12 = std::__shared_weak_count::lock(v10)) == 0)) {
        sub_100088B9C();
      }
      BOOL v13 = v12;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 56));
      uint64_t v14 = *(void *)buf;
      sub_100058DB0(__p, "Term-reg SMS dispatch timer");
      int v15 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v15;
      if (v15) {
        dispatch_retain(v15);
      }
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 1174405120;
      CFTypeRef v22[2] = sub_100723ED8;
      void v22[3] = &unk_1019FF5A8;
      uint8_t v22[4] = a1;
      v22[5] = v11;
      BOOL v23 = v13;
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      int v24 = a2;
      aBlock = _Block_copy(v22);
      sub_100118A44(v14, (uint64_t)__p, 0, 120000000, &object, &aBlock);
      int v16 = (uint64_t **)(a1 + 160);
      BOOL v17 = sub_1002C74D0(v16, a2, &v35);
      long long v18 = v29;
      BOOL v29 = 0;
      uint64_t v19 = v17[5];
      v17[5] = v18;
      if (v19)
      {
        (*(void (**)(uint64_t *))(*v19 + 8))(v19);
        int v20 = v29;
        BOOL v29 = 0;
        if (v20) {
          (*(void (**)(uint64_t *))(*v20 + 8))(v20);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v28 < 0) {
        operator delete(__p[0]);
      }
      if (v37) {
        sub_10004D2C8(v37);
      }
      if (sub_1002C74D0(v16, a2, &v35)[5])
      {
        long long v21 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Term SMS scheduled", buf, 2u);
        }
      }
      if (v23) {
        std::__shared_weak_count::__release_weak(v23);
      }
      std::__shared_weak_count::__release_weak(v13);
    }
    if (SHIBYTE(v34) < 0) {
      operator delete(v33[0]);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(v31[1]);
    }
    if (SHIBYTE(v31[0]) < 0) {
      operator delete(v30[0]);
    }
  }
}

void sub_100723DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100723ED8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      sub_10004D2C8(v4);
      if (v5)
      {
        unsigned int v7 = *(_DWORD *)(a1 + 56);
        int v6 = (int *)(a1 + 56);
        int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Term-SMS dispatch timer expired.", (uint8_t *)&buf, 2u);
        }
        int v9 = sub_100723534((void **)v3, *v6);
        uint64_t v10 = *v6;
        if (v9)
        {
          int v43 = *v6;
          uint64_t v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v10);
          uint64_t v12 = *(void *)(v3 + 336);
          if (v12)
          {
            do
            {
              if (*(_DWORD *)(v12 + 28) >= (int)v10) {
                BOOL v13 = (uint64_t *)v12;
              }
              else {
                BOOL v13 = (uint64_t *)(v12 + 8);
              }
              uint64_t v12 = *v13;
            }
            while (*v13);
          }
          long long v41 = 0uLL;
          uint64_t v42 = 0;
          if ((asWirelessTechnology() & 8) != 0) {
            uint64_t v14 = 12;
          }
          else {
            uint64_t v14 = 3;
          }
          (*(void (**)(void, uint64_t, uint64_t, long long *))(**(void **)(v3 + 128) + 200))(*(void *)(v3 + 128), v10, v14, &v41);
          memset(&__p, 0, sizeof(__p));
          v38[0] = 0;
          v38[1] = 0;
          uint64_t v39 = 0;
          if (*((unsigned char *)sub_100256E84((uint64_t **)(v3 + 72), v10, &v43)[5] + 169))
          {
            memset(&v48, 0, sizeof(v48));
            sub_100721718((std::string *)&buf, v3 + 224, v10, &v48);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = buf;
            __p.__r_.__value_.__r.__words[2] = v57;
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v48.__r_.__value_.__l.__data_);
            }
            if (v10 > 3) {
              int v15 = 0;
            }
            else {
              int v15 = dword_1014E74D0[(int)v10];
            }
            memset(&v48, 0, sizeof(v48));
            sub_100721718((std::string *)&buf, v3 + 224, v15, &v48);
            *(_OWORD *)int v38 = buf;
            uint64_t v39 = v57;
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v48.__r_.__value_.__l.__data_);
            }
            long long v18 = *v11;
            if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Using IMEI as the identifier", (uint8_t *)&buf, 2u);
            }
          }
          else
          {
            long long buf = 0u;
            long long v57 = 0u;
            sub_1000593FC((uint64_t)&buf, (long long *)(v3 + 248));
            if (BYTE8(v57))
            {
              std::string::operator=(&__p, (const std::string *)&buf);
              BOOL v17 = *v11;
              if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v48.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Using MEID as the identifier", (uint8_t *)&v48, 2u);
              }
              if (BYTE8(v57) && SBYTE7(v57) < 0) {
                operator delete((void *)buf);
              }
            }
          }
          uint64_t v19 = HIBYTE(v42);
          if (v42 < 0) {
            uint64_t v19 = *((void *)&v41 + 1);
          }
          if (!v19) {
            goto LABEL_50;
          }
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
          }
          if (size)
          {
            sub_1007252F8((char *)&v33, &v41, (long long *)&__p, (long long *)v38);
            int v55 = v10;
            long long v21 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v10);
            long long v53 = 0uLL;
            uint64_t v54 = 0;
            long long v22 = sub_100256E84((uint64_t **)(v3 + 72), v10, &v55)[5];
            std::string v48 = v33;
            memset(&v33, 0, sizeof(v33));
            long long v49 = *(_OWORD *)v34;
            uint64_t v50 = v35;
            v34[0] = 0;
            v34[1] = 0;
            uint64_t v35 = 0;
            uint64_t v52 = v37;
            long long v51 = *(_OWORD *)v36;
            v36[0] = 0;
            v36[1] = 0;
            uint64_t v37 = 0;
            char v23 = sub_100BD36C8((uint64_t)v22);
            if (SHIBYTE(v52) < 0) {
              operator delete((void *)v51);
            }
            if (SHIBYTE(v50) < 0) {
              operator delete((void *)v49);
            }
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v48.__r_.__value_.__l.__data_);
            }
            if (v23)
            {
              uint64_t v46 = 0;
              uint64_t v47 = 0;
              int v24 = sub_100256E84((uint64_t **)(v3 + 72), v10, &v55)[5];
              if (*((char *)v24 + 151) < 0)
              {
                sub_10004FC84(&__dst, (void *)v24[16], v24[17]);
              }
              else
              {
                long long __dst = *((_OWORD *)v24 + 8);
                uint64_t v45 = v24[18];
              }
              if (v45 >= 0) {
                p_dst = (char *)&__dst;
              }
              else {
                p_dst = (char *)__dst;
              }
              sub_100058DB0(&buf, p_dst);
              DWORD2(v57) = v10;
              if (SHIBYTE(v54) < 0)
              {
                sub_10004FC84(&v58, (void *)v53, *((unint64_t *)&v53 + 1));
              }
              else
              {
                long long v58 = v53;
                uint64_t v59 = v54;
              }
              int v60 = 5;
              char v64 = 0;
              char v65 = 0;
              long long v61 = 0u;
              long long v62 = 0u;
              char v63 = 0;
              int v66 = 4;
              char v67 = 0;
              char v68 = 0;
              sub_100643AD0();
            }
            int v26 = *v21;
            if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to compose Terminal registration message", (uint8_t *)&buf, 2u);
            }
            if (SHIBYTE(v54) < 0) {
              operator delete((void *)v53);
            }
            if (SHIBYTE(v37) < 0) {
              operator delete(v36[0]);
            }
            if (SHIBYTE(v35) < 0) {
              operator delete(v34[0]);
            }
            if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v33.__r_.__value_.__l.__data_);
            }
          }
          else
          {
LABEL_50:
            int v25 = *v11;
            if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid Terminal Info", (uint8_t *)&buf, 2u);
            }
          }
          if (SHIBYTE(v39) < 0) {
            operator delete(v38[0]);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v42) < 0) {
            operator delete((void *)v41);
          }
        }
        else
        {
          int v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *v6);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Term-SMS cannot be dispatched. Waiting for triggers.", (uint8_t *)&buf, 2u);
          }
        }
        char v28 = (uint64_t **)(v3 + 160);
        BOOL v29 = sub_1002C74D0(v28, *v6, v6);
        long long v30 = v29[5];
        v29[5] = 0;
        if (v30) {
          (*(void (**)(uint64_t *))(*v30 + 8))(v30);
        }
        int v31 = sub_1002C74D0(v28, *v6, v6);
        long long v32 = v31[5];
        v31[5] = 0;
        if (v32) {
          (*(void (**)(uint64_t *))(*v32 + 8))(v32);
        }
      }
    }
  }
}

void sub_1007249A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *aBlock,dispatch_object_t object,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  if (*(char *)(v68 - 201) < 0) {
    operator delete(*(void **)(v68 - 224));
  }
  if (a49 < 0) {
    operator delete(__p);
  }
  if (a68 < 0) {
    operator delete(a63);
  }
  sub_1001F78F8((uint64_t)&a10);
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100724B9C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_100720EB4((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100724BB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100724BC8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      sub_10004D2C8(v4);
      if (v5)
      {
        unsigned int v7 = *(_DWORD *)(a1 + 56);
        int v6 = (int *)(a1 + 56);
        int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Term response timer expired", v13, 2u);
        }
        int v9 = sub_1002C74D0((uint64_t **)(v3 + 184), *v6, v6);
        uint64_t v10 = v9[5];
        v9[5] = 0;
        if (v10) {
          (*(void (**)(uint64_t *))(*v10 + 8))(v10);
        }
        uint64_t v11 = sub_1002C74D0((uint64_t **)(v3 + 184), *v6, v6);
        uint64_t v12 = v11[5];
        uint64_t v11[5] = 0;
        if (v12) {
          (*(void (**)(uint64_t *))(*v12 + 8))(v12);
        }
        sub_100723A3C(v3, *v6);
      }
    }
  }
}

BOOL sub_100724D18(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = a1;
  if (!*(void *)(a1 + 32))
  {
    BOOL v6 = 1;
    goto LABEL_12;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v6 = *(void *)(a1 + 32) == 0;
LABEL_12:
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_100729100;
    v12[3] = &unk_101A00600;
    void v12[4] = a1 + 8;
    v12[5] = &v9;
    BOOL v13 = v12;
    unsigned int v7 = *(NSObject **)(a1 + 24);
    char v19 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    if (v6)
    {
      int v15 = sub_10005A19C;
      int v16 = &unk_101A00620;
      BOOL v17 = &v19;
      long long v18 = &v13;
      dispatch_sync(v7, block);
    }
    else
    {
      int v15 = sub_10005AF00;
      int v16 = &unk_101A00640;
      BOOL v17 = &v19;
      long long v18 = &v13;
      dispatch_async_and_wait(v7, block);
    }
    BOOL v5 = v19 != 0;
    uint64_t v3 = v10;
    if (v10) {
      goto LABEL_19;
    }
    return v5;
  }
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    BOOL v5 = *(unsigned char *)(v4 + 32) != 0;
    if (!v3) {
      return v5;
    }
    goto LABEL_18;
  }
  BOOL v5 = 0;
  if (v3)
  {
LABEL_18:
    sub_10004D2C8(v3);
LABEL_19:
    sub_10004D2C8(v3);
  }
  return v5;
}

void sub_100724EEC(void *a1, uint64_t *a2)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_100725028;
  std::locale v10[3] = &unk_1019FF608;
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  v10[4] = a1;
  v10[5] = v4;
  uint64_t v11 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  int v8 = v7;
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_10072915C;
  block[3] = &unk_101A00668;
  block[5] = v6;
  BOOL v13 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  void block[4] = v10;
  dispatch_async(v9, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v8);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100725028(void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(unsigned int *)(v2 + 8);
  int v21 = *(_DWORD *)(v2 + 8);
  if (subscriber::isValidSimSlot())
  {
    BOOL v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v4);
    uint64_t v6 = (uint64_t **)(v1 + 72);
    unsigned int v7 = sub_100256E84((uint64_t **)(v1 + 72), v4, &v21)[5];
    v20[0] = v2;
    v20[1] = (uint64_t)v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v8 = sub_100BD4578((uint64_t)v7, v20);
    if (v3) {
      sub_10004D2C8(v3);
    }
    if (v8)
    {
      uint64_t v19 = 0;
      long long v17 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)long long buf = 0u;
      *(_OWORD *)int v16 = 0u;
      if (sub_100721134(v1, v4, (uint64_t)buf))
      {
        uint64_t v9 = sub_100256E84((uint64_t **)(v1 + 72), v4, &v21);
        sub_100BD362C((uint64_t)v9[5], (std::string *)buf);
      }
      uint64_t v10 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v14 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received a valid Terminal Registration Response: persisting", v14, 2u);
      }
      uint64_t v11 = sub_100256E84(v6, v4, &v21);
      sub_100BD2D6C((uint64_t)v11[5]);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(v16[1]);
      }
      if (SHIBYTE(v16[0]) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      uint64_t v12 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Received an invalid Terminal Registration Response: clearing persistence", buf, 2u);
      }
      BOOL v13 = sub_100256E84(v6, v4, &v21);
      sub_100BD2CB8((uint64_t)v13[5]);
    }
  }
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_100725254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v11)
  {
    sub_10004D2C8(v11);
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100725290(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_100720EB4((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007252AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1007252C0(uint64_t a1)
{
  sub_1007253E0(a1);

  operator delete();
}

char *sub_1007252F8(char *__dst, long long *a2, long long *a3, long long *a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v7;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst + 24, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v8 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)(__dst + 24) = v8;
  }
  uint64_t v9 = __dst + 48;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *((void *)__dst + 8) = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v9 = v10;
  }
  return __dst;
}

void sub_1007253AC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007253E0(uint64_t a1)
{
  *(void *)a1 = off_1019FF588;
  sub_10005CD2C(a1 + 448, *(char **)(a1 + 456));
  sub_1000346F8(a1 + 424, *(void **)(a1 + 432));
  sub_1000346F8(a1 + 400, *(void **)(a1 + 408));
  sub_1000346F8(a1 + 376, *(void **)(a1 + 384));
  sub_1000346F8(a1 + 352, *(void **)(a1 + 360));
  sub_1000346F8(a1 + 328, *(void **)(a1 + 336));
  sub_100088048(a1 + 304, *(void **)(a1 + 312));
  sub_100087F94(a1 + 280, *(void **)(a1 + 288));
  if (*(unsigned char *)(a1 + 272) && *(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  sub_1000886C0(a1 + 224, *(char **)(a1 + 232));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 216);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100725B04(*(void **)(a1 + 192));
  sub_100725B04(*(void **)(a1 + 168));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 152);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4) {
    sub_10004D2C8(v4);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100119D90(*(void **)(a1 + 80));
  long long v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  TerminalRegistrationControllerInterface::~TerminalRegistrationControllerInterface((TerminalRegistrationControllerInterface *)a1);
}

void sub_10072555C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100725594(uint64_t a1)
{
}

uint64_t sub_1007255B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007255F4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void sub_100725620(ServiceManager::Service *this)
{
  *(void *)this = off_1019FF770;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10072567C(ServiceManager::Service *this)
{
  *(void *)this = off_1019FF770;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1007256EC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TerminalRegistrationController");
}

unsigned char *sub_1007256FC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  double result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10072573C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100723434(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100723434(v4, 0);
}

uint64_t sub_1007257C0()
{
  return 0;
}

uint64_t sub_1007257C8()
{
  return 1;
}

uint64_t sub_1007257D0()
{
  return 0;
}

void sub_1007257DC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007258BC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007259D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF7F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007259F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019FF7F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100725A44(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 176));
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
}

void sub_100725AE4()
{
}

uint64_t sub_100725AF8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100725B04(void *a1)
{
  if (a1)
  {
    sub_100725B04(*a1);
    sub_100725B04(a1[1]);
    uint64_t v2 = a1[5];
    a1[5] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

void sub_100725B84()
{
}

void *sub_100725B98(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FF880;
  result[1] = v3;
  return result;
}

uint64_t sub_100725BE0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FF880;
  a2[1] = v2;
  return result;
}

void sub_100725C0C(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100725C14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100725C54()
{
}

void sub_100725C64()
{
}

__n128 sub_100725C78(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FF900;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100725CCC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FF900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100725D04(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  long long v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100725DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100725DDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100725E1C()
{
}

void sub_100725E2C()
{
}

__n128 sub_100725E40(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FF980;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100725E94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FF980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100725ECC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  long long v18 = (void **)v3->__r_.__value_.__r.__words[0];
  uint64_t v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    long long v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  char v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      uint64_t v8 = (void **)v6[1];
      uint64_t v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          uint64_t v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          uint64_t v9 = (void ***)v6;
        }
        while (!v10);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  BOOL v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  int v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    BOOL v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  long long v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100726090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1007260D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726118()
{
}

void sub_100726128()
{
}

__n128 sub_10072613C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFA00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100726190(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFA00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007261C8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100726288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1007262A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007262E0()
{
}

void sub_1007262F0()
{
}

__n128 sub_100726304(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFA80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100726358(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFA80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100726390(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100726450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100726468(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007264A8()
{
}

void sub_1007264B8()
{
}

__n128 sub_1007264CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFB00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100726520(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFB00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100726558(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100726618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100726630(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726670()
{
}

void sub_100726680()
{
}

__n128 sub_100726694(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFB80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007266E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFB80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100726720(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1007267E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1007267F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726838()
{
}

void sub_100726848()
{
}

__n128 sub_10072685C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFC00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007268B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFC00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007268E8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1007269A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1007269C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726A00()
{
}

void sub_100726A10()
{
}

__n128 sub_100726A24(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFC80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100726A78(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFC80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100726AB0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v11 = (char **)*v3;
  uint64_t v12 = (char *)v5;
  BOOL v13 = (char *)v3[2];
  if (v13)
  {
    *(void *)(v5 + 16) = &v12;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v11 = &v12;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  uint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    *((void *)v12 + 2) = v10;
    uint64_t v11 = &v12;
    uint64_t v12 = 0;
    BOOL v13 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10[0]);
  sub_10005CD2C((uint64_t)&v11, v12);
}

void sub_100726BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
}

uint64_t sub_100726BD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726C18()
{
}

void sub_100726C28()
{
}

__n128 sub_100726C3C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019FFD00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100726C90(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFD00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100726CC8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100726D10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100726D50()
{
}

uint64_t *sub_100726D5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 208));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100726DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100726DC0(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v36 = a1;
  uint64_t v37 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (Registry **)(*v1 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*v3);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v42 = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v42);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
LABEL_9:
  BOOL v13 = *(std::__shared_weak_count **)(v2 + 120);
  *(void *)(v2 + 112) = v12;
  *(void *)(v2 + 12sub_100720EB4((uint64_t)&a9, 0) = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  sGetSubscriberSimInterface();
  long long v14 = v42;
  long long v42 = 0uLL;
  int v15 = *(std::__shared_weak_count **)(v2 + 136);
  *(_OWORD *)(v2 + 128) = v14;
  if (v15)
  {
    sub_10004D2C8(v15);
    if (*((void *)&v42 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v42 + 1));
    }
  }
  long long v16 = (std::mutex *)Registry::getServiceMap(*v3);
  uint64_t v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)&long long v42 = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v42);
  if (v22)
  {
    uint64_t v24 = v22[3];
    char v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  char v23 = 0;
LABEL_22:
  int v25 = *(std::__shared_weak_count **)(v2 + 152);
  *(void *)(v2 + 144) = v24;
  *(void *)(v2 + 152) = v23;
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (*(void *)(v2 + 112) && *(void *)(v2 + 128) && *(void *)(v2 + 144))
  {
    Registry::createRestModuleOneTimeUseConnection(&v38, *(Registry **)(v2 + 56));
    ctu::RestModule::connect();
    if (v39) {
      sub_10004D2C8(v39);
    }
    sub_1005FE9F4(v2 + 224);
    sub_100722258(v2 + 248);
    sub_100058DB0(__p, "/cc/props/carrier_bundles");
    int v26 = operator new(0x28uLL);
    *int v26 = off_1019FF900;
    v26[1] = v2 + 280;
    _OWORD v26[2] = v2;
    v26[3] = sub_100722338;
    v26[4] = 0;
    int v43 = v26;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/sims_in_use");
    BOOL v27 = operator new(0x28uLL);
    void *v27 = off_1019FF980;
    v27[1] = v2 + 304;
    CFPropertyListFormat v27[2] = v2;
    v27[3] = sub_100722428;
    uint8_t v27[4] = 0;
    int v43 = v27;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/rat");
    char v28 = operator new(0x28uLL);
    *char v28 = off_1019FFA00;
    v28[1] = v2 + 328;
    std::exception v28[2] = v2;
    v28[3] = sub_100722518;
    void v28[4] = 0;
    int v43 = v28;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/reg_cs_attached");
    BOOL v29 = operator new(0x28uLL);
    *BOOL v29 = off_1019FFA80;
    v29[1] = v2 + 352;
    v29[2] = v2;
    v29[3] = sub_1007227B8;
    void v29[4] = 0;
    int v43 = v29;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/smsc_address_available");
    long long v30 = operator new(0x28uLL);
    *long long v30 = off_1019FFB00;
    v30[1] = v2 + 376;
    v30[2] = v2;
    void v30[3] = sub_100722A58;
    v30[4] = 0;
    int v43 = v30;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/sms_online");
    int v31 = operator new(0x28uLL);
    void *v31 = off_1019FFB80;
    v31[1] = v2 + 400;
    v31[2] = v2;
    v31[3] = sub_100722CF8;
    v31[4] = 0;
    int v43 = v31;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/roaming_results");
    long long v32 = operator new(0x28uLL);
    void *v32 = off_1019FFC00;
    v32[1] = v2 + 424;
    v32[2] = v2;
    v32[3] = sub_100722F98;
    uint8_t v32[4] = 0;
    int v43 = v32;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/ims_registration_state");
    std::string v33 = operator new(0x28uLL);
    *std::string v33 = off_1019FFC80;
    v33[1] = v2 + 448;
    v33[2] = v2;
    v33[3] = sub_100723240;
    v33[4] = 0;
    int v43 = v33;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/events/dump_state");
    uint64_t v34 = operator new(0x20uLL);
    *uint64_t v34 = off_1019FFD00;
    v34[1] = v2;
    v34[2] = sub_1007233C4;
    v34[3] = 0;
    int v43 = v34;
    ctu::RestModule::observeEvent();
    sub_10003F600(&v42);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100088C88((uint64_t *)&v37);
  return sub_100046B58((uint64_t *)&v36);
}

void sub_100727468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100727514(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v2 = v10;
  if (v10 != v11)
  {
    do
    {
      if (v12(*v2)) {
        goto LABEL_5;
      }
      ++v2;
    }
    while (v2 != v11);
    uint64_t v2 = v11;
LABEL_5:
    while (v2 != v11)
    {
      unsigned int v15 = *v2;
      int v3 = v15;
      uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v15);
      long long v14 = 0;
      uint64_t v5 = sub_100256E84((uint64_t **)(v1 + 72), v3, &v15);
      sub_100BD2B00((uint64_t)v5[5], &v14);
      if (v14) {
        uint64_t v6 = sub_100080778;
      }
      else {
        uint64_t v6 = 0;
      }
      if (v6)
      {
        uint64_t v7 = *v4;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Found Terminal Registration settings", buf, 2u);
        }
        uint64_t v8 = sub_100256E84((uint64_t **)(v1 + 72), v3, &v15);
        sub_100BD27EC((uint64_t)v8[5]);
      }
      sub_100057D78(&v14);
      unsigned int v9 = v2 + 1;
      uint64_t v2 = v11;
      if (v9 != v11)
      {
        uint64_t v2 = v9;
        do
        {
          if (v12(*v2)) {
            goto LABEL_18;
          }
          ++v2;
        }
        while (v2 != v11);
        uint64_t v2 = v11;
      }
LABEL_18:
      ;
    }
  }
  operator delete();
}

void sub_1007276EC()
{
}

void sub_10072773C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v18 = a2;
  if (subscriber::isValidSimSlot())
  {
    uint64_t v6 = *(void *)(a1 + 288);
    if (v6)
    {
      uint64_t v7 = a1 + 288;
      do
      {
        int v8 = *(_DWORD *)(v6 + 32);
        BOOL v9 = v8 < (int)a2;
        if (v8 >= (int)a2) {
          BOOL v10 = (uint64_t *)v6;
        }
        else {
          BOOL v10 = (uint64_t *)(v6 + 8);
        }
        if (!v9) {
          uint64_t v7 = v6;
        }
        uint64_t v6 = *v10;
      }
      while (*v10);
      if (v7 != a1 + 288 && *(_DWORD *)(v7 + 32) <= (int)a2)
      {
        uint64_t v17 = 0;
        *(_OWORD *)long long v16 = 0u;
        memset(v15, 0, sizeof(v15));
        LOWORD(v15[0]) = *(_WORD *)a3;
        if (*(char *)(a3 + 31) < 0)
        {
          sub_10004FC84(&v15[1], *(void **)(a3 + 8), *(void *)(a3 + 16));
        }
        else
        {
          *(_OWORD *)&v15[1] = *(_OWORD *)(a3 + 8);
          v15[3] = *(void **)(a3 + 24);
        }
        if (*(char *)(a3 + 55) < 0)
        {
          sub_10004FC84(v16, *(void **)(a3 + 32), *(void *)(a3 + 40));
        }
        else
        {
          *(_OWORD *)long long v16 = *(_OWORD *)(a3 + 32);
          uint64_t v17 = *(void *)(a3 + 48);
        }
        v22[0] = off_1019FFD80;
        v22[1] = v15;
        char v23 = v22;
        unsigned int v21 = 0;
        uint64_t v11 = operator new(0x20uLL);
        void *v11 = off_1019FFE10;
        v11[1] = a1;
        _DWORD v11[2] = &v18;
        void v11[3] = a3;
        unsigned int v21 = v11;
        v19[3] = 0;
        uint64_t v12 = sub_1002C74D0((uint64_t **)(a1 + 160), a2, &v18);
        sub_100058DB0(__p, "No action on bundle change");
        sub_100720F0C(a1, a2, (uint64_t)v23, (uint64_t)v20, (uint64_t)v19, (uint64_t *)v12 + 5, (uint64_t *)__p);
        if (v14 < 0) {
          operator delete(__p[0]);
        }
        sub_10003B34C(v19);
        sub_10003B34C(v20);
        sub_100727CBC(v22);
        if (SHIBYTE(v17) < 0) {
          operator delete(v16[0]);
        }
        if (SHIBYTE(v15[3]) < 0) {
          operator delete(v15[1]);
        }
      }
    }
  }
}

void sub_100727954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007279C4()
{
}

void *sub_1007279D8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FFD80;
  result[1] = v3;
  return result;
}

uint64_t sub_100727A20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FFD80;
  a2[1] = v2;
  return result;
}

uint64_t sub_100727A4C(uint64_t a1)
{
  return (**(unsigned __int8 **)(a1 + 8) < 6u) & (0x2Cu >> **(unsigned char **)(a1 + 8));
}

uint64_t sub_100727A6C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FFDF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100727AAC()
{
  return &off_1019FFDF0;
}

void sub_100727ABC()
{
}

__n128 sub_100727AD0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019FFE10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100727B24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFE10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100727B5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(a1 + 16));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315394;
    uint64_t v6 = asString();
    __int16 v7 = 2080;
    uint64_t v8 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Handle carrier bundle setup for %s (%s)", (uint8_t *)&v5, 0x16u);
  }
  uint64_t v4 = sub_100256E84((uint64_t **)(v2 + 72), **(_DWORD **)(a1 + 16), *(_DWORD **)(a1 + 16));
  sub_100BD2CB8((uint64_t)v4[5]);
}

uint64_t sub_100727C70(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FFE70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100727CB0()
{
  return &off_1019FFE70;
}

void *sub_100727CBC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100727D40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v17 = a2;
  __n128 result = (void *)subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v7 = *(void *)(a1 + 312);
    if (v7)
    {
      uint64_t v8 = a1 + 312;
      do
      {
        int v9 = *(_DWORD *)(v7 + 32);
        BOOL v10 = v9 < (int)a2;
        if (v9 >= (int)a2) {
          uint64_t v11 = (uint64_t *)v7;
        }
        else {
          uint64_t v11 = (uint64_t *)(v7 + 8);
        }
        if (!v10) {
          uint64_t v8 = v7;
        }
        uint64_t v7 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 312 && *(_DWORD *)(v8 + 32) <= (int)a2)
      {
        uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        v21[0] = off_1019FFE90;
        v21[1] = a3;
        uint64_t v22 = v21;
        v20[0] = off_1019FFF10;
        v20[1] = a1;
        uint64_t v20[2] = &v17;
        void v20[3] = v20;
        uint64_t v19 = 0;
        uint64_t v12 = operator new(0x28uLL);
        *uint64_t v12 = off_1019FFF90;
        v12[1] = a1;
        v12[2] = a3;
        v12[3] = &v16;
        void v12[4] = &v17;
        uint64_t v19 = v12;
        BOOL v13 = sub_1002C74D0((uint64_t **)(a1 + 160), a2, &v17);
        sub_100058DB0(__p, "Current Sim state doesn't allow Term-SMS");
        sub_100720F0C(a1, a2, (uint64_t)v22, (uint64_t)v20, (uint64_t)v18, (uint64_t *)v13 + 5, (uint64_t *)__p);
        if (v15 < 0) {
          operator delete(__p[0]);
        }
        sub_10003B34C(v18);
        sub_10003B34C(v20);
        return sub_100727CBC(v21);
      }
    }
  }
  return result;
}

void sub_100727F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC((void *)(v21 - 72));
  _Unwind_Resume(a1);
}

void sub_100727F5C()
{
}

void *sub_100727F70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019FFE90;
  result[1] = v3;
  return result;
}

uint64_t sub_100727FB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019FFE90;
  a2[1] = v2;
  return result;
}

uint64_t sub_100727FE4()
{
  return subscriber::isSimPresent();
}

uint64_t sub_100727FF0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FFEF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728030()
{
  return &off_1019FFEF0;
}

void sub_100728040()
{
}

__n128 sub_100728054(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019FFF10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007280A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFF10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007280D0(uint64_t a1)
{
}

uint64_t sub_1007280E0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FFF70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728120()
{
  return &off_1019FFF70;
}

void sub_100728130()
{
}

__n128 sub_100728144(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019FFF90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100728198(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019FFF90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007281D0(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t result = subscriber::isSimPresent();
  if ((result & 1) == 0)
  {
    uint64_t v4 = ***(NSObject ****)(a1 + 24);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Clearing device identifier because sim is absent", (uint8_t *)v11, 2u);
    }
    int v5 = v2 + 9;
    uint64_t v6 = sub_100256E84(v2 + 9, **(_DWORD **)(a1 + 32), *(_DWORD **)(a1 + 32))[5];
    uint64_t v15 = 0;
    long long v13 = 0u;
    *(_OWORD *)std::string __p = 0u;
    *(_OWORD *)uint64_t v11 = 0u;
    *(_OWORD *)uint64_t v12 = 0u;
    sub_100BD362C((uint64_t)v6, (std::string *)v11);
    if (SHIBYTE(v15) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(v12[1]);
    }
    if (SHIBYTE(v12[0]) < 0) {
      operator delete(v11[0]);
    }
    uint64_t v7 = v2 + 23;
    if (sub_1002C74D0(v2 + 23, **(_DWORD **)(a1 + 32), *(_DWORD **)(a1 + 32))[5])
    {
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], **(unsigned int **)(a1 + 32));
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v11[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Canceling pending action since SIM present: false", (uint8_t *)v11, 2u);
      }
      int v9 = sub_1002C74D0(v7, **(_DWORD **)(a1 + 32), *(_DWORD **)(a1 + 32));
      BOOL v10 = v9[5];
      v9[5] = 0;
      if (v10) {
        (*(void (**)(uint64_t *))(*v10 + 8))(v10);
      }
    }
    uint64_t result = (uint64_t)sub_100256E84(v5, **(_DWORD **)(a1 + 32), *(_DWORD **)(a1 + 32));
    *(_DWORD *)(*(void *)(result + 40) + 16sub_100720EB4((uint64_t)&a9, 0) = 0;
  }
  return result;
}

void sub_100728398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007283D4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019FFFF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728414()
{
  return &off_1019FFFF0;
}

void sub_100728424()
{
}

void *sub_100728438(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A00010;
  result[1] = v3;
  return result;
}

uint64_t sub_100728480(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A00010;
  a2[1] = v2;
  return result;
}

uint64_t sub_1007284AC()
{
  return isSet();
}

uint64_t sub_1007284B8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00070)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007284F8()
{
  return &off_101A00070;
}

void sub_100728508()
{
}

__n128 sub_10072851C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00090;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100728568(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00090;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100728598(uint64_t a1)
{
}

uint64_t sub_1007285A8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A000F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007285E8()
{
  return &off_101A000F0;
}

void sub_1007285F8()
{
}

void *sub_10072860C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A00110;
  result[1] = v3;
  return result;
}

uint64_t sub_100728654(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A00110;
  a2[1] = v2;
  return result;
}

uint64_t sub_100728680(uint64_t a1)
{
  return **(unsigned __int8 **)(a1 + 8);
}

uint64_t sub_10072868C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00170)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007286CC()
{
  return &off_101A00170;
}

void sub_1007286DC()
{
}

__n128 sub_1007286F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10072873C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10072876C(uint64_t a1)
{
}

uint64_t sub_10072877C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A001F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007287BC()
{
  return &off_101A001F0;
}

void sub_1007287CC()
{
}

void *sub_1007287E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A00210;
  result[1] = v3;
  return result;
}

uint64_t sub_100728828(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A00210;
  a2[1] = v2;
  return result;
}

uint64_t sub_100728854(uint64_t a1)
{
  return **(unsigned __int8 **)(a1 + 8);
}

uint64_t sub_100728860(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00270)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007288A0()
{
  return &off_101A00270;
}

void sub_1007288B0()
{
}

__n128 sub_1007288C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00290;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100728910(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00290;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100728940(uint64_t a1)
{
}

uint64_t sub_100728950(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A002F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728990()
{
  return &off_101A002F0;
}

void sub_1007289A0()
{
}

void *sub_1007289B4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A00310;
  result[1] = v3;
  return result;
}

uint64_t sub_1007289FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A00310;
  a2[1] = v2;
  return result;
}

uint64_t sub_100728A28(uint64_t a1)
{
  return **(unsigned __int8 **)(a1 + 8);
}

uint64_t sub_100728A34(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00370)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728A74()
{
  return &off_101A00370;
}

void sub_100728A84()
{
}

__n128 sub_100728A98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100728AE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100728B14(uint64_t a1)
{
}

uint64_t sub_100728B24(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A003F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728B64()
{
  return &off_101A003F0;
}

void sub_100728B74()
{
}

void *sub_100728B88(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A00410;
  result[1] = v3;
  return result;
}

uint64_t sub_100728BD0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A00410;
  a2[1] = v2;
  return result;
}

BOOL sub_100728BFC(uint64_t a1)
{
  return **(_DWORD **)(a1 + 8) == 5;
}

uint64_t sub_100728C10(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00470)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728C50()
{
  return &off_101A00470;
}

void sub_100728C60()
{
}

__n128 sub_100728C74(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100728CC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100728CF0(uint64_t a1)
{
}

uint64_t sub_100728D00(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A004F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100728D40()
{
  return &off_101A004F0;
}

void *sub_100728D4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = SlotIdFromPersonalityIdEx();
  int v11 = v5;
  __n128 result = (void *)subscriber::isValidSimSlot();
  if (result)
  {
    if (*(unsigned char *)(a3 + 8)) {
      char v7 = 0;
    }
    else {
      char v7 = (*(_DWORD *)a3 == 1) & (*(_DWORD *)(a3 + 4) >> 1);
    }
    *((unsigned char *)sub_100256E84((uint64_t **)(a1 + 72), v5, &v11)[5] + 164) = v7;
    v14[0] = off_101A00510;
    v14[1] = a1;
    void v14[2] = &v11;
    uint64_t v15 = v14;
    v13[0] = off_101A00590;
    v13[1] = a1;
    void v13[2] = &v11;
    v13[3] = v13;
    v12[3] = 0;
    uint64_t v8 = sub_1002C74D0((uint64_t **)(a1 + 160), v5, &v11);
    sub_100058DB0(__p, "No IMS-SMS over cellular");
    sub_100720F0C(a1, v5, (uint64_t)v15, (uint64_t)v13, (uint64_t)v12, (uint64_t *)v8 + 5, (uint64_t *)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    sub_10003B34C(v12);
    sub_10003B34C(v13);
    return sub_100727CBC(v14);
  }
  return result;
}

void sub_100728EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a17);
  sub_10003B34C(&a21);
  sub_100727CBC((void *)(v21 - 72));
  _Unwind_Resume(a1);
}

void sub_100728F08()
{
}

__n128 sub_100728F1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00510;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100728F68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00510;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100728F98(uint64_t a1)
{
  return *((unsigned __int8 *)sub_100256E84((uint64_t **)(*(void *)(a1 + 8) + 72), **(_DWORD **)(a1 + 16), *(_DWORD **)(a1 + 16))[5]+ 164);
}

uint64_t sub_100728FC4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00570)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100729004()
{
  return &off_101A00570;
}

void sub_100729014()
{
}

__n128 sub_100729028(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A00590;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100729074(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A00590;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007290A4(uint64_t a1)
{
}

uint64_t sub_1007290B4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A005F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007290F4()
{
  return &off_101A005F0;
}

BOOL sub_100729100(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v3 = *v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v3)
  {
    BOOL v4 = 0;
    if (!v2) {
      return v4;
    }
    goto LABEL_5;
  }
  BOOL v4 = *(unsigned __int8 *)(v3 + 32) != 0;
  if (v2) {
LABEL_5:
  }
    sub_10004D2C8(v2);
  return v4;
}

uint64_t sub_10072915C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10072916C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_100720EB4((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100729188(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100729564(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 64));
  xpc_release(*(xpc_object_t *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1007295DC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D5A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D5A0))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D598, kCtLoggingSystemName, "migration");
    __cxa_guard_release(&qword_101B0D5A0);
  }
}

void sub_10072965C(_Unwind_Exception *a1)
{
}

void sub_100729674(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _postInstallUpdateActivityDidReceiveCallback:a2];
}

void sub_1007296C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100729FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10072A110(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  void block[2] = sub_10072A5B8;
  block[3] = &unk_1019A1BF8;
  void block[4] = a1;
  if (qword_101B0D590 != -1) {
    dispatch_once(&qword_101B0D590, block);
  }
}

void sub_10072A1B0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10072A3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void *sub_10072A4FC(void *a1)
{
  *a1 = off_101A006D0;
  uint64_t v2 = (id *)a1[4];
  a1[4] = 0;
  if (v2)
  {

    operator delete();
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_10072A580(void *a1)
{
  sub_10072A4FC(a1);

  operator delete();
}

void sub_10072A5B8(uint64_t a1)
{
  uint64_t v3 = 0;
  BOOL v4 = 0;
  Registry::getServiceManager(&v3, **(Registry ***)(a1 + 32));
  sub_100058DB0(&__p, "Registration legacy time update");
  v5[0] = off_101A00748;
  v5[3] = v5;
  ServiceManager::registerMigrationMethod();
  sub_1001472DC(v5);
  if (v2 < 0) {
    operator delete(__p);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_10072A68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

void sub_10072A6D0()
{
}

void *sub_10072A6E4()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_101A00748;
  return result;
}

void sub_10072A71C(uint64_t a1, void *a2)
{
  *a2 = off_101A00748;
}

void sub_10072A744(uint64_t a1, xpc_object_t *a2)
{
  *a2 = xpc_null_create();
  int v3 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D5A8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101B0D5A8))
    {
      sub_100058DB0(qword_101B0D5B0, "GsmRegistrationModel::fEnableAutomaticTimeUpdate");
      __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0D5B0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D5A8);
    }
  }
  uint64_t v2 = sub_100365D74();
  sub_100366010(v2);
}

void sub_10072A820(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_101B0D5A8);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10072A854(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A007A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072A894()
{
  return &off_101A007A8;
}

BOOL sub_10072A8A0(uint64_t a1, void **a2, _DWORD *a3)
{
  std::mutex::lock(&stru_101B09FA8);
  memset(&v11, 0, sizeof(v11));
  uint64_t v6 = sub_100046F68(a1, a2);
  char v7 = v6;
  uint64_t v8 = (void **)(a1 + 8);
  if (v8 != v6)
  {
    std::string::operator=(&v11, (const std::string *)(v6 + 7));
    if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v9 = &v11;
    }
    else {
      int v9 = (std::string *)v11.__r_.__value_.__r.__words[0];
    }
    *a3 = strtoll((const char *)v9, 0, 16);
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  std::mutex::unlock(&stru_101B09FA8);
  return v8 != v7;
}

void sub_10072A960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_101B09FA8);
  _Unwind_Resume(a1);
}

uint64_t *sub_10072A988(uint64_t a1)
{
  return sub_100C62700(a1, "kInternalToolPerformMigration", (unint64_t)sub_10072A9A8, 0xEu);
}

const void **sub_10072A9A8(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t *a5)
{
  sub_10072A110(a1);
  int v26 = 0;
  *(void *)long long v30 = a4;
  *(void *)&v30[8] = "kLastSystemVersionString";
  sub_100048BAC((uint64_t)v30, buf);
  xpc::bridge((uint64_t *)__p, (xpc *)buf, v8);
  sub_100056248(&v26, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  xpc_release(*(xpc_object_t *)buf);
  if (v26) {
    int v9 = sub_1000810B8;
  }
  else {
    int v9 = 0;
  }
  if (v9)
  {
    sub_1007295DC();
    char v10 = qword_101B0D598;
    if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_DEFAULT))
    {
      memset(v30, 0, sizeof(v30));
      uint64_t v31 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)v30;
      uint64_t v25 = v31;
      std::string v11 = *(void ***)v30;
      if (v31 >= 0) {
        std::string v11 = __p;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Migrating from system version: %{public}s", buf, 0xCu);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  *(void *)long long v30 = a4;
  *(void *)&v30[8] = "kLastSystemVersion";
  sub_100048BAC((uint64_t)v30, __p);
  int v13 = xpc::dyn_cast_or_default((xpc *)__p, (const object *)0xFFFFFFFFLL, v12);
  xpc_release(__p[0]);
  if (v13 != -1)
  {
    sub_1007295DC();
    char v14 = qword_101B0D598;
    if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v30 = 67109120;
      *(_DWORD *)&v30[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Migrating from system version: %d", v30, 8u);
    }
  }
  Registry::getServiceManager((uint64_t *)v30, *(Registry **)a1);
  xpc_object_t v23 = *a4;
  if (*a4) {
    xpc_retain(*a4);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  global_queue = dispatch_get_global_queue(0, 0);
  dispatch_object_t object = global_queue;
  if (global_queue) {
    dispatch_retain(global_queue);
  }
  int v17 = *(Registry **)a1;
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 8);
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = *a5;
  uint64_t v18 = a5[1];
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  char v28 = 0;
  uint64_t v20 = operator new(0x28uLL);
  void *v20 = off_101A007C8;
  v20[1] = v17;
  uint64_t v20[2] = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v20[3] = v19;
  void v20[4] = v18;
  char v28 = v20;
  ServiceManager::migrate();
  sub_100060644(v27);
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v23);
  if (*(void *)&v30[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v30[8]);
  }
  return sub_1000558F4(&v26);
}

void sub_10072ACB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, xpc_object_t a14, xpc_object_t a15, uint64_t a16, uint64_t a17, const void *a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 - 57) < 0) {
    operator delete(*(void **)(v21 - 80));
  }
  sub_1000558F4(&a18);
  _Unwind_Resume(a1);
}

void *sub_10072AD8C(void *a1)
{
  *a1 = off_101A007C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10072ADE4(void *a1)
{
  *a1 = off_101A007C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_10072AE5C(void *a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_101A007C8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_10072AED0(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A007C8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10072AF20(uint64_t a1)
{
}

void sub_10072AF28(void *a1)
{
  sub_10000ACD0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10072AF64(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  xpc_object_t v7 = xpc_BOOL_create(*a2 == 0);
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  v6[0] = *(void *)(a1 + 24);
  v6[1] = "kMigrationResult";
  sub_100035E70((uint64_t)v6, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  xpc_object_t v7 = 0;
  sub_1007295DC();
  uint64_t v4 = qword_101B0D598;
  if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Done with migration", (uint8_t *)v6, 2u);
  }
  if (v3)
  {
    sub_1007295DC();
    uint64_t v5 = qword_101B0D598;
    if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "CommCenter migration timeout", (uint8_t *)v6, 2u);
    }
  }
}

uint64_t sub_10072B088(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10072B0C8()
{
}

void sub_10072B0D8()
{
}

void *sub_10072B0EC()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_101A00848;
  return result;
}

void sub_10072B124(uint64_t a1, void *a2)
{
  *a2 = off_101A00848;
}

void sub_10072B14C(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  sub_1007295DC();
  int v3 = qword_101B0D598;
  if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Done with migration", buf, 2u);
  }
  if (v2)
  {
    sub_1007295DC();
    uint64_t v4 = qword_101B0D598;
    if (os_log_type_enabled((os_log_t)qword_101B0D598, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "CommCenter migration timeout", v5, 2u);
    }
  }
}

uint64_t sub_10072B208(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A008A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072B248()
{
  return &off_101A008A8;
}

void sub_10072B258(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10072B290(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10072B2C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10072B304(ServiceManager::Service *this)
{
  *(void *)this = off_101A00940;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10072B360(ServiceManager::Service *this)
{
  *(void *)this = off_101A00940;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10072B3D0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CommCenterDataMigrator");
}

unsigned char *sub_10072B3E0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  *int v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10072B420(uint64_t a1, dispatch_object_t *a2)
{
  int v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_10072B47C()
{
  return 0;
}

uint64_t sub_10072B484()
{
  return 1;
}

uint64_t sub_10072B48C()
{
  return 0;
}

id sub_10072B498(uint64_t a1)
{
  return [**(id **)(*(void *)(a1 + 8) + 32) setup];
}

void sub_10072B4AC()
{
  sub_100C624B8((uint64_t)&unk_101B0D588, (uint64_t)sub_10072A988);
}

uint64_t sub_10072B500(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t *sub_10072B530(uint64_t a1)
{
  sub_100C62700(a1, "kExecuteCmd", (unint64_t)sub_10072B5E8, 3u);
  sub_100C62700(a1, "kSimRefresh", (unint64_t)sub_10072BBF8, 3u);
  sub_100C62700(a1, "kCsVoiceStatus", (unint64_t)sub_10072BE94, 0xEu);

  return sub_100C62700(a1, "kProvisionLazuli", (unint64_t)sub_10072C200, 0xEu);
}

void sub_10072B5E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v21 = 0;
  uint64_t v22 = (const char **)a4;
  xpc_object_t v23 = "kName";
  sub_100048BAC((uint64_t)&v22, &object);
  long long __p = 0uLL;
  uint64_t v26 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)__p);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  *(void *)&long long __p = a4;
  *((void *)&__p + 1) = "kArgs";
  sub_100048BAC((uint64_t)&__p, &object);
  CFTypeRef cf = 0;
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_null)
  {
    CFTypeRef cf = 0;
  }
  else
  {
    *(void *)&long long __p = _CFXPCCreateCFObjectFromXPCObject();
    sub_100084068(&cf, (CFTypeRef *)&__p);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D5D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D5D8))
  {
    sub_100058DB0(&__p, "iRAT::start");
    BOOL v27 = (uint64_t (*)(uint64_t, uint64_t))&stru_101A00A08;
    sub_100058DB0(&v28, "iRAT::stop");
    v29[2] = &stru_101A00A48;
    sub_100058DB0(v30, "iRAT::pref");
    void v30[3] = &stru_101A00A88;
    sub_100058DB0(v31, "Reg::imsprefs");
    v31[3] = &stru_101A00AC8;
    sub_100058DB0(v32, "data::dataModeChanged");
    v32[3] = &stru_101A00B08;
    sub_100058DB0(v33, "data::dataAttached");
    v33[3] = &stru_101A00B48;
    sub_100058DB0(v34, "data::roaming");
    v34[3] = &stru_101A00B88;
    sub_100058DB0(v35, "data::provisioning2");
    v35[3] = &stru_101A00BC8;
    sub_100058DB0(v36, "power::powerMode");
    void v36[3] = &stru_101A00C08;
    sub_100058DB0(v37, "wifi::assertion");
    v37[3] = &stru_101A00C48;
    sub_100058DB0(v38, "em::setTestEmNumber");
    void v38[3] = &stru_101A00C88;
    sub_100730004((uint64_t **)&v22, &__p, 11);
    char v14 = (char *)v23;
    qword_101B0D600 = (uint64_t)v22;
    qword_101B0D608 = (uint64_t)v23;
    qword_101B0D610 = v24;
    if (v24)
    {
      *((void *)v23 + 2) = &qword_101B0D608;
      uint64_t v22 = &v23;
      xpc_object_t v23 = 0;
      uint64_t v24 = 0;
      char v14 = 0;
    }
    else
    {
      qword_101B0D600 = (uint64_t)&qword_101B0D608;
    }
    sub_1000DA2E4(v14);
    uint64_t v15 = 352;
    do
    {
      if (*((char *)&v23 + v15 + 7) < 0) {
        operator delete(*(void **)((char *)&v21 + v15));
      }
      v15 -= 32;
    }
    while (v15);
    __cxa_guard_release(&qword_101B0D5D8);
  }
  uint64_t v7 = qword_101B0D608;
  if (!qword_101B0D608) {
    goto LABEL_20;
  }
  uint64_t v8 = &qword_101B0D608;
  do
  {
    char v9 = sub_100046FE8((void *)(v7 + 32), v20);
    if (v9 >= 0) {
      char v10 = (uint64_t *)v7;
    }
    else {
      char v10 = (uint64_t *)(v7 + 8);
    }
    if (v9 >= 0) {
      uint64_t v8 = (uint64_t *)v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v8 == &qword_101B0D608 || (sub_100046FE8(v20, (void **)v8 + 4) & 0x80) != 0)
  {
LABEL_20:
    sub_10072CAF4();
    int v12 = qword_101B0D5E0;
    if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = v20;
      if (v21 < 0) {
        int v13 = (void **)v20[0];
      }
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E executeCmd: %s <-- handler not found", (uint8_t *)&__p, 0xCu);
    }
  }
  else
  {
    *(void *)&long long __p = 0;
    *((void *)&__p + 1) = &__p;
    uint64_t v26 = 0x3002000000;
    BOOL v27 = sub_10072CA04;
    char v28 = sub_10072CA18;
    v29[0] = 0;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    void block[2] = sub_10072CA20;
    block[3] = &unk_101A009B8;
    void block[4] = &__p;
    void block[5] = v8;
    void block[6] = a1;
    block[7] = a2;
    CFTypeRef v17 = cf;
    if (cf) {
      CFRetain(cf);
    }
    dispatch_async(global_queue, block);
    sub_100057D78(&v17);
    _Block_object_dispose(&__p, 8);
    sub_100057D78(v29);
  }
  sub_100057D78(&cf);
  xpc_release(object);
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
}

void sub_10072BAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, xpc_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v37 = 352;
  while (1)
  {
    if (*(char *)(v35 + v37 - 9) < 0) {
      operator delete(*(void **)(v35 + v37 - 32));
    }
    v37 -= 32;
    if (!v37)
    {
      __cxa_guard_abort(&qword_101B0D5D8);
      sub_100057D78(&a19);
      xpc_release(object);
      if (a26 < 0) {
        operator delete(__p);
      }
      _Unwind_Resume(a1);
    }
  }
}

void sub_10072BBF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)&long long buf = a4;
  *((void *)&buf + 1) = "kSimSlotIdentifier";
  sub_100048BAC((uint64_t)&buf, &object);
  int v7 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)0xFFFFFFFFLL, v6);
  xpc_release(object);
  if (v7 < 1)
  {
    BOOL v11 = v7 == 0;
    sub_10072CAF4();
    int v12 = qword_101B0D5E0;
    BOOL v13 = os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      if (v13)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Sending SIM refresh event for all available slots", (uint8_t *)&buf, 2u);
      }
      subscriber::makeSimSlotRange();
      char v14 = (int *)*((void *)&buf + 1);
      uint64_t v15 = (int *)buf;
      if ((void)buf != *((void *)&buf + 1))
      {
        uint64_t v16 = v23;
        while ((v16(*v15) & 1) == 0)
        {
          if (++v15 == v14)
          {
            uint64_t v15 = v14;
            break;
          }
        }
        CFTypeRef v17 = (int *)*((void *)&buf + 1);
LABEL_22:
        while (v15 != v17)
        {
          sub_1007301C4(*v15);
          uint64_t v18 = v15 + 1;
          uint64_t v15 = v14;
          if (v18 != v14)
          {
            uint64_t v15 = v18;
            while ((v16(*v15) & 1) == 0)
            {
              if (++v15 == v14)
              {
                uint64_t v15 = v14;
                goto LABEL_22;
              }
            }
          }
        }
      }
    }
    else if (v13)
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E Slot is unknown in SimRefresh request", (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    if (v7 == 2) {
      int v8 = 2;
    }
    else {
      int v8 = 1;
    }
    sub_10072CAF4();
    char v9 = qword_101B0D5E0;
    if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sending SIM refresh event for slot=%s", (uint8_t *)&buf, 0xCu);
    }
    sub_1007301C4(v8);
  }
  xpc_object_t v19 = xpc_BOOL_create(1);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  *(void *)&long long buf = *a5;
  *((void *)&buf + 1) = "kDidSucceed";
  sub_100035E70((uint64_t)&buf, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
}

void sub_10072BE54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072BE94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (sub_10121F67C())
  {
    *(void *)&long long buf = a4;
    *((void *)&buf + 1) = "kSimSlotIdentifier";
    sub_100048BAC((uint64_t)&buf, &object);
    int v8 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)0xFFFFFFFFLL, v7);
    xpc_release(object);
    *(void *)&long long buf = a4;
    *((void *)&buf + 1) = "kCsVoiceSupported";
    sub_100048BAC((uint64_t)&buf, &object);
    char v10 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v9);
    xpc_release(object);
    if (v8 < 1)
    {
      sub_10072CAF4();
      uint64_t v15 = qword_101B0D5E0;
      if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E Slot is unknown in CsVoiceStatus request", (uint8_t *)&buf, 2u);
      }
    }
    else
    {
      if (v8 == 2) {
        int v11 = 2;
      }
      else {
        int v11 = 1;
      }
      sub_10072CAF4();
      int v12 = qword_101B0D5E0;
      if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = subscriber::asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Sending cs_voice_support REST property change for slot=%s", (uint8_t *)&buf, 0xCu);
      }
      *((void *)&buf + 1) = 0;
      uint64_t v25 = 0;
      *(void *)&long long buf = (char *)&buf + 8;
      char v14 = operator new(0x28uLL);
      v14[7] = v11;
      *((unsigned char *)v14 + 32) = v10;
      *((unsigned char *)v14 + 33) = 1;
      *(void *)char v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = (char *)&buf + 8;
      *(void *)&long long buf = v14;
      *((void *)&buf + 1) = v14;
      sub_100046C90((uint64_t *)v14, (uint64_t *)v14);
      ++v25;
      sub_100058DB0(&__p, "/cc/props/cs_voice_support");
      sub_10073195C(&buf, &v18);
      ctu::RestModule::setProperty();
      xpc_release(v18);
      xpc_object_t v18 = 0;
      if (v20 < 0) {
        operator delete(__p);
      }
      sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
    }
    xpc_object_t v16 = xpc_BOOL_create(1);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    *(void *)&long long buf = *a5;
    *((void *)&buf + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&buf, &v16, &v17);
    xpc_release(v17);
    xpc_object_t v17 = 0;
    xpc_release(v16);
  }
  else
  {
    xpc_object_t v22 = xpc_BOOL_create(0);
    if (!v22) {
      xpc_object_t v22 = xpc_null_create();
    }
    *(void *)&long long buf = *a5;
    *((void *)&buf + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&buf, &v22, &v23);
    xpc_release(v23);
    xpc_object_t v23 = 0;
    xpc_release(v22);
  }
}

void sub_10072C150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072C200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (sub_10121F67C())
  {
    *(void *)&long long buf = a4;
    *((void *)&buf + 1) = "kSimSlotIdentifier";
    sub_100048BAC((uint64_t)&buf, &object);
    int v8 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)0xFFFFFFFFLL, v7);
    xpc_release((xpc_object_t)object);
    if (v8 < 1)
    {
      sub_10072CAF4();
      xpc_object_t v18 = qword_101B0D5E0;
      if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Slot is unknown in ProvisionLazuli request", (uint8_t *)&buf, 2u);
      }
    }
    else
    {
      v27[0] = 0;
      v27[1] = 0;
      uint64_t v28 = 0;
      PersonalityIdFromSlotId();
      sub_10072CAF4();
      BOOL v9 = qword_101B0D5E0;
      if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = subscriber::asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sending LazuliInfoReady REST property change for slot=%s", (uint8_t *)&buf, 0xCu);
      }
      CFMutableDictionaryRef theDict = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableDictionaryRef v12 = theDict;
        CFMutableDictionaryRef theDict = Mutable;
        *(void *)&long long buf = v12;
        sub_10005717C((const void **)&buf);
      }
      CFDictionarySetValue(theDict, @"ForceTcp", kCFBooleanTrue);
      CFDictionarySetValue(theDict, @"ForceTls", kCFBooleanTrue);
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long buf = 0u;
      long long v40 = 0u;
      sub_100058DB0(&buf, "bj.5GMC.ims.mnc000.mcc460.3gppnetwork.org");
      sub_100058DB0((void *)&v40 + 1, "460000333159277@ims.mnc000.mcc460.3gppnetwork.org");
      long long v43 = 0u;
      long long v44 = 0u;
      long long v42 = 0u;
      sub_100058DB0(&object, "sip:+8613811902853@bj.5GMC.ims.mnc000.mcc460.3gppnetwork.org");
      sub_100058DB0(v37, "sip:460000333159277@bj.5GMC.ims.mnc000.mcc460.3gppnetwork.org");
      sub_100058DB0(v38, "tel:+8613811902853");
      long long v45 = 0uLL;
      *(void *)&long long v46 = 0;
      *(void *)&long long v32 = &v45;
      *((void *)&v32 + 1) = 0;
      *(void *)&long long v45 = operator new(0x48uLL);
      *((void *)&v45 + 1) = v45;
      *(void *)&long long v46 = v45 + 72;
      *((void *)&v45 + 1) = sub_1000D8A18((uint64_t)&v46, &object, &buf, (char *)v45);
      sub_100058DB0(&v32, "siphh13.hbq.r.10086.cn");
      sub_100058DB0(v34, "siphh15.hbq.r.10086.cn");
      *((void *)&v46 + 1) = 0;
      long long v47 = 0uLL;
      v31[0] = (char *)&v46 + 8;
      v31[1] = 0;
      *((void *)&v46 + 1) = operator new(0x30uLL);
      *(void *)&long long v47 = *((void *)&v46 + 1);
      *((void *)&v47 + 1) = *((void *)&v46 + 1) + 48;
      *(void *)&long long v47 = sub_1000D8A18((uint64_t)&v47 + 8, &v32, &object, *((char **)&v46 + 1));
      LODWORD(v48) = 0;
      sub_10004EFE4((void *)&v48 + 1, (CFTypeRef *)&theDict);
      for (uint64_t i = 0; i != -6; i -= 3)
      {
        if (SHIBYTE(v34[i + 2]) < 0) {
          operator delete(v34[i]);
        }
      }
      for (uint64_t j = 0; j != -9; j -= 3)
      {
        if (SHIBYTE(v38[j + 2]) < 0) {
          operator delete((void *)v38[j]);
        }
      }
      *((void *)&v32 + 1) = 0;
      uint64_t v33 = 0;
      *(void *)&long long v32 = (char *)&v32 + 8;
      v31[0] = 0;
      uint64_t v15 = (uint64_t **)sub_100046ED4((uint64_t)&v32, v31, v27);
      if (!*v15)
      {
        uint64_t v36 = 0;
        xpc_object_t v16 = operator new(0xD8uLL);
        xpc_object_t v17 = v16;
        *(void *)&long long object = v16;
        *((void *)&object + 1) = (char *)&v32 + 8;
        LOBYTE(v36) = 0;
        if (SHIBYTE(v28) < 0)
        {
          sub_10004FC84(v16 + 32, v27[0], (unint64_t)v27[1]);
        }
        else
        {
          *((_OWORD *)v16 + 2) = *(_OWORD *)v27;
          *((void *)v16 + 6) = v28;
        }
        sub_100731E90(v17 + 56, &buf);
        LOBYTE(v36) = 1;
        uint64_t v19 = v31[0];
        char v20 = (uint64_t *)object;
        *(void *)long long object = 0;
        v20[1] = 0;
        uint64_t v20[2] = v19;
        *uint64_t v15 = v20;
        if (*(void *)v32)
        {
          *(void *)&long long v32 = *(void *)v32;
          char v20 = *v15;
        }
        sub_100046C90(*((uint64_t **)&v32 + 1), v20);
        ++v33;
        *(void *)&long long object = 0;
        sub_100732068((uint64_t)&object, 0);
      }
      sub_100058DB0(&__p, "/cc/props/lazuli_info_ready");
      sub_100731C90(&v32, &v23);
      ctu::RestModule::setProperty();
      xpc_release(v23);
      xpc_object_t v23 = 0;
      if (v25 < 0) {
        operator delete(__p);
      }
      sub_1007322F4((uint64_t)&v32, *((void **)&v32 + 1));
      sub_100057D78((const void **)&v48 + 1);
      *(void *)&long long object = (char *)&v46 + 8;
      sub_100047F64((void ***)&object);
      *(void *)&long long object = &v45;
      sub_100047F64((void ***)&object);
      if (SHIBYTE(v44) < 0) {
        operator delete(*((void **)&v43 + 1));
      }
      if (SBYTE7(v43) < 0) {
        operator delete((void *)v42);
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(*((void **)&v40 + 1));
      }
      if (SBYTE7(v40) < 0) {
        operator delete((void *)buf);
      }
      sub_10005717C((const void **)&theDict);
      if (SHIBYTE(v28) < 0) {
        operator delete(v27[0]);
      }
    }
    xpc_object_t v21 = xpc_BOOL_create(1);
    if (!v21) {
      xpc_object_t v21 = xpc_null_create();
    }
    *(void *)&long long buf = *a5;
    *((void *)&buf + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&buf, &v21, &v22);
    xpc_release(v22);
    xpc_object_t v22 = 0;
    xpc_release(v21);
  }
  else
  {
    xpc_object_t v29 = xpc_BOOL_create(0);
    if (!v29) {
      xpc_object_t v29 = xpc_null_create();
    }
    *(void *)&long long buf = *a5;
    *((void *)&buf + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&buf, &v29, &v30);
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_release(v29);
  }
}

void sub_10072C7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *a13, uint64_t a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,xpc_object_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10072CA04(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4sub_100720EB4((uint64_t)&a9, 0) = 0;
  *(void *)(result + 4sub_100720EB4((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4sub_100720EB4((uint64_t)&a9, 0) = 0;
  return result;
}

const void **sub_10072CA18(uint64_t a1)
{
  return sub_100057D78((const void **)(a1 + 40));
}

const void **sub_10072CA20(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 56);
  long long v6 = *(_OWORD *)(a1 + 48);
  sub_100058198(v7, (const void **)(a1 + 64));
  (*(void (**)(const void **__return_ptr, uint64_t, long long *))(v2 + 16))(&v8, v2, &v6);
  int v3 = (const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (v3 != &v8)
  {
    uint64_t v4 = *v3;
    NSObject *v3 = v8;
    int v8 = 0;
    BOOL v9 = v4;
    sub_100057D78(&v9);
  }
  sub_100057D78(&v8);
  return sub_100057D78(v7);
}

void sub_10072CACC(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

const void **sub_10072CAE0(uint64_t a1, uint64_t a2)
{
  return sub_100058198((const void **)(a1 + 64), (const void **)(a2 + 64));
}

const void **sub_10072CAEC(uint64_t a1)
{
  return sub_100057D78((const void **)(a1 + 64));
}

void sub_10072CAF4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D5E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D5E8))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D5E0, kCtLoggingSystemName, "debug");
    __cxa_guard_release(&qword_101B0D5E8);
  }
}

void sub_10072CB74(_Unwind_Exception *a1)
{
}

CFSharedRef<const __CFDictionary> sub_10072CB8C(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  *uint64_t v2 = 0;
  return (CFSharedRef<const __CFDictionary>)a1;
}

CFSharedRef<const __CFDictionary> sub_10072CB94(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  *uint64_t v2 = 0;
  return (CFSharedRef<const __CFDictionary>)a1;
}

CFSharedRef<const __CFDictionary> sub_10072CB9C(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  int v3 = v2;
  var0 = (Registry **)a2->var0.var0;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"appType");
  CFStringRef v6 = Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      if (CFEqual(v6, @"data"))
      {
        int v10 = 0;
        int v9 = 0;
        int v8 = 1;
        goto LABEL_6;
      }
      if (CFEqual(v6, @"voice"))
      {
        int v8 = 0;
        int v10 = 0;
        int v9 = 1;
        goto LABEL_6;
      }
    }
  }
  int v8 = 0;
  int v9 = 0;
  int v10 = 1;
LABEL_6:
  CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(theDict, @"linkType");
  CFStringRef v12 = v11;
  if (v11 && (CFTypeID v13 = CFGetTypeID(v11), v13 == CFStringGetTypeID()))
  {
    if (CFStringCompare(v12, @"bb", 0))
    {
      if (CFStringCompare(v12, @"wifi", 0)) {
        uint64_t v14 = 2;
      }
      else {
        uint64_t v14 = 1;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 2;
  }
  CFStringRef v15 = (const __CFString *)CFDictionaryGetValue(theDict, @"slot");
  CFStringRef v16 = v15;
  if (v15 && (CFTypeID v17 = CFGetTypeID(v15), v17 == CFStringGetTypeID()))
  {
    if (CFStringCompare(v16, @"2", 0))
    {
      if (CFStringCompare(v16, @"two", 0)) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = 2;
      }
    }
    else
    {
      uint64_t v18 = 2;
    }
  }
  else
  {
    uint64_t v18 = 1;
  }
  sub_10072CAF4();
  uint64_t v19 = qword_101B0D5E0;
  if (os_log_type_enabled((os_log_t)qword_101B0D5E0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = subscriber::asString();
    uint64_t v21 = asString();
    uint64_t v22 = asString();
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    __int16 v35 = 2080;
    uint64_t v36 = v22;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I iRatPref: slot %s appType %s linkType %s", buf, 0x20u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*var0);
  uint64_t v24 = ServiceMap;
  if (v25 < 0)
  {
    uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v25;
  xpc_object_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
  if (v29)
  {
    uint64_t v31 = v29[3];
    xpc_object_t v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      if (!v31)
      {
LABEL_39:
        sub_10004D2C8(v30);
        goto LABEL_40;
      }
    }
    else
    {
      std::mutex::unlock(v24);
      if (!v31) {
        goto LABEL_40;
      }
    }
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v31 + 432))(buf, v31);
    if (*(void *)buf)
    {
      if ((v8 | v10) == 1) {
        (*(void (**)(void))(**(void **)buf + 120))();
      }
      if ((v10 | v9) == 1) {
        (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)buf + 120))(*(void *)buf, v18, 1, v14, v14);
      }
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v30) {
      goto LABEL_39;
    }
  }
  else
  {
    std::mutex::unlock(v24);
  }
LABEL_40:
  void *v3 = 0;
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072CFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

CFSharedRef<const __CFDictionary> sub_10072D014(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  int v3 = v2;
  var0 = (uint64_t *)a2->var0.var0;
  var1 = a2->var0.var1;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFStringRef v6 = operator new(0x10uLL);
  *CFStringRef v6 = xmmword_1014E79E0;
  CFStringRef Value = (unsigned int *)CFDictionaryGetValue(theDict, @"imsServiceMask");
  int v8 = Value;
  LODWORD(v30[0]) = 3;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)v30, v8, v10);
    }
  }
  uint64_t v11 = LODWORD(v30[0]);
  CFDictionaryRef v12 = theDict;
  CFDictionaryRef v28 = theDict;
  if (theDict)
  {
    CFRetain(theDict);
    CFDictionaryRef v12 = v28;
  }
  int v13 = sub_10072D2F0(v12);
  sub_100057D78((const void **)&v28);
  sub_100058DB0(&v26, "cc/props/ims_preference_states");
  uint64_t v14 = (std::__shared_weak_count *)var0[1];
  uint64_t v20 = *var0;
  uint64_t v21 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __p[1] = 0;
  *(void *)&long long v23 = 0;
  __p[0] = 0;
  sub_1003FB56C(__p, v6, (uint64_t)(v6 + 1), 4uLL);
  *((void *)&v23 + 1) = v11;
  ptr = var1->fState.__ptr_;
  cntrl = (std::__shared_weak_count *)var1->fState.__cntrl_;
  uint64_t v25 = cntrl;
  if (cntrl) {
    atomic_fetch_add_explicit(&cntrl->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = 0;
  CFStringRef v16 = operator new(0x50uLL);
  *CFStringRef v16 = off_101A00CB8;
  v16[1] = v20;
  void v16[2] = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)v16 + 6) = v13;
  long long v17 = v23;
  *((_OWORD *)v16 + 2) = *(_OWORD *)__p;
  *((_OWORD *)v16 + 3) = v17;
  __p[1] = 0;
  *(void *)&long long v23 = 0;
  __p[0] = 0;
  uint64_t v18 = v25;
  unsigned __int8 v16[8] = ptr;
  v16[9] = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = v16;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(v30);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  void *v3 = 0;
  operator delete(v6);
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072D264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10072D2F0(const __CFDictionary *a1)
{
  CFStringRef Value = (void *)CFDictionaryGetValue(a1, @"simSlot");
  uint64_t result = 1;
  unsigned int v5 = 1;
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v5, (unsigned int *)Value, v4);
      return v5;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void *sub_10072D360(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  CFNumberRef v4 = (std::__shared_weak_count *)a1[1];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

CFSharedRef<const __CFDictionary> sub_10072D3AC(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  var0 = (uint64_t *)a2->var0.var0;
  var1 = a2->var0.var1;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFStringRef Value = (int *)CFDictionaryGetValue(theDict, @"adjusted");
  CFTypeID v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFNumberGetTypeID()) {
      CFTypeID v7 = 0;
    }
  }
  CFTypeID v9 = (int *)CFDictionaryGetValue(theDict, @"actual");
  uint64_t v11 = v9;
  if (v9)
  {
    CFTypeID v12 = CFGetTypeID(v9);
    if (v12 != CFNumberGetTypeID()) {
      uint64_t v11 = 0;
    }
  }
  LODWORD(v29[0]) = -1;
  ctu::cf::assign((ctu::cf *)v29, v7, v10);
  unsigned int v13 = v29[0];
  LODWORD(v29[0]) = -1;
  ctu::cf::assign((ctu::cf *)v29, v11, v14);
  if (v13 + 2 <= 0x14)
  {
    int v15 = v29[0];
    if (SLODWORD(v29[0]) >= -2 && SLODWORD(v29[0]) <= 18)
    {
      CFDictionaryRef v16 = theDict;
      CFDictionaryRef v27 = theDict;
      if (theDict) {
        CFRetain(theDict);
      }
      unsigned int v17 = sub_10072D2F0(v16);
      sub_100057D78((const void **)&v27);
      sub_100058DB0(&__p, "/cc/props/reg_data_modes");
      uint64_t v19 = *var0;
      uint64_t v18 = (std::__shared_weak_count *)var0[1];
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v24 = __PAIR64__(v13, v17);
      ptr = var1->fState.__ptr_;
      cntrl = (std::__shared_weak_count *)var1->fState.__cntrl_;
      if (cntrl) {
        atomic_fetch_add_explicit(&cntrl->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v30 = 0;
      uint64_t v22 = operator new(0x38uLL);
      void *v22 = off_101A00D38;
      v22[1] = v19;
      CFTypeRef v22[2] = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      void v22[3] = v24;
      *((_DWORD *)v22 + 8) = v15;
      v22[5] = ptr;
      void v22[6] = cntrl;
      if (cntrl) {
        atomic_fetch_add_explicit(&cntrl->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v30 = v22;
      ctu::RestModule::getPropertyOnce();
      sub_10003F600(v29);
      if (cntrl) {
        sub_10004D2C8(cntrl);
      }
      if (v18) {
        sub_10004D2C8(v18);
      }
      if (v26 < 0) {
        operator delete(__p);
      }
    }
  }
  void *v3 = 0;
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072D600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10072D674(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

CFSharedRef<const __CFDictionary> sub_10072D6B0(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  var0 = (uint64_t *)a2->var0.var0;
  var1 = a2->var0.var1;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"attached");
  CFBooleanRef v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFBooleanGetTypeID())
    {
      BOOL v9 = v7 == kCFBooleanTrue;
      CFDictionaryRef v10 = theDict;
      CFDictionaryRef v21 = theDict;
      if (theDict) {
        CFRetain(theDict);
      }
      int v11 = sub_10072D2F0(v10);
      sub_100057D78((const void **)&v21);
      sub_100058DB0(&__p, "/cc/props/reg_data_attached");
      uint64_t v13 = *var0;
      CFTypeID v12 = (std::__shared_weak_count *)var0[1];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v18 = v11;
      ptr = var1->fState.__ptr_;
      cntrl = (std::__shared_weak_count *)var1->fState.__cntrl_;
      if (cntrl) {
        atomic_fetch_add_explicit(&cntrl->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v24 = 0;
      CFDictionaryRef v16 = operator new(0x30uLL);
      *CFDictionaryRef v16 = off_101A00DB8;
      v16[1] = v13;
      void v16[2] = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((_DWORD *)v16 + 6) = v18;
      *((unsigned char *)v16 + 28) = v9;
      _OWORD v16[4] = ptr;
      v16[5] = cntrl;
      if (cntrl) {
        atomic_fetch_add_explicit(&cntrl->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v24 = v16;
      ctu::RestModule::getPropertyOnce();
      sub_10003F600(v23);
      if (cntrl) {
        sub_10004D2C8(cntrl);
      }
      if (v12) {
        sub_10004D2C8(v12);
      }
      if (v20 < 0) {
        operator delete(__p);
      }
    }
  }
  void *v3 = 0;
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072D8A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10072D908(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

CFSharedRef<const __CFDictionary> sub_10072D944(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"slot");
  CFNumberRef v5 = Value;
  if (Value && (CFTypeID v6 = CFGetTypeID(Value), v6 == CFNumberGetTypeID()))
  {
    LODWORD(valuePtr[0]) = 0;
    if (CFNumberGetValue(v5, kCFNumberIntType, valuePtr)) {
      int v7 = (int)valuePtr[0];
    }
    else {
      int v7 = 1;
    }
  }
  else
  {
    int v7 = 1;
  }
  CFTypeID v8 = (BOOL *)CFDictionaryGetValue(theDict, @"roaming");
  BOOL v9 = v8;
  LOBYTE(valuePtr[0]) = 0;
  if (v8 && (CFTypeID v10 = CFGetTypeID(v8), v10 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)valuePtr, v9, v11);
    char v12 = LOBYTE(valuePtr[0]) ^ 1;
  }
  else
  {
    char v12 = 1;
  }
  xpc_object_t object = 0;
  int v20 = v7;
  char v21 = v12;
  sub_10021D5C8((uint64_t)valuePtr, &v20, 1);
  sub_100014264(valuePtr, &object);
  sub_1000346F8((uint64_t)valuePtr, (void *)valuePtr[1]);
  sub_100058DB0(&__p, "/cc/props/in_home_countries_definite");
  xpc_object_t v14 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v14);
  if (v16 < 0) {
    operator delete(__p);
  }
  void *v3 = 0;
  xpc_release(object);
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072DB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, xpc_object_t a20,const void *a21)
{
}

CFSharedRef<const __CFDictionary> sub_10072DB90(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"fallback");
  CFBooleanRef v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID()) {
      CFBooleanRef v7 = v5;
    }
    else {
      CFBooleanRef v7 = 0;
    }
  }
  else
  {
    CFBooleanRef v7 = 0;
  }
  if (qword_101B14190 && (CFTypeID v8 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190)) != 0)
  {
    BOOL v9 = v8;
    uint64_t v10 = DataPlanManagerBootstrap::sInstance;
    if (DataPlanManagerBootstrap::sInstance)
    {
      int v11 = CFBooleanGetValue(v7);
      (*(void (**)(uint64_t, BOOL))(*(void *)(v10 + 8) + 288))(v10 + 8, v11 != 0);
    }
    void *v3 = 0;
    sub_10004D2C8(v9);
  }
  else
  {
    void *v3 = 0;
  }
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072DC8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10004D2C8(v2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

CFSharedRef<const __CFDictionary> sub_10072DCB0(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"enterLowPower");
  CFBooleanRef v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      sub_100068A94(&v8);
      if (v5 == kCFBooleanTrue)
      {
        v11[0] = off_101A00E38;
        void v11[3] = v11;
        (*(void (**)(uint64_t, void *))(*(void *)v8 + 24))(v8, v11);
        sub_100060644(v11);
      }
      else
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
  }
  void *v3 = 0;
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072DE0C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  CFNumberRef v4 = va_arg(va1, const void *);
  sub_100060644((uint64_t *)va1);
  if (a3) {
    sub_10004D2C8(a3);
  }
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

CFSharedRef<const __CFDictionary> sub_10072DE4C(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  CFDictionaryRef v27 = 0;
  sub_100058198((const void **)&v27, (const void **)&a2->var0.var2.var0);
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v27, @"acquire");
  CFBooleanRef v5 = Value;
  if (!Value) {
    goto LABEL_25;
  }
  CFTypeID v6 = CFGetTypeID(Value);
  CFTypeID TypeID = (Registry *)CFBooleanGetTypeID();
  if ((Registry *)v6 != TypeID) {
    goto LABEL_25;
  }
  if (v5 != kCFBooleanTrue)
  {
    if (!(void)xmmword_101B0D5F0) {
      goto LABEL_25;
    }
    uint64_t v8 = (std::__shared_weak_count *)*((void *)&xmmword_101B0D5F0 + 1);
    xmmword_101B0D5F0 = 0uLL;
    if (!v8) {
      goto LABEL_25;
    }
LABEL_24:
    sub_10004D2C8(v8);
    goto LABEL_25;
  }
  if ((void)xmmword_101B0D5F0) {
    goto LABEL_25;
  }
  Registry::get((uint64_t *)&v24, TypeID);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    char v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v11;
  int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
  if (!v15)
  {
    uint64_t v17 = 0;
    goto LABEL_15;
  }
  uint64_t v17 = v15[3];
  char v16 = (std::__shared_weak_count *)v15[4];
  if (!v16)
  {
LABEL_15:
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
LABEL_16:
  sub_100058DB0(__p, "DebugXpcServer");
  (*(void (**)(long long *__return_ptr, uint64_t, void **, void))(*(void *)v17 + 48))(&v26, v17, __p, 0);
  long long v19 = v26;
  long long v26 = 0uLL;
  int v20 = (std::__shared_weak_count *)*((void *)&xmmword_101B0D5F0 + 1);
  xmmword_101B0D5F0 = v19;
  if (v20)
  {
    sub_10004D2C8(v20);
    if (*((void *)&v26 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v26 + 1));
    }
  }
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  uint64_t v8 = v25;
  if (v25) {
    goto LABEL_24;
  }
LABEL_25:
  void *v3 = 0;
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&v27);
}

void sub_10072E044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_100057D78((const void **)(v19 - 56));
  _Unwind_Resume(a1);
}

CFSharedRef<const __CFDictionary> sub_10072E0A0(id a1, tuple<const std::shared_ptr<const Registry> &, const ctu::RestModule &, ctu::cf::CFSharedRef<const __CFDictionary>> *a2)
{
  CFTypeID v3 = v2;
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&theDict, (const void **)&a2->var0.var2.var0);
  long long __p = 0;
  long long v24 = 0uLL;
  if (theDict) {
    CFNumberRef v4 = sub_100080778;
  }
  else {
    CFNumberRef v4 = 0;
  }
  if (!v4) {
    goto LABEL_13;
  }
  CFBooleanRef Value = CFDictionaryGetValue(theDict, @"testEmNumber");
  if (Value)
  {
    CFGetTypeID(Value);
    CFStringGetTypeID();
  }
  memset(&v26, 0, sizeof(v26));
  ctu::cf::assign();
  v27[0] = v26.__r_.__value_.__l.__size_;
  CFTypeID v6 = (void *)v26.__r_.__value_.__r.__words[0];
  *(unint64_t *)((char *)v27 + 7) = *(std::string::size_type *)((char *)&v26.__r_.__value_.__r.__words[1] + 7);
  int v7 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p);
  }
  *(void *)((char *)&v24 + 7) = *(unint64_t *)((char *)v27 + 7);
  unint64_t v8 = v27[0];
  long long __p = v6;
  *(void *)&long long v24 = v27[0];
  HIBYTE(v24) = v7;
  if (v7 >= 0) {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    BOOL v9 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&v26, "TestEmergencyNumber");
    uint64_t v10 = (Registry *)sub_1002266A4(v9, &v26, (uint64_t)&__p);
  }
  else
  {
LABEL_13:
    uint64_t v11 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&v26, "TestEmergencyNumber");
    uint64_t v10 = (Registry *)sub_1003660FC(v11, (void **)&v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  Registry::get((uint64_t *)&v26, v10);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v26.__r_.__value_.__l.__data_);
  uint64_t v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  v27[0] = v14;
  char v18 = sub_10004D37C(&v13[1].__m_.__sig, v27);
  if (v18)
  {
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  uint64_t v19 = 0;
  char v21 = 1;
LABEL_24:
  (*(void (**)(uint64_t))(*(void *)v20 + 80))(v20);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  if (v26.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v26.__r_.__value_.__l.__size_);
  }
  void *v3 = 0;
  if (SHIBYTE(v24) < 0) {
    operator delete(__p);
  }
  return (CFSharedRef<const __CFDictionary>)sub_100057D78((const void **)&theDict);
}

void sub_10072E328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100057D78(&a15);
  _Unwind_Resume(a1);
}

void *sub_10072E3B4(void *a1)
{
  *a1 = off_101A00CB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  CFNumberRef v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_10072E41C(void *a1)
{
  *a1 = off_101A00CB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  CFNumberRef v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_10072E4A4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_101A00CB8;
  sub_10072E838((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10072E4F8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10072E50C(uint64_t a1, void *a2)
{
  *a2 = off_101A00CB8;
  return sub_10072E838((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10072E538(uint64_t a1)
{
}

void sub_10072E540(void *a1)
{
  sub_10072E8D4(a1 + 1);

  operator delete(a1);
}

void sub_10072E57C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v11 = *a2;
  *a2 = xpc_null_create();
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v19 = (uint64_t *)v20;
  sub_10072E934((uint64_t)&v19, &v11);
  subscriber::makeSimSlotRange();
  CFNumberRef v4 = (int *)object;
  CFTypeID v3 = v17;
  if (object != v17)
  {
    CFBooleanRef v5 = v18;
    while ((v5(*v4) & 1) == 0)
    {
      if (++v4 == v3)
      {
        CFNumberRef v4 = v3;
        break;
      }
    }
    CFTypeID v6 = v17;
    while (v4 != v6)
    {
      int v15 = 0;
      int v15 = *v4;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v13 = 0;
      sub_1003FB56C(__p, *(const void **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2);
      int v14 = sd::imsServiceMaskFromUint((sd *)*(unsigned int *)(a1 + 56), v7);
      char v21 = &v15;
      unint64_t v8 = sub_10072EFDC(&v19, &v15, (uint64_t)&unk_10144E20E, &v21);
      BOOL v9 = v8[5];
      if (v9)
      {
        void v8[6] = v9;
        operator delete(v9);
        void v8[5] = 0;
        void v8[6] = 0;
        v8[7] = 0;
      }
      *(_OWORD *)(v8 + 5) = *(_OWORD *)__p;
      v8[7] = v13;
      *((_DWORD *)v8 + 16) = v14;
      uint64_t v10 = v4 + 1;
      CFNumberRef v4 = v3;
      if (v10 != v3)
      {
        CFNumberRef v4 = v10;
        while ((v5(*v4) & 1) == 0)
        {
          if (++v4 == v3)
          {
            CFNumberRef v4 = v3;
            break;
          }
        }
      }
    }
  }
  sub_100058DB0(__p, "cc/props/ims_preference_states");
  sub_10072EBE0(&v19, &object);
  ctu::RestModule::setProperty();
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  sub_10026CF54((uint64_t)&v19, v20[0]);
  xpc_release(v11);
}

void sub_10072E76C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object,uint64_t a21,uint64_t a22,char a23,void *a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10026CF54((uint64_t)&a23, a24);
  xpc_release(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10072E7EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00D18)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072E82C()
{
  return &off_101A00D18;
}

uint64_t sub_10072E838(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_100720EB4((uint64_t)&a9, 0) = 0;
  sub_1003FB56C((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 2);
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v6;
  uint64_t v7 = *(void *)(a2 + 64);
  *(void *)(a1 + 64) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10072E8BC(_Unwind_Exception *exception_object)
{
  CFTypeID v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10072E8D4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFTypeID v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_10072E934(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10026CF54(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v12, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v11, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v13; i != v11[1] || v12 != v11[0]; uint64_t i = ++v13)
    {
      xpc_object_t v10 = 0;
      object[0] = &v12;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v10);
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v9 = 0;
        *(_OWORD *)xpc_object_t object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v10;
        if (v10) {
          xpc_retain(v10);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10072ED4C((int *)object, &v6);
        xpc_release(v6);
        sub_10072EF00((uint64_t **)a1, (int *)object, (uint64_t)object);
        if (object[1])
        {
          *(xpc_object_t *)&long long v8 = object[1];
          operator delete(object[1]);
        }
      }
      xpc_release(v10);
    }
    xpc_release(v12);
    xpc_release(v12);
  }
  xpc_release(v3);
}

void sub_10072EB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, xpc_object_t a17)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v18 - 48));
  xpc_release(v17);
  _Unwind_Resume(a1);
}

void sub_10072EBE0(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  long long v8 = (int *)*a1;
  xpc_object_t v6 = (int *)(a1 + 1);
  uint64_t v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_10072F0A8(v7 + 8, &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      uint64_t v9 = (int *)*((void *)v7 + 1);
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          uint64_t v9 = *(int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (int *)*((void *)v7 + 2);
          BOOL v11 = *(void *)v10 == (void)v7;
          uint64_t v7 = v10;
        }
        while (!v11);
      }
      uint64_t v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_10072ED20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_10072ED4C(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_10072EEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t **sub_10072EF00(uint64_t **a1, int *a2, uint64_t a3)
{
  xpc_object_t v6 = a1 + 1;
  xpc_object_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        xpc_object_t v5 = *v8;
        xpc_object_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      xpc_object_t v5 = v8[1];
      if (!v5)
      {
        xpc_object_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    int v10 = (char *)operator new(0x48uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 4sub_100720EB4((uint64_t)&a9, 0) = *(_OWORD *)(a3 + 8);
    *((void *)v10 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *((_DWORD *)v10 + 16) = *(_DWORD *)(a3 + 32);
    sub_100046C38(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t **sub_10072EFDC(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  xpc_object_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        xpc_object_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      xpc_object_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    BOOL v11 = (char *)operator new(0x48uLL);
    *((_DWORD *)v11 + 8) = **a4;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 4sub_100720EB4((uint64_t)&a9, 0) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void sub_10072F0A8(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v15, (ctu::rest::detail *)v7, v8, v9);
  uint64_t v13 = &v17;
  int v14 = "first";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  rest::write_rest_value();
  uint64_t v13 = &v17;
  int v14 = "second";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_10072F230(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void *sub_10072F248(void *a1)
{
  *a1 = off_101A00D38;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10072F2A0(void *a1)
{
  *a1 = off_101A00D38;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_10072F318(uint64_t a1)
{
  uint64_t result = operator new(0x38uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_101A00D38;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = *(void *)(a1 + 24);
  *((_DWORD *)result + 8) = *(_DWORD *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  result[5] = *(void *)(a1 + 40);
  result[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10072F39C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A00D38;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(result + 32);
  *(void *)(a2 + 24) = v4;
  uint64_t v5 = *(void *)(result + 48);
  *(void *)(a2 + 4sub_100720EB4((uint64_t)&a9, 0) = *(void *)(result + 40);
  *(void *)(a2 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10072F3FC(uint64_t a1)
{
}

void sub_10072F404(void *a1)
{
  sub_10072F68C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10072F440(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v9 = *a2;
  *a2 = xpc_null_create();
  v15[0] = 0;
  v15[1] = 0;
  int v14 = (uint64_t *)v15;
  sub_10025697C((uint64_t)&v14, &v9);
  subscriber::makeSimSlotRange();
  uint64_t v4 = (int *)__p;
  uint64_t v3 = v12;
  if (__p != v12)
  {
    uint64_t v5 = v13;
    while ((v5(*v4) & 1) == 0)
    {
      if (++v4 == v3)
      {
        uint64_t v4 = v3;
        break;
      }
    }
    xpc_object_t v6 = v12;
    while (v4 != v6)
    {
      int v10 = 0;
      int v10 = *v4;
      int v7 = *(uint64_t **)(a1 + 28);
      xpc_object_t object = &v10;
      sub_10072F848(&v14, &v10, (uint64_t)&unk_10144E20E, (_DWORD **)&object)[4] = v7;
      uint64_t v8 = v4 + 1;
      uint64_t v4 = v3;
      if (v8 != v3)
      {
        uint64_t v4 = v8;
        while ((v5(*v4) & 1) == 0)
        {
          if (++v4 == v3)
          {
            uint64_t v4 = v3;
            break;
          }
        }
      }
    }
  }
  sub_100058DB0(&__p, "/cc/props/reg_data_modes");
  sub_10072F6DC(&v14, &object);
  ctu::RestModule::setProperty();
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&v14, v15[0]);
  xpc_release(v9);
}

void sub_10072F5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, uint64_t a20,xpc_object_t object)
{
  xpc_object_t object = 0;
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&a17, a18);
  xpc_release(a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10072F640(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00D98)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072F680()
{
  return &off_101A00D98;
}

void sub_10072F68C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_10072F6DC(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v8 = (int *)*a1;
  xpc_object_t v6 = (int *)(a1 + 1);
  int v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_10072F910(v7 + 7, &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      xpc_object_t v9 = (int *)*((void *)v7 + 1);
      if (v9)
      {
        do
        {
          int v10 = v9;
          xpc_object_t v9 = *(int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (int *)*((void *)v7 + 2);
          BOOL v11 = *(void *)v10 == (void)v7;
          int v7 = v10;
        }
        while (!v11);
      }
      int v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_10072F81C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

uint64_t **sub_10072F848(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  xpc_object_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        xpc_object_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        xpc_object_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      xpc_object_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    xpc_object_t v9 = a1 + 1;
LABEL_10:
    BOOL v11 = operator new(0x28uLL);
    void v11[7] = **a4;
    *((void *)v11 + 4) = -1;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void sub_10072F910(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v15, (ctu::rest::detail *)v7, v8, v9);
  uint64_t v13 = &v17;
  int v14 = "first";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  rest::write_rest_value();
  uint64_t v13 = &v17;
  int v14 = "second";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_10072FA98(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void *sub_10072FAB0(void *a1)
{
  *a1 = off_101A00DB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10072FB08(void *a1)
{
  *a1 = off_101A00DB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_10072FB80(uint64_t a1)
{
  uint64_t result = operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_101A00DB8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 6) = *(_DWORD *)(a1 + 24);
  *((unsigned char *)result + 28) = *(unsigned char *)(a1 + 28);
  uint64_t v5 = *(void *)(a1 + 40);
  result[4] = *(void *)(a1 + 32);
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10072FC04(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A00DB8;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = *(_DWORD *)(result + 24);
  *(unsigned char *)(a2 + 28) = *(unsigned char *)(result + 28);
  *(_DWORD *)(a2 + 24) = v4;
  uint64_t v5 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_100720EB4((uint64_t)&a9, 0) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10072FC64(uint64_t a1)
{
}

void sub_10072FC6C(void *a1)
{
  sub_10072FEEC((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10072FCA8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v9 = *a2;
  *a2 = xpc_null_create();
  v15[0] = 0;
  v15[1] = 0;
  int v14 = (uint64_t *)v15;
  sub_10003447C((uint64_t)&v14, &v9);
  subscriber::makeSimSlotRange();
  int v4 = (int *)__p;
  uint64_t v3 = v12;
  if (__p != v12)
  {
    uint64_t v5 = v13;
    while ((v5(*v4) & 1) == 0)
    {
      if (++v4 == v3)
      {
        int v4 = v3;
        break;
      }
    }
    xpc_object_t v6 = v12;
    while (v4 != v6)
    {
      int v10 = 0;
      int v10 = *v4;
      char v7 = *(unsigned char *)(a1 + 28);
      xpc_object_t object = &v10;
      *((unsigned char *)sub_10005CE78(&v14, &v10, (uint64_t)&unk_10144E20E, (_DWORD **)&object) + 32) = v7;
      uint64_t v8 = v4 + 1;
      int v4 = v3;
      if (v8 != v3)
      {
        int v4 = v8;
        while ((v5(*v4) & 1) == 0)
        {
          if (++v4 == v3)
          {
            int v4 = v3;
            break;
          }
        }
      }
    }
  }
  sub_100058DB0(&__p, "/cc/props/reg_data_attached");
  sub_100014264(&v14, &object);
  ctu::RestModule::setProperty();
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&v14, v15[0]);
  xpc_release(v9);
}

void sub_10072FE38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, uint64_t a20,xpc_object_t object)
{
  xpc_object_t object = 0;
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&a17, a18);
  xpc_release(a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10072FEA0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00E18)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072FEE0()
{
  return &off_101A00E18;
}

void sub_10072FEEC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_10072FF40()
{
}

void *sub_10072FF54()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_101A00E38;
  return result;
}

void sub_10072FF8C(uint64_t a1, void *a2)
{
  *a2 = off_101A00E38;
}

uint64_t sub_10072FFB8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A00E98)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10072FFF8()
{
  return &off_101A00E98;
}

uint64_t **sub_100730004(uint64_t **a1, long long *a2, uint64_t a3)
{
  a1[1] = 0;
  int v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    xpc_object_t v6 = &a2[2 * a3];
    while (1)
    {
      char v7 = a1[1];
      if (*a1 == v4) {
        break;
      }
      uint64_t v8 = v4;
      if (v7)
      {
        do
        {
          xpc_object_t v9 = v7;
          char v7 = (uint64_t *)v7[1];
        }
        while (v7);
      }
      else
      {
        do
        {
          xpc_object_t v9 = (uint64_t *)v8[2];
          BOOL v10 = *v9 == (void)v8;
          uint64_t v8 = v9;
        }
        while (v10);
      }
      char v11 = sub_100046FE8(v9 + 4, (void **)v5);
      char v7 = (uint64_t *)*v4;
      if (v11 < 0) {
        goto LABEL_18;
      }
      xpc_object_t v12 = (uint64_t **)v4;
      uint64_t v13 = (uint64_t **)v4;
      if (v7)
      {
        uint64_t v13 = (uint64_t **)v4;
        do
        {
          while (1)
          {
            xpc_object_t v12 = (uint64_t **)v7;
            int v14 = v7 + 4;
            if ((sub_100046FE8(v5, (void **)v7 + 4) & 0x80) == 0) {
              break;
            }
            char v7 = *v12;
            uint64_t v13 = v12;
            if (!*v12) {
              goto LABEL_21;
            }
          }
          if ((sub_100046FE8(v14, (void **)v5) & 0x80) == 0) {
            goto LABEL_20;
          }
          uint64_t v13 = v12 + 1;
          char v7 = v12[1];
        }
        while (v7);
      }
LABEL_21:
      xpc_object_t v15 = (uint64_t *)operator new(0x40uLL);
      uint64_t v16 = v15 + 4;
      if (*((char *)v5 + 23) < 0)
      {
        sub_10004FC84(v16, *(void **)v5, *((void *)v5 + 1));
      }
      else
      {
        long long v17 = *v5;
        v15[6] = *((void *)v5 + 2);
        *(_OWORD *)uint64_t v16 = v17;
      }
      v15[7] = *((void *)v5 + 3);
      *xpc_object_t v15 = 0;
      v15[1] = 0;
      void v15[2] = (uint64_t)v12;
      *uint64_t v13 = v15;
      uint64_t v18 = (uint64_t *)**a1;
      if (v18)
      {
        *a1 = v18;
        xpc_object_t v15 = *v13;
      }
      sub_100046C90(a1[1], v15);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
LABEL_27:
      v5 += 2;
      if (v5 == v6) {
        return a1;
      }
    }
    xpc_object_t v9 = v4;
LABEL_18:
    xpc_object_t v12 = (uint64_t **)v4;
    uint64_t v13 = (uint64_t **)v4;
    if (v7)
    {
      uint64_t v13 = (uint64_t **)(v9 + 1);
      xpc_object_t v12 = (uint64_t **)v9;
LABEL_20:
      if (*v13) {
        goto LABEL_27;
      }
    }
    goto LABEL_21;
  }
  return a1;
}

void sub_1007301A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  sub_1000DA2E4(*v2);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1007301C4(int a1)
{
  LODWORD(v31) = a1;
  int v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  sub_10004DE24((uint64_t)&v39);
  uint64_t v2 = (void *)subscriber::operator<<();
  uint64_t v3 = sub_10004B96C(v2, (uint64_t)", ", 2);
  int v4 = (const char *)subscriber::asString();
  size_t v5 = strlen(v4);
  sub_10004B96C(v3, (uint64_t)v4, v5);
  sub_10004BC98((uint64_t)&v39 + 8, __p);
  sub_1001AA668(&event::subscriber::sim_refresh[3], (uint64_t *)__p);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(*((void **)&v43 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  xpc_object_t v6 = (uint64_t *)sub_1007307EC(&event::subscriber::sim_refresh[1]);
  int v35 = 3;
  int v36 = a1;
  long long v34 = 0uLL;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  char v7 = (pthread_mutex_t *)sub_100060E64(v6 + 3);
  sub_100061F70(&v39, v7);
  uint64_t v8 = v6[1];
  if (v8)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v8 + 8), memory_order_acquire) == 1) {
      sub_100730830(v6, &v39, 0, 1);
    }
    uint64_t v9 = *v6;
    uint64_t v10 = v6[1];
    if (v10) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = *v6;
  }
  long long v11 = v34;
  *(void *)&long long v34 = v9;
  *((void *)&v34 + 1) = v10;
  *(_OWORD *)long long __p = v11;
  sub_10000A740((atomic_uint **)&__p[1]);
  sub_10000A6C8(*((pthread_mutex_t **)&v50 + 1));
  sub_10000A5F8(&v39);
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  *(void *)&long long v54 = 0;
  *((void *)&v54 + 1) = 10;
  int v55 = (char *)&v39 + 8;
  uint64_t v56 = 0;
  long long v57 = &v36;
  long long v58 = &v35;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  xpc_object_t v12 = (uint64_t *)sub_1007308E4((uint64_t *)&v34);
  v33[0] = &v39;
  v33[1] = v6;
  v33[2] = sub_100730B54(v12);
  uint64_t v13 = sub_1007308E4((uint64_t *)&v34);
  sub_100060EA8((uint64_t *)(v13 + 16));
  int v14 = (uint64_t *)sub_1007308E4((uint64_t *)&v34);
  uint64_t v15 = *(void *)(sub_100730B54(v14) + 8);
  uint64_t v16 = (uint64_t *)sub_1007308E4((uint64_t *)&v34);
  *(void *)&long long v31 = v15;
  *((void *)&v31 + 1) = sub_100730B54(v16);
  *(void *)&long long v32 = &v39;
  *((void *)&v32 + 1) = *((void *)&v31 + 1);
  sub_100730C30((uint64_t *)&v31);
  long long v17 = (uint64_t *)sub_1007308E4((uint64_t *)&v34);
  uint64_t v18 = sub_100730B54(v17);
  uint64_t v19 = (uint64_t *)sub_1007308E4((uint64_t *)&v34);
  CFDictionaryRef v27 = (void *)v18;
  uint64_t v28 = sub_100730B54(v19);
  xpc_object_t v29 = &v39;
  uint64_t v30 = v28;
  sub_100730C30((uint64_t *)&v27);
  *(_OWORD *)long long __p = v31;
  long long v38 = v32;
  uint64_t v20 = v27;
  char v21 = (uint64_t *)v31;
  if ((void *)v31 != v27)
  {
    uint64_t v22 = (unsigned char *)v38;
    BOOL v23 = *(unsigned char *)v38 == 0;
    do
    {
      if (v23)
      {
        uint64_t v24 = sub_100730A64(v21 + 2);
        uint64_t v25 = sub_100730B10((uint64_t *)(v24 + 32));
        sub_100730B98((void *)(v25 + 24));
        if (!*v22) {
          unsigned char *v22 = 1;
        }
      }
      if (!*(unsigned char *)v38) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      __p[0] = *((void **)__p[0] + 1);
      sub_100730C30((uint64_t *)__p);
      uint64_t v22 = (unsigned char *)v38;
      if (*(unsigned char *)v38) {
        *(unsigned char *)long long v38 = 0;
      }
      char v21 = (uint64_t *)__p[0];
      BOOL v23 = 1;
    }
    while (__p[0] != v20);
  }
  sub_100730FAC(v33);
  sub_100731868((uint64_t)&v39);
  return sub_10000A740((atomic_uint **)&v34 + 1);
}

void sub_100730690(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x1007307E4);
}

void sub_1007306C8()
{
}

void sub_1007306D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void (__cdecl **a32)(std::stringbuf *__hidden this),uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  _Unwind_Resume(v45);
}

uint64_t sub_1007307EC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_100730830(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_1007308E4(a1);
  uint64_t v10 = sub_100730B54(v9);
  long long v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    xpc_object_t v12 = (uint64_t *)sub_1007308E4(a1);
    long long v11 = *(uint64_t **)(sub_100730B54(v12) + 8);
  }
  int v14 = v11;
  return sub_100730928(a1, a2, a3, &v14, a4);
}

uint64_t sub_1007308E4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100730928(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_1007308E4(a1);
  uint64_t result = (uint64_t *)sub_100730B54(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100730A64(result + 2);
        sub_100730AA8(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100730A64(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_1007308E4(a1);
        uint64_t v17 = sub_100730B54(v16);
        uint64_t v18 = sub_100730A64(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      uint64_t v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_1007308E4(a1);
      uint64_t v20 = (uint64_t *)sub_100730B54(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100730A64(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100730AA8(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    xpc_object_t v6 = (uint64_t *)sub_100730B10(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100730B10(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100730B54(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100730B98(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100730C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100730C30(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100730F6C(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100730A64((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        uint64_t v8 = *(_DWORD **)sub_100730B10((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_100730B10(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_100730B10(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100730A64((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100730A64((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100730F6C(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100730F14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100730F6C(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100730FAC(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_1007308E4(v2);
    if (sub_100730B54(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_1007308E4(v2);
      uint64_t v9 = *(uint64_t **)(sub_100730B54(v7) + 8);
      sub_100730928(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100731118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100731174(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100731234(&v2, a2);
}

uint64_t sub_1007311F0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100731234(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1007312A0(&v2);
}

void sub_10073128C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1007312A0(void *a1)
{
  *a1 = 0;
  operator new();
}