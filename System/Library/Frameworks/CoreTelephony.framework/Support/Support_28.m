void sub_100F55EC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a32) {
    sub_10004D2C8(a32);
  }
  operator delete();
}

uint64_t sub_100F560D0(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = a2;
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t sub_100F56128(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = a2;
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t sub_100F56180(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_100F561D0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Resetting Enable 3G/LTE switch preferences as network settings have been reset", buf, 2u);
  }
  if (capabilities::ct::supportsBB2GMitigation((capabilities::ct *)v4))
  {
    int v5 = sub_100529568();
    int v6 = *(_DWORD *)(*(void *)(v2 + 456) + 136);
    if (v5)
    {
      if (v6 != 2) {
        goto LABEL_12;
      }
      v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I 2G was enabled when in lockedown, resetting the preference", buf, 2u);
      }
    }
    else
    {
      if (v6 != 3) {
        goto LABEL_12;
      }
      v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "2G was disabled when not in lockedown, resetting the preference", buf, 2u);
      }
    }
    sub_100F4C574(v2, v5 ^ 1, 1);
  }
LABEL_12:
  v9 = *(void **)(v2 + 432);
  if (v9 != (void *)(v2 + 440))
  {
    do
    {
      v10 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v9 + 8));
      v11 = v10;
      v12 = (_DWORD *)v9[5];
      if (v12[154] == 3)
      {
        v13 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I 3G was disabled, resetting the preference", buf, 2u);
        }
        sub_100F45FFC(v2, *((unsigned int *)v9 + 8), 2, 1);
        v12 = (_DWORD *)v9[5];
      }
      if (v12[124] == 3)
      {
        v14 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I LTE was disabled, resetting the preference", buf, 2u);
        }
        sub_100F45FFC(v2, *((unsigned int *)v9 + 8), 3, 1);
        v12 = (_DWORD *)v9[5];
      }
      if (v12[94] == 3)
      {
        v15 = *v11;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I 5G was disabled, resetting the preference", buf, 2u);
        }
        sub_100F45FFC(v2, *((unsigned int *)v9 + 8), 4, 1);
      }
      v16 = (void *)v9[1];
      if (v16)
      {
        do
        {
          v17 = v16;
          v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v17 = (void *)v9[2];
          BOOL v18 = *v17 == (void)v9;
          v9 = v17;
        }
        while (!v18);
      }
      v9 = v17;
    }
    while (v17 != (void *)(v2 + 440));
  }
  sub_100088C88(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100F564C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100F564E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100F56568(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v46 = a1;
  uint64_t v47 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 56));
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v7;
  v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_26;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13) {
    goto LABEL_26;
  }
LABEL_10:
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13) & 1) == 0)
  {
    v16 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(v2 + 56));
    v17 = v16;
    if (v18 < 0)
    {
      v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(v16);
    *(void *)buf = v18;
    v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
    if (v22)
    {
      uint64_t v24 = v22[3];
      v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        if (!v24)
        {
LABEL_25:
          sub_10004D2C8(v23);
          goto LABEL_26;
        }
      }
      else
      {
        std::mutex::unlock(v17);
        if (!v24) {
          goto LABEL_26;
        }
      }
      *(void *)v48 = 0;
      v49 = 0;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v24 + 8))(v48, v24, *(unsigned int *)(v1 + 8));
      if (*(void *)v48
        && ((*(uint64_t (**)(void, uint64_t))(**(void **)v48 + 72))(*(void *)v48, 2) & 1) == 0)
      {
        v36 = *v3;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#N Current operator does not allow switching data rate", buf, 2u);
        }
        *(void *)buf = 0;
        v52 = 0;
        uint64_t v53 = 0;
        uint64_t v37 = *(void *)(v1 + 40);
        if (!v37) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v37 + 48))(v37, buf);
        if (*(void *)buf)
        {
          v52 = *(char **)buf;
          operator delete(*(void **)buf);
        }
        if (v49) {
          sub_10004D2C8(v49);
        }
        if (v23) {
          sub_10004D2C8(v23);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_81;
      }
      if (v49) {
        sub_10004D2C8(v49);
      }
      if (v23) {
        goto LABEL_25;
      }
    }
    else
    {
      std::mutex::unlock(v17);
    }
  }
LABEL_26:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  *(void *)buf = 0;
  v52 = 0;
  uint64_t v53 = 0;
  sub_100F4A7A8((int **)buf, v2, *(unsigned int *)(v1 + 8));
  uint64_t v25 = *(void *)(v2 + 248);
  if (v25)
  {
    uint64_t v26 = *(unsigned int *)(v1 + 8);
    uint64_t v27 = v2 + 248;
    do
    {
      int v28 = *(_DWORD *)(v25 + 28);
      BOOL v29 = v28 < (int)v26;
      if (v28 >= (int)v26) {
        v30 = (uint64_t *)v25;
      }
      else {
        v30 = (uint64_t *)(v25 + 8);
      }
      if (!v29) {
        uint64_t v27 = v25;
      }
      uint64_t v25 = *v30;
    }
    while (*v30);
    if (v27 != v2 + 248 && *(_DWORD *)(v27 + 28) <= (int)v26)
    {
      BOOL v31 = *(unsigned __int16 *)(v27 + 32) >= 0x100u && *(_WORD *)(v27 + 32) == 0;
      if (v31 && sub_100F49D10(v2, v26) - 1 >= 2)
      {
        v33 = *(char **)buf;
        v32 = v52;
        if (*(char **)buf == v52)
        {
LABEL_48:
          v35 = &v52[-*(void *)buf];
        }
        else
        {
          v34 = *(char **)buf;
          while ((*(_DWORD *)v34 - 1) >= 2)
          {
            v34 += 4;
            if (v34 == v52) {
              goto LABEL_48;
            }
          }
          if (v34 != v52)
          {
            for (i = v34 + 4; i != v32; i += 4)
            {
              if ((*(_DWORD *)i - 1) >= 2)
              {
                *(_DWORD *)v34 = *(_DWORD *)i;
                v34 += 4;
              }
            }
          }
          if (v32 != v34) {
            v52 = v34;
          }
          v35 = (char *)(v34 - v33);
        }
        if ((char *)(v32 - v33) != v35)
        {
          v39 = *v3;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v48 = 0;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#N 2G/3G data rates removed due to no CS voice support", v48, 2u);
          }
        }
      }
    }
  }
  *(void *)v48 = 0;
  v49 = 0;
  v50 = 0;
  v40 = *(char **)buf;
  int64_t v41 = (int64_t)&v52[-*(void *)buf];
  if (v52 != *(char **)buf)
  {
    if (v41 < 0) {
      sub_10006A748();
    }
    v42 = (char *)operator new((size_t)&v52[-*(void *)buf]);
    v43 = (std::__shared_weak_count *)&v42[4 * (v41 >> 2)];
    *(void *)v48 = v42;
    v50 = v43;
    memmove(v42, v40, v41);
    v49 = v43;
  }
  uint64_t v44 = *(void *)(v1 + 40);
  if (!v44) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v44 + 48))(v44, v48);
  if (*(void *)v48)
  {
    v49 = *(std::__shared_weak_count **)v48;
    operator delete(*(void **)v48);
  }
  if (v40) {
    operator delete(v40);
  }
LABEL_81:
  sub_100F56B68(&v47);
  return sub_100046B58((uint64_t *)&v46);
}

void sub_100F56AA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a12)
  {
    sub_10004D2C8(a12);
    if (!v17)
    {
LABEL_5:
      if (v18)
      {
LABEL_10:
        sub_100F56B68(&a10);
        sub_100046B58(&a9);
        _Unwind_Resume(a1);
      }
LABEL_9:
      sub_10004D2C8(v16);
      goto LABEL_10;
    }
  }
  else if (!v17)
  {
    goto LABEL_5;
  }
  sub_10004D2C8(v17);
  if (v18) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

uint64_t *sub_100F56B68(uint64_t *result)
{
  uint64_t v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1002BCD40((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100F56BB8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void sub_100F56C04(float *a1, int a2, int a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = v5;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_10006A7CC();
          }
          v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            int v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  void *v22 = *v28;
                  *int v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  int v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                v22 = v28;
                int v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  v30 = *(void **)a1;
  BOOL v31 = *(void **)(*(void *)a1 + 8 * v8);
  if (v31)
  {
    void *v12 = *v31;
LABEL_72:
    *BOOL v31 = v12;
    goto LABEL_73;
  }
  void *v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v30[v8] = a1 + 4;
  if (*v12)
  {
    unint64_t v32 = *(void *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v32 >= v6) {
        v32 %= v6;
      }
    }
    else
    {
      v32 &= v6 - 1;
    }
    BOOL v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void sub_100F56FD8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F56FEC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100F5706C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  int v2 = sub_100F49D10(*(void *)v1, *(unsigned int *)(v1 + 8));
  sub_1003DFC04(v1 + 16, v2);
  sub_100F570DC(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100F570C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F570DC(uint64_t *result)
{
  uint64_t v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_1004C6D38((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100F5712C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100F571AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  uint64_t v4 = *(unsigned int *)(v1 + 8);
  int v5 = *(_DWORD *)(v1 + 12);
  long long buf = 0uLL;
  uint64_t v20 = 0;
  sub_100F4A7A8((int **)&buf, v2, v4);
  unint64_t v6 = (_DWORD *)*((void *)&buf + 1);
  uint8x8_t v7 = (_DWORD *)buf;
  if ((void)buf != *((void *)&buf + 1))
  {
    uint8x8_t v7 = (_DWORD *)buf;
    while (*v7 != v5)
    {
      if (++v7 == *((_DWORD **)&buf + 1))
      {
        uint8x8_t v7 = (_DWORD *)*((void *)&buf + 1);
        break;
      }
    }
  }
  if ((void)buf) {
    operator delete((void *)buf);
  }
  if (v7 == v6)
  {
    v12 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Provided data rate %s is not valid", (uint8_t *)&buf, 0xCu);
    }
    if (!*(void *)(v1 + 40)) {
      goto LABEL_22;
    }
    uint64_t v14 = 22;
    goto LABEL_20;
  }
  int v8 = sub_100F49D10(v2, *(unsigned int *)(v1 + 8));
  int v9 = *(_DWORD *)(v1 + 12);
  if (v8 != v9)
  {
    if (sub_100F45FFC(v2, *(unsigned int *)(v1 + 8), v9, 1)) {
      goto LABEL_17;
    }
    uint64_t v14 = 35;
LABEL_20:
    BOOL v15 = std::generic_category();
    goto LABEL_21;
  }
  unsigned int v10 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Provided data rate %s is already one the device has been set to, bailing out", (uint8_t *)&buf, 0xCu);
  }
LABEL_17:
  if (*(void *)(v1 + 40))
  {
    BOOL v15 = std::generic_category();
    uint64_t v14 = 0;
LABEL_21:
    sub_1003DFBA4(v1 + 16, v14, (uint64_t)v15);
  }
LABEL_22:
  sub_100F573E0(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_100F573C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F573E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *result = 0;
  if (v1)
  {
    sub_100449214((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100F57430(const void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  (*((void (**)(const void *, void))*v1 + 2))(*v1, *((unsigned __int8 *)v1 + 8));
  sub_100F5749C(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100F57480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
}

const void ***sub_100F5749C(const void ***result)
{
  uint64_t v1 = *result;
  *result = 0;
  if (v1)
  {
    if (*v1) {
      _Block_release(*v1);
    }
    operator delete();
  }
  return result;
}

void sub_100F574F8()
{
}

__n128 sub_100F5750C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A730B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F57558(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A730B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F57588(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)(a1 + 8), *(Registry **)(*(void *)(a1 + 8) + 56));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, void))(*(void *)v10 + 344))(v10, *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 20));
  (*(void (**)(uint64_t, void, void))(*(void *)v10 + 352))(v10, *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 20));
  (*(void (**)(uint64_t, void, void))(*(void *)v10 + 360))(v10, *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 20));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100F57714(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F5772C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5776C()
{
}

uint64_t sub_100F57778(capabilities::ct *a1)
{
  uint64_t v1 = **((void **)a1 + 5);
  uint64_t result = capabilities::ct::supportsBB2GMitigation(a1);
  if (result) {
    return *(unsigned __int8 *)(*(void *)(v1 + 456) + 16) == 2;
  }
  return result;
}

uint64_t sub_100F577B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100F57834(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v7 = 0;
  int v8 = 0;
  MaxDataRateManager::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v7);
  uint64_t v3 = v7;
  if (v7) {
    sub_1003DFC70(v1 + 16, *(_DWORD *)(v7 + 376));
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (!v3) {
    sub_1003DFC70(v1 + 16, 0);
  }
  sub_100F578E4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F578B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F578E4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1004CACEC((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100F57934(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v7 = 0;
  int v8 = 0;
  MaxDataRateManager::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v7);
  uint64_t v3 = v7;
  if (v7) {
    sub_1003DFC70(v1 + 16, *(_DWORD *)(v7 + 496));
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (!v3) {
    sub_1003DFC70(v1 + 16, 0);
  }
  sub_100F578E4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F579B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F579E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v7 = 0;
  int v8 = 0;
  MaxDataRateManager::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v7);
  uint64_t v3 = v7;
  if (v7) {
    sub_1003DFC70(v1 + 16, *(_DWORD *)(v7 + 616));
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (!v3) {
    sub_1003DFC70(v1 + 16, 0);
  }
  sub_100F578E4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F57A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F57A94(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v4 = *a1;
  if (*(void *)(*(void *)v4 + 472)) {
    int v1 = 2;
  }
  else {
    int v1 = *(_DWORD *)(*(void *)(*(void *)v4 + 456) + 136);
  }
  sub_1003DFC70(v4 + 8, v1);
  sub_100F57B10(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100F57AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F57B10(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1004CACEC((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100F57B60(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  if ((capabilities::ct::supportsBB2GMitigation(a1) & 1) == 0)
  {
    if (!*(void *)(v1 + 40)) {
      goto LABEL_13;
    }
    uint64_t v4 = 102;
    goto LABEL_11;
  }
  if (*(unsigned char *)(*(void *)(v2 + 456) + 16) != 2)
  {
    int v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Setting 2G user preference was tried when the switch was not enabled", buf, 2u);
    }
    if (!*(void *)(v1 + 40)) {
      goto LABEL_13;
    }
    uint64_t v4 = 1;
LABEL_11:
    uint64_t v3 = std::generic_category();
    goto LABEL_12;
  }
  sub_100F4C574(v2, *(unsigned __int8 *)(v1 + 8), 1);
  if (*(void *)(v1 + 40))
  {
    uint64_t v3 = std::generic_category();
    uint64_t v4 = 0;
LABEL_12:
    sub_1003DFBA4(v1 + 16, v4, (uint64_t)v3);
  }
LABEL_13:
  sub_100F57C6C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100F57C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F57C6C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100449214((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100F57CBC(capabilities::ct *a1)
{
  uint64_t v1 = *(uint64_t **)a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *v1;
  if (capabilities::ct::supportsBB2GMitigation(a1) & 1) != 0 && (sub_100529568())
  {
    uint64_t v3 = v1[1];
    if (v3 < 1)
    {
      uint64_t v17 = *(void *)(v2 + 472);
      if (v17)
      {
        *(void *)(v2 + 472) = 0;
        uint64_t v18 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v17 + 8))(v17);
        if (capabilities::ct::supportsBB2GMitigation(v18))
        {
          uint64_t v19 = *(void *)(v2 + 456);
          if (*(unsigned char *)(v19 + 16) == 2 && *(_DWORD *)(v19 + 136) != 2) {
            sub_100F4C574(v2, 0, 2);
          }
        }
      }
    }
    else
    {
      uint64_t v4 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v3;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Temporary 2G enablement requested for %lld seconds", (uint8_t *)&buf, 0xCu);
      }
      sub_100F4C574(v2, 1, 2);
      int v5 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v5 || (uint64_t v6 = *(void *)(v2 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      Registry::getTimerService(&v26, *(Registry **)(v2 + 56));
      uint64_t v9 = v26;
      sub_100058DB0(__p, "2G temporary enablement");
      uint64_t v10 = v1[1];
      char v11 = *(NSObject **)(v2 + 24);
      dispatch_object_t object = v11;
      if (v11) {
        dispatch_retain(v11);
      }
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 1174405120;
      v30 = sub_100F580C0;
      BOOL v31 = &unk_101A73188;
      uint64_t v32 = v2;
      uint64_t v33 = v6;
      v34 = v8;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v35 = v2;
      aBlock = _Block_copy(&buf);
      sub_100118A44(v9, (uint64_t)__p, 2, 1000000 * v10, &object, &aBlock);
      uint64_t v12 = v28;
      uint64_t v28 = 0;
      uint64_t v13 = *(void *)(v2 + 472);
      *(void *)(v2 + 472) = v12;
      if (v13)
      {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        uint64_t v14 = v28;
        uint64_t v28 = 0;
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      if (v27) {
        sub_10004D2C8(v27);
      }
      if (v34) {
        std::__shared_weak_count::__release_weak(v34);
      }
      std::__shared_weak_count::__release_weak(v8);
    }
    if (v1[5])
    {
      char v15 = 1;
LABEL_28:
      sub_1000607A8((uint64_t)(v1 + 2), v15);
    }
  }
  else if (v1[5])
  {
    char v15 = 0;
    goto LABEL_28;
  }
  sub_100F58070((uint64_t *)&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100F57FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F58070(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100F580C0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Temporary 2G enablement timer fired", v10, 2u);
        }
        uint64_t v7 = *(capabilities::ct **)(v3 + 472);
        *(void *)(v3 + 472) = 0;
        if (v7) {
          uint64_t v7 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *))(*(void *)v7 + 8))(v7);
        }
        uint64_t v8 = a1[7];
        if (capabilities::ct::supportsBB2GMitigation(v7))
        {
          uint64_t v9 = *(void *)(v8 + 456);
          if (*(unsigned char *)(v9 + 16) == 2 && *(_DWORD *)(v9 + 136) != 2) {
            sub_100F4C574(v8, 0, 2);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F581BC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F581D0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F581EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t *sub_100F581FC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  __int16 v2 = sub_100F4B174(*(void *)v1, *(_DWORD *)(v1 + 8));
  sub_100335978(v1 + 16, v2);
  sub_100AB000C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100F58254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100F58270(uint64_t a1@<X0>, NSObject **a2@<X1>, std::__shared_weak_count **a3@<X8>)
{
  uint64_t v6 = (std::__shared_weak_count *)operator new(0xD8uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A73358;
  uint64_t v7 = v6 + 1;
  uint64_t v8 = *a2;
  *a2 = 0;
  uint64_t v10 = v8;
  sub_100F584EC((uint64_t)&v6[1], a1, &v10);
  if (v8) {
    dispatch_release(v8);
  }
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A733A8;
  shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    goto LABEL_7;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_7:
    sub_10004D2C8(v6);
  }
  *a3 = v7;
  a3[1] = v6;
}

void sub_100F5837C(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_100F583A0(uint64_t a1)
{
  *(void *)a1 = off_101A73208;
  sub_100088048(a1 + 168, *(void **)(a1 + 176));
  __int16 v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v5) {
    sub_100F5B1F0(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 64);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  CarrierSpaceAuthFlowManagerInterface::~CarrierSpaceAuthFlowManagerInterface((CarrierSpaceAuthFlowManagerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F584B4(uint64_t a1)
{
  sub_100F583A0(a1);

  operator delete();
}

uint64_t sub_100F584EC(uint64_t a1, uint64_t a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v36, kCtLoggingSystemName, "carrier.space.auth");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v34, &v36);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v34);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v34);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v36);
  v35[0] = off_1019AF850;
  v35[1] = sub_100F58B48;
  v35[3] = v35;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v35);
  *(void *)a1 = off_101A73208;
  uint64_t v8 = *(Registry **)a2;
  *(void *)(a1 + 56) = *(void *)a2;
  uint64_t v9 = *(void *)(a2 + 8);
  *(void *)(a1 + 64) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v8 = *(Registry **)(a1 + 56);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  char v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v36.var0 = (char *)v12;
  unint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v36);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v11);
  *(void *)(a1 + 72) = v18;
  *(void *)(a1 + 80) = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
  }
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v20 = v19;
  if (v21 < 0)
  {
    v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  v36.var0 = (char *)v21;
  char v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v36);
  if (v25)
  {
    uint64_t v27 = v25[3];
    uint64_t v26 = (std::__shared_weak_count *)v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      char v28 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v20);
  uint64_t v26 = 0;
  char v28 = 1;
LABEL_26:
  sub_100058DB0(&v36, "CarrierSpace");
  (*(void (**)(uint64_t, OsLogContext *))(*(void *)v27 + 16))(v27, &v36);
  if ((v37 & 0x80000000) == 0)
  {
    if (v28) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  operator delete(v36.var0);
  if ((v28 & 1) == 0) {
LABEL_28:
  }
    sub_10004D2C8(v26);
LABEL_29:
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  sub_100058DB0(&__p, "CarrierSpaceAuthFlowManager");
  unint64_t v29 = *(NSObject **)(a1 + 24);
  BOOL v31 = v29;
  if (v29) {
    dispatch_retain(v29);
  }
  ctu::RestModule::RestModule();
  if (v31) {
    dispatch_release(v31);
  }
  if (v33 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  return a1;
}

void sub_100F58968(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
}

const char *sub_100F58B48(int a1)
{
  uint64_t v1 = "carrier.space.auth.?";
  if (a1 == 2) {
    uint64_t v1 = "carrier.space.auth.2";
  }
  if (a1 == 1) {
    return "carrier.space.auth.1";
  }
  else {
    return v1;
  }
}

void sub_100F58B74(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", v2, 2u);
  }
}

void sub_100F58BD4(uint64_t a1)
{
  __int16 v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v4, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1001F3BF8(a1 + 168);
  sub_100058DB0(&__p, "/cc/events/app_state_changed");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_101A73478;
  v3[1] = a1;
  v3[2] = sub_100064434;
  v3[3] = 0;
  uint64_t v9 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_100F58D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F58D54(uint64_t a1)
{
  __int16 v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Shutting down", v4, 2u);
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 152));
}

void sub_100F58DC0(uint64_t a1)
{
  __int16 v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Migrating", (uint8_t *)__p, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3)
  {
    __p[0] = 0;
    __p[1] = 0;
    v8[0] = 0;
    sub_100058DB0(v11, "com.apple.carrierspace.token");
    (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)v3 + 32))(__p, v3, v11);
    if (v12 < 0) {
      operator delete(v11[0]);
    }
    uint64_t v4 = (char *)__p[0];
    uint64_t v5 = (char *)__p[1];
    if (__p[0] == __p[1])
    {
      if (!__p[0]) {
        return;
      }
      __p[1] = __p[0];
    }
    else
    {
      uint64_t v6 = *(void *)(a1 + 88);
      if (v6)
      {
        sub_100058DB0(__p, "com.apple.carrierspace.token");
        (*(void (**)(uint64_t, void **))(*(void *)v6 + 24))(v6, __p);
        if (SHIBYTE(v8[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      long long v9 = 0u;
      long long v10 = 0u;
      *(_OWORD *)__p = 0u;
      *(_OWORD *)uint64_t v8 = 0u;
      sub_10006E4A8(__p, v4, v5, v5 - v4);
      sub_100F58FB0(*(void *)(a1 + 88), (uint64_t)__p);
      sub_10007CA64((const void **)&v10);
      if (v8[1])
      {
        *(void **)&long long v9 = v8[1];
        operator delete(v8[1]);
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (!v4) {
        return;
      }
    }
    operator delete(v4);
  }
}

void sub_100F58F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v14) {
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F58FB0(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    sub_100058DB0(v5, "com.apple.carrierspace.authinfo");
    sub_100BE8D24(a2, __p);
    (*(void (**)(uint64_t, void **, void **))(*(void *)a1 + 16))(a1, v5, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v6 < 0) {
      operator delete(v5[0]);
    }
  }
}

void sub_100F5904C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F59080(void *a1)
{
  sub_100F595CC((uint64_t)a1, 1u);
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  sub_100F596C8((uint64_t)v5, a1[11]);
  if ((_BYTE)v6)
  {
    sub_100F59D5C((uint64_t)a1, (uint64_t)v5);
  }
  else
  {
    __int16 v2 = a1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Auth information could not be read from keychain", v4, 2u);
    }
    (*(void (**)(void *, void))(*a1 + 64))(a1, 0);
  }
  return sub_10007CAFC((uint64_t)v5);
}

void sub_100F59154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10007CAFC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100F59168(uint64_t a1, _DWORD **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    *uint64_t v3 = 1;
  }
  if (!*(_DWORD *)(a1 + 104))
  {
    if (!*(unsigned char *)(a1 + 128))
    {
      sub_100F595CC(a1, 1u);
      operator new();
    }
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Cannot proceed with authentication because app is still running", buf, 2u);
      uint64_t v3 = *a2;
    }
    if (v3) {
      *uint64_t v3 = 2;
    }
  }
}

void sub_100F5950C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
}

void sub_100F595CC(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(int *)(a1 + 104);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v2 > 4) {
        uint64_t v6 = "???";
      }
      else {
        uint64_t v6 = off_101A73678[v2];
      }
      if (a2 > 4) {
        char v7 = "???";
      }
      else {
        char v7 = off_101A73678[a2];
      }
      int v8 = 136315394;
      long long v9 = v6;
      __int16 v10 = 2080;
      char v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Transitioning from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(_DWORD *)(a1 + 104) = a2;
  }
}

void sub_100F596C8(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 64) = 0;
    return;
  }
  unsigned int v15 = 0;
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  sub_100058DB0(__p, "com.apple.carrierspace.authinfo");
  (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)a2 + 32))(&v15, a2, __p);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = v15;
  if (v15 == v16)
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 64) = 0;
    if (!v4) {
      return;
    }
    goto LABEL_13;
  }
  sub_100BE90E0((uint64_t)&v15, (uint64_t)v7);
  *(_OWORD *)a1 = *(_OWORD *)v7;
  *(void *)(a1 + 16) = v8;
  v7[0] = 0;
  v7[1] = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v9;
  uint64_t v8 = 0;
  v9[0] = 0;
  uint64_t v5 = v10;
  uint64_t v6 = v11;
  uint64_t v10 = 0;
  char v11 = 0;
  v9[1] = 0;
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = v6;
  *(_WORD *)(a1 + 56) = v12;
  *(unsigned char *)(a1 + 64) = 1;
  sub_10007CA64(&v11);
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
  uint64_t v4 = v15;
  if (v15)
  {
LABEL_13:
    unint64_t v16 = v4;
    operator delete(v4);
  }
}

void sub_100F59800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  unsigned int v24 = *(void **)(v22 - 40);
  if (v24)
  {
    *(void *)(v22 - 32) = v24;
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F59830(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v4 = a1 + 56;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    uint64_t v13 = v11[3];
    __int16 v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  __int16 v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_11:
    (*(void (**)(uint64_t, void))(*(void *)a1 + 64))(a1, 0);
    goto LABEL_38;
  }
LABEL_10:
  if (xpc_get_type(*a2) != (xpc_type_t)&_xpc_type_dictionary) {
    goto LABEL_11;
  }
  unsigned int v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 112) + 8));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)a2);
    unint64_t v16 = v31 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315138;
    *(void *)&buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Launching authentication alert with options: %s", buf, 0xCu);
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[0]);
    }
  }
  xpc_object_t v17 = xpc_null_create();
  xpc_object_t v29 = 0;
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v19 = v18;
  if (v18)
  {
    xpc_object_t v29 = v18;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
    xpc_object_t v29 = v19;
    if (!v19)
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v19 = 0;
      goto LABEL_25;
    }
  }
  if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v20 = xpc_null_create();
LABEL_25:
    xpc_object_t v29 = v20;
    goto LABEL_26;
  }
  xpc_retain(v19);
LABEL_26:
  xpc_release(v19);
  xpc_object_t v27 = *a2;
  *a2 = xpc_null_create();
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long buf = *(_OWORD *)__p;
  uint64_t v34 = v31;
  uint64_t v21 = (uint8_t *)__p[0];
  if (v31 >= 0) {
    uint64_t v21 = buf;
  }
  v26[0] = &v29;
  v26[1] = v21;
  sub_10014E03C((uint64_t)v26, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v34) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v22 = v29;
  xpc_object_t v29 = xpc_null_create();
  xpc_release(v17);
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 16))(buf, v13, v4);
  uint64_t v23 = *(void *)buf;
  sub_100058DB0(__p, "carrierspaceauth://");
  v24[0] = 1;
  xpc_object_t v25 = v22;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    xpc_object_t v25 = xpc_null_create();
  }
  v32[0] = off_101A734F8;
  v32[1] = a1;
  v32[3] = v32;
  (*(void (**)(uint64_t, void **, char *, void *))(*(void *)v23 + 16))(v23, __p, v24, v32);
  sub_100060644(v32);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  xpc_release(v29);
  xpc_release(v22);
LABEL_38:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100F59C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F59D5C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 112))
  {
    uint64_t v10 = a1;
    char v11 = 0;
    *(void *)__int16 v12 = 0;
    uint64_t v13 = 0;
    sub_10005C928(&v11, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    char v14 = 0;
    unsigned int v15 = 0;
    uint64_t v16 = 0;
    sub_10005C928(&v14, *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
    sub_100602178(&cf, (const void **)(a2 + 48));
    __int16 v18 = *(_WORD *)(a2 + 56);
    uint64_t v4 = *(void *)(a1 + 72);
    if (v4)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 16))(&v31);
      if (v31)
      {
        uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 112) + 8));
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Prompting for biometric authentication", (uint8_t *)&buf, 2u);
        }
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long buf = 0u;
        if (*(void *)(a1 + 24)) {
          dispatch_retain(*(dispatch_object_t *)(a1 + 24));
        }
        uint64_t v19 = v10;
        xpc_object_t v20 = 0;
        v21[0] = 0;
        v21[1] = 0;
        sub_10005C928(&v20, v11, *(uint64_t *)v12, *(void *)v12 - (void)v11);
        __p = 0;
        long long v23 = 0uLL;
        sub_10005C928(&__p, v14, (uint64_t)v15, v15 - (unsigned char *)v14);
        CFTypeRef v24 = cf;
        if (cf) {
          CFRetain(cf);
        }
        __int16 v25 = v18;
        char v33 = 0;
        uint64_t v6 = operator new(0x50uLL);
        uint64_t v8 = v19;
        uint64_t v7 = v20;
        *(void *)uint64_t v6 = off_101A735F8;
        *((void *)v6 + 1) = v8;
        *((void *)v6 + 2) = 0;
        *((void *)v6 + 3) = 0;
        *((void *)v6 + 4) = 0;
        sub_10005C928((void *)v6 + 2, v7, (uint64_t)v21[0], (char *)v21[0] - (char *)v7);
        *((void *)v6 + 5) = 0;
        *((void *)v6 + 6) = 0;
        *((void *)v6 + 7) = 0;
        sub_10005C928((void *)v6 + 5, __p, v23, v23 - (void)__p);
        sub_100602178((const void **)v6 + 8, &v24);
        *((_WORD *)v6 + 36) = v25;
        char v33 = v6;
        operator new();
      }
      sub_100F5B280(&v10, 5);
      if (v32) {
        sub_10004D2C8(v32);
      }
    }
    else
    {
      sub_100F5B280(&v10, 5);
    }
    sub_10007CA64(&cf);
    if (v14)
    {
      unsigned int v15 = v14;
      operator delete(v14);
    }
    if (v11)
    {
      *(void *)__int16 v12 = v11;
      operator delete(v11);
    }
  }
  else
  {
    uint64_t v9 = *(void (**)(void))(*(void *)a1 + 64);
    v9();
  }
}

void sub_100F5A2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  long long v30 = *(std::__shared_weak_count **)(v29 - 160);
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_100F5ABD0((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void sub_100F5A388(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x100F5A380);
}

void sub_100F5A3A0()
{
}

void sub_100F5A3A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int *)(a1 + 104);
  if (v3 == 1 && (uint64_t v4 = *(void *)(a1 + 112)) != 0)
  {
    uint64_t v6 = *(unsigned int *)(v4 + 8);
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      ctu::hex();
      uint64_t v8 = v21 >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)long long buf = 136315138;
      long long v23 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received authentication token '%s'", buf, 0xCu);
      if (v21 < 0) {
        operator delete(*(void **)__p);
      }
    }
    sub_100F595CC(a1, 2u);
    if (*(unsigned char *)(a2 + 57))
    {
      uint64_t v9 = *(void *)(a1 + 88);
      if (*(unsigned char *)(a2 + 56)) {
        sub_100F58FB0(v9, a2);
      }
      else {
        sub_100F5A67C(v9);
      }
    }
    uint64_t v12 = *(void *)(a1 + 120);
    if (v12)
    {
      xpc_object_t v17 = 0;
      __int16 v18 = 0;
      uint64_t v19 = 0;
      sub_10005C928(&v17, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      uint64_t v13 = *(void *)(a1 + 112);
      if (*(char *)(v13 + 39) < 0)
      {
        sub_10004FC84(v15, *(void **)(v13 + 16), *(void *)(v13 + 24));
      }
      else
      {
        *(_OWORD *)unsigned int v15 = *(_OWORD *)(v13 + 16);
        uint64_t v16 = *(void *)(v13 + 32);
      }
      (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v12 + 16))(v12, v6, &v17, v15);
      if (SHIBYTE(v16) < 0) {
        operator delete(v15[0]);
      }
      if (v17)
      {
        __int16 v18 = v17;
        operator delete(v17);
      }
    }
    char v14 = **(_DWORD ***)(a1 + 112);
    if (v14) {
      _DWORD *v14 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 4) {
        char v11 = "???";
      }
      else {
        char v11 = off_101A73678[v3];
      }
      *(_DWORD *)__p = 136315138;
      *(void *)&__p[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Received auth info in unexpected state: %s", __p, 0xCu);
    }
  }
}

void sub_100F5A640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F5A67C(uint64_t a1)
{
  if (a1)
  {
    sub_100058DB0(__p, "com.apple.carrierspace.authinfo");
    (*(void (**)(uint64_t, void **))(*(void *)a1 + 24))(a1, __p);
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100F5A6F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F5A710(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 104);
  BOOL v4 = v3 > 4 || ((1 << v3) & 0x1A) == 0;
  if (v4 || (uint64_t v5 = *(void *)(a1 + 112)) == 0)
  {
    char v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 4) {
        uint64_t v12 = "???";
      }
      else {
        uint64_t v12 = off_101A73678[v3];
      }
      int v13 = 136315138;
      char v14 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Ignoring auth failure received in unexpected state: %s", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    if ((a2 & 0xFF00000000) != 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = 10;
    }
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    uint64_t v8 = *(void *)(a1 + 120);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 24))(v8, v7, v5 + 16, v6);
    }
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 136315138;
      char v14 = asString(v6);
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Pending authentication failed with error: %s, resetting state", (uint8_t *)&v13, 0xCu);
    }
    uint64_t v10 = **(_DWORD ***)(a1 + 112);
    if (v10) {
      _DWORD *v10 = v6;
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  }
}

void sub_100F5A900(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 104);
  BOOL v4 = v3 > 4 || ((1 << v3) & 0x1A) == 0;
  if (v4 || (uint64_t v5 = *(void *)(a1 + 112)) == 0)
  {
    char v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 4) {
        uint64_t v12 = "???";
      }
      else {
        uint64_t v12 = off_101A73678[v3];
      }
      int v13 = 136315138;
      char v14 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Ignoring plan term confirmation received in unexpected state: %s", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = "accepted";
      if (!a2) {
        uint64_t v8 = "rejected";
      }
      uint64_t v9 = (void *)(v5 + 40);
      if (*(char *)(v5 + 63) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      int v13 = 136315394;
      char v14 = v8;
      __int16 v15 = 2080;
      uint64_t v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I User has %s the terms for plan '%s'", (uint8_t *)&v13, 0x16u);
    }
    if (a2)
    {
      if (*(_DWORD *)(a1 + 104) == 3)
      {
        if (*(unsigned char *)(a1 + 128))
        {
          uint64_t v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v13) = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I App is still running, will wait for termination before displaying authentication alert", (uint8_t *)&v13, 2u);
          }
          sub_100F595CC(a1, 4u);
        }
        else
        {
          sub_100F59080((void *)a1);
        }
      }
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, 0x10000000CLL);
    }
  }
}

void sub_100F5AB14(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cached token has been invalidated, clearing...", v3, 2u);
  }
  sub_100F5A67C(*(void *)(a1 + 88));
}

uint64_t sub_100F5AB80(uint64_t a1)
{
  sub_100F595CC(a1, 0);
  uint64_t result = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (result)
  {
    sub_100F5B1F0(result);
  }
  return result;
}

uint64_t sub_100F5ABD0(uint64_t a1)
{
  sub_10007CA64((const void **)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  unsigned int v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(void *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100F5AC1C(xpc_object_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 112);
  if (v3)
  {
    uint64_t v5 = *(unsigned int *)(v3 + 8);
    xpc_object_t object = 0;
    uint64_t v6 = (Registry **)(a2 + 56);
    sub_100BE7E60((Registry **)(a2 + 56), v5, &object);
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v10 = *(void *)(a2 + 176);
      uint64_t v9 = a2 + 176;
      uint64_t v8 = v10;
      if (v10)
      {
        uint64_t v11 = v9;
        do
        {
          int v12 = *(_DWORD *)(v8 + 32);
          BOOL v13 = v12 < (int)v5;
          if (v12 >= (int)v5) {
            char v14 = (uint64_t *)v8;
          }
          else {
            char v14 = (uint64_t *)(v8 + 8);
          }
          if (!v13) {
            uint64_t v11 = v8;
          }
          uint64_t v8 = *v14;
        }
        while (*v14);
        if (v11 != v9 && (int)v5 >= *(_DWORD *)(v11 + 32)) {
          sub_100BE7C0C(v6, v5, &object, v11 + 40);
        }
      }
      *a1 = object;
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t object = v7;
    }
    else
    {
      *a1 = xpc_null_create();
      xpc_object_t v7 = object;
    }
    xpc_release(v7);
  }
  else
  {
    *a1 = xpc_null_create();
  }
}

void sub_100F5AD0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_100F5AD38(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 104);
    if (v3 > 4) {
      BOOL v4 = "???";
    }
    else {
      BOOL v4 = off_101A73678[v3];
    }
    int v15 = 136315138;
    uint64_t v16 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fState = %s", (uint8_t *)&v15, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 112);
  if (v5)
  {
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(v5 + 8));
    xpc_object_t v7 = *(char **)(a1 + 112);
    os_log_t v8 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v9 = v7 + 16;
    if (v7[39] < 0) {
      uint64_t v9 = *(const char **)v9;
    }
    if (v7[88])
    {
      uint64_t v10 = v7 + 64;
      if (v7[87] < 0) {
        uint64_t v10 = *(const char **)v10;
      }
    }
    else
    {
      uint64_t v10 = "none";
    }
    int v15 = 136315394;
    uint64_t v16 = v9;
    __int16 v17 = 2080;
    __int16 v18 = v10;
    int v12 = "#I fCurrentRequest = planID '%s', planTermsURL '%s'";
    BOOL v13 = v8;
    uint32_t v14 = 22;
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v15) = 0;
    int v12 = "#I fCurrentRequest = null";
    BOOL v13 = v11;
    uint32_t v14 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v15, v14);
}

void sub_100F5AEF4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A73358;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F5AF14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A73358;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F5AF68(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F5AF94(uint64_t a1)
{
  sub_100F583A0(a1);

  operator delete();
}

void sub_100F5AFD0()
{
}

uint64_t sub_100F5AFE4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100F5AFF4()
{
}

__n128 sub_100F5B008(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A73478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F5B05C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A73478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F5B094(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5B0D4()
{
}

void sub_100F5B0E4()
{
}

void *sub_100F5B0F8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A734F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F5B140(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A734F8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F5B16C(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(result + 8) + 64))(*(void *)(result + 8), 0);
  }
  return result;
}

uint64_t sub_100F5B1A4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F5B1E4()
{
}

void sub_100F5B1F0(uint64_t a1)
{
  sub_10007CAFC(a1 + 96);
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  sub_10007C6F8((uint64_t *)a1, 0);

  operator delete();
}

void sub_100F5B280(void *a1, int a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*a1 + 48) + 16))(*(void *)(*a1 + 48), *(unsigned int *)(*(void *)(*a1 + 112) + 8));
  uint64_t v6 = v5;
  if (a2)
  {
    xpc_object_t v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Biometric authentication result: %s", (uint8_t *)&buf, 0xCu);
    }
    if (sub_100BE8D18(a2)) {
      (*(void (**)(uint64_t))(*(void *)v4 + 80))(v4);
    }
    BOOL v8 = sub_100BE8CD4(a2);
    uint64_t v9 = *v6;
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Biometric authentication failed, will ask user to authenticate with login credentials", (uint8_t *)&buf, 2u);
      }
      sub_100F5AC1C(&object, v4);
      sub_100F59830(v4, &object);
      xpc_release(object);
    }
    else
    {
      if (v10)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Will not present fallback authentication", (uint8_t *)&buf, 2u);
      }
      (*(void (**)(uint64_t, void))(*(void *)v4 + 64))(v4, 0);
    }
    return;
  }
  uint64_t v11 = (uint64_t)(a1 + 1);
  if (a1[4] != a1[5])
  {
    uint64_t v13 = a1[7];
    int v12 = (CFDateRef *)(a1 + 7);
    uint32_t v14 = v13 ? (uint64_t *)sub_1001908E4 : 0;
    if (v14)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(v4 + 56));
      uint64_t v16 = ServiceMap;
      if (v17 < 0)
      {
        __int16 v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          uint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v17;
      char v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&buf);
      if (v21)
      {
        uint64_t v23 = v21[3];
        xpc_object_t v22 = (std::__shared_weak_count *)v21[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v16);
      xpc_object_t v22 = 0;
      char v24 = 1;
LABEL_29:
      CFAbsoluteTime v25 = (*(double (**)(uint64_t))(*(void *)v23 + 96))(v23);
      if ((v24 & 1) == 0) {
        sub_10004D2C8(v22);
      }
      CFDateRef v56 = CFDateCreate(0, v25);
      CFComparisonResult v26 = CFDateCompare(v56, *v12, 0);
      long long v27 = *(NSObject **)(v4 + 40);
      BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
      if (v26 == kCFCompareLessThan)
      {
        if (v28)
        {
          sub_100BE9E5C(v12, (uint64_t)&buf);
          v40 = SHIBYTE(v62) >= 0 ? &buf : (long long *)buf;
          *(_DWORD *)v70 = 136315138;
          *(void *)&v70[4] = v40;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Cached token has not expired yet (expires on \"%s\")", v70, 0xCu);
          if (SHIBYTE(v62) < 0) {
            operator delete((void *)buf);
          }
        }
        sub_100F5BC74(v4, v11);
        goto LABEL_75;
      }
      if (v28)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Token has expired, attempting to refresh", (uint8_t *)&buf, 2u);
      }
      long long v30 = (std::mutex *)Registry::getServiceMap(v29, *(Registry **)(v4 + 56));
      uint64_t v31 = v30;
      if (v32 < 0)
      {
        char v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v34 = 5381;
        do
        {
          uint64_t v32 = v34;
          unsigned int v35 = *v33++;
          uint64_t v34 = (33 * v34) ^ v35;
        }
        while (v35);
      }
      std::mutex::lock(v30);
      *(void *)&long long buf = v32;
      OsLogContext v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)&buf);
      if (v36)
      {
        uint64_t v38 = v36[3];
        char v37 = (std::__shared_weak_count *)v36[4];
        if (v37)
        {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v31);
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v37);
          char v39 = 0;
LABEL_49:
          int64_t v41 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *(unsigned int *)(*(void *)(v4 + 112) + 8));
          memset(v70, 0, sizeof(v70));
          uint64_t v71 = 0;
          sub_100BE93BC((Registry **)(v4 + 56), (uint64_t *)v70);
          if (SHIBYTE(v71) < 0)
          {
            sub_10004FC84(__p, *(void **)v70, *(unint64_t *)&v70[8]);
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)v70;
            uint64_t v58 = v71;
          }
          sub_100BE97F0((uint64_t)&buf);
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **, long long *))(*(void *)v38 + 16))(v59, v38, 3, __p, &buf);
          long long v42 = *(_OWORD *)v59;
          memset(v59, 0, sizeof(v59));
          v43 = *(std::__shared_weak_count **)(v4 + 144);
          *(_OWORD *)(v4 + 136) = v42;
          if (v43)
          {
            sub_10004D2C8(v43);
            if (*(void *)&v59[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v59[8]);
            }
          }
          sub_10010C0E0((uint64_t)&buf, *((void **)&buf + 1));
          if (SHIBYTE(v58) < 0) {
            operator delete(__p[0]);
          }
          (*(void (**)(void))(**(void **)(v4 + 136) + 136))(*(void *)(v4 + 136));
          uint64_t v44 = *(void *)(v4 + 136);
          sub_100BE9514((Registry **)(v4 + 56), v11, (uint64_t)&buf);
          (*(void (**)(uint64_t, long long *))(*(void *)v44 + 56))(v44, &buf);
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          (*(void (**)(void, void))(**(void **)(v4 + 136) + 8))(*(void *)(v4 + 136), *(void *)(v4 + 24));
          v45 = *(std::__shared_weak_count **)(v4 + 16);
          if (!v45 || (v46 = *(void *)(v4 + 8), (uint64_t v47 = std::__shared_weak_count::lock(v45)) == 0)) {
            sub_100088B9C();
          }
          v48 = v47;
          p_shared_weak_owners = &v47->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v47->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v47);
          v50 = (std::__shared_weak_count *)operator new(0x28uLL);
          v50->__shared_weak_owners_ = 0;
          v50->__shared_owners_ = 0;
          v50[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
          v50->__vftable = (std::__shared_weak_count_vtbl *)off_101A735A8;
          v50[1].__shared_owners_ = (uint64_t)v6;
          uint64_t v51 = *(void *)(v4 + 136);
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 1174405120;
          v62 = sub_100F5BD78;
          v63 = &unk_101A73568;
          uint64_t v64 = v4;
          uint64_t v65 = v46;
          v66 = v48;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          v67 = v41;
          v68 = v50 + 1;
          v69 = v50;
          atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, long long *))(*(void *)v51 + 16))(v51, &buf);
          v52 = *v41;
          if (os_log_type_enabled(*v41, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v53 = v70;
            if (v71 < 0) {
              uint64_t v53 = *(uint8_t **)v70;
            }
            *(_DWORD *)v59 = 136315138;
            *(void *)&v59[4] = v53;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Issuing refresh token HTTP POST to \"%s\"", v59, 0xCu);
          }
          uint64_t v54 = *(void *)(v4 + 136);
          uint64_t v60 = 0;
          memset(v59, 0, sizeof(v59));
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v54 + 40))(v54, v59);
          if (SHIBYTE(v60) < 0) {
            operator delete(*(void **)v59);
          }
          if (v69) {
            sub_10004D2C8(v69);
          }
          if (v66) {
            std::__shared_weak_count::__release_weak(v66);
          }
          sub_10004D2C8(v50);
          std::__shared_weak_count::__release_weak(v48);
          if (SHIBYTE(v71) < 0) {
            operator delete(*(void **)v70);
          }
          if ((v39 & 1) == 0) {
            sub_10004D2C8(v37);
          }
LABEL_75:
          sub_10007CA64((const void **)&v56);
          return;
        }
      }
      else
      {
        uint64_t v38 = 0;
      }
      std::mutex::unlock(v31);
      char v37 = 0;
      char v39 = 1;
      goto LABEL_49;
    }
  }

  sub_100F5BC74(v4, v11);
}

void sub_100F5BAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, const void *a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
}

uint64_t sub_100F5BC10(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 40);
  sub_1000558F4((const void **)(a1 + 72));
  sub_1000558F4((const void **)(a1 + 64));
  sub_1000558F4((const void **)(a1 + 48));
  sub_1000558F4(v2);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  sub_100F5C3DC((uint64_t *)a1, 0);
  return a1;
}

void sub_100F5BC74(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_10005C928(&v4, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  __p = 0;
  BOOL v8 = 0;
  uint64_t v9 = 0;
  sub_10005C928(&__p, *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  sub_100602178(&v10, (const void **)(a2 + 48));
  __int16 v11 = *(_WORD *)(a2 + 56);
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 56))(a1, &v4);
  sub_10007CA64(&v10);
  if (__p)
  {
    BOOL v8 = __p;
    operator delete(__p);
  }
  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }
}

void sub_100F5BD4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
}

void sub_100F5BD78(uint64_t a1, ctu::Http::HttpResponse **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      xpc_object_t v7 = v6;
      if (!*(void *)(a1 + 40))
      {
LABEL_51:
        sub_10004D2C8(v7);
        return;
      }
      BOOL v8 = *a2;
      if (*a2)
      {
        unsigned int v9 = 0;
      }
      else
      {
        BOOL v10 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Received null refresh token response!", (uint8_t *)&__p, 2u);
          BOOL v8 = *a2;
        }
        else
        {
          BOOL v8 = 0;
        }
        unsigned int v9 = 10;
      }
      if ((*(unsigned int (**)(ctu::Http::HttpResponse *))(*(void *)v8 + 16))(v8) != 1)
      {
        __int16 v11 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          ctu::Http::asString();
          int v12 = v29 >= 0 ? &__p : (void **)__p;
          LODWORD(v23[0]) = 136315138;
          *(void **)((char *)v23 + 4) = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Refresh token operation failed with error: %s", (uint8_t *)v23, 0xCu);
          if (SHIBYTE(v29) < 0) {
            operator delete(__p);
          }
        }
        unsigned int v9 = 10;
      }
      int v13 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
      if (v13 != 200)
      {
        uint32_t v14 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(__p) = 67109120;
          HIDWORD(__p) = v13;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Refresh token operation failed with HTTP error code: %d", (uint8_t *)&__p, 8u);
        }
        unsigned int v9 = 10;
      }
      long long v25 = 0u;
      *(_OWORD *)CFTypeRef cf = 0u;
      *(_OWORD *)uint64_t v23 = 0u;
      *(_OWORD *)char v24 = 0u;
      ctu::Http::HttpResponse::getResponseData((uint64_t *)&__p, *a2);
      sub_100BE98AC((const void **)(v5 + 40), (Registry **)(v5 + 56), (uint64_t)&__p, (uint64_t)v23);
      if (__p)
      {
        BOOL v28 = __p;
        operator delete(__p);
      }
      int v15 = v23[0];
      if (v23[0] == v23[1])
      {
        uint64_t v17 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Failed to parse refresh token response", (uint8_t *)&__p, 2u);
          int v15 = v23[0];
        }
        __int16 v34 = 0;
        if (v15)
        {
          v23[1] = v15;
          operator delete(v15);
        }
        v23[0] = 0;
        v23[1] = 0;
        v24[0] = 0;
        BOOL v28 = 0;
        uint64_t v29 = 0;
        __p = 0;
        if (v24[1])
        {
          *(void **)&long long v25 = v24[1];
          operator delete(v24[1]);
        }
        v24[1] = 0;
        long long v25 = 0uLL;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        long long v30 = 0;
        *(CFTypeRef *)long long buf = cf[0];
        cf[0] = 0;
        CFTypeRef v33 = 0;
        sub_10007CA64((const void **)buf);
        LOWORD(cf[1]) = 0;
        sub_10007CA64(&v33);
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }
        if (__p)
        {
          BOOL v28 = __p;
          operator delete(__p);
        }
        unsigned int v9 = 10;
      }
      else if (!v9)
      {
        sub_100F58FB0(*(void *)(v5 + 88), (uint64_t)v23);
        uint64_t v16 = **(void **)(a1 + 64);
        __p = 0;
        BOOL v28 = 0;
        uint64_t v29 = 0;
        sub_10005C928(&__p, v23[0], (uint64_t)v23[1], (char *)v23[1] - (char *)v23[0]);
        long long v30 = 0;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        sub_10005C928(&v30, v24[1], v25, v25 - (unint64_t)v24[1]);
        CFTypeRef v33 = cf[0];
        if (cf[0]) {
          CFRetain(cf[0]);
        }
        __int16 v34 = (__int16)cf[1];
        (*(void (**)(uint64_t, void **))(*(void *)v16 + 56))(v16, &__p);
        sub_10007CA64(&v33);
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }
        if (__p)
        {
          BOOL v28 = __p;
          operator delete(__p);
        }
LABEL_45:
        xpc_object_t v22 = *(std::__shared_weak_count **)(v5 + 144);
        *(void *)(v5 + 136) = 0;
        *(void *)(v5 + 144) = 0;
        if (v22) {
          sub_10004D2C8(v22);
        }
        sub_10007CA64(cf);
        if (v24[1])
        {
          *(void **)&long long v25 = v24[1];
          operator delete(v24[1]);
        }
        if (v23[0])
        {
          v23[1] = v23[0];
          operator delete(v23[0]);
        }
        goto LABEL_51;
      }
      uint64_t v18 = *(void *)(a1 + 64);
      uint64_t v19 = *(uint64_t **)v18;
      unsigned int v20 = **(NSObject ***)(v18 + 8);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        char v21 = asString(v9);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Refresh token evaluation returned error: %s", buf, 0xCu);
      }
      sub_100F5A67C(v19[11]);
      (*(void (**)(uint64_t *, unint64_t))(*v19 + 64))(v19, v9 | (unint64_t)&_mh_execute_header);
      goto LABEL_45;
    }
  }
}

void sub_100F5C25C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F5C2DC(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F5C310(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100F5C360(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A735A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F5C380(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A735A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F5C3DC(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100F5C42C(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100F5C42C(uint64_t a1)
{
  if (*(void *)(a1 + 8) && *(void *)(a1 + 40))
  {
    sub_100F5C5F0((uint64_t)v4, a1 + 16);
    v4[32] = *(unsigned char *)a1;
    operator new();
  }
  sub_100F5C670((void *)(a1 + 16));
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  return a1;
}

void sub_100F5C518(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F5C524(uint64_t a1)
{
  sub_100F5C59C(a1, *(unsigned char *)(a1 + 32));
  sub_100F5C670((void *)a1);

  operator delete();
}

void sub_100F5C574()
{
  sub_100F5C670(v0);
  operator delete();
}

uint64_t sub_100F5C59C(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100F5C5F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100F5C670(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100F5C6F4(uint64_t a1)
{
  *(void *)a1 = off_101A735F8;
  sub_10007CA64((const void **)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + 24) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100F5C758(uint64_t a1)
{
  *(void *)a1 = off_101A735F8;
  sub_10007CA64((const void **)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + 24) = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_100F5C7DC(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 8);
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_101A735F8;
  sub_100F5C90C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F5C830(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F5C844(uint64_t a1, void *a2)
{
  *a2 = off_101A735F8;
  return sub_100F5C90C((uint64_t)(a2 + 1), (const void **)(a1 + 8));
}

void sub_100F5C870(uint64_t a1)
{
}

void sub_100F5C878(void *a1)
{
  sub_100F5C9AC((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F5C8B4(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_100F5C8C0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A73668)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F5C900()
{
  return &off_101A73668;
}

uint64_t sub_100F5C90C(uint64_t a1, const void **a2)
{
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_10005C928((void *)(a1 + 8), a2[1], (uint64_t)a2[2], (unsigned char *)a2[2] - (unsigned char *)a2[1]);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_10005C928((void *)(a1 + 32), a2[4], (uint64_t)a2[5], (unsigned char *)a2[5] - (unsigned char *)a2[4]);
  sub_100602178((const void **)(a1 + 56), a2 + 7);
  *(_WORD *)(a1 + 64) = *((_WORD *)a2 + 32);
  return a1;
}

void sub_100F5C990(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F5C9AC(uint64_t a1)
{
  sub_10007CA64((const void **)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(void *)(a1 + 16) = v3;
    operator delete(v3);
  }
}

void sub_100F5CA0C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F5CDB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100F5CF20(uint64_t a1)
{
  *(void *)a1 = off_101A736B0;
  uint64_t v2 = (void *)(a1 + 96);
  sub_10005CD2C(a1 + 128, *(char **)(a1 + 136));
  sub_100F5D904(v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  RegulatoryDomainInterface::~RegulatoryDomainInterface((RegulatoryDomainInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F5CFBC(uint64_t a1)
{
  sub_100F5CF20(a1);

  operator delete();
}

void sub_100F5CFF4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F5D11C(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v2 = a2;
  }
  else {
    uint64_t v2 = (uint64_t *)*a2;
  }
  id v3 = +[NSString stringWithUTF8String:v2];
  RDUpdateCountryCodeFromMCC();
}

void sub_100F5D17C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100F5D190(void *a1)
{
  v59 = 0;
  uint64_t v60 = 0;
  uint64_t v58 = &v59;
  uint64_t v1 = +[RDEstimate currentEstimates];
  if ([v1 count])
  {
    uint64_t v2 = v1;
  }
  else
  {
    uint64_t v2 = +[RDEstimate lastKnownEstimates];
  }
  if ([v2 count])
  {
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    id v3 = v2;
    id v4 = [v3 countByEnumeratingWithState:&v54 objects:v61 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v55;
      uint64_t v6 = kRDPrioritySingleLocation;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v55 != v5) {
            objc_enumerationMutation(v3);
          }
          id v8 = *(id *)(*((void *)&v54 + 1) + 8 * i);
          unsigned __int8 v9 = [v8 priorityIsAtLeast:v6];
          BOOL v10 = [v8 countryCode];
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          *(_OWORD *)__p = *(_OWORD *)buf;
          *(void *)&long long v53 = *(void *)&buf[16];
          BYTE8(v53) = v9;
          *(void *)long long buf = 0;
          __int16 v11 = sub_100046ED4((uint64_t)&v58, buf, __p);
          if (!*v11)
          {
            int v12 = operator new(0x40uLL);
            int v12[2] = *(_OWORD *)__p;
            *((void *)v12 + 6) = v53;
            __p[1] = 0;
            *(void *)&long long v53 = 0;
            __p[0] = 0;
            *((unsigned char *)v12 + 56) = BYTE8(v53);
            uint64_t v13 = *(void *)buf;
            *(void *)int v12 = 0;
            *((void *)v12 + 1) = 0;
            *((void *)v12 + 2) = v13;
            void *v11 = v12;
            if (*v58)
            {
              uint64_t v58 = (uint64_t **)*v58;
              int v12 = (_OWORD *)*v11;
            }
            sub_100046C90(v59, (uint64_t *)v12);
            ++v60;
          }
          if (SBYTE7(v53) < 0) {
            operator delete(__p[0]);
          }
        }
        id v4 = [v3 countByEnumeratingWithState:&v54 objects:v61 count:16];
      }
      while (v4);
    }

    if (v60)
    {
      uint32_t v14 = v58;
      if (v58 != &v59)
      {
        int v15 = v2;
        do
        {
          *(_OWORD *)__p = 0u;
          long long v53 = 0u;
          if (*((char *)v14 + 55) < 0)
          {
            sub_10004FC84(__p, v14[4], (unint64_t)v14[5]);
          }
          else
          {
            *(_OWORD *)__p = *((_OWORD *)v14 + 2);
            *(void *)&long long v53 = v14[6];
          }
          int v16 = *((unsigned __int8 *)v14 + 56);
          BYTE8(v53) = *((unsigned char *)v14 + 56);
          uint64_t v17 = a1[5];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v18 = __p;
            if (SBYTE7(v53) < 0) {
              uint64_t v18 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v16;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Country : %s : %{BOOL}d", buf, 0x12u);
          }
          uint64_t v2 = v15;
          if (SBYTE7(v53) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v19 = v14[1];
          if (v19)
          {
            do
            {
              unsigned int v20 = (uint64_t **)v19;
              uint64_t v19 = (uint64_t *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              unsigned int v20 = (uint64_t **)v14[2];
              BOOL v21 = *v20 == (uint64_t *)v14;
              uint32_t v14 = v20;
            }
            while (!v21);
          }
          uint32_t v14 = v20;
        }
        while (v20 != &v59);
      }
    }
    else
    {
      uint64_t v23 = a1[5];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No known countries from RD!!", (uint8_t *)__p, 2u);
      }
    }
    uint64_t v24 = a1[18];
    if (v24 == v60)
    {
      long long v25 = (unsigned __int8 *)a1[16];
      if (v25 == (unsigned __int8 *)(a1 + 17)) {
        goto LABEL_98;
      }
      CFComparisonResult v26 = v58;
      while (RegulatoryCountry::operator==(v25 + 32, (unsigned __int8 *)v26 + 32))
      {
        long long v27 = (unsigned __int8 *)*((void *)v25 + 1);
        BOOL v28 = v25;
        if (v27)
        {
          do
          {
            long long v25 = v27;
            long long v27 = *(unsigned __int8 **)v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            long long v25 = (unsigned __int8 *)*((void *)v28 + 2);
            BOOL v21 = *(void *)v25 == (void)v28;
            BOOL v28 = v25;
          }
          while (!v21);
        }
        uint64_t v29 = v26[1];
        if (v29)
        {
          do
          {
            long long v30 = (uint64_t **)v29;
            uint64_t v29 = (uint64_t *)*v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            long long v30 = (uint64_t **)v26[2];
            BOOL v21 = *v30 == (uint64_t *)v26;
            CFComparisonResult v26 = v30;
          }
          while (!v21);
        }
        CFComparisonResult v26 = v30;
        if (v25 == (unsigned __int8 *)(a1 + 17)) {
          goto LABEL_98;
        }
      }
    }
    uint64_t v31 = (uint64_t **)(a1 + 16);
    if (a1 + 16 != &v58)
    {
      uint64_t v32 = v58;
      if (v24)
      {
        __int16 v34 = (uint64_t **)(a1 + 17);
        uint64_t v33 = a1[17];
        unsigned int v35 = (char *)a1[16];
        a1[16] = a1 + 17;
        *(void *)(v33 + 16) = 0;
        a1[17] = 0;
        a1[18] = 0;
        if (*((void *)v35 + 1)) {
          OsLogContext v36 = (char *)*((void *)v35 + 1);
        }
        else {
          OsLogContext v36 = v35;
        }
        __p[0] = a1 + 16;
        __p[1] = v36;
        *(void *)&long long v53 = v36;
        if (v36)
        {
          __p[1] = sub_1000EA590((uint64_t)v36);
          if (v32 == &v59)
          {
            long long v42 = &v59;
          }
          else
          {
            do
            {
              std::string::operator=((std::string *)(v36 + 32), (const std::string *)(v32 + 4));
              v36[56] = *((unsigned char *)v32 + 56);
              char v37 = (uint64_t *)v53;
              uint64_t v38 = *v34;
              char v39 = (uint64_t **)(a1 + 17);
              v40 = (uint64_t **)(a1 + 17);
              if (*v34)
              {
                do
                {
                  while (1)
                  {
                    char v39 = (uint64_t **)v38;
                    if ((sub_100046FE8(v37 + 4, (void **)v38 + 4) & 0x80) == 0) {
                      break;
                    }
                    uint64_t v38 = *v39;
                    v40 = v39;
                    if (!*v39) {
                      goto LABEL_69;
                    }
                  }
                  uint64_t v38 = v39[1];
                }
                while (v38);
                v40 = v39 + 1;
              }
LABEL_69:
              sub_100046C38(v31, (uint64_t)v39, v40, v37);
              OsLogContext v36 = (char *)__p[1];
              *(void **)&long long v53 = __p[1];
              if (__p[1]) {
                __p[1] = sub_1000EA590((uint64_t)__p[1]);
              }
              int64_t v41 = v32[1];
              if (v41)
              {
                do
                {
                  long long v42 = (uint64_t **)v41;
                  int64_t v41 = (uint64_t *)*v41;
                }
                while (v41);
              }
              else
              {
                do
                {
                  long long v42 = (uint64_t **)v32[2];
                  BOOL v21 = *v42 == (uint64_t *)v32;
                  uint64_t v32 = v42;
                }
                while (!v21);
              }
              if (!v36) {
                break;
              }
              uint64_t v32 = v42;
            }
            while (v42 != &v59);
          }
        }
        else
        {
          long long v42 = v32;
        }
        sub_1000EA5E4((uint64_t)__p);
        uint64_t v32 = v42;
      }
      if (v32 != &v59)
      {
        v43 = (uint64_t **)(a1 + 17);
        do
        {
          __p[0] = 0;
          __p[1] = 0;
          *(void *)&long long v53 = 0;
          sub_100C0D0D8((uint64_t)v31, (uint64_t)(v32 + 4), __p);
          uint64_t v44 = *v43;
          v45 = (uint64_t **)(a1 + 17);
          uint64_t v46 = (uint64_t **)(a1 + 17);
          if (*v43)
          {
            uint64_t v47 = (char *)__p[0] + 32;
            do
            {
              while (1)
              {
                v45 = (uint64_t **)v44;
                if ((sub_100046FE8(v47, (void **)v44 + 4) & 0x80) == 0) {
                  break;
                }
                uint64_t v44 = *v45;
                uint64_t v46 = v45;
                if (!*v45) {
                  goto LABEL_90;
                }
              }
              uint64_t v44 = v45[1];
            }
            while (v44);
            uint64_t v46 = v45 + 1;
          }
LABEL_90:
          sub_100046C38(v31, (uint64_t)v45, v46, (uint64_t *)__p[0]);
          v48 = v32[1];
          if (v48)
          {
            do
            {
              v49 = (uint64_t **)v48;
              v48 = (uint64_t *)*v48;
            }
            while (v48);
          }
          else
          {
            do
            {
              v49 = (uint64_t **)v32[2];
              BOOL v21 = *v49 == (uint64_t *)v32;
              uint64_t v32 = v49;
            }
            while (!v21);
          }
          uint64_t v32 = v49;
        }
        while (v49 != &v59);
      }
    }
    uint64_t v50 = a1[15];
    if (v50) {
      (*(void (**)(uint64_t, uint64_t **))(*(void *)v50 + 48))(v50, v31);
    }
  }
  else
  {
    xpc_object_t v22 = a1[5];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No country estimates available from RD!!", (uint8_t *)__p, 2u);
    }
  }
LABEL_98:

  sub_10005CD2C((uint64_t)&v58, (char *)v59);
}

void sub_100F5D868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,char *a27)
{
  sub_10005CD2C((uint64_t)&a26, a27);
  _Unwind_Resume(a1);
}

void *sub_100F5D904(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F5D98C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F5D9C4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F5D9F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100F5DA38(ServiceManager::Service *this)
{
  *(void *)this = off_101A737F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F5DA94(ServiceManager::Service *this)
{
  *(void *)this = off_101A737F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F5DB04@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TelephonyRegulatoryDomain");
}

unsigned char *sub_100F5DB14@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F5DB50(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  id v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F5CFF4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F5CFF4(v4, 0);
}

uint64_t sub_100F5DBD4()
{
  return 0;
}

uint64_t sub_100F5DBDC()
{
  return 1;
}

uint64_t sub_100F5DBE4()
{
  return 0;
}

void sub_100F5DBF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F5DCD0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group, this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F5DDF8(void ***a1)
{
  uint64_t v1 = a1;
  sub_100F5D190(**a1);
  operator delete();
}

void sub_100F5DE4C()
{
}

uint64_t *sub_100F5DE78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Start regulatory domain service !", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v17, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v4 = (uint8_t *)(v2 + 96);
  *(void *)long long buf = off_101A73878;
  uint64_t v20 = v2 + 80;
  BOOL v21 = buf;
  if (buf != (uint8_t *)(v2 + 96))
  {
    uint64_t v5 = *(uint8_t **)(v2 + 120);
    if (v5 == v4)
    {
      __p[1] = (void *)(v2 + 80);
      uint64_t v23 = 0;
      BOOL v21 = 0;
      __p[0] = off_101A73878;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 24))(v2 + 96, buf);
      (*(void (**)(void))(**(void **)(v2 + 120) + 32))(*(void *)(v2 + 120));
      *(void *)(v2 + 120) = 0;
      BOOL v21 = buf;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, v2 + 96);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(v2 + 96) = off_101A73878;
      *(void *)(v2 + 104) = v2 + 80;
      BOOL v21 = v5;
    }
    *(void *)(v2 + 120) = v4;
  }
  sub_100F5D904(buf);
  uint64_t v6 = *(void *)(v2 + 120);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v2 + 128);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  *(void *)long long buf = off_101A73908;
  uint64_t v20 = v2;
  BOOL v21 = buf;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v7 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v7 || (v8 = *(uint64_t **)(v2 + 64), uint64_t v9 = *(void *)(v2 + 8), (v10 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  __int16 v11 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  int v12 = (uint8_t *)operator new(0x20uLL);
  uint64_t v13 = kRegulatoryDomainUpdateNotification;
  *(void *)int v12 = off_101A73988;
  *((void *)v12 + 1) = v2;
  *((void *)v12 + 2) = v9;
  *((void *)v12 + 3) = v11;
  BOOL v21 = v12;
  sub_100F017C8(v8, v13, (uint64_t)buf);
  sub_1001472DC(buf);
  sub_100088C88(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100F5E1AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F5E230()
{
}

void *sub_100F5E244(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A73878;
  result[1] = v3;
  return result;
}

uint64_t sub_100F5E28C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A73878;
  a2[1] = v2;
  return result;
}

void sub_100F5E2B8(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  xpc_object_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      ctu::rest::write_rest_value<RegulatoryCountry>((uint64_t)(v6 + 4), value);
      xpc_array_append_value(v4, value[0]);
      xpc_release(value[0]);
      id v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          id v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v11 = v4;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(value, "/cc/props/regulatory_domain_country_list");
  xpc_object_t object = v11;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v14 < 0) {
    operator delete(value[0]);
  }
  xpc_release(v11);
}

void sub_100F5E44C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100F5E4D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5E510()
{
}

void sub_100F5E520()
{
}

void *sub_100F5E534(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A73908;
  result[1] = v3;
  return result;
}

uint64_t sub_100F5E57C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A73908;
  a2[1] = v2;
  return result;
}

void sub_100F5E5A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void **)(v1 + 128);
  if (v2 != (void *)(v1 + 136))
  {
    do
    {
      uint64_t v3 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v4 = v2 + 4;
        if (*((char *)v2 + 55) < 0) {
          xpc_object_t v4 = (void *)*v4;
        }
        int v5 = *((unsigned __int8 *)v2 + 56);
        *(_DWORD *)long long buf = 136315394;
        BOOL v10 = v4;
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I RD ISO : '%s' : atleastLoc : %{BOOL}d", buf, 0x12u);
      }
      uint64_t v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          xpc_object_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          xpc_object_t v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          uint64_t v2 = v7;
        }
        while (!v8);
      }
      uint64_t v2 = v7;
    }
    while (v7 != (void *)(v1 + 136));
  }
}

uint64_t sub_100F5E6D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5E714()
{
}

void *sub_100F5E720(void *a1)
{
  *a1 = off_101A73988;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F5E76C(void *a1)
{
  *a1 = off_101A73988;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100F5E7D8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A73988;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F5E83C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A73988;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F5E87C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F5E88C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F5E8CC(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  xpc_object_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v5 = (void *)a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      xpc_object_t v7 = v6;
      if (a1[2])
      {
        BOOL v8 = v5[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received RD notification", v9, 2u);
        }
        sub_100F5D190(v5);
      }
      sub_10004D2C8(v7);
    }
  }
  xpc_release(v3);
}

void sub_100F5E980(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F5E9A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5E9E8()
{
}

uint64_t *sub_100F5E9F4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 80));
  sub_100F018AC(*(void *)(v2 + 64));
  sub_100113010(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100F5EA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

const char *sub_100F5EA6C(unsigned int a1)
{
  unsigned int v3 = a1;
  if (!qword_101B13F40) {
    sub_100F5EAC8();
  }
  uint64_t v1 = sub_100F5F778((void *)qword_101B13F40, &v3);
  if (v1) {
    return *(const char **)(v1[3] + 8);
  }
  else {
    return "UNKNOWN";
  }
}

void sub_100F5EAC8()
{
}

void sub_100F5EC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F5EC24(unsigned int a1)
{
  unsigned int v3 = a1;
  if (!qword_101B13F40) {
    sub_100F5EAC8();
  }
  uint64_t v1 = sub_100F5F778((void *)qword_101B13F40, &v3);
  if (v1) {
    return *(unsigned int *)(v1[3] + 4);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL sub_100F5EC7C(uint64_t a1, char *__s)
{
  unsigned int v3 = (void *)qword_101B13F48;
  if (!qword_101B13F48) {
    sub_100F5EAC8();
  }
  sub_100058DB0(__p, __s);
  unint64_t v4 = sub_100206390((uint64_t)(v3 + 3), (uint64_t)__p);
  int8x8_t v5 = (int8x8_t)v3[1];
  if (!*(void *)&v5) {
    goto LABEL_21;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  BOOL v10 = *(unsigned __int8 ***)(*v3 + 8 * v9);
  if (v10)
  {
    __int16 v11 = *v10;
    if (*v10)
    {
      uint64_t v12 = (uint64_t)(v3 + 4);
      do
      {
        unint64_t v13 = *((void *)v11 + 1);
        if (v13 == v6)
        {
          if (sub_1000609C0(v12, v11 + 16, (unsigned __int8 *)__p)) {
            break;
          }
        }
        else
        {
          if (v8 > 1)
          {
            if (v13 >= *(void *)&v5) {
              v13 %= *(void *)&v5;
            }
          }
          else
          {
            v13 &= *(void *)&v5 - 1;
          }
          if (v13 != v9) {
            goto LABEL_21;
          }
        }
        __int16 v11 = *(unsigned __int8 **)v11;
      }
      while (v11);
    }
  }
  else
  {
LABEL_21:
    __int16 v11 = 0;
  }
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if (v11) {
      goto LABEL_24;
    }
LABEL_26:
    int v14 = 0;
    goto LABEL_27;
  }
  if (!v11) {
    goto LABEL_26;
  }
LABEL_24:
  int v14 = **((_DWORD **)v11 + 5);
LABEL_27:
  *(_DWORD *)(a1 + 20) = v14;
  return v14 != 0;
}

uint64_t sub_100F5EDDC(uint64_t a1, std::string *a2)
{
  unsigned int v3 = (char *)sub_100F5EA6C(*(_DWORD *)(a1 + 20));
  if (v3)
  {
    sub_10003ED78(a2, v3);
  }
  else
  {
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      a2->__r_.__value_.__l.__size_ = 0;
      a2 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    else
    {
      *((unsigned char *)&a2->__r_.__value_.__s + 23) = 0;
    }
    a2->__r_.__value_.__s.__data_[0] = 0;
  }
  return 1;
}

void sub_100F5EE38()
{
}

void sub_100F5EE98()
{
}

const char *sub_100F5EEFC()
{
  return "charset";
}

void sub_100F5EF0C()
{
}

void *sub_100F5EF20(float *a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
    BOOL v10 = *(void ***)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      __int16 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
            if (*((_DWORD *)v11 + 4) == v6) {
              return v11;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }
            else
            {
              v12 &= v7 - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
          __int16 v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  __int16 v11 = operator new(0x20uLL);
  void *v11 = 0;
  v11[1] = v6;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v9;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      __int16 v34 = *(void **)a1;
      *(void *)a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    sub_10006A7CC();
  }
  uint64_t v19 = operator new(8 * *(void *)&prime);
  uint64_t v20 = *(void **)a1;
  *(void *)a1 = v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  xpc_object_t v22 = (void *)*((void *)a1 + 2);
  if (v22)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
    BOOL v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*(void *)a1 + 8 * v29))
          {
            *(void *)(*(void *)a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          void *v22 = *v28;
          *BOOL v28 = **(void **)(*(void *)a1 + 8 * v29);
          **(void **)(*(void *)a1 + 8 * v29) = v28;
          BOOL v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        xpc_object_t v22 = v28;
        BOOL v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  long long v30 = *(void **)a1;
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v6);
  if (v31)
  {
    void *v11 = *v31;
LABEL_72:
    *uint64_t v31 = v11;
    goto LABEL_73;
  }
  void *v11 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v11;
  v30[v6] = a1 + 4;
  if (*v11)
  {
    unint64_t v32 = *(void *)(*v11 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v11;
}

void sub_100F5F314(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100F5F328(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  unint64_t v7 = a1 + 3;
  unint64_t v8 = sub_100206390((uint64_t)(a1 + 3), (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = a1[1];
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v13 = v8;
      if (v8 >= v10) {
        unint64_t v13 = v8 % v10;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v8;
    }
    float v14 = *(void ***)(*a1 + 8 * v13);
    if (v14)
    {
      for (i = *v14; i; i = *(void **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v9)
        {
          if (sub_1000609C0((uint64_t)(a1 + 4), (unsigned __int8 *)i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v16 >= v10) {
              v16 %= v10;
            }
          }
          else
          {
            v16 &= v10 - 1;
          }
          if (v16 != v13) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v13 = 0;
  }
  unint64_t v17 = a1 + 2;
  i = operator new(0x30uLL);
  *(void *)i = 0;
  *((void *)i + 1) = v9;
  uint64_t v18 = *a4;
  long long v19 = **a4;
  *((void *)i + 4) = *((void *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *(void *)uint64_t v18 = 0;
  *((void *)i + 5) = 0;
  float v20 = (float)(unint64_t)(a1[3] + 1);
  float v21 = *((float *)a1 + 8);
  if (!v10 || (float)(v21 * (float)v10) < v20)
  {
    BOOL v22 = 1;
    if (v10 >= 3) {
      BOOL v22 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v10);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v10 = a1[1];
    if (*(void *)&prime > v10) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v10)
    {
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v10 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v10)
      {
        unint64_t v10 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_10006A7CC();
          }
          uint8x8_t v26 = operator new(8 * *(void *)&prime);
          uint64_t v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v28++) = 0;
          while (*(void *)&prime != v28);
          unint64_t v29 = (void *)*v17;
          if (*v17)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }
            else
            {
              v30 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v30) = v17;
            unsigned int v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }
                else
                {
                  v36 &= *(void *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(void *)(*a1 + 8 * v36))
                  {
                    *(void *)(*a1 + 8 * v36) = v29;
                    goto LABEL_55;
                  }
                  *unint64_t v29 = *v35;
                  void *v35 = **(void **)(*a1 + 8 * v36);
                  **(void **)(*a1 + 8 * v36) = v35;
                  unsigned int v35 = v29;
                }
                unint64_t v36 = v30;
LABEL_55:
                unint64_t v29 = v35;
                unsigned int v35 = (void *)*v35;
                unint64_t v30 = v36;
              }
              while (v35);
            }
          }
          unint64_t v10 = (unint64_t)prime;
          goto LABEL_59;
        }
        int64_t v41 = (void *)*a1;
        *a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v10 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v13 = v9 % v10;
      }
      else {
        unint64_t v13 = v9;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v9;
    }
  }
  uint64_t v37 = *a1;
  uint64_t v38 = *(void **)(*a1 + 8 * v13);
  if (v38)
  {
    *(void *)i = *v38;
LABEL_72:
    *uint64_t v38 = i;
    goto LABEL_73;
  }
  *(void *)i = *v17;
  void *v17 = i;
  *(void *)(v37 + 8 * v13) = v17;
  if (*(void *)i)
  {
    unint64_t v39 = *(void *)(*(void *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v39 >= v10) {
        v39 %= v10;
      }
    }
    else
    {
      v39 &= v10 - 1;
    }
    uint64_t v38 = (void *)(*a1 + 8 * v39);
    goto LABEL_72;
  }
LABEL_73:
  ++*v7;
  return i;
}

void sub_100F5F760(_Unwind_Exception *a1)
{
  sub_1003606B8(1, v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F5F778(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

void sub_100F5F82C(void *a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "set.cdma.fwd");
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v6 = *a3;
  a1[3] = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  v12[0] = off_101999E18;
  v12[1] = sub_100F60010;
  v12[3] = v12;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v12);
  *a1 = off_101A73B18;
  a1[7] = *a2;
  uint64_t v8 = a2[1];
  a1[8] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v9 = a1[3];
  v10[8] = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  sub_101020664();
}

void sub_100F5FE24(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, dispatch_object_t object,dispatch_object_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
}

const char *sub_100F60010(int a1)
{
  uint64_t v1 = "set.cdma.fwd.?";
  if (a1 == 2) {
    uint64_t v1 = "set.cdma.fwd.2";
  }
  if (a1 == 1) {
    return "set.cdma.fwd.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100F6003C(uint64_t a1)
{
  uint64_t v2 = 576;
  do
  {
    uint64_t v3 = a1 + v2;
    if (*(char *)(a1 + v2 - 25) < 0) {
      operator delete(*(void **)(v3 - 48));
    }
    if (*(char *)(v3 - 49) < 0) {
      operator delete(*(void **)(a1 + v2 - 72));
    }
    uint64_t v4 = a1 + v2;
    if (*(char *)(a1 + v2 - 81) < 0) {
      operator delete(*(void **)(v4 - 104));
    }
    if (*(char *)(v4 - 105) < 0) {
      operator delete(*(void **)(a1 + v2 - 128));
    }
    v2 -= 144;
  }
  while (v2);
  return a1;
}

uint64_t sub_100F600C4(uint64_t a1)
{
  *(void *)a1 = off_101A73B18;
  sub_100571DA4(a1 + 184, *(const void ***)(a1 + 192));
  sub_100F61E20(*(void **)(a1 + 168));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100087F94(a1 + 112, *(void **)(a1 + 120));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F60198(uint64_t a1)
{
  sub_100F600C4(a1);

  operator delete();
}

void sub_100F601D0(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v34, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_10057A438(a1 + 104);
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A73C30;
  v2[1] = a1 + 112;
  v2[2] = a1;
  v2[3] = sub_100F606E0;
  v2[4] = 0;
  v43 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v41);
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  sub_1002D795C(a1 + 136);
  subscriber::makeSimSlotRange();
  uint64_t v3 = v31;
  if (v31 == v32) {
    return;
  }
  while ((v33(*v3) & 1) == 0)
  {
    if (++v3 == v32)
    {
      uint64_t v3 = v32;
      break;
    }
  }
  if (v3 == v32) {
    return;
  }
  uint64_t v4 = (uint64_t **)(a1 + 160);
  do
  {
    int v40 = *v3;
    int v5 = v40;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v39 = 0;
    sub_10102024C(v40, __p);
    unint64_t v6 = 0x1FFFFFFFFFFFFFB8;
    unint64_t v7 = off_101A73A88;
    uint64_t v8 = off_101A73AA8;
    do
    {
      unsigned __int8 v37 = 0;
      uint64_t v9 = sub_100365D74();
      std::operator+<char>();
      BOOL v10 = sub_100571C98(v9, &v41, &v37);
      BOOL v11 = v10;
      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41);
        if (!v11) {
          goto LABEL_17;
        }
LABEL_16:
        int v12 = v37;
        LOBYTE(sub_100F61EF8(v4, v5, &v40)[v6 + 77]) = v12 != 0;
        goto LABEL_17;
      }
      if (v10) {
        goto LABEL_16;
      }
LABEL_17:
      memset(&v36, 0, sizeof(v36));
      uint64_t v13 = sub_100365D74();
      std::operator+<char>();
      BOOL v14 = sub_100226284(v13, &v41, &v36);
      BOOL v15 = v14;
      if (SHIBYTE(v42) < 0)
      {
        operator delete(v41);
        if (!v15) {
          goto LABEL_37;
        }
      }
      else if (!v14)
      {
        goto LABEL_37;
      }
      CSIPhoneNumber::CSIPhoneNumber();
      unint64_t v16 = sub_100F61EF8(v4, v5, &v40);
      unint64_t v17 = &v16[v6];
      v16[v6 + 78] = (uint64_t)v41;
      uint64_t v18 = (void **)&v16[v6 + 79];
      if (SHIBYTE(v16[v6 + 81]) < 0) {
        operator delete(*v18);
      }
      long long v19 = v42;
      v16[v6 + 81] = (uint64_t)v43;
      *(_OWORD *)uint64_t v18 = v19;
      HIBYTE(v43) = 0;
      LOBYTE(v42) = 0;
      float v20 = (void **)(v17 + 82);
      if (*((char *)v17 + 679) < 0) {
        operator delete(*v20);
      }
      long long v21 = v44;
      v17[84] = v45;
      *(_OWORD *)float v20 = v21;
      HIBYTE(v45) = 0;
      LOBYTE(v44) = 0;
      BOOL v22 = &v16[v6];
      char v23 = v47;
      *((_DWORD *)v22 + 170) = v46;
      *((unsigned char *)v22 + 684) = v23;
      unint64_t v24 = (void **)&v16[v6 + 86];
      if (SHIBYTE(v16[v6 + 88]) < 0) {
        operator delete(*v24);
      }
      long long v25 = v48;
      v16[v6 + 88] = v49;
      *(_OWORD *)unint64_t v24 = v25;
      HIBYTE(v49) = 0;
      LOBYTE(v48) = 0;
      uint8x8_t v26 = (void **)(v22 + 89);
      if (*((char *)v22 + 735) < 0) {
        operator delete(*v26);
      }
      long long v27 = v50;
      v22[91] = v51;
      *(_OWORD *)uint8x8_t v26 = v27;
      HIBYTE(v51) = 0;
      LOBYTE(v50) = 0;
      uint64_t v28 = &v16[v6];
      long long v29 = v52;
      *((unsigned char *)v28 + 752) = v53;
      *((_OWORD *)v28 + 46) = v29;
      if (SHIBYTE(v51) < 0) {
        operator delete((void *)v50);
      }
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)v48);
      }
      if (SHIBYTE(v45) < 0) {
        operator delete((void *)v44);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)v42);
      }
LABEL_37:
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      ++v8;
      ++v7;
      v6 += 18;
    }
    while (v6 * 8);
    if (SHIBYTE(v39) < 0) {
      operator delete(__p[0]);
    }
    unint64_t v30 = v3 + 1;
    uint64_t v3 = v32;
    if (v30 != v32)
    {
      uint64_t v3 = v30;
      while ((v33(*v3) & 1) == 0)
      {
        if (++v3 == v32)
        {
          uint64_t v3 = v32;
          break;
        }
      }
    }
  }
  while (v3 != v32);
}

void sub_100F60634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F606E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 112);
  uint64_t v3 = (void *)(a1 + 120);
  if (v2 != (void *)(a1 + 120))
  {
    int v5 = (void *)(a2 + 8);
    unint64_t v6 = (void *)(a1 + 192);
    uint64_t v39 = (void *)(a1 + 120);
    do
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *((unsigned int *)v2 + 8);
      if (*v5)
      {
        uint64_t v9 = v5;
        do
        {
          int v10 = *(_DWORD *)(v7 + 32);
          BOOL v11 = v10 < (int)v8;
          if (v10 >= (int)v8) {
            int v12 = (uint64_t *)v7;
          }
          else {
            int v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            uint64_t v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 != v5 && (int)v8 >= *((_DWORD *)v9 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_29;
          }
          uint64_t v8 = *((unsigned int *)v2 + 8);
        }
      }
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        uint64_t v15 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v43 = 2080;
        uint64_t v44 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle changed to %s (%s)", buf, 0x16u);
      }
      uint64_t v16 = *v6;
      if (*v6)
      {
        unint64_t v17 = v6;
        do
        {
          int v18 = *(_DWORD *)(v16 + 32);
          BOOL v19 = v18 < (int)v8;
          if (v18 >= (int)v8) {
            float v20 = (uint64_t *)v16;
          }
          else {
            float v20 = (uint64_t *)(v16 + 8);
          }
          if (!v19) {
            unint64_t v17 = (void *)v16;
          }
          uint64_t v16 = *v20;
        }
        while (*v20);
        if (v17 != v6 && *((_DWORD *)v17 + 8) <= (int)v8)
        {
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
          uint8x8_t v26 = ServiceMap;
          if (v27 < 0)
          {
            uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v29 = 5381;
            do
            {
              uint64_t v27 = v29;
              unsigned int v30 = *v28++;
              uint64_t v29 = (33 * v29) ^ v30;
            }
            while (v30);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long buf = v27;
          uint8x8_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
          if (v31)
          {
            uint64_t v33 = v31[3];
            unint64_t v32 = (std::__shared_weak_count *)v31[4];
            if (v32)
            {
              atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v26);
              atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v3 = v39;
              sub_10004D2C8(v32);
              char v34 = 0;
              if (!v33)
              {
LABEL_42:
                unsigned int v35 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not get CarrierSettingsInterface", buf, 2u);
                }
LABEL_49:
                if ((v34 & 1) == 0) {
                  sub_10004D2C8(v32);
                }
                goto LABEL_29;
              }
LABEL_46:
              (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v33 + 80))(&v40, v33, v8, 1, @"CallForwardingDialingCodes", 0, 0);
              sub_10004EFE4(&v41, &v40);
              std::string v36 = v17 + 5;
              if (v17 + 5 != &v41)
              {
                uint64_t v37 = *v36;
                uint64_t *v36 = v41;
                uint64_t v41 = 0;
                *(void *)long long buf = v37;
                sub_100057D78((const void **)buf);
              }
              sub_100057D78((const void **)&v41);
              sub_1000577C4(&v40);
              goto LABEL_49;
            }
          }
          else
          {
            uint64_t v33 = 0;
          }
          std::mutex::unlock(v26);
          unint64_t v32 = 0;
          char v34 = 1;
          if (!v33) {
            goto LABEL_42;
          }
          goto LABEL_46;
        }
      }
      long long v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v38;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
      }
LABEL_29:
      BOOL v22 = (void *)v2[1];
      if (v22)
      {
        do
        {
          char v23 = v22;
          BOOL v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          char v23 = (void *)v2[2];
          BOOL v24 = *v23 == (void)v2;
          uint64_t v2 = v23;
        }
        while (!v24);
      }
      uint64_t v2 = v23;
    }
    while (v23 != v3);
  }
}

void sub_100F60AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1000577C4((const void **)va);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(a1);
}

void sub_100F60AFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((int)a3 < 4)
  {
    uint64_t v10 = *(void *)(a1 + 168);
    if (!v10) {
      goto LABEL_18;
    }
    uint64_t v12 = a1 + 168;
    do
    {
      int v13 = *(_DWORD *)(v10 + 32);
      BOOL v14 = v13 < (int)a2;
      if (v13 >= (int)a2) {
        uint64_t v15 = (uint64_t *)v10;
      }
      else {
        uint64_t v15 = (uint64_t *)(v10 + 8);
      }
      if (!v14) {
        uint64_t v12 = v10;
      }
      uint64_t v10 = *v15;
    }
    while (*v15);
    if (v12 != a1 + 168 && *(_DWORD *)(v12 + 32) <= (int)a2)
    {
      uint64_t v17 = *(void *)(a1 + 72);
      uint64_t v18 = v12 + 144 * (int)a3;
      BOOL v19 = *(unsigned char *)(v18 + 40) != 0;
      sub_10009DB3C((uint64_t)v20, v18 + 48);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, void, unsigned char *))(*(void *)v17 + 32))(v17, a2, a3, a4, v19, 0, v20);
      if (v28 < 0) {
        operator delete(__p);
      }
      if (v26 < 0) {
        operator delete(v25);
      }
      if (v24 < 0) {
        operator delete(v23);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
    }
    else
    {
LABEL_18:
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v30 = subscriber::asString();
        char v8 = "Cannot find slot %s!!";
        uint64_t v9 = v16;
LABEL_29:
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, 0xCu);
      }
    }
  }
  else
  {
    unint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = "Call Forwarding Reason unknown";
      if (a3 == 4) {
        uint64_t v7 = "kCTCallForwardingReasonAll";
      }
      if (a3 == 5) {
        uint64_t v7 = "kCTCallForwardingReasonAllConditional";
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v30 = (uint64_t)v7;
      char v8 = "%s is not a valid reason for fetching call forwarding.";
      uint64_t v9 = v6;
      goto LABEL_29;
    }
  }
}

void sub_100F60D44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100087E24((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F60D60(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6 >= 4)
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v9 = "Call Forwarding Reason unknown";
    if (a6 == 4) {
      uint64_t v9 = "kCTCallForwardingReasonAll";
    }
    if (a6 == 5) {
      uint64_t v9 = "kCTCallForwardingReasonAllConditional";
    }
    int v20 = 136315138;
    uint64_t v21 = (uint64_t)v9;
    uint64_t v10 = "%s is not a valid reason for getting call forwarding.";
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&v20, 0xCu);
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 168);
  if (!v11) {
    goto LABEL_18;
  }
  uint64_t v13 = a1 + 168;
  do
  {
    int v14 = *(_DWORD *)(v11 + 32);
    BOOL v15 = v14 < (int)a2;
    if (v14 >= (int)a2) {
      uint64_t v16 = (uint64_t *)v11;
    }
    else {
      uint64_t v16 = (uint64_t *)(v11 + 8);
    }
    if (!v15) {
      uint64_t v13 = v11;
    }
    uint64_t v11 = *v16;
  }
  while (*v16);
  if (v13 == a1 + 168 || *(_DWORD *)(v13 + 32) > (int)a2)
  {
LABEL_18:
    uint64_t v7 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v20 = 136315138;
    uint64_t v21 = subscriber::asString();
    uint64_t v10 = "Cannot find slot %s!!";
    goto LABEL_20;
  }
  uint64_t v17 = v13 + 144 * a6;
  *a3 = *(unsigned char *)(v17 + 40);
  *(void *)a4 = *(void *)(v17 + 48);
  std::string::operator=((std::string *)(a4 + 8), (const std::string *)(v17 + 56));
  std::string::operator=((std::string *)(a4 + 32), (const std::string *)(v17 + 80));
  char v18 = *(unsigned char *)(v17 + 108);
  *(_DWORD *)(a4 + 56) = *(_DWORD *)(v17 + 104);
  *(unsigned char *)(a4 + 60) = v18;
  std::string::operator=((std::string *)(a4 + 64), (const std::string *)(v17 + 112));
  std::string::operator=((std::string *)(a4 + 88), (const std::string *)(v17 + 136));
  char v19 = *(unsigned char *)(v17 + 176);
  *(_OWORD *)(a4 + 112) = *(_OWORD *)(v17 + 160);
  *(unsigned char *)(a4 + 128) = v19;
  return 1;
}

void sub_100F60F5C(uint64_t a1, unsigned int a2, int a3, CSIPhoneNumber *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v59 = a2;
  uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CSIPhoneNumber::getFullNumber((uint64_t *)&__p, a4);
    uint64_t v13 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    buf.var0 = 67109634;
    buf.var1 = a3;
    *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_ = 2080;
    *(char **)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 2) = (char *)v13;
    WORD1(buf.var2.__r_.__value_.var0.var1.__size_) = 1024;
    HIDWORD(buf.var2.__r_.__value_.var0.var1.__size_) = a6;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I saveCallForwardingValue: Enabled: %d, FwdNumber: %s, FwdReason: %d", (uint8_t *)&buf, 0x18u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if ((int)a6 >= 5)
  {
    int v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v59);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      BOOL v15 = "Call Forwarding Reason unknown";
      if (a6 == 5) {
        BOOL v15 = "kCTCallForwardingReasonAllConditional";
      }
      buf.var0 = 136315138;
      *(void *)&buf.var1 = v15;
      uint64_t v16 = "%s is not a valid reason for saving call forwarding.";
      uint64_t v17 = v14;
      goto LABEL_25;
    }
    return;
  }
  if (!*(unsigned char *)(a1 + 104))
  {
LABEL_26:
    (*(void (**)(void, void, uint64_t, uint64_t, void))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72), v59, a6, a7, 0);
    return;
  }
  uint64_t v18 = *(void *)(a1 + 168);
  if (v18)
  {
    uint64_t v19 = a1 + 168;
    do
    {
      signed int v20 = *(_DWORD *)(v18 + 32);
      BOOL v21 = v20 < (int)v59;
      if (v20 >= (int)v59) {
        char v22 = (uint64_t *)v18;
      }
      else {
        char v22 = (uint64_t *)(v18 + 8);
      }
      if (!v21) {
        uint64_t v19 = v18;
      }
      uint64_t v18 = *v22;
    }
    while (*v22);
    if (v19 != a1 + 168 && (signed int)v59 >= *(_DWORD *)(v19 + 32))
    {
      if (!*(unsigned char *)(a1 + 136))
      {
        *(void *)&buf.var0 = &v59;
        if (sub_100571E00((uint64_t **)(a1 + 184), (int *)&v59, (uint64_t)&unk_10144E20E, &buf)[5] ? sub_100080778 : 0)
        {
          memset(&__p, 0, sizeof(__p));
          long long v56 = 0;
          long long v57 = 0uLL;
          if (a3) {
            CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, a4);
          }
          else {
            sub_100058DB0(&buf, "");
          }
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&buf.var0;
          __p.__r_.__value_.__r.__words[2] = buf.var2.__r_.__value_.var0.var1.__size_;
          uint64_t v27 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
          if (a6 == 4)
          {
            char v28 = *(NSObject **)v27();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.var0) = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Call forwarding reason: All", (uint8_t *)&buf, 2u);
            }
            if (a3) {
              __TUAssertTrigger();
            }
            for (uint64_t i = 0; i != 576; i += 144)
            {
              *(unsigned char *)(v19 + i + 40) = a3;
              CSIPhoneNumber::CSIPhoneNumber(&buf, "");
              *(void *)(v19 + i + 48) = *(void *)&buf.var0;
              uint64_t v30 = (void **)(v19 + i + 56);
              if (*(char *)(v19 + i + 79) < 0) {
                operator delete(*v30);
              }
              long long v31 = *(_OWORD *)buf.var2.__r_.__value_.var0.var0.__data_;
              *(void *)(v19 + i + 72) = *((void *)&buf.var2.__r_.__value_.var0.var1 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              *((unsigned char *)&buf.var2.__r_.__value_.var0.var1 + 23) = 0;
              buf.var2.__r_.__value_.var0.var0.__data_[0] = 0;
              uint64_t v32 = v19 + i;
              uint64_t v33 = (void **)(v19 + i + 80);
              if (*(char *)(v19 + i + 103) < 0) {
                operator delete(*v33);
              }
              long long v34 = *(_OWORD *)&buf.var2.__r_.var0;
              *(void *)(v19 + i + 96) = v62;
              *(_OWORD *)uint64_t v33 = v34;
              HIBYTE(v62) = 0;
              LOBYTE(buf.var2.__r_.var0) = 0;
              char v35 = v64;
              *(_DWORD *)(v32 + 104) = v63;
              *(unsigned char *)(v32 + 108) = v35;
              std::string v36 = (void **)(v32 + 112);
              if (*(char *)(v32 + 135) < 0) {
                operator delete(*v36);
              }
              char v37 = 0;
              long long v38 = v65;
              *(void *)(v32 + 128) = v66;
              *(_OWORD *)std::string v36 = v38;
              HIBYTE(v66) = 0;
              LOBYTE(v65) = 0;
              uint64_t v39 = v19 + i;
              int v40 = (void **)(v19 + i + 136);
              if (*(char *)(v19 + i + 159) < 0)
              {
                operator delete(*v40);
                char v37 = HIBYTE(v66);
              }
              long long v41 = v67;
              *(void *)(v19 + i + 152) = v68;
              *(_OWORD *)int v40 = v41;
              HIBYTE(v68) = 0;
              LOBYTE(v67) = 0;
              long long v42 = v69;
              *(unsigned char *)(v39 + 176) = v70;
              *(_OWORD *)(v39 + 160) = v42;
              if (v37 < 0) {
                operator delete((void *)v65);
              }
              if (SHIBYTE(v62) < 0) {
                operator delete(*(void **)&buf.var2.__r_.var0);
              }
              if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
                operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
              }
            }
            *(void *)&buf.var0 = &v59;
            __int16 v43 = sub_100571E00((uint64_t **)(a1 + 184), (int *)&v59, (uint64_t)&unk_10144E20E, &buf);
            CFDictionaryGetValue((CFDictionaryRef)v43[5], @"DisableCallForwarding");
            memset(&buf, 0, 24);
            ctu::cf::assign();
          }
          else
          {
            uint64_t v44 = *(NSObject **)v27();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.var0) = 0;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Call forwarding reason: Custom", (uint8_t *)&buf, 2u);
            }
            uint64_t v45 = v19 + 144 * (int)a6;
            *(unsigned char *)(v45 + 40) = a3;
            sub_100E09E00(v45 + 48, (uint64_t)a4);
            int v46 = off_101A73AC8;
            if (a3) {
              int v46 = off_101A73AE8;
            }
            char v47 = v46[(int)a6];
            *(void *)&buf.var0 = &v59;
            long long v48 = sub_100571E00((uint64_t **)(a1 + 184), (int *)&v59, (uint64_t)&unk_10144E20E, &buf);
            CFDictionaryGetValue((CFDictionaryRef)v48[5], v47);
            memset(&buf, 0, 24);
            ctu::cf::assign();
          }
          uint64_t v49 = *(void **)&buf.var0;
          v60[0] = buf.var2.__r_.__value_.var0.var1.__data_;
          *(void *)((char *)v60 + 7) = *(char **)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 7);
          unsigned int v50 = buf.var2.__r_.__value_.var0.var0.__data_[15];
          if (SHIBYTE(v57) < 0) {
            operator delete(v56);
          }
          long long v56 = v49;
          *(void *)&long long v57 = v60[0];
          *(void *)((char *)&v57 + 7) = *(void *)((char *)v60 + 7);
          HIBYTE(v57) = v50;
          sub_100F617F4(a1, v59);
          if ((v50 & 0x80u) == 0) {
            uint64_t v51 = &v56;
          }
          else {
            uint64_t v51 = (void **)v49;
          }
          if ((v50 & 0x80u) == 0) {
            std::string::size_type v52 = v50;
          }
          else {
            std::string::size_type v52 = v57;
          }
          std::string::insert(&__p, 0, (const std::string::value_type *)v51, v52);
          char v53 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v59);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            long long v54 = &v56;
            if (v57 < 0) {
              long long v54 = v56;
            }
            p_p = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            buf.var0 = 136315394;
            *(void *)&buf.var1 = v54;
            WORD2(buf.var2.__r_.__value_.var0.var1.__data_) = 2080;
            *(char **)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 6) = (char *)p_p;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Prefix: %s, FinalBaseNumber: %s", (uint8_t *)&buf, 0x16u);
          }
          sub_100F6198C(a1, v59, (uint64_t *)&__p, a6);
          if (SHIBYTE(v57) < 0) {
            operator delete(v56);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          return;
        }
      }
      long long v25 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I saveCallForwardingValue - Ongoing Voice call", (uint8_t *)&buf, 2u);
      }
      goto LABEL_26;
    }
  }
  char v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    uint64_t v24 = subscriber::asString();
    buf.var0 = 136315138;
    *(void *)&buf.var1 = v24;
    uint64_t v16 = "Cannot find slot %s!!";
    uint64_t v17 = v23;
LABEL_25:
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&buf, 0xCu);
  }
}

void sub_100F61784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F617F4(uint64_t a1, int a2)
{
  int v17 = a2;
  v15[0] = 0;
  v15[1] = 0;
  uint64_t v16 = 0;
  sub_10102024C(a2, v15);
  uint64_t v4 = (uint64_t **)(a1 + 160);
  int v5 = off_101A73AA8;
  uint64_t v6 = 6;
  uint64_t v7 = off_101A73A88;
  do
  {
    char v8 = (uint64_t **)sub_100365D74();
    std::operator+<char>();
    uint64_t v9 = sub_100F61EF8(v4, a2, &v17);
    sub_1002264FC(v8, &__p, (unsigned __int8 *)&v9[v6 - 1]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v10 = (uint64_t **)sub_100365D74();
    std::operator+<char>();
    uint64_t v11 = sub_100F61EF8(v4, a2, &v17);
    CSIPhoneNumber::getFullNumber((uint64_t *)v12, (CSIPhoneNumber *)&v11[v6]);
    sub_1002266A4(v10, &__p, (uint64_t)v12);
    if (v13 < 0) {
      operator delete(v12[0]);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    v6 += 18;
    ++v5;
    ++v7;
  }
  while (v6 != 78);
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void sub_100F61934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F6198C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  char v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = (uint64_t *)*a3;
    }
    *(_DWORD *)CSIPhoneNumber buf = 136315138;
    int v14 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Dialing %s", buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 144);
  v12[0] = off_101A73CB0;
  v12[1] = a1;
  int v12[2] = a2 | (unint64_t)(a4 << 32);
  v12[3] = v12;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, void *))(*(void *)v10 + 16))(v10, a2, a3, v12);
  return sub_10003B34C(v12);
}

void sub_100F61AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F61AF8(uint64_t a1)
{
  uint64_t v2 = *(CSIPhoneNumber **)(a1 + 160);
  char v23 = (CSIPhoneNumber **)(a1 + 168);
  if (v2 != (CSIPhoneNumber *)(a1 + 168))
  {
    do
    {
      uint64_t v3 = 0;
      uint64_t v4 = v2 + 1;
      do
      {
        int v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v2->var2.__r_.var0);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = "Call Forwarding Reason unknown";
          if (v3 <= 5) {
            uint64_t v6 = off_101A73D20[v3];
          }
          if (LOBYTE(v4[-1].var2.var0)) {
            uint64_t v7 = "enabled";
          }
          else {
            uint64_t v7 = "disabled";
          }
          CSIPhoneNumber::getFullNumber((uint64_t *)__p, v4);
          char v8 = __p;
          if (v25 < 0) {
            char v8 = (void **)__p[0];
          }
          *(_DWORD *)CSIPhoneNumber buf = 136315650;
          uint64_t v27 = v6;
          __int16 v28 = 2080;
          uint64_t v29 = v7;
          __int16 v30 = 2080;
          long long v31 = v8;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: is %s with number %s", buf, 0x20u);
          if (v25 < 0) {
            operator delete(__p[0]);
          }
        }
        ++v3;
        v4 += 3;
      }
      while (v3 != 4);
      data = v2->var2.__r_.__value_.var0.var1.__data_;
      if (data)
      {
        do
        {
          size = (CSIPhoneNumber **)data;
          data = *(char **)data;
        }
        while (data);
      }
      else
      {
        do
        {
          size = (CSIPhoneNumber **)v2->var2.__r_.__value_.var0.var1.__size_;
          BOOL v11 = *size == v2;
          uint64_t v2 = (CSIPhoneNumber *)size;
        }
        while (!v11);
      }
      uint64_t v2 = (CSIPhoneNumber *)size;
    }
    while (size != v23);
  }
  uint64_t v12 = *(void **)(a1 + 184);
  if (v12 != (void *)(a1 + 192))
  {
    do
    {
      if (v12[5]) {
        char v13 = sub_100080778;
      }
      else {
        char v13 = 0;
      }
      BOOL v14 = v13 == 0;
      BOOL v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v12 + 8));
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        if (v16)
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          uint64_t v18 = v15;
          uint64_t v19 = "#I no configuring prefixes";
          uint32_t v20 = 2;
          goto LABEL_29;
        }
      }
      else if (v16)
      {
        int v17 = (const char *)v12[5];
        *(_DWORD *)CSIPhoneNumber buf = 138412290;
        uint64_t v27 = v17;
        uint64_t v18 = v15;
        uint64_t v19 = "#I configuring prefixes are: %@";
        uint32_t v20 = 12;
LABEL_29:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, v20);
      }
      BOOL v21 = (void *)v12[1];
      if (v21)
      {
        do
        {
          char v22 = v21;
          BOOL v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          char v22 = (void *)v12[2];
          BOOL v11 = *v22 == (void)v12;
          uint64_t v12 = v22;
        }
        while (!v11);
      }
      uint64_t v12 = v22;
    }
    while (v22 != (void *)(a1 + 192));
  }
}

void sub_100F61E00()
{
}

uint64_t sub_100F61E14(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100F61E20(void *a1)
{
  if (a1)
  {
    sub_100F61E20(*a1);
    sub_100F61E20(a1[1]);
    sub_100F61E74((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100F61E74(uint64_t a1)
{
  uint64_t v2 = 576;
  do
  {
    uint64_t v3 = a1 + v2;
    if (*(char *)(a1 + v2 - 17) < 0) {
      operator delete(*(void **)(v3 - 40));
    }
    if (*(char *)(v3 - 41) < 0) {
      operator delete(*(void **)(a1 + v2 - 64));
    }
    uint64_t v4 = a1 + v2;
    if (*(char *)(a1 + v2 - 73) < 0) {
      operator delete(*(void **)(v4 - 96));
    }
    if (*(char *)(v4 - 97) < 0) {
      operator delete(*(void **)(a1 + v2 - 120));
    }
    v2 -= 144;
  }
  while (v2);
}

uint64_t *sub_100F61EF8(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  uint64_t v7 = (uint64_t *)(a1 + 1);
  char v8 = (uint64_t *)(a1 + 1);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        char v8 = v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        int v5 = (uint64_t *)*v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      int v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v15 = 0;
    uint64_t v10 = operator new(0x268uLL);
    v14[0] = v10;
    v14[1] = v6;
    v10[8] = *a3;
    bzero(v10 + 10, 0x240uLL);
    for (uint64_t i = 0; i != 144; i += 36)
    {
      LOBYTE(v10[i + 10]) = 0;
      CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)&v10[i + 12]);
    }
    LOBYTE(v15) = 1;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v8;
    uint64_t *v7 = (uint64_t)v10;
    uint64_t v12 = (uint64_t *)**a1;
    if (v12)
    {
      *a1 = v12;
      uint64_t v10 = (_DWORD *)*v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    char v8 = (uint64_t *)v14[0];
    v14[0] = 0;
    sub_100F62088((uint64_t)v14);
  }
  return v8;
}

void sub_100F62018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  for (; v3; v3 -= 144)
  {
    uint64_t v5 = v2 + v3;
    if (*(char *)(v2 + v3 + 15) < 0) {
      operator delete(*(void **)(v5 - 8));
    }
    if (*(char *)(v5 - 9) < 0) {
      operator delete(*(void **)(v2 + v3 - 32));
    }
    uint64_t v6 = v2 + v3;
    if (*(char *)(v2 + v3 - 41) < 0) {
      operator delete(*(void **)(v6 - 64));
    }
    if (*(char *)(v6 - 65) < 0) {
      operator delete(*(void **)(v2 + v3 - 88));
    }
  }
  sub_100F62088((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100F62088(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100F61E74((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100F620E4()
{
}

__n128 sub_100F620F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A73C30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F6214C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A73C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F62184(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  char v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100F62244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F6225C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6229C()
{
}

void sub_100F622AC()
{
}

__n128 sub_100F622C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A73CB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F6230C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A73CB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F6233C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F62430(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F62470()
{
}

void sub_100F6247C(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void, uint64_t, void))(**(void **)(**(void **)a1 + 72) + 40))(*(void *)(**(void **)a1 + 72), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12), 1, 0);
  operator delete();
}

void sub_100F62500()
{
}

void sub_100F62530(UserAlertGenerationInterface *a1)
{
  UserAlertGenerationInterface::~UserAlertGenerationInterface(a1);

  operator delete();
}

double sub_100F62568@<D0>(const void **a1@<X1>, const void **a2@<X2>, const void **a3@<X3>, _OWORD *a4@<X8>)
{
  sub_100201D40(a1, a2, a3, v6);
  double result = v6[0];
  *a4 = *(_OWORD *)v6;
  return result;
}

double sub_100F625A4@<D0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, _OWORD *a4@<X8>)
{
  char v8 = operator new(0x48uLL);
  v8[1] = 0;
  v8[2] = 0;
  void *v8 = off_1019AB758;
  sub_1001D7910((uint64_t)(v8 + 3), a1, a2, a3);
  *(void *)&long long v10 = v8 + 3;
  *((void *)&v10 + 1) = v8;
  sub_1000B3BC8((uint64_t)&v10, v8 + 4, (uint64_t)(v8 + 3));
  double result = *(double *)&v10;
  *a4 = v10;
  return result;
}

void sub_100F62648(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

double sub_100F62660@<D0>(const void **a1@<X1>, const void **a2@<X2>, const void **a3@<X3>, const void **a4@<X4>, NSObject **a5@<X5>, uint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  char v13 = *a5;
  BOOL v14 = operator new(0x78uLL);
  v14[1].isa = 0;
  v14[2].isa = 0;
  v14->isa = (Class)off_1019AE920;
  uint64_t v15 = (uint64_t)&v14[3];
  object[0] = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  sub_1001D7AC4(v15, a1, a2, a3, a4, object, a6);
  if (object[0]) {
    dispatch_release(object[0]);
  }
  object[0] = v14 + 3;
  object[1] = v14;
  sub_1000B3BC8((uint64_t)object, &v14[4].isa, v15);
  double result = *(double *)object;
  *a7 = *(_OWORD *)object;
  return result;
}

void sub_100F62748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

double sub_100F6276C@<D0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, NSObject **a5@<X5>, uint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  char v13 = *a5;
  BOOL v14 = operator new(0x78uLL);
  v14[1].isa = 0;
  v14[2].isa = 0;
  v14->isa = (Class)off_1019AE920;
  uint64_t v15 = (uint64_t)&v14[3];
  object[0] = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  sub_1001D7B74(v15, a1, a2, a3, a4, object, a6);
  if (object[0]) {
    dispatch_release(object[0]);
  }
  object[0] = v14 + 3;
  object[1] = v14;
  sub_1000B3BC8((uint64_t)object, &v14[4].isa, v15);
  double result = *(double *)object;
  *a7 = *(_OWORD *)object;
  return result;
}

void sub_100F62854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

double sub_100F62878@<D0>(const void **a1@<X1>, const void **a2@<X2>, const void **a3@<X3>, const void **a4@<X4>, const void **a5@<X5>, NSObject **a6@<X6>, uint64_t a7@<X7>, _OWORD *a8@<X8>)
{
  sub_100F62A64(a1, a2, a3, a4, a5, a6, a7, v10);
  double result = v10[0];
  *a8 = *(_OWORD *)v10;
  return result;
}

double sub_100F628B4@<D0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, NSObject **a6@<X6>, uint64_t a7@<X7>, _OWORD *a8@<X8>)
{
  uint64_t v15 = *a6;
  BOOL v16 = operator new(0x80uLL);
  v16[1].isa = 0;
  v16[2].isa = 0;
  v16->isa = (Class)off_101A1C830;
  uint64_t v17 = (uint64_t)&v16[3];
  object[0] = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  sub_1001D7F24(v17, a1, a2, a3, a4, a5, object, a7);
  if (object[0]) {
    dispatch_release(object[0]);
  }
  object[0] = v16 + 3;
  object[1] = v16;
  sub_1000B3BC8((uint64_t)object, &v16[4].isa, v17);
  double result = *(double *)object;
  *a8 = *(_OWORD *)object;
  return result;
}

void sub_100F629A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v11);
  _Unwind_Resume(a1);
}

void sub_100F629C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A73DC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F629E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A73DC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F62A3C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F62A64(const void **a1@<X1>, const void **a2@<X2>, const void **a3@<X3>, const void **a4@<X4>, const void **a5@<X5>, NSObject **a6@<X6>, uint64_t a7@<X7>, void *a8@<X8>)
{
  BOOL v16 = operator new(0x80uLL);
  sub_100F62B20(v16, a1, a2, a3, a4, a5, a6, a7);
  *a8 = v16 + 3;
  a8[1] = v16;

  sub_1000B3BC8((uint64_t)a8, v16 + 4, (uint64_t)(v16 + 3));
}

void sub_100F62B0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100F62B20(void *a1, const void **a2, const void **a3, const void **a4, const void **a5, const void **a6, NSObject **a7, uint64_t a8)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A1C830;
  sub_100F62B7C((uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_100F62B68(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F62B7C(uint64_t a1, const void **a2, const void **a3, const void **a4, const void **a5, const void **a6, NSObject **a7, uint64_t a8)
{
  uint64_t v15 = *a7;
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  sub_1001D7E90(a1, a2, a3, a4, a5, a6, &object, a8);
  if (object) {
    dispatch_release(object);
  }
  return a1;
}

void sub_100F62C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F62C30()
{
}

void sub_100F62D18(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F62D4C(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "ps.vnr");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  long long v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)a1 = off_101A73E18;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = a5;
  sub_100058DB0(&__p, "VoNRControl");
  char v13 = *(NSObject **)(a1 + 24);
  uint64_t v15 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  ctu::RestModule::RestModule();
  if (v15) {
    dispatch_release(v15);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 124) = 0;
  *(void *)(a1 + 137) = 0;
  return a1;
}

void sub_100F62EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  char v23 = *(std::__shared_weak_count **)(v19 + 72);
  if (v23) {
    sub_10004D2C8(v23);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v19 + 56);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void *sub_100F62F68(void *a1)
{
  *a1 = off_101A73E18;
  int v2 = (std::__shared_weak_count *)a1[17];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100F62FF0(void *a1)
{
  sub_100F62F68(a1);

  operator delete();
}

uint64_t sub_100F63028(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
}

BOOL sub_100F63030(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)CSIPhoneNumber buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v19 = 2080;
    uint32_t v20 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sinitializing", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CSIPhoneNumber buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  BOOL v14 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v13;
  *(void *)(a1 + 136) = v12;
  if (v14) {
    sub_10004D2C8(v14);
  }
  Registry::createRestModuleOneTimeUseConnection(&v16, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_100F63210(a1);
  sub_100F634F8(a1);
  BOOL result = sub_100F63B48(a1);
  *(unsigned char *)(a1 + 112) = result;
  return result;
}

void sub_100F631E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F63210(uint64_t a1)
{
  int v2 = (uint64_t *)__stack_chk_guard;
  *(_DWORD *)(a1 + 116) = 0;
  char v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CSIPhoneNumber buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v11 + 64))(&v22, v11, **(void **)(a1 + 64) + 24, @"VoNRUserPreference", kPhoneServicesWalletDomain, 0, 1);
  sub_1000842D0(&v23, &v22);
  sub_1000577C4(&v22);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v23) {
    BOOL v14 = sub_100081E58;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    *(_DWORD *)CSIPhoneNumber buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v23, v13);
    int v15 = *(_DWORD *)buf;
    if (*(int *)buf > 0)
    {
      int v16 = 2;
LABEL_22:
      *(_DWORD *)(a1 + 116) = v16;
      return sub_1000570E8((const void **)&v23);
    }
    int v17 = sub_100F63928(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 128));
    int v18 = -v15;
    if (v17 <= -v15)
    {
      int v16 = 1;
      goto LABEL_22;
    }
    __int16 v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      *(void *)&uint8_t buf[4] = v20;
      __int16 v25 = 2080;
      char v26 = " ";
      __int16 v27 = 1024;
      int v28 = v18;
      __int16 v29 = 1024;
      int v30 = v17;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: user preference has ver:%d vs current:%d, force reset to default", buf, 0x22u);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
  }
  return sub_1000570E8((const void **)&v23);
}

void sub_100F634A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F634F8(uint64_t a1)
{
  if (capabilities::ct::supportsVoLTE((capabilities::ct *)a1))
  {
    *(void *)CSIPhoneNumber buf = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 128) + 96))(&v13);
    sub_1000057AC(buf, &v13);
    sub_1000577C4(&v13);
    LOBYTE(v13) = 0;
    ctu::cf::assign((ctu::cf *)&v13, *(BOOL **)buf, v2);
    int v3 = (_BYTE)v13 != 0;
    sub_100062778((const void **)buf);
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 104))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    int v3 = 0;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)CSIPhoneNumber buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v15 = 2080;
    int v16 = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sDevice does not support VoNR", buf, 0x16u);
  }
  int v3 = 0;
LABEL_7:
  int v6 = *(unsigned __int8 *)(a1 + 104);
  if (v6 != v3)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      int v9 = *(unsigned __int8 *)(a1 + 104);
      unsigned int v10 = "true";
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      if (v9) {
        uint64_t v11 = "true";
      }
      else {
        uint64_t v11 = "false";
      }
      *(void *)&uint8_t buf[4] = v8;
      int v16 = " ";
      __int16 v15 = 2080;
      if (!v3) {
        unsigned int v10 = "false";
      }
      __int16 v17 = 2080;
      int v18 = v11;
      __int16 v19 = 2080;
      uint64_t v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports VoNR capability is changing from %s to %s", buf, 0x2Au);
    }
    *(unsigned char *)(a1 + 104) = v3;
  }
  return v6 != v3;
}

void sub_100F6371C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F63748(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstarted", (uint8_t *)&v5, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, 0, 1);
}

uint64_t sub_100F63834(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: review provisioning on migration", (uint8_t *)&v5, 0x16u);
  }
  sub_100F63210(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

unint64_t sub_100F63928(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)a2 + 96))(&cf, a2, a1, 1, kCFEnableLTEAfterUpgrade, 0, 0);
  if (cf) {
    CFBooleanRef v2 = sub_100080934;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (!v2) {
    goto LABEL_12;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  unint64_t v5 = (unint64_t)cf;
  if (v3 != TypeID)
  {
    unsigned __int8 v12 = 0;
    if (!cf) {
      goto LABEL_13;
    }
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v12, (BOOL *)v5, v9);
      unint64_t v5 = v12;
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  unsigned int v13 = 0;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v13, (int *)v5, v7);
      unint64_t v5 = v13;
      goto LABEL_13;
    }
LABEL_12:
    unint64_t v5 = 0;
  }
LABEL_13:
  sub_1000577C4(&cf);
  return v5;
}

void sub_100F63A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100F63A60(uint64_t a1, uint64_t a2)
{
  CFBooleanRef BOOLean = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)a2 + 96))(&v5, a2, a1, 1, @"ShowVoNRSwitch", 0, 0);
  sub_1000057AC(&BOOLean, &v5);
  sub_1000577C4(&v5);
  if (BOOLean) {
    CFBooleanRef v2 = sub_100084B4C;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (v2) {
    BOOL v3 = CFBooleanGetValue(BOOLean) == 1;
  }
  else {
    BOOL v3 = 0;
  }
  sub_100062778((const void **)&BOOLean);
  return v3;
}

void sub_100F63B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F63B48(uint64_t a1)
{
  BOOL v2 = sub_100F63A60(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 128));
  uint64_t v3 = sub_100F63CF4(a1, v2);
  if (v2 && (int v4 = *(_DWORD *)(a1 + 116)) != 0)
  {
    unint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v7 = *(int *)(a1 + 116);
      if (v7 > 2) {
        CFTypeID v8 = (char *)&unk_10161656E;
      }
      else {
        CFTypeID v8 = off_101A74000[v7];
      }
      int v12 = 136315650;
      uint64_t v13 = v6;
      __int16 v14 = 2080;
      __int16 v15 = " ";
      __int16 v16 = 2080;
      __int16 v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: Using manual preference %s", (uint8_t *)&v12, 0x20u);
      int v4 = *(_DWORD *)(a1 + 116);
    }
    return v4 == 2;
  }
  else
  {
    CFBooleanRef v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      int v12 = 136315650;
      uint64_t v13 = v10;
      __int16 v14 = 2080;
      __int16 v15 = " ";
      __int16 v16 = 1024;
      LODWORD(v17) = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: Using carrier default %d", (uint8_t *)&v12, 0x1Cu);
    }
  }
  return v3;
}

uint64_t sub_100F63CF4(uint64_t a1, int a2)
{
  int v4 = operator new(0x18uLL);
  *(_OWORD *)int v4 = *(_OWORD *)off_101A73EE0;
  v4[2] = @"EnableVoNRByDefault";
  std::string __p = v4;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 104))(cf);
  unint64_t v5 = *(BOOL **)cf;
  uint64_t v6 = a2 ^ 1u;
  unsigned __int8 v17 = v6;
  if (*(void *)cf)
  {
    CFTypeID v7 = CFGetTypeID(*(CFTypeRef *)cf);
    if (v7 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v17, v5, v8);
      uint64_t v6 = v17 != 0;
    }
  }
  sub_1000577C4((const void **)cf);
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 80))(cf);
  CFBooleanRef v9 = *(BOOL **)cf;
  unsigned __int8 v17 = 0;
  if (*(void *)cf && (CFTypeID v10 = CFGetTypeID(*(CFTypeRef *)cf), v10 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v17, v9, v11);
    int v12 = v17;
    sub_1000577C4((const void **)cf);
    if (v12 && *(unsigned char *)(a1 + 144))
    {
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)CFTypeRef cf = 136315394;
        *(void *)&cf[4] = v14;
        __int16 v19 = 2080;
        uint64_t v20 = " ";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switchchange default to ON when entitled", cf, 0x16u);
      }
      uint64_t v6 = 1;
    }
  }
  else
  {
    sub_1000577C4((const void **)cf);
  }
  if (__p) {
    operator delete(__p);
  }
  return v6;
}

void sub_100F63F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F63F70(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)__int16 v16 = 136315394;
    *(void *)&v16[4] = v4;
    __int16 v17 = 2080;
    int v18 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: Reset", v16, 0x16u);
  }
  *(_DWORD *)(a1 + 116) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    CFBooleanRef v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)__int16 v16 = v7;
  CFBooleanRef v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v16);
  if (v11)
  {
    uint64_t v13 = v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  int v12 = 0;
  char v14 = 1;
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 72))(v13, **(void **)(a1 + 64) + 24, @"VoNRUserPreference", kPhoneServicesWalletDomain, 0, 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_100F64164(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F64194(uint64_t a1)
{
  return *(_DWORD *)(a1 + 120) == 2;
}

unint64_t sub_100F641A4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116) | ((unint64_t)*(unsigned __int8 *)(a1 + 112) << 32);
}

uint64_t sub_100F641B4(uint64_t result)
{
  if (*(unsigned char *)(**(void **)(result + 64) + 48)) {
    phoneservices::submitSwitchAnalytics();
  }
  return result;
}

uint64_t sub_100F641F0(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    CFBooleanRef v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonality config changed", (uint8_t *)&v5, 0x16u);
  }
  sub_100F63210(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_100F642E4(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    CFBooleanRef v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonal wallet changed", (uint8_t *)&v5, 0x16u);
  }
  sub_100F63210(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

const void **sub_100F643D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CFMutableDictionaryRef theDict = 0;
  int v3 = *(_DWORD *)(a1 + 124);
  if ((v3 - 2) < 2)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v10 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      CFMutableDictionaryRef v15 = v10;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSetting, kCFBooleanTrue);
    char v8 = 1;
    char v6 = 1;
    char v7 = 1;
  }
  else if (v3 == 4)
  {
    CFBooleanRef v11 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v11)
    {
      CFMutableDictionaryRef v12 = theDict;
      CFMutableDictionaryRef theDict = v11;
      CFMutableDictionaryRef v15 = v12;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSettingEnableStillProvisioning, kCFBooleanTrue);
    char v7 = 0;
    char v8 = 1;
    char v6 = 1;
  }
  else if (v3 == 5)
  {
    uint64_t v4 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v4)
    {
      CFMutableDictionaryRef v5 = theDict;
      CFMutableDictionaryRef theDict = v4;
      CFMutableDictionaryRef v15 = v5;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCannotChangeSettingNeedToCallCarrier, kCFBooleanTrue);
    char v6 = 0;
    char v7 = 0;
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
    char v6 = 0;
    char v7 = 0;
  }
  *(unsigned char *)a2 = v8;
  *(unsigned char *)(a2 + 1) = v6;
  *(unsigned char *)(a2 + 2) = v7;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_100F64588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **sub_100F6459C@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  char v6 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 56))(&v5);
  *(unsigned char *)a2 = a1[30] == 2;
  sub_100058198((const void **)(a2 + 8), &v6);
  return sub_100057D78(&v6);
}

void sub_100F6462C(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v6 = asStringBool(a2);
    uint64_t v7 = *(int *)(a1 + 124);
    if (v7 > 5) {
      char v8 = "???";
    }
    else {
      char v8 = off_101A74018[v7];
    }
    *(_DWORD *)CSIPhoneNumber buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v38 = 2080;
    uint64_t v39 = " ";
    __int16 v40 = 2080;
    uint64_t v41 = v6;
    __int16 v42 = 2080;
    __int16 v43 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled(%s): Current 'VoNR can set' status: %s", buf, 0x2Au);
  }
  unsigned int v9 = *(_DWORD *)(a1 + 124);
  BOOL v10 = v9 > 5;
  int v11 = (1 << v9) & 0x23;
  if (v10 || v11 == 0)
  {
    if (a2) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    if (*(_DWORD *)(a1 + 116) == v13)
    {
LABEL_38:
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 1, 0);
      return;
    }
    char v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v16 = *(int *)(a1 + 116);
      if (v16 > 2) {
        __int16 v17 = (char *)&unk_10161656E;
      }
      else {
        __int16 v17 = off_101A74000[v16];
      }
      int v18 = "Disabled";
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      *(void *)&uint8_t buf[4] = v15;
      uint64_t v39 = " ";
      __int16 v38 = 2080;
      if (a2) {
        int v18 = "Enabled";
      }
      __int16 v40 = 2080;
      uint64_t v41 = (uint64_t)v17;
      __int16 v42 = 2080;
      __int16 v43 = v18;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Switch: changed user preference from %s to %s", buf, 0x2Au);
    }
    int v19 = sub_100F63928(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 128));
    if (a2) {
      int v20 = v19 + 1;
    }
    else {
      int v20 = -v19;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)-v19, *(Registry **)(a1 + 48));
    char v22 = ServiceMap;
    if (v23 < 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CSIPhoneNumber buf = v23;
    __int16 v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    if (v27)
    {
      uint64_t v29 = v27[3];
      int v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
LABEL_33:
        uint64_t v31 = **(void **)(a1 + 64);
        CFNumberRef v36 = 0;
        *(_DWORD *)CSIPhoneNumber buf = v20;
        CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
        if (v32)
        {
          CFNumberRef v33 = v36;
          CFNumberRef v36 = v32;
          *(void *)CSIPhoneNumber buf = v33;
          sub_1000570E8((const void **)buf);
        }
        CFNumberRef v34 = v36;
        CFNumberRef v35 = v36;
        CFNumberRef v36 = 0;
        sub_1000570E8((const void **)&v36);
        (*(void (**)(uint64_t, uint64_t, const __CFString *, CFNumberRef, void, void, uint64_t, void, CFNumberRef))(*(void *)v29 + 48))(v29, v31 + 24, @"VoNRUserPreference", v34, kPhoneServicesWalletDomain, 0, 1, 0, v35);
        sub_1000570E8((const void **)&v35);
        if ((v30 & 1) == 0) {
          sub_10004D2C8(v28);
        }
        *(_DWORD *)(a1 + 116) = v13;
        *(unsigned char *)(a1 + 112) = sub_100F63B48(a1);
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    int v28 = 0;
    char v30 = 1;
    goto LABEL_33;
  }
}

void sub_100F649D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100F64A20(uint64_t a1, int a2, char a3)
{
  BOOL v6 = sub_100F634F8(a1);
  int v7 = *(unsigned __int8 *)(a1 + 104);
  if (*(unsigned char *)(a1 + 104)) {
    int v8 = 2;
  }
  else {
    int v8 = 1;
  }
  int v9 = *(_DWORD *)(a1 + 108);
  if (v9 != v8)
  {
    char v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v41 = 2080;
      uint64_t v42 = asString();
      __int16 v43 = 2080;
      uint64_t v44 = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR Network support is changing from %s to %s", buf, 0x2Au);
      int v7 = *(unsigned __int8 *)(a1 + 104);
    }
    *(_DWORD *)(a1 + 108) = v8;
  }
  char v39 = a3;
  if (v7)
  {
    if (sub_100F63A60(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 128)))
    {
      int v12 = 2;
      int v13 = "kCanSetCanEnableDisable";
      goto LABEL_14;
    }
    char v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CSIPhoneNumber buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sEither VoNR switch support is not present or it is set to false", buf, 0x16u);
    }
  }
  int v12 = 1;
  int v13 = "kCannotSet";
LABEL_14:
  int v16 = *(_DWORD *)(a1 + 124);
  if (v16 != v12)
  {
    __int16 v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v19 = *(int *)(a1 + 124);
      if (v19 > 5) {
        int v20 = "???";
      }
      else {
        int v20 = off_101A74018[v19];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315906;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v41 = 2080;
      uint64_t v42 = (uint64_t)v20;
      __int16 v43 = 2080;
      uint64_t v44 = (uint64_t)v13;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports VoNR switch is changing from %s to %s", buf, 0x2Au);
    }
    *(_DWORD *)(a1 + 124) = v12;
  }
  int v21 = *(unsigned __int8 *)(a1 + 112);
  int v22 = sub_100F63B48(a1);
  *(unsigned char *)(a1 + 112) = v22;
  BOOL v23 = v21 != v22;
  uint64_t v24 = **(PersonalityInfo ***)(a1 + 64);
  if (*((unsigned char *)v24 + 48))
  {
    int v25 = *(_DWORD *)(a1 + 108);
    if ((v22 & (v25 == 2)) != 0) {
      int v26 = 2;
    }
    else {
      int v26 = 1;
    }
    if (v25) {
      int v27 = v26;
    }
    else {
      int v27 = 0;
    }
  }
  else
  {
    int v27 = 0;
  }
  if (v27 != *(_DWORD *)(a1 + 120))
  {
    int v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = PersonalityInfo::logPrefix(v24);
      uint64_t v30 = asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315650;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v41 = 2080;
      uint64_t v42 = v30;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR feature re-evaluated to %s", buf, 0x20u);
    }
    *(_DWORD *)(a1 + 120) = v27;
    BOOL v23 = 1;
  }
  if (v16 != v12) {
    BOOL v23 = 1;
  }
  if (v9 != v8) {
    BOOL v23 = 1;
  }
  BOOL v31 = v23 || v6;
  sub_100A2FD3C(*(void *)(a1 + 80), 3, a2);
  if (v31 || (v39 & 1) != 0 || a2)
  {
    char v32 = *(unsigned char *)(a1 + 104);
    char v33 = *(unsigned char *)(a1 + 112);
    BOOL v34 = *(_DWORD *)(a1 + 108) == 2;
    int v35 = *(_DWORD *)(a1 + 116);
    int v36 = *(_DWORD *)(a1 + 120);
    uint64_t v37 = *(void *)(a1 + 80);
    __int16 v38 = (char *)operator new(0x30uLL);
    *((void *)v38 + 1) = 0;
    *((void *)v38 + 2) = 0;
    *(void *)__int16 v38 = off_1019DD770;
    *(_WORD *)(v38 + 25) = 0;
    v38[27] = 0;
    *((_DWORD *)v38 + 7) = v35;
    v38[32] = v33;
    *(_WORD *)(v38 + 33) = 0;
    v38[35] = 0;
    v38[36] = v34;
    *(_WORD *)(v38 + 37) = 0;
    v38[39] = 0;
    *((_DWORD *)v38 + 10) = v36;
    *(void *)&uint8_t buf[8] = v38;
    v38[24] = v32;
    *(void *)CSIPhoneNumber buf = v38 + 24;
    sub_100A321D8(v37, 3, (uint64_t **)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
}

void sub_100F64E4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void sub_100F64E6C(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v4 = **(void **)(a1 + 64);
    int v7 = *(const char **)(v4 + 24);
    uint64_t v5 = (const char *)(v4 + 24);
    BOOL v6 = v7;
    uint64_t v8 = *((unsigned __int8 *)v5 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)v5 + 1);
    }
    if (v9 < 0) {
      uint64_t v5 = v6;
    }
    if (!v8) {
      uint64_t v5 = "<invalid>";
    }
    int v30 = 136315650;
    uint64_t v31 = v3;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s== dump VoNRControl '%s'", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 104));
    int v30 = 136315650;
    uint64_t v31 = v10;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sCarrier support: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v13 = asString();
    int v30 = 136315650;
    uint64_t v31 = v12;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sAccount/Network support: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v15 = asStringBool(*(unsigned char *)(a1 + 112));
    int v30 = 136315650;
    uint64_t v31 = v14;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sActual VoNR switch state: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v17 = *(int *)(a1 + 116);
    if (v17 > 2) {
      uint64_t v18 = (char *)&unk_10161656E;
    }
    else {
      uint64_t v18 = off_101A74000[v17];
    }
    int v30 = 136315650;
    uint64_t v31 = v16;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sUser preference: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v20 = *(int *)(a1 + 124);
    if (v20 > 5) {
      int v21 = "???";
    }
    else {
      int v21 = off_101A74018[v20];
    }
    int v30 = 136315650;
    uint64_t v31 = v19;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v21;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sCanSet state: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v23 = asString();
    int v30 = 136315650;
    uint64_t v31 = v22;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sFinal capability state: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    BOOL v25 = sub_100F63A60(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 128));
    char v26 = sub_100F63CF4(a1, v25);
    uint64_t v27 = asStringBool(v26);
    int v30 = 136315650;
    uint64_t v31 = v24;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sEnableByDefault: %s", (uint8_t *)&v30, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v29 = asStringBool(*(unsigned char *)(a1 + 144));
    int v30 = 136315650;
    uint64_t v31 = v28;
    __int16 v32 = 2080;
    char v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v29;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s5G SA Provisioned: %s", (uint8_t *)&v30, 0x20u);
  }
}

uint64_t sub_100F65340(uint64_t result, int a2, uint64_t *a3)
{
  if ((a2 - 3) >= 0xFFFFFFFE)
  {
    uint64_t v3 = result;
    for (uint64_t i = *a3; ; i += 64)
    {
      if (i == a3[1])
      {
        int v5 = 0;
        goto LABEL_10;
      }
      if (*(unsigned char *)(i + 57) && a2 == 2 && *(unsigned char *)(i + 56)) {
        break;
      }
    }
    int v5 = 1;
LABEL_10:
    if (*(unsigned __int8 *)(result + 144) != v5)
    {
      BOOL v6 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 64));
        int v8 = *(unsigned __int8 *)(v3 + 144);
        int v9 = "True";
        int v11 = 136315906;
        uint64_t v12 = v7;
        if (v8) {
          uint64_t v10 = "True";
        }
        else {
          uint64_t v10 = "False";
        }
        uint64_t v14 = " ";
        __int16 v13 = 2080;
        if (!v5) {
          int v9 = "False";
        }
        __int16 v15 = 2080;
        uint64_t v16 = v10;
        __int16 v17 = 2080;
        uint64_t v18 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sVoNR f5gSaProvisioned changed from %s to %s", (uint8_t *)&v11, 0x2Au);
      }
      *(unsigned char *)(v3 + 144) = v5;
      return (*(uint64_t (**)(uint64_t, void, void))(*(void *)v3 + 104))(v3, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100F654C0()
{
  return 0;
}

void sub_100F654C8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F65594(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100F6566C);
  __cxa_rethrow();
}

void sub_100F655BC(_Unwind_Exception *a1)
{
}

void sub_100F655D4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F6560C(uint64_t a1)
{
}

uint64_t sub_100F65628(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F6566C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F65698(uint64_t a1)
{
  if (qword_101B12FB0 != -1) {
    dispatch_once(&qword_101B12FB0, &stru_101A740E0);
  }
  uint64_t v2 = qword_101B12FA8;
  uint64_t v3 = *(NSObject **)(a1 + 8);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)BOOL v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Starting STK alert session manager", v6, 2u);
    }
    global_queue = dispatch_get_global_queue(0, 0);
    if (global_queue) {
      dispatch_retain(global_queue);
    }
    operator new();
  }
  if (v4)
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Unable to load SIMToolkitUI on this platform", buf, 2u);
  }
}

void sub_100F657BC(uint64_t a1, uint64_t a2)
{
  if (qword_101B12FB0 != -1) {
    dispatch_once(&qword_101B12FB0, &stru_101A740E0);
  }
  if (qword_101B12FA8)
  {
    CFTypeRef cf = 0;
    uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
    if ((v4 & 0x80u) != 0) {
      uint64_t v4 = *(void *)(a2 + 8);
    }
    if (v4)
    {
      uint64_t v10 = 0;
      if (ctu::cf::convert_copy())
      {
        CFTypeRef v5 = cf;
        CFTypeRef cf = v10;
        *(void *)CSIPhoneNumber buf = v5;
        sub_1000558F4((const void **)buf);
        global_queue = dispatch_get_global_queue(0, 0);
        if (global_queue) {
          dispatch_retain(global_queue);
        }
        operator new();
      }
    }
    uint64_t v7 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Device language passed is not valid", buf, 2u);
    }
    sub_1000558F4(&cf);
  }
  else
  {
    int v8 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Unable to load SIMToolkitUI on this platform", buf, 2u);
    }
  }
}

void sub_100F65998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100F659AC(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  STKAlertSessionManagerInterface::~STKAlertSessionManagerInterface((STKAlertSessionManagerInterface *)a1);
}

void sub_100F659E8(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  STKAlertSessionManagerInterface::~STKAlertSessionManagerInterface((STKAlertSessionManagerInterface *)a1);

  operator delete();
}

void sub_100F65A38(id a1)
{
  qword_101B12FA8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/SIMToolkitUI.framework/SIMToolkitUI", 2);
}

uint64_t sub_100F65A64(uint64_t a1)
{
  uint64_t result = off_101B0B820[0]();
  if (a1)
  {
    operator delete();
  }
  return result;
}

void sub_100F65AC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F65AE4()
{
  if (qword_101B12FB0 != -1) {
    dispatch_once(&qword_101B12FB0, &stru_101A740E0);
  }
  v0 = (uint64_t (*)())dlsym((void *)qword_101B12FA8, "STKAlertSessionManagerStart");
  off_101B0B820[0] = v0;

  return v0();
}

const void ***sub_100F65B4C(const void ***a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1000558F4(v2);
    operator delete();
  }
  return a1;
}

const void ***sub_100F65B94(const void **a1)
{
  uint64_t v2 = a1;
  off_101B0B828((uint64_t)*a1);
  return sub_100F65B4C(&v2);
}

void sub_100F65BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100F65B4C((const void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F65BE8(uint64_t a1)
{
  if (qword_101B12FB0 != -1) {
    dispatch_once(&qword_101B12FB0, &stru_101A740E0);
  }
  uint64_t v2 = (uint64_t (*)())dlsym((void *)qword_101B12FA8, "STKAlertSessionManagerSetDeviceLanguage");
  off_101B0B828 = v2;

  return ((uint64_t (*)(uint64_t))v2)(a1);
}

void AttachApnModule::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F66260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, dispatch_object_t a13, dispatch_object_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

const char *sub_100F664B0(int a1)
{
  uint64_t v1 = "AttachAPNModule.?";
  if (a1 == 2) {
    uint64_t v1 = "AttachAPNModule.2";
  }
  if (a1 == 1) {
    return "AttachAPNModule.1";
  }
  else {
    return v1;
  }
}

void sub_100F664DC(uint64_t a1)
{
  *(void *)a1 = off_101A74110;
  sub_100119D90(*(void **)(a1 + 168));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100087F94(a1 + 112, *(void **)(a1 + 120));
  sub_100160A84((atomic_uint **)(a1 + 88));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  AttachApnModuleInterface::~AttachApnModuleInterface((AttachApnModuleInterface *)a1);
}

void sub_100F665B4(uint64_t a1)
{
  sub_100F664DC(a1);

  operator delete();
}

void sub_100F665EC(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 144) + 16))(&v1);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1006E1630();
}

void sub_100F66698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F666BC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F667E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 88))();
}

void sub_100F66808(uint64_t a1, uint64_t a2)
{
  unsigned int PushCount_sync = AttachApnManagerInterface::getPushCount_sync((AttachApnManagerInterface *)a1);
  uint64_t v5 = *(void **)(a1 + 112);
  if (v5 != (void *)(a1 + 120))
  {
    BOOL v6 = (uint64_t *)(a1 + 168);
    uint64_t v7 = (uint64_t *)(a2 + 8);
    uint64_t v29 = PushCount_sync;
    while (1)
    {
      uint64_t v8 = *((unsigned int *)v5 + 8);
      uint64_t v9 = *v6;
      if (*v6)
      {
        uint64_t v10 = a1 + 168;
        do
        {
          int v11 = *(_DWORD *)(v9 + 32);
          BOOL v12 = v11 < (int)v8;
          if (v11 >= (int)v8) {
            __int16 v13 = (uint64_t *)v9;
          }
          else {
            __int16 v13 = (uint64_t *)(v9 + 8);
          }
          if (!v12) {
            uint64_t v10 = v9;
          }
          uint64_t v9 = *v13;
        }
        while (*v13);
        if ((uint64_t *)v10 != v6 && *(_DWORD *)(v10 + 32) <= (int)v8) {
          break;
        }
      }
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = subscriber::asString();
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E handleCarrierBundlesUpdated_sync: Invalid simSlot: %s", buf, 0xCu);
      }
LABEL_38:
      char v26 = (void *)v5[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          char v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v5[2];
          BOOL v28 = *v27 == (void)v5;
          uint64_t v5 = v27;
        }
        while (!v28);
      }
      uint64_t v5 = v27;
      if (v27 == (void *)(a1 + 120)) {
        return;
      }
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v31 = 0;
    if (*((char *)v5 + 71) < 0)
    {
      sub_10004FC84(__p, (void *)v5[6], v5[7]);
      uint64_t v8 = *((unsigned int *)v5 + 8);
    }
    else
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v5 + 3);
      uint64_t v31 = v5[8];
    }
    uint64_t v16 = *v7;
    if (*v7)
    {
      uint64_t v17 = a2 + 8;
      do
      {
        int v18 = *(_DWORD *)(v16 + 32);
        BOOL v19 = v18 < (int)v8;
        if (v18 >= (int)v8) {
          uint64_t v20 = (uint64_t *)v16;
        }
        else {
          uint64_t v20 = (uint64_t *)(v16 + 8);
        }
        if (!v19) {
          uint64_t v17 = v16;
        }
        uint64_t v16 = *v20;
      }
      while (*v20);
      if ((uint64_t *)v17 != v7 && (int)v8 >= *(_DWORD *)(v17 + 32))
      {
        if (rest::operator==())
        {
LABEL_36:
          if (SHIBYTE(v31) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_38;
        }
        uint64_t v8 = *((unsigned int *)v5 + 8);
      }
    }
    int v21 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
    uint64_t v22 = *v21;
    if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = asString();
      uint64_t v24 = asString();
      BOOL v25 = __p;
      if (v31 < 0) {
        BOOL v25 = (void **)__p[0];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315650;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v24;
      __int16 v34 = 2080;
      uint64_t v35 = v25;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I handleCarrierBundlesUpdated_sync: changeType: %s, techType: %s, bundleId: %s", buf, 0x20u);
    }
    *(void *)CSIPhoneNumber buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_100F66DC0(buf, a1, *((_DWORD *)v5 + 8));
    v32[0] = off_101A74718;
    v32[1] = v21;
    v32[2] = v29;
    v32[3] = v32;
    (*(void (**)(void, uint64_t, void *))(**(void **)buf + 32))(*(void *)buf, 1, v32);
    sub_10003B34C(v32);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_36;
  }
}

void sub_100F66B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F66BA4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v3 = a2;
  uint64_t v5 = *(void *)(a1 + 168);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v7 = a1 + 168;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < (int)a2;
    if (v8 >= (int)a2) {
      uint64_t v10 = (uint64_t *)v5;
    }
    else {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != a1 + 168 && *(_DWORD *)(v7 + 32) <= (int)a2)
  {
    BOOL v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        __int16 v13 = a3;
      }
      else {
        __int16 v13 = (uint64_t *)*a3;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I handleRefreshAttachApn_sync: cause %s", (uint8_t *)&buf, 0xCu);
    }
    sub_100F66DC0(&buf, a1, v3);
    v14[0] = off_101A747F8;
    v14[3] = v14;
    (*(void (**)(void, void, void *))(*(void *)buf + 32))(buf, 0, v14);
    sub_10003B34C(v14);
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
  }
  else
  {
LABEL_11:
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E handleRefreshAttachApn_sync: Invalid simSlot: %s", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_100F66D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void *sub_100F66DC0(void *result, uint64_t a2, int a3)
{
  uint64_t v5 = *(uint64_t **)(a2 + 168);
  int v3 = (uint64_t *)(a2 + 168);
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  BOOL v6 = v3;
  uint64_t v7 = v4;
  do
  {
    int v8 = *((_DWORD *)v7 + 8);
    BOOL v9 = v8 < a3;
    if (v8 >= a3) {
      uint64_t v10 = (uint64_t **)v7;
    }
    else {
      uint64_t v10 = (uint64_t **)(v7 + 1);
    }
    if (!v9) {
      BOOL v6 = v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v6 != v3 && *((_DWORD *)v6 + 8) <= a3)
  {
    while (1)
    {
      while (1)
      {
        int v11 = *((_DWORD *)v4 + 8);
        if (v11 <= a3) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          goto LABEL_18;
        }
      }
      if (v11 >= a3) {
        break;
      }
      uint64_t v4 = (uint64_t *)v4[1];
      if (!v4) {
LABEL_18:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    uint64_t v13 = v4[5];
    uint64_t v12 = v4[6];
    *uint64_t result = v13;
    result[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *uint64_t result = 0;
    result[1] = 0;
  }
  return result;
}

BOOL sub_100F66E64(uint64_t a1, int a2, char a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100F6A54C;
  v9[3] = &unk_101A74788;
  v9[4] = a1 + 8;
  v9[5] = &v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  int v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005B464;
    uint64_t v14 = &unk_101A747C8;
    uint64_t v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005A700;
    uint64_t v14 = &unk_101A747A8;
    uint64_t v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

void sub_100F66FA0(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  sub_1000F0058((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F670E0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F670F8(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100F67220(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100F6ACA0;
  v7[3] = &unk_101A74868;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_10005B464;
    uint64_t v12 = &unk_101A747C8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_10005A700;
    uint64_t v12 = &unk_101A747A8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_100F67358(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F674A4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F674BC(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  sub_1000F0058((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6760C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100F67624(uint64_t a1)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = AttachApnManagerInterface::getPushCount_sync;
  v5[3] = &unk_101A74908;
  _OWORD v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100F6B5CC;
    uint64_t v10 = &unk_101A74948;
    int v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100F6B590;
    uint64_t v10 = &unk_101A74928;
    int v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

BOOL sub_100F6774C(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100F6B608;
  v9[3] = &unk_101A74968;
  v9[4] = a1 + 8;
  v9[5] = &v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned int v13 = sub_10005B464;
    uint64_t v14 = &unk_101A747C8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned int v13 = sub_10005A700;
    uint64_t v14 = &unk_101A747A8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

void sub_100F67884(uint64_t a1, int a2)
{
  uint64_t v4 = a1;
  int v5 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100F6B774;
  block[3] = &unk_101A74988;
  block[4] = a1 + 8;
  block[5] = &v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100F67910(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F679F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F67A2C(uint64_t a1)
{
}

uint64_t sub_100F67A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F67A8C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F67AB8(ServiceManager::Service *this)
{
  *(void *)this = off_101A742B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F67B14(ServiceManager::Service *this)
{
  *(void *)this = off_101A742B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F67B84@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "AttachAPNModule");
}

unsigned char *sub_100F67B94@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F67BD0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F666BC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F666BC(v4, 0);
}

uint64_t sub_100F67C54()
{
  return 0;
}

uint64_t sub_100F67C5C()
{
  return 1;
}

uint64_t sub_100F67C64()
{
  return 0;
}

void sub_100F67C70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F67D50(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F67E68()
{
}

uint64_t sub_100F67E7C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100F67E88(uint64_t **a1)
{
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 144) + 24))(*(void *)(v1 + 144));
  uint64_t v2 = *(void **)(v1 + 160);
  if (v2 != (void *)(v1 + 168))
  {
    do
    {
      (*(void (**)(void))(*(void *)v2[5] + 16))(v2[5]);
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (void *)(v1 + 168));
  }
  Registry::createRestModuleOneTimeUseConnection(&v15, *(Registry **)(v1 + 56));
  ctu::RestModule::connect();
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v6 = operator new(0x20uLL);
  *uint64_t v6 = off_101A74370;
  v6[1] = v1;
  v6[2] = sub_100F667E4;
  double v6[3] = 0;
  *((void *)&v31 + 1) = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(&buf);
  if (SBYTE7(v21[0]) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  int v7 = operator new(0x28uLL);
  void *v7 = off_101A743F0;
  v7[1] = v1 + 112;
  v7[2] = v1;
  v7[3] = sub_100F66808;
  v7[4] = 0;
  *((void *)&v31 + 1) = v7;
  ctu::RestModule::observeProperty();
  int v8 = (capabilities::ct *)sub_10003F600(&buf);
  if (SBYTE7(v21[0]) < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v8))
  {
    sub_100058DB0(__p, "/cc/props/user_preferred_data_slot");
    *(void *)&long long buf = off_101A74470;
    *((void *)&buf + 1) = v1 + 136;
    *(void *)&long long v31 = v1;
    *((void *)&v31 + 1) = &buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(&buf);
    if (SBYTE7(v21[0]) < 0) {
      operator delete(__p[0]);
    }
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100F694C0;
  aBlock[3] = &unk_101A744E0;
  aBlock[4] = v1 + 8;
  aBlock[5] = sub_100F66BA4;
  aBlock[6] = 0;
  uint64_t v9 = _Block_copy(aBlock);
  uint64_t v10 = *(std::__shared_weak_count **)(v1 + 16);
  if (v10)
  {
    int v11 = std::__shared_weak_count::lock(v10);
    if (v11)
    {
      uint64_t v12 = v11;
      unsigned int v13 = *(NSObject **)(v1 + 24);
      dispatch_object_t object = v13;
      if (v9)
      {
        uint64_t v14 = _Block_copy(v9);
        unsigned int v13 = object;
      }
      else
      {
        uint64_t v14 = 0;
      }
      BOOL v19 = v14;
      dispatch_retain(v13);
      v21[0] = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_100F6996C(v22, v13, v14);
      sub_100F6996C(v23, v22[0], v22[1]);
      sub_100F6996C(v26, v23[0], v23[1]);
      uint64_t v24 = 0;
      sub_100F6996C(v27, v26[0], v26[1]);
      sub_100F6996C(v28, v27[0], v27[1]);
      sub_100F6996C(v29, v28[0], v28[1]);
      sub_100F6996C((NSObject **)&buf, v29[0], v29[1]);
      sub_100F6996C(&v25, buf, *((void **)&buf + 1));
      sub_100F6A3B8((uint64_t)&buf);
      sub_100F6A3B8((uint64_t)v29);
      sub_100F6A3B8((uint64_t)v28);
      uint64_t v24 = &off_101A74618;
      sub_100F6A3B8((uint64_t)v27);
      sub_100F6A3B8((uint64_t)v26);
      long long buf = 0u;
      long long v31 = 0u;
      sub_100F69F74((uint64_t)&buf, (uint64_t *)&v24);
      sub_100F69F74((uint64_t)&v24, (uint64_t *)v21 + 1);
      sub_100F69F74((uint64_t)v21 + 8, (uint64_t *)&buf);
      sub_100F6A034((uint64_t *)&buf);
      sub_100F6A034((uint64_t *)&v24);
      sub_100F6A3B8((uint64_t)v23);
      sub_100F6A3B8((uint64_t)v22);
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F68938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a2)
  {
    sub_100163C60((void ***)&a41);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100F68950(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a53);
    if (a41) {
      (*(void (**)(uint64_t))(*(void *)a41 + 8))(a41);
    }
    std::__shared_weak_count::__release_weak(v53);
    JUMPOUT(0x100F68BE4);
  }
  _Unwind_Resume(a1);
}

void sub_100F68988(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100F68AB4);
}

void sub_100F689A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  sub_100160AF8(v5);
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  JUMPOUT(0x100F68C10);
}

void sub_100F689C0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100F68A00(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint **a13)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(a13);
    JUMPOUT(0x100F68BDCLL);
  }
  _Unwind_Resume(a1);
}

void sub_100F68A14(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100F697B8(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100F68A34(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v3);
    *(void *)uint64_t v2 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v2 + 16));
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100F68A50(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100F68A58);
  }
  _Unwind_Resume(a1);
}

void sub_100F68A74(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100F68A7CLL);
  }
  _Unwind_Resume(a1);
}

void sub_100F68ABC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100F68BE4);
}

void sub_100F68AC8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100F68AD4);
  }
  _Unwind_Resume(a1);
}

void sub_100F68B04(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100F68B10);
  }
  _Unwind_Resume(a1);
}

void sub_100F68B28(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a15);
  sub_100046B58(&a14);
  JUMPOUT(0x100F68C10);
}

void sub_100F68B50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_100088C88(&a15);
  sub_100046B58(&a14);
  JUMPOUT(0x100F68C10);
}

void sub_100F68B64(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100F68BF4);
}

void sub_100F68B70(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100F68BD4);
  }
  _Unwind_Resume(a1);
}

void sub_100F68C18(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 144) + 32))(*(void *)(v1 + 144));
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I AttachApnModule started", buf, 2u);
  }
  operator delete();
}

void sub_100F68CCC()
{
}

uint64_t *sub_100F68CF8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v2 + 144) + 40))(*(void *)(v2 + 144));
  uint64_t v4 = *(void **)(v2 + 160);
  if (v4 != (void *)(v2 + 168))
  {
    do
    {
      (*(void (**)(void))(*(void *)v4[5] + 24))(v4[5]);
      BOOL v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          BOOL v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          uint64_t v4 = v6;
        }
        while (!v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != (void *)(v2 + 168));
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  int v8 = (atomic_uint **)(v2 + 88);
  for (uint64_t i = *(void *)(v2 + 96); (atomic_uint **)i != v8; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84(v8);
  sub_100088C88(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100F68E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100F68E6C()
{
}

__n128 sub_100F68E80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A74370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F68ED4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F68F0C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F68F54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F68F94()
{
}

void sub_100F68FA4()
{
}

__n128 sub_100F68FB8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A743F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F6900C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A743F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F69044(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = &v15;
  sub_10008AAD8((uint64_t)&v14, a2);
  uint64_t v4 = v3 + 1;
  BOOL v5 = (void *)v3[1];
  int v11 = (void **)*v3;
  uint64_t v12 = v5;
  if (v3[2])
  {
    v5[2] = &v12;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v11 = &v12;
  }
  uint64_t v9 = v14;
  v10[0] = v15;
  v10[1] = v16;
  if (v16)
  {
    v15[2] = v10;
    uint64_t v14 = &v15;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  sub_100A555B4((uint64_t)v3, &v9);
  sub_100087F94((uint64_t)&v9, v10[0]);
  if (rest::operator!=())
  {
    uint64_t v6 = (void (*)(void *, void ***))a1[3];
    uint64_t v7 = a1[4];
    int v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
    }
    v6(v8, &v11);
  }
  sub_100087F94((uint64_t)&v11, v12);
  sub_100087F94((uint64_t)&v14, v15);
}

void sub_100F69184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14, uint64_t a15, char a16, void *a17)
{
}

uint64_t sub_100F691C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F69204()
{
}

void sub_100F69214()
{
}

__n128 sub_100F69228(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A74470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F69274(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F692A4(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v4 = *(int **)(a1 + 8);
  int v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    *(_DWORD *)uint64_t v20 = *v4;
    xpc_type_t type = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v20, (int *)a2, v7);
    *uint64_t v4 = *(_DWORD *)v20;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t type = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
    *uint64_t v4 = (int)type;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(type))
  {
    int v11 = *(_DWORD *)(v10 + 136);
    BOOL v12 = v11 == v5 || v5 == 0;
    BOOL v13 = v12 || v5 == 3;
    BOOL v14 = v13 || v11 == 0;
    if (!v14 && v11 != 3)
    {
      uint64_t v16 = *(NSObject **)(v10 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = subscriber::asString();
        uint64_t v19 = subscriber::asString();
        *(_DWORD *)uint64_t v20 = 136315394;
        *(void *)&v20[4] = v18;
        *(_WORD *)&v20[12] = 2080;
        *(void *)&v20[14] = v19;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Changing preferred data sim from %s -> %s", v20, 0x16u);
      }
      sub_100F66DC0(v20, v10, 1);
      (*(void (**)(void))(**(void **)v20 + 72))(*(void *)v20);
      if (*(void *)&v20[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v20[8]);
      }
    }
  }
}

void sub_100F69454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F69474(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F694B4()
{
}

uint64_t sub_100F694C0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F6950C(uint64_t a1)
{
  sub_100F6A034((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100F69550(uint64_t a1)
{
  sub_100F6989C(a1);

  operator delete();
}

BOOL sub_100F69588(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_100C9EE7C((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_100C9EE7C((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_100F696C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F69704(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100F69730(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100F6975C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_100F697B8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100F6A034((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100F69818()
{
}

uint64_t sub_100F6982C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100F6A034((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100F69884()
{
  return 0;
}

uint64_t sub_100F6988C()
{
  return 0;
}

uint64_t sub_100F69894()
{
  return 0;
}

uint64_t sub_100F6989C(uint64_t a1)
{
  *(void *)a1 = off_101A74510;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100F69910()
{
}

uint64_t sub_100F69924(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F69954()
{
  return 0;
}

uint64_t sub_100F6995C()
{
  return 0;
}

uint64_t sub_100F69964()
{
  return 0;
}

NSObject **sub_100F6996C(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_100F699BC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100F6996C((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100F6A3B8(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotERKNSt3_"
                                    "_112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100F69A94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v17 = *(void *)(a3 + 16);
  }
  uint64_t v4 = *(const void **)(a1 + 8);
  if (v4 && (uint64_t v5 = _Block_copy(v4)) != 0 && (v6 = _Block_copy(v5), (v7 = v6) != 0))
  {
    int v8 = _Block_copy(v6);
    uint64_t v9 = v8;
    if (v8)
    {
      uint64_t v10 = _Block_copy(v8);
      int v11 = v10;
      if (v10)
      {
        BOOL v12 = _Block_copy(v10);
        BOOL v13 = v12;
        if (v12)
        {
          BOOL v14 = _Block_copy(v12);
          uint64_t v15 = v14;
          if (v14)
          {
            *(void *)&long long v19 = _Block_copy(v14);
            _Block_release(v15);
          }
          else
          {
            *(void *)&long long v19 = 0;
          }
          _Block_release(v13);
        }
        else
        {
          *(void *)&long long v19 = 0;
        }
        _Block_release(v11);
      }
      else
      {
        *(void *)&long long v19 = 0;
      }
      uint64_t v18 = off_101A74658;
      _Block_release(v9);
    }
    else
    {
      uint64_t v18 = off_101A74658;
      *(void *)&long long v19 = 0;
    }
    _Block_release(v7);
  }
  else
  {
    uint64_t v18 = off_101A74658;
    *(void *)&long long v19 = 0;
  }
  operator new();
}

void sub_100F69D58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_100F69DD4(uint64_t a1)
{
  sub_100C9F08C(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100F6A034(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    operator delete();
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete();
  }
  return result;
}

void sub_100F69E88(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      int v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotERKNSt3__112ba"
                                                  "sic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100F69F64(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100F69F74(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100F6A010(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100F6A020(_Unwind_Exception *a1)
{
}

uint64_t *sub_100F6A034(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100F6A088(void *a1)
{
  *a1 = off_101A74688;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F6A0D4(void *a1)
{
  *a1 = off_101A74688;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100F6A140(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100F6A1F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F6A208(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100F6A228()
{
}

void *sub_100F6A294(void *a1)
{
  *a1 = off_101A746D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F6A2E0(void *a1)
{
  *a1 = off_101A746D8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F6A34C()
{
}

uint64_t sub_100F6A3B8(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F6A3F8()
{
}

__n128 sub_100F6A40C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A74718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F6A458(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F6A488(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 != AttachApnManagerInterface::getPushCount_sync((AttachApnManagerInterface *)a1))
  {
    uint64_t v3 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I handleCarrierBundlesUpdated_sync: AttachAPN settings were pushed", v4, 2u);
    }
  }
}

uint64_t sub_100F6A500(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6A540()
{
}

uint64_t sub_100F6A54C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)(*(void *)v1 + 168);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)v1 + 168;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      int v8 = (uint64_t *)v4;
    }
    else {
      int v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != *(void *)v1 + 168 && *(_DWORD *)(v5 + 32) <= v3)
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asStringBool(*(unsigned char *)(v1 + 12));
      LODWORD(v14) = 136315138;
      *(void *)((char *)&v14 + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I alwaysPush = %s", (uint8_t *)&v14, 0xCu);
    }
    sub_100F66DC0(&v14, v2, *(_DWORD *)(v1 + 8));
    uint64_t v10 = (*(uint64_t (**)(void, void, void))(*(void *)v14 + 80))(v14, *(unsigned __int8 *)(v1 + 12), 0);
    if (*((void *)&v14 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
    }
  }
  else
  {
LABEL_11:
    uint64_t v9 = *(NSObject **)(v2 + 40);
    uint64_t v10 = 0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v14) = 136315138;
      *(void *)((char *)&v14 + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E triggerBundleCheck: Invalid simSlot: %s", (uint8_t *)&v14, 0xCu);
      return 0;
    }
  }
  return v10;
}

void sub_100F6A71C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F6A73C(int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = v1[2];
  uint64_t v4 = *(void *)(*(void *)v1 + 168);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)v1 + 168;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      int v8 = (uint64_t *)v4;
    }
    else {
      int v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != *(void *)v1 + 168 && *(_DWORD *)(v5 + 32) <= v3)
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = v1[3];
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v20) = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I setAttachAPNSettingsType xpc_type_t type = %d for current sim", buf, 8u);
    }
    sub_100F66DC0(&v17, v2, v1[2]);
    uint64_t v12 = v17;
    uint64_t v13 = v1[3];
    sub_1000F0058((uint64_t)buf, (uint64_t)(v1 + 4));
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v12 + 40))(v12, v13, buf);
    sub_10003B34C(buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
  else
  {
LABEL_11:
    uint64_t v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v20 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E setAttachAPNSettingsType: Invalid simSlot: %s", buf, 0xCu);
    }
  }
  sub_100F6A968((uint64_t *)&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100F6A928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100F6A968(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F6A968(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10003B34C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100F6A9B8(uint64_t ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  long long v19 = v1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*v1, (Registry *)(*v1)[7]);
  int v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v22 = (unsigned int *)v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v22);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_26;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10) {
    goto LABEL_26;
  }
LABEL_10:
  subscriber::makeSimSlotRange();
  uint64_t v13 = v22;
  uint64_t v12 = v23;
  if (v22 != v23)
  {
    long long v14 = v24;
    while ((v14(*v13) & 1) == 0)
    {
      if (++v13 == v12)
      {
        uint64_t v13 = v12;
        break;
      }
    }
    uint64_t v15 = v23;
LABEL_16:
    while (v13 != v15)
    {
      uint64_t v20 = 0;
      int v21 = 0;
      sub_10022EDC4(v10, &v20);
      if (v20) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 72))(v20, 1);
      }
      if (v21) {
        sub_10004D2C8(v21);
      }
      uint64_t v16 = v13 + 1;
      uint64_t v13 = v12;
      if (v16 != v12)
      {
        uint64_t v13 = v16;
        while ((v14(*v13) & 1) == 0)
        {
          if (++v13 == v12)
          {
            uint64_t v13 = v12;
            goto LABEL_16;
          }
        }
      }
    }
  }
LABEL_26:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  sub_100088C88((uint64_t *)&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100F6AB84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F6ABDC()
{
}

void *sub_100F6ABF0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A747F8;
  return result;
}

void sub_100F6AC28(uint64_t a1, void *a2)
{
  *a2 = off_101A747F8;
}

uint64_t sub_100F6AC54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6AC94()
{
}

uint64_t sub_100F6ACA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)v1;
  uint64_t v7 = *(void *)(v4 + 168);
  uint64_t v5 = v4 + 168;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = v5;
  do
  {
    int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 < v3;
    if (v9 >= v3) {
      char v11 = (uint64_t *)v6;
    }
    else {
      char v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 != v5 && *(_DWORD *)(v8 + 32) <= v3)
  {
    sub_100F66DC0(&v15, v2, v3);
    uint64_t v13 = (*(uint64_t (**)(void))(*(void *)v15 + 56))(v15);
    if (*((void *)&v15 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
    }
  }
  else
  {
LABEL_11:
    uint64_t v12 = *(NSObject **)(v2 + 40);
    uint64_t v13 = 0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v15) = 136315138;
      *(void *)((char *)&v15 + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E settingFromUIAllowed: Invalid simSlot: %s", (uint8_t *)&v15, 0xCu);
      return 0;
    }
  }
  return v13;
}

void sub_100F6ADE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F6AE08(_DWORD **a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = v1[2];
  uint64_t v4 = *(void *)(*(void *)v1 + 168);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)v1 + 168;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != *(void *)v1 + 168 && *(_DWORD *)(v5 + 32) <= v3)
  {
    sub_100F66DC0(buf, v2, v3);
    char v11 = (*(uint64_t (**)(void))(**(void **)buf + 56))(*(void *)buf);
    sub_1000607A8((uint64_t)(v1 + 4), v11);
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
  else
  {
LABEL_11:
    int v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E settingFromUIAllowed: Invalid sim slot", buf, 2u);
    }
    sub_1000607A8((uint64_t)(v1 + 4), 0);
  }
  sub_10041EF98((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100F6AF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10041EF98(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F6AF7C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)(*(void *)v1 + 168);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)v1 + 168;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != *(void *)v1 + 168 && *(_DWORD *)(v5 + 32) <= v3)
  {
    uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    sub_100F66DC0(&v22, v2, *(_DWORD *)(v1 + 8));
    uint64_t v13 = v22;
    int v14 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v22 + 80))(v22, *(unsigned __int8 *)(v1 + 12), 0);
    long long v15 = *v12;
    BOOL v16 = os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v16)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I pushAttachAPNSettings: start to push", buf, 2u);
      }
      *(void *)long long buf = v12;
      sub_1000F0058((uint64_t)&buf[8], v1 + 16);
      char v26 = 0;
      uint64_t v17 = operator new(0x30uLL);
      uint64_t v18 = *(void *)buf;
      void *v17 = off_101A74898;
      v17[1] = v18;
      sub_1000DA470((uint64_t)(v17 + 2), (uint64_t)&buf[8]);
      char v26 = v17;
      (*(void (**)(uint64_t, void *))(*(void *)v13 + 88))(v13, v25);
      sub_10003B34C(v25);
      sub_10003B34C(&buf[8]);
    }
    else
    {
      if (v16)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I pushAttachAPNSettings: no need to push", buf, 2u);
      }
      uint64_t v19 = *(void *)(v1 + 40);
      if (!v19) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t))(*(void *)v19 + 48))(v19);
    }
    if (v23) {
      sub_10004D2C8(v23);
    }
  }
  else
  {
LABEL_11:
    int v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E pushAttachAPNSettings: Invalid simSlot: %s", buf, 0xCu);
    }
    uint64_t v10 = *(void *)(v1 + 40);
    if (!v10) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v10 + 48))(v10);
  }
  sub_100F6B2D0(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100F6B280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_10003B34C(&a18);
  sub_10003B34C(v18);
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100F6B2D0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F6B2D0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10003B34C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void *sub_100F6B320(void *a1)
{
  *a1 = off_101A74898;
  sub_10003B34C(a1 + 2);
  return a1;
}

void sub_100F6B364(void *a1)
{
  *a1 = off_101A74898;
  sub_10003B34C(a1 + 2);

  operator delete();
}

void *sub_100F6B3C8(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A74898;
  v2[1] = v3;
  sub_1000F0058((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100F6B420(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F6B434(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A74898;
  a2[1] = v2;
  return sub_1000F0058((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100F6B464(uint64_t a1)
{
  return sub_10003B34C((void *)(a1 + 16));
}

void sub_100F6B46C(void *a1)
{
  sub_10003B34C(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100F6B4A8(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I pushAttachAPNSettings: completed", v5, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
}

uint64_t sub_100F6B540(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6B580()
{
}

uint64_t sub_100F6B590(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100F6B5CC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100F6B608(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)(*(void *)v1 + 168);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)v1 + 168;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != *(void *)v1 + 168 && *(_DWORD *)(v5 + 32) <= v3)
  {
    sub_100F66DC0(&v12, v2, *(_DWORD *)(v1 + 8));
    uint64_t v10 = (*(uint64_t (**)(void, void))(*(void *)v12 + 48))(v12, *(unsigned int *)(v1 + 12));
    if (*((void *)&v12 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
    }
  }
  else
  {
LABEL_11:
    int v9 = *(NSObject **)(v2 + 40);
    uint64_t v10 = 0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v12) = 136315138;
      *(void *)((char *)&v12 + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E isAttachAPNTypeSupported: Invalid simSlot: %s", (uint8_t *)&v12, 0xCu);
      return 0;
    }
  }
  return v10;
}

void sub_100F6B754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F6B774(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v4 = *(void *)v1;
  uint64_t v7 = *(void *)(v4 + 168);
  uint64_t v5 = v4 + 168;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = v5;
  do
  {
    int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 < v3;
    if (v9 >= v3) {
      char v11 = (uint64_t *)v6;
    }
    else {
      char v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 != v5 && *(_DWORD *)(v8 + 32) <= v3)
  {
    sub_100F66DC0(&v13, v2, v3);
    (*(void (**)(void))(*(void *)v13 + 64))(v13);
    if (*((void *)&v13 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
    }
  }
  else
  {
LABEL_11:
    long long v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v13) = 136315138;
      *(void *)((char *)&v13 + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E handlePRIFilePushed: Invalid simSlot: %s", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sub_100F6B8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F6B8C4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void **)(v1 + 160);
  int v3 = (void *)(v1 + 168);
  if (v2 != (void *)(v1 + 168))
  {
    do
    {
      (*(void (**)(void))(*(void *)v2[5] + 96))(v2[5]);
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  operator delete();
}

void sub_100F6B98C()
{
}

void TimeHandler::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F6BEFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, dispatch_object_t object, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_100F6C178(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100F6C11CLL);
}

void sub_100F6C1A0()
{
}

const char *sub_100F6C1A8(int a1)
{
  uint64_t v1 = "time.?";
  if (a1 == 2) {
    uint64_t v1 = "time.2";
  }
  if (a1 == 1) {
    return "time.1";
  }
  else {
    return v1;
  }
}

void sub_100F6C1D4(uint64_t a1)
{
  *(void *)a1 = off_101A749B8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1840);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 1824);
  if (v3) {
    sub_10004D2C8(v3);
  }
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 1796));
  sub_10005D0E4(a1 + 1760, *(void **)(a1 + 1768));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 1752);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 1736);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10003FB28(a1 + 1704, *(void **)(a1 + 1712));
  sub_100136194(a1 + 896);
  sub_100136194(a1 + 96);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_1006020EC((const void **)(a1 + 72));
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  TimeHandlerInterface::~TimeHandlerInterface((TimeHandlerInterface *)a1);
}

void sub_100F6C2EC(uint64_t a1)
{
  sub_100F6C1D4(a1);

  operator delete();
}

void sub_100F6C324(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6C424(uint64_t a1, int a2, int a3, int a4, MCC *a5, const MCC *a6, int a7, char a8)
{
  MCC::MCC((MCC *)&v13, a5);
  MCC::MCC((MCC *)&v14, a6);
  int v15 = a7;
  char v16 = a8;
  long long v12 = *(std::__shared_weak_count **)(a1 + 16);
  if (v12)
  {
    if (std::__shared_weak_count::lock(v12)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6C5D4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 + 111) < 0) {
    operator delete(*(void **)(v26 + 88));
  }
  sub_10006A6AC(a1);
}

void sub_100F6C614(uint64_t a1, int a2, int a3, int a4, MCC *a5, const MCC *a6, int a7, char a8)
{
  MCC::MCC((MCC *)&v13, a5);
  MCC::MCC((MCC *)&v14, a6);
  int v15 = a7;
  char v16 = a8;
  long long v12 = *(std::__shared_weak_count **)(a1 + 16);
  if (v12)
  {
    if (std::__shared_weak_count::lock(v12)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6C7C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 + 111) < 0) {
    operator delete(*(void **)(v26 + 88));
  }
  sub_10006A6AC(a1);
}

void sub_100F6C804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  BOOL v25 = 0;
  sub_100061DC4(&v24, a1, a2);
  uint64_t v17 = v24;
  if (v24)
  {
    sub_100670390(&v23, (const void **)(a1 + 72));
    long long v18 = *(_OWORD *)(a3 + 16);
    v21[0] = *(_OWORD *)a3;
    v21[1] = v18;
    uint64_t v22 = *(void *)(a3 + 48);
    _OWORD v21[2] = *(_OWORD *)(a3 + 32);
    (*(void (**)(uint64_t, const void **, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char))(*(void *)v17 + 32))(v17, &v23, v21, a4, a5, a6, a7, a8, a9);
    sub_1006020EC(&v23);
  }
  else
  {
    uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find model for reporting time update", buf, 2u);
    }
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100F6C978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F6C9A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1696))
  {
    (*(void (**)(void))(**(void **)(a1 + 1816) + 384))(*(void *)(a1 + 1816));
    uint64_t v2 = *(void **)(a1 + 1760);
    if (v2 != (void *)(a1 + 1768))
    {
      do
      {
        (*(void (**)(void))(*(void *)v2[5] + 72))(v2[5]);
        int v3 = (void *)v2[1];
        if (v3)
        {
          do
          {
            uint64_t v4 = v3;
            int v3 = (void *)*v3;
          }
          while (v3);
        }
        else
        {
          do
          {
            uint64_t v4 = (void *)v2[2];
            BOOL v5 = *v4 == (void)v2;
            uint64_t v2 = v4;
          }
          while (!v5);
        }
        uint64_t v2 = v4;
      }
      while (v4 != (void *)(a1 + 1768));
    }
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Airplane mode has been enabled, resetting all timestamps, location", v7, 2u);
    }
  }
}

void sub_100F6CAB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6CBB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6CCC0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 1784)) {
      int v3 = "true";
    }
    else {
      int v3 = "false";
    }
    int v12 = 136315138;
    uint64_t v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Fetch Time From Network Request Active: %s", (uint8_t *)&v12, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 1696)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v12 = 136315138;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Airplane mode toggled: %s", (uint8_t *)&v12, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 1832)) {
      BOOL v5 = "true";
    }
    else {
      BOOL v5 = "false";
    }
    int v12 = 136315138;
    uint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Airplane mode assertion held: %s", (uint8_t *)&v12, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 1788);
    int v12 = 67109120;
    LODWORD(v13) = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Time cache validity period: %d", (uint8_t *)&v12, 8u);
  }
  uint64_t v7 = *(void **)(a1 + 1760);
  uint64_t v8 = (void *)(a1 + 1768);
  if (v7 != v8)
  {
    do
    {
      (*(void (**)(void))(*(void *)v7[5] + 80))(v7[5]);
      int v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          uint64_t v7 = v10;
        }
        while (!v11);
      }
      uint64_t v7 = v10;
    }
    while (v10 != v8);
  }
}

void sub_100F6CEE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6CFF4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1784))
  {
    int v2 = *(unsigned __int8 *)(a1 + 1792);
    int v3 = *(_DWORD *)(a1 + 1804);
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v5 = "Is Not";
      if (v3 != 5) {
        BOOL v5 = "Is";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s in Emergency", (uint8_t *)&buf, 0xCu);
      uint64_t v4 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "are not";
      if (v2) {
        int v6 = "are";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Cellular calls %s active", (uint8_t *)&buf, 0xCu);
    }
    if (v2 || v3 != 5)
    {
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 60;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Delaying for %lld seconds until checking again", (uint8_t *)&buf, 0xCu);
      }
      Registry::getTimerService(&v24, *(Registry **)(a1 + 56));
      uint64_t v10 = v24;
      sub_100058DB0(v22, "Force fetch network time");
      BOOL v11 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v11 || (v12 = *(void *)(a1 + 8), (uint64_t v13 = std::__shared_weak_count::lock(v11)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v14 = v13;
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      *(_OWORD *)std::string __p = *(_OWORD *)v22;
      uint64_t v27 = v23;
      v22[0] = 0;
      v22[1] = 0;
      uint64_t v23 = 0;
      *(void *)&long long buf = off_101A74E20;
      *((void *)&buf + 1) = v12;
      uint64_t v29 = v14;
      p_long long buf = &buf;
      (*(void (**)(uint64_t, void **, void, uint64_t, long long *))(*(void *)v10 + 32))(v10, __p, 0, 60000000, &buf);
      sub_10003B34C(&buf);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v23) < 0) {
        operator delete(v22[0]);
      }
      if (v25) {
        sub_10004D2C8(v25);
      }
    }
    else
    {
      if (*(void *)(a1 + 1832))
      {
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Network time fetch request is pending with airplane mode assertion held", (uint8_t *)&buf, 2u);
        }
      }
      else
      {
        sub_100058DB0(&buf, "/cc/assertions/airplane_mode");
        ctu::rest::AssertionHandle::create();
        if (SHIBYTE(v29) < 0) {
          operator delete((void *)buf);
        }
        long long v15 = *(_OWORD *)__p;
        __p[0] = 0;
        __p[1] = 0;
        char v16 = *(std::__shared_weak_count **)(a1 + 1840);
        *(_OWORD *)(a1 + 1832) = v15;
        if (v16)
        {
          sub_10004D2C8(v16);
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
        }
        uint64_t v17 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v17 || (uint64_t v18 = *(void *)(a1 + 8), (v19 = std::__shared_weak_count::lock(v17)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v20 = v19;
        atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        uint64_t v21 = (long long *)operator new(0x20uLL);
        *(void *)uint64_t v21 = off_101A74EA0;
        *((void *)v21 + 1) = v18;
        *((void *)v21 + 2) = v20;
        *((void *)v21 + 3) = a1;
        p_long long buf = v21;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(&buf);
      }
      *(unsigned char *)(a1 + 1784) = 0;
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Network Time fetch request is not active anymore", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_100F6D3D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_100F6D468(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F6D558(uint64_t a1)
{
  unsigned int v5 = 0;
  v4[0] = &v5;
  v4[1] = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100F6FC84;
  block[3] = &unk_101A74F90;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
  return v5;
}

void sub_100F6D5F0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F6D628(uint64_t a1)
{
}

uint64_t sub_100F6D644(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F6D688(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F6D6B4(ServiceManager::Service *this)
{
  *(void *)this = off_101A74B60;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F6D710(ServiceManager::Service *this)
{
  *(void *)this = off_101A74B60;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F6D780@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TimeHandler");
}

unsigned char *sub_100F6D790@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F6D7D0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F6C324(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F6C324(v4, 0);
}

uint64_t sub_100F6D854()
{
  return 0;
}

uint64_t sub_100F6D85C()
{
  return 1;
}

uint64_t sub_100F6D864()
{
  return 0;
}

void sub_100F6D870(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6D950(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F6DA68()
{
}

uint64_t sub_100F6DA7C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100F6DA88(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 80));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F6DB0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F6DB28(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v41 = a1;
  uint64_t v42 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  *(void *)(v2 + 1744) = v13;
  long long v15 = *(std::__shared_weak_count **)(v2 + 1752);
  *(void *)(v2 + 1752) = v12;
  if (v15) {
    sub_10004D2C8(v15);
  }
  char v16 = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(v2 + 56));
  uint64_t v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)long long buf = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
  if (v22)
  {
    uint64_t v24 = v22[3];
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v23 = 0;
LABEL_21:
  *(void *)(v2 + 1728) = v24;
  uint64_t v26 = *(std::__shared_weak_count **)(v2 + 1736);
  *(void *)(v2 + 1736) = v23;
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(v2 + 56));
  BOOL v28 = v27;
  if (v29 < 0)
  {
    int v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  *(void *)long long buf = v29;
  char v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
  if (v33)
  {
    uint64_t v35 = v33[3];
    __int16 v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v28);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v28);
  __int16 v34 = 0;
LABEL_31:
  *(void *)(v2 + 1816) = v35;
  int v36 = *(std::__shared_weak_count **)(v2 + 1824);
  *(void *)(v2 + 1824) = v34;
  if (v36) {
    sub_10004D2C8(v36);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v37 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v37 = off_101A74C20;
  *((void *)v37 + 1) = v2;
  *((void *)v37 + 2) = sub_100F6CCC0;
  *((void *)v37 + 3) = 0;
  long long v48 = v37;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_net_info1");
  *(void *)long long buf = off_101A74CA0;
  int v46 = (std::__shared_weak_count *)(v2 + 96);
  uint64_t v47 = v2;
  long long v48 = buf;
  ctu::RestModule::observeProperty();
  __int16 v38 = (capabilities::ct *)sub_10003F600(buf);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsGemini(v38))
  {
    sub_100058DB0(__p, "/cc/props/reg_net_info2");
    *(void *)long long buf = off_101A74D20;
    int v46 = (std::__shared_weak_count *)(v2 + 896);
    uint64_t v47 = v2;
    long long v48 = buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (v44 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  char v39 = (uint8_t *)operator new(0x28uLL);
  *(void *)char v39 = off_101A74DA0;
  *((void *)v39 + 1) = v2 + 1696;
  *((void *)v39 + 2) = v2;
  *((void *)v39 + 3) = sub_100F6C9A0;
  *((void *)v39 + 4) = 0;
  long long v48 = v39;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  sub_1002D795C(v2 + 1792);
  sub_1002D7B1C(v2 + 1796);
  sub_100D3EA30(v2 + 1704);
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)buf, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v46) {
    sub_10004D2C8(v46);
  }
  sub_100088C88(&v42);
  return sub_100046B58((uint64_t *)&v41);
}

void sub_100F6DFD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100F6E054()
{
}

__n128 sub_100F6E068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A74C20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F6E0BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74C20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F6E0F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F6E13C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6E17C()
{
}

void sub_100F6E18C()
{
}

__n128 sub_100F6E1A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A74CA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F6E1EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74CA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F6E21C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6E25C()
{
}

void sub_100F6E26C()
{
}

__n128 sub_100F6E280(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A74D20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F6E2CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74D20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F6E2FC(uint64_t a1, const xpc::object *a2)
{
  uint64_t v4 = *(const RegisteredNetworkInfo **)(a1 + 8);
  bzero(v6, 0x320uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)v6, v4);
  read_rest_value(v4, a2);
  sub_100068B28(*(void *)(a1 + 16), 2, (uint64_t)v6, *(void *)(a1 + 16) + 896);
  if (v15 && v14 < 0) {
    operator delete(__p);
  }
  sub_10002B2D8((uint64_t)&v12);
  sub_10002B28C((uint64_t)&v11);
  sub_10002B1F4((uint64_t)&v10);
  sub_10002B1A8((uint64_t)&v9);
  sub_10002B1A8((uint64_t)&v8);
  return sub_10002B240((uint64_t)&v7);
}

void sub_100F6E3E4(_Unwind_Exception *a1)
{
}

uint64_t sub_100F6E444(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6E484()
{
}

void sub_100F6E494()
{
}

__n128 sub_100F6E4A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A74DA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F6E4FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A74DA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F6E534(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  unsigned int v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    unsigned int v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_100F6E5BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6E5FC()
{
}

void sub_100F6E608(uint64_t **a1)
{
  uint64_t v6 = a1;
  uint64_t v1 = **a1;
  CFCalendarRef v2 = CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  CFTimeZoneRef v3 = *(const __CFTimeZone **)(v1 + 72);
  *(void *)(v1 + 72) = v2;
  CFTimeZoneRef v8 = v3;
  sub_1006020EC((const void **)&v8);
  CFTimeZoneRef v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorSystemDefault, 0.0);
  CFCalendarSetTimeZone(*(CFCalendarRef *)(v1 + 72), v8);
  if (*(void *)(v1 + 72)) {
    uint64_t v4 = sub_100670388;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
    unsigned int v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Could not create gregorian calendar", buf, 2u);
    }
  }
  sub_1005653C4((const void **)&v8);
  operator delete();
}

void sub_100F6E710(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1005653C4((const void **)va);
  operator delete();
}

uint64_t *sub_100F6E74C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  long long v4 = *(_OWORD *)(v1 + 32);
  v8[0] = *(_OWORD *)(v1 + 16);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(v1 + 48);
  uint64_t v9 = *(void *)(v1 + 64);
  sub_100F6C804(v2, v3, (uint64_t)v8, *(unsigned int *)(v1 + 72), v1 + 80, v1 + 112, *(unsigned int *)(v1 + 144), *(unsigned __int8 *)(v1 + 148), 1);
  sub_100F6E7E8(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100F6E7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  sub_100F6E7E8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F6E7E8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 143) < 0) {
      operator delete(*(void **)(v1 + 120));
    }
    if (*(char *)(v1 + 111) < 0) {
      operator delete(*(void **)(v1 + 88));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100F6E850(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  long long v4 = *(_OWORD *)(v1 + 32);
  v8[0] = *(_OWORD *)(v1 + 16);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(v1 + 48);
  uint64_t v9 = *(void *)(v1 + 64);
  sub_100F6C804(v2, v3, (uint64_t)v8, *(unsigned int *)(v1 + 72), v1 + 80, v1 + 112, *(unsigned int *)(v1 + 144), *(unsigned __int8 *)(v1 + 148), 0);
  sub_100F6E7E8(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100F6E8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  sub_100F6E7E8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F6E8E8(void ****a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((_DWORD *)*a1 + 2);
  if (v3 == 65534 || v3 == 0)
  {
    unsigned int v5 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 3));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      std::to_string(&v10, *((_DWORD *)v1 + 2));
      uint64_t v6 = (v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &v10
         : (std::string *)v10.__r_.__value_.__r.__words[0];
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Invalid values for LAC: %s", buf, 0xCu);
      if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v10.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    *(_OWORD *)&v10.__r_.__value_.__l.__data_ = 0uLL;
    sub_100061DC4(&v10, (uint64_t)v2, *((_DWORD *)v1 + 3));
    std::string::size_type v7 = v10.__r_.__value_.__r.__words[0];
    if (v10.__r_.__value_.__r.__words[0])
    {
      uint64_t v8 = ((uint64_t (*)(void **))(*v2)[11])(v2);
      (*(void (**)(std::string::size_type, uint64_t, void, void))(*(void *)v7 + 48))(v7, v8, *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 4));
    }
    else
    {
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 3));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find model for LAC update", buf, 2u);
      }
    }
    if (v10.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v10.__r_.__value_.__l.__size_);
    }
  }
  operator delete();
}

void sub_100F6EB1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  operator delete();
}

void sub_100F6EB60(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_100061DC4(&v5, v2, *((_DWORD *)v1 + 2));
  if (v5)
  {
    (*(void (**)(uint64_t, void, void, void))(*(void *)v5 + 64))(v5, *((unsigned int *)v1 + 3), *((unsigned int *)v1 + 4), *((unsigned int *)v1 + 5));
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Could not find model for SID/NID update", buf, 2u);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  operator delete();
}

void sub_100F6EC74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  operator delete();
}

uint64_t *sub_100F6ECB0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v24 = a1;
  uint64_t v25 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 1816);
  if (v3)
  {
    if ((*(_DWORD *)(v1 + 8) - 1) > 1
      || ((*(void (**)(uint64_t))(*(void *)v3 + 384))(v3), *(_DWORD *)(v1 + 8) != 1))
    {
      uint64_t v4 = *(void **)(v2 + 1760);
      if (v4 == (void *)(v2 + 1768))
      {
        unsigned int v6 = 2;
LABEL_49:
        uint64_t v20 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = asString();
          uint64_t v22 = asString();
          *(_DWORD *)BOOL v28 = 136315394;
          *(void *)&v28[4] = v21;
          *(_WORD *)&v28[12] = 2080;
          *(void *)&v28[14] = v22;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Received request to fetch time from network with type %s, and result is %s", v28, 0x16u);
        }
        xpc_object_t object = xpc_int64_create(v6);
        if (!object) {
          xpc_object_t object = xpc_null_create();
        }
        *(void *)BOOL v28 = *(void *)(v1 + 16);
        *(void *)&v28[8] = "kNetworkTimeFetchResult";
        sub_100035E70((uint64_t)v28, &object, (xpc_object_t *)buf);
        xpc_release(*(xpc_object_t *)buf);
        *(void *)long long buf = 0;
        xpc_release(object);
        goto LABEL_54;
      }
      uint64_t v5 = (uint64_t *)(v2 + 1712);
      unsigned int v6 = 2;
      while (1)
      {
        *(_OWORD *)std::string __p = 0u;
        long long v30 = 0u;
        memset(v28, 0, sizeof(v28));
        MCCAndMNC::MCCAndMNC((MCCAndMNC *)v28);
        uint64_t v7 = *v5;
        uint64_t v8 = *((unsigned int *)v4 + 8);
        if (*v5)
        {
          uint64_t v9 = v2 + 1712;
          do
          {
            int v10 = *(_DWORD *)(v7 + 32);
            BOOL v11 = v10 < (int)v8;
            if (v10 >= (int)v8) {
              uint64_t v12 = (uint64_t *)v7;
            }
            else {
              uint64_t v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if ((uint64_t *)v9 != v5 && (int)v8 >= *(_DWORD *)(v9 + 32))
          {
            MCC::operator=();
            MCC::operator=();
            uint64_t v8 = *((unsigned int *)v4 + 8);
          }
        }
        uint64_t v13 = v2 + 896;
        if (v8 == 2 || (uint64_t v13 = v2 + 96, v8 == 1))
        {
          unsigned int v6 = (*(uint64_t (**)(void, void, uint64_t, uint8_t *))(*(void *)v4[5] + 16))(v4[5], *(unsigned int *)(v1 + 8), v13, v28);
        }
        else
        {
          char v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v8, v13);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find model to fetch time from network", buf, 2u);
          }
        }
        if (v6 == 1) {
          break;
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__p[1]);
        }
        if ((char)v28[31] < 0) {
          operator delete(*(void **)&v28[8]);
        }
        char v15 = (void *)v4[1];
        if (v15)
        {
          do
          {
            char v16 = v15;
            char v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            char v16 = (void *)v4[2];
            BOOL v17 = *v16 == (void)v4;
            uint64_t v4 = v16;
          }
          while (!v17);
        }
        uint64_t v4 = v16;
        if (v16 == (void *)(v2 + 1768)) {
          goto LABEL_49;
        }
      }
      if (*(unsigned char *)(v2 + 1784))
      {
        uint64_t v19 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N A request is already active", buf, 2u);
        }
      }
      else
      {
        *(unsigned char *)(v2 + 1784) = 1;
        sub_100F6CFF4(v2);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete(__p[1]);
      }
      if ((char)v28[31] < 0) {
        operator delete(*(void **)&v28[8]);
      }
    }
    unsigned int v6 = 1;
    goto LABEL_49;
  }
  uint64_t v18 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v28 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find registration controller to fetch time from network", v28, 2u);
  }
  xpc_object_t object = xpc_int64_create(35);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)BOOL v28 = *(void *)(v1 + 16);
  *(void *)&v28[8] = "kPosixError";
  sub_100035E70((uint64_t)v28, &object, (xpc_object_t *)buf);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)long long buf = 0;
  xpc_release(object);
LABEL_54:
  sub_10013A778(&v25);
  return sub_100046B58((uint64_t *)&v24);
}

void sub_100F6F108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_10013A778(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_100F6F188(void *a1)
{
  *a1 = off_101A74E20;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F6F1D4(void *a1)
{
  *a1 = off_101A74E20;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100F6F240(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A74E20;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F6F29C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A74E20;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F6F2D4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F6F2E4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F6F324(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100F6F43C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F6F47C()
{
}

uint64_t *sub_100F6F488(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100F6CFF4(*v1);
  sub_1000E3958((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100F6F4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_100F6F4E8(void *a1)
{
  *a1 = off_101A74EA0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F6F534(void *a1)
{
  *a1 = off_101A74EA0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100F6F5A0(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *__n128 result = off_101A74EA0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100F6F604(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A74EA0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100F6F644(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F6F654(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F6F694(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[3];
    unsigned int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = a1[1];
      if (v8)
      {
        int v9 = *(_DWORD *)(*(void *)(v5 + 1832) + 68);
        if (v9)
        {
          int v10 = *(NSObject **)(v8 + 40);
          BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if (v4 && v9 == 2)
          {
            if (v11)
            {
              LODWORD(buf) = 134217984;
              *(void *)((char *)&buf + 4) = 5;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Acquired airplane mode assertion, delaying for %lld seconds before enabling radio", (uint8_t *)&buf, 0xCu);
            }
            Registry::getTimerService(&v18, *(Registry **)(v8 + 56));
            uint64_t v12 = v18;
            sub_100058DB0(v16, "Enable radio");
            uint64_t v14 = a1[1];
            uint64_t v13 = a1[2];
            if (v13) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
            }
            *(_OWORD *)std::string __p = *(_OWORD *)v16;
            uint64_t v21 = v17;
            v16[0] = 0;
            v16[1] = 0;
            uint64_t v17 = 0;
            *(void *)&long long buf = off_101A74F10;
            *((void *)&buf + 1) = v14;
            uint64_t v23 = v13;
            p_long long buf = &buf;
            (*(void (**)(uint64_t, void **, void, uint64_t, long long *))(*(void *)v12 + 32))(v12, __p, 0, 5000000, &buf);
            sub_10003B34C(&buf);
            if (SHIBYTE(v21) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v17) < 0) {
              operator delete(v16[0]);
            }
            char v15 = v19;
            if (!v19) {
              goto LABEL_21;
            }
            goto LABEL_20;
          }
          if (v11)
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Could not acquire airplane mode assertion", (uint8_t *)&buf, 2u);
          }
        }
        char v15 = *(std::__shared_weak_count **)(v5 + 1840);
        *(void *)(v5 + 1832) = 0;
        *(void *)(v5 + 1840) = 0;
        if (v15) {
LABEL_20:
        }
          sub_10004D2C8(v15);
      }
LABEL_21:
      sub_10004D2C8(v7);
    }
  }
}

void sub_100F6F8B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  sub_10003B34C(&a25);
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10004D2C8(v25);
  _Unwind_Resume(a1);
}

uint64_t sub_100F6F908(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F6F948()
{
}

void *sub_100F6F954(void *a1)
{
  *a1 = off_101A74F10;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F6F9A0(void *a1)
{
  *a1 = off_101A74F10;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100F6FA0C(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A74F10;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F6FA68(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A74F10;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F6FAA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F6FAB0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F6FAF0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        unsigned int v6 = *(std::__shared_weak_count **)(v5 + 1840);
        *(_OWORD *)(v5 + 1832) = 0u;
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100F6FB64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F6FBA4()
{
}

void sub_100F6FBB0(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  int v2 = *((_DWORD *)*a1 + 2);
  *(_DWORD *)(v1 + 1788) = v2;
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v6 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Time cache validity period has been set to %u", buf, 8u);
  }
  operator delete();
}

uint64_t sub_100F6FC84(uint64_t result)
{
  ***(_DWORD ***)(result + 40) = *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 1788);
  return result;
}

void sub_100F6FC98()
{
}

void *sub_100F6FD20(uint64_t a1, int a2)
{
  int v5 = a2;
  int v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A75090;
  v6[1] = &v5;
  double v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100F6FDC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F6FDE0(uint64_t a1, uint64_t a2)
{
  int v2 = *(void ***)(a1 + 8);
  uint64_t v5 = a2;
  v6[0] = off_101A75110;
  v6[1] = &v5;
  double v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100F6FE84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F6FEA0(uint64_t a1, int a2)
{
  int v5 = a2;
  int v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A75190;
  v6[1] = &v5;
  double v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100F6FF44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F6FF60(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_101A75210;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_100F6FFFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F70018(CTXPCCarrierBundleNotificationInterface *this)
{
  *(void *)this = off_101A74FC0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCCarrierBundleNotificationInterface::~CTXPCCarrierBundleNotificationInterface(this);
}

void sub_100F70074(CTXPCCarrierBundleNotificationInterface *this)
{
  *(void *)this = off_101A74FC0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCCarrierBundleNotificationInterface::~CTXPCCarrierBundleNotificationInterface(this);

  operator delete();
}

void sub_100F700E4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F7014C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F70188(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F701C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F701F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100F70238()
{
}

void *sub_100F7024C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A75090;
  result[1] = v3;
  return result;
}

uint64_t sub_100F70294(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A75090;
  a2[1] = v2;
  return result;
}

void sub_100F702C0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 carrierBundleChange:v3];
}

void sub_100F70334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F70354(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F70394()
{
}

void sub_100F703A4()
{
}

void *sub_100F703B8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A75110;
  result[1] = v3;
  return result;
}

uint64_t sub_100F70400(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A75110;
  a2[1] = v2;
  return result;
}

void sub_100F7042C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder cfUuid:**(void **)(a1 + 8)];
  [v4 carrierBundleChange:v3];
}

void sub_100F704A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F704C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F70500()
{
}

void sub_100F70510()
{
}

void *sub_100F70524(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A75190;
  result[1] = v3;
  return result;
}

uint64_t sub_100F7056C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A75190;
  a2[1] = v2;
  return result;
}

void sub_100F70598(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 operatorBundleChange:v3];
}

void sub_100F7060C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F7062C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7066C()
{
}

void sub_100F7067C()
{
}

void *sub_100F70690()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A75210;
  return result;
}

void sub_100F706C8(uint64_t a1, void *a2)
{
  *a2 = off_101A75210;
}

id sub_100F706F0(uint64_t a1, id *a2)
{
  return [*a2 defaultBundleChange];
}

uint64_t sub_100F706F8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F70738()
{
}

void sub_100F70744(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  if (*a3) {
    dispatch_retain(*a3);
  }
  sub_100C6E7F8(&v3);
}

void sub_100F707B4(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void DataiRatController::create()
{
}

void sub_100F708D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
    if (!v9)
    {
LABEL_3:
      if (v10) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v9)
  {
    goto LABEL_3;
  }
  dispatch_release(v9);
  if (v10) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t DataiRatController::DataiRatController(uint64_t a1, void *a2, NSObject **a3, uint64_t *a4)
{
  uint64_t v42 = *a3;
  if (v42) {
    dispatch_retain(v42);
  }
  sub_100DD80E0(a1, a2, &v42, "DATA.iRatController");
  if (v42) {
    dispatch_release(v42);
  }
  *(void *)a1 = off_101A752A0;
  *(void *)(a1 + 8) = off_101A75370;
  *(void *)(a1 + 160) = a1 + 160;
  *(void *)(a1 + 168) = a1 + 160;
  *(void *)(a1 + 176) = 0;
  sub_100058DB0(__p, "");
  *(_DWORD *)(a1 + 184) = 0;
  if ((__p[23] & 0x80000000) != 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 192), *(void **)__p, *(unint64_t *)&__p[8]);
    int v7 = __p[23];
    *(_DWORD *)(a1 + 216) = 0;
    if (v7 < 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    *(_OWORD *)(a1 + 192) = *(_OWORD *)__p;
    *(void *)(a1 + 208) = *(void *)&__p[16];
    *(_DWORD *)(a1 + 216) = 0;
  }
  *(void *)(a1 + 248) = 0;
  sub_100058DB0(__p, "");
  *(_DWORD *)(a1 + 256) = 0;
  uint64_t v8 = (unsigned char *)(a1 + 264);
  if ((__p[23] & 0x80000000) != 0)
  {
    sub_10004FC84(v8, *(void **)__p, *(unint64_t *)&__p[8]);
    int v9 = __p[23];
    *(_DWORD *)(a1 + 288) = 0;
    if (v9 < 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)__p;
    *(void *)(a1 + 280) = *(void *)&__p[16];
    *(_DWORD *)(a1 + 288) = 0;
  }
  int v10 = (rest *)sub_100058DB0(v38, "");
  *(_DWORD *)std::string __p = -1;
  char v11 = HIBYTE(v39);
  if (SHIBYTE(v39) < 0)
  {
    int v10 = (rest *)sub_10004FC84(&__p[8], v38[0], (unint64_t)v38[1]);
    int v12 = *(_DWORD *)__p;
    char v11 = HIBYTE(v39);
  }
  else
  {
    *(_OWORD *)&__p[8] = *(_OWORD *)v38;
    uint64_t v41 = v39;
    int v12 = -1;
  }
  *(void *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 328) = v12;
  *(_OWORD *)(a1 + 336) = *(_OWORD *)&__p[8];
  *(void *)(a1 + 352) = v41;
  *(void *)&__p[8] = 0;
  *(void *)&__p[16] = 0;
  uint64_t v41 = 0;
  if (v11 < 0) {
    operator delete(v38[0]);
  }
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = a1 + 416;
  rest::getDefaultDataConnectionTypeMaskStates((uint64_t *)__p, v10);
  uint64_t v13 = a1 + 440;
  uint64_t v14 = *(void **)&__p[8];
  *(void *)(a1 + 432) = *(void *)__p;
  *(void *)(a1 + 440) = v14;
  uint64_t v15 = *(void *)&__p[16];
  *(void *)(a1 + 448) = *(void *)&__p[16];
  if (v15)
  {
    void v14[2] = v13;
    *(void *)std::string __p = &__p[8];
    *(void *)&__p[8] = 0;
    *(void *)&__p[16] = 0;
    uint64_t v14 = 0;
  }
  else
  {
    *(void *)(a1 + 432) = v13;
  }
  sub_1000346F8((uint64_t)__p, v14);
  *(void *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 456) = a1 + 464;
  *(_WORD *)(a1 + 480) = 0;
  *(unsigned char *)(a1 + 482) = 0;
  char v16 = (uint64_t **)(a1 + 528);
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 528) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 488) = 0;
  *(_WORD *)(a1 + 512) = 0;
  *(void *)(a1 + 520) = a1 + 528;
  sub_100058DB0(__p, *(char **)(a1 + 64));
  PersonalitiesTracker::PersonalitiesTracker();
  int v36 = a4;
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t SimSlotRange = subscriber::makeSimSlotRange();
  uint64_t v19 = *(unsigned int **)__p;
  uint64_t v18 = *(unsigned int **)&__p[8];
  if (*(void *)__p != *(void *)&__p[8])
  {
    uint64_t v20 = *(uint64_t (**)(void))&__p[16];
    while (1)
    {
      uint64_t SimSlotRange = v20(*v19);
      if (SimSlotRange) {
        break;
      }
      if (++v19 == v18)
      {
        uint64_t v19 = v18;
        break;
      }
    }
    uint64_t v21 = *(unsigned int **)&__p[8];
    while (v19 != v21)
    {
      signed int v22 = *v19;
      uint64_t v23 = *v16;
      uint64_t v24 = (uint64_t **)(a1 + 528);
      uint64_t v25 = (uint64_t **)(a1 + 528);
      if (*v16)
      {
        do
        {
          while (1)
          {
            uint64_t v25 = (uint64_t **)v23;
            signed int v26 = *((_DWORD *)v23 + 8);
            if (v26 <= v22) {
              break;
            }
            uint64_t v23 = *v25;
            uint64_t v24 = v25;
            if (!*v25) {
              goto LABEL_37;
            }
          }
          if (v26 >= v22)
          {
            uint64_t v29 = v25;
            goto LABEL_40;
          }
          uint64_t v23 = v25[1];
        }
        while (v23);
        uint64_t v24 = v25 + 1;
      }
LABEL_37:
      uint64_t v29 = operator new(0x50uLL);
      *((_DWORD *)v29 + 8) = v22;
      *((void *)v29 + 5) = 2;
      *((void *)v29 + 6) = 2;
      *((void *)v29 + 7) = 2;
      *((void *)v29 + 8) = 0;
      *((void *)v29 + 9) = 0;
      *(void *)uint64_t v29 = 0;
      *((void *)v29 + 1) = 0;
      *((void *)v29 + 2) = v25;
      *uint64_t v24 = (uint64_t *)v29;
      uint64_t v27 = **(void **)(a1 + 520);
      BOOL v28 = (uint64_t *)v29;
      if (v27)
      {
        *(void *)(a1 + 520) = v27;
        BOOL v28 = *v24;
      }
      sub_100046C90(*(uint64_t **)(a1 + 528), v28);
      ++*(void *)(a1 + 536);
LABEL_40:
      *((void *)v29 + 5) = 2;
      *((void *)v29 + 6) = 2;
      *((void *)v29 + 7) = 2;
      uint64_t SimSlotRange = *((void *)v29 + 8);
      *((void *)v29 + 8) = 0;
      if (SimSlotRange) {
        uint64_t SimSlotRange = (*(uint64_t (**)(uint64_t))(*(void *)SimSlotRange + 8))(SimSlotRange);
      }
      *((void *)v29 + 9) = 0;
      long long v30 = v19 + 1;
      uint64_t v19 = v18;
      if (v30 != v18)
      {
        uint64_t v19 = v30;
        while (1)
        {
          uint64_t SimSlotRange = v20(*v19);
          if (SimSlotRange) {
            break;
          }
          if (++v19 == v18)
          {
            uint64_t v19 = v18;
            break;
          }
        }
      }
    }
  }
  if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)SimSlotRange) == 2)
  {
    uint64_t v31 = *v36;
    if (!*v36) {
      operator new();
    }
    unsigned int v32 = *(NSObject **)(a1 + 32);
    dispatch_object_t object = v32;
    if (v32) {
      dispatch_retain(v32);
    }
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, dispatch_object_t *))(*(void *)v31 + 16))(__p, v31, a1 + 72, &object);
    long long v33 = *(_OWORD *)__p;
    *(void *)std::string __p = 0;
    *(void *)&__p[8] = 0;
    __int16 v34 = *(std::__shared_weak_count **)(a1 + 504);
    *(_OWORD *)(a1 + 496) = v33;
    if (v34)
    {
      sub_10004D2C8(v34);
      if (*(void *)&__p[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
      }
    }
    if (object) {
      dispatch_release(object);
    }
  }
  return a1;
}

void sub_100F70E84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, uint64_t a11, char **a12, atomic_uint **a13, PersonalitiesTracker *a14, char **a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  PersonalitiesTracker::~PersonalitiesTracker(a14);
  long long v33 = (uint64_t *)(v31 + 488);
  sub_100F76FA0(*(void **)(v31 + 528));
  __int16 v34 = *(std::__shared_weak_count **)(v31 + 504);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v35 = *v33;
  uint64_t *v33 = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  sub_10005CD2C(v31 + 456, *a15);
  sub_1000346F8(a11, *a10);
  sub_10005CD2C(v31 + 408, *a12);
  sub_100F76C40((void *)(v31 + 360));
  sub_100F76CC4(v31 + 296);
  sub_100F76D8C(a16);
  if (*(char *)(v31 + 215) < 0) {
    operator delete(*a9);
  }
  sub_100160A84(a13);
  sub_100DD8DB8(v31);
  _Unwind_Resume(a1);
}

void sub_100F71030(uint64_t a1, NSObject **a2)
{
  long long v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  sub_100DD8744(a1);
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  *(void *)&long long v5 = sub_100F71ABC;
  *((void *)&v5 + 1) = 0;
  uint64_t v6 = a1;
  char v7 = 1;
  id v4 = *(std::__shared_weak_count **)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 16);
  if (v4)
  {
    char v11 = std::__shared_weak_count::lock(v4);
    if (v11) {
      sub_100F7701C((int)&__p, (int)&event::enterLowPower, (int)&v10, *(dispatch_object_t *)(a1 + 32), &v5);
    }
  }
  else
  {
    char v11 = 0;
  }
  sub_100088B9C();
}

void sub_100F719D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_group_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F71ABC(uint64_t a1, int a2)
{
  id v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    long long v5 = "Exiting";
    if (a2) {
      long long v5 = "Entering";
    }
    int v11 = 136315138;
    int v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s low power", (uint8_t *)&v11, 0xCu);
  }
  *(unsigned char *)(a1 + 512) = a2;
  if (a2)
  {
    sub_100F72FB8(a1);
  }
  else
  {
    uint64_t v6 = *(void **)(a1 + 520);
    if (v6 != (void *)(a1 + 528))
    {
      do
      {
        char v7 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v11) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I sendCurrentiRatRecommendationEvents because of low power", (uint8_t *)&v11, 2u);
        }
        sub_100F7458C(a1, *((unsigned int *)v6 + 8));
        uint64_t v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            uint64_t v6 = v9;
          }
          while (!v10);
        }
        uint64_t v6 = v9;
      }
      while (v9 != (void *)(a1 + 528));
    }
  }
}

void sub_100F71C34(uint64_t a1, uint64_t a2)
{
  void (***v18)(uint64_t *__return_ptr, void, uint64_t);
  char v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int v23;
  BOOL v24;
  uint64_t *v25;
  int v26;
  NSObject *v27;
  int v28;
  NSObject *v29;
  void **v30;
  void **v31;
  BOOL v32;
  void *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint8_t buf[8];
  __int16 v37;
  int v38;

  uint64_t v2 = *(void ***)(a1 + 408);
  long long v3 = (void **)(a1 + 416);
  if (v2 != (void **)(a1 + 416))
  {
    uint64_t v6 = (void **)(a2 + 8);
    char v7 = (void *)(a1 + 528);
    long long v33 = (void *)(a1 + 528);
    while (1)
    {
      uint64_t v8 = sub_100046F68(a2, v2 + 4);
      if (v6 == v8) {
        break;
      }
      int v9 = (uint64_t *)*((unsigned int *)v8 + 14);
      if (v9 != *((_DWORD *)v2 + 14)) {
        break;
      }
      int v9 = (uint64_t *)*((unsigned int *)v8 + 15);
      if (v9 != *((_DWORD *)v2 + 15)) {
        break;
      }
      int v9 = (uint64_t *)*((unsigned __int8 *)v8 + 64);
      if (v9 != *((unsigned __int8 *)v2 + 64)) {
        break;
      }
LABEL_41:
      long long v30 = (void **)v2[1];
      if (v30)
      {
        do
        {
          uint64_t v31 = v30;
          long long v30 = (void **)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v31 = (void **)v2[2];
          unsigned int v32 = *v31 == v2;
          uint64_t v2 = v31;
        }
        while (!v32);
      }
      uint64_t v2 = v31;
      if (v31 == v3) {
        return;
      }
    }
    __int16 v34 = 0;
    uint64_t v35 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 72));
    int v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v12;
    char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        char v7 = v33;
        sub_10004D2C8(v17);
        uint64_t v19 = 0;
LABEL_15:
        (**v18)(&v34, v18, (uint64_t)(v2 + 4));
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        if (v34)
        {
          uint64_t v20 = *(unsigned char *)(v34 + 49) ? 1 : *(unsigned int *)(v34 + 52);
          uint64_t v21 = *v7;
          if (*v7)
          {
            signed int v22 = v7;
            do
            {
              uint64_t v23 = *(_DWORD *)(v21 + 32);
              uint64_t v24 = v23 < (int)v20;
              if (v23 >= (int)v20) {
                uint64_t v25 = (uint64_t *)v21;
              }
              else {
                uint64_t v25 = (uint64_t *)(v21 + 8);
              }
              if (!v24) {
                signed int v22 = (void *)v21;
              }
              uint64_t v21 = *v25;
            }
            while (*v25);
            if (v22 != v7 && (int)v20 >= *((_DWORD *)v22 + 8))
            {
              signed int v26 = sd::imsServiceMaskToUint();
              if (*((_DWORD *)v22 + 19) != v26)
              {
                uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), v20);
                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  BOOL v28 = *((_DWORD *)v22 + 19);
                  *(_DWORD *)long long buf = 67109376;
                  *(_DWORD *)&uint8_t buf[4] = v28;
                  uint64_t v37 = 1024;
                  __int16 v38 = v26;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I WiFi calling feature mask changed from %d to %d", buf, 0xEu);
                }
                *((_DWORD *)v22 + 19) = v26;
                sub_100F72FB8(a1);
                if (*((_DWORD *)v22 + 19) && sub_100F746B8(a1, v20, 1))
                {
                  uint64_t v29 = *(NSObject **)(a1 + 48);
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of IMS feature state", buf, 2u);
                  }
                  sub_100F75370(a1, v20, 1);
                }
              }
            }
          }
        }
        if (v35) {
          sub_10004D2C8(v35);
        }
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    uint64_t v19 = 1;
    goto LABEL_15;
  }
}

void sub_100F71FC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F72008(uint64_t a1, void *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2[2] == *(void *)(a1 + 448))
  {
    id v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    long long v5 = *(void **)(a1 + 432);
    uint64_t v6 = v5;
    while (1)
    {
      BOOL v7 = *((_DWORD *)v4 + 8) == *((_DWORD *)v6 + 8) && v4[5] == v6[5];
      if (!v7) {
        break;
      }
      uint64_t v8 = (void *)v4[1];
      int v9 = v4;
      if (v8)
      {
        do
        {
          id v4 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          id v4 = (void *)v9[2];
          BOOL v7 = *v4 == (void)v9;
          int v9 = v4;
        }
        while (!v7);
      }
      BOOL v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v6[2];
          BOOL v7 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v7);
      }
      uint64_t v6 = v11;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    long long v5 = *(void **)(a1 + 432);
  }
  uint64_t v12 = (void *)(a1 + 440);
  if (v5 == (void *)(a1 + 440)) {
    return;
  }
  uint64_t v13 = a1 + 120;
  uint64_t v39 = a1 + 440;
  do
  {
    long long v40 = *((_OWORD *)v5 + 2);
    uint64_t v14 = *(uint64_t **)(v2 + 8);
    uint64_t v15 = v40;
    if (!v14)
    {
LABEL_29:
      uint64_t v17 = 0;
      goto LABEL_31;
    }
    while (1)
    {
      int v16 = *((_DWORD *)v14 + 8);
      if ((int)v40 >= v16) {
        break;
      }
LABEL_28:
      uint64_t v14 = (uint64_t *)*v14;
      if (!v14) {
        goto LABEL_29;
      }
    }
    if (v16 < (int)v40)
    {
      ++v14;
      goto LABEL_28;
    }
    uint64_t v17 = *sub_1000FD774(v2, (int *)&v40);
    uint64_t v15 = v40;
LABEL_31:
    uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), v15);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218496;
      uint64_t v42 = v17;
      __int16 v43 = 2048;
      uint64_t v44 = *((void *)&v40 + 1);
      __int16 v45 = 2048;
      uint64_t v46 = *((void *)&v40 + 1);
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Allowed policy typeMask changed 0x%02llx -> 0x%02llx(%lld)", buf, 0x20u);
    }
    for (int i = 0; i != 36; ++i)
    {
      if ((i & 0x7FFFFFF7) != 0x12)
      {
        char v20 = BYTE8(v40);
        int AppType = DataiRatControllerInterface::getAppType();
        if (DataiRatControllerInterface::isCriticalAppType())
        {
          sub_100DDA034(a1, v40, AppType);
          uint64_t v22 = *(void *)(a1 + 120);
          if (v22)
          {
            BOOL v23 = v20 & 1;
            uint64_t v24 = a1 + 120;
            do
            {
              int v25 = *(_DWORD *)(v22 + 32);
              BOOL v26 = v25 < (int)v40;
              if (v25 >= (int)v40) {
                uint64_t v27 = (uint64_t *)v22;
              }
              else {
                uint64_t v27 = (uint64_t *)(v22 + 8);
              }
              if (!v26) {
                uint64_t v24 = v22;
              }
              uint64_t v22 = *v27;
            }
            while (*v27);
            if (v24 != v13)
            {
              int v29 = *(_DWORD *)(v24 + 32);
              uint64_t v28 = v24 + 32;
              if ((int)v40 >= v29)
              {
                uint64_t v30 = *(void *)(v28 + 8 * AppType + 48);
                if (v30)
                {
                  if (*(unsigned char *)(v30 + 36) != v23)
                  {
                    *(unsigned char *)(v30 + 36) = v23;
                    uint64_t v31 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v32 = asString();
                      uint64_t v33 = asString();
                      uint64_t v34 = asStringBool(v23);
                      *(_DWORD *)long long buf = 136315650;
                      uint64_t v42 = v32;
                      uint64_t v2 = (uint64_t)a2;
                      __int16 v43 = 2080;
                      uint64_t v44 = v33;
                      __int16 v45 = 2080;
                      uint64_t v46 = v34;
                      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I iWLanPolicy value for connType %s with critical appType %s changed to %s", buf, 0x20u);
                    }
                    sub_100F72FB8(a1);
                    uint64_t v12 = (void *)v39;
                    if (v23 && sub_100F746B8(a1, v40, AppType))
                    {
                      uint64_t v35 = *(NSObject **)(a1 + 48);
                      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of iWLAN policy change", buf, 2u);
                      }
                      sub_100F75370(a1, v40, AppType);
                    }
                  }
                }
              }
            }
          }
        }
      }
      *((void *)&v40 + 1) >>= 1;
    }
    int v36 = (void *)v5[1];
    if (v36)
    {
      do
      {
        uint64_t v37 = v36;
        int v36 = (void *)*v36;
      }
      while (v36);
    }
    else
    {
      do
      {
        uint64_t v37 = (void *)v5[2];
        BOOL v7 = *v37 == (void)v5;
        long long v5 = v37;
      }
      while (!v7);
    }
    long long v5 = v37;
  }
  while (v37 != v12);
}

void sub_100F7243C(uint64_t a1, unsigned int a2)
{
  if (sub_100F75C1C(*(Registry **)(a1 + 72), __stack_chk_guard))
  {
    int v4 = *(unsigned __int8 *)(a1 + 481);
    long long v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = asStringBool(a2 & 0x100);
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asStringBool(v4 != 0);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I handleInEmergencyModeChanged_sync: In-Emergency changed from %s -> %s", buf, 0x16u);
    }
    if (((a2 >> 8) & 1) != v4)
    {
      uint64_t v6 = *(void *)(a1 + 488);
      *(void *)(a1 + 488) = 0;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      }
      if (v4)
      {
        BOOL v7 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I handleInEmergencyModeChanged_sync: Telephony is forced ON now", buf, 2u);
        }
        uint64_t v18 = 0;
        memset(buf, 0, sizeof(buf));
        sub_100058DB0(__p, "TelephonyEnabledInEmergency");
        *(_DWORD *)long long buf = 2;
        if (SHIBYTE(v16) < 0)
        {
          sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
          LODWORD(v18) = 0;
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
          *(void *)&uint8_t buf[24] = v16;
          LODWORD(v18) = 0;
        }
        if (!sub_1009929A4(a1 + 256, (uint64_t)buf)) {
          sub_100F797D4(a1 + 224, (uint64_t)buf);
        }
        if ((char)buf[31] < 0) {
          operator delete(*(void **)&buf[8]);
        }
      }
      else if (!sub_100F75DC8(a1))
      {
        uint64_t v8 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          if (*(_DWORD *)(a1 + 184) == 2 || *(_DWORD *)(a1 + 216) == 2) {
            int v9 = "ON";
          }
          else {
            int v9 = "OFF";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handleInEmergencyModeChanged_sync: Telephony is %s by iRAT recommendation", buf, 0xCu);
        }
        BOOL v10 = *(void **)(a1 + 520);
        if (v10 != (void *)(a1 + 528))
        {
          do
          {
            int v11 = *(NSObject **)(a1 + 48);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I sendCurrentiRatRecommendationEvents because of emergency mode change", buf, 2u);
            }
            sub_100F7458C(a1, *((unsigned int *)v10 + 8));
            uint64_t v12 = (void *)v10[1];
            if (v12)
            {
              do
              {
                uint64_t v13 = v12;
                uint64_t v12 = (void *)*v12;
              }
              while (v12);
            }
            else
            {
              do
              {
                uint64_t v13 = (void *)v10[2];
                BOOL v14 = *v13 == (void)v10;
                BOOL v10 = v13;
              }
              while (!v14);
            }
            BOOL v10 = v13;
          }
          while (v13 != (void *)(a1 + 528));
        }
        if (!sub_1009929A4(a1 + 256, a1 + 184)) {
          sub_100F797D4(a1 + 224, a1 + 184);
        }
      }
    }
  }
}

void sub_100F72770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F727A8(uint64_t a1, BOOL a2)
{
  if (sub_100F75C1C(*(Registry **)(a1 + 72), __stack_chk_guard))
  {
    int v4 = *(unsigned __int8 *)(a1 + 482);
    long long v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      uint64_t v8 = asStringBool(a2);
      __int16 v9 = 2080;
      uint64_t v10 = asStringBool(v4 != 0);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I handleCallActiveChanged_sync: %s -> %s", (uint8_t *)&v7, 0x16u);
    }
    if (!v4 && a2 && *(void *)(a1 + 488))
    {
      uint64_t v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v7) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I handleCallActiveChanged_sync: Call ends with fIMSInEmergencyTimer. Reschedule fIMSInEmergencyTimer", (uint8_t *)&v7, 2u);
      }
      sub_100F75DC8(a1);
    }
  }
}

void sub_100F728E4(void *a1, uint64_t a2)
{
  uint64_t v2 = (void **)a1[57];
  long long v3 = (void **)(a1 + 58);
  if (v2 != a1 + 58)
  {
    uint64_t v6 = (void **)(a2 + 8);
    while (1)
    {
      int v7 = sub_100046F68(a2, v2 + 4);
      if (v6 != v7) {
        break;
      }
      uint64_t v13 = sub_100F76AE0(a1[87], (unsigned __int8 *)v2 + 32);
      if (v13)
      {
        uint64_t v9 = v13;
        sub_100F72FB8((uint64_t)a1);
        signed int AppType = DataiRatControllerInterface::getAppType();
        sub_100F746B8((uint64_t)a1, v9, AppType);
        int v11 = a1[6];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v17 = 0;
          uint64_t v12 = (uint8_t *)&v17;
LABEL_12:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of transport master override", v12, 2u);
        }
LABEL_13:
        sub_100F75370((uint64_t)a1, v9, AppType);
      }
LABEL_14:
      BOOL v14 = (void **)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          BOOL v14 = (void **)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void **)v2[2];
          BOOL v16 = *v15 == v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    if (*((unsigned __int8 *)v7 + 56) == *((unsigned __int8 *)v2 + 56) && *((_DWORD *)v7 + 15) == *((_DWORD *)v2 + 15)) {
      goto LABEL_14;
    }
    uint64_t v8 = sub_100F76AE0(a1[87], (unsigned __int8 *)v2 + 32);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = v8;
    sub_100F72FB8((uint64_t)a1);
    signed int AppType = DataiRatControllerInterface::getAppType();
    sub_100F746B8((uint64_t)a1, v9, AppType);
    int v11 = a1[6];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v18 = 0;
      uint64_t v12 = (uint8_t *)&v18;
      goto LABEL_12;
    }
    goto LABEL_13;
  }
}

void sub_100F72AA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    int v7 = v22 >= 0 ? &__p : (void **)__p;
    uint64_t v8 = asString();
    uint64_t v9 = subscriber::asString();
    *(_DWORD *)long long buf = 136315650;
    uint64_t v24 = v7;
    __int16 v25 = 2080;
    uint64_t v26 = v8;
    __int16 v27 = 2080;
    uint64_t v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I personalityEvent: %s for %s / %s", buf, 0x20u);
    if (v22 < 0) {
      operator delete(__p);
    }
  }
  if ((*(unsigned char *)(a2 + 24) & 0xFE) == 6 && !*(unsigned char *)(*(void *)a3 + 49))
  {
    uint64_t v10 = sub_100046F68(a1 + 456, (void **)a2);
    BOOL v11 = (void **)(a1 + 464) != v10 && (unint64_t)((_BYTE)v10[7] & 1);
    uint64_t v12 = *(void *)(a1 + 528);
    if (v12)
    {
      uint64_t v13 = *(unsigned int *)(*(void *)a3 + 52);
      uint64_t v14 = a1 + 528;
      do
      {
        int v15 = *(_DWORD *)(v12 + 32);
        BOOL v16 = v15 < (int)v13;
        if (v15 >= (int)v13) {
          __int16 v17 = (uint64_t *)v12;
        }
        else {
          __int16 v17 = (uint64_t *)(v12 + 8);
        }
        if (!v16) {
          uint64_t v14 = v12;
        }
        uint64_t v12 = *v17;
      }
      while (*v17);
      if (v14 != a1 + 528 && (int)v13 >= *(_DWORD *)(v14 + 32))
      {
        uint64_t v18 = *(void *)(v14 + 64);
        *(void *)(v14 + 64) = 0;
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
        }
        *(void *)(v14 + 72) = 0;
        if (v11)
        {
          signed int AppType = DataiRatControllerInterface::getAppType();
          char v20 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of personality event", buf, 2u);
          }
          sub_100F75370(a1, v13, AppType);
        }
      }
    }
  }
}

void sub_100F72CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_100F72CF8(uint64_t a1)
{
  sub_100DD8BE4(a1, 1);
  uint64_t result = *(void *)(a1 + 496);
  if (result)
  {
    long long v3 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v3();
  }
  return result;
}

void sub_100F72D64(uint64_t a1, dispatch_object_t *a2)
{
  int v4 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v4);
  }
  sub_100DD8D3C((void *)a1);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  for (uint64_t i = *(void *)(a1 + 168); i != a1 + 160; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(a1 + 160));
  uint64_t v6 = *(void *)(a1 + 496);
  if (v6)
  {
    int v7 = *a2;
    dispatch_group_t group = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(v7);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 32))(v6, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
}

void sub_100F72E60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F72E9C(uint64_t a1)
{
  *(void *)a1 = off_101A752A0;
  *(void *)(a1 + 8) = off_101A75370;
  sub_100F72FB8(a1);
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 544));
  sub_100F76FA0(*(void **)(a1 + 528));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 504);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 488);
  *(void *)(a1 + 488) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_10005CD2C(a1 + 456, *(char **)(a1 + 464));
  sub_1000346F8(a1 + 432, *(void **)(a1 + 440));
  sub_10005CD2C(a1 + 408, *(char **)(a1 + 416));
  sub_100F76C40((void *)(a1 + 360));
  sub_100F76CC4(a1 + 296);
  sub_100F76D8C(a1 + 224);
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  sub_100160A84((atomic_uint **)(a1 + 160));

  sub_100DD8DB8(a1);
}

uint64_t sub_100F72FB8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I resetting timer", (uint8_t *)&v16, 2u);
  }
  uint64_t result = subscriber::makeSimSlotRange();
  long long v5 = v16;
  int v4 = v17;
  if (v16 != v17)
  {
    uint64_t v6 = v18;
    while (1)
    {
      uint64_t result = v6(*v5);
      if (result) {
        break;
      }
      if (++v5 == v4)
      {
        long long v5 = v4;
        break;
      }
    }
    int v7 = v17;
    if (v5 != v17)
    {
      uint64_t v8 = (void *)(a1 + 528);
      do
      {
        uint64_t v9 = *v8;
        if (*v8)
        {
          signed int v10 = *v5;
          BOOL v11 = v8;
          do
          {
            signed int v12 = *(_DWORD *)(v9 + 32);
            BOOL v13 = v12 < v10;
            if (v12 >= v10) {
              uint64_t v14 = (uint64_t *)v9;
            }
            else {
              uint64_t v14 = (uint64_t *)(v9 + 8);
            }
            if (!v13) {
              BOOL v11 = (void *)v9;
            }
            uint64_t v9 = *v14;
          }
          while (*v14);
          if (v11 != v8 && v10 >= *((_DWORD *)v11 + 8))
          {
            *((_DWORD *)v11 + 18) = 0;
            uint64_t result = v11[8];
            if (result)
            {
              v11[8] = 0;
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
            }
          }
        }
        int v15 = v5 + 1;
        long long v5 = v4;
        if (v15 != v4)
        {
          long long v5 = v15;
          while (1)
          {
            uint64_t result = v6(*v5);
            if (result) {
              break;
            }
            if (++v5 == v4)
            {
              long long v5 = v4;
              break;
            }
          }
        }
      }
      while (v5 != v7);
    }
  }
  return result;
}

void sub_100F73154(uint64_t a1)
{
}

void sub_100F7315C(uint64_t a1)
{
  sub_100F72E9C(a1);

  operator delete();
}

void sub_100F73194(uint64_t a1)
{
  sub_100F72E9C(a1 - 8);

  operator delete();
}

void sub_100F731D0(uint64_t a1, int a2)
{
  sub_100DD8EAC(a1, a2);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100F732E8;
  v5[3] = &unk_101A753A8;
  _OWORD v5[4] = a1;
  int v6 = a2;
  uint64_t v9 = 0;
  signed int v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 16));
  int v4 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100F795F8;
  block[3] = &unk_101A75B68;
  block[5] = v9;
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

uint64_t sub_100F732E8(uint64_t a1)
{
  return sub_100F72FB8(*(void *)(a1 + 32));
}

void sub_100F732F8(uint64_t a1, int a2)
{
}

uint64_t sub_100F73300(Registry **a1, uint64_t a2)
{
  int v4 = (capabilities::ct *)capabilities::ct::supportsVoiceCall((capabilities::ct *)a1);
  if (v4) {
    return 0;
  }
  if (!capabilities::ct::supportsCellRadio(v4)) {
    return 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, a1[9]);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    signed int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v9;
  BOOL v13 = sub_10004D37C(&v8[1].__m_.__sig, &v16);
  if (!v13)
  {
    std::mutex::unlock(v8);
    return 1;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
    std::mutex::unlock(v8);
    if (v15) {
      goto LABEL_13;
    }
    return 1;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  if (!v15)
  {
LABEL_23:
    sub_10004D2C8(v14);
    return 1;
  }
LABEL_13:
  unint64_t v16 = 0;
  __int16 v17 = 0;
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 824))(&v16, v15, a2);
  if (!v16 || ((*(uint64_t (**)(unint64_t))(*(void *)v16 + 56))(v16) & 1) == 0)
  {
    if (v17) {
      sub_10004D2C8(v17);
    }
    if (!v14) {
      return 1;
    }
    goto LABEL_23;
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  return 2;
}

void sub_100F73498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F734C8(uint64_t a1, int a2, uint64_t *a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  v7[2] = sub_100F73600;
  v7[3] = &unk_101A753C8;
  uint64_t v5 = *a3;
  int v4 = (std::__shared_weak_count *)a3[1];
  v7[4] = a1;
  v7[5] = v5;
  uint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = a2;
  uint64_t v12 = 0;
  BOOL v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 16));
  int v6 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100F795F8;
  block[3] = &unk_101A75B68;
  block[5] = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100F73600(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  if (*v1 != v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    do
    {
      int v6 = *(signed int **)v2;
      uint64_t v7 = *(void *)(v2 + 8);
      if (v7)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        uint64_t v8 = *(unsigned int *)(a1 + 56);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v8 = *(unsigned int *)(a1 + 56);
      }
      v9[0] = v6;
      v9[1] = (signed int *)v7;
      sub_100F736C0(v5, v8, v9);
      if (v7)
      {
        sub_10004D2C8((std::__shared_weak_count *)v7);
        sub_10004D2C8((std::__shared_weak_count *)v7);
      }
      v2 += 16;
    }
    while (v2 != v3);
  }
}

void sub_100F736A0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F736C0(uint64_t a1, uint64_t a2, signed int **a3)
{
  int v6 = *a3;
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (!v8) {
      return;
    }
    LOWORD(v29) = 0;
    uint64_t v26 = "#E handleNewiRatMsg: got an empty iRat message, ignore.";
    __int16 v27 = v7;
    goto LABEL_28;
  }
  if (v8)
  {
    uint64_t v9 = asString();
    uint64_t v10 = asString();
    signed int v11 = (*a3)[13];
    int v29 = 136315650;
    uint64_t v30 = v9;
    __int16 v31 = 2080;
    uint64_t v32 = v10;
    __int16 v33 = 1024;
    signed int v34 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I handleNewiRatMsg: appType=%s, linkType=%s, reason=%d", (uint8_t *)&v29, 0x1Cu);
  }
  if (**a3 > 2 || (validContextType() & 1) == 0)
  {
    __int16 v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v29) = 0;
    uint64_t v26 = "#E handleNewiRatMsg: got an invalid iRat message, ignore.";
    __int16 v27 = v25;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, (uint8_t *)&v29, 2u);
    return;
  }
  uint64_t v12 = *(void *)(a1 + 528);
  if (v12)
  {
    uint64_t v13 = a1 + 528;
    do
    {
      int v14 = *(_DWORD *)(v12 + 32);
      BOOL v15 = v14 < (int)a2;
      if (v14 >= (int)a2) {
        unint64_t v16 = (uint64_t *)v12;
      }
      else {
        unint64_t v16 = (uint64_t *)(v12 + 8);
      }
      if (!v15) {
        uint64_t v13 = v12;
      }
      uint64_t v12 = *v16;
    }
    while (*v16);
    if (v13 != a1 + 528 && *(_DWORD *)(v13 + 32) <= (int)a2)
    {
      uint64_t v17 = v13 + 40;
      signed int v18 = (*a3)[1];
      int v19 = *(_DWORD *)(v13 + 40 + 8 * **a3);
      if (v18 != v19)
      {
        char v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v29) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I handleNewiRatMsg: iRatChanged", (uint8_t *)&v29, 2u);
        }
        if (DataiRatControllerInterface::isCriticalAppType()) {
          sub_100F72FB8(a1);
        }
      }
      uint64_t v21 = *a3;
      uint64_t v22 = **a3;
      BOOL v23 = (_DWORD *)(v17 + 8 * v22);
      _DWORD *v23 = (*a3)[1];
      v23[1] = v21[13];
      if (sub_100F746B8(a1, a2, v22))
      {
        uint64_t v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v29) = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I handleNewiRatMsg: timer created: assuming iRatChanged", (uint8_t *)&v29, 2u);
        }
      }
      else if (v18 == v19)
      {
        return;
      }
      uint64_t v28 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v29) = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of new iRat message", (uint8_t *)&v29, 2u);
      }
      sub_100F75370(a1, a2, **a3);
    }
  }
}

void sub_100F73A68(uint64_t a1, int a2, uint64_t *a3)
{
}

void sub_100F73A70(uint64_t a1, uint64_t a2, char a3, char a4, char a5, char a6)
{
  signed int v11 = (void *)(a1 + 16);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  char v14 = a3;
  char v15 = a4;
  char v16 = a5;
  char v17 = a6;
  uint64_t v18 = a1;
  v19[0] = 0;
  v19[1] = 0;
  sub_10003E168(v19, v11);
  operator new();
}

void sub_100F73BDC(uint64_t a1, uint64_t a2, char a3, char a4, char a5, char a6)
{
}

void sub_100F73BE4(uint64_t a1, int a2, uint64_t *a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  v7[2] = sub_100F73D1C;
  v7[3] = &unk_101A753F8;
  uint64_t v5 = *a3;
  int v4 = (std::__shared_weak_count *)a3[1];
  v7[4] = a1;
  v7[5] = v5;
  BOOL v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = a2;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 16));
  int v6 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100F795F8;
  block[3] = &unk_101A75B68;
  block[5] = v12;
  signed int v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100F73D1C(uint64_t a1)
{
  memset(v43, 0, sizeof(v43));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  unsigned int v4 = *(_DWORD *)(v2 + 4);
  if (v4 >= 3) {
    unsigned int v4 = -1;
  }
  LODWORD(v43[0]) = v4;
  if (*(char *)(v2 + 55) < 0)
  {
    sub_10004FC84(&v43[1], *(void **)(v2 + 32), *(void *)(v2 + 40));
    uint64_t v2 = *(void *)(a1 + 40);
  }
  else
  {
    *(_OWORD *)&v43[1] = *(_OWORD *)(v2 + 32);
    v43[3] = *(void **)(v2 + 48);
  }
  uint64_t v42 = 0;
  memset(v41, 0, sizeof(v41));
  if (*(_DWORD *)v2) {
    int v5 = 2 * (*(_DWORD *)v2 == 1);
  }
  else {
    int v5 = 1;
  }
  int v6 = *(_DWORD *)(v2 + 56);
  if (v6) {
    int v7 = 2 * (v6 == 1);
  }
  else {
    int v7 = 1;
  }
  LODWORD(v41[0]) = v5;
  if (*(char *)(v2 + 31) < 0)
  {
    sub_10004FC84(&v41[1], *(void **)(v2 + 8), *(void *)(v2 + 16));
  }
  else
  {
    long long v8 = *(_OWORD *)(v2 + 8);
    v41[3] = *(void **)(v2 + 24);
    *(_OWORD *)&v41[1] = v8;
  }
  LODWORD(v42) = v7;
  int v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), *(unsigned int *)(a1 + 56));
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    unsigned int v11 = *(_DWORD *)(v3 + 328) + 1;
    if (v11 > 3) {
      uint64_t v12 = "???";
    }
    else {
      uint64_t v12 = off_101A75BF8[v11];
    }
    if (*(_DWORD *)(v3 + 256) == 2 || *(_DWORD *)(v3 + 288) != 2) {
      uint64_t v13 = (const char *)asString();
    }
    else {
      uint64_t v13 = "WiFiCalling-only";
    }
    if ((LODWORD(v43[0]) + 1) > 3) {
      char v14 = "???";
    }
    else {
      char v14 = off_101A75BF8[LODWORD(v43[0]) + 1];
    }
    if (SHIBYTE(v43[3]) < 0)
    {
      sub_10004FC84(__dst, v43[1], (unint64_t)v43[2]);
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)&v43[1];
      long long v40 = v43[3];
    }
    if (SHIBYTE(v40) >= 0) {
      char v15 = __dst;
    }
    else {
      char v15 = (void **)__dst[0];
    }
    uint64_t v16 = asString();
    char v17 = v13;
    uint64_t v18 = v12;
    if (SHIBYTE(v41[3]) < 0)
    {
      sub_10004FC84(__p, v41[1], (unint64_t)v41[2]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)&v41[1];
      __int16 v38 = v41[3];
    }
    int v19 = SHIBYTE(v38);
    char v20 = (void **)__p[0];
    uint64_t v21 = asString();
    *(_DWORD *)long long buf = 136316674;
    uint64_t v22 = __p;
    if (v19 < 0) {
      uint64_t v22 = v20;
    }
    __int16 v45 = v18;
    __int16 v46 = 2080;
    uint64_t v47 = v17;
    __int16 v48 = 2080;
    uint64_t v49 = v14;
    __int16 v50 = 2080;
    uint64_t v51 = v15;
    __int16 v52 = 2080;
    uint64_t v53 = v16;
    __int16 v54 = 2080;
    long long v55 = v22;
    __int16 v56 = 2080;
    uint64_t v57 = v21;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Operating mode has changed from {BBState: %s, Telephony: %s}  ->  { %s(%s), %s(%s), %s }", buf, 0x48u);
    if (SHIBYTE(v38) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v40) < 0) {
      operator delete(__dst[0]);
    }
  }
  if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v10) == 2
    && (*(_DWORD *)(v3 + 256) != LODWORD(v41[0]) || *(_DWORD *)(v3 + 288) != v42))
  {
    if ((indeterminate() & 1) != 0 || indeterminate())
    {
      BOOL v23 = *(NSObject **)(v3 + 48);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unexpected Telephony with value kUnknown in check telephony status", buf, 2u);
      }
      goto LABEL_48;
    }
    BOOL v26 = LODWORD(v41[0]) == 1 && v42 == 2;
    int v27 = v26;
    if (*(unsigned __int8 *)(v3 + 513) == v27) {
      goto LABEL_48;
    }
    *(unsigned char *)(v3 + 513) = v27;
    uint64_t v28 = *(NSObject **)(v3 + 48);
    BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
    if (v27)
    {
      if (v29)
      {
        *(_WORD *)long long buf = 0;
        __int16 v31 = "#I Telephony status changed: Entering WiFiCalling-only mode";
LABEL_73:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v31, buf, 2u);
      }
    }
    else if (v29)
    {
      *(_WORD *)long long buf = 0;
      __int16 v31 = "#I Telephony status changed: Exiting WiFiCalling-only mode";
      goto LABEL_73;
    }
    if (sub_100F75C1C(*(Registry **)(v3 + 72), v30) && (*(unsigned char *)(v3 + 481) || *(void *)(v3 + 488)))
    {
      uint64_t v32 = *(NSObject **)(v3 + 48);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Telephony status changed: In Emergency mode, skip sending current iRat recommendations", buf, 2u);
      }
    }
    else
    {
      __int16 v33 = *(void **)(v3 + 520);
      if (v33 != (void *)(v3 + 528))
      {
        do
        {
          signed int v34 = *(NSObject **)(v3 + 48);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I sendCurrentiRatRecommendationEvents because of wifi calling only status", buf, 2u);
          }
          sub_100F7458C(v3, *((unsigned int *)v33 + 8));
          uint64_t v35 = (void *)v33[1];
          if (v35)
          {
            do
            {
              int v36 = v35;
              uint64_t v35 = (void *)*v35;
            }
            while (v35);
          }
          else
          {
            do
            {
              int v36 = (void *)v33[2];
              BOOL v26 = *v36 == (void)v33;
              __int16 v33 = v36;
            }
            while (!v26);
          }
          __int16 v33 = v36;
        }
        while (v36 != (void *)(v3 + 528));
      }
    }
  }
LABEL_48:
  *(_DWORD *)(v3 + 184) = v41[0];
  std::string::operator=((std::string *)(v3 + 192), (const std::string *)&v41[1]);
  uint64_t v24 = (uint64_t *)v42;
  *(_DWORD *)(v3 + 216) = v42;
  if ((!sub_100F75C1C(*(Registry **)(v3 + 72), v24) || !*(unsigned char *)(v3 + 481) && !*(void *)(v3 + 488))
    && !sub_1009929A4(v3 + 256, (uint64_t)v41))
  {
    sub_100F797D4(v3 + 224, (uint64_t)v41);
  }
  if ((sub_100992FD8(v3 + 328, (uint64_t)v43) & 1) == 0)
  {
    *(_DWORD *)(v3 + 328) = v43[0];
    std::string::operator=((std::string *)(v3 + 336), (const std::string *)&v43[1]);
    uint64_t v25 = *(void *)(v3 + 320);
    if (v25) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 48))(v25, v3 + 328);
    }
  }
  if (SHIBYTE(v41[3]) < 0) {
    operator delete(v41[1]);
  }
  if (SHIBYTE(v43[3]) < 0) {
    operator delete(v43[1]);
  }
}

void sub_100F7430C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F7438C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F743A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100F743B8(uint64_t a1, int a2, uint64_t *a3)
{
}

void sub_100F743C0(uint64_t a1, int a2, int a3, int a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100F744D8;
  double v6[3] = &unk_101A75428;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  int v9 = a4;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 16));
  int v5 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100F795F8;
  block[3] = &unk_101A75B68;
  block[5] = v12;
  unsigned int v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

uint64_t sub_100F744D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = capabilities::ct::supportsCerberus((capabilities::ct *)a1);
  if (result)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 40);
    unsigned int v5 = *(_DWORD *)(a1 + 44);
    int v6 = *(_DWORD *)(a1 + 48);
    if (*(void *)(v2 + 392) != __PAIR64__(v5, v4) || *(_DWORD *)(v2 + 400) != v6)
    {
      *(_DWORD *)(v2 + 392) = v4;
      *(_DWORD *)(v2 + 396) = v5;
      *(_DWORD *)(v2 + 400) = v6;
      uint64_t result = *(void *)(v2 + 384);
      if (result)
      {
        int v7 = *(uint64_t (**)(void))(*(void *)result + 48);
        return v7();
      }
    }
  }
  return result;
}

void sub_100F74584(uint64_t a1, int a2, int a3, int a4)
{
}

void sub_100F7458C(uint64_t a1, uint64_t a2)
{
  for (signed int i = 0; i != 3; ++i)
  {
    if ((sub_100F746B8(a1, a2, i) & 1) != 0
      || !DataiRatControllerInterface::isCriticalAppType()
      || sub_100DDAA90(a1, a2, i))
    {
      unsigned int v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of explicit send request", v6, 2u);
      }
      sub_100F75370(a1, a2, i);
    }
  }
}

uint64_t sub_100F74660(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, char *a6)
{
  uint64_t v8 = sub_100DDA3F8(a1, a2, a3, a4, a5, a6);
  if (v8)
  {
    signed int AppType = DataiRatControllerInterface::getAppType();
    sub_100F746B8(a1, a2, AppType);
  }
  return v8;
}

uint64_t sub_100F746B8(uint64_t a1, uint64_t a2, signed int a3)
{
  if ((DataiRatControllerInterface::isCriticalAppType() & 1) == 0)
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 136315138;
      uint64_t v24 = asString();
      char v14 = "#I iRatChangeTimer: %s: not creating for non-critical app";
      goto LABEL_16;
    }
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = a1 + 120;
  do
  {
    int v8 = *(_DWORD *)(v6 + 32);
    BOOL v9 = v8 < (int)a2;
    if (v8 >= (int)a2) {
      BOOL v10 = (uint64_t *)v6;
    }
    else {
      BOOL v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 == a1 + 120 || (v12 = *(_DWORD *)(v7 + 32), uint64_t v11 = v7 + 32, v12 > (int)a2))
  {
LABEL_12:
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 136315138;
      uint64_t v24 = asString();
      char v14 = "#I iRatChangeTimer: %s: no SIM info";
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v23, 0xCu);
      return 0;
    }
    return 0;
  }
  uint64_t v16 = v11 + 8 * a3;
  int v19 = *(uint64_t **)(v16 + 48);
  uint64_t v18 = (void *)(v16 + 48);
  char v17 = v19;
  if (!v19)
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v23 = 136315138;
    uint64_t v24 = asString();
    char v14 = "#I iRatChangeTimer: %s: non critical app status";
    goto LABEL_16;
  }
  int v20 = sub_100F74CF4(a1, a2, a3, v17);
  int v21 = sub_100F74EA8(a1, a2, a3);
  if (!validContextType()
    || !validContextType()
    || !validContextType()
    || (validContextType() & 1) == 0)
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v23 = 136315138;
    uint64_t v24 = asString();
    char v14 = "#I iRatChangeTimer: %s: check 1 failed";
    goto LABEL_16;
  }
  uint64_t v22 = (_DWORD *)*v18;
  if (*(_DWORD *)*v18 == v20 && v22[1] == v21 || v20 == 1 && !*((unsigned char *)v22 + 36))
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v23 = 136315138;
    uint64_t v24 = asString();
    char v14 = "#I iRatChangeTimer: %s: check 2 failed";
    goto LABEL_16;
  }

  return sub_100F75684(a1, a2);
}

uint64_t sub_100F74A80(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 17)
  {
    uint64_t v5 = *(void *)(a1 + 496);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
    }
  }

  return sub_100DDA738(a1, a2);
}

BOOL sub_100F74B08(uint64_t a1, int a2, int a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100F74C80;
  double v6[3] = &unk_101A75448;
  void v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  BOOL v9 = v6;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100F79858;
  double v10[3] = &unk_101A75B98;
  v10[4] = a1 + 16;
  v10[5] = &v9;
  uint64_t v11 = v10;
  uint64_t v4 = a1 + 32;
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (*(void *)(v4 + 8))
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    char v14 = sub_10005B4A0;
    char v15 = &unk_101A75BD8;
    uint64_t v16 = &v18;
    char v17 = &v11;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    char v14 = sub_10005A73C;
    char v15 = &unk_101A75BB8;
    uint64_t v16 = &v18;
    char v17 = &v11;
    dispatch_sync(v3, &block);
  }
  return v18 != 0;
}

BOOL sub_100F74C80(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v1 + 120);
  uint64_t v2 = v1 + 120;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 40);
  uint64_t v6 = v2;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < v5;
    if (v7 >= v5) {
      BOOL v9 = (uint64_t *)v3;
    }
    else {
      BOOL v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 != v2
    && (v11 = *(_DWORD *)(v6 + 32), uint64_t v10 = v6 + 32, v5 >= v11)
    && (uint64_t v12 = *(unsigned int *)(a1 + 44), v12 <= 2)
    && (uint64_t v13 = *(void *)(v10 + 8 * v12 + 48)) != 0)
  {
    return *(unsigned char *)(v13 + 36) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F74CF4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t *a4@<X8>)
{
  if (a3 > 2) {
    return 2;
  }
  if ((!sub_100F75C1C(*(Registry **)(a1 + 72), a4) || !*(unsigned char *)(a1 + 481) && !*(void *)(a1 + 488))
    && *(unsigned char *)(a1 + 513)
    || sub_100F73300((Registry **)a1, a2) && DataiRatControllerInterface::getAppType() == a3
    || (sub_100F74DE4(a1, a2) & 1) != 0)
  {
    return 1;
  }
  uint64_t v7 = *(void *)(a1 + 528);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = a1 + 528;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < (int)a2;
    if (v9 >= (int)a2) {
      int v11 = (uint64_t *)v7;
    }
    else {
      int v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if (v8 != a1 + 528 && *(_DWORD *)(v8 + 32) <= (int)a2) {
    return *(unsigned int *)(v8 + 8 * a3 + 40);
  }
  else {
    return 0;
  }
}

unint64_t sub_100F74DE4(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 696);
  uint64_t v4 = *(void **)v3;
  int v5 = *(void **)(v3 + 8);
  if (v4 != v5)
  {
    while (*(unsigned char *)(*v4 + 49) || *(_DWORD *)(*v4 + 52) != a2)
    {
      v4 += 2;
      if (v4 == v5) {
        return 0xFFFFFFFF00000000;
      }
    }
  }
  if (v4 == v5) {
    return 0xFFFFFFFF00000000;
  }
  uint64_t v6 = *v4;
  uint64_t v7 = (std::__shared_weak_count *)v4[1];
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!v6)
    {
      unint64_t v8 = 0xFFFFFFFF00000000;
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  if (!v6) {
    return 0xFFFFFFFF00000000;
  }
LABEL_11:
  int v9 = sub_100046F68(a1 + 456, (void **)(v6 + 24));
  if ((void **)(a1 + 464) != v9)
  {
    unint64_t v8 = (unint64_t)v9[7];
    if (!v7) {
      return v8;
    }
    goto LABEL_16;
  }
  unint64_t v8 = 0xFFFFFFFF00000000;
  if (v7) {
LABEL_16:
  }
    sub_10004D2C8(v7);
  return v8;
}

uint64_t sub_100F74EA8(uint64_t a1, int a2, unsigned int a3)
{
  if (a3 > 2) {
    return 2;
  }
  if ((!sub_100F75C1C(*(Registry **)(a1 + 72), __stack_chk_guard) || !*(unsigned char *)(a1 + 481) && !*(void *)(a1 + 488))
    && *(unsigned char *)(a1 + 513))
  {
    return 1;
  }
  unint64_t v7 = sub_100F74DE4(a1, a2);
  if (v7)
  {
    unint64_t v6 = HIDWORD(v7);
    uint64_t v13 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 136315138;
      uint64_t v16 = asString();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I TransportMaster override: %s", (uint8_t *)&v15, 0xCu);
    }
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 528);
    if (!v8) {
      return 0;
    }
    uint64_t v9 = a1 + 528;
    do
    {
      int v10 = *(_DWORD *)(v8 + 32);
      BOOL v11 = v10 < a2;
      if (v10 >= a2) {
        uint64_t v12 = (uint64_t *)v8;
      }
      else {
        uint64_t v12 = (uint64_t *)(v8 + 8);
      }
      if (!v11) {
        uint64_t v9 = v8;
      }
      uint64_t v8 = *v12;
    }
    while (*v12);
    if (v9 != a1 + 528 && *(_DWORD *)(v9 + 32) <= a2) {
      return *(unsigned int *)(v9 + 8 * a3 + 40);
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_100F75004(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  int v10 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v20) = a5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I setiRatAppLinkType: appType=%s, linkType=%s, reason=%d", buf, 0x1Cu);
  }
  if (a3 <= 2 && validContextType())
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    int v12[2] = sub_100F75224;
    v12[3] = &unk_101A75468;
    void v12[4] = a1;
    unsigned int v13 = a3;
    int v14 = a4;
    int v15 = a5;
    int v16 = a2;
    uint64_t v17 = 0;
    char v18 = 0;
    sub_10003E168(&v17, (void *)(a1 + 16));
    BOOL v11 = *(NSObject **)(a1 + 32);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 1174405120;
    *(void *)&uint8_t buf[16] = sub_100F795F8;
    int v20 = &unk_101A75B68;
    uint64_t v22 = v17;
    int v23 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v21 = v12;
    dispatch_async(v11, buf);
    if (v23) {
      sub_10004D2C8(v23);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
}

void sub_100F75218(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F75224(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (char *)operator new(0x50uLL);
  *((void *)v3 + 2) = 0;
  *((void *)v3 + 1) = 0;
  *(void *)uint64_t v3 = off_101A09840;
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 5) = 0;
  *((void *)v3 + 6) = 0;
  *((void *)v3 + 7) = -1;
  *((void *)v3 + 8) = -1;
  *((void *)v3 + 9) = -1;
  *((void *)v3 + 3) = *(void *)(a1 + 40);
  uint64_t v4 = *(unsigned int *)(a1 + 52);
  *((_DWORD *)v3 + 19) = *(_DWORD *)(a1 + 48);
  v5[0] = (signed int *)(v3 + 24);
  v5[1] = (signed int *)v3;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
  sub_100F736C0(v2, v4, v5);
  sub_10004D2C8((std::__shared_weak_count *)v3);

  sub_10004D2C8((std::__shared_weak_count *)v3);
}

void sub_100F752E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100F75300(capabilities::ct *a1, uint64_t a2)
{
  BOOL result = 1;
  if (capabilities::ct::getBasebandBootStrategy(a1) == 2)
  {
    unsigned int AppType = DataiRatControllerInterface::getAppType();
    int v6 = sub_100F74CF4((uint64_t)a1, a2, AppType, v5);
    if (!AppType && v6 == 1) {
      return 0;
    }
  }
  return result;
}

void sub_100F75370(uint64_t a1, uint64_t a2, signed int a3)
{
  if (*(unsigned char *)(a1 + 512))
  {
    int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent: %s: lowpower", buf, 0xCu);
    }
  }
  else
  {
    sub_100F74CF4(a1, a2, a3, (uint64_t *)*(unsigned __int8 *)(a1 + 512));
    uint64_t v7 = *(void *)(a1 + 528);
    if (v7)
    {
      uint64_t v8 = a1 + 528;
      do
      {
        int v9 = *(_DWORD *)(v7 + 32);
        BOOL v10 = v9 < (int)a2;
        if (v9 >= (int)a2) {
          BOOL v11 = (uint64_t *)v7;
        }
        else {
          BOOL v11 = (uint64_t *)(v7 + 8);
        }
        if (!v10) {
          uint64_t v8 = v7;
        }
        uint64_t v7 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 528 && *(_DWORD *)(v8 + 32) <= (int)a2)
      {
        uint64_t v12 = v8 + 40;
        sub_100F74EA8(a1, a2, a3);
        unsigned int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asString();
          uint64_t v15 = asString();
          uint64_t v16 = asString();
          int v17 = *(_DWORD *)(v12 + 8 * a3 + 4);
          *(_DWORD *)long long buf = 136315906;
          *(void *)&uint8_t buf[4] = v14;
          __int16 v20 = 2080;
          uint64_t v21 = v15;
          __int16 v22 = 2080;
          uint64_t v23 = v16;
          __int16 v24 = 1024;
          int v25 = v17;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Sending out iRatChange event with appType %s, dataContextType %s, transportType: %s, reasonCode %d", buf, 0x26u);
        }
        write_rest_value();
        sub_100058DB0(buf, "/cc/events/irat_change");
        xpc_object_t v18 = xpc_null_create();
        ctu::RestModule::sendEvent();
        xpc_release(0);
        if (SHIBYTE(v22) < 0) {
          operator delete(*(void **)buf);
        }
        xpc_release(v18);
      }
    }
  }
}

void sub_100F75624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, xpc_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F75684(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 528);
  if (!v2) {
    return 0;
  }
  uint64_t v5 = a1 + 528;
  do
  {
    int v6 = *(_DWORD *)(v2 + 32);
    BOOL v7 = v6 < (int)a2;
    if (v6 >= (int)a2) {
      uint64_t v8 = (uint64_t *)v2;
    }
    else {
      uint64_t v8 = (uint64_t *)(v2 + 8);
    }
    if (!v7) {
      uint64_t v5 = v2;
    }
    uint64_t v2 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 528 || *(_DWORD *)(v5 + 32) > (int)a2 || *(void *)(v5 + 64) || *(unsigned char *)(a1 + 512)) {
    return 0;
  }
  unint64_t v10 = *(int *)(v5 + 72);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12FB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12FB8))
  {
    *(_OWORD *)long long buf = xmmword_10159B640;
    long long v28 = unk_10159B650;
    sub_100F75B58(buf, 8uLL);
    __cxa_atexit((void (*)(void *))sub_100F75BE8, &qword_101B12FC0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B12FB8);
  }
  unint64_t v11 = (qword_101B12FC8 - qword_101B12FC0) >> 2;
  if (v11 <= v10) {
    unint64_t v12 = v11 - 1;
  }
  else {
    unint64_t v12 = v10;
  }
  uint64_t v13 = *(int *)(qword_101B12FC0 + 4 * v12);
  uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Arming iRat Change checking timer for %lld seconds", buf, 0xCu);
  }
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 72));
  uint64_t v15 = *(void *)buf;
  sub_100058DB0(__p, "iRat Change Check Timer");
  uint64_t v16 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100F75A24;
  aBlock[3] = &unk_101A75488;
  aBlock[4] = a1;
  aBlock[5] = v5 + 40;
  int v21 = a2;
  __int16 v22 = _Block_copy(aBlock);
  sub_100118A44(v15, (uint64_t)__p, 1, 1000000 * (int)v13, &object, &v22);
  uint64_t v17 = v26;
  uint64_t v26 = 0;
  uint64_t v18 = *(void *)(v5 + 64);
  *(void *)(v5 + 64) = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    uint64_t v19 = v26;
    uint64_t v26 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  if (v22) {
    _Block_release(v22);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return 1;
}

void sub_100F759A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void sub_100F75A24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fiRatChangeTimer timer fired", buf, 2u);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(v4 + 24);
  *(void *)(v4 + 24) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = 0;
  ++*(_DWORD *)(*(void *)(a1 + 40) + 32);
  do
  {
    if (sub_100F746B8(v2, *(unsigned int *)(a1 + 48), v6))
    {
      BOOL v7 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I triggeriRatChangeEvent because of iRat change timer creation", v8, 2u);
      }
      sub_100F75370(v2, *(unsigned int *)(a1 + 48), v6);
    }
    uint64_t v6 = (v6 + 1);
  }
  while (v6 != 3);
}

void *sub_100F75B58(void *result, unint64_t a2)
{
  qword_101B12FC0 = 0;
  qword_101B12FC8 = 0;
  qword_101B12FD0 = 0;
  if (a2)
  {
    uint64_t v3 = result;
    sub_10005CCE8(&qword_101B12FC0, a2);
    uint64_t v4 = qword_101B12FC8;
    BOOL result = memmove((void *)qword_101B12FC8, v3, 4 * a2);
    qword_101B12FC8 = v4 + 4 * a2;
  }
  return result;
}

void sub_100F75BC4(_Unwind_Exception *exception_object)
{
  if (qword_101B12FC0)
  {
    qword_101B12FC8 = qword_101B12FC0;
    operator delete((void *)qword_101B12FC0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F75BE8(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL sub_100F75C1C@<W0>(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v16 = (BOOL *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v16);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    BOOL v12 = 1;
    if (v11) {
      return v12;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v16 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v10 + 32))(&v15, v10, kCarrier1BundleId, @"SupportsTelephonyInEmergency", 0, 0);
  sub_1000057AC(&v16, &v15);
  sub_1000577C4(&v15);
  LOBYTE(v15) = 1;
  ctu::cf::assign((ctu::cf *)&v15, v16, v13);
  BOOL v12 = (_BYTE)v15 != 0;
  sub_100062778((const void **)&v16);
  if ((v11 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v9);
  return v12;
}

void sub_100F75D8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100F75DC8(uint64_t a1)
{
  BOOL result = sub_100F75C1C(*(Registry **)(a1 + 72), __stack_chk_guard);
  if (!result) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 488);
  *(void *)(a1 + 488) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 72));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    BOOL v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  BOOL v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_10:
    uint64_t v15 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E scheduleIMSInEmergencyTimer_sync: No CarrierSettingsInterface. fIMSInEmergencyTimer was not scheduled", (uint8_t *)&buf, 2u);
    }
    goto LABEL_45;
  }
LABEL_14:
  uint64_t v39 = 0;
  (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v13 + 32))(&buf, v13, kCarrier1BundleId, @"PreventDetachAfterEmergencyCallTimer", 0, 0);
  sub_1000842D0(&v39, (CFTypeRef *)&buf);
  uint64_t v16 = sub_1000577C4((const void **)&buf);
  if (v39) {
    uint64_t v18 = sub_100081E58;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18)
  {
    LODWORD(buf) = 0;
    ctu::cf::assign((ctu::cf *)v16, v39, v17);
    uint64_t v19 = buf;
    if (buf)
    {
      __int16 v20 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v19;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I scheduleIMSInEmergencyTimer_sync: Schedule fIMSInEmergencyTimer for %lld seconds", (uint8_t *)&buf, 0xCu);
      }
      int v21 = *(std::__shared_weak_count **)(a1 + 24);
      if (!v21 || (v22 = *(void *)(a1 + 16), (uint64_t v23 = std::__shared_weak_count::lock(v21)) == 0)) {
        sub_100088B9C();
      }
      __int16 v24 = v23;
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 72));
      uint64_t v25 = buf;
      sub_100058DB0(__p, *(char **)(a1 + 64));
      uint64_t v26 = *(NSObject **)(a1 + 32);
      dispatch_object_t object = v26;
      if (v26) {
        dispatch_retain(v26);
      }
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 1174405120;
      v32[2] = sub_100F76304;
      v32[3] = &unk_101A754A8;
      void v32[4] = a1;
      v32[5] = v22;
      __int16 v33 = v24;
      atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlock = _Block_copy(v32);
      sub_100118A44(v25, (uint64_t)__p, 1, 1000000 * v19, &object, &aBlock);
      uint64_t v27 = v38;
      uint64_t v38 = 0;
      uint64_t v28 = *(void *)(a1 + 488);
      *(void *)(a1 + 488) = v27;
      if (v28)
      {
        (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
        uint64_t v29 = v38;
        uint64_t v38 = 0;
        if (v29) {
          (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v37 < 0) {
        operator delete(__p[0]);
      }
      if (*((void *)&buf + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
      }
      if (v33) {
        std::__shared_weak_count::__release_weak(v33);
      }
      std::__shared_weak_count::__release_weak(v24);
      goto LABEL_44;
    }
    uint64_t v30 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      __int16 v31 = "#I scheduleIMSInEmergencyTimer_sync: PreventDetachAfterEmergencyCallTimer == 0. fIMSInEmergencyTimer was not scheduled";
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v30 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      __int16 v31 = "#I scheduleIMSInEmergencyTimer_sync: No PreventDetachAfterEmergencyCallTimer. fIMSInEmergencyTimer was not scheduled";
LABEL_43:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&buf, 2u);
    }
  }
LABEL_44:
  sub_1000570E8((const void **)&v39);
LABEL_45:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return *(void *)(a1 + 488) != 0;
}

void sub_100F76248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100F76304(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        if (!*(unsigned char *)(v3 + 482)) {
          goto LABEL_8;
        }
        uint64_t v6 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I scheduleIMSInEmergencyTimer_sync: fIMSInEmergencyTimer fired with active call. Reschedule fIMSInEmergencyTimer", buf, 2u);
        }
        if ((sub_100F75DC8(v3) & 1) == 0)
        {
LABEL_8:
          uint64_t v7 = *(NSObject **)(v3 + 48);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v15 = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I scheduleIMSInEmergencyTimer_sync: fIMSInEmergencyTimer fired. Sending current Telephony status", v15, 2u);
          }
          uint64_t v8 = *(void *)(v3 + 488);
          *(void *)(v3 + 488) = 0;
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
          }
          uint64_t v9 = *(void **)(v3 + 520);
          if (v9 != (void *)(v3 + 528))
          {
            do
            {
              unsigned int v10 = *(NSObject **)(v3 + 48);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)char v14 = 0;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I sendCurrentiRatRecommendationEvents because of IMS emergency timer fired", v14, 2u);
              }
              sub_100F7458C(v3, *((unsigned int *)v9 + 8));
              char v11 = (void *)v9[1];
              if (v11)
              {
                do
                {
                  BOOL v12 = v11;
                  char v11 = (void *)*v11;
                }
                while (v11);
              }
              else
              {
                do
                {
                  BOOL v12 = (void *)v9[2];
                  BOOL v13 = *v12 == (void)v9;
                  uint64_t v9 = v12;
                }
                while (!v13);
              }
              uint64_t v9 = v12;
            }
            while (v12 != (void *)(v3 + 528));
          }
          if (!sub_1009929A4(v3 + 256, v3 + 184)) {
            sub_100F797D4(v3 + 224, v3 + 184);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F764E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F764F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F76514(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100F76524(uint64_t a1)
{
  sub_100DDAB20(a1);
  uint64_t v2 = *(void **)(a1 + 520);
  if (v2 != (void *)(a1 + 528))
  {
    do
    {
      uint64_t v3 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v4;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I DATA:: For SIM %s:", buf, 0xCu);
        uint64_t v3 = *(NSObject **)(a1 + 48);
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I DATA:: iRat Recommendations: {", buf, 2u);
      }
      uint64_t v5 = 0;
      uint64_t v6 = (IRatLinkPref *)(v2 + 5);
      do
      {
        uint64_t v7 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = asString();
          IRatLinkPref::asString((uint64_t *)buf, v6);
          uint64_t v9 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
          *(_DWORD *)__int16 v31 = 136315394;
          uint64_t v32 = v8;
          __int16 v33 = 2080;
          signed int v34 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t%s: (%s)", v31, 0x16u);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        ++v5;
        uint64_t v6 = (IRatLinkPref *)((char *)v6 + 8);
      }
      while (v5 != 3);
      unsigned int v10 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: }", buf, 2u);
        unsigned int v10 = *(NSObject **)(a1 + 48);
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *((_DWORD *)v2 + 18);
        BOOL v12 = "on";
        if (!v2[8]) {
          BOOL v12 = "off";
        }
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fiRatChangeAttempted: %d, fiRatChangeTimer: %s", buf, 0x12u);
        unsigned int v10 = *(NSObject **)(a1 + 48);
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *((_DWORD *)v2 + 19);
        uint64_t v14 = asStringBool(*(unsigned char *)(a1 + 512));
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v13;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fWifiCallingServiceMask: %d, fInLowPower: %s", buf, 0x12u);
      }
      uint64_t v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v2[2];
          BOOL v17 = *v16 == (void)v2;
          uint64_t v2 = v16;
        }
        while (!v17);
      }
      uint64_t v2 = v16;
    }
    while (v16 != (void *)(a1 + 528));
  }
  uint64_t v18 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_DWORD *)(a1 + 256) == 2 || *(_DWORD *)(a1 + 288) != 2) {
      uint64_t v19 = (const char *)asString();
    }
    else {
      uint64_t v19 = "WiFiCalling-only";
    }
    if (*(char *)(a1 + 287) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 264), *(void *)(a1 + 272));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(a1 + 264);
      *(void *)&uint8_t buf[16] = *(void *)(a1 + 280);
    }
    __int16 v20 = buf;
    if (buf[23] < 0) {
      __int16 v20 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v31 = 136315394;
    uint64_t v32 = (uint64_t)v19;
    __int16 v33 = 2080;
    signed int v34 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: fWRMEnableTelephonySource: { %s : '%s' }", v31, 0x16u);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v18 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v21 = *(_DWORD *)(a1 + 328) + 1;
    if (v21 > 3) {
      uint64_t v22 = "???";
    }
    else {
      uint64_t v22 = off_101A75BF8[v21];
    }
    if (*(char *)(a1 + 359) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 336), *(void *)(a1 + 344));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(a1 + 336);
      *(void *)&uint8_t buf[16] = *(void *)(a1 + 352);
    }
    uint64_t v23 = buf;
    if (buf[23] < 0) {
      uint64_t v23 = *(unsigned char **)buf;
    }
    *(_DWORD *)__int16 v31 = 136315394;
    uint64_t v32 = (uint64_t)v22;
    __int16 v33 = 2080;
    signed int v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: fWRMEnableBasebandStateSource: { %s : '%s' }", v31, 0x16u);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v18 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v25 = sub_100F75C1C(*(Registry **)(a1 + 72), v24);
    if (v25)
    {
      if (*(unsigned char *)(a1 + 481)) {
        LOBYTE(v25) = 1;
      }
      else {
        LOBYTE(v25) = *(void *)(a1 + 488) != 0;
      }
    }
    uint64_t v26 = asStringBool(v25);
    uint64_t v27 = asStringBool(*(void *)(a1 + 488) != 0);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v26;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v27;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: InEmergencyMode= %s, fIMSInEmergencyTimer= %s", buf, 0x16u);
    uint64_t v18 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = asStringBool(*(unsigned char *)(a1 + 513));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: fInWiFiCallingOnlyMode: %s", buf, 0xCu);
  }
  uint64_t result = *(void *)(a1 + 496);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
  }
  return result;
}

uint64_t sub_100F76AE0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  if (*(void **)a1 == v3) {
    return 0;
  }
  uint64_t v5 = a1;
  while (!sub_10001D294((unsigned __int8 *)(*v2 + 24), a2))
  {
    v2 += 2;
    if (v2 == v3)
    {
      uint64_t v2 = v3;
      break;
    }
  }
  if (v2 == *(void **)(v5 + 8)) {
    return 0;
  }
  uint64_t v7 = *v2;
  uint64_t v6 = (std::__shared_weak_count *)v2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
    uint64_t v5 = *(unsigned int *)(v7 + 52);
    if (!v6) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (v6) {
LABEL_11:
  }
    sub_10004D2C8(v6);
LABEL_12:
  if (!v7) {
    return 0;
  }
  return v5;
}

void sub_100F76B84(TelephonyOndemandFactoryInterface *a1)
{
  TelephonyOndemandFactoryInterface::~TelephonyOndemandFactoryInterface(a1);

  operator delete();
}

void *sub_100F76BBC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F76C40(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F76CC4(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }

  return sub_100F76D08((void *)a1);
}

void *sub_100F76D08(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F76D8C(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }

  return sub_100F76BBC((void *)a1);
}

void sub_100F76DD0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F76E9C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_100F76F74);
  __cxa_rethrow();
}

void sub_100F76EC4(_Unwind_Exception *a1)
{
}

void sub_100F76EDC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F76F14(uint64_t a1)
{
}

uint64_t sub_100F76F30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F76F74(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F76FA0(void *a1)
{
  if (a1)
  {
    sub_100F76FA0(*a1);
    sub_100F76FA0(a1[1]);
    uint64_t v2 = a1[8];
    a1[8] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

void sub_100F7701C(int a1, int a2, int a3, dispatch_object_t object, long long *a5)
{
  long long v6 = a5[1];
  long long v10 = *a5;
  long long v11 = v6;
  dispatch_retain(object);
  long long v7 = 0u;
  long long v8 = 0u;
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  uint64_t v9 = 0;
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  operator new();
}

void sub_100F772B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  sub_100163BC8((uint64_t)&a21);
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 8))(a17);
  }
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  sub_100161C9C((uint64_t)&a9);
  dispatch_release(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100F773A0(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x800000010159B7D1 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x800000010159B7D1 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_100F774E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long block = *(_OWORD *)(*a1 + 8);
  long long v3 = *(_OWORD *)(v1 + 24);
  operator new();
}

void sub_100F77604()
{
}

uint64_t *sub_100F77638(uint64_t a1)
{
  sub_100164B7C(*(void **)(a1 + 32));
  uint64_t result = *(uint64_t **)(a1 + 32);
  if (result)
  {
    sub_100165094(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100F77698(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x800000010159B819 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x800000010159B819 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100F777AC(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *((void *)*a1 + 1);
  long long v3 = *(uint64_t (**)(void *, void))*a1;
  uint64_t v4 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    long long v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, v1[24]);
}

void *sub_100F777FC(void *a1)
{
  *a1 = off_101A75630;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F77848(void *a1)
{
  *a1 = off_101A75630;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100F778B4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100F77964(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F7797C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100F7799C()
{
}

void *sub_100F77A08(void *a1)
{
  *a1 = off_101A75680;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F77A54(void *a1)
{
  *a1 = off_101A75680;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F77AC0()
{
}

void sub_100F77B30()
{
}

__n128 sub_100F77B44(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A756C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F77B98(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A756C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F77BD0(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  long long v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *long long v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100169118((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100F77C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100F77CA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F77CE8()
{
}

void sub_100F77CF8()
{
}

__n128 sub_100F77D0C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A75740;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F77D60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A75740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F77D98(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  long long v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *long long v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100F77EBC((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100F77E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F77E70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F77EB0()
{
}

void sub_100F77EBC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v11, object, 0);
    xpc_release(object[0]);
    xpc_object_t v7 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t v7 = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, &v7, count);
    xpc_release(v7);
    for (signed int i = v12; i != object[1] || v11 != object[0]; signed int i = ++v12)
    {
      long long v8 = i;
      xpc_object_t v9 = 0;
      xpc_object_t v7 = &v11;
      sub_10003FBDC((uint64_t)&v7, &v9);
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v7 = 0;
        long long v8 = 0;
        xpc_object_t v6 = v9;
        if (v9) {
          xpc_retain(v9);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100F7813C((int *)&v7, &v6);
        xpc_release(v6);
        sub_100F782F4((uint64_t **)a1, (int *)&v7, (uint64_t)&v7);
      }
      xpc_release(v9);
    }
    xpc_release(v11);
    xpc_release(v11);
  }
  xpc_release(v3);
}

void sub_100F780AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100F7813C(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v10 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v10 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v7 = &v10;
    long long v8 = "first";
    sub_100048BAC((uint64_t)&v7, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v11 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v11, (int *)&object, v5);
      *a1 = v11;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v7 = &v10;
    long long v8 = "second";
    sub_100048BAC((uint64_t)&v7, &object);
    *((void *)a1 + 1) = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
    xpc_release(object);
    xpc_object_t v3 = v10;
  }
  xpc_release(v3);
}

void sub_100F782A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t **sub_100F782F4(uint64_t **a1, int *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    xpc_object_t v10 = operator new(0x30uLL);
    v10[8] = *(_DWORD *)a3;
    *((void *)v10 + 5) = *(void *)(a3 + 8);
    sub_100046C38(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_100F783BC()
{
}

void *sub_100F783D0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A757C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F78418(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A757C0;
  a2[1] = v2;
  return result;
}

void sub_100F78444(uint64_t a1, int *a2)
{
  xpc_object_t v5 = 0;
  sub_10099308C(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/wrm-enable-baseband-state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100F784E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F7852C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7856C()
{
}

void sub_100F7857C()
{
}

void *sub_100F78590(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A75850;
  result[1] = v3;
  return result;
}

uint64_t sub_100F785D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A75850;
  a2[1] = v2;
  return result;
}

void sub_100F78604(uint64_t a1, int *a2)
{
  xpc_object_t v5 = 0;
  sub_100992A6C(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/wrm-enable-telephony");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100F786A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F786EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7872C()
{
}

void sub_100F7873C()
{
}

void *sub_100F78750(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A758E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F78798(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A758E0;
  a2[1] = v2;
  return result;
}

void sub_100F787C4(uint64_t a1, rest *a2)
{
  xpc_object_t v5 = 0;
  rest::write_rest_value(a2, a2);
  sub_100058DB0(&__p, "/cc/props/wrm_sub_preference");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100F78868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F788AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F788EC()
{
}

void sub_100F788FC()
{
}

__n128 sub_100F78910(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A75970;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F78964(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A75970;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F7899C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (unsigned char *)a1[1];
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_1001F299C((uint64_t *)&v10, a2);
  unsigned __int16 v9 = *(_WORD *)v3;
  long long v7 = v10;
  uint64_t v8 = v11;
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_100F78B08(v3, (void ***)&v7);
  BOOL v12 = (void **)&v7;
  sub_1001F1FAC(&v12);
  if (AnyCallInfo::operator!=())
  {
    char v4 = (void (*)(void *, void))a1[3];
    uint64_t v5 = a1[4];
    unint64_t v6 = (void *)(a1[2] + (v5 >> 1));
    if (v5) {
      char v4 = *(void (**)(void *, void))(*v6 + v4);
    }
    v4(v6, v9);
  }
  BOOL v12 = (void **)&v10;
  sub_1001F1FAC(&v12);
}

void sub_100F78A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 40) = v13;
  sub_1001F1FAC((void ***)(v14 - 40));
  *(void *)(v14 - 40) = &a13;
  sub_1001F1FAC((void ***)(v14 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_100F78ABC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F78AFC()
{
}

void sub_100F78B08(unsigned char *a1, void ***a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3)
  {
    char v5 = 0;
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    char v5 = 0;
    do
    {
      unint64_t v6 = *v2;
      xpc_object_t v17 = v6;
      if (v6) {
        xpc_retain(v6);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      uint64_t v14 = &v17;
      uint64_t v15 = "kCallStatus";
      sub_100048BAC((uint64_t)&v14, &object);
      int v8 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)6, v7);
      xpc_release(object);
      if (!v8)
      {
        uint64_t v14 = &v17;
        uint64_t v15 = "kCallType";
        sub_100048BAC((uint64_t)&v14, &object);
        int v10 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v9);
        xpc_release(object);
        uint64_t v14 = &v17;
        uint64_t v15 = "kCallSubType";
        sub_100048BAC((uint64_t)&v14, &object);
        unsigned __int8 v12 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v11);
        xpc_release(object);
        v5 |= (v10 & 0xFFFFFFFE) == 2;
        if (v12 <= 8u && ((1 << v12) & 0x112) != 0) {
          char v4 = 1;
        }
      }
      xpc_release(v17);
      ++v2;
    }
    while (v2 != v3);
  }
  *a1 = v4 & 1;
  a1[1] = v5 & 1;
}

void sub_100F78C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, xpc_object_t a14)
{
}

void sub_100F78CF4()
{
}

__n128 sub_100F78D08(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A759F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F78D5C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A759F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F78D94(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (unsigned char *)a1[1];
  v9[0] = 0;
  v9[1] = 0;
  int v8 = v9;
  sub_10031571C((uint64_t)&v8, a2);
  int v4 = *v3;
  sub_1003159D4(v3, &v8);
  if (v4 != *v3)
  {
    char v5 = (void (*)(void *, BOOL))a1[3];
    uint64_t v6 = a1[4];
    uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      char v5 = *(void (**)(void *, BOOL))(*v7 + v5);
    }
    v5(v7, v4 != 0);
  }
  sub_10005CD2C((uint64_t)&v8, v9[0]);
}

void sub_100F78E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100F78E74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F78EB4()
{
}

void sub_100F78EC4()
{
}

__n128 sub_100F78ED8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A75A70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F78F2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A75A70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F78F64(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  char v5 = (void *)(v3 + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  xpc_object_t v17 = *(uint64_t **)v3;
  uint64_t v18 = (char *)v4;
  if (*(void *)(v3 + 16))
  {
    *(void *)(v4 + 16) = &v18;
    *(void *)uint64_t v3 = v5;
    *char v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    xpc_object_t v17 = (uint64_t *)&v18;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_10005CD2C(v3, *(char **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v24, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v23, object, count);
    xpc_release(object[0]);
    for (signed int i = v25; ; signed int i = ++v25)
    {
      if (i == v23[1] && v24 == v23[0])
      {
        xpc_release(v24);
        xpc_release(v24);
        goto LABEL_41;
      }
      xpc_object_t v22 = 0;
      object[0] = &v24;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v22);
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_39:
      xpc_release(v22);
    }
    *(_OWORD *)xpc_object_t object = 0u;
    long long v21 = 0u;
    HIDWORD(v21) = -1;
    xpc_object_t v9 = v22;
    if (v22)
    {
      xpc_retain(v22);
      v30[0] = (uint64_t)v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      v30[0] = (uint64_t)v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
LABEL_30:
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v27 = v30;
        uint64_t v28 = "first";
        sub_100048BAC((uint64_t)&v27, &v26);
        read_rest_value();
        xpc_release(v26);
        uint64_t v27 = v30;
        uint64_t v28 = "second";
        sub_100048BAC((uint64_t)&v27, &v26);
        read_rest_value();
        xpc_release(v26);
        xpc_object_t v10 = (xpc_object_t)v30[0];
      }
      xpc_release(v10);
      xpc_release(v9);
      v30[0] = 0;
      uint64_t v11 = (uint64_t **)sub_100046ED4(v3, v30, object);
      if (!*v11)
      {
        uint64_t v29 = 0;
        unsigned __int8 v12 = (uint64_t *)operator new(0x40uLL);
        uint64_t v28 = (const char *)(v3 + 8);
        LOBYTE(v29) = 0;
        uint64_t v13 = v12 + 4;
        if (SBYTE7(v21) < 0)
        {
          sub_10004FC84(v13, object[0], (unint64_t)object[1]);
        }
        else
        {
          *(_OWORD *)uint64_t v13 = *(_OWORD *)object;
          v12[6] = v21;
        }
        v12[7] = *((void *)&v21 + 1);
        sub_100046C38((uint64_t **)v3, v30[0], v11, v12);
      }
      if (SBYTE7(v21) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_39;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    v30[0] = (uint64_t)v10;
    goto LABEL_30;
  }
LABEL_41:
  xpc_release(v6);
  uint64_t v14 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v15 = a1[4];
  uint64_t v16 = (void *)(a1[2] + (v15 >> 1));
  if (v15) {
    uint64_t v14 = *(void (**)(void *, uint64_t **))(*v16 + v14);
  }
  v14(v16, &v17);
  sub_10005CD2C((uint64_t)&v17, v18);
}

void sub_100F79350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, char a12, char *a13, uint64_t a14, xpc_object_t object, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,xpc_object_t a23,xpc_object_t a24,uint64_t a25,xpc_object_t a26,uint64_t a27,xpc_object_t a28)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a26);
  xpc_release(v28);
  sub_10005CD2C((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7946C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F794AC()
{
}

void sub_100F794BC()
{
}

__n128 sub_100F794D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A75AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F79524(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A75AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F7955C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  xpc_object_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100F795AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F795EC()
{
}

uint64_t sub_100F795F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t *sub_100F79608(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v2;
  v1.i32[0] = *(_DWORD *)(v2 + 24);
  if (*(char *)(v2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)v2, *(void *)(v2 + 8));
  }
  else
  {
    long long v3 = *(_OWORD *)v2;
    uint64_t v8 = *(void *)(v2 + 16);
    *(_OWORD *)__dst = v3;
  }
  unsigned __int32 v9 = vmovn_s16((int16x8_t)vmovl_u8(v1)).u32[0];
  xpc_object_t v13 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/callkit_call_change");
  xpc_object_t object = v13;
  xpc_object_t v13 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v12 < 0) {
    operator delete(__p);
  }
  xpc_release(v13);
  if (SHIBYTE(v8) < 0) {
    operator delete(__dst[0]);
  }
  sub_100F7977C(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F79700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

uint64_t *sub_100F7977C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100F797D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a2;
  uint64_t v3 = a1 + 32;
  std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 8));
  *(_DWORD *)(v3 + 32) = *(_DWORD *)(a2 + 32);
  uint64_t result = *(void *)(v3 - 8);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v5();
  }
  return result;
}

void *sub_100F79858(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_100F7986C(uint64_t a1, void *a2, _OWORD *a3)
{
  *(void *)a1 = off_101AB2248;
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v5, v8);
  if (v6) {
    sub_10004D2C8(v6);
  }
  *(void *)a1 = off_101A75C28;
  *(_OWORD *)(a1 + 32) = *a3;
  return a1;
}

void sub_100F79910(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F79928(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == -1)
  {
    uint64_t v4 = *a2;
    BOOL v3 = 0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unsigned __int32 v9 = "Banned.xml";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Infinite validity of %s xml", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    BOOL v3 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
  return v3;
}

void sub_100F79A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F79A2C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F79A5C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void DataMigrationFrameworkInterface::create(DataMigrationFrameworkInterface *this)
{
}

void sub_100F79B04()
{
}

void *sub_100F79B28(void *a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "dmclient.fw");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = off_101A75C88;
  return a1;
}

void sub_100F79BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  DataMigrationFrameworkInterface::~DataMigrationFrameworkInterface(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100F79C08(uint64_t a1)
{
  uint64_t v2 = DMIsMigrationNeeded();
  BOOL v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I DMIsMigrationNeeded returning %d", (uint8_t *)v5, 8u);
  }
  return v2;
}

uint64_t sub_100F79CB0()
{
  return (DMGetUserDataDisposition() >> 2) & 1;
}

void sub_100F79CCC(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  DataMigrationFrameworkInterface::~DataMigrationFrameworkInterface((DataMigrationFrameworkInterface *)a1);
}

void sub_100F79D08(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  DataMigrationFrameworkInterface::~DataMigrationFrameworkInterface((DataMigrationFrameworkInterface *)a1);

  operator delete();
}

void sub_100F79D58(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F79DC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F79DFC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F79E34(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F79E64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void lasd::write_rest_value(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v7 = xpc_null_create();
  if (*((void *)a1 + 1)) {
    uint64_t v8 = sub_100080934;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    uint64_t v9 = _CFXPCCreateXPCObjectFromCFObject();
    if (!v9) {
      uint64_t v9 = (uint64_t)xpc_null_create();
    }
    xpc_release(v7);
    xpc_object_t v7 = (xpc_object_t)v9;
  }
  xpc_object_t v15 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_object_t v13 = &v17;
  uint64_t v14 = "payload";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v11 = xpc_int64_create(*a1);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v13 = &v17;
  uint64_t v14 = "slot";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v7);
  xpc_release(v17);
}

void sub_100F7A074(_Unwind_Exception *a1)
{
  xpc_release(v1);
  xpc_release(*(xpc_object_t *)(v2 - 40));
  _Unwind_Resume(a1);
}

void lasd::read_rest_value(xpc_object_t **a1, void **a2)
{
  BOOL v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v14 = xpc_null_create();
    p_xpc_object_t object = &object;
    xpc_object_t v10 = "payload";
    sub_100048BAC((uint64_t)&p_object, &v11);
    sub_10014F00C(&v14, &v11);
    xpc_release(v11);
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_null)
    {
      xpc_object_t v6 = a1[1];
      a1[1] = 0;
    }
    else
    {
      uint64_t v5 = _CFXPCCreateCFObjectFromXPCObject();
      xpc_object_t v6 = a1[1];
      a1[1] = (xpc_object_t *)v5;
    }
    p_xpc_object_t object = v6;
    sub_1000577C4((const void **)&p_object);
    p_xpc_object_t object = &object;
    xpc_object_t v10 = "slot";
    sub_100048BAC((uint64_t)&p_object, &v11);
    xpc_type_t type = xpc_get_type(v11);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v13 = *(_DWORD *)a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)&v11, v8);
      *(_DWORD *)a1 = v13;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)a1 = xpc::dyn_cast_or_default((xpc *)&v11, 0, (uint64_t)v8);
    }
    xpc_release(v11);
    xpc_release(v14);
  }
  else
  {
    LODWORD(p_object) = 0;
    xpc_object_t v10 = 0;
    *(_DWORD *)a1 = 0;
    if (&p_object != a1)
    {
      xpc_object_t v14 = a1[1];
      a1[1] = 0;
      xpc_object_t v10 = 0;
      sub_1000577C4((const void **)&v14);
    }
    sub_1000577C4((const void **)&v10);
  }
  xpc_release(object);
}

void sub_100F7A2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t object)
{
}

void sub_100F7A32C()
{
}

void sub_100F7A3FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F7A430(uint64_t a1, uint64_t a2, NSObject **a3, long long *a4)
{
  void (***v17)(unint64_t *__return_ptr, void, long long *);
  char v18;
  int v19;
  int v20;
  NSObject *v21;
  long long v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v26;
  void *__p;
  char v28;
  OsLogContext v29;
  unint64_t v30;
  std::__shared_weak_count *v31;

  uint64_t v8 = (void *)(a1 + 8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a2);
  xpc_object_t v10 = (char *)ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    xpc_object_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v30 = v11;
  xpc_object_t v15 = sub_10004D37C((void *)v10 + 8, &v30);
  if (v15)
  {
    xpc_object_t v17 = (void (***)(unint64_t *__return_ptr, void, long long *))v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock((std::mutex *)v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      uint64_t v18 = 0;
      if (!v17) {
        goto LABEL_21;
      }
      goto LABEL_10;
    }
  }
  else
  {
    xpc_object_t v17 = 0;
  }
  std::mutex::unlock((std::mutex *)v10);
  uint64_t v16 = 0;
  uint64_t v18 = 1;
  if (!v17)
  {
LABEL_21:
    xpc_object_t v10 = "5wi.auth";
    goto LABEL_22;
  }
LABEL_10:
  uint64_t v30 = 0;
  __int16 v31 = 0;
  (**v17)(&v30, v17, a4);
  if (!v30)
  {
LABEL_17:
    uint64_t v19 = 1;
    goto LABEL_18;
  }
  if (*(unsigned char *)(v30 + 49))
  {
    if (*(unsigned char *)(v30 + 49) == 1)
    {
      uint64_t v19 = 0;
      xpc_object_t v10 = "5wi.auth.T";
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  __int16 v20 = *(_DWORD *)(v30 + 52);
  if (v20 != 1)
  {
    if (v20 == 2)
    {
      uint64_t v19 = 0;
      xpc_object_t v10 = "5wi.auth.2";
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  uint64_t v19 = 0;
  xpc_object_t v10 = "5wi.auth.1";
LABEL_18:
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (v19) {
    goto LABEL_21;
  }
LABEL_22:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, v10);
  void *v8 = 0;
  v8[1] = 0;
  long long v21 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v21) {
    dispatch_retain(v21);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v30, &v29);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v30);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v30);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
  *(void *)a1 = off_101A75D78;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    xpc_object_t v22 = *a4;
    *(void *)(a1 + 64) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 48) = v22;
  }
  *(void *)(a1 + 72) = *(void *)a2;
  uint64_t v23 = *(void *)(a2 + 8);
  *(void *)(a1 + 80) = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "SDAuthenticationManager");
  xpc_object_t v24 = *(NSObject **)(a1 + 24);
  xpc_object_t v26 = v24;
  if (v24) {
    dispatch_retain(v24);
  }
  ctu::RestModule::RestModule();
  if (v26) {
    dispatch_release(v26);
  }
  if (v28 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_100F7A728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, char a20)
{
  ctu::OsLogLogger::~OsLogLogger(v22);
  sub_100087E88(v21);
  IMSAuthenticationManagerInterface::~IMSAuthenticationManagerInterface(v20);
  _Unwind_Resume(a1);
}

void sub_100F7A7E8(uint64_t a1)
{
  *(void *)a1 = off_101A75D78;
  int v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  IMSAuthenticationManagerInterface::~IMSAuthenticationManagerInterface((IMSAuthenticationManagerInterface *)a1);
}

void sub_100F7A878(uint64_t a1)
{
  sub_100F7A7E8(a1);

  operator delete();
}

void sub_100F7A8B0(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(Registry **)(a1 + 72));
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100F7A8FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F7A914(void *a1)
{
  int v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  BOOL v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  xpc_object_t v4 = (void *)a1[7];
  if (v4)
  {
    a1[8] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[4];
  if (v5)
  {
    a1[5] = v5;
    operator delete(v5);
  }
  xpc_object_t v6 = (void *)a1[1];
  if (v6)
  {
    a1[2] = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_100F7A988(uint64_t a1, uint64_t *a2, char **this, int a4)
{
  if (!*a2)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v14 = "#E Invalid client handle. Ignoring AUTH request";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
    return;
  }
  if ((ims::aka::Request::isValid((ims::aka::Request *)this) & 1) == 0)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v14 = "#E Failed to deserialize Auth challenge. Can't authenticate";
    goto LABEL_20;
  }
  v64[0] = 0;
  v64[1] = 0;
  *(void *)long long buf = v64;
  unsigned int v8 = *((unsigned __int8 *)this + 1);
  if (v8 < 2)
  {
LABEL_6:
    v65[0] = 0;
    uint64_t v47 = v65;
    uint64_t v9 = sub_10008CC40((uint64_t **)buf, v65, (uint64_t)&unk_10144E20E, (_DWORD **)&v47);
    if (v9 + 4 != (uint64_t **)this) {
      sub_10006E4A8(v9 + 5, this[1], this[2], this[2] - this[1]);
    }
    v65[0] = 1;
    uint64_t v47 = v65;
    xpc_object_t v10 = sub_10008CC40((uint64_t **)buf, v65, (uint64_t)&unk_10144E20E, (_DWORD **)&v47) + 5;
    if (v10 != (uint64_t **)(this + 4)) {
      sub_10006E4A8(v10, this[4], this[5], this[5] - this[4]);
    }
    int v11 = *((unsigned __int8 *)this + 1);
    if (v11 == 3)
    {
      int v12 = 2;
    }
    else if (v11 == 2)
    {
      int v12 = 5;
    }
    else if (*((unsigned char *)this + 1))
    {
      int v12 = 4;
    }
    else if (a4)
    {
      int v12 = 3;
    }
    else
    {
      int v12 = 2;
    }
    uint64_t v30 = *a2;
    __int16 v31 = (std::__shared_weak_count *)a2[1];
    v62[0] = v30;
    v62[1] = (uint64_t)v31;
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10026E7F8(v61, (uint64_t)buf);
    sub_100F7BF70((uint64_t)&v50, (__int16 *)this);
    sub_100F7B0DC(a1, v62, v12, (uint64_t)v61, &v50);
    if (__p)
    {
      uint64_t v60 = __p;
      operator delete(__p);
    }
    if (v57)
    {
      uint64_t v58 = v57;
      operator delete(v57);
    }
    if (v55)
    {
      __int16 v56 = v55;
      operator delete(v55);
    }
    if (v53)
    {
      __int16 v54 = v53;
      operator delete(v53);
    }
    if (v51)
    {
      __int16 v52 = v51;
      operator delete(v51);
    }
    sub_10026CF54((uint64_t)v61, (void *)v61[1]);
    if (v31) {
      sub_10004D2C8(v31);
    }
    goto LABEL_66;
  }
  if (v8 == 2)
  {
    uint64_t v47 = 0;
    __src = 0;
    uint64_t v49 = 0;
    LOBYTE(v65[0]) = *((unsigned char *)this + 16) - *((_DWORD *)this + 2);
    sub_100F7B6C0((uint64_t)&v47, 0, (char *)v65);
    sub_10005C748((uint64_t)&v47, (char *)__src, this[1], this[2], this[2] - this[1]);
    LOBYTE(v65[0]) = *((unsigned char *)this + 88) - *((_DWORD *)this + 20);
    sub_100F7B6C0((uint64_t)&v47, (char *)__src, (char *)v65);
    sub_10005C748((uint64_t)&v47, (char *)__src, this[10], this[11], this[11] - this[10]);
    LOBYTE(v65[0]) = *((unsigned char *)this + 112) - *((_DWORD *)this + 26);
    sub_100F7B6C0((uint64_t)&v47, (char *)__src, (char *)v65);
    sub_10005C748((uint64_t)&v47, (char *)__src, this[13], this[14], this[14] - this[13]);
    LODWORD(v45) = 2;
    *(void *)long long v65 = &v45;
    xpc_object_t v15 = sub_10008CC40((uint64_t **)buf, (int *)&v45, (uint64_t)&unk_10144E20E, (_DWORD **)v65) + 5;
    if (v15 != (uint64_t **)(this + 7)) {
      sub_10006E4A8(v15, this[7], this[8], this[8] - this[7]);
    }
    uint64_t v45 = 0;
    __int16 v46 = 0;
    uint64_t v16 = (os_log_t *)(a1 + 40);
    sGetSubscriberSimInterface();
    uint64_t v17 = v45;
    if (v45)
    {
      uint64_t v18 = PersonalityIDToSimSlot();
      uint64_t v42 = 0;
      __int16 v43 = 0;
      uint64_t v44 = 0;
      sub_10005C928(&v42, v47, (uint64_t)__src, (unsigned char *)__src - (unsigned char *)v47);
      uint64_t v20 = *a2;
      uint64_t v19 = a2[1];
      *(void *)&long long v35 = a1;
      *((void *)&v35 + 1) = v20;
      uint64_t v36 = v19;
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
      }
      int v37 = 5;
      sub_10026E7F8((uint64_t *)&v38, (uint64_t)buf);
      sub_100F7BF70((uint64_t)v41, (__int16 *)this);
      char v70 = 0;
      long long v21 = (char *)operator new(0xC8uLL);
      xpc_object_t v22 = v21;
      *(void *)long long v21 = off_101A75EB0;
      *(_OWORD *)(v21 + 8) = v35;
      *((void *)v21 + 3) = v36;
      *((void *)&v35 + 1) = 0;
      uint64_t v36 = 0;
      int v23 = v37;
      uint64_t v24 = v39;
      *((void *)v21 + 5) = v38;
      *((_DWORD *)v21 + 8) = v23;
      *((void *)v21 + 6) = v24;
      BOOL v25 = v21 + 48;
      uint64_t v26 = v40;
      *((void *)v21 + 7) = v40;
      if (v26)
      {
        *(void *)(v24 + 16) = v25;
        uint64_t v38 = &v39;
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      else
      {
        *((void *)v21 + 5) = v25;
      }
      sub_100F7BF70((uint64_t)(v21 + 64), v41);
      char v70 = v22;
      (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void *))(*(void *)v17 + 224))(v17, v18, 33, &v42, v69);
      sub_100060644(v69);
      sub_100F7B8C4((uint64_t)&v35);
      signed int v34 = v42;
      if (!v42) {
        goto LABEL_61;
      }
      __int16 v43 = v42;
    }
    else
    {
      uint64_t v32 = *v16;
      if (!os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_61;
      }
      ims::aka::asString();
      __int16 v33 = v66 >= 0 ? v65 : *(int **)v65;
      *(_DWORD *)long long v67 = 136315138;
      uint64_t v68 = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#E Subscriber interface is not available. Auth Mode [%s] not handled", v67, 0xCu);
      if ((v66 & 0x80000000) == 0) {
        goto LABEL_61;
      }
      signed int v34 = *(void **)v65;
    }
    operator delete(v34);
LABEL_61:
    if (v46) {
      sub_10004D2C8(v46);
    }
    uint64_t v29 = v47;
    if (!v47) {
      goto LABEL_66;
    }
    __src = v47;
    goto LABEL_65;
  }
  if (v8 == 3) {
    goto LABEL_6;
  }
  uint64_t v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    ims::aka::asString();
    uint64_t v28 = v49 >= 0 ? &v47 : (void **)v47;
    v65[0] = 136315138;
    *(void *)&v65[1] = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Can't authenticate. Auth Mode [%s] not handled", (uint8_t *)v65, 0xCu);
    if (SHIBYTE(v49) < 0)
    {
      uint64_t v29 = v47;
LABEL_65:
      operator delete(v29);
    }
  }
LABEL_66:
  sub_10026CF54((uint64_t)buf, v64[0]);
}

void sub_100F7AFB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37,void *__p,uint64_t a39,uint64_t a40,char a41)
{
  if (a37) {
    sub_10004D2C8(a37);
  }
  if (__p) {
    operator delete(__p);
  }
  sub_10026CF54(v41 - 192, *(void **)(v41 - 184));
  _Unwind_Resume(a1);
}

void sub_100F7B0DC(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, __int16 *a5)
{
  xpc_object_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received challenge for context %s", buf, 0xCu);
  }
  long long v64 = 0u;
  long long v63 = 0u;
  long long v62 = 0u;
  long long v61 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  long long v58 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  uint64_t v12 = *a2;
  int v11 = (std::__shared_weak_count *)a2[1];
  *(void *)long long buf = a1;
  *(void *)&uint8_t buf[8] = v12;
  long long v55 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  LODWORD(v56) = a3;
  sub_100F7BF70((uint64_t)&v56 + 8, a5);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 72));
  xpc_object_t v15 = ServiceMap;
  if (v16 < 0)
  {
    uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)__int16 v48 = v16;
  uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)v48);
  if (v20)
  {
    uint64_t v22 = v20[3];
    long long v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      if (!v22) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  long long v21 = 0;
  char v23 = 1;
  if (!v22)
  {
LABEL_11:
    uint64_t v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v48 = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#E Missing subscriber controller", v48, 2u);
    }
    v51[0] = 0;
    v51[1] = 0;
    __int16 v50 = v51;
    sub_100F7B950((uint64_t)buf);
  }
LABEL_16:
  *(void *)__int16 v48 = 0;
  long long v49 = 0u;
  *(void *)&uint8_t v48[8] = &v49;
  *(_DWORD *)__int16 v48 = PersonalityIDToSimSlot();
  *(_DWORD *)&v48[4] = a3;
  if (&v48[8] != (uint8_t *)a4) {
    sub_100C77378((uint64_t **)&v48[8], *(uint64_t **)a4, (uint64_t *)(a4 + 8));
  }
  BOOL v25 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v25 || (uint64_t v26 = *(std::__shared_weak_count **)(a1 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v28 = v27;
  p_shared_weak_owners = &v27->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  uint64_t v46 = *(void *)v48;
  sub_10026E7F8(v47, (uint64_t)&v48[8]);
  v31[0] = v26;
  v31[1] = v28;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  *(void *)uint64_t v32 = a1;
  *(_OWORD *)&v32[8] = *(_OWORD *)buf;
  *(void *)&v32[24] = v55;
  if (v55) {
    atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v33 = v56;
  sub_100F7BF70((uint64_t)&v34, (__int16 *)&v56 + 4);
  uint64_t v53 = 0;
  uint64_t v30 = (char *)operator new(0xC8uLL);
  *(_OWORD *)(v30 + 8) = *(_OWORD *)v31;
  *(void *)uint64_t v30 = off_101A75F30;
  *(_OWORD *)(v30 + 24) = *(_OWORD *)v32;
  *(_OWORD *)(v30 + 40) = *(_OWORD *)&v32[16];
  *((_DWORD *)v30 + 14) = v33;
  *((_WORD *)v30 + 32) = v34;
  *(_OWORD *)(v30 + 72) = *(_OWORD *)v35;
  *((void *)v30 + 11) = v36;
  v35[0] = 0;
  v35[1] = 0;
  *((_OWORD *)v30 + 6) = *(_OWORD *)v37;
  *((void *)v30 + 14) = v38;
  uint64_t v36 = 0;
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v38 = 0;
  *(_OWORD *)(v30 + 120) = *(_OWORD *)v39;
  *((void *)v30 + 17) = v40;
  v39[0] = 0;
  v39[1] = 0;
  *((_OWORD *)v30 + 9) = *(_OWORD *)v41;
  *((void *)v30 + 20) = v42;
  uint64_t v40 = 0;
  v41[0] = 0;
  v41[1] = 0;
  uint64_t v42 = 0;
  *(_OWORD *)(v30 + 168) = *(_OWORD *)__p;
  *((void *)v30 + 23) = v44;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v44 = 0;
  *((_DWORD *)v30 + 48) = v45;
  uint64_t v53 = v30;
  (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v22 + 256))(v22, &v46, v52);
  sub_100273F20(v52);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v41[0])
  {
    v41[1] = v41[0];
    operator delete(v41[0]);
  }
  if (v39[0])
  {
    v39[1] = v39[0];
    operator delete(v39[0]);
  }
  if (v37[0])
  {
    v37[1] = v37[0];
    operator delete(v37[0]);
  }
  if (v35[0])
  {
    v35[1] = v35[0];
    operator delete(v35[0]);
  }
  sub_10026CF54((uint64_t)v47, (void *)v47[1]);
  std::__shared_weak_count::__release_weak(v28);
  sub_10026CF54((uint64_t)&v48[8], (void *)v49);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if ((void)v63)
  {
    *((void *)&v63 + 1) = v63;
    operator delete((void *)v63);
  }
  if (*((void *)&v61 + 1))
  {
    *(void *)&long long v62 = *((void *)&v61 + 1);
    operator delete(*((void **)&v61 + 1));
  }
  if ((void)v60)
  {
    *((void *)&v60 + 1) = v60;
    operator delete((void *)v60);
  }
  if (*((void *)&v58 + 1))
  {
    *(void *)&long long v59 = *((void *)&v58 + 1);
    operator delete(*((void **)&v58 + 1));
  }
  if ((void)v57)
  {
    *((void *)&v57 + 1) = v57;
    operator delete((void *)v57);
  }
  if (v55) {
    sub_10004D2C8(v55);
  }
}

void sub_100F7B5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,void *a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  sub_10026CF54((uint64_t)&a42, a43);
  if ((v52 & 1) == 0) {
    sub_10004D2C8(v51);
  }
  sub_100F7BEF0(&a49);
  _Unwind_Resume(a1);
}

void sub_100F7B6C0(uint64_t a1, char *__src, char *a3)
{
  xpc_object_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    xpc_object_t v10 = *(char **)a1;
    uint64_t v11 = (uint64_t)&v6[-*(void *)a1 + 1];
    if (v11 < 0) {
      sub_10006A748();
    }
    uint64_t v12 = __src - v10;
    unint64_t v13 = v7 - (void)v10;
    if (2 * v13 > v11) {
      uint64_t v11 = 2 * v13;
    }
    if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v14 = v11;
    }
    if (v14) {
      xpc_object_t v15 = (char *)operator new(v14);
    }
    else {
      xpc_object_t v15 = 0;
    }
    uint64_t v16 = &v15[v12];
    uint64_t v17 = &v15[v14];
    if (v12 == v14)
    {
      if (v12 < 1)
      {
        if ((unint64_t)(2 * v12) <= 1) {
          size_t v19 = 1;
        }
        else {
          size_t v19 = 2 * v12;
        }
        uint64_t v20 = (char *)operator new(v19);
        uint64_t v16 = &v20[v19 >> 2];
        uint64_t v17 = &v20[v19];
        if (v15)
        {
          operator delete(v15);
          xpc_object_t v10 = *(char **)a1;
        }
      }
      else
      {
        if (v12 + 1 >= 0) {
          uint64_t v18 = v12 + 1;
        }
        else {
          uint64_t v18 = v12 + 2;
        }
        v16 -= v18 >> 1;
      }
    }
    char *v16 = *a3;
    long long v21 = v16 + 1;
    if (v10 != __src)
    {
      uint64_t v22 = __src;
      do
      {
        char v23 = *--v22;
        *--uint64_t v16 = v23;
      }
      while (v22 != v10);
    }
    uint64_t v24 = *(unsigned char **)(a1 + 8);
    uint64_t v25 = v24 - __src;
    if (v24 != __src) {
      memmove(v21, __src, v24 - __src);
    }
    uint64_t v26 = *(char **)a1;
    *(void *)a1 = v16;
    *(void *)(a1 + 8) = &v21[v25];
    *(void *)(a1 + 16) = v17;
    if (v26)
    {
      operator delete(v26);
    }
  }
  else if (__src == v6)
  {
    void *__src = *a3;
    *(void *)(a1 + 8) = __src + 1;
  }
  else
  {
    unsigned int v8 = __src + 1;
    if (v6)
    {
      *xpc_object_t v6 = *(v6 - 1);
      uint64_t v9 = v6 + 1;
    }
    else
    {
      uint64_t v9 = 0;
    }
    *(void *)(a1 + 8) = v9;
    if (v6 != v8) {
      memmove(__src + 1, __src, v6 - v8);
    }
    void *__src = *a3;
  }
}

void sub_100F7B8AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F7B8C4(uint64_t a1)
{
  int v2 = *(void **)(a1 + 160);
  if (v2)
  {
    *(void *)(a1 + 168) = v2;
    operator delete(v2);
  }
  BOOL v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  xpc_object_t v4 = *(void **)(a1 + 112);
  if (v4)
  {
    *(void *)(a1 + 120) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 88);
  if (v5)
  {
    *(void *)(a1 + 96) = v5;
    operator delete(v5);
  }
  xpc_object_t v6 = *(void **)(a1 + 64);
  if (v6)
  {
    *(void *)(a1 + 72) = v6;
    operator delete(v6);
  }
  sub_10026CF54(a1 + 32, *(void **)(a1 + 40));
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

void sub_100F7B950(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Received callback for AuthChallenge", buf, 2u);
  }
  *(_DWORD *)&uint8_t buf[4] = 0;
  uint64_t v3 = 0;
  *(_DWORD *)long long buf = 1;
  operator new();
}

void sub_100F7BE24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void *sub_100F7BE64(void *a1)
{
  int v2 = (void *)a1[20];
  if (v2)
  {
    a1[21] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[17];
  if (v3)
  {
    a1[18] = v3;
    operator delete(v3);
  }
  xpc_object_t v4 = (void *)a1[14];
  if (v4)
  {
    a1[15] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[11];
  if (v5)
  {
    a1[12] = v5;
    operator delete(v5);
  }
  xpc_object_t v6 = (void *)a1[8];
  if (v6)
  {
    a1[9] = v6;
    operator delete(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)a1[5];
  if (v7) {
    sub_10004D2C8(v7);
  }
  unsigned int v8 = (std::__shared_weak_count *)a1[1];
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

void *sub_100F7BEF0(void *a1)
{
  int v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  xpc_object_t v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  xpc_object_t v6 = (void *)a1[5];
  if (v6)
  {
    a1[6] = v6;
    operator delete(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

uint64_t sub_100F7BF70(uint64_t a1, __int16 *a2)
{
  __int16 v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_10005C928((void *)(a1 + 8), *((const void **)a2 + 1), *((void *)a2 + 2), *((void *)a2 + 2) - *((void *)a2 + 1));
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_10005C928((void *)(a1 + 32), *((const void **)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 5) - *((void *)a2 + 4));
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_10005C928((void *)(a1 + 56), *((const void **)a2 + 7), *((void *)a2 + 8), *((void *)a2 + 8) - *((void *)a2 + 7));
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  sub_10005C928((void *)(a1 + 80), *((const void **)a2 + 10), *((void *)a2 + 11), *((void *)a2 + 11) - *((void *)a2 + 10));
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  sub_10005C928((void *)(a1 + 104), *((const void **)a2 + 13), *((void *)a2 + 14), *((void *)a2 + 14) - *((void *)a2 + 13));
  *(_DWORD *)(a1 + 128) = *((_DWORD *)a2 + 32);
  return a1;
}

void sub_100F7C044(_Unwind_Exception *exception_object)
{
  unint64_t v7 = *v5;
  if (*v5)
  {
    v1[11] = v7;
    operator delete(v7);
  }
  unsigned int v8 = *v4;
  if (*v4)
  {
    v1[8] = v8;
    operator delete(v8);
  }
  uint64_t v9 = *v3;
  if (*v3)
  {
    v1[5] = v9;
    operator delete(v9);
  }
  xpc_object_t v10 = *v2;
  if (*v2)
  {
    v1[2] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7C0A8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F7C174(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100F7C24C);
  __cxa_rethrow();
}

void sub_100F7C19C(_Unwind_Exception *a1)
{
}

void sub_100F7C1B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F7C1EC(uint64_t a1)
{
}

uint64_t sub_100F7C208(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F7C24C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_100F7C278(void *a1)
{
  *a1 = off_101A75EB0;
  sub_100F7B8C4((uint64_t)(a1 + 1));
  return a1;
}

void sub_100F7C2BC(void *a1)
{
  *a1 = off_101A75EB0;
  sub_100F7B8C4((uint64_t)(a1 + 1));

  operator delete();
}

void *sub_100F7C320(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0xC8uLL);
  *int v2 = off_101A75EB0;
  sub_100F7C674((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F7C374(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7C388(uint64_t a1, void *a2)
{
  *a2 = off_101A75EB0;
  return sub_100F7C674((uint64_t)(a2 + 1), a1 + 8);
}

uint64_t sub_100F7C3B4(uint64_t a1)
{
  return sub_100F7B8C4(a1 + 8);
}

void sub_100F7C3BC(void *a1)
{
  sub_100F7B8C4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F7C3F8(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v6) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)xpc_object_t v15 = "SDAuthenticationManager";
    *(_WORD *)&v15[8] = 2080;
    *(void *)&v15[10] = "operator()";
    unint64_t v7 = "#I DATA.%s: %s: Successful write to EF-GBABP (Bootstrapping parameters)";
    unsigned int v8 = v5;
    uint32_t v9 = 22;
  }
  else
  {
    if (!v6) {
      goto LABEL_7;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v7 = "#E Failed to write to EF-GBABP (Bootstrapping parameters)";
    unsigned int v8 = v5;
    uint32_t v9 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
LABEL_7:
  xpc_object_t v10 = *(std::__shared_weak_count **)(a1 + 24);
  v13[0] = *(void *)(a1 + 16);
  v13[1] = (uint64_t)v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *(_DWORD *)(a1 + 32);
  sub_10026E7F8(v12, a1 + 40);
  sub_100F7BF70((uint64_t)buf, (__int16 *)(a1 + 64));
  sub_100F7B0DC(v4, v13, v11, (uint64_t)v12, (__int16 *)buf);
  if (__p)
  {
    char v23 = __p;
    operator delete(__p);
  }
  if (v20)
  {
    long long v21 = v20;
    operator delete(v20);
  }
  if (v18)
  {
    size_t v19 = v18;
    operator delete(v18);
  }
  if (v16)
  {
    uint64_t v17 = v16;
    operator delete(v16);
  }
  if (*(void *)&v15[4])
  {
    *(void *)&v15[12] = *(void *)&v15[4];
    operator delete(*(void **)&v15[4]);
  }
  sub_10026CF54((uint64_t)v12, (void *)v12[1]);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100F7C5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p)
  {
    a29 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a25)
  {
    a26 = (uint64_t)a25;
    operator delete(a25);
  }
  if (a22)
  {
    a23 = (uint64_t)a22;
    operator delete(a22);
  }
  if (a19)
  {
    a20 = (uint64_t)a19;
    operator delete(a19);
  }
  if (a16)
  {
    a17 = (uint64_t)a16;
    operator delete(a16);
  }
  sub_10026CF54((uint64_t)&a10, a11);
  if (v29) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F7C628(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7C668()
{
}

uint64_t sub_100F7C674(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  sub_10026E7F8((uint64_t *)(a1 + 32), a2 + 32);
  sub_100F7BF70(a1 + 56, (__int16 *)(a2 + 56));
  return a1;
}

void sub_100F7C6E8(_Unwind_Exception *a1)
{
  sub_10026CF54(v2, *(void **)(v1 + 40));
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void *sub_100F7C714(void *a1)
{
  *a1 = off_101A75F30;
  sub_100F7BE64(a1 + 1);
  return a1;
}

void sub_100F7C758(void *a1)
{
  *a1 = off_101A75F30;
  sub_100F7BE64(a1 + 1);

  operator delete();
}

void *sub_100F7C7BC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xC8uLL);
  *uint64_t v2 = off_101A75F30;
  sub_100F7CBA4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F7C810(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7C824(uint64_t a1, void *a2)
{
  *a2 = off_101A75F30;
  return sub_100F7CBA4((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100F7C850(uint64_t a1)
{
  return sub_100F7BE64((void *)(a1 + 8));
}

void sub_100F7C858(void *a1)
{
  sub_100F7BE64(a1 + 1);

  operator delete(a1);
}

void sub_100F7C894(uint64_t a1, void *a2)
{
  int v3 = a2 + 1;
  uint64_t v4 = (void *)a2[1];
  xpc_object_t v10 = (void **)*a2;
  int v11 = v4;
  uint64_t v12 = a2[2];
  if (v12)
  {
    void v4[2] = &v11;
    *a2 = v3;
    *int v3 = 0;
    a2[2] = 0;
  }
  else
  {
    xpc_object_t v10 = &v11;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    unint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      if (*(void *)(a1 + 8))
      {
        long long v13 = *(_OWORD *)(a1 + 32);
        uint64_t v8 = *(void *)(a1 + 48);
        uint64_t v14 = v8;
        if (v8) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
        }
        int v15 = *(_DWORD *)(a1 + 56);
        sub_100F7BF70((uint64_t)&v16, (__int16 *)(a1 + 64));
        uint64_t v17 = v10;
        v18[0] = v11;
        v18[1] = v12;
        if (v12)
        {
          v11[2] = v18;
          xpc_object_t v10 = &v11;
          int v11 = 0;
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v17 = v18;
        }
        uint32_t v9 = *(std::__shared_weak_count **)(v6 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10026CF54((uint64_t)&v10, v11);
}

void sub_100F7CB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v15);
  sub_10026CF54((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7CB58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7CB98()
{
}

uint64_t sub_100F7CBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  sub_100F7BF70(a1 + 56, (__int16 *)(a2 + 56));
  return a1;
}

void sub_100F7CC14(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F7CC38(uint64_t a1)
{
  sub_10026CF54(a1 + 168, *(void **)(a1 + 176));
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 112);
  if (v3)
  {
    *(void *)(a1 + 120) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 88);
  if (v4)
  {
    *(void *)(a1 + 96) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 64);
  if (v5)
  {
    *(void *)(a1 + 72) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6)
  {
    *(void *)(a1 + 48) = v6;
    operator delete(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

void sub_100F7CCC4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1;
  uint64_t v3 = v1;
  sub_10026E7F8(&v4, v1 + 168);
  sub_100F7B950(v1);
}

void sub_100F7CD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t *sub_100F7CD54(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_100F7CC38(v2);
    operator delete();
  }
  return a1;
}

uint64_t sub_100F7CD9C(uint64_t a1)
{
  *(void *)a1 = off_101A75FB0;
  *(void *)(a1 + 48) = off_101A76000;
  uint64_t v2 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 224);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 112);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 64);
  if (v8) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100F7CEBC(uint64_t a1)
{
  return sub_100F7CD9C(a1 - 48);
}

void sub_100F7CEC4(uint64_t a1)
{
  sub_100F7CD9C(a1);

  operator delete();
}

void sub_100F7CEFC(uint64_t a1)
{
  sub_100F7CD9C(a1 - 48);

  operator delete();
}

uint64_t sub_100F7CF38(uint64_t a1, void *a2, NSObject **a3, void *a4, long long *a5, long long *a6, long long *a7, int a8)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v29, kCtLoggingSystemName, "tkn.mgr");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  __int16 v16 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v16) {
    dispatch_retain(v16);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v30, &v29);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v30);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v30);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
  *(void *)a1 = off_101A75FB0;
  *(void *)(a1 + 48) = off_101A76000;
  *(void *)(a1 + 56) = *a2;
  uint64_t v17 = a2[1];
  *(void *)(a1 + 64) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v18 = *a4;
  size_t v19 = *a3;
  dispatch_object_t object = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  (*(void (**)(uint64_t, dispatch_object_t *, long long *))(*(void *)v18 + 24))(v18, &object, a5);
  if (object) {
    dispatch_release(object);
  }
  (*(void (**)(void, long long *))(*(void *)*a4 + 16))(*a4, a5);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 136), *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long v20 = *a6;
    *(void *)(a1 + 152) = *((void *)a6 + 2);
    *(_OWORD *)(a1 + 136) = v20;
  }
  if (*((char *)a7 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 160), *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v21 = *a7;
    *(void *)(a1 + 176) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 160) = v21;
  }
  *(_DWORD *)(a1 + 184) = a8;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 192), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v22 = *a5;
    *(void *)(a1 + 208) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 192) = v22;
  }
  sub_100058DB0(&__p, "AnonymizedCarrierTokenManager");
  char v23 = *(NSObject **)(a1 + 24);
  uint64_t v25 = v23;
  if (v23) {
    dispatch_retain(v23);
  }
  ctu::RestModule::RestModule();
  if (v25) {
    dispatch_release(v25);
  }
  if (v27 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 232) = 1;
  *(void *)(a1 + 240) = 0;
  return a1;
}

void sub_100F7D1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t a18, char a19, uint64_t a20,char a21)
{
  if (*(char *)(v21 + 183) < 0) {
    operator delete(*v24);
  }
  if (*(char *)(v21 + 159) < 0) {
    operator delete(*v23);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 128);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  char v27 = *(std::__shared_weak_count **)(v21 + 112);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v21 + 96);
  if (v28) {
    sub_10004D2C8(v28);
  }
  OsLogContext v29 = *(std::__shared_weak_count **)(v21 + 80);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v21 + 64);
  if (v30) {
    sub_10004D2C8(v30);
  }
  ctu::OsLogLogger::~OsLogLogger(a9);
  sub_100087E88(v22);
  _Unwind_Resume(a1);
}

void sub_100F7D2FC(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v12, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100058DB0(&__p, "/cc/props/wifi_status");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A76110;
  v2[1] = a1 + 232;
  v2[2] = a1;
  v2[3] = sub_100F7D54C;
  v2[4] = 0;
  uint64_t v17 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v15 < 0) {
    operator delete(__p);
  }
  (*(void (**)(void))(**(void **)(a1 + 104) + 8))(*(void *)(a1 + 104));
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104));
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I AnonymizedCarrierTokenManager init tokens = (%d)", buf, 8u);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v5 || (uint64_t v6 = *(void *)(a1 + 88), v7 = *(void *)(a1 + 8), (v8 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v7 + 48;
  if (!v7) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v9;
  int v11 = v8;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 16))(v6, &v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100F7D4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7D54C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 232) != 1
    && (*(unsigned int (**)(void))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104)) <= 9)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v2 || (v3 = *(void *)(a1 + 8), (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v5 = v4;
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
    Registry::getTimerService(&v17, *(Registry **)(a1 + 56));
    uint64_t v6 = v17;
    sub_100058DB0(__p, "fetch.tokens.timer");
    uint64_t v7 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v7;
    if (v7) {
      dispatch_retain(v7);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 3321888768;
    aBlock[2] = sub_100F7D9E8;
    aBlock[3] = &unk_101A76018;
    aBlock[4] = a1;
    aBlock[5] = v3;
    uint64_t v12 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    long long v13 = _Block_copy(aBlock);
    sub_100118A44(v6, (uint64_t)__p, 2, 15000000, &object, &v13);
    uint64_t v8 = v19;
    uint64_t v19 = 0;
    uint64_t v9 = *(void *)(a1 + 240);
    *(void *)(a1 + 240) = v8;
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      uint64_t v10 = v19;
      uint64_t v19 = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
    }
    if (v13) {
      _Block_release(v13);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v12) {
      std::__shared_weak_count::__release_weak(v12);
    }
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_100F7D750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  char v27 = *(std::__shared_weak_count **)(v25 - 48);
  if (v27) {
    sub_10004D2C8(v27);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7D7BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 32))();
}

uint64_t sub_100F7D7E4(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 104) + 40);

  return v2();
}

uint64_t sub_100F7D860(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 48))();
}

void sub_100F7D888(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 128);
  *(void *)(a1 + 120) = v3;
  *(void *)(a1 + 128) = v2;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100F7D8B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 32))(*(void *)(a1 + 104));
  (***(void (****)(void, uint64_t))(a1 + 104))(*(void *)(a1 + 104), a3);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 32))(*(void *)(a1 + 104)))
  {
    if ((v5 & 1) == 0)
    {
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 128);
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void (****)(void))(a1 + 120);
          if (v9) {
            (**v9)(v9);
          }
          sub_10004D2C8(v8);
        }
      }
    }
  }
}

void sub_100F7D9CC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100F7D9E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100F7D9E8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (a1[5]
        && !*(unsigned char *)(v3 + 232)
        && (*(unsigned int (**)(void))(**(void **)(v3 + 104) + 16))(*(void *)(v3 + 104)) <= 9)
      {
        int v6 = *(_DWORD *)(v3 + 184);
        int v7 = (*(uint64_t (**)(void))(**(void **)(v3 + 104) + 16))(*(void *)(v3 + 104));
        (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(v3 + 88) + 8))(*(void *)(v3 + 88), v3 + 160, v3 + 136, (v6 - v7 + 10));
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F7DAF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F7DB08(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F7DB24(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F7DB38()
{
}

__n128 sub_100F7DB4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A76110;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F7DBA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76110;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F7DBD8(void *a1, xpc_object_t *a2)
{
  int v4 = (char *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (unsigned __int8 *)a2, v6);
    *int v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *int v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  int v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100F7DCC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F7DD08()
{
}

uint64_t sub_100F7DD14(uint64_t a1, void *a2, NSObject **a3, int a4)
{
  if (a4 == 18) {
    uint64_t v8 = "em.data.9";
  }
  else {
    uint64_t v8 = "em.data.???";
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, v8);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v9 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v9) {
    dispatch_retain(v9);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_101A76190;
  if (a4 == 18) {
    uint64_t v10 = "em.DataActivator.9";
  }
  else {
    uint64_t v10 = "em.DataActivator.???";
  }
  *(void *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 64) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = *(char **)(a1 + 48);
  }
  sub_100058DB0(&__p, v10);
  uint64_t v12 = *(NSObject **)(a1 + 24);
  uint64_t v14 = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  ctu::RestModule::RestModule();
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(_DWORD *)(a1 + 116) = -1;
  *(_DWORD *)(a1 + 120) = a4;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 2;
  *(_DWORD *)(a1 + 152) = 2;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  return a1;
}

void sub_100F7DED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  char v23 = (std::__shared_weak_count *)*((void *)v19 + 8);
  if (v23) {
    sub_10004D2C8(v23);
  }
  DataSessionActivator::~DataSessionActivator(v19);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void sub_100F7DF58(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v6, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100058DB0(__p, "/cc/props/connection_state");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A76310;
  v2[1] = a1 + 88;
  v2[2] = a1;
  v2[3] = sub_100F7E20C;
  v2[4] = 0;
  uint64_t v11 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/connection_activate_error");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_101A76390;
  v3[1] = a1;
  v3[2] = sub_100F7E710;
  v3[3] = 0;
  uint64_t v11 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/proxy_update");
  int v4 = operator new(0x20uLL);
  *int v4 = off_101A76410;
  v4[1] = a1;
  void v4[2] = sub_100F7EAA8;
  v4[3] = 0;
  uint64_t v11 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/application_id");
  char v5 = operator new(0x20uLL);
  *char v5 = off_101A76490;
  v5[1] = a1;
  _DWORD v5[2] = sub_100F7EB40;
  v5[3] = 0;
  uint64_t v11 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F7E1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F7E20C(uint64_t a1)
{
  long long v61 = 0u;
  long long v62 = 0u;
  long long v60 = 0u;
  int v2 = *(_DWORD *)(a1 + 148);
  v59[0] = 0;
  v59[1] = 0;
  long long v58 = v59;
  uint64_t v3 = *(void *)(a1 + 96);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = a1 + 96;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < v2;
    if (v5 >= v2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 96 || *(_DWORD *)(v4 + 32) > v2)
  {
LABEL_11:
    long long v64 = 0;
    uint64_t v65 = 0;
    long long v63 = &v64;
    int v8 = *(_DWORD *)(a1 + 140);
    *(_DWORD *)long long buf = -1;
    *(_DWORD *)&uint8_t buf[4] = v8;
    memset(&buf[8], 0, 32);
    uint64_t v9 = 8;
    do
    {
      uint64_t v10 = &buf[v9];
      *(_DWORD *)uint64_t v10 = 0;
      *((void *)v10 + 1) = 0;
      v9 += 16;
    }
    while (v10 + 16 != &buf[40]);
    uint64_t v11 = 0;
    buf[40] = 0;
    *(_DWORD *)&buf[44] = 2;
    long long v60 = *(_OWORD *)buf;
    long long v61 = *(_OWORD *)&buf[16];
    long long v62 = *(_OWORD *)&buf[32];
    goto LABEL_14;
  }
  long long v64 = 0;
  uint64_t v65 = 0;
  long long v63 = &v64;
  long long v22 = *(void **)(v4 + 40);
  char v23 = (void *)(v4 + 48);
  if (v22 != (void *)(v4 + 48))
  {
    uint64_t v24 = 0;
    uint64_t v25 = &v64;
    while (1)
    {
      int v26 = *((_DWORD *)v22 + 8);
      char v27 = &v64;
      if (v25 == &v64) {
        break;
      }
      uint64_t v28 = v24;
      OsLogContext v29 = &v64;
      if (v24)
      {
        do
        {
          char v27 = (uint64_t **)v28;
          uint64_t v28 = (uint64_t *)v28[1];
        }
        while (v28);
      }
      else
      {
        do
        {
          char v27 = (uint64_t **)v29[2];
          BOOL v30 = *v27 == (uint64_t *)v29;
          OsLogContext v29 = v27;
        }
        while (v30);
      }
      if (*((_DWORD *)v27 + 8) < v26) {
        break;
      }
      uint64_t v32 = &v64;
      __int16 v31 = &v64;
      if (!v24) {
        goto LABEL_53;
      }
      int v33 = v24;
      while (1)
      {
        while (1)
        {
          __int16 v31 = (uint64_t **)v33;
          int v34 = *((_DWORD *)v33 + 8);
          if (v34 <= v26) {
            break;
          }
          int v33 = *v31;
          uint64_t v32 = v31;
          if (!*v31) {
            goto LABEL_53;
          }
        }
        if (v34 >= v26) {
          break;
        }
        int v33 = v31[1];
        if (!v33)
        {
          uint64_t v32 = v31 + 1;
          goto LABEL_53;
        }
      }
LABEL_56:
      uint64_t v39 = (void *)v22[1];
      if (v39)
      {
        do
        {
          uint64_t v40 = v39;
          uint64_t v39 = (void *)*v39;
        }
        while (v39);
      }
      else
      {
        do
        {
          uint64_t v40 = (void *)v22[2];
          BOOL v30 = *v40 == (void)v22;
          long long v22 = v40;
        }
        while (!v30);
      }
      if (v40 == v23) {
        goto LABEL_63;
      }
      uint64_t v25 = v63;
      uint64_t v24 = v64;
      long long v22 = v40;
    }
    if (v24) {
      __int16 v31 = v27;
    }
    else {
      __int16 v31 = &v64;
    }
    if (v24)
    {
      uint64_t v32 = v27 + 1;
    }
    else
    {
      char v27 = (uint64_t **)&v63;
      uint64_t v32 = &v64;
    }
    if (v27[1]) {
      goto LABEL_56;
    }
LABEL_53:
    long long v35 = operator new(0x58uLL);
    long long v36 = *((_OWORD *)v22 + 2);
    long long v37 = *((_OWORD *)v22 + 3);
    long long v38 = *((_OWORD *)v22 + 4);
    v35[10] = v22[10];
    *((_OWORD *)v35 + 3) = v37;
    *((_OWORD *)v35 + 4) = v38;
    *((_OWORD *)v35 + 2) = v36;
    void *v35 = 0;
    v35[1] = 0;
    v35[2] = v31;
    NSObject *v32 = v35;
    if (*v63)
    {
      long long v63 = (uint64_t **)*v63;
      long long v35 = *v32;
    }
    sub_100046C90(v64, v35);
    ++v65;
    goto LABEL_56;
  }
LABEL_63:
  int v41 = *(_DWORD *)(a1 + 120);
  int v42 = *(_DWORD *)(a1 + 140);
  *(_DWORD *)long long buf = -1;
  *(_DWORD *)&uint8_t buf[4] = v42;
  memset(&buf[8], 0, 32);
  uint64_t v43 = 8;
  do
  {
    uint64_t v44 = &buf[v43];
    *(_DWORD *)uint64_t v44 = 0;
    *((void *)v44 + 1) = 0;
    v43 += 16;
  }
  while (v44 + 16 != &buf[40]);
  buf[40] = 0;
  *(_DWORD *)&buf[44] = 2;
  if (v64)
  {
    int v45 = &v64;
    uint64_t v46 = v64;
    do
    {
      uint64_t v47 = v46;
      __int16 v48 = v45;
      int v49 = *((_DWORD *)v46 + 8);
      __int16 v50 = (uint64_t **)(v46 + 1);
      if (v49 >= v41)
      {
        __int16 v50 = (uint64_t **)v47;
        int v45 = (uint64_t **)v47;
      }
      uint64_t v46 = *v50;
    }
    while (v46);
    uint64_t v51 = buf;
    if (v45 != &v64)
    {
      BOOL v52 = v49 < v41;
      if (v49 >= v41) {
        uint64_t v53 = v47;
      }
      else {
        uint64_t v53 = v48;
      }
      int v54 = v53[8];
      long long v55 = (uint8_t *)(v48 + 5);
      long long v56 = (uint8_t *)(v47 + 5);
      if (v52) {
        long long v56 = v55;
      }
      if (v54 <= v41) {
        uint64_t v51 = v56;
      }
    }
  }
  else
  {
    uint64_t v51 = buf;
  }
  long long v57 = *((_OWORD *)v51 + 1);
  long long v60 = *(_OWORD *)v51;
  long long v61 = v57;
  long long v62 = *((_OWORD *)v51 + 2);
  sub_1000346F8((uint64_t)&v63, v64);
  uint64_t v11 = (void *)v59[0];
LABEL_14:
  sub_1000346F8((uint64_t)&v58, v11);
  int v12 = *(_DWORD *)(a1 + 140);
  if (DWORD1(v60) != v12)
  {
    char v13 = 0;
    uint64_t v14 = 0;
    *(_DWORD *)(a1 + 140) = DWORD1(v60);
    while (1)
    {
      char v15 = v13;
      char v16 = (char *)&v60 + 16 * v14 + 8;
      int v17 = *(_DWORD *)v16;
      uint64_t v18 = *((void *)v16 + 1);
      if ((ConnectionTypeToMask() & v18) != 0) {
        break;
      }
      char v13 = 1;
      uint64_t v14 = 1;
      if (v15)
      {
        int v19 = 2;
        goto LABEL_20;
      }
    }
    int v19 = v17 == 18;
LABEL_20:
    *(_DWORD *)(a1 + 144) = v19;
    if (*(_DWORD *)(a1 + 140) == 2)
    {
      sub_100F80054(a1);
    }
    else if (v12 == 2)
    {
      long long v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s disconnected.", buf, 0xCu);
      }
      if (*(void *)(a1 + 248))
      {
        memset(buf, 0, 32);
        sub_1000F0058((uint64_t)buf, a1 + 224);
        sub_100F7EC74(a1);
        if (!*(void *)&buf[24]) {
          sub_10007B600();
        }
        (*(void (**)(void))(**(void **)&buf[24] + 48))(*(void *)&buf[24]);
        sub_10003B34C(buf);
      }
    }
  }
}

void sub_100F7E6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F7E710(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 148)) {
    return;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if ((ConnectionTypeToMask() & v4) == 0) {
    return;
  }
  int v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = CSIErrorString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Activate error (%s)", (uint8_t *)&buf, 0xCu);
  }
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 == 102)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Got UAC check error, downgrade RAT and retry", (uint8_t *)&buf, 2u);
    }
    char v17 = 1;
    goto LABEL_32;
  }
  if (v6 != -9 || *(int *)(a1 + 136) > 4)
  {
    char v17 = 0;
LABEL_32:
    sub_100F80130(a1, v17);
    return;
  }
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Got temporary error, schedule retry", (uint8_t *)&buf, 2u);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v8 || (uint64_t v9 = *(void *)(a1 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v11 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  Registry::getTimerService(&v23, *(Registry **)(a1 + 56));
  uint64_t v12 = v23;
  sub_100058DB0(__p, *(char **)(a1 + 48));
  char v13 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 1174405120;
  char v27 = sub_100F80234;
  uint64_t v28 = &unk_101A761D8;
  uint64_t v29 = v9;
  BOOL v30 = v11;
  atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  aBlock = _Block_copy(&buf);
  sub_100118A44(v12, (uint64_t)__p, 1, 300000, &object, &aBlock);
  uint64_t v14 = v25;
  uint64_t v25 = 0;
  uint64_t v15 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v14;
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    uint64_t v16 = v25;
    uint64_t v25 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  std::__shared_weak_count::__release_weak(v11);
}

void sub_100F7EA24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7EAA8(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == *(_DWORD *)(a1 + 148))
  {
    uint64_t v4 = *(void *)(a2 + 32);
    BOOL v6 = (ConnectionTypeToMask() & v4) == 0;
    uint64_t v5 = a1 + 256;
    BOOL v6 = v6 || v5 == a2 + 8;
    if (!v6)
    {
      int v7 = *(std::string **)(a2 + 8);
      int v8 = *(long long **)(a2 + 16);
      sub_10005CA3C(v5, v7, v8, 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v7) >> 3));
    }
  }
}

void sub_100F7EB40(uint64_t a1, int *a2)
{
  if (a2[4] == *(_DWORD *)(a1 + 148))
  {
    uint64_t v4 = *((void *)a2 + 1);
    if ((ConnectionTypeToMask() & v4) != 0)
    {
      int v5 = *(_DWORD *)(a1 + 116);
      int v6 = *a2;
      if (v5 != *a2)
      {
        int v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8[0] = 67109376;
          v8[1] = v5;
          __int16 v9 = 1024;
          int v10 = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I appID is changing from %d to %d", (uint8_t *)v8, 0xEu);
          int v6 = *a2;
        }
        *(_DWORD *)(a1 + 116) = v6;
      }
    }
  }
}

void sub_100F7EC38(uint64_t a1)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 72));

  sub_100F7EC74(a1);
}

void sub_100F7EC74(uint64_t a1)
{
  uint64_t v2 = a1 + 160;
  uint64_t v3 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0;
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  sub_100555F38((void *)(a1 + 192));
  sub_1003355AC((void *)(a1 + 224));
  *(_DWORD *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0x200000000;
  sub_100047FB8((uint64_t *)(a1 + 256));
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4)
  {
    *(void *)(a1 + 128) = 0;
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  *(_DWORD *)(a1 + 136) = 0;
  if ((anyContextType() & 1) == 0)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315138;
      uint64_t v7 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I clear forced context type %s", (uint8_t *)&v6, 0xCu);
    }
    sub_100F7F824(a1, 2);
  }
}

uint64_t sub_100F7EE00(uint64_t a1)
{
  *(void *)a1 = off_101A76190;
  int v6 = (void **)(a1 + 256);
  sub_100047F64(&v6);
  sub_10003B34C((void *)(a1 + 224));
  sub_100060644((void *)(a1 + 192));
  sub_100EB975C((void *)(a1 + 160));
  uint64_t v2 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_10024D10C(a1 + 88, *(void **)(a1 + 96));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  DataSessionActivator::~DataSessionActivator((DataSessionActivator *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F7EEE4(uint64_t a1)
{
  sub_100F7EE00(a1);

  operator delete();
}

void sub_100F7EF1C(uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = asString();
    __int16 v35 = 2080;
    uint64_t v36 = subscriber::asString();
    __int16 v37 = 2080;
    long long v38 = (unsigned char *)asString();
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Activating %s on SIM slot %s with type %s", buf, 0x20u);
  }
  if (*(void *)(a1 + 184))
  {
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Other Client is in using, fail the activation", buf, 2u);
    }
    if (*(void *)(a4 + 24))
    {
      sub_1000DFC90((uint64_t)buf, a4);
      uint64_t v14 = *(std::__shared_weak_count **)(a1 + 16);
      if (v14)
      {
        if (std::__shared_weak_count::lock(v14)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    uint64_t v15 = (void *)a3[3];
    if (v15)
    {
      if (v15 == a3)
      {
        long long v38 = buf;
        (*(void (**)(void *, unsigned char *))(*a3 + 24))(a3, buf);
      }
      else
      {
        long long v38 = (unsigned char *)(*(uint64_t (**)(void *))(*v15 + 16))(v15);
      }
    }
    else
    {
      long long v38 = 0;
    }
    uint64_t v16 = a1 + 160;
    if (buf != (unsigned char *)(a1 + 160))
    {
      char v17 = v38;
      uint64_t v18 = *(void *)(a1 + 184);
      if (v38 == buf)
      {
        if (v18 == v16)
        {
          memset(v39, 0, sizeof(v39));
          (*(void (**)(unsigned char *, void *))(*(void *)buf + 24))(buf, v39);
          (*(void (**)(unsigned char *))(*(void *)v38 + 32))(v38);
          long long v38 = 0;
          (*(void (**)(void, unsigned char *))(**(void **)(a1 + 184) + 24))(*(void *)(a1 + 184), buf);
          (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
          *(void *)(a1 + 184) = 0;
          long long v38 = buf;
          (*(void (**)(void *, uint64_t))(v39[0] + 24))(v39, a1 + 160);
          (*(void (**)(void *))(v39[0] + 32))(v39);
        }
        else
        {
          (*(void (**)(unsigned char *, uint64_t))(*(void *)buf + 24))(buf, a1 + 160);
          (*(void (**)(unsigned char *))(*(void *)v38 + 32))(v38);
          long long v38 = *(unsigned char **)(a1 + 184);
        }
        *(void *)(a1 + 184) = v16;
      }
      else if (v18 == v16)
      {
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v16 + 24))(a1 + 160, buf);
        (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
        *(void *)(a1 + 184) = v38;
        long long v38 = buf;
      }
      else
      {
        long long v38 = *(unsigned char **)(a1 + 184);
        *(void *)(a1 + 184) = v17;
      }
    }
    sub_100EB975C(buf);
    sub_10033A644((void *)(a1 + 192), a4);
    sub_1003351AC((void *)(a1 + 224), a5);
    if (*(_DWORD *)(a1 + 140) == 2)
    {
      int v19 = *(_DWORD *)(a1 + 148);
      if (v19 && v19 != a2)
      {
        long long v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = asString();
          uint64_t v22 = subscriber::asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v21;
          __int16 v35 = 2080;
          uint64_t v36 = v22;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E %s already activated on different Sim slot %s, fail the activation", buf, 0x16u);
        }
        uint64_t v23 = *(std::__shared_weak_count **)(a1 + 16);
        if (v23 && std::__shared_weak_count::lock(v23)) {
          operator new();
        }
        sub_100088B9C();
      }
      if ((anyContextType() & 1) != 0 || *(_DWORD *)(a1 + 144) == a6)
      {
        int v26 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = asString();
          uint64_t v28 = asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v27;
          __int16 v35 = 2080;
          uint64_t v36 = v28;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s already activated on context type %s", buf, 0x16u);
        }
        uint64_t v29 = *(std::__shared_weak_count **)(a1 + 16);
        if (v29 && std::__shared_weak_count::lock(v29)) {
          operator new();
        }
        sub_100088B9C();
      }
      BOOL v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = asString();
        uint64_t v32 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v31;
        __int16 v35 = 2080;
        uint64_t v36 = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#E %s already activated on different context type %s, fail the activation", buf, 0x16u);
      }
      int v33 = *(std::__shared_weak_count **)(a1 + 16);
      if (v33 && std::__shared_weak_count::lock(v33)) {
        operator new();
      }
      sub_100088B9C();
    }
    *(_DWORD *)(a1 + 148) = a2;
    if ((anyContextType() & 1) == 0)
    {
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I force to use %s context", buf, 0xCu);
      }
      sub_100F7F824(a1, a6);
    }
    sub_100F7F978(a1);
  }
}

void sub_100F7F7D8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F7F824(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 152) = a2;
  int v4 = anyContextType();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 56));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    __int16 v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    char v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  char v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (v14) {
LABEL_10:
  }
    (*(void (**)(uint64_t, void, void, void, uint64_t))(*(void *)v14 + 104))(v14, *(unsigned int *)(a1 + 148), *(unsigned int *)(a1 + 120), v4 ^ 1u, a2);
LABEL_11:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100F7F95C(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7F978(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(*(_DWORD *)(a1 + 136) + 1);
  *(_DWORD *)(a1 + 136) = v2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 56));
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v20.__r_.__value_.__r.__words[0] = v5;
  __int16 v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v20);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_11:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11)
  {
LABEL_7:
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E no DataServiceInterface", (uint8_t *)&v20, 2u);
    }
    sub_100F80130(a1, 0);
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v14 = *(unsigned int *)(a1 + 148);
  uint64_t v15 = ConnectionTypeToMask();
  *((unsigned char *)&v20.__r_.__value_.__s + 23) = 16;
  strcpy((char *)&v20, "Activating from ");
  unint64_t v16 = *(const char **)(a1 + 48);
  size_t v17 = strlen(v16);
  uint64_t v18 = std::string::append(&v20, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  std::string::size_type v22 = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v11 + 80))(v11, v14, v15, 1, __p, 0, 0);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_15:
    if (v12) {
      return;
    }
    goto LABEL_16;
  }
  operator delete(v20.__r_.__value_.__l.__data_);
  if (v12) {
    return;
  }
LABEL_16:
  sub_10004D2C8(v10);
}

void sub_100F7FB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F7FBC4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Deactivating %s.", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 148);
  sub_100F7EC74(a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 56));
  int v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      std::string::size_type v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_9;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  char v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_9:
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E no DataServiceInterface", (uint8_t *)&buf, 2u);
      if (v14) {
        return;
      }
      goto LABEL_18;
    }
LABEL_17:
    if (v14) {
      return;
    }
    goto LABEL_18;
  }
LABEL_14:
  uint64_t v16 = ConnectionTypeToMask();
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 18;
  strcpy((char *)&buf, "Deactivating from ");
  size_t v17 = *(const char **)(a1 + 48);
  size_t v18 = strlen(v17);
  long long v19 = std::string::append(&buf, v17, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v22 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, void, void))(*(void *)v13 + 80))(v13, v3, v16, 0, __p, 0, 0);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v14) {
    return;
  }
LABEL_18:
  sub_10004D2C8(v12);
}

void sub_100F7FE44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F7FEA4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

void sub_100F7FEAC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)a2, *(Registry **)(a1 + 56));
  std::string::size_type v5 = ServiceMap;
  if (v6 < 0)
  {
    std::string::size_type v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v14 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v14);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_10:
  (*(void (**)(long long *__return_ptr, uint64_t, void, void))(*(void *)v12 + 120))(&v14, v12, *(unsigned int *)(a1 + 148), *(unsigned int *)(a1 + 120));
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v14;
  *(void *)(a2 + 16) = v15;
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100F7FFF8(_Unwind_Exception *exception_object)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100F8002C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  return sub_1000302C0((char *)a2, *(long long **)(a1 + 256), *(long long **)(a1 + 264), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 264) - *(void *)(a1 + 256)) >> 3));
}

uint64_t sub_100F80054(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s activated.", (uint8_t *)&v4, 0xCu);
  }
  uint64_t result = *(void *)(a1 + 184);
  if (result)
  {
    int v4 = *(_DWORD *)(a1 + 144);
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)result + 48))(result, &v4);
  }
  return result;
}

void sub_100F80130(uint64_t a1, char a2)
{
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v5[0]) = 136315138;
    *(void *)((char *)v5 + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s activation failed.", (uint8_t *)v5, 0xCu);
  }
  if (*(void *)(a1 + 216))
  {
    memset(v5, 0, sizeof(v5));
    sub_1000DFC90((uint64_t)v5, a1 + 192);
    sub_100F7EC74(a1);
    sub_1000607A8((uint64_t)v5, a2);
    sub_100060644(v5);
  }
}

void sub_100F80218(_Unwind_Exception *exception_object)
{
}

void sub_100F80234(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        sub_100F7F978(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100F80294(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F802A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F802C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F802D4(void *a1@<X1>, NSObject **a2@<X2>, int *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x130uLL);
  sub_100F80360(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_100F8034C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100F80360(void *a1, void *a2, NSObject **a3, int *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A762C0;
  sub_100F7DD14((uint64_t)(a1 + 3), a2, a3, *a4);
  return a1;
}

void sub_100F803AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100F803C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A762C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F803E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A762C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F80434(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F80460()
{
}

__n128 sub_100F80474(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A76310;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F804C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76310;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F80500(uint64_t *a1, xpc_object_t *a2)
{
  sub_100318E34(a1[1], a2);
  char v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    char v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100F8057C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F805BC()
{
}

void sub_100F805CC()
{
}

__n128 sub_100F805E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A76390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F80634(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F8066C(void *a1)
{
  v6[0] = 0;
  v6[1] = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void *))(*v4 + v2);
  }
  return v2(v4, v6);
}

uint64_t sub_100F806EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F8072C()
{
}

void sub_100F8073C()
{
}

__n128 sub_100F80750(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A76410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F807A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F807DC(void *a1)
{
  long long v6 = 0u;
  memset(v5, 0, sizeof(v5));
  DWORD2(v6) = -1;
  read_rest_value();
  uint64_t v2 = (void (*)(void *, _OWORD *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, _OWORD *))(*v4 + v2);
  }
  v2(v4, v5);
  std::string::size_type v7 = (void **)v5 + 1;
  sub_100047F64(&v7);
}

void sub_100F80880(_Unwind_Exception *a1)
{
  *(void *)(v2 - 24) = v1;
  sub_100047F64((void ***)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F80898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F808D8()
{
}

void sub_100F808E8()
{
}

__n128 sub_100F808FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A76490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F80950(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F80988(void *a1)
{
  v6[1] = 0;
  void v6[2] = 0;
  v6[0] = 0xFFFFFFFFLL;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void *))(*v4 + v2);
  }
  return v2(v4, v6);
}

uint64_t sub_100F80A14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F80A54()
{
}

uint64_t *sub_100F80A60(void **a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = *a1;
  sub_1000607A8((uint64_t)v3, 0);
  sub_1002BFA38(&v3);
  return sub_100046B58((uint64_t *)&v2);
}

void sub_100F80AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_100F80AC4(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100F80130(**a1, 0);
  operator delete();
}

void sub_100F80B1C()
{
}

void sub_100F80B48(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100F80130(**a1, 0);
  operator delete();
}

void sub_100F80BA0()
{
}

void sub_100F80BCC(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100F80054(**a1);
  operator delete();
}

void sub_100F80C20()
{
}

void sub_100F80C4C()
{
}

double sub_100F80CC0@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_100F80CF8(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101020664();
}

void sub_100F80D70(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F80D88(IBICDMASettingsFactoryInterface *this)
{
  *(void *)this = off_101A76510;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  IBICDMASettingsFactoryInterface::~IBICDMASettingsFactoryInterface(this);
}

void sub_100F80DE4(IBICDMASettingsFactoryInterface *this)
{
  *(void *)this = off_101A76510;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  IBICDMASettingsFactoryInterface::~IBICDMASettingsFactoryInterface(this);

  operator delete();
}

void sub_100F80E54(void *a1)
{
  *a1 = off_101A76558;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  SilenceAssertionControllerInterface::~SilenceAssertionControllerInterface((SilenceAssertionControllerInterface *)a1);
}

void sub_100F80EC8(void *a1)
{
  sub_100F80E54(a1);

  operator delete();
}

void sub_100F80F00(uint64_t a1, void *a2)
{
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Silence assertion feature is not supported on this platform", (uint8_t *)v4, 2u);
  }
  xpc_object_t v5 = xpc_int64_create(45);
  if (!v5) {
    xpc_object_t v5 = xpc_null_create();
  }
  v4[0] = *a2;
  v4[1] = "kPosixError";
  sub_100035E70((uint64_t)v4, &v5, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
}

void sub_100F80FC0(uint64_t a1, void **a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Silence assertion feature is not supported on this platform", buf, 2u);
  }
  xpc_object_t object = xpc_int64_create(45);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)std::string buf = *a3;
  uint64_t v28 = "kPosixError";
  sub_100035E70((uint64_t)buf, &object, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 48));
  uint64_t v11 = ServiceMap;
  uint64_t v12 = "11CCXpcServer";
  if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
  {
    char v13 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    size_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  size_t v17 = 0;
  char v19 = 1;
  if (!v18)
  {
LABEL_11:
    long long v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Silence Assertion response: cannot locate XPC server from reg. Not notifying assertion addition status", buf, 2u);
      if (v19) {
        return;
      }
      goto LABEL_26;
    }
LABEL_25:
    if (v19) {
      return;
    }
    goto LABEL_26;
  }
LABEL_16:
  sub_100058DB0(v25, "SilenceAssertion");
  uint64_t v21 = *a2;
  xpc_object_t v24 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v23 = *(void *)(a4 + 16);
  }
  sub_100C64FD0((long long *)v25, &v24, (long long *)__p, 0);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if ((v26 & 0x80000000) == 0) {
    goto LABEL_25;
  }
  operator delete(v25[0]);
  if (v19) {
    return;
  }
LABEL_26:
  sub_10004D2C8(v17);
}

void sub_100F8121C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  xpc_release(object);
  if (a22 < 0) {
    operator delete(__p);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100F81290(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Silence assertion feature is not supported on this platform", v2, 2u);
  }
}

void *sub_100F812F0(void *a1, void *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "silence.ctrl");
  sub_100F813D8(a1 + 1, "SilenceAssertionController", QOS_CLASS_UTILITY, &v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *a1 = off_101A76558;
  a1[6] = *a2;
  uint64_t v4 = a2[1];
  a1[7] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100F813B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  SilenceAssertionControllerInterface::~SilenceAssertionControllerInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_100F813D8(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_100F81440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100F81478()
{
  return 0;
}

void sub_100F81480(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsSilenceAssertion(a1))
  {
    long long v3 = 0uLL;
    sub_100F81550(&v3);
  }
  *a2 = 0;
  a2[1] = 0;
  operator new();
}

void sub_100F8152C()
{
}

void sub_100F81550(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F8179C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    (*((void (**)(dispatch_object_t))a11->isa + 1))(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100F818B0(uint64_t a1)
{
  *(void *)a1 = off_101A76598;
  uint64_t v2 = *(xpc_object_t **)(a1 + 152);
  if (v2)
  {
    long long v3 = *(xpc_object_t **)(a1 + 160);
    uint64_t v4 = *(void **)(a1 + 152);
    if (v3 != v2)
    {
      do
        sub_100F82A38(--v3);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 152);
    }
    *(void *)(a1 + 160) = v2;
    operator delete(v4);
  }
  sub_100F8302C(*(void **)(a1 + 136));
  xpc_object_t v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5) {
    sub_10004D2C8(v5);
  }
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 84));
  OsLogContext v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }

  sub_100F80E54((void *)a1);
}

void sub_100F8196C(uint64_t a1)
{
  sub_100F818B0(a1);

  operator delete();
}

void sub_100F819A4(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[18];
    int v5 = 134217984;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %lu clients are waiting for silence assertion response", (uint8_t *)&v5, 0xCu);
    uint64_t v2 = a1[5];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(a1[20] - a1[19]) >> 3;
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %lu clients are granted silence assertion", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100F81A9C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F81B9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F81C9C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 104);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Prevent detach timer active for %f seconds", (uint8_t *)&buf, 0xCu);
  }
  if (*(double *)(a1 + 104) != 0.0)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Barring silence assertion", (uint8_t *)&buf, 2u);
    }
    xpc_object_t v9 = xpc_BOOL_create(1);
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    *(void *)&long long buf = *a2;
    *((void *)&buf + 1) = "kRadioIsSilenceAssertionBarred";
    sub_100035E70((uint64_t)&buf, &v9, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_object_t v7 = xpc_double_create(*(double *)(a1 + 104));
    if (!v7) {
      xpc_object_t v7 = xpc_null_create();
    }
    *(void *)&long long buf = *a2;
    *((void *)&buf + 1) = "kBarringEndTime";
    sub_100035E70((uint64_t)&buf, &v7, &v8);
    xpc_release(v8);
    xpc_object_t v8 = 0;
    xpc_release(v7);
  }
}

void sub_100F81E2C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F81E6C(uint64_t a1, int a2)
{
  if (a2)
  {
    if (!*(_DWORD *)(a1 + 80)) {
      return;
    }
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315138;
      uint64_t v11 = radioStateAsString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Silence assertion granted; radio state is %s [not Online] -- time to party",
        (uint8_t *)&v10,
        0xCu);
    }
    uint64_t v4 = a1;
    unint64_t v5 = 0;
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)(a1 + 152);
  uint64_t v7 = *(void *)(a1 + 160);
  xpc_object_t v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6 == v7)
  {
    if (v9)
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Silence assertion rejected; notifying clients waiting for response",
        (uint8_t *)&v10,
        2u);
    }
    uint64_t v4 = a1;
    unint64_t v5 = 0x100000001;
LABEL_12:
    sub_100F81FCC(v4, v5, 0.0);
    return;
  }
  if (v9)
  {
    int v10 = 134217984;
    uint64_t v11 = (v7 - v6) >> 3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Silence assertion revoked even though %lu clients were granted earlier", (uint8_t *)&v10, 0xCu);
  }
}

void sub_100F81FCC(uint64_t a1, unint64_t a2, double a3)
{
  unint64_t v5 = *(void **)(a1 + 128);
  uint64_t v6 = (void *)(a1 + 136);
  if (v5 != (void *)(a1 + 136))
  {
    int64_t value = HIDWORD(a2);
    do
    {
      if (a2)
      {
        xpc_object_t v54 = xpc_int64_create(value);
        if (!v54) {
          xpc_object_t v54 = xpc_null_create();
        }
        *(void *)long long buf = v5[8];
        *(void *)&uint8_t buf[8] = "kPosixError";
        sub_100035E70((uint64_t)buf, &v54, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v54);
        xpc_object_t v54 = 0;
        xpc_object_t v52 = xpc_double_create(a3);
        if (!v52) {
          xpc_object_t v52 = xpc_null_create();
        }
        *(void *)long long buf = v5[8];
        *(void *)&uint8_t buf[8] = "kBarringEndTime";
        sub_100035E70((uint64_t)buf, &v52, &v53);
        xpc_release(v53);
        xpc_object_t v53 = 0;
        xpc_release(v52);
        xpc_object_t v52 = 0;
      }
      else
      {
        BOOL v9 = (void *)v5[4];
        int v10 = *(xpc_object_t **)(a1 + 160);
        unint64_t v11 = *(void *)(a1 + 168);
        if ((unint64_t)v10 >= v11)
        {
          uint64_t v13 = *(void *)(a1 + 152);
          uint64_t v14 = ((uint64_t)v10 - v13) >> 3;
          if ((unint64_t)(v14 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v15 = v11 - v13;
          uint64_t v16 = v15 >> 2;
          if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
            uint64_t v16 = v14 + 1;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v16;
          }
          if (v17)
          {
            if (v17 >> 61) {
              sub_10006A7CC();
            }
            uint64_t v18 = (char *)operator new(8 * v17);
          }
          else
          {
            uint64_t v18 = 0;
          }
          char v19 = (xpc_object_t *)&v18[8 * v14];
          long long v20 = &v18[8 * v17];
          sub_100F82A68(v19, v9);
          uint64_t v12 = v19 + 1;
          char v22 = *(xpc_object_t **)(a1 + 152);
          uint64_t v21 = *(xpc_object_t **)(a1 + 160);
          if (v21 == v22)
          {
            *(void *)(a1 + 152) = v19;
            *(void *)(a1 + 160) = v12;
            *(void *)(a1 + 168) = v20;
          }
          else
          {
            char v23 = *(xpc_object_t **)(a1 + 160);
            do
            {
              xpc_object_t v24 = *--v23;
              *--char v19 = v24;
              *(v21 - 1) = xpc_null_create();
              uint64_t v21 = v23;
            }
            while (v23 != v22);
            uint64_t v21 = *(xpc_object_t **)(a1 + 152);
            uint64_t v25 = *(xpc_object_t **)(a1 + 160);
            *(void *)(a1 + 152) = v19;
            *(void *)(a1 + 160) = v12;
            *(void *)(a1 + 168) = v20;
            while (v25 != v21)
              sub_100F82A38(--v25);
          }
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          uint64_t v12 = sub_100F82A68(v10, (xpc_object_t)v5[4]) + 1;
        }
        *(void *)(a1 + 160) = v12;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 48));
      uint64_t v27 = ServiceMap;
      uint64_t v28 = "11CCXpcServer";
      if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
      {
        uint64_t v29 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v30 = 5381;
        do
        {
          uint64_t v28 = (const char *)v30;
          unsigned int v31 = *v29++;
          uint64_t v30 = (33 * v30) ^ v31;
        }
        while (v31);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v28;
      uint64_t v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
      if (v32)
      {
        uint64_t v33 = v32[3];
        int v34 = (std::__shared_weak_count *)v32[4];
        if (v34)
        {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v27);
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v34);
          char v35 = 0;
          if (!v33) {
            goto LABEL_37;
          }
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      std::mutex::unlock(v27);
      int v34 = 0;
      char v35 = 1;
      if (!v33)
      {
LABEL_37:
        uint64_t v36 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Silence Assertion response: cannot locate XPC server from reg. Not notifying assertion addition status", buf, 2u);
          if (v35) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
        goto LABEL_51;
      }
LABEL_42:
      sub_100058DB0(v50, "SilenceAssertion");
      __int16 v37 = (void *)v5[4];
      xpc_object_t v49 = v37;
      if (v37) {
        xpc_retain(v37);
      }
      else {
        xpc_object_t v49 = xpc_null_create();
      }
      if (*((char *)v5 + 63) < 0)
      {
        sub_10004FC84(__p, (void *)v5[5], v5[6]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(v5 + 5);
        uint64_t v48 = v5[7];
      }
      sub_100C64FD0((long long *)v50, &v49, (long long *)__p, a2 == 0);
      if (SHIBYTE(v48) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v49);
      xpc_object_t v49 = 0;
      if (v51 < 0)
      {
        operator delete(v50[0]);
        if (v35) {
          goto LABEL_53;
        }
LABEL_52:
        sub_10004D2C8(v34);
        goto LABEL_53;
      }
LABEL_51:
      if ((v35 & 1) == 0) {
        goto LABEL_52;
      }
LABEL_53:
      long long v38 = (void *)v5[1];
      if (v38)
      {
        do
        {
          uint64_t v39 = v38;
          long long v38 = (void *)*v38;
        }
        while (v38);
      }
      else
      {
        do
        {
          uint64_t v39 = (void *)v5[2];
          BOOL v40 = *v39 == (void)v5;
          unint64_t v5 = v39;
        }
        while (!v40);
      }
      unint64_t v5 = v39;
    }
    while (v39 != v6);
  }
  int v41 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    int v42 = "Rejected";
    if (!a2) {
      int v42 = "Granted";
    }
    uint64_t v43 = (uint64_t)(*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 3;
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v42;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v43;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Silence Assertion response: %s. Num current holders: %lu", buf, 0x16u);
  }
  sub_100F8302C(*(void **)(a1 + 136));
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 128) = v6;
  if (*(void *)(a1 + 152) == *(void *)(a1 + 160))
  {
    uint64_t v44 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Release limit to cmas assertion as no more clients need it", buf, 2u);
    }
    int v45 = *(std::__shared_weak_count **)(a1 + 120);
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
    if (v45) {
      sub_10004D2C8(v45);
    }
  }
}

void sub_100F824BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100F8255C(uint64_t a1)
{
  if (*(void *)(a1 + 112) && *(_DWORD *)(a1 + 80))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315138;
      uint64_t v4 = radioStateAsString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Silence assertion has been requested; radio state is %s [not Online] -- time to party",
        (uint8_t *)&v3,
        0xCu);
    }
    sub_100F81FCC(a1, 0, 0.0);
  }
}

void sub_100F82628(uint64_t a1, xpc_object_t *a2)
{
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F82748(uint64_t a1, void **a2, uint64_t *a3, uint64_t a4)
{
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  uint64_t v7 = *a2;
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v8 = a3[1];
  uint64_t v12 = *a3;
  uint64_t v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F82910(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _OWORD v5[2] = sub_100F840A8;
  v5[3] = &unk_101A76948;
  _OWORD v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    BOOL v9 = sub_100F840FC;
    int v10 = &unk_101A76988;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    uint64_t v13 = 0;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    long long block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    BOOL v9 = sub_100F840C0;
    int v10 = &unk_101A76968;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    uint64_t v13 = 0;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_100F82A38(xpc_object_t *a1)
{
  *a1 = 0;
}

xpc_object_t *sub_100F82A68(xpc_object_t *a1, xpc_object_t object)
{
  *a1 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    *a1 = xpc_null_create();
  }
  return a1;
}

void sub_100F82AAC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F82B78(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100F82C50);
  __cxa_rethrow();
}

void sub_100F82BA0(_Unwind_Exception *a1)
{
}

void sub_100F82BB8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F82BF0(uint64_t a1)
{
}

uint64_t sub_100F82C0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F82C50(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F82C80(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F82CB8(uint64_t a1)
{
}

uint64_t sub_100F82CD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F82D18(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F82D44(ServiceManager::Service *this)
{
  *(void *)this = off_101A76758;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F82DA0(ServiceManager::Service *this)
{
  *(void *)this = off_101A76758;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F82E10@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SilenceAssertionController");
}

unsigned char *sub_100F82E20@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  double result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F82E5C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F81A9C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F81A9C(v4, 0);
}

uint64_t sub_100F82EE0()
{
  return 0;
}

uint64_t sub_100F82EE8()
{
  return 1;
}

uint64_t sub_100F82EF0()
{
  return 0;
}

uint64_t sub_100F82F00(uint64_t result, int a2, ServiceStage *this)
{
  if (!a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&object, this);
    uint64_t v4 = object;
    if (object)
    {
      dispatch_retain(object);
      dispatch_group_enter(v4);
    }
    unint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100F8302C(void *a1)
{
  if (a1)
  {
    sub_100F8302C(*a1);
    sub_100F8302C(a1[1]);
    sub_100F83080((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100F83080(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

uint64_t *sub_100F830CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_101A767D8;
  v3[1] = v2;
  v3[2] = sub_100F819A4;
  v3[3] = 0;
  uint64_t v13 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  sub_1009E3980(v2 + 104);
  sub_1002D7B1C(v2 + 84);
  sub_100058DB0(__p, "/cc/props/radio_state");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A76858;
  v4[1] = v2 + 80;
  void v4[2] = v2;
  v4[3] = sub_100F8255C;
  void v4[4] = 0;
  uint64_t v13 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100F83268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100F832CC()
{
}

__n128 sub_100F832E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A767D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F83334(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A767D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F8336C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F833B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F833F4()
{
}

void sub_100F83404()
{
}

__n128 sub_100F83418(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A76858;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F8346C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A76858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F834A4(void *a1, xpc *this, uint64_t a3)
{
  uint64_t v4 = (_DWORD *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  unint64_t v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    unint64_t v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_100F8352C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F8356C()
{
}

uint64_t *sub_100F83578(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100F835C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100F835DC(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t v1 = *(void **)a1;
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)a1 + 8);
  uint64_t v2 = *(void *)(*(void *)a1 + 16);
  v6[0] = *v1;
  v6[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_100F81C9C(v2, v6);
    sub_10004D2C8(v3);
  }
  else
  {
    sub_100F81C9C(v2, v6);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[1];
  if (v4) {
    sub_10004D2C8(v4);
  }
  operator delete();
}

uint64_t *sub_100F8366C(xpc_object_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *((void *)*v1 + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(v2[20] - v2[19]) >> 3;
    *(_DWORD *)long long buf = 134217984;
    uint64_t v17 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Request to release silence assertion; current holders: %lu",
      buf,
      0xCu);
  }
  uint64_t v6 = (xpc_object_t *)v2[19];
  uint64_t v5 = (xpc_object_t *)v2[20];
  while (v6 != v5)
  {
    if (xpc_equal(*v6, v1[1])) {
      goto LABEL_8;
    }
    ++v6;
  }
  uint64_t v6 = v5;
LABEL_8:
  if (v6 != v5)
  {
    for (signed int i = v6 + 1; i != v5; ++i)
    {
      if (!xpc_equal(*i, v1[1]))
      {
        xpc_object_t v8 = *i;
        xpc_object_t *i = xpc_null_create();
        xpc_object_t v9 = *v6;
        *uint64_t v6 = v8;
        xpc_release(v9);
        ++v6;
      }
    }
  }
  int v10 = (xpc_object_t *)v2[20];
  if (v6 != v10)
  {
    while (v10 != v6)
      sub_100F82A38(--v10);
    v2[20] = v6;
  }
  if ((xpc_object_t *)v2[19] == v6)
  {
    char v11 = v2[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Release limit to cmas assertion as no more clients need it", buf, 2u);
    }
    uint64_t v12 = (std::__shared_weak_count *)v2[15];
    v2[14] = 0;
    v2[15] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  sub_100F838AC((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100F83870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F838AC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_100F83904(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (void *)(v1 + 8);
    if (*(char *)(v1 + 31) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Request for silence assertion from client [%s]", buf, 0xCu);
  }
  sub_100F819A4((void *)v2);
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(v1 + 8);
    uint64_t v30 = *(void *)(v1 + 24);
    *(_OWORD *)std::string __p = v5;
  }
  uint64_t v7 = *(void *)(v1 + 40);
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 48);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (SHIBYTE(v30) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)__p;
    uint64_t v34 = v30;
  }
  *(void *)&long long v35 = v7;
  *((void *)&v35 + 1) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v8 = *(void **)(v1 + 32);
  xpc_object_t v9 = *(char **)(v2 + 136);
  int v10 = (char **)(v2 + 136);
  char v11 = (char **)(v2 + 136);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        char v11 = (char **)v9;
        unint64_t v12 = *((void *)v9 + 4);
        if (v12 <= (unint64_t)v8) {
          break;
        }
        xpc_object_t v9 = *v11;
        int v10 = v11;
        if (!*v11) {
          goto LABEL_22;
        }
      }
      if (v12 >= (unint64_t)v8) {
        break;
      }
      xpc_object_t v9 = v11[1];
      if (!v9)
      {
        int v10 = v11 + 1;
        goto LABEL_22;
      }
    }
  }
  else
  {
LABEL_22:
    uint64_t v32 = 0;
    uint64_t v13 = (char *)operator new(0x50uLL);
    *(void *)&long long v31 = v13;
    *((void *)&v31 + 1) = v2 + 136;
    *((void *)v13 + 4) = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      *((void *)v13 + 4) = xpc_null_create();
    }
    uint64_t v14 = v13 + 40;
    if (SHIBYTE(v34) < 0)
    {
      sub_10004FC84(v14, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)uint64_t v14 = *(_OWORD *)buf;
      *((void *)v13 + 7) = v34;
    }
    *((_OWORD *)v13 + 4) = v35;
    long long v35 = 0uLL;
    LOBYTE(v32) = 1;
    *(void *)uint64_t v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v11;
    xpc_object_t *v10 = v13;
    uint64_t v15 = **(void **)(v2 + 128);
    if (v15)
    {
      *(void *)(v2 + 128) = v15;
      uint64_t v13 = *v10;
    }
    sub_100046C90(*(uint64_t **)(v2 + 136), (uint64_t *)v13);
    ++*(void *)(v2 + 144);
    *(void *)&long long v31 = 0;
    sub_100F83EA8((uint64_t)&v31);
  }
  if (*((void *)&v35 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v35 + 1));
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(*(void **)buf);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  double v16 = *(double *)(v2 + 104);
  if (v16 == 0.0)
  {
    uint64_t v19 = *(void *)(v2 + 112);
    if (v19)
    {
      int v20 = *(_DWORD *)(v19 + 68);
      uint64_t v21 = *(NSObject **)(v2 + 40);
      BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
      if (v20 == 2)
      {
        if (v22)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Limit to cmas assertion is already granted; grant silence assertion to client right away",
            buf,
            2u);
        }
        sub_100F81E6C(v2, 1);
      }
      else if (v22)
      {
        uint64_t v26 = *(void *)(v2 + 144);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Waiting for limit to cmas assertion be granted; pending client requests [%lu]",
          buf,
          0xCu);
      }
    }
    else
    {
      char v23 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Acquiring limit to cmas assertion", buf, 2u);
      }
      sub_100058DB0(buf, "/cc/assertions/limit_to_cmas_mode");
      ctu::rest::AssertionHandle::create();
      if (SHIBYTE(v34) < 0) {
        operator delete(*(void **)buf);
      }
      long long v24 = v31;
      long long v31 = 0uLL;
      uint64_t v25 = *(std::__shared_weak_count **)(v2 + 120);
      *(_OWORD *)(v2 + 112) = v24;
      if (v25)
      {
        sub_10004D2C8(v25);
        if (*((void *)&v31 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
        }
      }
      *(void *)long long buf = off_101A768D8;
      *(void *)&uint8_t buf[8] = v2;
      *(void *)&long long v35 = buf;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(buf);
    }
  }
  else
  {
    uint64_t v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(double *)&uint8_t buf[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E Prevent detach timer active [%f secs]; cannot grant silence assertion",
        buf,
        0xCu);
      double v16 = *(double *)(v2 + 104);
    }
    sub_100F81FCC(v2, 0x2300000001uLL, v16);
  }
  sub_100F83E34(&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_100F83D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29)
{
}

uint64_t *sub_100F83E34(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
    if (v2) {
      sub_10004D2C8(v2);
    }
    xpc_release(*(xpc_object_t *)(v1 + 32));
    *(void *)(v1 + 32) = 0;
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void sub_100F83EA8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100F83080((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100F83F04()
{
}

void *sub_100F83F18(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A768D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F83F60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A768D8;
  a2[1] = v2;
  return result;
}

void sub_100F83F8C(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    long long v5 = "rejected";
    if (v2) {
      long long v5 = "granted";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Limit to cmas assertion is %s", (uint8_t *)&v6, 0xCu);
  }
  sub_100F81E6C(v3, v2 != 0);
}

uint64_t sub_100F8405C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F8409C()
{
}

uint64_t sub_100F840A8(uint64_t a1)
{
  return (uint64_t)(*(void *)(**(void **)(a1 + 40) + 160) - *(void *)(**(void **)(a1 + 40) + 152)) >> 3;
}

uint64_t sub_100F840C0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100F840FC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_100F84138(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100F84228(uint64_t **a1)
{
  int v2 = a1;
  uint64_t v1 = **a1;
  sub_100058DB0(&__p, "/cc/events/app_state_changed");
  v5[0] = off_101A769B8;
  v5[1] = v1;
  v5[3] = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(v5);
  if (v4 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100F84300(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100F84350()
{
}

void *sub_100F84364(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A769B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F843AC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A769B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F843D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F84418()
{
}

void *sub_100F84424(void *a1)
{
  *a1 = off_101A76A38;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F84470(void *a1)
{
  *a1 = off_101A76A38;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100F844DC(uint64_t a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A76A38;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F84544(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A76A38;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F8458C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F8459C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F845DC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v20 = 0;
  rest::read_rest_value((rest *)&v20, (AppInfoResponse *)&object, v3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    long long v5 = *(void **)(a1 + 8);
    int v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!*(void *)(a1 + 24) || (sub_1000691CC(v5, *(_DWORD *)(a1 + 16), v20) & 1) == 0)
      {
LABEL_21:
        sub_10004D2C8(v7);
        goto LABEL_22;
      }
      int v8 = *(_DWORD *)(a1 + 16);
      int v9 = BYTE4(v20);
      uint64_t v21 = 0;
      BOOL v22 = 0;
      sub_1000326EC((uint64_t)v5, v8, &v21);
      int v10 = v21;
      if (v21)
      {
        int v11 = v21[1];
        if (v11 == 3)
        {
          int v12 = 5;
LABEL_10:
          if (v9) {
            int v13 = 1;
          }
          else {
            int v13 = v12;
          }
          if (v13 != v11)
          {
            uint64_t v14 = v5[5];
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v15 = v10 + 2;
              if (*((char *)v10 + 31) < 0) {
                uint64_t v15 = (void *)*v15;
              }
              int v16 = *v10;
              uint64_t v17 = asString();
              uint64_t v18 = asString();
              *(_DWORD *)long long buf = 136315906;
              long long v24 = v15;
              __int16 v25 = 1024;
              int v26 = v16;
              __int16 v27 = 2080;
              uint64_t v28 = v17;
              __int16 v29 = 2080;
              uint64_t v30 = v18;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I App state[%s(%d)] is moving from %s to %s", buf, 0x26u);
            }
            v10[1] = v13;
          }
          goto LABEL_19;
        }
        if (v11 == 2)
        {
          int v12 = 4;
          goto LABEL_10;
        }
      }
LABEL_19:
      if (v22) {
        sub_10004D2C8(v22);
      }
      goto LABEL_21;
    }
  }
LABEL_22:
  xpc_release(object);
}

void sub_100F847A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100F847F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F84834()
{
}

uint64_t sub_100F84850@<X0>(void *a1@<X8>)
{
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  memset(v7, 0, sizeof(v7));
  long long v6 = 0u;
  sub_10004BD84((uint64_t)&v6);
  *(void *)((char *)v7 + *(void *)(v6 - 24)) = 14;
  sub_10004B96C(v7, (uint64_t)"Circle:[", 8);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_10004B96C(v2, (uint64_t)",", 1);
  uint64_t v3 = (void *)std::ostream::operator<<();
  sub_10004B96C(v3, (uint64_t)"] ", 2);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v7 + 8, a1);
  *(void *)((char *)&v7[-1]
  *(void *)&v7[0] = v4;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100F84A6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100F84A80(uint64_t a1, void *a2, dispatch_object_t *a3)
{
  *(void *)a1 = off_101A10AF0;
  long long v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "rm.op.act");
  *long long v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)a1 = off_101A76AE0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "OperatingModeManagerAction");
  long long v10 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v10) {
    dispatch_release(v10);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 2;
  return a1;
}

void sub_100F84C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  char v23 = *(std::__shared_weak_count **)(v19 + 56);
  if (v23) {
    sub_10004D2C8(v23);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void *sub_100F84C88(void *a1)
{
  *a1 = off_101A76AE0;
  sub_100F85600(a1 + 20);
  sub_10030AB98(a1 + 15);
  sub_100F8557C(a1 + 10);
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100F84D0C(void *a1)
{
  sub_100F84C88(a1);

  operator delete();
}

void sub_100F84D44(uint64_t a1)
{
  if (capabilities::ct::supportsCMASCampOnlyMode((capabilities::ct *)a1))
  {
    uint64_t v2 = (uint64_t (***)())(a1 + 80);
    long long v11 = off_101A76BC0;
    uint64_t v12 = a1 + 64;
    OsLogContext v13 = &v11;
    if (&v11 != (uint64_t (***)())(a1 + 80))
    {
      uint64_t v3 = *(uint64_t (****)())(a1 + 104);
      if (v3 == v2)
      {
        uint64_t v15 = a1 + 64;
        uint64_t v16 = 0;
        OsLogContext v13 = 0;
        long long v14 = off_101A76BC0;
        ((void (*)(uint64_t, uint64_t (***)()))(*v2)[3])(a1 + 80, &v11);
        (*(void (**)(void))(**(void **)(a1 + 104) + 32))(*(void *)(a1 + 104));
        *(void *)(a1 + 104) = 0;
        OsLogContext v13 = &v11;
        ((void (*)(uint64_t (***)(), uint64_t))v14[3])(&v14, a1 + 80);
        ((void (*)(uint64_t (***)()))v14[4])(&v14);
      }
      else
      {
        *(void *)(a1 + 80) = off_101A76BC0;
        *(void *)(a1 + 88) = a1 + 64;
        OsLogContext v13 = v3;
      }
      *(void *)(a1 + 104) = v2;
    }
    sub_100F8557C(&v11);
    uint64_t v4 = *(void *)(a1 + 104);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, a1 + 112);
    }
  }
  long long v11 = off_101A76C50;
  uint64_t v12 = a1 + 64;
  OsLogContext v13 = &v11;
  sub_100318874(&v11, (void *)(a1 + 120));
  sub_10030AB98(&v11);
  uint64_t v5 = *(void *)(a1 + 144);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, a1 + 152);
  }
  long long v6 = (uint64_t (***)())(a1 + 160);
  long long v11 = off_101A76CD0;
  uint64_t v12 = a1 + 64;
  OsLogContext v13 = &v11;
  if (&v11 != (uint64_t (***)())(a1 + 160))
  {
    uint64_t v7 = *(uint64_t (****)())(a1 + 184);
    if (v7 == v6)
    {
      uint64_t v15 = a1 + 64;
      uint64_t v16 = 0;
      OsLogContext v13 = 0;
      long long v14 = off_101A76CD0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v6)[3])(a1 + 160, &v11);
      (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
      *(void *)(a1 + 184) = 0;
      OsLogContext v13 = &v11;
      ((void (*)(uint64_t (***)(), uint64_t))v14[3])(&v14, a1 + 160);
      ((void (*)(uint64_t (***)()))v14[4])(&v14);
    }
    else
    {
      *(void *)(a1 + 160) = off_101A76CD0;
      *(void *)(a1 + 168) = a1 + 64;
      OsLogContext v13 = v7;
    }
    *(void *)(a1 + 184) = v6;
  }
  sub_100F85600(&v11);
  uint64_t v8 = *(void *)(a1 + 184);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a1 + 192);
  }
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100F85130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F85164(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315394;
    uint64_t v3 = asString();
    __int16 v4 = 2080;
    uint64_t v5 = asString();
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I  -- triggeredOperatingModeType=%s, inCampOnly=%s", (uint8_t *)&v2, 0x16u);
  }
}

void sub_100F85228(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    if (capabilities::ct::requiresSeparateOperatingModeForStewie((capabilities::ct *)a1)) {
      int v3 = 1;
    }
    else {
      int v3 = 2;
    }
LABEL_16:
    if (*(_DWORD *)(a1 + 192) == v3) {
      return;
    }
    int active = isActiveLowPowerMode();
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v24 = 136315138;
      *(void *)&v24[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [    ] requesting radio operating mode %s", v24, 0xCu);
    }
    if (*(unsigned __int8 *)(a1 + 152) != active)
    {
      *(unsigned char *)(a1 + 152) = active;
      uint64_t v10 = *(void *)(a1 + 144);
      if (v10) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, a1 + 152);
      }
    }
    long long v11 = (uint64_t *)*(unsigned int *)(a1 + 192);
    if (v11 != v3)
    {
      *(_DWORD *)(a1 + 192) = v3;
      uint64_t v12 = *(void *)(a1 + 184);
      if (v12) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a1 + 192);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 48));
    long long v14 = ServiceMap;
    if (v15 < 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v24 = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)v24);
    if (v19)
    {
      uint64_t v21 = v19[3];
      uint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        if (!v21)
        {
LABEL_35:
          if ((v22 & 1) == 0) {
            sub_10004D2C8(v20);
          }
          return;
        }
LABEL_34:
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v21 + 456))(v21, active ^ 1u, 2);
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  int v3 = a2;
  if (a2 == 2)
  {
    if (capabilities::ct::supportsCMASCampOnlyMode((capabilities::ct *)a1))
    {
      uint64_t v5 = a1 + 112;
      if (*(_DWORD *)(a1 + 112) != 3)
      {
        int v6 = 3;
LABEL_13:
        *(_DWORD *)(a1 + 112) = v6;
        uint64_t v7 = *(void *)(a1 + 104);
        if (v7) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v5);
        }
      }
    }
LABEL_15:
    int v3 = 2;
    goto LABEL_16;
  }
  if (a2 != 3) {
    goto LABEL_16;
  }
  __int16 v4 = (capabilities::ct *)capabilities::ct::supportsCMASCampOnlyMode((capabilities::ct *)a1);
  if (v4)
  {
    uint64_t v5 = a1 + 112;
    if (*(_DWORD *)(a1 + 112) != 1)
    {
      int v6 = 1;
      goto LABEL_13;
    }
    goto LABEL_15;
  }
  if (capabilities::ct::supportsCampOnlyMode(v4))
  {
    int v3 = 3;
    goto LABEL_16;
  }
  char v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v24 = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Camp only mode not supported", v24, 2u);
  }
}

void sub_100F8554C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F8557C(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F85600(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F85688()
{
}

void *sub_100F8569C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A76BC0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F856E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A76BC0;
  a2[1] = v2;
  return result;
}

void sub_100F85710(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/cmas_camp_only_mode");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100F857C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F85808(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F85848()
{
}

void sub_100F85858()
{
}

void *sub_100F8586C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A76C50;
  result[1] = v3;
  return result;
}

uint64_t sub_100F858B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A76C50;
  a2[1] = v2;
  return result;
}

void sub_100F858E0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/airplane_mode");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100F85990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100F859D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F85A18()
{
}

void sub_100F85A28()
{
}

void *sub_100F85A3C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A76CD0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F85A84(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A76CD0;
  a2[1] = v2;
  return result;
}

void sub_100F85AB0(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/operating_mode_request");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100F85B64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F85BA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F85BE8()
{
}

uint64_t sub_100F85BF4(uint64_t a1, void *a2, char a3)
{
  sub_100058DB0(__p, "jetsam");
  sub_100DD14AC(a1, a2, (long long *)__p, "xpc", 0);
  *(void *)a1 = off_101A76DD0;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101A76D60;
  *(unsigned char *)(a1 + 168) = a3;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  return a1;
}

void sub_100F85CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F85CC8()
{
}

void sub_100F85D3C()
{
}

uint64_t sub_100F85D60(uint64_t a1, xpc_connection_t *a2, uint64_t **a3)
{
  if (*(unsigned char *)(a1 + 168))
  {
    if (!*(void *)(a1 + 176))
    {
      sub_100058DB0(&__p, "JetsamXpc");
      Registry::createXpcJetsamAssertion();
      long long v6 = *(_OWORD *)buf;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v7 = *(std::__shared_weak_count **)(a1 + 184);
      *(_OWORD *)(a1 + 176) = v6;
      if (v7)
      {
        sub_10004D2C8(v7);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      if (v12 < 0) {
        operator delete(__p);
      }
    }
    char v8 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) < 0) {
        a3 = (uint64_t **)*a3;
      }
      pid_t pid = xpc_connection_get_pid(*a2);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = a3;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = pid;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s(%d) requested Jetsam XPC assertion", buf, 0x12u);
    }
  }
  return 1;
}

void sub_100F85EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F85EC4(uint64_t a1, xpc_connection_t *a2, uint64_t *a3)
{
  if (*(unsigned char *)(a1 + 168))
  {
    char v5 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) < 0) {
        a3 = (uint64_t *)*a3;
      }
      pid_t pid = xpc_connection_get_pid(*a2);
      int v7 = 136315394;
      char v8 = a3;
      __int16 v9 = 1024;
      pid_t v10 = pid;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s(%d) released its Jetsam XPC assertion", (uint8_t *)&v7, 0x12u);
    }
  }
}

void sub_100F85F98(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    int v2 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I All Jetsam XPC assertions released", v4, 2u);
    }
  }
}

uint64_t sub_100F86014(void *a1)
{
  *a1 = off_101A76D60;
  int v2 = (std::__shared_weak_count *)a1[23];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100DD1644((uint64_t)a1);
}

void sub_100F86070(void *a1)
{
  *a1 = off_101A76D60;
  int v2 = (std::__shared_weak_count *)a1[23];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100DD1644((uint64_t)a1);

  operator delete();
}

void sub_100F860E4(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_100F8611C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F8619C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F861D8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F86210(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F86240(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100F86284(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, NSObject **a7, void **a8)
{
  uint64_t v12 = *(void *)(a3 + 16);
  *(_OWORD *)std::string __p = *(_OWORD *)a3;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  char v8 = *a7;
  *a7 = 0;
  aBlock = *a8;
  dispatch_object_t object = v8;
  *a8 = 0;
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t, dispatch_object_t *, void **))(*(void *)a2 + 16))(a2, __p, a4, a5, a6, &object, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F8634C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F86384(uint64_t a1)
{
  sub_100F863C8(*(void *)(a1 + 32));
  int v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

void sub_100F863C8(unint64_t a1)
{
  if (!*(void *)(a1 + 32)) {
    return;
  }
  if (*(void *)(a1 + 40))
  {
    int v2 = *(std::__shared_weak_count **)(a1 + 48);
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    if (v2)
    {
      sub_10004D2C8(v2);
    }
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(0, *(Registry **)(a1 + 16));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __dst.__r_.__value_.__r.__words[0] = v5;
  __int16 v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__dst);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_15:
    std::mutex::unlock(v4);
    pid_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_35;
    }
LABEL_16:
    memset(&v18, 0, sizeof(v18));
    sub_100F86E54(&v18, a1);
    uint64_t v17 = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v15, v18.__r_.__value_.__l.__data_, v18.__r_.__value_.__l.__size_);
    }
    else {
      std::string v15 = v18;
    }
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v15;
    }
    uint64_t v19 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = __p;
    }
    char v22 = 0;
    if (ctu::cf::convert_copy())
    {
      OsLogContext v13 = v19;
      uint64_t v19 = v22;
      char v23 = v13;
      sub_1000558F4(&v23);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    long long v14 = v19;
    uint64_t v16 = v19;
    uint64_t v19 = 0;
    sub_1000558F4(&v19);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    (*(void (**)(uint64_t, const void **, const void *))(*(void *)v11 + 16))(v11, &v17, v14);
    sub_1000558F4(&v16);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    sub_10007CA64(&v17);
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    goto LABEL_35;
  }
  uint64_t v11 = v9[3];
  pid_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_15;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
    goto LABEL_16;
  }
LABEL_35:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100F86658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10007CA64(&a18);
  if (a24 < 0) {
    operator delete(a19);
  }
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(a1);
}

void *sub_100F866F4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 40);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100F86728(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100F8674C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, NSObject **a7, void **a8)
{
  uint64_t v20 = a4;
  uint64_t v21 = a5;
  ctu::TimerService::throwIfPeriodIsZero();
  *(_OWORD *)std::string __p = *(_OWORD *)a3;
  uint64_t v19 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  uint64_t v13 = v20;
  uint64_t v14 = v21;
  std::string v15 = *a7;
  *a7 = 0;
  aBlock = *a8;
  dispatch_object_t object = v15;
  *a8 = 0;
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t, dispatch_object_t *, void **))(*(void *)a2 + 24))(a2, __p, v13, v14, a6, &object, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F86840(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F86878(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  sub_100F863C8(v2);
  sub_100F868D0(v2, *(void *)(a1 + 40), *(unsigned char *)(a1 + 56), v3);
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);

  return v4();
}

void sub_100F868D0(unint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 16));
  unsigned int v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    pid_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    uint64_t v17 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Fail to schedule wake. Missing power assertion provider", (uint8_t *)&buf, 2u);
      if (v16) {
        return;
      }
      goto LABEL_43;
    }
LABEL_42:
    if (v16) {
      return;
    }
    goto LABEL_43;
  }
LABEL_12:
  memset(&v29, 0, sizeof(v29));
  sub_100F86E54(&v29, a1);
  if (a2 <= 2 && (a3 & 1) == 0)
  {
    std::string v18 = (v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v29
        : (std::string *)v29.__r_.__value_.__r.__words[0];
    (*(void (**)(std::string *__return_ptr, uint64_t, std::string *, uint64_t))(*(void *)v15 + 8))(&buf, v15, v18, a2);
    long long v19 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    memset(&buf, 0, 16);
    uint64_t v20 = *(std::__shared_weak_count **)(a1 + 48);
    *(_OWORD *)(a1 + 40) = v19;
    if (v20)
    {
      sub_10004D2C8(v20);
      if (buf.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
    }
  }
  if (!*(void *)(a1 + 40))
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v22 = CFDateCreate(0, Current + (double)a2);
    CFDateRef v27 = v22;
    CFDateRef v28 = v22;
    if (v22) {
      CFRetain(v22);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v25, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
    }
    else {
      std::string v25 = v29;
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v25;
    }
    uint64_t v30 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __p;
    }
    uint64_t v33 = 0;
    if (ctu::cf::convert_copy())
    {
      char v23 = v30;
      uint64_t v30 = v33;
      uint64_t v34 = v23;
      sub_1000558F4(&v34);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    long long v24 = v30;
    int v26 = v30;
    uint64_t v30 = 0;
    sub_1000558F4(&v30);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    (*(void (**)(uint64_t, CFDateRef *, const void *))(*(void *)v15 + 24))(v15, &v27, v24);
    sub_1000558F4(&v26);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    sub_10007CA64((const void **)&v27);
    sub_10007CA64((const void **)&v28);
  }
  if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_42;
  }
  operator delete(v29.__r_.__value_.__l.__data_);
  if (v16) {
    return;
  }
LABEL_43:
  sub_10004D2C8(v14);
}

void sub_100F86C18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10007CA64(&a17);
  sub_10007CA64(&a18);
  if (a24 < 0) {
    operator delete(a19);
  }
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  _Unwind_Resume(a1);
}

void *sub_100F86CD0(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 48);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_100F86D04(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 48);
  if (v1) {
    _Block_release(v1);
  }
}

void *sub_100F86D28(void *a1)
{
  sub_100F86DAC((unint64_t)a1);
  unint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::Timer::~Timer((ctu::Timer *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

uint64_t sub_100F86DAC(unint64_t a1)
{
  sub_100F863C8(a1);
  uint64_t result = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v3();
  }
  return result;
}

void sub_100F86E1C(void *a1)
{
  sub_100F86D28(a1);

  operator delete();
}

void sub_100F86E54(std::string *a1, unint64_t __val)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B12FD8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v7 = __val;
    int v6 = __cxa_guard_acquire(qword_101B12FD8);
    __val = v7;
    if (v6)
    {
      __cxa_atexit((void (*)(void *))&std::string::~string, aWakingtimer, (void *)&_mh_execute_header);
      __cxa_guard_release(qword_101B12FD8);
      __val = v7;
    }
  }
  std::to_string(&v8, __val);
  if (byte_101B0B847 >= 0) {
    uint64_t v3 = (const std::string::value_type *)aWakingtimer;
  }
  else {
    uint64_t v3 = (const std::string::value_type *)aWakingtimer[0];
  }
  if (byte_101B0B847 >= 0) {
    std::string::size_type v4 = byte_101B0B847;
  }
  else {
    std::string::size_type v4 = aWakingtimer[1];
  }
  std::string::size_type v5 = std::string::insert(&v8, 0, v3, v4);
  *a1 = *v5;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
}

void sub_100F86F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F86F58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 24))();
  }
  else {
    return 1;
  }
}

void sub_100F86F8C()
{
}

void sub_100F86FF8()
{
}

void *sub_100F8701C(void *a1, void *a2)
{
  std::string::size_type v4 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "wk.timer.srvc");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *a1 = off_101A76F18;
  a1[2] = *a2;
  uint64_t v5 = a2[1];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100F870F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  CTWakingTimerInterface::~CTWakingTimerInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100F87128(void *a1)
{
  *a1 = off_101A76F18;
  unint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  CTWakingTimerInterface::~CTWakingTimerInterface((CTWakingTimerInterface *)a1);
}

void sub_100F87190(void *a1)
{
  sub_100F87128(a1);

  operator delete();
}

void sub_100F871C8()
{
}

void sub_100F8722C()
{
}

void sub_100F878E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, int a15, int a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,void *aBlock,dispatch_object_t object,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100F87A9C()
{
}

uint64_t sub_100F87B04(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  Registry::getTimerService((uint64_t *)&v4, *(Registry **)(a1 + 16));
  unint64_t v2 = v4;
  if (v4) {
    uint64_t v1 = (**v4)(v4);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v2) {
    return v1;
  }
  else {
    return 0;
  }
}

void sub_100F87B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F87B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, void **a6)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  Registry::getTimerService(&v20, *(Registry **)(a1 + 16));
  uint64_t v12 = v20;
  if (v20)
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    uint64_t v13 = *a5;
    *a5 = 0;
    aBlock = *a6;
    dispatch_object_t object = v13;
    *a6 = 0;
    sub_10027A2C0(v12, (uint64_t)__p, a3, a4, &object, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v14 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Fail to schedule block. Missing timer service provider", v15, 2u);
    }
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_100F87CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F87D04(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, NSObject **a6@<X5>, void **a7@<X6>, void *a8@<X8>)
{
  *(void *)std::string buf = 0;
  long long v24 = 0;
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 16));
  uint64_t v16 = *(void *)buf;
  if (*(void *)buf)
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v22 = *(void *)(a2 + 16);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    uint64_t v17 = *a6;
    *a6 = 0;
    aBlock = *a7;
    dispatch_object_t object = v17;
    *a7 = 0;
    sub_100F86284((uint64_t)a8, v16, (uint64_t)__p, a3, a4, a5, &object, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (!v16)
  {
    std::string v18 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Fail to create one-shot timer. Missing timer service provider", buf, 2u);
    }
    *a8 = 0;
  }
}

void sub_100F87E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F87E94(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, NSObject **a6@<X5>, void **a7@<X6>, void *a8@<X8>)
{
  *(void *)std::string buf = 0;
  long long v24 = 0;
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 16));
  uint64_t v16 = *(void *)buf;
  if (*(void *)buf)
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v22 = *(void *)(a2 + 16);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    uint64_t v17 = *a6;
    *a6 = 0;
    aBlock = *a7;
    dispatch_object_t object = v17;
    *a7 = 0;
    sub_100F8674C((uint64_t)a8, v16, (uint64_t)__p, a3, a4, a5, &object, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (!v16)
  {
    std::string v18 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Fail to create periodic timer. Missing timer service provider", buf, 2u);
    }
    *a8 = 0;
  }
}

void sub_100F87FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F88024(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F8808C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F880C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F88100(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_100F88130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL *sub_100F88174@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    OsLogContext v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v6;
  pid_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&cf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v12 + 96))(&cf, v12, a2, 2, @"UseLTEAlternateBarMapping", kCFBooleanFalse, 0);
  uint64_t v14 = (BOOL *)cf;
  unsigned __int8 v18 = 0;
  if (cf)
  {
    CFTypeID v15 = CFGetTypeID(cf);
    if (v15 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v18, v14, v16);
      uint64_t v14 = (BOOL *)v18;
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  sub_1000577C4(&cf);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return v14;
}

void sub_100F882E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F88A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F88B74(os_log_t *a1, void *a2)
{
  if (a2)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v4 = [a2 countByEnumeratingWithState:&v11 objects:v17 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v12;
      do
      {
        for (signed int i = 0; i != v5; signed int i = (char *)i + 1)
        {
          if (*(void *)v12 != v6) {
            objc_enumerationMutation(a2);
          }
          uint64_t v8 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            id v9 = [*(id *)(*((void *)&v11 + 1) + 8 * i) UTF8String];
            *(_DWORD *)std::string buf = 136315138;
            id v16 = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I      %s", buf, 0xCu);
          }
        }
        id v5 = [a2 countByEnumeratingWithState:&v11 objects:v17 count:16];
      }
      while (v5);
    }
  }
  else
  {
    pid_t v10 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I      (no device uuids)", buf, 2u);
    }
  }
}

void sub_100F88D04(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 8) devices];
  uint64_t v3 = IDSCopyLocalDeviceUniqueID();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100F88DA0;
  block[3] = &unk_101A6B758;
  id v4 = *(NSObject **)(a1 + 40);
  block[4] = *(void *)(a1 + 32);
  block[5] = v3;
  void block[6] = v2;
  dispatch_async(v4, block);
}

void sub_100F88DA0(id *a1)
{
  uint64_t v3 = (os_log_t *)*((void *)a1[4] + 8);
  id v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = (const char *)[a1[5] UTF8String];
    uint64_t v6 = "unknown";
    if (v5) {
      uint64_t v6 = v5;
    }
    *(_DWORD *)std::string buf = 136315138;
    long long v24 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  Local IDS device ID is %s", buf, 0xCu);
    uint64_t v3 = (os_log_t *)*((void *)a1[4] + 8);
    id v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    OsLogContext v7 = (const char *)[a1[6] count];
    *(_DWORD *)std::string buf = 134217984;
    long long v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  Initial full set of registered devices: %lu devices", buf, 0xCu);
    uint64_t v3 = (os_log_t *)*((void *)a1[4] + 8);
  }
  sub_100F89054(v3, a1[6]);
  id v8 = (id)objc_opt_new();
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v9 = a1[6];
  id v10 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v19;
    do
    {
      for (signed int i = 0; i != v11; signed int i = (char *)i + 1)
      {
        if (*(void *)v19 != v12) {
          objc_enumerationMutation(v9);
        }
        long long v14 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        if (v14
          && [*(id *)(*((void *)&v18 + 1) + 8 * i) isLocallyPaired]
          && [v14 isConnected])
        {
          [v8 addObject:v14];
        }
      }
      id v11 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v11);
  }
  CFTypeID v15 = (os_log_t *)*((void *)a1[4] + 8);
  id v16 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = (const char *)[v8 count];
    *(_DWORD *)std::string buf = 134217984;
    long long v24 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I  Initial set of connected devices: %lu devices", buf, 0xCu);
    CFTypeID v15 = (os_log_t *)*((void *)a1[4] + 8);
  }
  sub_100F89054(v15, v8);
  [a1[4] setFConnectedDevices:v8];
  if ([v8 count]) {
    [a1[4] invokeDeviceChangedCallback:v8];
  }
}

void sub_100F89054(os_log_t *a1, void *a2)
{
  if (a2)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v4 = [a2 countByEnumeratingWithState:&v18 objects:v32 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v19;
      do
      {
        for (signed int i = 0; i != v5; signed int i = (char *)i + 1)
        {
          if (*(void *)v19 != v6) {
            objc_enumerationMutation(a2);
          }
          id v8 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            id v9 = *(void **)(*((void *)&v18 + 1) + 8 * i);
            id v10 = [v9 uniqueIDOverride];
            id v11 = (id)IDSCopyIDForDevice();
            uint64_t v12 = a1;
            long long v13 = a2;
            id v14 = [v9 name];
            id v15 = [v9 modelIdentifier];
            *(_DWORD *)std::string buf = 134219010;
            char v23 = v9;
            __int16 v24 = 2112;
            id v25 = v10;
            __int16 v26 = 2112;
            id v27 = v11;
            __int16 v28 = 2112;
            id v29 = v14;
            a2 = v13;
            a1 = v12;
            __int16 v30 = 2112;
            id v31 = v15;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I      (%p) - %@ %@ %@ (%@)", buf, 0x34u);
          }
        }
        id v5 = [a2 countByEnumeratingWithState:&v18 objects:v32 count:16];
      }
      while (v5);
    }
  }
  else
  {
    id v16 = *a1;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I      (no devices)", buf, 2u);
    }
  }
}

void sub_100F89510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_100F8998C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

void sub_100F899EC(void *a1)
{
  uint64_t v3 = a1[4];
  id v5 = *(unsigned __int8 **)(v3 + 88);
  id v4 = *(std::__shared_weak_count **)(v3 + 96);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = a1[4];
  }
  uint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  id v8 = *(std::__shared_weak_count **)(v3 + 96);
  *(void *)(v3 + 88) = v7;
  *(void *)(v3 + 96) = v6;
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = a1[5];
  if ((v5 != 0) != (v9 != 0)) {
    goto LABEL_52;
  }
  if (!v9) {
    goto LABEL_57;
  }
  uint64_t v10 = *(unsigned __int8 *)(v9 + 23);
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(v9 + 23);
  }
  else {
    uint64_t v11 = *(void *)(v9 + 8);
  }
  uint64_t v12 = v5[23];
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *((void *)v5 + 1);
  }
  if (v11 != v12) {
    goto LABEL_52;
  }
  if (v13 >= 0) {
    id v14 = v5;
  }
  else {
    id v14 = *(unsigned __int8 **)v5;
  }
  if ((v10 & 0x80) != 0)
  {
    if (memcmp(*(const void **)v9, v14, *(void *)(v9 + 8))) {
      goto LABEL_52;
    }
  }
  else if (*(unsigned char *)(v9 + 23))
  {
    id v15 = (unsigned __int8 *)a1[5];
    while (*v15 == *v14)
    {
      ++v15;
      ++v14;
      if (!--v10) {
        goto LABEL_25;
      }
    }
    goto LABEL_52;
  }
LABEL_25:
  if (*(_DWORD *)(v9 + 24) == *((_DWORD *)v5 + 6))
  {
    uint64_t v16 = *(unsigned __int8 *)(v9 + 55);
    if ((v16 & 0x80u) == 0) {
      uint64_t v17 = *(unsigned __int8 *)(v9 + 55);
    }
    else {
      uint64_t v17 = *(void *)(v9 + 40);
    }
    uint64_t v18 = v5[55];
    int v19 = (char)v18;
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *((void *)v5 + 5);
    }
    if (v17 == v18)
    {
      long long v20 = (const void **)(v9 + 32);
      if (v19 >= 0) {
        long long v21 = v5 + 32;
      }
      else {
        long long v21 = (unsigned __int8 *)*((void *)v5 + 4);
      }
      if ((v16 & 0x80) == 0)
      {
        if (*(unsigned char *)(v9 + 55))
        {
          while (*(unsigned __int8 *)v20 == *v21)
          {
            long long v20 = (const void **)((char *)v20 + 1);
            ++v21;
            if (!--v16) {
              goto LABEL_41;
            }
          }
          goto LABEL_52;
        }
LABEL_41:
        uint64_t v22 = *(const void **)(v9 + 64);
        if (v22) {
          char v23 = sub_100080778;
        }
        else {
          char v23 = 0;
        }
        __int16 v24 = (const void *)*((void *)v5 + 8);
        if (v24) {
          id v25 = sub_100080778;
        }
        else {
          id v25 = 0;
        }
        if ((v23 == 0) != (v25 != 0)
          && (!v23 || CFEqual(v22, v24))
          && *(unsigned __int8 *)(v9 + 56) == v5[56]
          && *(_DWORD *)(v9 + 72) == *((_DWORD *)v5 + 18))
        {
          goto LABEL_57;
        }
        goto LABEL_52;
      }
      if (!memcmp(*v20, v21, *(void *)(v9 + 40))) {
        goto LABEL_41;
      }
    }
  }
LABEL_52:
  uint64_t v26 = *(void *)(a1[4] + 32);
  if (v26)
  {
    id v27 = (std::__shared_weak_count *)a1[6];
    uint64_t v28 = a1[5];
    id v29 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(v26 + 16))(v26, &v28);
    if (v29) {
      sub_10004D2C8(v29);
    }
  }
LABEL_57:
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100F89C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F89C88(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F89CA4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100F89E00(void *a1)
{
  uint64_t v3 = *(void *)(a1[4] + 24);
  if (v3) {
    (*(void (**)(uint64_t, void, void, void))(v3 + 16))(v3, a1[5], a1[6], a1[7]);
  }
}

const void **sub_100F89E5C(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 5, a2 + 5);
  sub_100083DA4(a1 + 6, a2 + 6);

  return sub_1000584C8(a1 + 7, a2 + 7);
}

const void **sub_100F89EB0(const void **a1)
{
  uint64_t v1 = a1 + 5;
  uint64_t v2 = a1 + 6;
  sub_1000577C4(a1 + 7);
  sub_1000558F4(v2);

  return sub_1000558F4(v1);
}

void sub_100F8A084(uint64_t a1)
{
  char v20 = 1;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4
    && ((*(void (**)(uint64_t, void, void, void, void, char *))(v4 + 16))(v4, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), &v20), uint64_t v3 = *(void *)(a1 + 32), !v20))
  {
    uint64_t v12 = **(NSObject ***)(v3 + 64);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = objc_msgSend(objc_msgSend(*(id *)(a1 + 64), "description"), "UTF8String");
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I ownership on %s delegated to IDSTransactionManager", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    [(id)v3 fTopic];
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string v16 = buf;
    id v5 = std::string::insert(&v16, 0, "IDSP2PSync: ", 0xCuLL);
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v17.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    uint64_t v7 = std::string::append(&v17, " filemanager queue", 0x12uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    int64_t v19 = v7->__r_.__value_.__r.__words[2];
    long long v18 = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    if (v19 >= 0) {
      uint64_t v9 = (const char *)&v18;
    }
    else {
      uint64_t v9 = (const char *)v18;
    }
    uint64_t v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
    uint64_t v11 = dispatch_queue_create(v9, v10);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3321888768;
    void v14[2] = sub_100F8A33C;
    v14[3] = &unk_101A770F8;
    sub_100119B5C(&v15, (const void **)(a1 + 64));
    void v14[4] = *(void *)(a1 + 32);
    dispatch_async(v11, v14);
    sub_1000FE824(&v15);
    if (v11) {
      dispatch_release(v11);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete((void *)v18);
    }
  }
}

void sub_100F8A2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8A33C(uint64_t a1)
{
  id v11 = 0;
  unsigned __int8 v2 = [+[NSFileManager defaultManager] removeItemAtURL:*(void *)(a1 + 40) error:&v11];
  uint64_t v3 = **(NSObject ***)(*(void *)(a1 + 32) + 64);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      return;
    }
    id v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "description"), "UTF8String");
    *(_DWORD *)std::string buf = 136315138;
    id v13 = v5;
    long long v6 = "#I removed %s";
    uint64_t v7 = v3;
    uint32_t v8 = 12;
  }
  else
  {
    if (!v4) {
      return;
    }
    id v9 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "description"), "UTF8String");
    id v10 = objc_msgSend(objc_msgSend(v11, "description"), "UTF8String");
    *(_DWORD *)std::string buf = 136315394;
    id v13 = v9;
    __int16 v14 = 2080;
    id v15 = v10;
    long long v6 = "#I Failed to delete resource %s, err %s";
    uint64_t v7 = v3;
    uint32_t v8 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
}

const void **sub_100F8A478(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 5, a2 + 5);
  sub_100083DA4(a1 + 6, a2 + 6);
  sub_1000584C8(a1 + 7, a2 + 7);

  return sub_100119B5C(a1 + 8, a2 + 8);
}

const void **sub_100F8A4D8(const void **a1)
{
  uint64_t v1 = a1 + 5;
  unsigned __int8 v2 = a1 + 6;
  uint64_t v3 = a1 + 7;
  sub_1000FE824(a1 + 8);
  sub_1000577C4(v3);
  sub_1000558F4(v2);

  return sub_1000558F4(v1);
}

void sub_100F8A644(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v3 + 112);
  uint64_t v4 = v3 + 112;
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_8;
  }
  uint64_t v7 = v4;
  do
  {
    CFComparisonResult v8 = CFStringCompare(*(CFStringRef *)(v5 + 32), *(CFStringRef *)(a1 + 40), 0);
    id v9 = (uint64_t *)(v5 + 8);
    if (v8 != kCFCompareLessThan)
    {
      id v9 = (uint64_t *)v5;
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v7 == v4 || CFStringCompare(*(CFStringRef *)(a1 + 40), *(CFStringRef *)(v7 + 32), 0) == kCFCompareLessThan) {
LABEL_8:
  }
    uint64_t v7 = v4;
  uint64_t v10 = *(void *)(a1 + 32);
  if (v7 == v10 + 112)
  {
    id v15 = **(NSObject ***)(v10 + 64);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      id v16 = [*(id *)(a1 + 40) UTF8String];
      int v22 = 136315138;
      id v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Ack block missing for identifier %s", (uint8_t *)&v22, 0xCu);
    }
  }
  else
  {
    uint64_t v11 = *(void *)(v7 + 40);
    if (v11)
    {
      uint64_t v12 = *(void *)(a1 + 40);
      if (*(void *)(a1 + 48)) {
        id v13 = sub_10039195C;
      }
      else {
        id v13 = 0;
      }
      if (v13)
      {
        CFIndex Code = CFErrorGetCode(*(CFErrorRef *)(a1 + 48));
        uint64_t v11 = *(void *)(v7 + 40);
      }
      else
      {
        CFIndex Code = 0;
      }
      (*(void (**)(uint64_t, uint64_t, void, CFIndex))(v11 + 16))(v11, v12, *(unsigned __int8 *)(a1 + 56), Code);
      uint64_t v10 = *(void *)(a1 + 32);
    }
    std::string v17 = *(void **)(v7 + 8);
    if (v17)
    {
      do
      {
        long long v18 = v17;
        std::string v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      int64_t v19 = (void *)v7;
      do
      {
        long long v18 = (void *)v19[2];
        BOOL v20 = *v18 == (void)v19;
        int64_t v19 = v18;
      }
      while (!v20);
    }
    if (*(void *)(v10 + 104) == v7) {
      *(void *)(v10 + 104) = v18;
    }
    long long v21 = *(uint64_t **)(v10 + 112);
    --*(void *)(v10 + 120);
    sub_10005EE6C(v21, (uint64_t *)v7);
    sub_100F8F978(v7 + 32);
    operator delete((void *)v7);
  }
}

CFTypeRef sub_100F8A840(uint64_t a1, uint64_t a2)
{
  sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));
  CFTypeRef result = *(CFTypeRef *)(a2 + 48);
  *(void *)(a1 + 48) = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

const void **sub_100F8A884(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 40);
  sub_100127D74((const void **)(a1 + 48));

  return sub_1000558F4(v1);
}

void sub_100F8A930(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 32);
  uint64_t v4 = *v3[8];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  Watch pairing complete", v5, 2u);
    uint64_t v3 = *(void ***)(a1 + 32);
  }
  objc_msgSend(v3, "invokeDeviceChangedCallback:", objc_msgSend(v3, "fConnectedDevices"));
}

void sub_100F8ABF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_100F8ACF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100F8B1FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8B258(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 32) + 64);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  INVITE delivery failed", (uint8_t *)&v9, 2u);
    }
  }
  objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fInvitedDevices"), "removeObject:", *(void *)(a1 + 40));
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = (os_log_t *)v5[8];
  uint64_t v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = objc_msgSend(objc_msgSend(v5, "fInvitedDevices"), "count");
    int v9 = 134217984;
    id v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I  Set of InvitedDevices become: %lu devices", (uint8_t *)&v9, 0xCu);
    uint64_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = (os_log_t *)v5[8];
  }
  sub_100F88B74(v6, [v5 fInvitedDevices]);
}

const void **sub_100F8B384(uint64_t a1, uint64_t a2)
{
  return sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));
}

const void **sub_100F8B390(uint64_t a1)
{
  return sub_1000558F4((const void **)(a1 + 40));
}

uint64_t sub_100F8B398(uint64_t **a1, CFStringRef *a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = a1[1];
  if (!v4)
  {
    uint64_t v6 = (uint64_t *)(a1 + 1);
LABEL_9:
    id v8 = operator new(0x30uLL);
    _DWORD v8[2] = *(_OWORD *)a2;
    *(_OWORD *)a2 = 0u;
    _OWORD *v8 = 0u;
    *((void *)v8 + 2) = v6;
    *uint64_t v5 = (uint64_t *)v8;
    int v9 = (uint64_t *)**a1;
    if (v9)
    {
      *a1 = v9;
      id v10 = *v5;
    }
    else
    {
      id v10 = (uint64_t *)v8;
    }
    uint64_t result = (uint64_t)sub_100046C90(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return result;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v6 = v4;
      if (CFStringCompare(*a2, (CFStringRef)v4[4], 0) != kCFCompareLessThan) {
        break;
      }
      uint64_t v4 = (uint64_t *)*v6;
      uint64_t v5 = (uint64_t **)v6;
      if (!*v6) {
        goto LABEL_9;
      }
    }
    uint64_t result = CFStringCompare((CFStringRef)v6[4], *a2, 0);
    if (result != -1) {
      break;
    }
    uint64_t v5 = (uint64_t **)(v6 + 1);
    uint64_t v4 = (uint64_t *)v6[1];
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!*v5) {
    goto LABEL_9;
  }
  return result;
}

const void **sub_100F8B488(uint64_t a1)
{
  unsigned __int8 v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }

  return sub_1000558F4((const void **)a1);
}

void sub_100F8B91C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8B980(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = **(NSObject ***)(v4 + 64);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I  INTRO delivery failed", v6, 2u);
      uint64_t v4 = *(void *)(a1 + 32);
    }
    *(unsigned char *)(v4 + 128) = 1;
  }
}

void sub_100F8BACC(uint64_t a1)
{
  uint64_t v3 = *(unsigned char **)(a1 + 32);
  if (v3[129])
  {
    [v3 whitelistDevice:*(void *)(a1 + 40) with:&__NSDictionary0__struct];
    objc_msgSend(*(id *)(a1 + 32), "invokeDeviceChangedCallback:", objc_msgSend(*(id *)(a1 + 32), "fConnectedDevices"));
    uint64_t v3 = *(unsigned char **)(a1 + 32);
  }
  v3[128] = 1;
  [*(id *)(a1 + 32) introduceMyselfIfNeeded:*(void *)(a1 + 48)];
}

void sub_100F8BC60(uint64_t a1)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"capable");
  if (Value && (CFBooleanRef v4 = Value, v5 = CFGetTypeID(Value), v5 == CFBooleanGetTypeID()))
  {
    if (CFBooleanGetValue(v4))
    {
      uint64_t v6 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"devinfo");
      if (v6)
      {
        uint64_t v7 = v6;
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 == CFDictionaryGetTypeID()) {
          int v9 = v7;
        }
        else {
          int v9 = 0;
        }
      }
      else
      {
        int v9 = 0;
      }
      [*(id *)(a1 + 32) whitelistDevice:*(void *)(a1 + 48) with:v9];
      objc_msgSend(*(id *)(a1 + 32), "invokeDeviceChangedCallback:", objc_msgSend(*(id *)(a1 + 32), "fConnectedDevices"));
    }
    else
    {
      [*(id *)(a1 + 32) blacklistDevice:*(void *)(a1 + 48)];
    }
  }
  else
  {
    id v10 = **(NSObject ***)(*(void *)(a1 + 32) + 64);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [*(id *)(a1 + 48) UTF8String];
      int v12 = 136315394;
      id v13 = v11;
      __int16 v14 = 2080;
      id v15 = [@"capable" UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I  INTRO from %s doesnt have '%s' field", (uint8_t *)&v12, 0x16u);
    }
  }
}

const void **sub_100F8BDE4(uint64_t a1, uint64_t a2)
{
  sub_100058198((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100083DA4((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_100F8BE2C(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 40);
  sub_1000558F4((const void **)(a1 + 48));

  return sub_100057D78(v1);
}

id sub_100F8C1D4(os_log_t *a1, void *a2)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id result = [a2 countByEnumeratingWithState:&v10 objects:v16 count:16];
  if (result)
  {
    id v5 = result;
    uint64_t v6 = *(void *)v11;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(a2);
        }
        CFTypeID v8 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          id v9 = [*(id *)(*((void *)&v10 + 1) + 8 * (void)v7) UTF8String];
          *(_DWORD *)std::string buf = 136315138;
          id v15 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I      %s", buf, 0xCu);
        }
        uint64_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id result = [a2 countByEnumeratingWithState:&v10 objects:v16 count:16];
      id v5 = result;
    }
    while (result);
  }
  return result;
}

id sub_100F8CB04(os_log_t *a1, void *a2)
{
  id v4 = +[NSMutableSet set];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v5 = (char *)[a2 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      CFTypeID v8 = 0;
      do
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(a2);
        }
        id v9 = (id)IDSCopyIDForDevice();
        if (v9)
        {
          [v4 addObject:v9];
        }
        else
        {
          long long v10 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            v12[0] = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I  IDSCopyForDevice returned nil in sCreateDestinationSet", (uint8_t *)v12, 2u);
          }
        }
        ++v8;
      }
      while (v6 != v8);
      uint64_t v6 = (char *)[a2 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v6);
  }
  return v4;
}

void sub_100F8D098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8D300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8D3CC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) count];
  id v4 = *(os_log_t **)(*(void *)(a1 + 40) + 64);
  id v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    id v44 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I  Set of registered devices changed: %lu device(s)", buf, 0xCu);
    id v4 = *(os_log_t **)(*(void *)(a1 + 40) + 64);
  }
  sub_100F89054(v4, *(void **)(a1 + 32));
  id v6 = [*(id *)(a1 + 40) fBlacklistedDeviceUuids];
  uint64_t v7 = *(unsigned char **)(a1 + 40);
  if (v6)
  {
    id v8 = sub_100F8D8A8([v7 fBlacklistedDeviceUuids], *(void **)(a1 + 32));
    id v9 = [v8 count] ? v8 : 0;
    [*(id *)(a1 + 40) setFBlacklistedDeviceUuids:v9];
    uint64_t v7 = *(unsigned char **)(a1 + 40);
    if (v7[130])
    {
      DevicePersistentSaveValue((const __CFString *)[v7 fBlacklistedDeviceUuidsKey], objc_msgSend(*(id *)(a1 + 40), "fBlacklistedDeviceUuids"));
      uint64_t v7 = *(unsigned char **)(a1 + 40);
    }
  }
  __int16 v37 = 0;
  DevicePersistentCopyValue((uint64_t *)buf, (const __CFString *)[v7 fWhitelistedDevicesKey], 0);
  sub_10004EFE4(&v37, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v37) {
    long long v10 = sub_100080778;
  }
  else {
    long long v10 = 0;
  }
  if (v10)
  {
    objc_msgSend(*(id *)(a1 + 40), "setFWhitelistedDeviceUuids:", objc_msgSend(sub_100F8D8A8(objc_msgSend(*(id *)(a1 + 40), "fWhitelistedDeviceUuids"), *(void **)(a1 + 32)), "mutableCopy"));
    id v11 = v37;
    long long v12 = *(void **)(a1 + 32);
    id v13 = (id)objc_opt_new();
    id v14 = [v11 keyEnumerator];
    for (id i = [v14 nextObject]; ; id i = objc_msgSend(v14, "nextObject"))
    {
      id v16 = i;
      if (!i) {
        break;
      }
      if ((sub_100F8F5AC(i, v12) & 1) == 0) {
        [v13 addObject:v16];
      }
    }
    if ([v13 count])
    {
      id v11 = [v11 mutableCopy];
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      id v17 = [v13 countByEnumeratingWithState:&v38 objects:buf count:16];
      if (v17)
      {
        uint64_t v18 = *(void *)v39;
        do
        {
          for (j = 0; j != v17; j = (char *)j + 1)
          {
            if (*(void *)v39 != v18) {
              objc_enumerationMutation(v13);
            }
            [v11 removeObjectForKey:*(void *)(*((void *)&v38 + 1) + 8 * (void)j)];
          }
          id v17 = [v13 countByEnumeratingWithState:&v38 objects:buf count:16];
        }
        while (v17);
      }
    }
    CFStringRef v20 = (const __CFString *)[*(id *)(a1 + 40) fWhitelistedDevicesKey];
    if ([v11 count]) {
      long long v21 = v11;
    }
    else {
      long long v21 = 0;
    }
    DevicePersistentSaveValue(v20, v21);
  }
  if ([*(id *)(a1 + 40) fInvitedDevices])
  {
    id v22 = sub_100F8D8A8([*(id *)(a1 + 40) fInvitedDevices], *(void **)(a1 + 32));
    if ([v22 count]) {
      id v23 = [v22 mutableCopy];
    }
    else {
      id v23 = 0;
    }
    [*(id *)(a1 + 40) setFInvitedDevices:v23];
  }
  id v24 = (id)objc_opt_new();
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v25 = *(void **)(a1 + 32);
  id v26 = [v25 countByEnumeratingWithState:&v33 objects:v42 count:16];
  if (v26)
  {
    uint64_t v27 = *(void *)v34;
    do
    {
      for (k = 0; k != v26; k = (char *)k + 1)
      {
        if (*(void *)v34 != v27) {
          objc_enumerationMutation(v25);
        }
        id v29 = *(void **)(*((void *)&v33 + 1) + 8 * (void)k);
        if (v29
          && [*(id *)(*((void *)&v33 + 1) + 8 * (void)k) isLocallyPaired]
          && [v29 isConnected])
        {
          [v24 addObject:v29];
        }
      }
      id v26 = [v25 countByEnumeratingWithState:&v33 objects:v42 count:16];
    }
    while (v26);
  }
  __int16 v30 = *(os_log_t **)(*(void *)(a1 + 40) + 64);
  id v31 = *v30;
  if (os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT))
  {
    id v32 = [v24 count];
    *(_DWORD *)std::string buf = 134217984;
    id v44 = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I  Set of connected devices changed (devicesChanged): %lu device(s)", buf, 0xCu);
    __int16 v30 = *(os_log_t **)(*(void *)(a1 + 40) + 64);
  }
  sub_100F89054(v30, v24);
  [*(id *)(a1 + 40) setFConnectedDevices:v24];
  [*(id *)(a1 + 40) invokeDeviceChangedCallback:v24];

  sub_100057D78((const void **)&v37);
}

void sub_100F8D854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100F8D8A8(id a1, void *a2)
{
  id v4 = (id)objc_opt_new();
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v5 = [a1 countByEnumeratingWithState:&v19 objects:v24 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v20;
    do
    {
      for (id i = 0; i != v6; id i = (char *)i + 1)
      {
        if (*(void *)v20 != v7) {
          objc_enumerationMutation(a1);
        }
        id v9 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        if ((sub_100F8F5AC(v9, a2) & 1) == 0) {
          [v4 addObject:v9];
        }
      }
      id v6 = [a1 countByEnumeratingWithState:&v19 objects:v24 count:16];
    }
    while (v6);
  }
  if ([v4 count])
  {
    a1 = [a1 mutableCopy];
    long long v15 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v10 = [v4 countByEnumeratingWithState:&v15 objects:v23 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v16;
      do
      {
        for (j = 0; j != v11; j = (char *)j + 1)
        {
          if (*(void *)v16 != v12) {
            objc_enumerationMutation(v4);
          }
          [a1 removeObject:*(void *)(*((void *)&v15 + 1) + 8 * (void)j)];
        }
        id v11 = [v4 countByEnumeratingWithState:&v15 objects:v23 count:16];
      }
      while (v11);
    }
  }
  return a1;
}

void sub_100F8DADC(uint64_t a1)
{
  id v3 = *(void **)(a1 + 40);
  if (v3)
  {
    id v4 = [v3 uniqueIDOverride];
    id v5 = [*(id *)(a1 + 40) modelIdentifier];
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = **(NSObject ***)(v6 + 64);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      *(_DWORD *)std::string buf = 138412546;
      *(void *)&uint8_t buf[4] = v4;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I  Active device changed: %@, %@", buf, 0x16u);
      uint64_t v6 = *(void *)(a1 + 48);
    }
    if (v4 && v5)
    {
      if (*(void *)(v6 + 40)
        && capabilities::ct::supportsP2PAsPhone((capabilities::ct *)v8)
        && [+[NRPairedDeviceRegistry sharedInstance] deviceForIDSDevice:*(void *)(a1 + 40)])
      {
        id v9 = (char *)operator new(0x68uLL);
        *((void *)v9 + 1) = 0;
        *((void *)v9 + 2) = 0;
        *(void *)id v9 = off_101A77390;
        *(_OWORD *)(v9 + 24) = 0u;
        id v10 = (void **)(v9 + 24);
        *(_OWORD *)(v9 + 40) = 0u;
        *(_OWORD *)(v9 + 56) = 0u;
        *(_OWORD *)(v9 + 72) = 0u;
        *(_OWORD *)(v9 + 88) = 0u;
        *((_DWORD *)v9 + 12) = NRWatchOSVersionForRemoteDevice();
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        uint64_t v11 = *(void *)buf;
        *(void *)long long v18 = *(void *)&buf[8];
        *(void *)&v18[7] = *(void *)&buf[15];
        uint8_t v12 = buf[23];
        if (v9[47] < 0) {
          operator delete(*v10);
        }
        *((void *)v9 + 3) = v11;
        *((void *)v9 + 4) = *(void *)v18;
        *(void *)(v9 + 39) = *(void *)&v18[7];
        v9[47] = v12;
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        uint64_t v13 = *(void *)buf;
        *(void *)&long long v17 = *(void *)&buf[8];
        *(void *)((char *)&v17 + 7) = *(void *)&buf[15];
        uint8_t v14 = buf[23];
        if (v9[79] < 0) {
          operator delete(*((void **)v9 + 7));
        }
        *((void *)v9 + 7) = v13;
        *((void *)v9 + 8) = v17;
        *(void *)(v9 + 71) = *(void *)((char *)&v17 + 7);
        v9[79] = v14;
        v9[80] = objc_msgSend(*(id *)(a1 + 40), "isConnected", v17);
        sub_100F8DDB8(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)v10, (std::__shared_weak_count *)v9);
        sub_10004D2C8((std::__shared_weak_count *)v9);
      }
    }
    else
    {
      long long v15 = **(NSObject ***)(v6 + 64);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 40);
        *(_DWORD *)std::string buf = 138412290;
        *(void *)&uint8_t buf[4] = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I ignored activePairedDevice because of incomplete descripton: %@", buf, 0xCu);
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100F8DD80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100F8DDB8(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  uint64_t v3 = a2;
  id v4 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(a1 + 16))(a1, &v3);
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100F8DE0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F8DE94(uint64_t a1)
{
  id v3 = [+[NRPairedDeviceRegistry sharedInstance] getActivePairedDevice];
  if (v3)
  {
    id v4 = -[NRPairedDeviceRegistry deviceForNRDevice:fromIDSDevices:](+[NRPairedDeviceRegistry sharedInstance](NRPairedDeviceRegistry, "sharedInstance"), "deviceForNRDevice:fromIDSDevices:", v3, [*(id *)(*(void *)(a1 + 32) + 8) devices]);
    if (v4)
    {
      id v5 = v4;
      id v6 = [v4 modelIdentifier];
      id v7 = [v5 uniqueIDOverride];
      if (v6) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      if (!v8) {
        operator new();
      }
      id v9 = **(NSObject ***)(*(void *)(a1 + 32) + 64);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int buf = 138412290;
        *(void *)buf_4 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ignored active device on start because of incomplete descripton: %@", (uint8_t *)&buf, 0xCu);
      }
    }
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 40);
  if (v10) {
    sub_100F8DDB8(v10, 0, 0);
  }
}

void sub_100F8E130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100F8E2AC(uint64_t a1)
{
  [*(id *)(a1 + 32) setFConnectedDevices:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) invokeDeviceChangedCallback:*(void *)(a1 + 40)];
}

void sub_100F8E79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10012C330((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F8EBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_100F8EDC4(uint64_t a1)
{
  *(void *)a1 = off_101A77278;

  sub_100057D78((const void **)(a1 + 48));
  sub_1000558F4((const void **)(a1 + 32));
  unsigned __int8 v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F8EE30(uint64_t a1)
{
  sub_100F8EDC4(a1);

  operator delete();
}

id sub_100F8EE68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint8_t v12 = [IDSP2PDelegate alloc];
  uint64_t v14 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(a1 + 32);
  long long v15 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v20 = *(void *)(a1 + 8);
  long long v21 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  LOBYTE(v19) = *(unsigned char *)(a1 + 56);
  uint64_t v16 = [(IDSP2PDelegate *)v12 initWithServiceName:v13 logPrefix:v14 onDeviceState:a3 onActiveDeviceChange:a4 onMessage:a5 onURL:a6 queue:a2 registry:&v20 capable:v19];
  *(void *)(a1 + 40) = v16;
  if (v21)
  {
    sub_10004D2C8(v21);
    uint64_t v16 = *(IDSP2PDelegate **)(a1 + 40);
  }
  if (*(void *)(a1 + 48)) {
    long long v17 = sub_100080778;
  }
  else {
    long long v17 = 0;
  }
  if (v17)
  {
    -[IDSP2PDelegate setIntroductionInfo:](v16, "setIntroductionInfo:");
    uint64_t v16 = *(IDSP2PDelegate **)(a1 + 40);
  }
  return [(IDSP2PDelegate *)v16 postActiveDeviceIdOnStart];
}

void sub_100F8EF44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F8EF5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, 0, a2, a3, a4, a5);
}

uint64_t sub_100F8EF94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t sub_100F8EFD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 88))(a1, 0, a2, a3, a4);
}

uint64_t sub_100F8F004(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t sub_100F8F040(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 104))(a1, 0, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_100F8F080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112))(a1, 0, a2, a3, a4, a5);
}

id sub_100F8F0B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  id result = *(id *)(a1 + 40);
  if (result) {
    return [result sendMessage:a4 withName:a3 withOptions:a5 withAck:a6 toDevice:a2];
  }
  *a7 = 0;
  return result;
}

const void **sub_100F8F0DC(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v15 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v19 = v15;
    sub_10005717C((const void **)&v19);
  }
  if (a5) {
    CFDictionaryAddValue(theDict, IDSSendMessageOptionQueueOneIdentifierKey, a3);
  }
  uint64_t v16 = (const void **)&kCFBooleanFalse;
  if (!a6) {
    uint64_t v16 = (const void **)&kCFBooleanTrue;
  }
  CFDictionaryAddValue(theDict, IDSSendMessageOptionNonWakingKey, *v16);
  (*(void (**)(uint64_t, uint64_t, const void *, uint64_t, CFMutableDictionaryRef, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, a4, theDict, a7);
  return sub_10005717C((const void **)&theDict);
}

void sub_100F8F208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100F8F21C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, a4, 0, a5);
}

id sub_100F8F248@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  id result = *(id *)(a1 + 40);
  if (result) {
    return [result sendFile:a4 withMessage:a5 withName:a3 withOptions:a6 withAck:a7 toDevice:a2];
  }
  *a8 = 0;
  return result;
}

const void **sub_100F8F270(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8)
{
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v17 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v21 = v17;
    sub_10005717C((const void **)&v21);
  }
  if (a6) {
    CFDictionaryAddValue(theDict, IDSSendMessageOptionQueueOneIdentifierKey, a3);
  }
  long long v18 = (const void **)&kCFBooleanFalse;
  if (!a7) {
    long long v18 = (const void **)&kCFBooleanTrue;
  }
  CFDictionaryAddValue(theDict, IDSSendMessageOptionNonWakingKey, *v18);
  (*(void (**)(uint64_t, uint64_t, const void *, uint64_t, uint64_t, CFMutableDictionaryRef, uint64_t))(*(void *)a1 + 96))(a1, a2, a3, a4, a5, theDict, a8);
  return sub_10005717C((const void **)&theDict);
}

void sub_100F8F3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100F8F3C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 96))(a1, a2, a3, a4, a5, 0, a6);
}

id sub_100F8F3EC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  id result = *(id *)(a1 + 40);
  if (result) {
    return [result getDeviceInProximity];
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

id sub_100F8F400@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  id result = *(id *)(a1 + 40);
  if (result) {
    return [result getAllRegisteredDevicesUuids];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

id sub_100F8F418(uint64_t a1, const void *a2)
{
  CFTypeRef v5 = a2;
  id v3 = (void *)(a1 + 48);
  sub_100282490((const void **)(a1 + 48), &v5);
  id result = *(id *)(a1 + 40);
  if (result) {
    return [result setIntroductionInfo:*v3];
  }
  return result;
}

uint64_t sub_100F8F464(uint64_t *a1, char **a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1000D8578();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  CFMutableDictionaryRef v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10004812C(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[24 * v4];
  CFMutableDictionaryRef v15 = v14;
  uint64_t v16 = &v10[24 * v9];
  sub_100058DB0(v14, *a2);
  CFMutableDictionaryRef v15 = v14 + 24;
  sub_100048204(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100048174((uint64_t)&v13);
  return v11;
}

void sub_100F8F558(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F8F56C(uint64_t a1, const void **a2, void **a3)
{
  sub_100083DA4((const void **)a1, a2);
  unint64_t v5 = *a3;
  if (*a3) {
    unint64_t v5 = _Block_copy(v5);
  }
  *(void *)(a1 + 8) = v5;
  return a1;
}

uint64_t sub_100F8F5AC(void *a1, void *a2)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t result = (uint64_t)[a2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)v9;
    while (2)
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(a2);
        }
        if (objc_msgSend(a1, "isEqualToString:", objc_msgSend(*(id *)(*((void *)&v8 + 1) + 8 * v7), "uniqueIDOverride")))return 1; {
        ++v7;
        }
      }
      while (v5 != v7);
      uint64_t result = (uint64_t)[a2 countByEnumeratingWithState:&v8 objects:v12 count:16];
      uint64_t v5 = result;
      if (result) {
        continue;
      }
      break;
    }
  }
  return result;
}

void *sub_100F8F6AC@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, CFTypeRef *a4@<X4>, void *a5@<X8>)
{
  long long v10 = operator new(0x58uLL);
  uint64_t result = sub_100F8F728(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_100F8F714(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100F8F728(void *a1, char *a2, uint64_t *a3, uint64_t *a4, CFTypeRef *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A77340;
  sub_100F8F82C((uint64_t)(a1 + 3), *a2, a3, *a4, *a5);
  return a1;
}

void sub_100F8F77C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100F8F790(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A77340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F8F7B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A77340;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F8F804(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100F8F82C(uint64_t a1, char a2, uint64_t *a3, uint64_t a4, CFTypeRef cf)
{
  uint64_t v8 = *a3;
  uint64_t v7 = a3[1];
  *(void *)a1 = off_101A77278;
  *(void *)(a1 + 8) = v8;
  *(void *)(a1 + 16) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 24) = a4;
  sub_100056210((void *)(a1 + 32), cf);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = a2;
  return a1;
}

void sub_100F8F8A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A77390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F8F8C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A77390;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F8F914(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 88));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    unsigned __int8 v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

const void **sub_100F8F978(uint64_t a1)
{
  unsigned __int8 v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }

  return sub_1000558F4((const void **)a1);
}

void sub_100F8F9C0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F8F9F8(uint64_t a1)
{
  return sub_100F8FA44(*(void *)(a1 + 24));
}

uint64_t sub_100F8FA00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F8FA44(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_100057D78((const void **)(result + 64));
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

void sub_100F8FABC()
{
}

void *sub_100F8FAD0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A77458;
  result[1] = v3;
  return result;
}

uint64_t sub_100F8FB18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A77458;
  a2[1] = v2;
  return result;
}

void sub_100F8FB44(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = **(NSObject ***)(**(void **)(a1 + 8) + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      unint64_t v4 = a2;
    }
    else {
      unint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100F8FBFC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A774B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F8FC3C()
{
  return &off_101A774B8;
}

void sub_100F8FC48(void *a1)
{
  if (a1)
  {
    sub_100F8FC48(*a1);
    sub_100F8FC48(a1[1]);
    sub_100F8F978((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t sub_100F8FC9C(uint64_t a1, void *a2, uint64_t a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  sub_1012305BC((std::string *)(a1 + 40));
  uint64_t v6 = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)a3;
  *(void *)(a1 + 80) = v6;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 120) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100F8FD68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v12 + 4);
  if (v14) {
    sub_10004D2C8(v14);
  }
  CFMutableDictionaryRef v15 = (std::__shared_weak_count *)*((void *)v12 + 2);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  ctu::OsLogLogger::~OsLogLogger(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_100F8FDB4(uint64_t a1, void *a2, uint64_t *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &v8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  sub_101230220(a3, (std::string *)(a1 + 40));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  sub_1004081A4((void *)(a1 + 88), (const void *)*a3, a3[1], (a3[1] - *a3) >> 4);
  *(void *)(a1 + 112) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 120) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100F8FE90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  if (*(char *)(v12 + 63) < 0) {
    operator delete(*v13);
  }
  CFMutableDictionaryRef v15 = *(std::__shared_weak_count **)(v12 + 32);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v12 + 16);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  _Unwind_Resume(a1);
}

void sub_100F8FEF4(ctu::OsLogLogger *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 11);
  if (v3)
  {
    *((void *)this + 12) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

BOOL sub_100F8FF6C(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 24);
  if (!v2)
  {
    unint64_t v4 = *(NSObject **)a1;
    BOOL result = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_100F900D8(a1, __p);
    if (v10 >= 0) {
      int v5 = __p;
    }
    else {
      int v5 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v12 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s Invalid region pointer...", buf, 0xCu);
    goto LABEL_14;
  }
  if (*v2 > 1u) {
    return 1;
  }
  uint64_t v6 = *(NSObject **)a1;
  BOOL v7 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v7)
  {
    sub_100F900D8(a1, __p);
    if (v10 >= 0) {
      OsLogContext v8 = __p;
    }
    else {
      OsLogContext v8 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %{public}s <-- Waiting for results...", buf, 0xCu);
LABEL_14:
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return result;
}

void sub_100F900D8(uint64_t a1@<X0>, void *a2@<X8>)
{
  std::string __p = 0;
  long long v15 = 0uLL;
  if (*(void *)(a1 + 24))
  {
    sub_100058DB0(&v12, " (:");
    uint64_t v4 = **(int **)(a1 + 24);
    if (v4 > 3) {
      int v5 = "???";
    }
    else {
      int v5 = off_101A774C8[v4];
    }
    size_t v6 = strlen(v5);
    BOOL v7 = std::string::append(&v12, v5, v6);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v13.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    OsLogContext v9 = std::string::append(&v13, ":)", 2uLL);
    char v10 = (void *)v9->__r_.__value_.__r.__words[0];
    v16[0] = v9->__r_.__value_.__l.__size_;
    *(void *)((char *)v16 + 7) = *(std::string::size_type *)((char *)&v9->__r_.__value_.__r.__words[1] + 7);
    char v11 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    *(void *)((char *)&v15 + 7) = *(void *)((char *)v16 + 7);
    std::string __p = v10;
    *(void *)&long long v15 = v16[0];
    HIBYTE(v15) = v11;
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v13.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    HIBYTE(v15) = 7;
    qmemcpy(&__p, " (null)", 7);
  }
  sub_1002055B4((const void **)(a1 + 40), (const void **)&__p, a2);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
}

void sub_100F90258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F902A8(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
    if (v2)
    {
      uint64_t v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        uint64_t v4 = v3;
        uint64_t v5 = *(void *)(a1 + 112);
        if (v5)
        {
          size_t v6 = *(std::__shared_weak_count **)(a1 + 32);
          uint64_t v11 = *(void *)(a1 + 24);
          std::string v12 = v6;
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (*(char *)(a1 + 63) < 0)
          {
            sub_10004FC84(v9, *(void **)(a1 + 40), *(void *)(a1 + 48));
          }
          else
          {
            *(_OWORD *)OsLogContext v9 = *(_OWORD *)(a1 + 40);
            uint64_t v10 = *(void *)(a1 + 56);
          }
          (*(void (**)(uint64_t, uint64_t *, void **))(*(void *)v5 + 56))(v5, &v11, v9);
          if (SHIBYTE(v10) < 0) {
            operator delete(v9[0]);
          }
          if (v12) {
            sub_10004D2C8(v12);
          }
        }
        sub_10004D2C8(v4);
      }
    }
  }
  else
  {
    BOOL v7 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      sub_100F900D8(a1, __p);
      long long v8 = v14 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)int buf = 136446210;
      uint64_t v16 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s Invalid region pointer...", buf, 0xCu);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100F9043C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

BOOL sub_100F9047C(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 24);
  if (v1) {
    return *v1 == 2;
  }
  uint64_t v4 = *(NSObject **)a1;
  BOOL result = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_100F900D8(a1, __p);
    if (v7 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136446210;
    OsLogContext v9 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s Invalid region pointer...", buf, 0xCu);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return result;
}

void sub_100F90574(NSObject **a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = *a1;
  uint64_t v4 = *a1;
  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100F900D8((uint64_t)a1, __p);
      uint64_t v5 = (void **)__p[0];
      if (v8 >= 0) {
        uint64_t v5 = __p;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v10 = v5;
      __int16 v11 = 2082;
      std::string v12 = "U";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s -> %{public}s", buf, 0x16u);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = a1[3];
    }
    LODWORD(v2->isa) = 1;
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_100F900D8((uint64_t)a1, __p);
    size_t v6 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136446210;
    uint64_t v10 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s Null region pointer..", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100F906EC(NSObject **a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = *a1;
  uint64_t v4 = *a1;
  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100F900D8((uint64_t)a1, __p);
      uint64_t v5 = (void **)__p[0];
      if (v8 >= 0) {
        uint64_t v5 = __p;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v10 = v5;
      __int16 v11 = 2082;
      std::string v12 = "I";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s -> %{public}s", buf, 0x16u);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = a1[3];
    }
    LODWORD(v2->isa) = 2;
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_100F900D8((uint64_t)a1, __p);
    size_t v6 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136446210;
    uint64_t v10 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s Null region pointer..", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100F90864(NSObject **a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = *a1;
  uint64_t v4 = *a1;
  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100F900D8((uint64_t)a1, __p);
      uint64_t v5 = (void **)__p[0];
      if (v8 >= 0) {
        uint64_t v5 = __p;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v10 = v5;
      __int16 v11 = 2082;
      std::string v12 = "O";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s -> %{public}s", buf, 0x16u);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = a1[3];
    }
    LODWORD(v2->isa) = 3;
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_100F900D8((uint64_t)a1, __p);
    size_t v6 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136446210;
    uint64_t v10 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s Null region pointer..", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100F909DC(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 24);
  if (v2)
  {
    *uint64_t v2 = a2;
  }
  else
  {
    uint64_t v4 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      sub_100F900D8(a1, __p);
      if (v7 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      *(_DWORD *)int buf = 136446210;
      OsLogContext v9 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s Null region pointer..", buf, 0xCu);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

BOOL sub_100F90AC8(uint64_t a1)
{
  if (*(void *)(a1 + 24)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 88);
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3 == v4)
  {
    if (v5)
    {
      size_t v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        uint64_t v8 = *(void *)(a1 + 112);
        if (v8)
        {
          double v9 = *(double *)(a1 + 64);
          double v10 = *(double *)(a1 + 72);
          double v11 = *(double *)(a1 + 80);
          if (*(char *)(a1 + 63) < 0)
          {
            sub_10004FC84(v20, *(void **)(a1 + 40), *(void *)(a1 + 48));
          }
          else
          {
            *(_OWORD *)uint64_t v20 = *(_OWORD *)(a1 + 40);
            uint64_t v21 = *(void *)(a1 + 56);
          }
          (*(void (**)(void **__return_ptr, uint64_t, void **, double, double, double))(*(void *)v8 + 40))(v22, v8, v20, v9, v10, v11);
          long long v17 = *(_OWORD *)v22;
          v22[0] = 0;
          v22[1] = 0;
          long long v18 = *(std::__shared_weak_count **)(a1 + 32);
          *(_OWORD *)(a1 + 24) = v17;
          if (v18)
          {
            sub_10004D2C8(v18);
            if (v22[1]) {
              sub_10004D2C8((std::__shared_weak_count *)v22[1]);
            }
          }
          if (SHIBYTE(v21) < 0) {
            operator delete(v20[0]);
          }
        }
      }
    }
    else
    {
      size_t v6 = 0;
    }
    char v14 = *(NSObject **)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    sub_100F900D8(a1, v22);
    if (v23 >= 0) {
      CFMutableDictionaryRef v19 = v22;
    }
    else {
      CFMutableDictionaryRef v19 = (void **)v22[0];
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v30 = v19;
    uint64_t v16 = "#I Geofence created (circ): %{public}s ";
  }
  else
  {
    if (v5)
    {
      size_t v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 112);
        if (v7)
        {
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          id v26 = 0;
          sub_1004081A4(&v26, *(const void **)(a1 + 88), *(void *)(a1 + 96), (uint64_t)(*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 4);
          if (*(char *)(a1 + 63) < 0)
          {
            sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
            uint64_t v25 = *(void *)(a1 + 56);
          }
          (*(void (**)(void **__return_ptr, uint64_t, void **, void **))(*(void *)v7 + 48))(v22, v7, &v26, __p);
          long long v12 = *(_OWORD *)v22;
          v22[0] = 0;
          v22[1] = 0;
          std::string v13 = *(std::__shared_weak_count **)(a1 + 32);
          *(_OWORD *)(a1 + 24) = v12;
          if (v13)
          {
            sub_10004D2C8(v13);
            if (v22[1]) {
              sub_10004D2C8((std::__shared_weak_count *)v22[1]);
            }
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(__p[0]);
          }
          if (v26)
          {
            uint64_t v27 = v26;
            operator delete(v26);
          }
        }
      }
    }
    else
    {
      size_t v6 = 0;
    }
    char v14 = *(NSObject **)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    sub_100F900D8(a1, v22);
    if (v23 >= 0) {
      long long v15 = v22;
    }
    else {
      long long v15 = (void **)v22[0];
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v30 = v15;
    uint64_t v16 = "#I Geofence created (poly): %{public}s ";
  }
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
  if (v23 < 0) {
    operator delete(v22[0]);
  }
LABEL_42:
  if (v6) {
    sub_10004D2C8(v6);
  }
  return *(void *)(a1 + 24) != 0;
}

void sub_100F90DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27)
{
  sub_10004D2C8(v27);
  _Unwind_Resume(a1);
}

void sub_100F90E4C(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    uint64_t v5 = (char **)(a2 + 24);
    uint64_t v6 = a2 + 40;
    do
    {
      uint64_t v7 = *v2;
      if (*(void *)(*v2 + 96) == *(void *)(*v2 + 88))
      {
        double v10 = (long long *)(v7 + 64);
        unint64_t v12 = *(void *)(a2 + 32);
        unint64_t v11 = *(void *)(a2 + 40);
        if (v12 >= v11)
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)*v5) >> 3);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_100578470();
          }
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)*v5) >> 3);
          if (2 * v17 > v16) {
            unint64_t v16 = 2 * v17;
          }
          if (v17 >= 0x555555555555555) {
            unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v18 = v16;
          }
          if (v18) {
            CFMutableDictionaryRef v19 = (char *)sub_10004812C(v6, v18);
          }
          else {
            CFMutableDictionaryRef v19 = 0;
          }
          uint64_t v20 = &v19[24 * v15];
          long long v21 = *v10;
          *((void *)v20 + 2) = *((void *)v10 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          char v23 = *(char **)(a2 + 24);
          long long v22 = *(char **)(a2 + 32);
          id v24 = v20;
          if (v22 != v23)
          {
            do
            {
              long long v25 = *(_OWORD *)(v22 - 24);
              *((void *)v24 - 1) = *((void *)v22 - 1);
              *(_OWORD *)(v24 - 24) = v25;
              v24 -= 24;
              v22 -= 24;
            }
            while (v22 != v23);
            long long v22 = *v5;
          }
          char v14 = v20 + 24;
          *(void *)(a2 + 24) = v24;
          *(void *)(a2 + 32) = v20 + 24;
          *(void *)(a2 + 40) = &v19[24 * v18];
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          long long v13 = *v10;
          *(void *)(v12 + 16) = *((void *)v10 + 2);
          *(_OWORD *)unint64_t v12 = v13;
          char v14 = (char *)(v12 + 24);
        }
        *(void *)(a2 + 32) = v14;
      }
      else
      {
        uint64_t v8 = *(void **)(a2 + 8);
        if ((unint64_t)v8 >= *(void *)(a2 + 16))
        {
          uint64_t v9 = sub_100578560((uint64_t *)a2, *v2 + 88);
        }
        else
        {
          void *v8 = 0;
          v8[1] = 0;
          _DWORD v8[2] = 0;
          sub_1004081A4(v8, *(const void **)(v7 + 88), *(void *)(v7 + 96), (uint64_t)(*(void *)(v7 + 96) - *(void *)(v7 + 88)) >> 4);
          uint64_t v9 = (uint64_t)(v8 + 3);
          *(void *)(a2 + 8) = v8 + 3;
        }
        *(void *)(a2 + 8) = v9;
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
}

void sub_100F91020(_Unwind_Exception *a1)
{
  sub_100576180(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F91044(uint64_t a1)
{
  *(void *)a1 = off_101A777D0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91088(uint64_t a1)
{
  *(void *)a1 = off_101A77840;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F910CC(uint64_t a1)
{
  *(void *)a1 = off_101A778B0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91110(uint64_t a1)
{
  *(void *)a1 = off_101A77920;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91154(uint64_t a1)
{
  *(void *)a1 = off_101A77990;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91198(uint64_t a1)
{
  *(void *)a1 = off_101A77A00;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F911DC(uint64_t a1)
{
  *(void *)a1 = off_101A77A70;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91220(uint64_t a1)
{
  *(void *)a1 = off_101A77AE0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91264(uint64_t a1)
{
  *(void *)a1 = off_101A77B50;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F912A8(uint64_t a1)
{
  *(void *)a1 = off_101A77BC0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F912EC(uint64_t a1)
{
  *(void *)a1 = off_101A77C30;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91330(uint64_t a1)
{
  *(void *)a1 = off_101A77CA0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F91374(uint64_t a1)
{
  *(void *)a1 = off_101A77D10;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_100F913B8(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && (unsigned int v2 = sub_100FB5980(a1) - 2, v2 <= 0xE)) {
    return dword_1015A3B28[v2];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void entitlements::CEHTTPDriver::CEHTTPDriver(uint64_t a1, NSObject **a2, void *a3, char *a4, void *a5, uint64_t *a6, long long *a7, uint64_t *a8)
{
  unint64_t v15 = *a2;
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  unint64_t v16 = (std::__shared_weak_count *)a8[1];
  uint64_t v19 = *a8;
  uint64_t v20 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100CEC110(a1, &object, a3, "CEHTTPDriver", a4, a5, a6, &v19);
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = off_101A774F8;
  *(void *)(a1 + 392) = a4;
  if (*((char *)a7 + 23) < 0)
  {
    unint64_t v18 = *((void *)a7 + 1);
    if (v18)
    {
      sub_10004FC84((unsigned char *)(a1 + 400), *(void **)a7, v18);
      goto LABEL_15;
    }
  }
  else if (*((unsigned char *)a7 + 23))
  {
    long long v17 = *a7;
    *(void *)(a1 + 416) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 400) = v17;
    goto LABEL_15;
  }
  sub_100CE9A24(*a6, a1 + 400);
LABEL_15:
  sub_100CE9DBC(*a6, (void *)(a1 + 424));
  *(unsigned char *)(a1 + 504) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(unsigned char *)(a1 + 480) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(void *)(a1 + 560) = 0;
  *(unsigned char *)(a1 + 568) = *(unsigned char *)(***(void ***)(a1 + 128) + 49) == 1;
  *(_OWORD *)(a1 + 576) = 0u;
  *(void *)(a1 + 592) = a1 + 592;
  *(void *)(a1 + 600) = a1 + 592;
  *(unsigned char *)(a1 + 644) = 0;
  *(_OWORD *)(a1 + 664) = 0u;
  *(void *)(a1 + 648) = 0;
  *(unsigned char *)(a1 + 640) = 0;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(void *)(a1 + 656) = a1 + 664;
  *(_OWORD *)(a1 + 688) = 0u;
  *(void *)(a1 + 680) = a1 + 688;
  *(_WORD *)(a1 + 704) = 0;
  *(_OWORD *)(a1 + 784) = 0u;
  *(unsigned char *)(a1 + 728) = 0;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_WORD *)(a1 + 768) = 0;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(void *)(a1 + 776) = a1 + 784;
  *(void *)(a1 + 816) = 0;
  *(void *)(a1 + 808) = 0;
  *(void *)(a1 + 800) = a1 + 808;
  *(void *)(a1 + 840) = 0;
  *(void *)(a1 + 832) = 0;
  *(void *)(a1 + 824) = a1 + 832;
  *(unsigned char *)(a1 + 848) = 0;
  sub_100F917E8();
}

void sub_100F9164C(_Unwind_Exception *a1)
{
  sub_100CEC610(v1);
  _Unwind_Resume(a1);
}

void sub_100F917C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x100F917C0);
}

void sub_100F917E8()
{
}

void sub_100F919B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F919E8(uint64_t a1)
{
  *(void *)a1 = off_101A774F8;
  *(unsigned char *)(a1 + 124) = 1;
  unsigned int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    int v5 = 136315906;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    __int16 v11 = 2080;
    unint64_t v12 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sDriver is going away. Invalidating all incomplete actions", (uint8_t *)&v5, 0x2Au);
  }
  LOBYTE(v5) = 0;
  LOBYTE(v6) = 0;
  sub_100F91C6C(a1, 0, (uint64_t)&v5);
}

void sub_100F91C60(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F91C6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t *)(a1 + 592);
  for (id i = *(uint64_t **)(a1 + 600); i != v6; id i = (uint64_t *)i[1])
    sub_100F9FBF4(a1, a2, i[2], a3);
  uint64_t v8 = *(void *)(a1 + 576);
  if (v8) {
    sub_100F9FBF4(a1, a2, v8, a3);
  }
  sub_10011A838(v6);
  if (*(unsigned char *)(a1 + 644)) {
    *(unsigned char *)(a1 + 644) = 0;
  }
  __int16 v9 = *(std::__shared_weak_count **)(a1 + 584);
  *(_OWORD *)(a1 + 576) = 0u;
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v12 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    uint64_t v14 = v11;
    __int16 v15 = 2080;
    unint64_t v16 = " ";
    __int16 v17 = 2080;
    uint64_t v18 = v12;
    __int16 v19 = 2080;
    uint64_t v20 = "";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAll pending and requested queries terminated", buf, 0x2Au);
  }
  sub_100F917E8();
}

void sub_100F91DEC(uint64_t a1)
{
}

void sub_100F91E24(void *a1)
{
  sub_100CEC79C((uint64_t)a1);
  unsigned int v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
      sub_100058DB0(&v33, "/cc/props/connection_state");
      uint64_t v6 = operator new(0x28uLL);
      *uint64_t v6 = off_101A78740;
      v6[1] = a1 + 97;
      void v6[2] = a1;
      void v6[3] = v3;
      void v6[4] = v5;
      *((void *)&v32 + 1) = v6;
      ctu::RestModule::observeProperty();
      sub_10003F600(&v31);
      if (v34 < 0) {
        operator delete(v33);
      }
      __int16 v7 = (std::__shared_weak_count *)a1[2];
      if (v7)
      {
        uint64_t v8 = a1[1];
        __int16 v9 = std::__shared_weak_count::lock(v7);
        if (v9)
        {
          uint64_t v10 = v9;
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
          sub_100058DB0(&v33, "/cc/props/reg_data_attached");
          uint64_t v11 = operator new(0x28uLL);
          void *v11 = off_101A787C0;
          v11[1] = a1 + 100;
          v11[2] = a1;
          v11[3] = v8;
          v11[4] = v10;
          *((void *)&v32 + 1) = v11;
          ctu::RestModule::observeProperty();
          sub_10003F600(&v31);
          if (v34 < 0) {
            operator delete(v33);
          }
          uint64_t v12 = (std::__shared_weak_count *)a1[2];
          if (v12)
          {
            uint64_t v13 = a1[1];
            uint64_t v14 = std::__shared_weak_count::lock(v12);
            if (v14)
            {
              __int16 v15 = v14;
              atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v14);
              sub_100058DB0(&v33, "/cc/props/connection_availability");
              unint64_t v16 = operator new(0x28uLL);
              void *v16 = off_101A78840;
              v16[1] = a1 + 103;
              void v16[2] = a1;
              v16[3] = v13;
              v16[4] = v15;
              *((void *)&v32 + 1) = v16;
              ctu::RestModule::observeProperty();
              sub_10003F600(&v31);
              if (v34 < 0) {
                operator delete(v33);
              }
              __int16 v17 = (std::__shared_weak_count *)a1[2];
              if (v17)
              {
                uint64_t v18 = a1[1];
                __int16 v19 = std::__shared_weak_count::lock(v17);
                if (v19)
                {
                  uint64_t v20 = v19;
                  atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v19);
                  sub_100058DB0(&v33, "/cc/events/connection_activate_error");
                  long long v21 = operator new(0x20uLL);
                  *long long v21 = off_101A788C0;
                  v21[1] = a1;
                  _OWORD v21[2] = v18;
                  _OWORD v21[3] = v20;
                  *((void *)&v32 + 1) = v21;
                  ctu::RestModule::observeEvent();
                  sub_10003F600(&v31);
                  if (v34 < 0) {
                    operator delete(v33);
                  }
                  long long v22 = (std::__shared_weak_count *)a1[2];
                  if (v22)
                  {
                    uint64_t v23 = a1[1];
                    id v24 = std::__shared_weak_count::lock(v22);
                    if (v24)
                    {
                      long long v25 = v24;
                      atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      sub_10004D2C8(v24);
                      id v26 = (std::__shared_weak_count *)a1[2];
                      if (v26)
                      {
                        if (std::__shared_weak_count::lock(v26))
                        {
                          uint64_t v27 = a1[3];
                          uint64_t v28 = a1;
                          uint64_t v29 = v23;
                          __int16 v30 = v25;
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          long long v31 = 0u;
                          long long v32 = 0u;
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          dispatch_retain(v27);
                          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          long long v33 = 0;
                          dispatch_retain(v27);
                          operator new();
                        }
                      }
                      sub_100088B9C();
                    }
                  }
                  sub_100088B9C();
                }
              }
              sub_100088B9C();
            }
          }
          sub_100088B9C();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100F92874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_100060644(va);
  _Unwind_Resume(a1);
}

void sub_100F92B8C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 824);
  uint64_t v3 = (void *)(a1 + 832);
  if (v2 == (void *)(a1 + 832))
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    while (1)
    {
      char v5 = ConnectionAvailabilityContainer::available();
      if (v5) {
        break;
      }
      uint64_t v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          __int16 v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          __int16 v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          unsigned int v2 = v7;
        }
        while (!v8);
      }
      v4 |= v5;
      unsigned int v2 = v7;
      if (v7 == v3) {
        goto LABEL_13;
      }
    }
    char v4 = 1;
  }
LABEL_13:
  uint64_t v9 = ***(void ***)(a1 + 128);
  if (*(unsigned char *)(v9 + 49)) {
    goto LABEL_14;
  }
  uint64_t v18 = *v3;
  if (!*v3) {
    goto LABEL_14;
  }
  int v19 = *(_DWORD *)(v9 + 52);
  uint64_t v20 = v3;
  do
  {
    int v21 = *(_DWORD *)(v18 + 28);
    BOOL v22 = v21 < v19;
    if (v21 >= v19) {
      uint64_t v23 = (uint64_t *)v18;
    }
    else {
      uint64_t v23 = (uint64_t *)(v18 + 8);
    }
    if (!v22) {
      uint64_t v20 = (void *)v18;
    }
    uint64_t v18 = *v23;
  }
  while (*v23);
  if (v20 == v3 || v19 < *((_DWORD *)v20 + 7)) {
LABEL_14:
  }
    int v10 = 0;
  else {
    int v10 = ConnectionAvailabilityContainer::available();
  }
  char v11 = v4 & 1;
  if (*(unsigned char *)(a1 + 768) != (v4 & 1) || *(unsigned __int8 *)(a1 + 769) != v10)
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v14 = *(void *)(a1 + 160);
      uint64_t v15 = asStringBool(*(unsigned char *)(a1 + 768));
      uint64_t v16 = asStringBool(v4 & 1);
      uint64_t v17 = asStringBool(*(unsigned char *)(a1 + 769));
      int v24 = 136316930;
      uint64_t v25 = v13;
      __int16 v26 = 2080;
      uint64_t v27 = " ";
      __int16 v28 = 2080;
      uint64_t v29 = v14;
      __int16 v30 = 2080;
      long long v31 = "";
      __int16 v32 = 2080;
      uint64_t v33 = v15;
      __int16 v34 = 2080;
      uint64_t v35 = v16;
      __int16 v36 = 2080;
      uint64_t v37 = v17;
      __int16 v38 = 2080;
      uint64_t v39 = asStringBool(v10);
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sConnection availability changed. Internet: %s -> %s, Entitlement: %s -> %s. Issuing any pending transactions", (uint8_t *)&v24, 0x52u);
    }
    *(unsigned char *)(a1 + 768) = v11;
    *(unsigned char *)(a1 + 769) = v10;
    sub_100F92DE8(a1);
    sub_100F937E8(a1);
  }
}

uint64_t sub_100F92DE8(uint64_t a1)
{
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)long long v31 = 0u;
  long long v32 = 0u;
  memset(v30, 0, sizeof(v30));
  long long v29 = 0u;
  sub_10004BD84((uint64_t)&v29);
  uint64_t v2 = *(void *)(*(void *)(a1 + 144) + 96);
  if ((v2 & 2) != 0)
  {
    int v3 = *(unsigned char *)(a1 + 768) || *(unsigned char *)(a1 + 704) || *(unsigned char *)(a1 + 705);
    char v4 = sub_10004B96C(v30, (uint64_t)"kInternet", 9);
    sub_10004B96C(v4, (uint64_t)":[", 2);
    if (*(unsigned char *)(a1 + 768))
    {
      sub_10004B96C(v30, (uint64_t)"cellular", 8);
      if (!*(unsigned char *)(a1 + 704))
      {
LABEL_14:
        if (!*(unsigned char *)(a1 + 705))
        {
LABEL_23:
          sub_10004B96C(v30, (uint64_t)"]", 1);
          if ((v2 & 1) == 0) {
            goto LABEL_34;
          }
          if (*(unsigned char *)(a1 + 769)) {
            int v3 = 1;
          }
          sub_10004B96C(v30, (uint64_t)" and ", 5);
          char v5 = (unsigned char *)(a1 + 769);
          goto LABEL_27;
        }
        sub_10004B96C(v30, (uint64_t)", ", 2);
        uint64_t v6 = "via phone";
        uint64_t v7 = 9;
LABEL_22:
        sub_10004B96C(v30, (uint64_t)v6, v7);
        goto LABEL_23;
      }
      sub_10004B96C(v30, (uint64_t)", ", 2);
    }
    else if (!*(unsigned char *)(a1 + 704))
    {
      if (*(unsigned char *)(a1 + 705)) {
        uint64_t v6 = "via phone";
      }
      else {
        uint64_t v6 = "unavailable";
      }
      if (*(unsigned char *)(a1 + 705)) {
        uint64_t v7 = 9;
      }
      else {
        uint64_t v7 = 11;
      }
      goto LABEL_22;
    }
    sub_10004B96C(v30, (uint64_t)"wifi", 4);
    goto LABEL_14;
  }
  if ((v2 & 1) == 0)
  {
    sub_10004B96C(v30, (uint64_t)"no options", 10);
    int v3 = 0;
    goto LABEL_34;
  }
  char v5 = (unsigned char *)(a1 + 769);
  int v3 = *(unsigned char *)(a1 + 769) != 0;
LABEL_27:
  sub_10004B96C(v30, (uint64_t)"kDedicatedAPN", 13);
  if (*v5) {
    BOOL v8 = ":[available]";
  }
  else {
    BOOL v8 = ":[unavailable]";
  }
  if (*v5) {
    uint64_t v9 = 12;
  }
  else {
    uint64_t v9 = 14;
  }
  sub_10004B96C(v30, (uint64_t)v8, v9);
LABEL_34:
  int v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v12 = *(void *)(a1 + 160);
    sub_10004BC98((uint64_t)v30 + 8, __p);
    uint64_t v13 = v28 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v45 = 2080;
    uint64_t v46 = v12;
    __int16 v47 = 2080;
    uint64_t v48 = "";
    __int16 v49 = 2082;
    uint64_t v50 = (uint64_t)v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransport availability: %{public}s", buf, 0x34u);
    if (v28 < 0) {
      operator delete(__p[0]);
    }
  }
  if (*(unsigned __int8 *)(a1 + 848) != v3)
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v16 = *(void *)(a1 + 160);
      uint64_t v17 = asStringBool(v3);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v45 = 2080;
      uint64_t v46 = v16;
      __int16 v47 = 2080;
      uint64_t v48 = "";
      __int16 v49 = 2080;
      uint64_t v50 = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransport availability changes to: %s", buf, 0x34u);
    }
    *(unsigned char *)(a1 + 848) = v3;
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 112);
    if (v18)
    {
      int v19 = std::__shared_weak_count::lock(v18);
      if (v19)
      {
        uint64_t v20 = v19;
        int v21 = *(void (****)(void, unsigned char *, void))(a1 + 104);
        if (v21)
        {
          BOOL v22 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v22 || (v23 = *(void *)(a1 + 8), (int v24 = std::__shared_weak_count::lock(v22)) == 0)) {
            sub_100088B9C();
          }
          *(void *)int buf = v23;
          *(void *)&uint8_t buf[8] = v24;
          atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v24);
          (**v21)(v21, buf, *(unsigned __int8 *)(a1 + 848));
          if (*(void *)&buf[8]) {
            std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        sub_10004D2C8(v20);
      }
    }
  }
  *(void *)((char *)&v30[-1]
  *(void *)&v30[0] = v25;
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100F93390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  BOOL v8 = *(std::__shared_weak_count **)(v6 - 120);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  sub_10004D2C8(v5);
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F933E8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 848);
}

void sub_100F933F0(uint64_t a1)
{
  if (!*(unsigned char *)(***(void ***)(a1 + 128) + 49))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(***(void ***)(a1 + 128) + 49), *(Registry **)(a1 + 48));
    int v3 = ServiceMap;
    if ((v4 & 0x8000000000000000) != 0)
    {
      char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        unint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v18 = v4;
    BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, &v18);
    if (v8)
    {
      uint64_t v10 = v8[3];
      uint64_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        char v11 = 0;
        if (!v10)
        {
LABEL_14:
          if ((v11 & 1) == 0) {
            sub_10004D2C8(v9);
          }
          return;
        }
LABEL_11:
        uint64_t v12 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v12
          || (uint64_t v13 = *(unsigned int *)(***(void ***)(a1 + 128) + 52),
              uint64_t v14 = *(void *)(a1 + 8),
              (uint64_t v15 = std::__shared_weak_count::lock(v12)) == 0))
        {
          sub_100088B9C();
        }
        uint64_t v16 = v15;
        atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        uint64_t v20 = 0;
        uint64_t v17 = operator new(0x20uLL);
        void *v17 = off_101A78C08;
        v17[1] = a1;
        v17[2] = v14;
        v17[3] = v16;
        uint64_t v20 = v17;
        (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v10 + 112))(v10, v13, v19);
        sub_100060644(v19);
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_14;
    }
    goto LABEL_11;
  }
}

void sub_100F935C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void entitlements::CEHTTPDriver::handleWifiAvailable(entitlements::CEHTTPDriver *this, int a2)
{
  if (*((unsigned __int8 *)this + 704) != a2)
  {
    BOOL v2 = a2;
    unint64_t v4 = *((void *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(***((PersonalityInfo ****)this + 16));
      uint64_t v6 = *((void *)this + 20);
      uint64_t v7 = asStringBool(*((unsigned char *)this + 704));
      int v11 = 136316418;
      uint64_t v12 = v5;
      __int16 v13 = 2080;
      uint64_t v14 = " ";
      __int16 v15 = 2080;
      uint64_t v16 = v6;
      __int16 v17 = 2080;
      unint64_t v18 = "";
      __int16 v19 = 2080;
      uint64_t v20 = v7;
      __int16 v21 = 2080;
      uint64_t v22 = asStringBool(v2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sWifi availability is changing from %s to %s", (uint8_t *)&v11, 0x3Eu);
    }
    *((unsigned char *)this + 704) = v2;
    sub_100F92DE8((uint64_t)this);
    if (*((unsigned char *)this + 704))
    {
      sub_100CECA44((uint64_t)this, (uint64_t)"handleWifiAvailable", 0);
      BOOL v8 = *((void *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(***((PersonalityInfo ****)this + 16));
        uint64_t v10 = *((void *)this + 20);
        int v11 = 136315906;
        uint64_t v12 = v9;
        __int16 v13 = 2080;
        uint64_t v14 = " ";
        __int16 v15 = 2080;
        uint64_t v16 = v10;
        __int16 v17 = 2080;
        unint64_t v18 = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sBecame WiFi attached, issuing any pending transactions", (uint8_t *)&v11, 0x2Au);
      }
      sub_100F937E8((uint64_t)this);
    }
  }
}

void sub_100F937E8(uint64_t a1)
{
  if ((*(void *)(a1 + 608) > 1uLL
     || (BOOL v2 = *(void **)(*(void *)(a1 + 616) + 40)) != 0 && [v2 count])
    && !*(void *)(a1 + 576))
  {
    char v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v5 = *(void *)(a1 + 160);
      int v6 = 136315906;
      uint64_t v7 = v4;
      __int16 v8 = 2080;
      uint64_t v9 = " ";
      __int16 v10 = 2080;
      uint64_t v11 = v5;
      __int16 v12 = 2080;
      __int16 v13 = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________   Sending Request for pending query", (uint8_t *)&v6, 0x2Au);
    }
    sub_100FA0BA4(a1, 0);
  }
}

void sub_100F938F8(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________   Reset called on driver. Cancelling all transactions.", buf, 0x2Au);
  }
  sub_100CEC800(a1, a2);
  sub_100CEA0C0(*(void *)(a1 + 144), (uint64_t)buf);
  uint64_t v7 = (void **)(a1 + 512);
  if (*(char *)(a1 + 535) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)uint64_t v7 = *(_OWORD *)buf;
  *(void *)(a1 + 528) = *(void *)&buf[16];
  buf[0] = 0;
  uint8_t buf[4] = 0;
  sub_100F91C6C(a1, 0, (uint64_t)buf);
}

void sub_100F9400C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (a14)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F94130(uint64_t a1)
{
  uint64_t v2 = a1 + 536;
  char v3 = *(std::__shared_weak_count **)(a1 + 544);
  *(_OWORD *)uint64_t v2 = 0u;
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 560);
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 24) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 760);
  *(_OWORD *)(a1 + 752) = 0u;
  if (v5) {
    sub_10004D2C8(v5);
  }

  return _CFURLConnectionInvalidateConnectionCache();
}

void sub_100F9419C(uint64_t a1, uint64_t *a2, void *a3)
{
  sub_100F941D4(a1, a2, a3);

  sub_100F937E8(a1);
}

void sub_100F941D4(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v23 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v23);
  uint64_t v6 = *(void *)(a1 + 144);
  uint64_t v7 = *(void *)(v6 + 88);
  if (!*(unsigned char *)(v6 + 16) && ((unint64_t)sub_100CE9554(v6) & 0x20) != 0) {
    v7 |= 5uLL;
  }
  uint64_t v22 = *a3 & v7;
  if ((v22 & 0x3FFFFF) != 0)
  {
    sub_100F94478(&v20, a1, -1);
    if (v21) {
      sub_10004D2C8(v21);
    }
    __int16 v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v10 = *(void *)(a1 + 160);
      sub_1000225AC((uint64_t)&v22, __p);
      uint64_t v11 = v19 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)int buf = 136316162;
      uint64_t v25 = v9;
      __int16 v26 = 2080;
      uint64_t v27 = " ";
      __int16 v28 = 2080;
      uint64_t v29 = v10;
      __int16 v30 = 2080;
      long long v31 = "";
      __int16 v32 = 2082;
      long long v33 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%squeryEntitlements_sync with %{public}s", buf, 0x34u);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }
    id v12 = sub_100FB5B78(&v22);
    uint64_t v13 = *(void *)(a1 + 576);
    if (v13) {
      id v12 = sub_100FBDB40(v13, v12);
    }
    id v14 = sub_100FBB504(*(void *)(a1 + 616), v12);
    if (v14) {
      sub_100F9461C(a1, v14, a2);
    }
    else {
      sub_100FBC250(*(void *)(a1 + 616), &v22);
    }
  }
  else
  {
    __int16 v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v17 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      uint64_t v25 = v16;
      __int16 v26 = 2080;
      uint64_t v27 = " ";
      __int16 v28 = 2080;
      uint64_t v29 = v17;
      __int16 v30 = 2080;
      long long v31 = "";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sNo entitlements to query", buf, 0x2Au);
    }
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v23);
}

void sub_100F94444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void *sub_100F94478(void *result, uint64_t a2, int a3)
{
  uint64_t v4 = result;
  uint64_t v5 = *(void *)(a2 + 616);
  uint64_t v6 = *(void *)(v5 + 120);
  if ((v6 & 0xFF00000000) != 0)
  {
    if (v6 != a3)
    {
      __int16 v8 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a2 + 128));
        uint64_t v10 = *(void *)(a2 + 160);
        if (a3 == -1) {
          uint64_t v11 = "-";
        }
        else {
          uint64_t v11 = sub_100059954(a3);
        }
        uint64_t v12 = *(void *)(*(void *)(a2 + 616) + 120);
        if ((v12 & 0xFF00000000) != 0) {
          uint64_t v13 = sub_100059954(v12);
        }
        else {
          uint64_t v13 = "-";
        }
        *(_DWORD *)int buf = 136316418;
        uint64_t v16 = v9;
        __int16 v17 = 2080;
        unint64_t v18 = " ";
        __int16 v19 = 2080;
        uint64_t v20 = v10;
        __int16 v21 = 2080;
        uint64_t v22 = "";
        __int16 v23 = 2080;
        int v24 = v11;
        __int16 v25 = 2080;
        __int16 v26 = v13;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdding new pending query because I am:%s. Existing query dedicated to:%s", buf, 0x3Eu);
      }
      sub_100F917E8();
    }
  }
  else
  {
    BOOL result = *(void **)(v5 + 40);
    if (result) {
      BOOL result = [result count];
    }
  }
  uint64_t v14 = *(void *)(a2 + 624);
  *uint64_t v4 = *(void *)(a2 + 616);
  v4[1] = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F9461C(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  if (*(unsigned char *)(*a3 + 16) && *(_DWORD *)(v6 + 12))
  {
    objc_msgSend(a2, "setAttemptsLimit:");
    uint64_t v6 = *a3;
  }
  if (*(unsigned char *)(v6 + 2))
  {
    [a2 setBootstrapDataAllowed:1];
    uint64_t v6 = *a3;
  }
  if (*(unsigned char *)v6 && sub_100CEBB54(*(void *)(a1 + 144))) {
    [a2 setNeedSecureIntent:1];
  }
  uint64_t v7 = *a3;
  if (*(unsigned char *)(*a3 + 1))
  {
    [a2 setFullAuthenticationNeeded];
    uint64_t v7 = *a3;
  }
  if (*(unsigned char *)(v7 + 48))
  {
    __int16 v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v10 = *(void *)(a1 + 160);
      int v14 = 136315906;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      __int16 v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v10;
      __int16 v20 = 2080;
      __int16 v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sblind signature provided for authentication!!!", (uint8_t *)&v14, 0x2Au);
      uint64_t v7 = *a3;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 264))(a1, v7 + 24, v7 + 56);
    uint64_t v7 = *a3;
  }
  if (*(unsigned char *)(v7 + 8) && *(_DWORD *)(v7 + 4))
  {
    objc_msgSend(a2, "setCancelationTimestampInSecond:");
    sub_100F9F270(a1);
    uint64_t v7 = *a3;
  }
  if (*(unsigned char *)(v7 + 3))
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v13 = *(void *)(a1 + 160);
      int v14 = 136315906;
      uint64_t v15 = v12;
      __int16 v16 = 2080;
      __int16 v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      __int16 v20 = 2080;
      __int16 v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sforced action added!!!", (uint8_t *)&v14, 0x2Au);
    }
    *(unsigned char *)(a1 + 728) = 1;
    [a2 setUserInitiated:1];
    (*(void (**)(uint64_t, void))(*(void *)a1 + 344))(a1, 0);
  }
}

BOOL sub_100F948C4(uint64_t a1, void *a2)
{
  uint64_t v13 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v13);
  uint64_t v4 = *a2 & 0x3FFFFFLL;
  if (v4)
  {
    sub_100F94478(&v11, a1, -1);
    if (v12) {
      sub_10004D2C8(v12);
    }
    id v5 = sub_100FB5C24(a2);
    uint64_t v6 = *(void *)(a1 + 576);
    if (v6) {
      id v5 = sub_100FBDBB8(v6, v5);
    }
    sub_100FBB57C(*(void *)(a1 + 616), v5);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
    sub_100F937E8(a1);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v9 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      uint64_t v15 = v8;
      __int16 v16 = 2080;
      __int16 v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v9;
      __int16 v20 = 2080;
      __int16 v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sNo entitlements to query", buf, 0x2Au);
    }
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
  }
  return v4 != 0;
}

void sub_100F94A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F94A4C(uint64_t a1, void *a2)
{
  uint64_t v13 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v13);
  uint64_t v4 = *a2 & 0x3FFFFFLL;
  if (v4)
  {
    sub_100F94478(&v11, a1, -1);
    if (v12) {
      sub_10004D2C8(v12);
    }
    id v5 = sub_100FB5C24(a2);
    uint64_t v6 = *(void *)(a1 + 576);
    if (v6) {
      id v5 = sub_100FBDC30(v6, v5);
    }
    sub_100FBB5F4(*(void *)(a1 + 616), v5);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
    sub_100F937E8(a1);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v9 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      uint64_t v15 = v8;
      __int16 v16 = 2080;
      __int16 v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v9;
      __int16 v20 = 2080;
      __int16 v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sempty get provisioning request", buf, 0x2Au);
    }
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
  }
  return v4 != 0;
}

void sub_100F94BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F94BD4(uint64_t a1, void *a2)
{
  uint64_t v13 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v13);
  uint64_t v4 = a2[2];
  if (v4)
  {
    sub_100F94478(&v11, a1, *(_DWORD *)(*a2 + 32));
    if (v12) {
      sub_10004D2C8(v12);
    }
    id v5 = sub_100FB5CE4((uint64_t)a2);
    uint64_t v6 = *(void *)(a1 + 576);
    if (v6) {
      id v5 = sub_100FBDCA8(v6, v5);
    }
    sub_100FBB66C(*(void *)(a1 + 616), v5);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
    sub_100F937E8(a1);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v9 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      uint64_t v15 = v8;
      __int16 v16 = 2080;
      __int16 v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v9;
      __int16 v20 = 2080;
      __int16 v21 = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sempty set provisioning request", buf, 0x2Au);
    }
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v13);
  }
  return v4 != 0;
}

void sub_100F94D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F94D5C(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v10 = *(void *)(a1 + 160);
    sub_1000225AC((uint64_t)a4, &__p);
    uint64_t v11 = v28 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v31 = v10;
    __int16 v32 = 2080;
    long long v33 = "";
    __int16 v34 = 2080;
    long long v35 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sgetRegisteredLocationStatus with %s", buf, 0x34u);
    if (v28 < 0) {
      operator delete(__p);
    }
  }
  uint64_t v29 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v29);
  sub_100CEB718(*(void *)(a1 + 144), (uint64_t)buf);
  uint64_t v12 = buf[23];
  if ((buf[23] & 0x80u) != 0) {
    uint64_t v12 = *(void *)&buf[8];
  }
  if (v12 != 1)
  {
    BOOL v14 = 0;
    if ((char)buf[23] < 0) {
      goto LABEL_17;
    }
LABEL_15:
    if (!v14) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  uint64_t v13 = *(uint8_t **)buf;
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v13 = buf;
  }
  BOOL v14 = *v13 == 49;
  if (((char)buf[23] & 0x80000000) == 0) {
    goto LABEL_15;
  }
LABEL_17:
  operator delete(*(void **)buf);
  if (!v14)
  {
LABEL_18:
    uint64_t v15 = *(unsigned __int8 *)(a3 + 23);
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = *(void *)(a3 + 8);
    }
    if (!v15) {
      goto LABEL_29;
    }
  }
LABEL_21:
  uint64_t v16 = *(unsigned __int8 *)(a3 + 47);
  if ((v16 & 0x80u) != 0) {
    uint64_t v16 = *(void *)(a3 + 32);
  }
  if (v16)
  {
    sub_100F94478(&__p, a1, -1);
    if (v27) {
      sub_10004D2C8(v27);
    }
    if (v14)
    {
      uint64_t v17 = *(void *)(a1 + 128);
      if (*(char *)(v17 + 407) < 0)
      {
        sub_10004FC84(buf, *(void **)(v17 + 384), *(void *)(v17 + 392));
      }
      else
      {
        uint64_t v18 = v17 + 384;
        *(_OWORD *)int buf = *(_OWORD *)v18;
        *(void *)&uint8_t buf[16] = *(void *)(v18 + 16);
      }
    }
    else
    {
      memset(buf, 0, sizeof(buf));
    }
    id v23 = sub_100FB6124(a3, v14, (uint64_t)buf);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v24 = *(void *)(a1 + 576);
    if (v24) {
      id v23 = sub_100FBE40C(v24, v23);
    }
    __int16 v25 = sub_100FBE398(*(void *)(a1 + 616), v23);
    sub_100F9461C(a1, v25, a2);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v29);
    if ((*(_DWORD *)a4 & 0x3FFFFF) != 0) {
      sub_100F941D4(a1, a2, a4);
    }
    sub_100F937E8(a1);
    return 1;
  }
LABEL_29:
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v21 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v31 = v21;
    __int16 v32 = 2080;
    long long v33 = "";
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sGet registration location status is not valid", buf, 0x2Au);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v29);
  return 0;
}

void sub_100F950B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_100F950FC(uint64_t a1, uint64_t *a2)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  sub_1001B4E5C(&v16, *a2, a2[1], 0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 3));
  uint64_t v23 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v23);
  char v3 = v16;
  if (v16 == v17) {
    goto LABEL_20;
  }
  LOBYTE(v4) = 1;
  do
  {
    if (v4)
    {
      int v4 = *v3;
      if (*v3) {
        int v4 = *((unsigned char *)v3 + 64) != 0;
      }
    }
    else
    {
      int v4 = 0;
    }
    v3 += 18;
  }
  while (v3 != v17);
  if (!v4)
  {
LABEL_20:
    uint64_t v12 = *(NSObject **)(a1 + 40);
    uint64_t v11 = 0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v14 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v25 = 2080;
      __int16 v26 = " ";
      __int16 v27 = 2080;
      uint64_t v28 = v14;
      __int16 v29 = 2080;
      __int16 v30 = "";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sEnable push notificaiton request is not valid", buf, 0x2Au);
      uint64_t v11 = 0;
    }
  }
  else
  {
    sub_100F94478(&v21, a1, -1);
    if (v22) {
      sub_10004D2C8(v22);
    }
    id v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v7 = *(void *)(a1 + 160);
      sub_100C91770(&v16, __p);
      uint64_t v8 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v25 = 2080;
      __int16 v26 = " ";
      __int16 v27 = 2080;
      uint64_t v28 = v7;
      __int16 v29 = 2080;
      __int16 v30 = "";
      __int16 v31 = 2080;
      __int16 v32 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdding enable push notification with %s", buf, 0x34u);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    id v9 = sub_100FB65F8((uint64_t *)&v16);
    uint64_t v10 = *(void *)(a1 + 576);
    if (v10) {
      id v9 = sub_100FBE47C(v10, v9);
    }
    sub_100FBBE6C(*(void *)(a1 + 616), v9);
    uint64_t v11 = 1;
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v23);
  *(void *)int buf = &v16;
  sub_10019EAF0((void ***)buf);
  if (v11) {
    sub_100F937E8(a1);
  }
  return v11;
}

void sub_100F953A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void **a19)
{
  a19 = (void **)&a10;
  sub_10019EAF0(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100F953E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  sub_1001B56C8(&v16, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3));
  uint64_t v23 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v23);
  char v3 = v16;
  if (v16 == v17) {
    goto LABEL_20;
  }
  LOBYTE(v4) = 1;
  do
  {
    if (v4)
    {
      int v4 = *v3;
      if (*v3) {
        int v4 = *((unsigned char *)v3 + 32) != 0;
      }
    }
    else
    {
      int v4 = 0;
    }
    v3 += 10;
  }
  while (v3 != v17);
  if (!v4)
  {
LABEL_20:
    uint64_t v12 = *(NSObject **)(a1 + 40);
    uint64_t v11 = 0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v14 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v25 = 2080;
      __int16 v26 = " ";
      __int16 v27 = 2080;
      uint64_t v28 = v14;
      __int16 v29 = 2080;
      __int16 v30 = "";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sDisable push notificaiton request is not valid", buf, 0x2Au);
      uint64_t v11 = 0;
    }
  }
  else
  {
    sub_100F94478(&v21, a1, -1);
    if (v22) {
      sub_10004D2C8(v22);
    }
    id v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v7 = *(void *)(a1 + 160);
      sub_100C918E4(&v16, __p);
      uint64_t v8 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v25 = 2080;
      __int16 v26 = " ";
      __int16 v27 = 2080;
      uint64_t v28 = v7;
      __int16 v29 = 2080;
      __int16 v30 = "";
      __int16 v31 = 2080;
      __int16 v32 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdding disable push notification with %s", buf, 0x34u);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    id v9 = sub_100FB69BC((uint64_t *)&v16);
    uint64_t v10 = *(void *)(a1 + 576);
    if (v10) {
      id v9 = sub_100FBE55C(v10, v9);
    }
    sub_100FBE4EC(*(void *)(a1 + 616), v9);
    uint64_t v11 = 1;
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v23);
  *(void *)int buf = &v16;
  sub_10019EBDC((void ***)buf);
  if (v11) {
    sub_100F937E8(a1);
  }
  return v11;
}

void sub_100F95688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void **a19)
{
  a19 = (void **)&a10;
  sub_10019EBDC(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100F956CC(uint64_t a1, uint64_t **a2)
{
  uint64_t v9 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F94478(&v7, a1, -1);
  if (v8) {
    sub_10004D2C8(v8);
  }
  id v4 = sub_100FB6C10(a2);
  uint64_t v5 = *(void *)(a1 + 576);
  if (v5) {
    id v4 = sub_100FBE644(v5, v4);
  }
  sub_100FBE5CC(*(void *)(a1 + 616), v4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F95758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F95770(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 576);
  if (v4) {
    BOOL v5 = sub_100FBA740(v4, a2) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t v6 = a1 + 592;
  for (uint64_t i = *(void *)(a1 + 600); i != v6; uint64_t i = *(void *)(i + 8))
  {
    if (sub_100FBA740(*(void *)(i + 16), a2)) {
      return v6 != i || v5;
    }
  }
  uint64_t i = v6;
  return v6 != i || v5;
}

uint64_t sub_100F957F0(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v8 = sub_100FBEEBC(*(void *)(a1 + 616), a3, a4);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F95888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F958A0(uint64_t a1, void *a2)
{
  sub_100F94478(&v5, a1, -1);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100FC0618(*(void *)(a1 + 616), a2);
  sub_100F937E8(a1);
  return 1;
}

BOOL sub_100F95900(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  if ((a4 & 1) == 0 && *(unsigned char *)(a1 + 384)) {
    return 0;
  }
  *(unsigned char *)(a1 + 384) = 0;
  uint64_t v20 = 0;
  *(_OWORD *)std::string __p = 0u;
  long long v19 = 0u;
  *(_OWORD *)uint64_t v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  uint64_t v7 = *(char *)(a2 + 23) >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  if (v7)
  {
    *(void *)int buf = 0;
    ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)buf);
    sub_100F94478(&v21, a1, -1);
    if (v22) {
      sub_10004D2C8(v22);
    }
    id v8 = sub_100FB6CBC((uint64_t *)a2);
    uint64_t v9 = *(void *)(a1 + 576);
    if (v9) {
      id v8 = sub_100FBE72C(v9, v8);
    }
    sub_100FBE6B4(*(void *)(a1 + 616), v8);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)buf);
    sub_10005EDC0(&v15, &v21);
    uint64_t v10 = v22;
    *(void *)int buf = v21;
    *(void *)&uint8_t buf[8] = v22;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    sub_100F941D4(a1, (uint64_t *)buf, a3);
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    sub_100F937E8(a1);
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v13 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v24 = 2080;
      uint64_t v25 = v13;
      __int16 v26 = 2080;
      __int16 v27 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sempty token", buf, 0x2Au);
    }
  }
  if ((_BYTE)v20 && SHIBYTE(v19) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]))
  {
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[1]);
    }
  }
  return v7 != 0;
}

void sub_100F95B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_10016A3E8((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL sub_100F95B58(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a3 + 8);
  }
  if (v6) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = *(unsigned char *)(a3 + 168) == 0;
  }
  if (!v7)
  {
    if (*(char *)(a3 + 127) < 0)
    {
      uint64_t v6 = *(void *)(a3 + 112);
      if (v6) {
        goto LABEL_11;
      }
      goto LABEL_17;
    }
    uint64_t v6 = *(unsigned __int8 *)(a3 + 127);
  }
  if (v6)
  {
LABEL_11:
    *(void *)int buf = 0;
    ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)buf);
    sub_100F94478(&v15, a1, -1);
    if (v16) {
      sub_10004D2C8(v16);
    }
    id v8 = sub_100FB6D38(a3);
    uint64_t v9 = *(void *)(a1 + 576);
    if (v9) {
      id v8 = sub_100FBE810(v9, v8);
    }
    uint64_t v10 = sub_100FBE79C(*(void *)(a1 + 616), v8);
    sub_100F9461C(a1, v10, a2);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)buf);
    sub_100F937E8(a1);
    return v6 != 0;
  }
LABEL_17:
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v13 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v12;
    __int16 v18 = 2080;
    long long v19 = " ";
    __int16 v20 = 2080;
    uint64_t v21 = v13;
    __int16 v22 = 2080;
    uint64_t v23 = "";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sempty iccid", buf, 0x2Au);
  }
  return v6 != 0;
}

void sub_100F95CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

BOOL sub_100F95D1C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v4 = *(void *)(a3 + 8);
  }
  if (v4)
  {
    *(void *)int buf = 0;
    ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)buf);
    sub_100F94478(&v14, a1, -1);
    if (v15) {
      sub_10004D2C8(v15);
    }
    id v7 = sub_100FB737C(a3);
    uint64_t v8 = *(void *)(a1 + 576);
    if (v8) {
      id v7 = sub_100FBE8F4(v8, v7);
    }
    uint64_t v9 = sub_100FBE880(*(void *)(a1 + 616), v7);
    sub_100F9461C(a1, v9, a2);
    ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)buf);
    sub_100F937E8(a1);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v12 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v17 = 2080;
      __int16 v18 = " ";
      __int16 v19 = 2080;
      uint64_t v20 = v12;
      __int16 v21 = 2080;
      __int16 v22 = "";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%ssignUpForSIMService request is not valid", buf, 0x2Au);
    }
  }
  return v4 != 0;
}

void sub_100F95E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F95EBC(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = sub_100FB79DC(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBD824(v7, v6);
  }
  uint64_t v8 = sub_100FBD7B0(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F95F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F95F80(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = sub_100FB7AFC(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBD908(v7, v6);
  }
  uint64_t v8 = sub_100FBD894(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96044(uint64_t a1, uint64_t *a2, uint64_t ***a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = sub_100FB7BAC(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBD9EC(v7, v6);
  }
  uint64_t v8 = sub_100FBD978(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F960EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96108(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = sub_100FB7D5C(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBDAD0(v7, v6);
  }
  uint64_t v8 = sub_100FBDA5C(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F961B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F961CC(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F94478(&v7, a1, -1);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v4 = *(void *)(a1 + 576);
  if (!v4 || !sub_100FBA740(v4, 16))
  {
    id v5 = sub_100FBE964(*(void *)(a1 + 616));
    sub_100F9461C(a1, v5, a2);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F9627C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = sub_100FB7ED0(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBEA40(v7, v6);
  }
  uint64_t v8 = sub_100FBE9CC(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96340(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = codec::toJSONObject(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBEB98(v7, v6);
  }
  uint64_t v8 = sub_100FBEAB0(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F963E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96404(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v12 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F94478(&v10, a1, -1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v6 = codec::toJSONObject(a3);
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBEC08(v7, v6);
  }
  uint64_t v8 = sub_100FBEB24(*(void *)(a1 + 616), v6);
  sub_100F9461C(a1, v8, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v12);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F964AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void sub_100F964C8(uint64_t a1, uint64_t *a2, const void **a3)
{
  if (objc_opt_class() && (dispatch_queue_t v6 = dispatch_queue_create("com.apple.CommCenter.ent.ids_auth", 0)) != 0)
  {
    uint64_t v7 = v6;
    uint64_t v21 = 0;
    __int16 v22 = &v21;
    uint64_t v23 = 0x3052000000;
    __int16 v24 = sub_100F96804;
    uint64_t v25 = sub_100F96814;
    id v26 = 0;
    id v26 = [objc_alloc((Class)IDSPhoneCertificateVendor) initWithQueue:v6];
    if (v22[5])
    {
      if (*(_DWORD *)(***(void ***)(a1 + 128) + 52) == 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = 2;
      }
      id v9 = objc_alloc((Class)IDSCarrierTokenRequestParameters);
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = (void *)(v10 + 16);
      if (*(char *)(v10 + 39) < 0) {
        uint64_t v11 = (void *)*v11;
      }
      uint64_t v12 = +[NSString stringWithUTF8String:v11];
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v13 = a2;
      }
      else {
        uint64_t v13 = (uint64_t *)*a2;
      }
      id v14 = objc_msgSend(v9, "initWithSubscriptionSource:IMEI:carrierNonce:", v8, v12, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13));
      if (*a3) {
        uint64_t v15 = _Block_copy(*a3);
      }
      else {
        uint64_t v15 = 0;
      }
      __int16 v17 = (void *)v22[5];
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3321888768;
      void v19[2] = sub_100F96820;
      void v19[3] = &unk_101A776B8;
      v19[5] = a1;
      if (v15) {
        __int16 v18 = _Block_copy(v15);
      }
      else {
        __int16 v18 = 0;
      }
      aBlock = v18;
      v19[4] = &v21;
      [v17 requestCarrierTokenWithParameters:v14 completion:v19];
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (v15) {
        _Block_release(v15);
      }
    }
    else
    {
      sub_100F96780((uint64_t)*a3, 0);
    }
    _Block_object_dispose(&v21, 8);
    dispatch_release(v7);
  }
  else
  {
    uint64_t v16 = *a3;
    sub_100F96780((uint64_t)v16, 0);
  }
}

void sub_100F9671C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *aBlock, char a17)
{
  _Block_object_dispose(&a17, 8);
  dispatch_release(v17);
  _Unwind_Resume(a1);
}

void sub_100F96780(uint64_t a1, char a2)
{
  v2[0] = 2;
  LOBYTE(__p) = a2;
  (*(void (**)(uint64_t, char *))(a1 + 16))(a1, v2);
  if (v2[0] == 1 && v4 < 0) {
    operator delete(__p);
  }
}

void sub_100F967DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a9 == 1 && a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F96804(uint64_t a1, uint64_t a2)
{
}

void sub_100F96814(uint64_t a1)
{
}

void sub_100F96820(void *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a1[5];
  uint64_t v7 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v6 + 128));
    uint64_t v9 = *(void *)(v6 + 160);
    *(_DWORD *)int buf = 136316162;
    *(void *)std::string __p = v8;
    *(_WORD *)&__p[8] = 2080;
    *(void *)&__p[10] = " ";
    *(_WORD *)&__p[18] = 2080;
    uint64_t v15 = v9;
    __int16 v16 = 2080;
    __int16 v17 = "";
    __int16 v18 = 1024;
    BOOL v19 = a3 == 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sDone request IDS token: %d", buf, 0x30u);
  }
  if (a3 || !objc_msgSend(objc_msgSend(a2, "tokenString"), "length"))
  {
    sub_100F96780(a1[6], 0);
  }
  else
  {
    sub_100058DB0(v11, (char *)objc_msgSend(objc_msgSend(a2, "tokenString"), "UTF8String"));
    uint64_t v10 = a1[6];
    buf[0] = 1;
    *(_OWORD *)&__p[4] = *(_OWORD *)v11;
    uint64_t v15 = v12;
    v11[1] = 0;
    uint64_t v12 = 0;
    v11[0] = 0;
    (*(void (**)(void))(v10 + 16))();
    if (buf[0] == 1 && SHIBYTE(v15) < 0) {
      operator delete(*(void **)&__p[4]);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[0]);
    }
  }
}

void sub_100F969DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 == 1 && a22 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F96A1C(uint64_t a1, uint64_t a2)
{
  BOOL result = *(void **)(a2 + 48);
  if (result) {
    BOOL result = _Block_copy(result);
  }
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_100F96A50(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 48);
  if (v1) {
    _Block_release(v1);
  }
}

uint64_t sub_100F96A74(uint64_t a1)
{
  uint64_t v6 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v6);
  sub_100F94478(&v4, a1, -1);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v2 = *(void *)(a1 + 576);
  if (!v2 || !sub_100FBA740(v2, 19)) {
    sub_100FBEC78(*(void *)(a1 + 616));
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v6);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96B0C(uint64_t a1)
{
  uint64_t v6 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v6);
  sub_100F94478(&v4, a1, -1);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v2 = *(void *)(a1 + 576);
  if (!v2 || !sub_100FBA740(v2, 8)) {
    sub_100FBECE4(*(void *)(a1 + 616));
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v6);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96BA4(uint64_t a1, id *a2)
{
  uint64_t v9 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F94478(&v7, a1, -1);
  if (v8) {
    sub_10004D2C8(v8);
  }
  id v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 576);
  if (v5) {
    id v4 = sub_100FBEDD0(v5, 9, v4);
  }
  sub_100FBED50(*(void *)(a1 + 616), 9, v4, 0);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v9);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96C58(uint64_t a1, id *a2)
{
  uint64_t v7 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v7);
  sub_100F94478(&v5, a1, -1);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100FBEE3C(*(void *)(a1 + 616), 10, *a2, 0);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v7);
  sub_100F937E8(a1);
  return 1;
}

void sub_100F96CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96CF8(uint64_t a1, int a2)
{
  uint64_t v10 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v10);
  sub_100F94478(&v8, a1, -1);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v4 = *(void *)(a1 + 576);
  if (!v4 || !sub_100FBA740(v4, 21))
  {
    uint64_t v5 = *(void *)(a1 + 616);
    id v6 = sub_100FB808C(a2);
    sub_100FBBF60(v5, v6);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v10);
  return 1;
}

void sub_100F96D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96D9C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v11 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v11);
  sub_100F94478(&v9, a1, -1);
  if (v10) {
    sub_10004D2C8(v10);
  }
  id v6 = *(id *)a3;
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBEDD0(v7, a2, v6);
  }
  sub_100FBED50(*(void *)(a1 + 616), a2, v6, *(void *)(a3 + 8));
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v11);
  return 1;
}

void sub_100F96E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F96E54(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v11 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v11);
  sub_100F94478(&v9, a1, -1);
  if (v10) {
    sub_10004D2C8(v10);
  }
  id v6 = *(id *)a3;
  uint64_t v7 = *(void *)(a1 + 576);
  if (v7) {
    id v6 = sub_100FBEDD0(v7, a2, v6);
  }
  sub_100FBEE3C(*(void *)(a1 + 616), a2, v6, *(void *)(a3 + 8));
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v11);
  return 1;
}

void sub_100F96EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

void sub_100F96F10(uint64_t a1)
{
  uint64_t v1 = ***(void ***)(a1 + 128);
  if (!*(unsigned char *)(v1 + 49))
  {
    uint64_t v3 = *(void *)(a1 + 808);
    if (v3)
    {
      int v4 = *(_DWORD *)(v1 + 52);
      uint64_t v5 = a1 + 808;
      do
      {
        int v6 = *(_DWORD *)(v3 + 28);
        BOOL v7 = v6 < v4;
        if (v6 >= v4) {
          uint64_t v8 = (uint64_t *)v3;
        }
        else {
          uint64_t v8 = (uint64_t *)(v3 + 8);
        }
        if (!v7) {
          uint64_t v5 = v3;
        }
        uint64_t v3 = *v8;
      }
      while (*v8);
      if (v5 != a1 + 808 && v4 >= *(_DWORD *)(v5 + 28) && *(unsigned char *)(v5 + 32))
      {
        sub_100CECA44(a1, (uint64_t)"Became data attached", 0);
        uint64_t v9 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v11 = *(void *)(a1 + 160);
          int v12 = 136315906;
          uint64_t v13 = v10;
          __int16 v14 = 2080;
          uint64_t v15 = " ";
          __int16 v16 = 2080;
          uint64_t v17 = v11;
          __int16 v18 = 2080;
          BOOL v19 = "";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sBecame data attached, issuing any pending transactions", (uint8_t *)&v12, 0x2Au);
        }
        sub_100F937E8(a1);
      }
    }
  }
}

unint64_t sub_100F9706C(uint64_t a1, uint64_t a2)
{
  if (sub_100FBA740(*(void *)(a1 + 576), 28))
  {
    if (*(unsigned char *)(a1 + 504))
    {
      if (*(char *)(a1 + 503) < 0) {
        operator delete(*(void **)(a1 + 480));
      }
      *(unsigned char *)(a1 + 504) = 0;
    }
    uint64_t v5 = *(unsigned int **)(*(void *)a2 + 448);
    int v4 = *(std::__shared_weak_count **)(*(void *)a2 + 456);
    int v6 = 28;
    if (v4) {
LABEL_7:
    }
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    if (!sub_100FBA740(*(void *)(a1 + 576), 29))
    {
      uint64_t v13 = 6000;
      unsigned int v12 = 1;
      return ((unint64_t)v12 << 8) | 1 | (v13 << 32);
    }
    uint64_t v5 = *(unsigned int **)(*(void *)a2 + 464);
    int v4 = *(std::__shared_weak_count **)(*(void *)a2 + 472);
    int v6 = 29;
    if (v4) {
      goto LABEL_7;
    }
  }
  if (v5)
  {
    BOOL v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v9 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v9;
      LOWORD(v161[0]) = 2080;
      *(void *)((char *)v161 + 2) = "";
      WORD5(v161[0]) = 2080;
      *(void *)((char *)v161 + 12) = "authentication";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________   Received response: %s", buf, 0x34u);
    }
    uint64_t v10 = (char *)operator new(0x270uLL);
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
    *(void *)uint64_t v10 = off_101A78ED0;
    v10[24] = 0;
    v10[32] = 0;
    v10[56] = 0;
    v10[64] = 0;
    v10[88] = 0;
    v10[96] = 0;
    v10[120] = 0;
    v10[128] = 0;
    v10[584] = 0;
    v10[592] = 0;
    v10[616] = 0;
    v145 = v10 + 24;
    v146 = (std::__shared_weak_count *)v10;
    uint64_t v11 = *((void *)v5 + 1);
    v10[24] = *(unsigned char *)v11;
    sub_100179AF8((std::string *)(v10 + 32), (const std::string *)(v11 + 8));
    sub_100179AF8((std::string *)(v10 + 64), (const std::string *)(v11 + 40));
    sub_100179AF8((std::string *)v10 + 4, (const std::string *)(v11 + 72));
    sub_1001A1CE4(v10 + 128, v11 + 104);
    sub_100179AF8((std::string *)(v10 + 592), (const std::string *)(v11 + 568));
    unsigned int v12 = 0;
    uint64_t v13 = *v5;
    if ((int)v13 > 6005)
    {
      if (v13 == 6006)
      {
        memset(__p, 0, sizeof(__p));
        CFDictionaryRef theDict = 0;
        v136 = 0;
        v137 = 0;
        sub_100FBA50C(*(void *)(a1 + 576), v6, (const void **)&theDict);
        if (theDict) {
          BOOL v19 = sub_100080778;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19)
        {
          CFBooleanRef Value = CFDictionaryGetValue(theDict, @"service-token");
          if (Value)
          {
            CFTypeID v21 = CFGetTypeID(Value);
            if (v21 == CFStringGetTypeID()) {
              goto LABEL_43;
            }
          }
          if ((__int16 v22 = CFDictionaryGetValue(theDict, @"transfer-token")) != 0
            && (CFTypeID v23 = CFGetTypeID(v22), v23 == CFStringGetTypeID())
            || (CFDictionaryRef v28 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"unblinded-data"), (v29 = v28) != 0)
            && (CFTypeID v30 = CFGetTypeID(v28), v30 == CFDictionaryGetTypeID())
            && (__int16 v31 = CFDictionaryGetValue(v29, @"unblinded-sig")) != 0
            && (CFTypeID v32 = CFGetTypeID(v31), v32 == CFStringGetTypeID()))
          {
LABEL_43:
            memset(buf, 0, 24);
            ctu::cf::assign();
            __int16 v24 = *(void **)buf;
            *(void *)v187 = *(void *)&buf[8];
            *(void *)&v187[7] = *(void *)&buf[15];
            char v25 = buf[23];
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
            __p[0] = v24;
            __p[1] = *(void **)v187;
            *(void **)((char *)&__p[1] + 7) = *(void **)&v187[7];
            HIBYTE(__p[2]) = v25;
          }
        }
        long long v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v35 = *(void *)(a1 + 160);
          long long v36 = __p;
          if (SHIBYTE(__p[2]) < 0) {
            long long v36 = (void **)__p[0];
          }
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v34;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v35;
          LOWORD(v161[0]) = 2080;
          *(void *)((char *)v161 + 2) = "";
          WORD5(v161[0]) = 2080;
          *(void *)((char *)v161 + 12) = v36;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sservice_token_expired: '%s'", buf, 0x34u);
        }
        uint64_t v37 = ***(void ***)(a1 + 128);
        if (*(char *)(v37 + 47) < 0)
        {
          sub_10004FC84(v133, *(void **)(v37 + 24), *(void *)(v37 + 32));
        }
        else
        {
          *(_OWORD *)v133 = *(_OWORD *)(v37 + 24);
          uint64_t v134 = *(void *)(v37 + 40);
        }
        if (SHIBYTE(__p[2]) < 0)
        {
          sub_10004FC84(v131, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)v131 = *(_OWORD *)__p;
          v132 = __p[2];
        }
        if (SHIBYTE(v134) < 0)
        {
          sub_10004FC84(v151, v133[0], (unint64_t)v133[1]);
        }
        else
        {
          *(_OWORD *)v151 = *(_OWORD *)v133;
          uint64_t v152 = v134;
        }
        if (SHIBYTE(v132) < 0)
        {
          sub_10004FC84(v149, v131[0], (unint64_t)v131[1]);
        }
        else
        {
          *(_OWORD *)v149 = *(_OWORD *)v131;
          v150 = v132;
        }
        *(void *)&long long v174 = 0;
        long long v172 = 0u;
        long long v173 = 0u;
        long long v170 = 0u;
        long long v171 = 0u;
        long long v168 = 0u;
        long long v169 = 0u;
        long long v166 = 0u;
        long long v167 = 0u;
        long long v164 = 0u;
        long long v165 = 0u;
        *(_OWORD *)v162 = 0u;
        long long v163 = 0u;
        memset(v161, 0, sizeof(v161));
        memset(buf, 0, sizeof(buf));
        sub_10004DE24((uint64_t)buf);
        long long v38 = (void *)HIBYTE(v152);
        if (v152 < 0) {
          long long v38 = v151[1];
        }
        long long v39 = v151;
        if (v152 < 0) {
          long long v39 = (void **)v151[0];
        }
        if (v38) {
          long long v40 = (const char *)v39;
        }
        else {
          long long v40 = "<invalid>";
        }
        size_t v41 = strlen(v40);
        long long v42 = sub_10004B96C(buf, (uint64_t)v40, v41);
        uint64_t v43 = sub_10004B96C(v42, (uint64_t)", ", 2);
        if (SHIBYTE(v150) >= 0) {
          id v44 = v149;
        }
        else {
          id v44 = (void **)v149[0];
        }
        if (SHIBYTE(v150) >= 0) {
          uint64_t v45 = HIBYTE(v150);
        }
        else {
          uint64_t v45 = (uint64_t)v149[1];
        }
        sub_10004B96C(v43, (uint64_t)v44, v45);
        sub_10004BC98((uint64_t)&buf[8], v187);
        sub_1001AA668(&qword_101B13F88, (uint64_t *)v187);
        if ((v187[23] & 0x80000000) != 0) {
          operator delete(*(void **)v187);
        }
        if (SHIBYTE(v163) < 0) {
          operator delete(v162[1]);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        std::ios::~ios();
        if (SHIBYTE(v150) < 0) {
          operator delete(v149[0]);
        }
        if (SHIBYTE(v152) < 0) {
          operator delete(v151[0]);
        }
        uint64_t v46 = (uint64_t *)sub_100B3917C(&qword_101B13F78);
        long long v159 = 0uLL;
        long long v168 = 0u;
        long long v169 = 0u;
        long long v166 = 0u;
        long long v167 = 0u;
        long long v164 = 0u;
        long long v165 = 0u;
        *(_OWORD *)v162 = 0u;
        long long v163 = 0u;
        memset(v161, 0, sizeof(v161));
        memset(buf, 0, sizeof(buf));
        __int16 v47 = (pthread_mutex_t *)sub_100060E64(v46 + 3);
        sub_100061F70(buf, v47);
        uint64_t v48 = v46[1];
        if (v48)
        {
          if (atomic_load_explicit((atomic_uint *volatile)(v48 + 8), memory_order_acquire) == 1) {
            sub_100B397EC(v46, buf, 0, 1);
          }
          uint64_t v49 = *v46;
          uint64_t v50 = v46[1];
          if (v50) {
            atomic_fetch_add_explicit((atomic_uint *volatile)(v50 + 8), 1u, memory_order_relaxed);
          }
        }
        else
        {
          uint64_t v50 = 0;
          uint64_t v49 = *v46;
        }
        long long v51 = v159;
        *(void *)&long long v159 = v49;
        *((void *)&v159 + 1) = v50;
        *(_OWORD *)v187 = v51;
        sub_10000A740((atomic_uint **)&v187[8]);
        sub_10000A6C8(*((pthread_mutex_t **)&v169 + 1));
        sub_10000A5F8(buf);
        long long v171 = 0u;
        long long v172 = 0u;
        long long v169 = 0u;
        long long v170 = 0u;
        long long v167 = 0u;
        long long v168 = 0u;
        long long v165 = 0u;
        long long v166 = 0u;
        long long v163 = 0u;
        long long v164 = 0u;
        *(_OWORD *)v162 = 0u;
        memset(v161, 0, sizeof(v161));
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v173 = 0;
        *((void *)&v173 + 1) = 10;
        *(void *)&long long v174 = &buf[8];
        *((void *)&v174 + 1) = 0;
        *(void *)&long long v175 = v133;
        *((void *)&v175 + 1) = v131;
        long long v176 = 0uLL;
        xpc_object_t v52 = (uint64_t *)sub_100B39448((uint64_t *)&v159);
        uint64_t v53 = sub_100B3A7AC(v52);
        v156 = buf;
        v157 = (std::__shared_weak_count *)v46;
        uint64_t v158 = v53;
        uint64_t v54 = sub_100B39448((uint64_t *)&v159);
        sub_100060EA8((uint64_t *)(v54 + 16));
        long long v55 = (uint64_t *)sub_100B39448((uint64_t *)&v159);
        long long v56 = *(void **)(sub_100B3A7AC(v55) + 8);
        long long v57 = (uint64_t *)sub_100B39448((uint64_t *)&v159);
        long long v58 = (void *)sub_100B3A7AC(v57);
        v147[0] = v56;
        v147[1] = v58;
        *(void *)&long long v148 = buf;
        *((void *)&v148 + 1) = v58;
        sub_100FB1C44((uint64_t *)v147);
        long long v59 = (uint64_t *)sub_100B39448((uint64_t *)&v159);
        long long v60 = (void *)sub_100B3A7AC(v59);
        long long v61 = (uint64_t *)sub_100B39448((uint64_t *)&v159);
        long long v62 = (void *)sub_100B3A7AC(v61);
        v153[0] = v60;
        v153[1] = v62;
        v154 = buf;
        v155 = v62;
        sub_100FB1C44((uint64_t *)v153);
        *(_OWORD *)v187 = *(_OWORD *)v147;
        *(_OWORD *)&v187[16] = v148;
        long long v63 = v153[0];
        long long v64 = (uint64_t *)v147[0];
        if (v147[0] != v153[0])
        {
          uint64_t v65 = *(unsigned char **)&v187[16];
          BOOL v66 = **(unsigned char **)&v187[16] == 0;
          do
          {
            if (v66)
            {
              uint64_t v67 = sub_100B3948C(v64 + 2);
              uint64_t v68 = sub_100B39F3C((uint64_t *)(v67 + 32));
              sub_100B3ADD4((void *)(v68 + 24));
              if (!*v65) {
                *uint64_t v65 = 1;
              }
            }
            if (!**(unsigned char **)&v187[16]) {
              __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
            }
            *(void *)v187 = *(void *)(*(void *)v187 + 8);
            sub_100FB1C44((uint64_t *)v187);
            uint64_t v65 = *(unsigned char **)&v187[16];
            if (**(unsigned char **)&v187[16]) {
              **(unsigned char **)&v187[16] = 0;
            }
            long long v64 = *(uint64_t **)v187;
            BOOL v66 = 1;
          }
          while (*(void **)v187 != v63);
        }
        sub_100FB1FC0(&v156);
        sub_100FB2188((uint64_t)buf);
        sub_10000A740((atomic_uint **)&v159 + 1);
        if (SHIBYTE(v132) < 0) {
          operator delete(v131[0]);
        }
        if (SHIBYTE(v134) < 0) {
          operator delete(v133[0]);
        }
        sub_1000577C4(&v137);
        sub_1000577C4(&v136);
        sub_100057D78((const void **)&theDict);
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
          goto LABEL_119;
        }
        __int16 v27 = __p[0];
        goto LABEL_118;
      }
      if (v13 == 6302)
      {
        uint64_t v16 = (uint64_t)v145;
        if (v145[64])
        {
          long long v17 = *(_OWORD *)(a1 + 536);
          *(void *)(a1 + 536) = 0;
          *(void *)(a1 + 544) = 0;
          __int16 v18 = *(std::__shared_weak_count **)(a1 + 560);
          *(_OWORD *)(a1 + 552) = v17;
          if (v18)
          {
            sub_10004D2C8(v18);
            uint64_t v16 = (uint64_t)v145;
          }
          sub_100179AF8((std::string *)(a1 + 480), (const std::string *)(v16 + 568));
          if (*(char *)(a1 + 455) < 0)
          {
            **(unsigned char **)(a1 + 432) = 0;
            *(void *)(a1 + 440) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 432) = 0;
            *(unsigned char *)(a1 + 455) = 0;
          }
          if (*(char *)(a1 + 479) < 0)
          {
            **(unsigned char **)(a1 + 456) = 0;
            *(void *)(a1 + 464) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 456) = 0;
            *(unsigned char *)(a1 + 479) = 0;
          }
          v151[0] = 0;
          ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)v151);
          int v69 = *(_DWORD *)(a1 + 172);
          char v70 = *(NSObject **)(a1 + 40);
          BOOL v71 = os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT);
          if (v69 == 1)
          {
            if (v71)
            {
              uint64_t v72 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v73 = *(void *)(a1 + 160);
              *(_DWORD *)int buf = 136315906;
              *(void *)&uint8_t buf[4] = v72;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&uint8_t buf[24] = v73;
              LOWORD(v161[0]) = 2080;
              *(void *)((char *)v161 + 2) = "";
              _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived an EAP_AKA challenge", buf, 0x2Au);
            }
            v153[0] = 0;
            v153[1] = 0;
            v154 = 0;
            ctu::base64::decode();
            sub_1010E78C4(v187);
          }
          if (v71)
          {
            uint64_t v74 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v75 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v74;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v75;
            LOWORD(v161[0]) = 2080;
            *(void *)((char *)v161 + 2) = "";
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnsupported Authentication Type", buf, 0x2Au);
          }
          ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)v151);
          unsigned int v12 = 0;
          *(_DWORD *)(a1 + 176) = 0;
          goto LABEL_189;
        }
        goto LABEL_119;
      }
LABEL_189:
      *(void *)&uint8_t buf[8] = 0;
      *(void *)int buf = 0;
      LODWORD(v147[0]) = *v5;
      sub_100FB227C((int *)v147, (uint64_t *)&v145, buf);
      v147[0] = 0;
      v147[1] = 0;
      uint64_t v105 = *(void *)(a1 + 576);
      uint64_t v129 = *(void *)buf;
      v130 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      LOBYTE(v153[0]) = 0;
      BYTE4(v153[0]) = 0;
      v127 = 0;
      v128 = 0;
      sub_100F9920C((uint64_t)v147, *(void *)(v105 + 96), 28, (uint64_t)&v129, (uint64_t)v153, &v128);
      sub_1000577C4(&v127);
      sub_100057D78(&v128);
      if (v130) {
        sub_10004D2C8(v130);
      }
      uint64_t v106 = *(void *)(a1 + 576);
      v107 = (std::__shared_weak_count *)v147[1];
      v125 = v147[0];
      v126 = (std::__shared_weak_count *)v147[1];
      if (v147[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v147[1] + 1, 1uLL, memory_order_relaxed);
      }
      v123 = 0;
      v124 = 0;
      sub_100F992F4(a1, v106, 28, 3, (uint64_t *)&v125, &v124, &v123);
      sub_1000577C4(&v123);
      sub_100057D78(&v124);
      if (v126) {
        sub_10004D2C8(v126);
      }
      if (v107) {
        sub_10004D2C8(v107);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v146) {
        sub_10004D2C8(v146);
      }
      goto LABEL_203;
    }
    if (v13 != 6000)
    {
      if (v13 == 6004)
      {
        __int16 v14 = *(uint64_t ***)(a1 + 128);
        if (!*((unsigned char *)v14 + 465))
        {
          sub_100CEE094(a1);
          __int16 v14 = *(uint64_t ***)(a1 + 128);
        }
        uint64_t v15 = **v14;
        *(_DWORD *)int buf = 1;
        if (*(char *)(v15 + 47) < 0)
        {
          sub_10004FC84(&buf[8], *(void **)(v15 + 24), *(void *)(v15 + 32));
        }
        else
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v15 + 24);
          *(void *)&uint8_t buf[24] = *(void *)(v15 + 40);
        }
        sub_1001AA030(a1 + 88, (int *)buf);
        if ((buf[31] & 0x80000000) != 0) {
          operator delete(*(void **)&buf[8]);
        }
        uint64_t v26 = ***(void ***)(a1 + 128);
        if (*(char *)(v26 + 47) < 0)
        {
          sub_10004FC84(&__dst, *(void **)(v26 + 24), *(void *)(v26 + 32));
        }
        else
        {
          long long __dst = *(_OWORD *)(v26 + 24);
          uint64_t v140 = *(void *)(v26 + 40);
        }
        sub_10018B390((uint64_t)&event::entitlements::auth_unknown_subscriber, (uint64_t)&__dst);
        if ((SHIBYTE(v140) & 0x80000000) == 0) {
          goto LABEL_119;
        }
        __int16 v27 = (void *)__dst;
LABEL_118:
        operator delete(v27);
LABEL_119:
        unsigned int v12 = 0;
        goto LABEL_189;
      }
      goto LABEL_189;
    }
    long long v185 = 0u;
    long long v186 = 0u;
    long long v183 = 0u;
    long long v184 = 0u;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    long long v177 = 0u;
    long long v178 = 0u;
    long long v175 = 0u;
    long long v176 = 0u;
    long long v173 = 0u;
    long long v174 = 0u;
    long long v171 = 0u;
    long long v172 = 0u;
    long long v169 = 0u;
    long long v170 = 0u;
    long long v167 = 0u;
    long long v168 = 0u;
    long long v165 = 0u;
    long long v166 = 0u;
    long long v163 = 0u;
    long long v164 = 0u;
    *(_OWORD *)v162 = 0u;
    memset(v161, 0, sizeof(v161));
    memset(buf, 0, sizeof(buf));
    sub_1001A16A8(buf, (uint64_t)(v145 + 104));
    if (BYTE8(v186)) {
      sub_100093B44((std::string *)buf, (const std::string *)(a1 + 208));
    }
    sub_1001A1CE4(v145 + 104, (uint64_t)buf);
    *(_OWORD *)v147 = 0u;
    long long v148 = 0u;
    sub_1000593FC((uint64_t)v147, (long long *)(v145 + 8));
    if (!BYTE8(v148))
    {
LABEL_182:
      if (!*(unsigned char *)(***(void ***)(a1 + 128) + 49))
      {
        v109 = *(std::__shared_weak_count **)(a1 + 112);
        if (v109)
        {
          v110 = std::__shared_weak_count::lock(v109);
          if (v110)
          {
            v111 = v110;
            uint64_t v112 = *(void *)(a1 + 104);
            if (v112)
            {
              v113 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v113 || (v114 = *(void **)(a1 + 8), (v115 = std::__shared_weak_count::lock(v113)) == 0)) {
                sub_100088B9C();
              }
              v156 = v114;
              v157 = v115;
              uint64_t v116 = *(void *)(a1 + 128);
              if (*(char *)(v116 + 87) < 0)
              {
                sub_10004FC84(v143, *(void **)(v116 + 64), *(void *)(v116 + 72));
              }
              else
              {
                *(_OWORD *)v143 = *(_OWORD *)(v116 + 64);
                v144 = *(unsigned char **)(v116 + 80);
              }
              if (SHIBYTE(v144) < 0)
              {
                sub_10004FC84(v153, v143[0], (unint64_t)v143[1]);
              }
              else
              {
                *(_OWORD *)v153 = *(_OWORD *)v143;
                v154 = v144;
              }
              __p[0] = 0;
              if (SHIBYTE(v154) < 0)
              {
                sub_10004FC84(v187, v153[0], (unint64_t)v153[1]);
              }
              else
              {
                *(_OWORD *)v187 = *(_OWORD *)v153;
                *(void *)&v187[16] = v154;
              }
              v149[0] = 0;
              if (ctu::cf::convert_copy())
              {
                v117 = __p[0];
                __p[0] = v149[0];
                v151[0] = v117;
                sub_1000558F4((const void **)v151);
              }
              if ((v187[23] & 0x80000000) != 0) {
                operator delete(*(void **)v187);
              }
              CFDictionaryRef theDict = (CFDictionaryRef)__p[0];
              __p[0] = 0;
              sub_1000558F4((const void **)__p);
              if (SHIBYTE(v154) < 0) {
                operator delete(v153[0]);
              }
              (*(void (**)(uint64_t, void **, const __CFString *, CFDictionaryRef, uint64_t))(*(void *)v112 + 48))(v112, &v156, @"kEntitlementsSelfRegistrationUpdateImsi", theDict, 1);
              sub_1000558F4((const void **)&theDict);
              if (SHIBYTE(v144) < 0) {
                operator delete(v143[0]);
              }
              if (v157) {
                sub_10004D2C8(v157);
              }
              v118 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v118 || (v119 = *(void **)(a1 + 8), (v120 = std::__shared_weak_count::lock(v118)) == 0)) {
                sub_100088B9C();
              }
              v156 = v119;
              v157 = v120;
              uint64_t v121 = *(void *)(a1 + 128);
              if (*(char *)(v121 + 39) < 0)
              {
                sub_10004FC84(v141, *(void **)(v121 + 16), *(void *)(v121 + 24));
              }
              else
              {
                *(_OWORD *)v141 = *(_OWORD *)(v121 + 16);
                v142 = *(unsigned char **)(v121 + 32);
              }
              if (SHIBYTE(v142) < 0)
              {
                sub_10004FC84(v153, v141[0], (unint64_t)v141[1]);
              }
              else
              {
                *(_OWORD *)v153 = *(_OWORD *)v141;
                v154 = v142;
              }
              __p[0] = 0;
              if (SHIBYTE(v154) < 0)
              {
                sub_10004FC84(v187, v153[0], (unint64_t)v153[1]);
              }
              else
              {
                *(_OWORD *)v187 = *(_OWORD *)v153;
                *(void *)&v187[16] = v154;
              }
              v149[0] = 0;
              if (ctu::cf::convert_copy())
              {
                v122 = __p[0];
                __p[0] = v149[0];
                v151[0] = v122;
                sub_1000558F4((const void **)v151);
              }
              if ((v187[23] & 0x80000000) != 0) {
                operator delete(*(void **)v187);
              }
              CFDictionaryRef theDict = (CFDictionaryRef)__p[0];
              __p[0] = 0;
              sub_1000558F4((const void **)__p);
              if (SHIBYTE(v154) < 0) {
                operator delete(v153[0]);
              }
              (*(void (**)(uint64_t, void **, const __CFString *, CFDictionaryRef, uint64_t))(*(void *)v112 + 48))(v112, &v156, @"kEntitlementsSelfRegistrationUpdateImei", theDict, 1);
              sub_1000558F4((const void **)&theDict);
              if (SHIBYTE(v142) < 0) {
                operator delete(v141[0]);
              }
              if (v157) {
                sub_10004D2C8(v157);
              }
            }
            sub_10004D2C8(v111);
          }
        }
      }
      *(_DWORD *)(a1 + 176) = 2;
      sub_100F94130(a1);
      if (BYTE8(v148) && SBYTE7(v148) < 0) {
        operator delete(v147[0]);
      }
      if (BYTE8(v186)) {
        sub_10019D6E8((uint64_t)buf);
      }
      unsigned int v12 = 1;
      goto LABEL_189;
    }
    v153[0] = 0;
    v153[1] = 0;
    v154 = 0;
    if (SBYTE7(v148) < 0)
    {
      sub_10004FC84(v153, v147[0], (unint64_t)v147[1]);
    }
    else
    {
      *(_OWORD *)v153 = *(_OWORD *)v147;
      v154 = (unsigned char *)v148;
    }
    v156 = 0;
    v157 = 0;
    uint64_t v158 = 0;
    ctu::base64::decode();
    v77 = (std::__shared_weak_count *)v156;
    v76 = v157;
    if (v157 == v156)
    {
      v78 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_139;
      }
      uint64_t v79 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v80 = *(void *)(a1 + 160);
      *(_DWORD *)v187 = 136315906;
      *(void *)&v187[4] = v79;
      *(_WORD *)&v187[12] = 2080;
      *(void *)&v187[14] = " ";
      *(_WORD *)&v187[22] = 2080;
      *(void *)&v187[24] = v80;
      __int16 v188 = 2080;
      v189 = "";
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to base64 decode auth token", v187, 0x2Au);
      v77 = (std::__shared_weak_count *)v156;
      v76 = v157;
    }
    if (v76 != v77)
    {
      if (*(char *)(a1 + 255) < 0) {
        uint64_t v81 = *(void *)(a1 + 240);
      }
      else {
        uint64_t v81 = *(unsigned __int8 *)(a1 + 255);
      }
      if (!v81 || !sub_10001D294((unsigned __int8 *)(a1 + 232), (unsigned __int8 *)v153))
      {
        v91 = *(std::__shared_weak_count **)(a1 + 112);
        if (v91)
        {
          v92 = std::__shared_weak_count::lock(v91);
          if (v92)
          {
            v93 = v92;
            uint64_t v94 = *(void *)(a1 + 104);
            if (v94)
            {
              v95 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v95 || (v96 = *(void **)(a1 + 8), (v97 = std::__shared_weak_count::lock(v95)) == 0)) {
                sub_100088B9C();
              }
              v151[0] = v96;
              v151[1] = v97;
              memset(v187, 0, 24);
              sub_10005C928(v187, v156, (uint64_t)v157, (char *)v157 - (unsigned char *)v156);
              v187[24] = 1;
              (*(void (**)(uint64_t, void **, unsigned char *))(*(void *)v94 + 16))(v94, v151, v187);
              if (v187[24] && *(void *)v187)
              {
                *(void *)&v187[8] = *(void *)v187;
                operator delete(*(void **)v187);
              }
              if (v151[1]) {
                sub_10004D2C8((std::__shared_weak_count *)v151[1]);
              }
            }
            sub_10004D2C8(v93);
          }
        }
        v98 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v99 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v100 = *(void *)(a1 + 160);
          *(_DWORD *)v187 = 136316162;
          *(void *)&v187[4] = v99;
          *(_WORD *)&v187[12] = 2080;
          *(void *)&v187[14] = " ";
          *(_WORD *)&v187[22] = 2080;
          *(void *)&v187[24] = v100;
          __int16 v188 = 2080;
          v189 = "";
          __int16 v190 = 2048;
          int64_t v191 = (char *)v157 - (unsigned char *)v156;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sgot auth-token with %zu bytes", v187, 0x34u);
        }
      }
LABEL_168:
      if (*(void *)(*(void *)(a1 + 144) + 56) <= 1uLL && !*(_DWORD *)(a1 + 120))
      {
        uint64_t v101 = *(void *)(a1 + 128);
        v102 = *(std::__shared_weak_count **)(a1 + 136);
        if (v102) {
          atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1005C8AC8(v101 + 432, (char **)&v156);
        if (v102) {
          sub_10004D2C8(v102);
        }
        uint64_t v103 = *(void *)(a1 + 128);
        v104 = *(std::__shared_weak_count **)(a1 + 136);
        if (v104) {
          atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100189ABC(v103, 1);
        if (v104) {
          sub_10004D2C8(v104);
        }
      }
      (*(void (**)(uint64_t, void **))(*(void *)a1 + 280))(a1, &v156);
      if (v156)
      {
        v157 = (std::__shared_weak_count *)v156;
        operator delete(v156);
      }
      if (SHIBYTE(v154) < 0) {
        operator delete(v153[0]);
      }
      goto LABEL_182;
    }
    v78 = *(NSObject **)(a1 + 40);
LABEL_139:
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v82 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v83 = *(void *)(a1 + 160);
      *(_DWORD *)v187 = 136315906;
      *(void *)&v187[4] = v82;
      *(_WORD *)&v187[12] = 2080;
      *(void *)&v187[14] = " ";
      *(_WORD *)&v187[22] = 2080;
      *(void *)&v187[24] = v83;
      __int16 v188 = 2080;
      v189 = "";
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno or corrupted auth-token in response - clean cache", v187, 0x2Au);
    }
    v84 = *(std::__shared_weak_count **)(a1 + 112);
    if (v84)
    {
      v85 = std::__shared_weak_count::lock(v84);
      if (v85)
      {
        v86 = v85;
        uint64_t v87 = *(void *)(a1 + 104);
        if (v87)
        {
          v88 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v88 || (v89 = *(void **)(a1 + 8), (v90 = std::__shared_weak_count::lock(v88)) == 0)) {
            sub_100088B9C();
          }
          v151[0] = v89;
          v151[1] = v90;
          v187[0] = 0;
          v187[24] = 0;
          (*(void (**)(uint64_t, void **, unsigned char *))(*(void *)v87 + 16))(v87, v151, v187);
          if (v187[24] && *(void *)v187)
          {
            *(void *)&v187[8] = *(void *)v187;
            operator delete(*(void **)v187);
          }
          if (v151[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v151[1]);
          }
        }
        sub_10004D2C8(v86);
      }
    }
    goto LABEL_168;
  }
  unsigned int v12 = 0;
  uint64_t v13 = 6000;
LABEL_203:
  if (v4) {
    sub_10004D2C8(v4);
  }
  return ((unint64_t)v12 << 8) | 1 | (v13 << 32);
}

void sub_100F98C44(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F99020()
{
}

void sub_100F9904C()
{
}

void sub_100F99054()
{
}

void sub_100F990B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *__p,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61,void *a62,uint64_t a63)
{
  sub_1000C937C((uint64_t)&STACK[0x200]);
  if (a60 < 0) {
    operator delete(__p);
  }
  if (a67 < 0) {
    operator delete(a62);
  }
  JUMPOUT(0x100F99168);
}

void sub_100F990E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_objecta, uint64_t a12, const void *a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,std::__shared_weak_count *a48)
{
  sub_1000577C4(&a13);
  sub_100057D78(&a14);
  if (a16) {
    sub_10004D2C8((std::__shared_weak_count *)a16);
  }
  if (v49) {
    sub_10004D2C8(v49);
  }
  if (STACK[0x208]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x208]);
  }
  if (a48) {
    sub_10004D2C8(a48);
  }
  if (v48) {
    sub_10004D2C8(v48);
  }
  _Unwind_Resume(a1);
}

void sub_100F99140()
{
}

void sub_100F99148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,const void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,std::__shared_weak_count *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_100FB1FC0(&a72);
  sub_100FB2188((uint64_t)&STACK[0x200]);
  sub_10000A740(&a73);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_100F991C8(&a35);
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a57) {
    sub_10004D2C8(a57);
  }
  if (v73) {
    sub_10004D2C8(v73);
  }
  _Unwind_Resume(a1);
}

const void **sub_100F991C8(const void **a1)
{
  sub_1000577C4(a1 + 2);
  sub_1000577C4(a1 + 1);

  return sub_100057D78(a1);
}

void sub_100F9920C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t v9 = (uint64_t *)(a2 + 16 * a3);
  uint64_t v11 = *v9;
  uint64_t v10 = (std::__shared_weak_count *)v9[1];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v11)
  {
    sub_100058198(&v12, a6);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const void **, uint64_t))(*(void *)v11 + 24))(&v13, v11, a4, &v12, a5);
    *(_OWORD *)a1 = v13;
    long long v13 = 0uLL;
    sub_100057D78(&v12);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (!v11)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
}

void sub_100F992D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100F992F4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t *a5, const void **a6, const void **a7)
{
  if (a3 == 12)
  {
    uint64_t v14 = *a5;
    uint64_t v15 = (std::__shared_weak_count *)a5[1];
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (a4 == 3 && *(_DWORD *)v14 == 6000)
    {
      *(unsigned char *)(a1 + 384) = **(unsigned char **)(v14 + 8);
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v25 = *(void *)(a1 + 160);
        uint64_t v18 = asStringBool(*(unsigned char *)(a1 + 384));
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v29 = 2080;
        uint64_t v30 = v25;
        __int16 v31 = 2080;
        CFTypeID v32 = "";
        __int16 v33 = 2080;
        uint64_t v34 = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sSetting update push token acknowledged: %s", buf, 0x34u);
      }
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
  BOOL v19 = (uint64_t *)(*(void *)(a2 + 96) + 16 * a3);
  uint64_t v21 = *v19;
  uint64_t v20 = (std::__shared_weak_count *)v19[1];
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v21)
  {
    if (*(unsigned char *)(a1 + 124))
    {
      *(void *)int buf = 0;
      *(void *)&uint8_t buf[8] = 0;
    }
    else
    {
      __int16 v22 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v22 || (v23 = *(void *)(a1 + 8), (__int16 v24 = std::__shared_weak_count::lock(v22)) == 0)) {
        sub_100088B9C();
      }
      *(void *)int buf = v23;
      *(void *)&uint8_t buf[8] = v24;
      atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
    }
    sub_100058198(&v27, a6);
    sub_1000584C8(&v26, a7);
    (*(void (**)(uint64_t, unsigned char *, uint64_t, uint64_t, uint64_t *, const void **, const void **))(*(void *)v21 + 32))(v21, buf, a1 + 104, a4, a5, &v27, &v26);
    sub_1000577C4(&v26);
    sub_100057D78(&v27);
    if (*(void *)&buf[8]) {
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_100F99554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F995A0(Registry *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (***v14)(void **__return_ptr, void, uint64_t);
  char v15;
  void *v16;
  uint64_t result;
  void v18[2];
  void *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  void *v22[2];
  uint64_t v23;
  void *v24[2];
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  uint64_t v35;
  const void *v36[6];
  long long v37;
  uint64_t v38;

  if (*(unsigned char *)(a2 + 49) != 1)
  {
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v23 = 0;
    BOOL v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sub_100E63EA4((uint64_t)v24);
    v18[0] = v22;
    v18[1] = &v19;
    sub_100294590(v18, (long long *)v24);
    if (SHIBYTE(v26) < 0) {
      operator delete(*((void **)&v25 + 1));
    }
    if (SBYTE7(v25) < 0) {
      operator delete(v24[0]);
    }
    sub_1002055B4((const void **)v22, (const void **)&v19, v24);
    if (*(char *)(a4 + 23) < 0) {
      operator delete(*(void **)a4);
    }
    *(_OWORD *)a4 = *(_OWORD *)v24;
    *(void *)(a4 + 16) = v25;
    if (SHIBYTE(v21) < 0) {
      operator delete(v19);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    return 1;
  }
  BOOL v19 = 0;
  uint64_t v20 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  BOOL v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v24[0] = (void *)v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v24);
  if (v12)
  {
    uint64_t v14 = (void (***)(void **__return_ptr, void, uint64_t))v12[3];
    long long v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      uint64_t v15 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  long long v13 = 0;
  uint64_t v15 = 1;
LABEL_20:
  (**v14)(&v19, v14, a2 + 24);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  uint64_t v16 = v19;
  if (v19)
  {
    __int16 v33 = 0u;
    uint64_t v34 = 0u;
    __int16 v31 = 0u;
    CFTypeID v32 = 0u;
    __int16 v29 = 0u;
    uint64_t v30 = 0u;
    __int16 v27 = 0u;
    CFDictionaryRef v28 = 0u;
    uint64_t v25 = 0u;
    uint64_t v26 = 0u;
    *(_OWORD *)__int16 v24 = 0u;
    uint64_t v35 = 1;
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0u;
    long long v38 = 0;
    (*(void (**)(void *, void **))(*(void *)v19 + 104))(v19, v24);
    sub_1002055B4(v36, (const void **)&v37, v22);
    if (*(char *)(a4 + 23) < 0) {
      operator delete(*(void **)a4);
    }
    *(_OWORD *)a4 = *(_OWORD *)v22;
    *(void *)(a4 + 16) = v23;
    sub_100350940((uint64_t)v24);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v16) {
    return 1;
  }
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  BOOL result = 0;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  return result;
}

void sub_100F99850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_100F998B8(const void *a1, Registry *this, int a3, uint64_t a4, void ***a5, int64_t a6, uint64_t a7, int a8, int64_t a9, uint64_t a10, uint64_t a11)
{
  int64_t value = a6;
  uint64_t v151 = a7;
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v16;
  uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)__p);
  if (!v20)
  {
    uint64_t v21 = 0;
LABEL_9:
    std::mutex::unlock(v15);
    __int16 v22 = 0;
    char v23 = 1;
    if (!v21) {
      goto LABEL_356;
    }
    goto LABEL_10;
  }
  uint64_t v21 = v20[3];
  __int16 v22 = (std::__shared_weak_count *)v20[4];
  if (!v22) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v15);
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v22);
  char v23 = 0;
  if (!v21) {
    goto LABEL_356;
  }
LABEL_10:
  char v109 = v23;
  if (*(char *)(a4 + 23) < 0) {
    sub_10004FC84(&__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __dst = *(std::string *)a4;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(v179, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    v179[0] = __dst;
  }
  v128[0] = 0;
  if (SHIBYTE(v179[0].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(__p, v179[0].__r_.__value_.__l.__data_, v179[0].__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)&v179[0].__r_.__value_.__l.__data_;
    *(void *)&long long v141 = *((void *)&v179[0].__r_.__value_.__l + 2);
  }
  v149.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    __int16 v24 = v128[0];
    v128[0] = v149.__r_.__value_.__l.__data_;
    v175.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
    sub_1000558F4((const void **)&v175.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v141) < 0) {
    operator delete(__p[0]);
  }
  v159[0] = (xpc_object_t)v128[0];
  v128[0] = 0;
  sub_1000558F4(v128);
  if (SHIBYTE(v179[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v179[0].__r_.__value_.__l.__data_);
  }
  uint64_t v25 = [+[NSURLComponents componentsWithString:v159[0]] host];
  sub_1000558F4((const void **)v159);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  memset(&v149, 0, sizeof(v149));
  sub_10004BD84((uint64_t)__p);
  memset(v179, 0, 24);
  ctu::cf::assign();
  std::string v175 = v179[0];
  if ((v179[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v26 = &v175;
  }
  else {
    uint64_t v26 = (std::string *)v175.__r_.__value_.__r.__words[0];
  }
  if ((v179[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v175.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v175.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(&v141, (uint64_t)v26, size);
  sub_10004B96C(&v141, (uint64_t)",", 1);
  *(_DWORD *)((char *)&v141 + *(void *)(v141 - 24) + 8) = *(_DWORD *)((unsigned char *)&v141 + *(void *)(v141 - 24) + 8) & 0xFFFFFFB5 | 2;
  std::ostream::operator<<();
  if ((BYTE8(v146) & 0x10) != 0)
  {
    uint64_t v29 = v146;
    if ((unint64_t)v146 < *((void *)&v144 + 1))
    {
      *(void *)&long long v146 = *((void *)&v144 + 1);
      uint64_t v29 = *((void *)&v144 + 1);
    }
    uint64_t v30 = v144;
  }
  else
  {
    if ((BYTE8(v146) & 8) == 0)
    {
      uint64_t v28 = 0;
LABEL_44:
      std::string::size_type v32 = 0;
      goto LABEL_45;
    }
    uint64_t v30 = *((void *)&v142 + 1);
    uint64_t v29 = *((void *)&v143 + 1);
  }
  uint64_t v28 = v29 - v30;
  if (!v28) {
    goto LABEL_44;
  }
  __int16 v31 = &v145[1];
  if (v145[3] < 0) {
    __int16 v31 = (uint64_t *)v145[1];
  }
  std::string::size_type v32 = v30 - (void)v31;
LABEL_45:
  std::string v149 = *(std::string *)&v145[1];
  memset(&v145[1], 0, 24);
  std::string::resize(&v149, v32 + v28, 0);
  std::string::erase(&v149, 0, v32);
  sub_100146140((uint64_t)&v141 + 8);
  if (SHIBYTE(v175.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v175.__r_.__value_.__l.__data_);
  }
  *(void **)((char *)__p
  *(void *)&long long v141 = v33;
  if (SHIBYTE(v145[3]) < 0) {
    operator delete((void *)v145[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();

  v179[0].__r_.__value_.__r.__words[0] = 0;
  xpc_object_t v34 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v35 = v34;
  if (v34)
  {
    v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
  }
  else
  {
    xpc_object_t v35 = xpc_null_create();
    v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    if (!v35)
    {
      xpc_object_t v36 = xpc_null_create();
      xpc_object_t v35 = 0;
      goto LABEL_56;
    }
  }
  if (xpc_get_type(v35) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v36 = xpc_null_create();
LABEL_56:
    v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
    goto LABEL_57;
  }
  xpc_retain(v35);
LABEL_57:
  xpc_release(v35);
  if (BYTE4(v151))
  {
    if ((v151 - 1) >= 3) {
      int64_t v37 = 3;
    }
    else {
      int64_t v37 = qword_1015A3B68[(int)v151 - 1];
    }
    xpc_object_t v138 = xpc_int64_create(v37);
    if (!v138) {
      xpc_object_t v138 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "error_cause_code";
    sub_100035E70((uint64_t)__p, &v138, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v138);
    xpc_object_t v138 = 0;
  }
  if (BYTE4(value))
  {
    xpc_object_t v136 = xpc_int64_create((int)value);
    if (!v136) {
      xpc_object_t v136 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "http_response_code";
    sub_100035E70((uint64_t)__p, &v136, &v137);
    xpc_release(v137);
    xpc_object_t v137 = 0;
    xpc_release(v136);
    xpc_object_t v136 = 0;
  }
  if ((_BYTE)a10)
  {
    xpc_object_t v134 = xpc_int64_create(a9);
    if (!v134) {
      xpc_object_t v134 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "network_error_code";
    sub_100035E70((uint64_t)__p, &v134, &v135);
    xpc_release(v135);
    xpc_object_t v135 = 0;
    xpc_release(v134);
    xpc_object_t v134 = 0;
  }
  if ((a11 & 0xFF00000000) != 0)
  {
    xpc_object_t v132 = xpc_int64_create(a11);
    if (!v132) {
      xpc_object_t v132 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "response_time";
    sub_100035E70((uint64_t)__p, &v132, &v133);
    xpc_release(v133);
    xpc_object_t v133 = 0;
    xpc_release(v132);
    xpc_object_t v132 = 0;
  }
  if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v38 = &v149;
  }
  else {
    long long v38 = (std::string *)v149.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v130 = xpc_string_create((const char *)v38);
  if (!v130) {
    xpc_object_t v130 = xpc_null_create();
  }
  __p[0] = v179;
  __p[1] = "source";
  sub_100035E70((uint64_t)__p, &v130, &v131);
  xpc_release(v131);
  xpc_object_t v131 = 0;
  xpc_release(v130);
  xpc_object_t v129 = (xpc_object_t)v179[0].__r_.__value_.__r.__words[0];
  xpc_object_t v130 = 0;
  if (v179[0].__r_.__value_.__r.__words[0]) {
    xpc_retain(v179[0].__r_.__value_.__l.__data_);
  }
  else {
    xpc_object_t v129 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterEntitlementResponse", &v129);
  xpc_release(v129);
  xpc_object_t v129 = 0;
  xpc_release(v179[0].__r_.__value_.__l.__data_);
  uint64_t v40 = 0;
  v128[0] = a1;
  v128[1] = &value;
  v128[2] = &v151;
  do
  {
    if (v40 <= 0x1D && ((1 << v40) & 0x30000001) != 0) {
      goto LABEL_87;
    }
    long long v41 = *(_OWORD *)&(*a5)[2 * v40];
    long long v110 = v41;
    long long v42 = (std::__shared_weak_count *)(*a5)[2 * v40 + 1];
    if (*((void *)&v41 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    if ((void)v41)
    {
      v179[0].__r_.__value_.__r.__words[0] = 0;
      xpc_object_t v43 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v44 = v43;
      if (v43)
      {
        v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
      }
      else
      {
        xpc_object_t v44 = xpc_null_create();
        v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
        if (!v44)
        {
          xpc_object_t v45 = xpc_null_create();
          xpc_object_t v44 = 0;
          goto LABEL_99;
        }
      }
      if (xpc_get_type(v44) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v44);
LABEL_100:
        xpc_release(v44);
        *(_OWORD *)std::string __p = v110;
        if (v42) {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100FA9CD8(v128, v40, (_DWORD **)__p, (uint64_t)v179);
        if (v42) {
          sub_10004D2C8(v42);
        }
        if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v46 = &v149;
        }
        else {
          uint64_t v46 = (std::string *)v149.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v126 = xpc_string_create((const char *)v46);
        if (!v126) {
          xpc_object_t v126 = xpc_null_create();
        }
        __p[0] = v179;
        __p[1] = "source";
        sub_100035E70((uint64_t)__p, &v126, &v127);
        xpc_release(v127);
        xpc_object_t v127 = 0;
        xpc_release(v126);
        xpc_object_t v125 = (xpc_object_t)v179[0].__r_.__value_.__r.__words[0];
        xpc_object_t v126 = 0;
        if (v179[0].__r_.__value_.__r.__words[0]) {
          xpc_retain(v179[0].__r_.__value_.__l.__data_);
        }
        else {
          xpc_object_t v125 = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterEntitlementActionResponse", &v125);
        xpc_release(v125);
        xpc_object_t v125 = 0;
        xpc_release(v179[0].__r_.__value_.__l.__data_);
        goto LABEL_113;
      }
      xpc_object_t v45 = xpc_null_create();
LABEL_99:
      v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
      goto LABEL_100;
    }
LABEL_113:
    if (v42) {
      sub_10004D2C8(v42);
    }
LABEL_87:
    ++v40;
  }
  while (v40 != 30);
  __int16 v47 = a5;
  uint64_t v48 = (*a5)[56];
  uint64_t v49 = (std::__shared_weak_count *)(*a5)[57];
  if (v49) {
    atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v48)
  {
    v179[0].__r_.__value_.__r.__words[0] = 0;
    xpc_object_t v50 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v51 = v50;
    if (v50)
    {
      v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
      goto LABEL_121;
    }
    xpc_object_t v51 = xpc_null_create();
    v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
    if (v51)
    {
LABEL_121:
      if (xpc_get_type(v51) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v52 = xpc_null_create();
        goto LABEL_125;
      }
      xpc_retain(v51);
    }
    else
    {
      xpc_object_t v52 = xpc_null_create();
      xpc_object_t v51 = 0;
LABEL_125:
      v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
    }
    xpc_release(v51);
    __p[0] = v48;
    __p[1] = v49;
    if (v49) {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100FA9CD8(v128, 28, (_DWORD **)__p, (uint64_t)v179);
    if (v49) {
      sub_10004D2C8(v49);
    }
    if (*(_DWORD *)v48 == 6000)
    {
      uint64_t v53 = v48[1];
      if (v53)
      {
        if (*(unsigned char *)(v53 + 32))
        {
          xpc_object_t v123 = xpc_BOOL_create(1);
          if (!v123) {
            xpc_object_t v123 = xpc_null_create();
          }
          __p[0] = v179;
          __p[1] = "has_app_token";
          sub_100035E70((uint64_t)__p, &v123, &v124);
          xpc_release(v124);
          xpc_object_t v124 = 0;
          xpc_release(v123);
          xpc_object_t v123 = 0;
        }
      }
    }
    if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v54 = &v149;
    }
    else {
      uint64_t v54 = (std::string *)v149.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v121 = xpc_string_create((const char *)v54);
    if (!v121) {
      xpc_object_t v121 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "source";
    sub_100035E70((uint64_t)__p, &v121, &v122);
    xpc_release(v122);
    xpc_object_t v122 = 0;
    xpc_release(v121);
    xpc_object_t v120 = (xpc_object_t)v179[0].__r_.__value_.__r.__words[0];
    xpc_object_t v121 = 0;
    if (v179[0].__r_.__value_.__r.__words[0]) {
      xpc_retain(v179[0].__r_.__value_.__l.__data_);
    }
    else {
      xpc_object_t v120 = xpc_null_create();
    }
    (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterEntitlementActionResponse", &v120);
    xpc_release(v120);
    xpc_object_t v120 = 0;
    xpc_release(v179[0].__r_.__value_.__l.__data_);
  }
  if (v49) {
    sub_10004D2C8(v49);
  }
  long long v55 = (*a5)[58];
  long long v56 = (std::__shared_weak_count *)(*a5)[59];
  if (v56) {
    atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v55)
  {
    v179[0].__r_.__value_.__r.__words[0] = 0;
    xpc_object_t v57 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v58 = v57;
    if (v57)
    {
      v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
      goto LABEL_153;
    }
    xpc_object_t v58 = xpc_null_create();
    v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
    if (v58)
    {
LABEL_153:
      if (xpc_get_type(v58) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v59 = xpc_null_create();
        goto LABEL_157;
      }
      xpc_retain(v58);
    }
    else
    {
      xpc_object_t v59 = xpc_null_create();
      xpc_object_t v58 = 0;
LABEL_157:
      v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
    }
    xpc_release(v58);
    __p[0] = v55;
    __p[1] = v56;
    if (v56) {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100FA9CD8(v128, 29, (_DWORD **)__p, (uint64_t)v179);
    if (v56) {
      sub_10004D2C8(v56);
    }
    if (*(_DWORD *)v55 == 6000)
    {
      uint64_t v60 = v55[1];
      if (v60)
      {
        if (*(unsigned char *)(v60 + 32))
        {
          xpc_object_t v118 = xpc_BOOL_create(1);
          if (!v118) {
            xpc_object_t v118 = xpc_null_create();
          }
          __p[0] = v179;
          __p[1] = "has_app_token";
          sub_100035E70((uint64_t)__p, &v118, &v119);
          xpc_release(v119);
          xpc_object_t v119 = 0;
          xpc_release(v118);
          xpc_object_t v118 = 0;
        }
      }
    }
    if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v61 = &v149;
    }
    else {
      long long v61 = (std::string *)v149.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v116 = xpc_string_create((const char *)v61);
    if (!v116) {
      xpc_object_t v116 = xpc_null_create();
    }
    __p[0] = v179;
    __p[1] = "source";
    sub_100035E70((uint64_t)__p, &v116, &v117);
    xpc_release(v117);
    xpc_object_t v117 = 0;
    xpc_release(v116);
    xpc_object_t v115 = (xpc_object_t)v179[0].__r_.__value_.__r.__words[0];
    xpc_object_t v116 = 0;
    if (v179[0].__r_.__value_.__r.__words[0]) {
      xpc_retain(v179[0].__r_.__value_.__l.__data_);
    }
    else {
      xpc_object_t v115 = xpc_null_create();
    }
    (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterEntitlementActionResponse", &v115);
    xpc_release(v115);
    xpc_object_t v115 = 0;
    xpc_release(v179[0].__r_.__value_.__l.__data_);
  }
  if (v56) {
    sub_10004D2C8(v56);
  }
  long long v62 = **a5;
  long long v63 = (std::__shared_weak_count *)(*a5)[1];
  if (v63) {
    atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v62)
  {
    long long v64 = (unsigned char *)v62[1];
    if (v64)
    {
      v108 = v63;
      if (*v64)
      {
        v179[0].__r_.__value_.__r.__words[0] = 0;
        xpc_object_t v65 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v66 = v65;
        if (v65)
        {
          v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
          goto LABEL_187;
        }
        xpc_object_t v66 = xpc_null_create();
        v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v66;
        if (v66)
        {
LABEL_187:
          if (xpc_get_type(v66) != (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_object_t v67 = xpc_null_create();
            goto LABEL_191;
          }
          xpc_retain(v66);
        }
        else
        {
          xpc_object_t v67 = xpc_null_create();
          xpc_object_t v66 = 0;
LABEL_191:
          v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
        }
        xpc_release(v66);
        __p[0] = v62;
        __p[1] = v63;
        if (v63) {
          atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100FA9CD8(v128, 0, (_DWORD **)__p, (uint64_t)v179);
        if (v63) {
          sub_10004D2C8(v63);
        }
        if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v68 = &v149;
        }
        else {
          uint64_t v68 = (std::string *)v149.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v113 = xpc_string_create((const char *)v68);
        if (!v113) {
          xpc_object_t v113 = xpc_null_create();
        }
        __p[0] = v179;
        __p[1] = "source";
        sub_100035E70((uint64_t)__p, &v113, &v114);
        xpc_release(v114);
        xpc_object_t v114 = 0;
        xpc_release(v113);
        xpc_object_t v112 = (xpc_object_t)v179[0].__r_.__value_.__r.__words[0];
        xpc_object_t v113 = 0;
        if (v179[0].__r_.__value_.__r.__words[0]) {
          xpc_retain(v179[0].__r_.__value_.__l.__data_);
        }
        else {
          xpc_object_t v112 = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterEntitlementActionResponse", &v112);
        xpc_release(v112);
        xpc_object_t v112 = 0;
        xpc_release(v179[0].__r_.__value_.__l.__data_);
        long long v64 = (unsigned char *)v62[1];
      }
      long long v148 = 0u;
      long long v146 = 0u;
      memset(v147, 0, sizeof(v147));
      memset(v145, 0, sizeof(v145));
      long long v143 = 0u;
      long long v144 = 0u;
      long long v141 = 0u;
      long long v142 = 0u;
      *(_OWORD *)std::string __p = 0u;
      LOBYTE(__p[0]) = *v64;
      sub_1001A0DB0((uint64_t *)&__p[1], (uint64_t)(v64 + 8));
      sub_1001A0E08((uint64_t *)&v142, (uint64_t)(v64 + 32));
      sub_1001A0E60((uint64_t)&v143 + 8, (uint64_t)(v64 + 56));
      v107 = sub_1001A0EB8(v145, (uint64_t)(v64 + 80));
      v145[3] = (uint64_t)v62;
      *(void *)&long long v146 = v63;
      if (v63) {
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      DWORD2(v146) = value;
      BYTE12(v146) = BYTE4(value);
      LODWORD(v147[0]) = v151;
      BYTE4(v147[0]) = BYTE4(v151);
      if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v147[1], v149.__r_.__value_.__l.__data_, v149.__r_.__value_.__l.__size_);
      }
      else {
        *(std::string *)&v147[1] = v149;
      }
      *(void *)&long long v148 = v21;
      *((void *)&v148 + 1) = v22;
      if ((v109 & 1) == 0) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v69 = 0;
      while (2)
      {
        if ((sub_100022DE8((uint64_t)__p, v69) & 0xFF00000000) != 0)
        {
          unint64_t v70 = sub_100C89C88((uint64_t)__p, v69);
          if ((v70 & 0xFF00000000) != 0)
          {
            int v71 = v70;
            xpc_object_t v178 = 0;
            xpc_object_t v72 = xpc_dictionary_create(0, 0, 0);
            xpc_object_t v73 = v72;
            if (v72)
            {
              xpc_object_t v178 = v72;
              goto LABEL_218;
            }
            xpc_object_t v73 = xpc_null_create();
            xpc_object_t v178 = v73;
            if (v73)
            {
LABEL_218:
              if (xpc_get_type(v73) != (xpc_type_t)&_xpc_type_dictionary)
              {
                xpc_object_t v74 = xpc_null_create();
                goto LABEL_222;
              }
              xpc_retain(v73);
            }
            else
            {
              xpc_object_t v74 = xpc_null_create();
              xpc_object_t v73 = 0;
LABEL_222:
              xpc_object_t v178 = v74;
            }
            xpc_release(v73);
            sub_100FB595C(v69);
            memset(v179, 0, 24);
            ctu::cf::assign();
            std::string v175 = v179[0];
            if ((v179[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v75 = &v175;
            }
            else {
              uint64_t v75 = (std::string *)v175.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v176 = xpc_string_create((const char *)v75);
            if (!v176) {
              xpc_object_t v176 = xpc_null_create();
            }
            v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v178;
            v179[0].__r_.__value_.__l.__size_ = (std::string::size_type)"entitlement_type";
            sub_100035E70((uint64_t)v179, &v176, &v177);
            xpc_release(v177);
            xpc_object_t v177 = 0;
            xpc_release(v176);
            xpc_object_t v176 = 0;
            if (SHIBYTE(v175.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v175.__r_.__value_.__l.__data_);
            }
            xpc_object_t v173 = xpc_int64_create(v71);
            if (!v173) {
              xpc_object_t v173 = xpc_null_create();
            }
            v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v178;
            v179[0].__r_.__value_.__l.__size_ = (std::string::size_type)"entitlement_status";
            sub_100035E70((uint64_t)v179, &v173, &v174);
            xpc_release(v174);
            xpc_object_t v174 = 0;
            xpc_release(v173);
            BOOL v76 = 0;
            xpc_object_t v173 = 0;
            if (*(_DWORD *)v145[3] == 6000 && BYTE12(v146) && DWORD2(v146) == 200 && BYTE4(v147[0])) {
              BOOL v76 = v71 == 6100 && LODWORD(v147[0]) == 0;
            }
            xpc_object_t v171 = xpc_BOOL_create(v76);
            if (!v171) {
              xpc_object_t v171 = xpc_null_create();
            }
            v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v178;
            v179[0].__r_.__value_.__l.__size_ = (std::string::size_type)"is_entitlement_success";
            sub_100035E70((uint64_t)v179, &v171, &v172);
            xpc_release(v172);
            xpc_object_t v172 = 0;
            xpc_release(v171);
            xpc_object_t v171 = 0;
            if (v69 == 15)
            {
              memset(v179, 0, 24);
              sub_1001A0E60((uint64_t)v179, (uint64_t)&v143 + 8);
              std::string::size_type v78 = v179[0].__r_.__value_.__l.__size_;
              if (v179[0].__r_.__value_.__l.__size_)
              {
                uint64_t v79 = (std::string *)&v179[0].__r_.__value_.__r.__words[1];
                do
                {
                  uint64_t v80 = (std::string *)v78;
                  uint64_t v81 = v79;
                  int v82 = *(_DWORD *)(v78 + 32);
                  uint64_t v83 = (std::string::size_type *)(v78 + 8);
                  if (v82 >= 15)
                  {
                    uint64_t v83 = (std::string::size_type *)v80;
                    uint64_t v79 = v80;
                  }
                  std::string::size_type v78 = *v83;
                }
                while (v78);
                if (v79 != (std::string *)&v179[0].__r_.__value_.__r.__words[1])
                {
                  v84 = v82 >= 15 ? v80 : v81;
                  if (SLODWORD(v84[1].__r_.__value_.__r.__words[1]) <= 15)
                  {
                    v85 = v82 >= 15 ? v80 : v81;
                    v86 = (uint64_t *)v85[1].__r_.__value_.__r.__words[2];
                    if (v86)
                    {
                      if (*((unsigned char *)v86 + 24))
                      {
                        uint64_t v87 = *v86;
                        uint64_t v111 = v86[1];
                        if (*v86 != v111)
                        {
                          uint64_t v106 = v85;
                          while (1)
                          {
                            xpc_object_t v170 = 0;
                            xpc_object_t v88 = xpc_dictionary_create(0, 0, 0);
                            xpc_object_t v89 = v88;
                            if (v88)
                            {
                              xpc_object_t v170 = v88;
                            }
                            else
                            {
                              xpc_object_t v89 = xpc_null_create();
                              xpc_object_t v170 = v89;
                              if (!v89)
                              {
                                xpc_object_t v90 = xpc_null_create();
                                xpc_object_t v89 = 0;
                                goto LABEL_269;
                              }
                            }
                            if (xpc_get_type(v89) != (xpc_type_t)&_xpc_type_dictionary)
                            {
                              xpc_object_t v90 = xpc_null_create();
LABEL_269:
                              xpc_object_t v170 = v90;
                              goto LABEL_270;
                            }
                            xpc_retain(v89);
LABEL_270:
                            xpc_release(v89);
                            if (*(unsigned char *)(v87 + 4))
                            {
                              if (*(_DWORD *)v87 == 1)
                              {
                                xpc_object_t v166 = xpc_string_create("unmetered");
                                if (!v166) {
                                  xpc_object_t v166 = xpc_null_create();
                                }
                                v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                                v175.__r_.__value_.__l.__size_ = (std::string::size_type)"plan_type";
                                sub_100035E70((uint64_t)&v175, &v166, &v167);
                                xpc_release(v167);
                                xpc_object_t v167 = 0;
                                xpc_release(v166);
                                xpc_object_t v166 = 0;
                              }
                              else if (!*(_DWORD *)v87)
                              {
                                xpc_object_t v168 = xpc_string_create("metered");
                                if (!v168) {
                                  xpc_object_t v168 = xpc_null_create();
                                }
                                v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                                v175.__r_.__value_.__l.__size_ = (std::string::size_type)"plan_type";
                                sub_100035E70((uint64_t)&v175, &v168, &v169);
                                xpc_release(v169);
                                xpc_object_t v169 = 0;
                                xpc_release(v168);
                                xpc_object_t v168 = 0;
                              }
                            }
                            if (*(unsigned char *)(v87 + 9))
                            {
                              xpc_object_t v164 = xpc_BOOL_create(*(unsigned char *)(v87 + 8));
                              if (!v164) {
                                xpc_object_t v164 = xpc_null_create();
                              }
                              v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                              v175.__r_.__value_.__l.__size_ = (std::string::size_type)"5g_experience";
                              sub_100035E70((uint64_t)&v175, &v164, &v165);
                              xpc_release(v165);
                              xpc_object_t v165 = 0;
                              xpc_release(v164);
                              xpc_object_t v164 = 0;
                            }
                            if (*(unsigned char *)(v87 + 16))
                            {
                              xpc_object_t v162 = xpc_int64_create(*(int *)(v87 + 12));
                              if (!v162) {
                                xpc_object_t v162 = xpc_null_create();
                              }
                              v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                              v175.__r_.__value_.__l.__size_ = (std::string::size_type)"volume_cap_gb";
                              sub_100035E70((uint64_t)&v175, &v162, &v163);
                              xpc_release(v163);
                              xpc_object_t v163 = 0;
                              xpc_release(v162);
                              xpc_object_t v162 = 0;
                            }
                            if (!*(unsigned char *)(v87 + 48)) {
                              goto LABEL_308;
                            }
                            v91 = v47;
                            memset(&v175, 0, sizeof(v175));
                            v92 = *(_DWORD **)(v87 + 24);
                            v93 = *(_DWORD **)(v87 + 32);
                            if (v92 == v93)
                            {
                              v95 = &v175;
                              goto LABEL_304;
                            }
                            uint64_t v94 = 0;
                            do
                            {
                              if (*v92 == 1)
                              {
                                if (v94) {
                                  std::string::push_back(&v175, 43);
                                }
                                std::string::append(&v175, "sub6", 4uLL);
                              }
                              else
                              {
                                if (*v92) {
                                  goto LABEL_299;
                                }
                                if (v94) {
                                  std::string::push_back(&v175, 43);
                                }
                                std::string::append(&v175, "mmw", 3uLL);
                              }
                              ++v94;
LABEL_299:
                              ++v92;
                            }
                            while (v92 != v93);
                            if ((v175.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                              v95 = &v175;
                            }
                            else {
                              v95 = (std::string *)v175.__r_.__value_.__r.__words[0];
                            }
LABEL_304:
                            __int16 v47 = v91;
                            xpc_object_t v160 = xpc_string_create((const char *)v95);
                            if (!v160) {
                              xpc_object_t v160 = xpc_null_create();
                            }
                            v159[0] = &v170;
                            v159[1] = "plan_supported_rat";
                            sub_100035E70((uint64_t)v159, &v160, &v161);
                            xpc_release(v161);
                            xpc_object_t v161 = 0;
                            xpc_release(v160);
                            xpc_object_t v160 = 0;
                            if (SHIBYTE(v175.__r_.__value_.__r.__words[2]) < 0) {
                              operator delete(v175.__r_.__value_.__l.__data_);
                            }
LABEL_308:
                            if (*(unsigned char *)(v87 + 57))
                            {
                              xpc_object_t v157 = xpc_BOOL_create(*(unsigned char *)(v87 + 56));
                              if (!v157) {
                                xpc_object_t v157 = xpc_null_create();
                              }
                              v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                              v175.__r_.__value_.__l.__size_ = (std::string::size_type)"sa_provisioned";
                              sub_100035E70((uint64_t)&v175, &v157, &v158);
                              xpc_release(v158);
                              xpc_object_t v158 = 0;
                              xpc_release(v157);
                              xpc_object_t v157 = 0;
                            }
                            if (v147[3] >= 0) {
                              v96 = (const char *)&v147[1];
                            }
                            else {
                              v96 = (const char *)v147[1];
                            }
                            xpc_object_t v155 = xpc_string_create(v96);
                            if (!v155) {
                              xpc_object_t v155 = xpc_null_create();
                            }
                            v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v170;
                            v175.__r_.__value_.__l.__size_ = (std::string::size_type)"source";
                            sub_100035E70((uint64_t)&v175, &v155, &v156);
                            xpc_release(v156);
                            xpc_object_t v156 = 0;
                            xpc_release(v155);
                            xpc_object_t v155 = 0;
                            uint64_t v97 = v148;
                            xpc_object_t v154 = v170;
                            if (v170) {
                              xpc_retain(v170);
                            }
                            else {
                              xpc_object_t v154 = xpc_null_create();
                            }
                            (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v97 + 16))(v97, "commCenterEntitlement5GServicePlan", &v154);
                            xpc_release(v154);
                            xpc_object_t v154 = 0;
                            xpc_release(v170);
                            v87 += 64;
                            if (v87 == v111)
                            {
                              uint64_t v98 = *(void *)(v106[1].__r_.__value_.__r.__words[2] + 8)
                                  - *(void *)v106[1].__r_.__value_.__r.__words[2];
                              if (v98)
                              {
                                xpc_object_t v170 = xpc_int64_create(v98 >> 6);
                                if (!v170) {
                                  xpc_object_t v170 = xpc_null_create();
                                }
                                v175.__r_.__value_.__r.__words[0] = (std::string::size_type)&v178;
                                v175.__r_.__value_.__l.__size_ = (std::string::size_type)"plan_count";
                                sub_100035E70((uint64_t)&v175, &v170, v159);
                                xpc_release(v159[0]);
                                v159[0] = 0;
                                xpc_release(v170);
                                xpc_object_t v170 = 0;
                              }
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              sub_10005D0E4((uint64_t)v179, (void *)v179[0].__r_.__value_.__l.__size_);
            }
            if (v147[3] >= 0) {
              uint64_t v99 = (const char *)&v147[1];
            }
            else {
              uint64_t v99 = (const char *)v147[1];
            }
            xpc_object_t v153 = xpc_string_create(v99);
            if (!v153) {
              xpc_object_t v153 = xpc_null_create();
            }
            v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v178;
            v179[0].__r_.__value_.__l.__size_ = (std::string::size_type)"source";
            sub_100035E70((uint64_t)v179, &v153, (xpc_object_t *)&v175.__r_.__value_.__l.__data_);
            xpc_release(v175.__r_.__value_.__l.__data_);
            v175.__r_.__value_.__r.__words[0] = 0;
            xpc_release(v153);
            xpc_object_t v153 = 0;
            uint64_t v100 = v148;
            v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v178;
            if (v178) {
              xpc_retain(v178);
            }
            else {
              v179[0].__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
            }
            (*(void (**)(uint64_t, const char *, std::string *))(*(void *)v100 + 16))(v100, "commCenterEntitlementTypeResponse", v179);
            xpc_release(v179[0].__r_.__value_.__l.__data_);
            v179[0].__r_.__value_.__r.__words[0] = 0;
            xpc_release(v178);
          }
        }
        if (++v69 != 22) {
          continue;
        }
        break;
      }
      long long v63 = v108;
      if (*((void *)&v148 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v148 + 1));
      }
      if (SHIBYTE(v147[3]) < 0) {
        operator delete((void *)v147[1]);
      }
      if ((void)v146) {
        sub_10004D2C8((std::__shared_weak_count *)v146);
      }
      sub_1000346F8((uint64_t)v107, (void *)v145[1]);
      sub_10005D0E4((uint64_t)&v143 + 8, (void *)v144);
      sub_1000346F8((uint64_t)&v142, *((void **)&v142 + 1));
      sub_1000346F8((uint64_t)&__p[1], (void *)v141);
    }
  }
  if (v63) {
    sub_10004D2C8(v63);
  }
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v39);
  v102 = (void *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800E3u);
  __p[0] = v102;
  if (v102)
  {
    uint64_t v103 = sub_10001C8F4(8);
    uint64_t v105 = *v103;
    v104 = (std::__shared_weak_count *)v103[1];
    if (v104) {
      atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v105) {
      operator new();
    }
    if (v104) {
      sub_10004D2C8(v104);
    }
    wis::MetricContainer::~MetricContainer((wis::MetricContainer *)v102);
    operator delete();
  }
  if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v149.__r_.__value_.__l.__data_);
  }
  char v23 = v109;
LABEL_356:
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
}

void sub_100F9B368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, char a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,xpc_object_t object,uint64_t a39,uint64_t a40,xpc_object_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,xpc_object_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,xpc_object_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,xpc_object_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (STACK[0x240]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x240]);
  }
  sub_100181C2C((void **)&a68);
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (SLOBYTE(STACK[0x307]) < 0) {
    operator delete((void *)STACK[0x2F0]);
  }
  if ((a19 & 1) == 0) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(a1);
}

void sub_100F9B8E4(uint64_t a1, void *a2)
{
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v6;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________<   Received the HTTP response, processing it", buf, 0x2Au);
  }
  memset(v208, 0, sizeof(v208));
  sub_100FAC734(v208);
  uint64_t v207 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = (std::__shared_weak_count *)a2[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (Registry **)(a1 + 48);
  uint64_t v9 = *(Registry **)(a1 + 48);
  v215 = 0;
  uint64_t v216 = 0;
  v217 = 0;
  int v11 = sub_100F995A0(v9, ***(void ***)(a1 + 128), *(void *)(a1 + 128) + 64, (uint64_t)&v215);
  if ((v11 & 1) == 0)
  {
    unsigned int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v140 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v141 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v140;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v141;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#E %s%s%s%sPLMN is not available. Will not submit AWDMetrics", buf, 0x2Au);
    }
  }
  CFDictionaryRef theDict = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&theDict);
  if (*(void *)(a1 + 736)) {
    *(std::chrono::system_clock::time_point *)(*(void *)(a1 + 736) + 8) = std::chrono::system_clock::now();
  }
  v201 = (uint64_t *)(a1 + 576);
  uint64_t v13 = *(void *)(a1 + 576);
  if (!v13 || (uint64_t v14 = *(void **)(v13 + 40)) == 0 || ![v14 count])
  {
    __int16 v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v29 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v28;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v29;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnsolicited Response, ignoring", buf, 0x2Au);
    }
    if (!v11 || *(_DWORD *)(a1 + 120)) {
      goto LABEL_55;
    }
    sub_100FAC734(buf);
    sub_100F998B8(v201, *(Registry **)(a1 + 48), a1 + 144, a1 + 400, (void ***)buf, 0, 0x100000003, (int)&v215, 0, 0, 0);
    goto LABEL_50;
  }
  if (!v7)
  {
    uint64_t v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v32 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v32;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sResponse: <nil>", buf, 0x2Au);
    }
    if (!v11 || *(_DWORD *)(a1 + 120)) {
      goto LABEL_55;
    }
    sub_100FAC734(buf);
    sub_100F998B8(v201, *(Registry **)(a1 + 48), a1 + 144, a1 + 400, (void ***)buf, 0, 0x100000001, (int)&v215, 0, 0, 0);
LABEL_50:
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
    sub_10077EE24((void ***)&__dst);
LABEL_55:
    BOOL v26 = 0;
    LODWORD(v15) = -1;
    goto LABEL_56;
  }
  uint64_t v15 = (ctu::Http *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
  v200 = a2;
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v18 = *(void *)(a1 + 160);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v7 + 64))(&__dst, v7);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    v205 = p_dst;
    int v203 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
    (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
    ctu::Http::asString();
    if (v214 >= 0) {
      uint64_t v21 = &v212;
    }
    else {
      uint64_t v21 = v212;
    }
    v197 = v21;
    ctu::Http::asString((uint64_t *)&v209, v15, v20);
    if (v211 >= 0) {
      __int16 v22 = &v209;
    }
    else {
      __int16 v22 = v209;
    }
    v195 = v22;
    uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
    (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
    ctu::Http::asString();
    if (v226 >= 0) {
      __int16 v24 = __p;
    }
    else {
      __int16 v24 = *(unsigned char **)__p;
    }
    *(_DWORD *)int buf = 136317698;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v18;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v205;
    *(_WORD *)&buf[52] = 1024;
    *(_DWORD *)&buf[54] = v203;
    *(_WORD *)&buf[58] = 2080;
    *(void *)&buf[60] = v197;
    *(_WORD *)&buf[68] = 1024;
    *(_DWORD *)&buf[70] = v15;
    *(_WORD *)&buf[74] = 2080;
    *(void *)&buf[76] = v195;
    *(_WORD *)&buf[84] = 2048;
    *(void *)&buf[86] = v23;
    *(_WORD *)&buf[94] = 2080;
    *(void *)&long long v234 = v24;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sResponse Status: '%s', Result: %d (%s), Status: '%d' (%s), ErrorCode: '%ld' (%s)", buf, 0x68u);
    if (v226 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v10 = (Registry **)(a1 + 48);
    if (SHIBYTE(v211) < 0) {
      operator delete(v209);
    }
    if (SHIBYTE(v214) < 0) {
      operator delete(v212);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    uint64_t v16 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v172 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v7 + 48))(&__dst, v7);
    xpc_object_t v173 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__dst
         : (std::string *)__dst.__r_.__value_.__r.__words[0];
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = v172;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v173;
    _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "#D %s%sResponse: '%s'", buf, 0x20u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  a2 = v200;
  if (*(void *)(a1 + 736)) {
    *(void *)(*(void *)(a1 + 736) + 16) = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7) == 1)
  {
    if (v15 == 200)
    {
      v212 = 0;
      uint64_t v25 = *v201;
      (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v7 + 40))(buf, v7);
      BOOL v26 = sub_100FC1234(v25, *(const __CFData **)buf, (uint64_t *)v208);
      sub_100030068((const void **)buf);
      if (v26)
      {
        if (v11 && !*(_DWORD *)(a1 + 120)) {
          sub_100F998B8(v201, *(Registry **)(a1 + 48), a1 + 144, a1 + 400, v208, 0x1000000C8, (uint64_t)&_mh_execute_header, (int)&v215, 0, 0, (*(_DWORD *)(*(void *)(a1 + 576) + 88) - *(_DWORD *)(*(void *)(a1 + 576) + 80)) | (unint64_t)&_mh_execute_header);
        }
      }
      else
      {
        long long v142 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v143 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v144 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v143;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v144;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sCouldn't parse responses", buf, 0x2Au);
        }
        if (v11 && !*(_DWORD *)(a1 + 120))
        {
          sub_100FAC734(buf);
          sub_100F998B8(v201, *(Registry **)(a1 + 48), a1 + 144, a1 + 400, (void ***)buf, 0x1000000C8, 0x100000002, (int)&v215, 0, 0, 0);
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
          sub_10077EE24((void ***)&__dst);
        }
      }
      sub_100044D00((const void **)&v212);
      LODWORD(v15) = 200;
    }
    else
    {
      if (v11 && !*(_DWORD *)(a1 + 120))
      {
        sub_100FAC734(buf);
        int64_t v130 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
        sub_100F998B8(v201, *v10, a1 + 144, a1 + 400, (void ***)buf, v15 | (unint64_t)&_mh_execute_header, 0, (int)&v215, v130, 1, 0);
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        sub_10077EE24((void ***)&__dst);
      }
      BOOL v26 = 1;
    }
  }
  else
  {
    if (v11 && !*(_DWORD *)(a1 + 120))
    {
      sub_100FAC734(buf);
      int64_t v116 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
      sub_100F998B8(v201, *v10, a1 + 144, a1 + 400, (void ***)buf, 0, 0, (int)&v215, v116, 1, 0);
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
      sub_10077EE24((void ***)&__dst);
    }
    BOOL v26 = 0;
  }
LABEL_56:
  uint64_t v33 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v35 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v34;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v35;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%svalidateAndParseHttpResponse_sync  ", buf, 0x2Au);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&theDict);
  if (SHIBYTE(v217) < 0) {
    operator delete(v215);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  v202 = (long long *)(a1 + 536);
  if (v26)
  {
    v212 = 0;
    v213 = 0;
    uint64_t v214 = 0;
    (*(void (**)(void **__return_ptr))(*(void *)*a2 + 56))(&v212);
    xpc_object_t v36 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v38 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v37;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v38;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sreceived header:", buf, 0x2Au);
    }
    BOOL v204 = v26;
    long long v39 = v212;
    if (v212 != &v213)
    {
      do
      {
        uint64_t v40 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          long long v42 = v39 + 4;
          if (*((char *)v39 + 55) < 0) {
            long long v42 = (void *)*v42;
          }
          xpc_object_t v43 = v39 + 7;
          if (*((char *)v39 + 79) < 0) {
            xpc_object_t v43 = (void *)*v43;
          }
          uint64_t v44 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136316418;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v44;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          *(_WORD *)&buf[42] = 2080;
          *(void *)&buf[44] = v42;
          *(_WORD *)&buf[52] = 2080;
          *(void *)&buf[54] = v43;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  %s: %s", buf, 0x3Eu);
        }
        xpc_object_t v45 = (void *)v39[1];
        if (v45)
        {
          do
          {
            uint64_t v46 = (void **)v45;
            xpc_object_t v45 = (void *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            uint64_t v46 = (void **)v39[2];
            BOOL v47 = *v46 == v39;
            long long v39 = v46;
          }
          while (!v47);
        }
        long long v39 = v46;
      }
      while (v46 != &v213);
    }
    if (v15 != 200)
    {
      BOOL v47 = v15 == 401;
      uint64_t v48 = (void *)(a1 + 536);
      if (v47 && *(_DWORD *)(a1 + 172) == 2)
      {
        *(_DWORD *)(a1 + 176) = 0;
        if (*(unsigned char *)(a1 + 336))
        {
          if (*(char *)(a1 + 335) < 0) {
            operator delete(*(void **)(a1 + 312));
          }
          *(unsigned char *)(a1 + 336) = 0;
        }
        if (*(void *)(a1 + 552))
        {
          uint64_t v49 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v51 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v50;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v51;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sRe-Authentication failed", buf, 0x2Au);
          }
        }
        else
        {
          long long v120 = *v202;
          *(void *)v202 = 0;
          *(void *)(a1 + 544) = 0;
          xpc_object_t v121 = *(std::__shared_weak_count **)(a1 + 560);
          *(_OWORD *)(a1 + 552) = v120;
          if (v121) {
            sub_10004D2C8(v121);
          }
          v209 = 0;
          v210 = 0;
          uint64_t v211 = 0;
          (*(void (**)(void **__return_ptr))(*(void *)*a2 + 56))(&v209);
          int v122 = (*(uint64_t (**)(void))(*(void *)*a2 + 80))();
          xpc_object_t v123 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v124 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v125 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v124;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v125;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = v122;
            _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scipher suite: 0x%X", buf, 0x30u);
          }
          xpc_object_t v126 = *(PersonalityInfo ****)(a1 + 128);
          if (*((unsigned char *)v126 + 296))
          {
            long long v235 = 0u;
            uint64_t v238 = 0;
            long long v236 = 0u;
            long long v237 = 0u;
            long long v234 = 0u;
            memset(buf, 0, sizeof(buf));
            HIDWORD(v235) = 3;
            memset(v239, 0, 40);
            xpc_object_t v127 = **v126;
            v128 = (*v126)[1];
            if (v128)
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)v128 + 1, 1uLL, memory_order_relaxed);
              xpc_object_t v129 = *(std::__shared_weak_count **)&buf[8];
              *(void *)int buf = v127;
              *(void *)&uint8_t buf[8] = v128;
              if (v129) {
                sub_10004D2C8(v129);
              }
            }
            else
            {
              *(_OWORD *)int buf = (unint64_t)**v126;
            }
            std::string::operator=((std::string *)&buf[16], (const std::string *)(*(void *)(a1 + 128) + 168));
            uint64_t v158 = *(void *)(a1 + 128);
            if (&buf[40] != (unsigned char *)(v158 + 216))
            {
              sub_10005CA3C((uint64_t)&buf[40], *(std::string **)(v158 + 216), *(long long **)(v158 + 224), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v158 + 224) - *(void *)(v158 + 216)) >> 3));
              uint64_t v158 = *(void *)(a1 + 128);
            }
            sub_100179AF8((std::string *)&buf[64], (const std::string *)(v158 + 304));
            BYTE8(v235) = *(_DWORD *)(*(void *)(a1 + 128) + 288) == 2;
            sub_100FA6008(&__dst, a1, a1 + 400);
            if (SBYTE7(v235) < 0) {
              operator delete((void *)v234);
            }
            long long v234 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            *(void *)&long long v235 = *((void *)&__dst.__r_.__value_.__l + 2);
            LOWORD(v239[2]) = v122;
            CFDictionaryRef theDict = 0;
            sub_100CEA358(*(const void ***)(a1 + 144), &theDict);
            if (theDict) {
              long long v159 = sub_100080778;
            }
            else {
              long long v159 = 0;
            }
            if (v159)
            {
              CFBooleanRef Value = (unsigned int *)CFDictionaryGetValue(theDict, @"BsfPort");
              xpc_object_t v161 = Value;
              LODWORD(__dst.__r_.__value_.__l.__data_) = 0;
              if (Value)
              {
                CFTypeID v162 = CFGetTypeID(Value);
                if (v162 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__dst, v161, v163);
                }
              }
              LODWORD(v236) = __dst.__r_.__value_.__l.__data_;
              xpc_object_t v164 = (BOOL *)CFDictionaryGetValue(theDict, @"BsfUseSecureTransport");
              xpc_object_t v165 = v164;
              __dst.__r_.__value_.__s.__data_[0] = 0;
              if (v164)
              {
                CFTypeID v166 = CFGetTypeID(v164);
                if (v166 == CFBooleanGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__dst, v165, v167);
                }
              }
              BYTE4(v236) = __dst.__r_.__value_.__s.__data_[0];
              xpc_object_t v168 = CFDictionaryGetValue(theDict, @"BsfHost");
              if (v168)
              {
                CFTypeID v169 = CFGetTypeID(v168);
                if (v169 == CFStringGetTypeID())
                {
                  memset(&__dst, 0, sizeof(__dst));
                  ctu::cf::assign();
                  *(void *)std::string __p = __dst.__r_.__value_.__l.__size_;
                  std::string::size_type v170 = __dst.__r_.__value_.__r.__words[0];
                  *(void *)&__p[7] = *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 7);
                  char v171 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                  if ((_BYTE)v238)
                  {
                    if (SHIBYTE(v237) < 0) {
                      operator delete(*((void **)&v236 + 1));
                    }
                    *((void *)&v236 + 1) = v170;
                    *(void *)&long long v237 = *(void *)__p;
                    *(void *)((char *)&v237 + 7) = *(void *)&__p[7];
                    HIBYTE(v237) = v171;
                  }
                  else
                  {
                    *((void *)&v236 + 1) = __dst.__r_.__value_.__r.__words[0];
                    *(void *)&long long v237 = *(void *)__p;
                    *(void *)((char *)&v237 + 7) = *(void *)&__p[7];
                    HIBYTE(v237) = *((unsigned char *)&__dst.__r_.__value_.__s + 23);
                    LOBYTE(v238) = 1;
                  }
                }
              }
            }
            xpc_object_t v174 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v175 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v176 = *(void *)(a1 + 160);
              if (buf[39] >= 0) {
                xpc_object_t v177 = &buf[16];
              }
              else {
                xpc_object_t v177 = *(unsigned char **)&buf[16];
              }
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136316162;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v175;
              WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
              HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
              uint64_t v228 = v176;
              __int16 v229 = 2080;
              v230 = "";
              __int16 v231 = 2080;
              unint64_t v232 = (unint64_t)v177;
              _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPI: %s", (uint8_t *)&__dst, 0x34u);
              xpc_object_t v174 = *(NSObject **)(a1 + 40);
            }
            if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v178 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v179 = *(void *)(a1 + 160);
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136316162;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v178;
              WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
              HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
              uint64_t v228 = v179;
              __int16 v229 = 2080;
              v230 = "";
              __int16 v231 = 2048;
              unint64_t v232 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[48] - *(void *)&buf[40]) >> 3);
              _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPU: %lu items", (uint8_t *)&__dst, 0x34u);
            }
            unint64_t v180 = *(void *)&buf[40];
            for (uint64_t i = *(void *)&buf[48]; v180 != i; v180 += 24)
            {
              long long v182 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
              {
                std::string::size_type v183 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                unint64_t v184 = v180;
                if (*(char *)(v180 + 23) < 0) {
                  unint64_t v184 = *(void *)v180;
                }
                uint64_t v185 = *(void *)(a1 + 160);
                LODWORD(__dst.__r_.__value_.__l.__data_) = 136316162;
                *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v183;
                WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
                uint64_t v228 = v185;
                __int16 v229 = 2080;
                v230 = "";
                __int16 v231 = 2080;
                unint64_t v232 = v184;
                _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPU: %s", (uint8_t *)&__dst, 0x34u);
              }
            }
            if (!sub_100FA09C4(a1) && (*(unsigned char *)(*(void *)(a1 + 144) + 96) & 1) != 0 && *(unsigned char *)(a1 + 769))
            {
              long long v186 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
              {
                std::string::size_type v187 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                uint64_t v188 = *(void *)(a1 + 160);
                LODWORD(__dst.__r_.__value_.__l.__data_) = 136315906;
                *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v187;
                WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
                uint64_t v228 = v188;
                __int16 v229 = 2080;
                v230 = "";
                _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sGBA authentication will go over Entitlement service", (uint8_t *)&__dst, 0x2Au);
              }
              __dst.__r_.__value_.__r.__words[0] = kCTDataConnectionServiceTypeEntitlementTraffic;
              sub_100013168((const void **)v239, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
              std::string::operator=((std::string *)((char *)v239 + 8), ***(const std::string ****)(a1 + 128));
            }
            v189 = *(NSObject **)(a1 + 24);
            v223 = v189;
            if (v189) {
              dispatch_retain(v189);
            }
            v215 = _NSConcreteStackBlock;
            uint64_t v216 = 3321888768;
            v217 = sub_100FA7CD0;
            v218 = &unk_101A77778;
            __int16 v190 = *(std::__shared_weak_count **)(a1 + 16);
            if (v190)
            {
              uint64_t v191 = *(void *)(a1 + 8);
              v192 = std::__shared_weak_count::lock(v190);
              if (v192)
              {
                v193 = v192;
                p_shared_weak_owners = &v192->__shared_weak_owners_;
                atomic_fetch_add_explicit(&v192->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v192);
                uint64_t v219 = a1;
                uint64_t v220 = v191;
                v221 = v193;
                atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                sub_1007D6704(&__dst);
              }
            }
            sub_100088B9C();
          }
          v145 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v146 = PersonalityInfo::logPrefix(**v126);
            uint64_t v147 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v146;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v147;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sAuthentication Failure. Cannot initiate GBA authentication", buf, 0x2Au);
          }
          sub_10010C0E0((uint64_t)&v209, v210);
        }
      }
      BOOL v204 = 0;
      char v52 = 0;
      goto LABEL_221;
    }
    unint64_t v53 = sub_100F9706C(a1, (uint64_t)v208);
    uint64_t v48 = (void *)(a1 + 536);
    if (!(_BYTE)v53)
    {
      sub_10010C0E0((uint64_t)&v212, v213);
      goto LABEL_241;
    }
    LODWORD(v207) = HIDWORD(v53);
    BYTE4(v207) = 1;
    if ((v53 & 0xFF00) == 0)
    {
      xpc_object_t v117 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v118 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v119 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v118;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v119;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = "";
        _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sAuthentication Failure", buf, 0x2Au);
      }
      BOOL v204 = 0;
      char v52 = 0;
      *(_DWORD *)(a1 + 176) = 0;
      BOOL v26 = 1;
      goto LABEL_222;
    }
    int v54 = 0;
    uint64_t v55 = 0;
    uint64_t v56 = *v201;
    do
    {
      memset(buf, 0, 24);
      sub_100FBA50C(v56, v54, (const void **)buf);
      xpc_object_t v57 = *(const void **)buf;
      if (*(void *)buf) {
        xpc_object_t v58 = sub_100080778;
      }
      else {
        xpc_object_t v58 = 0;
      }
      if (v58)
      {
        v215 = 0;
        uint64_t v216 = 0;
        long long v59 = *(_OWORD *)&v208[0][v55];
        uint64_t v60 = v208[0][v55 + 1];
        if (v60) {
          atomic_fetch_add_explicit(v60 + 1, 1uLL, memory_order_relaxed);
        }
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v59;
        LOBYTE(v209) = 0;
        BYTE4(v209) = 0;
        *(void *)std::string __p = v57;
        if (v57) {
          CFRetain(v57);
        }
        CFDictionaryRef theDict = *(CFDictionaryRef *)&buf[16];
        if (*(void *)&buf[16]) {
          CFRetain(*(CFTypeRef *)&buf[16]);
        }
        sub_100F9920C((uint64_t)&v215, *(void *)(v56 + 96), v54, (uint64_t)&__dst, (uint64_t)&v209, (const void **)__p);
        sub_1000577C4((const void **)&theDict);
        sub_100057D78((const void **)__p);
        if (__dst.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
        }
        long long v61 = v215;
        long long v62 = (std::__shared_weak_count *)v216;
        if (v216)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v216 + 8), 1uLL, memory_order_relaxed);
          long long v63 = v208[0];
          atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          long long v63 = v208[0];
        }
        long long v64 = &v63[v55];
        xpc_object_t v65 = (std::__shared_weak_count *)v64[1];
        *long long v64 = v61;
        v64[1] = v62;
        if (v65) {
          sub_10004D2C8(v65);
        }
        if (v62)
        {
          sub_10004D2C8(v62);
          sub_10004D2C8(v62);
        }
      }
      sub_1000577C4((const void **)&buf[16]);
      sub_1000577C4((const void **)&buf[8]);
      sub_100057D78((const void **)buf);
      v55 += 2;
      ++v54;
    }
    while (v55 != 56);
    uint64_t v66 = 0;
    char v196 = 0;
    uint64_t v206 = *(void *)(a1 + 576);
    v198 = (uint64_t **)(a1 + 680);
    v199 = (uint64_t *)(a1 + 688);
    do
    {
      xpc_object_t v67 = (int **)&v208[0][2 * v66];
      int v69 = *v67;
      uint64_t v68 = (std::__shared_weak_count *)v67[1];
      if (v68) {
        atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v69)
      {
        unint64_t v70 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v72 = *(void *)(a1 + 160);
          xpc_object_t v73 = (uint64_t *)(*(void *)(v206 + 96) + 16 * v66);
          uint64_t v74 = *v73;
          uint64_t v75 = (std::__shared_weak_count *)v73[1];
          if (v75) {
            atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v76 = (*(uint64_t (**)(uint64_t))(*(void *)v74 + 40))(v74);
          if (v75) {
            sub_10004D2C8(v75);
          }
          v77 = sub_100FB56F4(*v69);
          *(_DWORD *)int buf = 136316418;
          *(void *)&uint8_t buf[4] = v71;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v72;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          *(_WORD *)&buf[42] = 2080;
          *(void *)&buf[44] = v76;
          *(_WORD *)&buf[52] = 2080;
          *(void *)&buf[54] = v77;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%saction %s = %s", buf, 0x3Eu);
        }
        int v78 = *v69;
        switch(*v69)
        {
          case 6000:
            uint64_t v94 = *v199;
            if (*v199)
            {
              uint64_t v95 = a1 + 688;
              do
              {
                uint64_t v96 = *(int *)(v94 + 28);
                BOOL v97 = v66 <= v96;
                if (v66 <= v96) {
                  uint64_t v98 = (uint64_t *)v94;
                }
                else {
                  uint64_t v98 = (uint64_t *)(v94 + 8);
                }
                if (v97) {
                  uint64_t v95 = v94;
                }
                uint64_t v94 = *v98;
              }
              while (*v98);
              if ((uint64_t *)v95 != v199 && v66 >= *(int *)(v95 + 28))
              {
                sub_10006C514(v198, (uint64_t *)v95);
                operator delete((void *)v95);
              }
            }
            goto LABEL_159;
          case 6001:
          case 6002:
          case 6003:
          case 6010:
            uint64_t v79 = (uint64_t **)(a1 + 688);
            break;
          case 6004:
            v86 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v87 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v88 = *(void *)(a1 + 160);
              xpc_object_t v89 = (uint64_t *)(*(void *)(v206 + 96) + 16 * v66);
              uint64_t v90 = *v89;
              v91 = (std::__shared_weak_count *)v89[1];
              if (v91) {
                atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v92 = (*(uint64_t (**)(uint64_t))(*(void *)v90 + 40))(v90);
              if (v91) {
                sub_10004D2C8(v91);
              }
              v93 = sub_100FB56F4(*v69);
              *(_DWORD *)int buf = 136316674;
              *(void *)&uint8_t buf[4] = v87;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&uint8_t buf[24] = v88;
              *(_WORD *)&unsigned char buf[32] = 2080;
              *(void *)&buf[34] = "";
              *(_WORD *)&buf[42] = 2080;
              *(void *)&buf[44] = v92;
              *(_WORD *)&buf[52] = 2080;
              *(void *)&buf[54] = v93;
              *(_WORD *)&buf[62] = 2080;
              *(void *)&buf[64] = "STATUS_TEMPORARY_FAILURE";
              _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%saction %s replied with incorrect code %s -> treating as %s", buf, 0x48u);
            }
            goto LABEL_139;
          case 6005:
LABEL_139:
            char v196 = 1;
            goto LABEL_159;
          default:
            goto LABEL_159;
        }
        while (1)
        {
          uint64_t v80 = *v79;
          uint64_t v81 = v79;
          if (!*v79) {
            break;
          }
          while (1)
          {
            uint64_t v79 = (uint64_t **)v80;
            uint64_t v82 = *((int *)v80 + 7);
            if (v66 < v82) {
              break;
            }
            if (v66 <= v82)
            {
              uint64_t v83 = v79;
              goto LABEL_153;
            }
            uint64_t v80 = v79[1];
            if (!v80)
            {
              uint64_t v81 = v79 + 1;
              goto LABEL_130;
            }
          }
        }
LABEL_130:
        uint64_t v83 = operator new(0x28uLL);
        v83[7] = v66;
        v83[8] = 0;
        *(void *)uint64_t v83 = 0;
        *((void *)v83 + 1) = 0;
        *((void *)v83 + 2) = v79;
        *uint64_t v81 = (uint64_t *)v83;
        v84 = (uint64_t *)**v198;
        v85 = (uint64_t *)v83;
        if (v84)
        {
          *v198 = v84;
          v85 = *v81;
        }
        sub_100046C90(*(uint64_t **)(a1 + 688), v85);
        ++*(void *)(a1 + 696);
LABEL_153:
        v83[8] = v78;
        uint64_t v99 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v100 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v101 = *(void *)(a1 + 160);
          v102 = (uint64_t *)(*(void *)(v206 + 96) + 16 * v66);
          uint64_t v103 = *v102;
          v104 = (std::__shared_weak_count *)v102[1];
          if (v104) {
            atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v105 = (*(uint64_t (**)(uint64_t))(*(void *)v103 + 40))(v103);
          if (v104) {
            sub_10004D2C8(v104);
          }
          uint64_t v106 = sub_100FB56F4(*v69);
          *(_DWORD *)int buf = 136316418;
          *(void *)&uint8_t buf[4] = v100;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v101;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          *(_WORD *)&buf[42] = 2080;
          *(void *)&buf[44] = v105;
          *(_WORD *)&buf[52] = 2080;
          *(void *)&buf[54] = v106;
          _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smarked action %s failed with vital %s", buf, 0x3Eu);
        }
      }
LABEL_159:
      if (v68) {
        sub_10004D2C8(v68);
      }
      ++v66;
    }
    while (v66 != 28);
    uint64_t v107 = *v201;
    if (!sub_100FBA740(*v201, 0))
    {
      xpc_object_t v132 = *v208[0];
      xpc_object_t v131 = (std::__shared_weak_count *)v208[0][1];
      if (v131)
      {
        atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v131);
        if (!v132) {
          goto LABEL_163;
        }
        xpc_object_t v132 = *v208[0];
        xpc_object_t v133 = (std::__shared_weak_count *)v208[0][1];
        if (v133) {
          atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        if (!v132) {
          goto LABEL_163;
        }
        xpc_object_t v133 = 0;
      }
      v215 = v132;
      uint64_t v216 = (uint64_t)v133;
      CFDictionaryRef theDict = 0;
      *(void *)std::string __p = 0;
      sub_100F992F4(a1, v107, 0, 3, (uint64_t *)&v215, (const void **)__p, (const void **)&theDict);
      sub_1000577C4((const void **)&theDict);
      sub_100057D78((const void **)__p);
      if (v216) {
        sub_10004D2C8((std::__shared_weak_count *)v216);
      }
    }
LABEL_163:
    for (uint64_t j = 0; j != 28; ++j)
    {
      memset(buf, 0, 24);
      sub_100FBA50C(v107, j, (const void **)buf);
      char v109 = *(NSObject **)buf;
      if (*(void *)buf) {
        long long v110 = sub_100080778;
      }
      else {
        long long v110 = 0;
      }
      if (v110)
      {
        long long v111 = *(_OWORD *)&v208[0][2 * j];
        xpc_object_t v112 = v208[0][2 * j + 1];
        if (v112) {
          atomic_fetch_add_explicit(v112 + 1, 1uLL, memory_order_relaxed);
        }
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v111;
        v223 = v109;
        if (v109) {
          CFRetain(v109);
        }
        v222 = *(const void **)&buf[16];
        if (*(void *)&buf[16]) {
          CFRetain(*(CFTypeRef *)&buf[16]);
        }
        sub_100F992F4(a1, v107, j, 3, (uint64_t *)&__dst, (const void **)&v223, &v222);
        sub_1000577C4(&v222);
        sub_100057D78((const void **)&v223);
        if (__dst.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
        }
      }
      sub_1000577C4((const void **)&buf[16]);
      sub_1000577C4((const void **)&buf[8]);
      xpc_object_t v113 = sub_100057D78((const void **)buf);
    }
    xpc_object_t v114 = v208[0][26];
    xpc_object_t v115 = (std::__shared_weak_count *)v208[0][27];
    if (v115)
    {
      atomic_fetch_add_explicit(&v115->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v48 = (void *)(a1 + 536);
      char v52 = v196;
      if (!v114)
      {
LABEL_277:
        sub_10004D2C8(v115);
        goto LABEL_221;
      }
      atomic_fetch_add_explicit(&v115->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v48 = (void *)(a1 + 536);
      char v52 = v196;
      if (!v114)
      {
LABEL_221:
        BOOL v26 = 0;
LABEL_222:
        sub_10010C0E0((uint64_t)&v212, v213);
        goto LABEL_223;
      }
    }
    uint64_t v134 = v114[1];
    if (v134)
    {
      *(void *)int buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_100FA9C74;
      *(void *)&uint8_t buf[24] = &unk_101A77D70;
      *(void *)&unsigned char buf[32] = v134;
      SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v113);
      xpc_object_t v136 = (void *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80109u);
      v209 = v136;
      if (v136)
      {
        xpc_object_t v137 = sub_10001C8F4(8);
        uint64_t v139 = *v137;
        xpc_object_t v138 = (std::__shared_weak_count *)v137[1];
        if (v138) {
          atomic_fetch_add_explicit(&v138->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v139) {
          operator new();
        }
        if (v138) {
          sub_10004D2C8(v138);
        }
        wis::MetricContainer::~MetricContainer((wis::MetricContainer *)v136);
        operator delete();
      }
    }
    if (!v115) {
      goto LABEL_221;
    }
    sub_10004D2C8(v115);
    goto LABEL_277;
  }
  BOOL v204 = 0;
  char v52 = 0;
  uint64_t v48 = (void *)(a1 + 536);
LABEL_223:
  if ((v52 | v26)) {
    sub_100F9DEA4(a1, v26);
  }
  long long v148 = *(NSObject **)(a1 + 40);
  BOOL v149 = os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT);
  if (v204)
  {
    if (v149)
    {
      uint64_t v150 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v151 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v150;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v151;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sHTTP response processing complete with success", buf, 0x2Au);
    }
    sub_100CECA44(a1, (uint64_t)"HTTP response processing complete with success", ((v52 | v26) & 1) == 0);
  }
  else
  {
    if (v149)
    {
      uint64_t v152 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v153 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v152;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v153;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sHTTP response invalid or authentication failed, invalidate request and try again", buf, 0x2Au);
    }
    sub_100F9E344(a1, v26, (uint64_t)&v207);
  }
  xpc_object_t v154 = *(std::__shared_weak_count **)(a1 + 584);
  *(_OWORD *)(a1 + 576) = 0u;
  if (v154) {
    sub_10004D2C8(v154);
  }
  xpc_object_t v155 = *(std::__shared_weak_count **)(a1 + 544);
  void *v48 = 0;
  v48[1] = 0;
  if (v155) {
    sub_10004D2C8(v155);
  }
  xpc_object_t v156 = *(std::__shared_weak_count **)(a1 + 560);
  v48[2] = 0;
  v48[3] = 0;
  if (v156) {
    sub_10004D2C8(v156);
  }
  xpc_object_t v157 = *(std::__shared_weak_count **)(a1 + 760);
  *(_OWORD *)(a1 + 752) = 0u;
  if (v157) {
    sub_10004D2C8(v157);
  }
  sub_100F937E8(a1);
LABEL_241:
  *(void *)int buf = v208;
  sub_10077EE24((void ***)buf);
}

void sub_100F9DB00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44,uint64_t a45,uint64_t a46,const void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  a35 = &a29;
  sub_10077EE24((void ***)&a35);
  _Unwind_Resume(a1);
}

void sub_100F9DEA4(uint64_t a1, int a2)
{
  ++*(_DWORD *)(a1 + 368);
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    uint64_t v7 = "TEMP";
    int v8 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)int buf = 136316418;
    if (a2) {
      uint64_t v7 = "AUTH";
    }
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v6;
    __int16 v38 = 2080;
    long long v39 = "";
    __int16 v40 = 2080;
    uint64_t v41 = v7;
    __int16 v42 = 1024;
    int v43 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sServer reported %s failure on one of actions, fServerBackoffCnt = %d", buf, 0x3Au);
  }
  uint64_t v9 = *(void *)(a1 + 128);
  if (*(unsigned char *)(v9 + 465) && *(unsigned char *)(v9 + 464))
  {
    uint64_t v10 = 86400000000;
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v9);
      uint64_t v13 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v36 = 2080;
      uint64_t v37 = v13;
      __int16 v38 = 2080;
      long long v39 = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sengaging block on communication until next Monitor Mode retry", buf, 0x2Au);
    }
  }
  else
  {
    int v14 = *(_DWORD *)(a1 + 368);
    unsigned int v15 = sub_100CEBA78(*(void *)(a1 + 144)) * v14;
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v18 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v36 = 2080;
      uint64_t v37 = v18;
      __int16 v38 = 2080;
      long long v39 = "";
      __int16 v40 = 1024;
      LODWORD(v41) = v15;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sengaging %u seconds block on communication", buf, 0x30u);
    }
    uint64_t v10 = 1000000 * v15;
  }
  unsigned int v19 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v19 || (v20 = *(void *)(a1 + 8), (uint64_t v21 = std::__shared_weak_count::lock(v19)) == 0)) {
    sub_100088B9C();
  }
  __int16 v22 = v21;
  atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 48));
  uint64_t v23 = *(void *)buf;
  sub_100058DB0(__p, "server initiated backoff");
  __int16 v24 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v24;
  if (v24) {
    dispatch_retain(v24);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3321888768;
  aBlock[2] = sub_100F9FA6C;
  aBlock[3] = &unk_101A776E8;
  aBlock[4] = a1;
  aBlock[5] = v20;
  uint64_t v29 = v22;
  atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v30 = _Block_copy(aBlock);
  sub_100118A44(v23, (uint64_t)__p, 1, v10, &object, &v30);
  uint64_t v25 = v34;
  uint64_t v34 = 0;
  uint64_t v26 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = v25;
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    uint64_t v27 = v34;
    uint64_t v34 = 0;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
  }
  if (v30) {
    _Block_release(v30);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  std::__shared_weak_count::__release_weak(v22);
}

void sub_100F9E2C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9E344(uint64_t a1, BOOL a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    int v8 = *(void **)(a1 + 160);
    uint64_t v9 = asStringBool(a2);
    uint64_t v10 = asStringBool(*(void *)(a1 + 576) != 0);
    uint64_t v11 = *(void *)(a1 + 576);
    if (v11 && (uint64_t v12 = *(void *)(v11 + 120), (v12 & 0xFF00000000) != 0)) {
      uint64_t v13 = sub_100059954(v12);
    }
    else {
      uint64_t v13 = "-";
    }
    if (*(unsigned char *)(a3 + 4)) {
      int v14 = sub_100FB56F4(*(_DWORD *)a3);
    }
    else {
      int v14 = "-";
    }
    *(_DWORD *)int buf = 136316930;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    int v78 = v8;
    *(_WORD *)uint64_t v79 = 2080;
    *(void *)&v79[2] = "";
    *(_WORD *)&v79[10] = 2080;
    *(void *)&v79[12] = v9;
    *(_WORD *)&v79[20] = 2080;
    uint64_t v80 = v10;
    __int16 v81 = 2080;
    uint64_t v82 = v13;
    __int16 v83 = 2080;
    v84 = v14;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%shandleRequestFailureAndMergeWithPending_sync (%s), fRequestedQuery:%s, dedicated:%s, status_override:%s", buf, 0x52u);
  }
  uint64_t v15 = *(void *)(a1 + 576);
  if (v15)
  {
    *(_DWORD *)(a1 + 176) = 0;
    int v16 = *(_DWORD *)(a1 + 348) + 1;
    *(_DWORD *)(a1 + 348) = v16;
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v42 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      int v43 = *(void **)(a1 + 160);
      int v44 = *(_DWORD *)(a1 + 348);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v42;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      int v78 = v43;
      *(_WORD *)uint64_t v79 = 2080;
      *(void *)&v79[2] = "";
      *(_WORD *)&v79[10] = 1024;
      *(_DWORD *)&v79[12] = v44;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "#E %s%s%s%sHttp Request Failure, %d Total Failures", buf, 0x30u);
      int v16 = *(_DWORD *)(a1 + 348);
    }
    if (v16 >= 5)
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v20 = *(void **)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        int v78 = v20;
        *(_WORD *)uint64_t v79 = 2080;
        *(void *)&v79[2] = "";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sExceeded Max Failures, clearing pending transactions", buf, 0x2Au);
      }
      sub_100F91C6C(a1, 1, a3);
    }
    if (*(unsigned char *)(a1 + 356))
    {
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v23 = *(void **)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        int v78 = v23;
        *(_WORD *)uint64_t v79 = 2080;
        *(void *)&v79[2] = "";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sSubscriber blocked, clearing pending transactions", buf, 0x2Au);
      }
      sub_100F91C6C(a1, 1, a3);
    }
    if (!sub_100F9FDF8(a1))
    {
      sub_100FBA7A0(v15);
      int v24 = 0;
      *(void *)&long long v25 = 136316162;
      long long v60 = v25;
      do
      {
        CFTypeRef cf = 0;
        uint64_t v72 = 0;
        CFTypeRef v73 = 0;
        sub_100FBA50C(v15, v24, &cf);
        if (v72) {
          uint64_t v26 = sub_100080934;
        }
        else {
          uint64_t v26 = 0;
        }
        if (v26) {
          uint64_t v27 = v72;
        }
        else {
          uint64_t v27 = 0;
        }
        if (cf) {
          uint64_t v28 = sub_100080778;
        }
        else {
          uint64_t v28 = 0;
        }
        if (v28 && ([v27 hasLeftAttempts] & 1) == 0)
        {
          uint64_t v29 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v30 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v31 = *(void **)(a1 + 160);
            *(_DWORD *)int buf = v60;
            *(void *)&uint8_t buf[4] = v30;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            int v78 = v31;
            *(_WORD *)uint64_t v79 = 2080;
            *(void *)&v79[2] = "";
            *(_WORD *)&v79[10] = 2112;
            *(void *)&v79[12] = v27;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sFailing because 'No more attempts' request:%@", buf, 0x34u);
          }
          *(void *)int buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t v67 = 0;
          uint64_t v68 = 0;
          CFTypeRef v66 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v65 = v73;
          if (v73) {
            CFRetain(v73);
          }
          sub_100F9920C((uint64_t)buf, *(void *)(v15 + 96), v24, (uint64_t)&v67, a3, &v66);
          sub_1000577C4(&v65);
          sub_100057D78(&v66);
          if (v68) {
            sub_10004D2C8(v68);
          }
          uint64_t v32 = *(std::__shared_weak_count **)&buf[8];
          uint64_t v63 = *(void *)buf;
          long long v64 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
          }
          CFTypeRef v62 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v61 = v73;
          if (v73) {
            CFRetain(v73);
          }
          sub_100F992F4(a1, v15, v24, 1, &v63, &v62, &v61);
          sub_1000577C4(&v61);
          sub_100057D78(&v62);
          if (v64) {
            sub_10004D2C8(v64);
          }
          sub_100FBA3D4(v15, v27);
          if (v32) {
            sub_10004D2C8(v32);
          }
        }
        sub_1000577C4(&v73);
        sub_1000577C4((const void **)&v72);
        sub_100057D78(&cf);
        ++v24;
      }
      while (v24 != 28);
      sub_100F9FBF4(a1, 2, v15, a3);
      char v33 = *(void **)(v15 + 40);
      if (v33 && [v33 count] == (id)1)
      {
        sub_100FBBFD8(v15);
        uint64_t v34 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          __int16 v36 = *(void **)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v35;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          int v78 = v36;
          *(_WORD *)uint64_t v79 = 2080;
          *(void *)&v79[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sno elements in the query except Authentication - dropping query", buf, 0x2Au);
        }
        *(_DWORD *)(v15 + 32) = 0;
        objc_msgSend(*(id *)(v15 + 40), "removeAllObjects", v60, v61, v62, v63);
        *(void *)(v15 + 80) = 0;
        *(void *)(v15 + 88) = 0;
      }
    }
    int v37 = *(_DWORD *)(a1 + 348);
    if (v37)
    {
      int v38 = sub_100CEBA04(*(void *)(a1 + 144));
      if (sub_100F9FDF8(a1))
      {
        long long v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v40 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v41 = *(void **)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v40;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          int v78 = v41;
          *(_WORD *)uint64_t v79 = 2080;
          *(void *)&v79[2] = "";
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sprevious interim failure detected", buf, 0x2Au);
        }
        *(int32x2_t *)(a1 + 348) = vadd_s32(*(int32x2_t *)(a1 + 348), (int32x2_t)0x1FFFFFFFFLL);
        int v37 = 3;
      }
      else
      {
        v37 *= v38;
        *(_DWORD *)(a1 + 352) = 0;
      }
    }
    xpc_object_t v45 = *(std::__shared_weak_count **)(a1 + 744);
    *(_OWORD *)(a1 + 736) = 0u;
    if (v45) {
      sub_10004D2C8(v45);
    }
    if (v37)
    {
      uint64_t v46 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v47 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v48 = *(void **)(a1 + 160);
        int v49 = *(_DWORD *)(a1 + 348);
        int v50 = *(_DWORD *)(a1 + 352);
        *(_DWORD *)int buf = 136316674;
        *(void *)&uint8_t buf[4] = v47;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        int v78 = v48;
        *(_WORD *)uint64_t v79 = 2080;
        *(void *)&v79[2] = "";
        *(_WORD *)&v79[10] = 1024;
        *(_DWORD *)&v79[12] = v37;
        *(_WORD *)&v79[16] = 1024;
        *(_DWORD *)&v79[18] = v49;
        LOWORD(v80) = 1024;
        *(_DWORD *)((char *)&v80 + 2) = v50;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________   Adding retry backoff timer in ___ %d ___ seconds, fFailures: ___ %d ___, fInterimFailures: ___ %d ___", buf, 0x3Cu);
      }
      uint64_t v51 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v51 || (v52 = *(void *)(a1 + 8), (unint64_t v53 = std::__shared_weak_count::lock(v51)) == 0)) {
        sub_100088B9C();
      }
      int v54 = v53;
      atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v53);
      Registry::getTimerService(&v74, *(Registry **)(a1 + 48));
      uint64_t v55 = v74;
      sub_100058DB0(&cf, "automatic retry timeout");
      uint64_t v56 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v56;
      if (v56) {
        dispatch_retain(v56);
      }
      *(void *)int buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3321888768;
      *(void *)&uint8_t buf[16] = sub_100FA1FD8;
      int v78 = &unk_101A77718;
      *(void *)uint64_t v79 = v52;
      *(void *)&v79[8] = v54;
      atomic_fetch_add_explicit(&v54->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlock = _Block_copy(buf);
      sub_100118A44(v55, (uint64_t)&cf, 1, 1000000 * v37, &object, &aBlock);
      uint64_t v57 = v76;
      uint64_t v76 = 0;
      uint64_t v58 = *(void *)(a1 + 360);
      *(void *)(a1 + 360) = v57;
      if (v58)
      {
        (*(void (**)(uint64_t))(*(void *)v58 + 8))(v58);
        uint64_t v59 = v76;
        uint64_t v76 = 0;
        if (v59) {
          (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (SHIBYTE(v73) < 0) {
        operator delete((void *)cf);
      }
      if (v75) {
        sub_10004D2C8(v75);
      }
      if (*(void *)&v79[8]) {
        std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v79[8]);
      }
      std::__shared_weak_count::__release_weak(v54);
    }
    sub_100F9EE20(a1, 0);
    sub_100F9F270(a1);
  }
}

void sub_100F9ED14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *aBlock,dispatch_object_t object,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::__shared_weak_count *a41)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9EE20(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 576);
  if (!v2) {
    return;
  }
  int v4 = *(void **)(v2 + 40);
  if (v4 && [v4 count])
  {
    uint64_t v6 = (long long *)(a1 + 576);
    uint64_t v7 = *(void **)(a1 + 600);
    uint64_t v8 = *(void *)(a1 + 576);
    uint64_t v9 = *(void *)(v8 + 120);
    uint64_t v10 = v7[2];
    uint64_t v11 = *(void *)(v10 + 120);
    uint64_t v12 = v9 & 0xFF00000000;
    uint64_t v13 = v11 & 0xFF00000000;
    if ((v9 & 0xFF00000000) == 0 || v13 == 0)
    {
      if ((v12 != 0) == (v13 != 0))
      {
LABEL_16:
        sub_100FBA8A0(*(void *)(a1 + 576), v10);
        long long v23 = *v6;
        *(void *)uint64_t v6 = 0;
        *(void *)(a1 + 584) = 0;
        int v24 = (std::__shared_weak_count *)v7[3];
        *((_OWORD *)v7 + 1) = v23;
        if (v24) {
          sub_10004D2C8(v24);
        }
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        uint64_t v25 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v26 = *(void *)(a1 + 160);
        uint64_t v27 = *(void *)(a1 + 608);
        int v49 = 136316162;
        uint64_t v50 = v25;
        __int16 v51 = 2080;
        uint64_t v52 = " ";
        __int16 v53 = 2080;
        uint64_t v54 = v26;
        __int16 v55 = 2080;
        uint64_t v56 = "";
        __int16 v57 = 2048;
        uint64_t v58 = v27;
        uint64_t v22 = "#I %s%s%s%sMerge failed query into first element of pending queue (%zu elems)";
        goto LABEL_20;
      }
    }
    else if (v9 == v11)
    {
      goto LABEL_16;
    }
    uint64_t v15 = (uint64_t *)(a1 + 592);
    if (a2)
    {
      uint64_t v16 = *(void *)(a1 + 584);
      uint64_t v17 = operator new(0x20uLL);
      v17[2] = v8;
      v17[3] = v16;
      if (v16)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        uint64_t v7 = *(void **)(a1 + 600);
      }
      void *v17 = v15;
      v17[1] = v7;
      void *v7 = v17;
      *(void *)(a1 + 600) = v17;
      ++*(void *)(a1 + 608);
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_21;
      }
      uint64_t v19 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v20 = *(void *)(a1 + 160);
      uint64_t v21 = *(void *)(a1 + 608);
      int v49 = 136316162;
      uint64_t v50 = v19;
      __int16 v51 = 2080;
      uint64_t v52 = " ";
      __int16 v53 = 2080;
      uint64_t v54 = v20;
      __int16 v55 = 2080;
      uint64_t v56 = "";
      __int16 v57 = 2048;
      uint64_t v58 = v21;
      uint64_t v22 = "#I %s%s%s%sAdding failed query back as a first element of pending queue (%zu elems)";
      goto LABEL_20;
    }
    uint64_t v33 = *v15;
    uint64_t v34 = *(void *)(*v15 + 16);
    uint64_t v35 = *(void *)(v34 + 120);
    uint64_t v36 = v35 & 0xFF00000000;
    if (v12) {
      BOOL v37 = v36 == 0;
    }
    else {
      BOOL v37 = 1;
    }
    if (v37)
    {
      if ((v12 != 0) == (v36 != 0))
      {
LABEL_38:
        sub_100FBA8A0(*(void *)(a1 + 576), v34);
        long long v39 = *v6;
        *(void *)uint64_t v6 = 0;
        *(void *)(a1 + 584) = 0;
        uint64_t v40 = *(std::__shared_weak_count **)(v33 + 24);
        *(_OWORD *)(v33 + 16) = v39;
        if (v40) {
          sub_10004D2C8(v40);
        }
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        uint64_t v41 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v42 = *(void *)(a1 + 160);
        uint64_t v43 = *(void *)(a1 + 608);
        int v49 = 136316162;
        uint64_t v50 = v41;
        __int16 v51 = 2080;
        uint64_t v52 = " ";
        __int16 v53 = 2080;
        uint64_t v54 = v42;
        __int16 v55 = 2080;
        uint64_t v56 = "";
        __int16 v57 = 2048;
        uint64_t v58 = v43;
        uint64_t v22 = "#I %s%s%s%sMerge failed query into last element of pending queue (%zu elems)";
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v49, 0x34u);
        goto LABEL_21;
      }
    }
    else if (v9 == v35)
    {
      goto LABEL_38;
    }
    int v38 = *(void **)(*(void *)(a1 + 616) + 40);
    if (v38)
    {
      if ([v38 count])
      {
        sub_100116B10((uint64_t *)(a1 + 592), *(void *)(a1 + 576), *(void *)(a1 + 584));
LABEL_47:
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        uint64_t v46 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v47 = *(void *)(a1 + 160);
        uint64_t v48 = *(void *)(a1 + 608);
        int v49 = 136316162;
        uint64_t v50 = v46;
        __int16 v51 = 2080;
        uint64_t v52 = " ";
        __int16 v53 = 2080;
        uint64_t v54 = v47;
        __int16 v55 = 2080;
        uint64_t v56 = "";
        __int16 v57 = 2048;
        uint64_t v58 = v48;
        uint64_t v22 = "#I %s%s%s%sAdding failed query back as a last element of pending queue (%zu elems)";
        goto LABEL_20;
      }
      uint64_t v33 = *v15;
      uint64_t v8 = *(void *)v6;
    }
    uint64_t v44 = *(void *)(a1 + 584);
    if (v44) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
    }
    xpc_object_t v45 = *(std::__shared_weak_count **)(v33 + 24);
    *(void *)(v33 + 16) = v8;
    *(void *)(v33 + 24) = v44;
    if (v45) {
      sub_10004D2C8(v45);
    }
    goto LABEL_47;
  }
LABEL_21:
  uint64_t v28 = *(std::__shared_weak_count **)(a1 + 584);
  *(_OWORD *)(a1 + 576) = 0u;
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = *(void *)(a1 + 592);
  uint64_t v31 = *(void *)(v29 + 16);
  uint64_t v30 = *(void *)(v29 + 24);
  if (v30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 616) = v31;
  uint64_t v32 = *(std::__shared_weak_count **)(a1 + 624);
  *(void *)(a1 + 624) = v30;
  if (v32) {
    sub_10004D2C8(v32);
  }
}

void sub_100F9F270(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v61 = 2080;
    uint64_t v62 = v4;
    __int16 v63 = 2080;
    long long v64 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%schecking possibly expired queued actions", buf, 0x2Au);
  }
  uint64_t v5 = *(void *)(a1 + 648);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    uint64_t v6 = *(void *)(a1 + 648);
    *(void *)(a1 + 648) = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  uint64_t v7 = *(uint64_t **)(a1 + 600);
  if (v7 != (uint64_t *)(a1 + 592))
  {
    unsigned int v8 = 0;
    while (1)
    {
      for (int i = 0; i != 28; ++i)
      {
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        __int16 v57 = 0;
        sub_100FBA50C(v7[2], i, &v57);
        uint64_t v10 = v58;
        if (v58) {
          uint64_t v11 = sub_100080934;
        }
        else {
          uint64_t v11 = 0;
        }
        if (v11) {
          BOOL v12 = v58 == 0;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          if (v57 ? sub_100080778 : 0)
          {
            if ([v58 expired])
            {
              int v14 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v15 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                uint64_t v16 = *(void *)(a1 + 160);
                *(_DWORD *)int buf = 136316162;
                *(void *)&uint8_t buf[4] = v15;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                __int16 v61 = 2080;
                uint64_t v62 = v16;
                __int16 v63 = 2080;
                long long v64 = "";
                __int16 v65 = 2112;
                CFTypeRef v66 = v10;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sCancelling expired request:{%@}", buf, 0x34u);
              }
              *(void *)int buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              uint64_t v17 = v7[2];
              uint64_t v55 = 0;
              uint64_t v56 = 0;
              v54[0] = 0;
              v54[4] = 0;
              __int16 v53 = v57;
              if (v57) {
                CFRetain(v57);
              }
              uint64_t v52 = v59;
              if (v59) {
                CFRetain(v59);
              }
              sub_100F9920C((uint64_t)buf, *(void *)(v17 + 96), i, (uint64_t)&v55, (uint64_t)v54, &v53);
              sub_1000577C4(&v52);
              sub_100057D78(&v53);
              if (v56) {
                sub_10004D2C8(v56);
              }
              uint64_t v18 = v7[2];
              uint64_t v19 = *(std::__shared_weak_count **)&buf[8];
              uint64_t v50 = *(void *)buf;
              __int16 v51 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
              }
              int v49 = v57;
              if (v57) {
                CFRetain(v57);
              }
              uint64_t v48 = v59;
              if (v59) {
                CFRetain(v59);
              }
              sub_100F992F4(a1, v18, i, 0, &v50, &v49, &v48);
              sub_1000577C4(&v48);
              sub_100057D78(&v49);
              if (v51) {
                sub_10004D2C8(v51);
              }
              sub_100FBA3D4(v7[2], v10);
              if (v19) {
                sub_10004D2C8(v19);
              }
            }
            else if ([v10 cancelationSupported])
            {
              unsigned int v20 = [v10 secondsTillCancelation];
              if (v20 >= v8) {
                unsigned int v21 = v8;
              }
              else {
                unsigned int v21 = v20;
              }
              if (v8) {
                unsigned int v8 = v21;
              }
              else {
                unsigned int v8 = v20;
              }
            }
          }
        }
        sub_1000577C4(&v59);
        sub_1000577C4((const void **)&v58);
        sub_100057D78(&v57);
      }
      uint64_t v22 = v7[2];
      long long v23 = *(void **)(v22 + 40);
      if (v23)
      {
        if ([v23 count]) {
          goto LABEL_56;
        }
        uint64_t v22 = v7[2];
      }
      if (v22 != *(void *)(a1 + 616))
      {
        int v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v26 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          __int16 v61 = 2080;
          uint64_t v62 = v26;
          __int16 v63 = 2080;
          long long v64 = "";
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sremoving empty query from the queue", buf, 0x2Au);
        }
        uint64_t v27 = *v7;
        uint64_t v28 = (uint64_t *)v7[1];
        *(void *)(v27 + 8) = v28;
        *(void *)v7[1] = v27;
        --*(void *)(a1 + 608);
        uint64_t v29 = (std::__shared_weak_count *)v7[3];
        if (v29) {
          sub_10004D2C8(v29);
        }
        operator delete(v7);
        uint64_t v7 = v28;
        goto LABEL_57;
      }
LABEL_56:
      uint64_t v7 = (uint64_t *)v7[1];
LABEL_57:
      if (v7 == (uint64_t *)(a1 + 592))
      {
        if (v8)
        {
          uint64_t v30 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v32 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v31;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int16 v61 = 2080;
            uint64_t v62 = v32;
            __int16 v63 = 2080;
            long long v64 = "";
            __int16 v65 = 1024;
            LODWORD(v66) = v8;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sschedule cancelation recheck in %u seconds", buf, 0x30u);
          }
          uint64_t v33 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v33 || (v34 = *(void *)(a1 + 8), (uint64_t v35 = std::__shared_weak_count::lock(v33)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v36 = v35;
          atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v35);
          Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 48));
          uint64_t v37 = *(void *)buf;
          sub_100058DB0(__p, "entitlement cancelation check");
          int v38 = *(NSObject **)(a1 + 24);
          dispatch_object_t object = v38;
          if (v38) {
            dispatch_retain(v38);
          }
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 3321888768;
          aBlock[2] = sub_100FA1EAC;
          aBlock[3] = &unk_101A776E8;
          aBlock[4] = a1;
          aBlock[5] = v34;
          uint64_t v43 = v36;
          atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          uint64_t v44 = _Block_copy(aBlock);
          sub_100118A44(v37, (uint64_t)__p, 1, 1000000 * v8, &object, &v44);
          long long v39 = v57;
          __int16 v57 = 0;
          uint64_t v40 = *(void *)(a1 + 648);
          *(void *)(a1 + 648) = v39;
          if (v40)
          {
            (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
            uint64_t v41 = v57;
            __int16 v57 = 0;
            if (v41) {
              (*(void (**)(const void *))(*(void *)v41 + 8))(v41);
            }
          }
          if (v44) {
            _Block_release(v44);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v47 < 0) {
            operator delete(__p[0]);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v43) {
            std::__shared_weak_count::__release_weak(v43);
          }
          std::__shared_weak_count::__release_weak(v36);
        }
        return;
      }
    }
  }
}

void sub_100F9F96C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *aBlock,dispatch_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,char a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F9FA6C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 128));
          uint64_t v8 = *(void *)(v3 + 160);
          int v10 = 136315906;
          uint64_t v11 = v7;
          __int16 v12 = 2080;
          uint64_t v13 = " ";
          __int16 v14 = 2080;
          uint64_t v15 = v8;
          __int16 v16 = 2080;
          uint64_t v17 = "";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sblock on communication expired - issuing request if needed", (uint8_t *)&v10, 0x2Au);
        }
        uint64_t v9 = *(void *)(v3 + 376);
        *(void *)(v3 + 376) = 0;
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        }
        sub_100F937E8(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F9FBB0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F9FBC8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F9FBE4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

const void **sub_100F9FBF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (int i = 0; i != 28; ++i)
  {
    CFTypeRef cf = 0;
    long long v23 = 0;
    CFTypeRef v24 = 0;
    sub_100FBA50C(a3, i, &cf);
    if (cf) {
      uint64_t v9 = sub_100080778;
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      uint64_t v20 = 0;
      unsigned int v21 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      CFTypeRef v17 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v16 = v24;
      if (v24) {
        CFRetain(v24);
      }
      sub_100F9920C((uint64_t)&v20, *(void *)(a3 + 96), i, (uint64_t)&v18, a4, &v17);
      sub_1000577C4(&v16);
      sub_100057D78(&v17);
      if (v19) {
        sub_10004D2C8(v19);
      }
      int v10 = v21;
      uint64_t v14 = v20;
      uint64_t v15 = v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      CFTypeRef v13 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v12 = v24;
      if (v24) {
        CFRetain(v24);
      }
      sub_100F992F4(a1, a3, i, a2, &v14, &v13, &v12);
      sub_1000577C4(&v12);
      sub_100057D78(&v13);
      if (v15) {
        sub_10004D2C8(v15);
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
    sub_1000577C4(&v24);
    sub_1000577C4(&v23);
    BOOL result = sub_100057D78(&cf);
  }
  return result;
}

void sub_100F9FDA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, std::__shared_weak_count *);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  sub_1000577C4((const void **)va);
  sub_100057D78((const void **)va1);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100F991C8((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_100F9FDF8(uint64_t a1)
{
  if (*(int *)(a1 + 352) > 2) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 736);
  if (!v1 || *(unsigned char *)(v1 + 24)) {
    return 1;
  }
  uint64_t v3 = *(void *)(v1 + 16);
  return ((unint64_t)(v3 + 1006) < 4 || v3 == -1009)
      && (double)(uint64_t)(*(void *)(v1 + 8) - *(void *)v1) / 1000000.0 < 5.0;
}

void sub_100F9FE64(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 672) == a2[2])
  {
    uint64_t v4 = *(void **)(a1 + 656);
    uint64_t v5 = (void *)(a1 + 664);
    if (v4 == (void *)(a1 + 664)) {
      return;
    }
    uint64_t v6 = (void *)*a2;
    while (*((_DWORD *)v4 + 8) == *((_DWORD *)v6 + 8)
         && sub_100C8A278((unsigned __int8 *)v4 + 40, (unsigned __int8 *)v6 + 40))
    {
      uint64_t v7 = (void *)v4[1];
      uint64_t v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v9 = *v4 == (void)v8;
          uint64_t v8 = v4;
        }
        while (!v9);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v4 == v5) {
        return;
      }
    }
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v14 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v48 = v14;
    __int16 v49 = 2080;
    uint64_t v50 = "";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%supdating alt-servers:", buf, 0x2Au);
  }
  uint64_t v44 = a2;
  CFTypeRef v17 = (void *)*a2;
  uint64_t v15 = a2 + 1;
  CFTypeRef v16 = v17;
  if (v17 != v15)
  {
    do
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v20 = *(void *)(a1 + 160);
        unsigned int v21 = sub_100059954(*((_DWORD *)v16 + 8));
        sub_100C8A32C((uint64_t)(v16 + 5), __p);
        uint64_t v22 = __p;
        if (v46 < 0) {
          uint64_t v22 = (void **)__p[0];
        }
        *(_DWORD *)int buf = 136316418;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v48 = v20;
        __int16 v49 = 2080;
        uint64_t v50 = "";
        __int16 v51 = 2080;
        uint64_t v52 = v21;
        __int16 v53 = 2080;
        uint64_t v54 = v22;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s\t%s: %s", buf, 0x3Eu);
        if (v46 < 0) {
          operator delete(__p[0]);
        }
      }
      long long v23 = (void *)v16[1];
      if (v23)
      {
        do
        {
          CFTypeRef v24 = v23;
          long long v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          CFTypeRef v24 = (void *)v16[2];
          BOOL v9 = *v24 == (void)v16;
          CFTypeRef v16 = v24;
        }
        while (!v9);
      }
      CFTypeRef v16 = v24;
    }
    while (v24 != v15);
  }
  uint64_t v25 = (uint64_t **)(a1 + 656);
  if ((void *)(a1 + 656) != v44)
  {
    uint64_t v26 = (void *)*v44;
    if (*(void *)(a1 + 672))
    {
      uint64_t v27 = *(void *)(a1 + 656);
      uint64_t v28 = (uint64_t **)(a1 + 664);
      *(void *)(a1 + 656) = a1 + 664;
      *(void *)(*(void *)(a1 + 664) + 16) = 0;
      *(void *)(a1 + 664) = 0;
      *(void *)(a1 + 672) = 0;
      if (*(void *)(v27 + 8)) {
        uint64_t v29 = *(void *)(v27 + 8);
      }
      else {
        uint64_t v29 = v27;
      }
      *(void *)int buf = a1 + 656;
      *(void *)&uint8_t buf[8] = v29;
      *(void *)&uint8_t buf[16] = v29;
      if (v29)
      {
        *(void *)&uint8_t buf[8] = sub_1000EA590(v29);
        if (v26 == v15)
        {
          uint64_t v34 = v15;
        }
        else
        {
          do
          {
            *(_DWORD *)(v29 + 32) = *((_DWORD *)v26 + 8);
            std::string::operator=((std::string *)(v29 + 40), (const std::string *)(v26 + 5));
            *(unsigned char *)(v29 + 64) = *((unsigned char *)v26 + 64);
            uint64_t v30 = *v28;
            uint64_t v31 = (uint64_t **)(a1 + 664);
            uint64_t v32 = (uint64_t **)(a1 + 664);
            if (*v28)
            {
              do
              {
                while (1)
                {
                  uint64_t v31 = (uint64_t **)v30;
                  if (*(_DWORD *)(*(void *)&buf[16] + 32) >= *((_DWORD *)v30 + 8)) {
                    break;
                  }
                  uint64_t v30 = (uint64_t *)*v30;
                  uint64_t v32 = v31;
                  if (!*v31) {
                    goto LABEL_45;
                  }
                }
                uint64_t v30 = (uint64_t *)v30[1];
              }
              while (v30);
              uint64_t v32 = v31 + 1;
            }
LABEL_45:
            sub_100046C38((uint64_t **)(a1 + 656), (uint64_t)v31, v32, *(uint64_t **)&buf[16]);
            uint64_t v29 = *(void *)&buf[8];
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            if (*(void *)&buf[8]) {
              *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
            }
            uint64_t v33 = (void *)v26[1];
            if (v33)
            {
              do
              {
                uint64_t v34 = v33;
                uint64_t v33 = (void *)*v33;
              }
              while (v33);
            }
            else
            {
              do
              {
                uint64_t v34 = (void *)v26[2];
                BOOL v9 = *v34 == (void)v26;
                uint64_t v26 = v34;
              }
              while (!v9);
            }
            if (!v29) {
              break;
            }
            uint64_t v26 = v34;
          }
          while (v34 != v15);
        }
      }
      else
      {
        uint64_t v34 = v26;
      }
      sub_100429C9C((uint64_t)buf);
      uint64_t v26 = v34;
    }
    if (v26 != v15)
    {
      uint64_t v35 = (uint64_t **)(a1 + 664);
      do
      {
        uint64_t v36 = (char *)operator new(0x48uLL);
        *((_DWORD *)v36 + 8) = *((_DWORD *)v26 + 8);
        uint64_t v37 = v36 + 40;
        if (*((char *)v26 + 63) < 0)
        {
          sub_10004FC84(v37, (void *)v26[5], v26[6]);
        }
        else
        {
          long long v38 = *(_OWORD *)(v26 + 5);
          *((void *)v36 + 7) = v26[7];
          *(_OWORD *)uint64_t v37 = v38;
        }
        v36[64] = *((unsigned char *)v26 + 64);
        long long v39 = *v35;
        uint64_t v40 = v35;
        uint64_t v41 = v35;
        if (*v35)
        {
          do
          {
            while (1)
            {
              uint64_t v40 = (uint64_t **)v39;
              if (*((_DWORD *)v36 + 8) >= *((_DWORD *)v39 + 8)) {
                break;
              }
              long long v39 = (uint64_t *)*v39;
              uint64_t v41 = v40;
              if (!*v40) {
                goto LABEL_69;
              }
            }
            long long v39 = (uint64_t *)v39[1];
          }
          while (v39);
          uint64_t v41 = v40 + 1;
        }
LABEL_69:
        sub_100046C38(v25, (uint64_t)v40, v41, (uint64_t *)v36);
        uint64_t v42 = (void *)v26[1];
        if (v42)
        {
          do
          {
            uint64_t v43 = v42;
            uint64_t v42 = (void *)*v42;
          }
          while (v42);
        }
        else
        {
          do
          {
            uint64_t v43 = (void *)v26[2];
            BOOL v9 = *v43 == (void)v26;
            uint64_t v26 = v43;
          }
          while (!v9);
        }
        uint64_t v26 = v43;
      }
      while (v43 != v15);
    }
  }
}

void sub_100FA0360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  operator delete(v17);
  _Unwind_Resume(a1);
}

BOOL sub_100FA038C(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 784);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = a1 + 784;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a3;
    if (v5 >= a3) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 784) {
    return 0;
  }
  if (*(_DWORD *)(v4 + 32) > a3) {
    return 0;
  }
  uint64_t v10 = *(void *)(v4 + 48);
  uint64_t v8 = v4 + 48;
  uint64_t v9 = v10;
  if (!v10) {
    return 0;
  }
  uint64_t v11 = v8;
  do
  {
    int v12 = *(_DWORD *)(v9 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      uint64_t v14 = (uint64_t *)v9;
    }
    else {
      uint64_t v14 = (uint64_t *)(v9 + 8);
    }
    if (!v13) {
      uint64_t v11 = v9;
    }
    uint64_t v9 = *v14;
  }
  while (*v14);
  return v11 != v8 && *(_DWORD *)(v11 + 32) <= a2 && *(_DWORD *)(v11 + 44) == 2;
}

uint64_t sub_100FA0420(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v8 = *(void *)(a1 + 160);
    sub_100FBA118(*a2, __p);
    uint64_t v9 = v41 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136316418;
    uint64_t v43 = v7;
    __int16 v44 = 2080;
    xpc_object_t v45 = " ";
    __int16 v46 = 2080;
    uint64_t v47 = v8;
    __int16 v48 = 2080;
    __int16 v49 = "";
    __int16 v50 = 2048;
    uint64_t v51 = a3;
    __int16 v52 = 2080;
    __int16 v53 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sQ:%zu, analysing: %s", buf, 0x3Eu);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v10 = *(void *)(*a2 + 120);
  if ((v10 & 0xFF00000000) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 664);
    if (v11)
    {
      uint64_t v12 = a1 + 664;
      do
      {
        int v13 = *(_DWORD *)(v11 + 32);
        BOOL v14 = v13 < (int)v10;
        if (v13 >= (int)v10) {
          uint64_t v15 = (uint64_t *)v11;
        }
        else {
          uint64_t v15 = (uint64_t *)(v11 + 8);
        }
        if (!v14) {
          uint64_t v12 = v11;
        }
        uint64_t v11 = *v15;
      }
      while (*v15);
      if (v12 != a1 + 664 && *(_DWORD *)(v12 + 32) <= (int)v10)
      {
        if (*(char *)(v12 + 63) < 0)
        {
          if (*(void *)(v12 + 48))
          {
LABEL_26:
            if (*(unsigned char *)(v12 + 64)) {
              goto LABEL_27;
            }
            goto LABEL_18;
          }
        }
        else if (*(unsigned char *)(v12 + 63))
        {
          goto LABEL_26;
        }
        uint64_t v36 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          return 1;
        }
        uint64_t v37 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v38 = *(void *)(a1 + 160);
        long long v39 = sub_100059954(v10);
        *(_DWORD *)int buf = 136316418;
        uint64_t v43 = v37;
        __int16 v44 = 2080;
        xpc_object_t v45 = " ";
        __int16 v46 = 2080;
        uint64_t v47 = v38;
        __int16 v48 = 2080;
        __int16 v49 = "";
        __int16 v50 = 2048;
        uint64_t v51 = a3;
        __int16 v52 = 2080;
        __int16 v53 = (void *)v39;
        uint64_t v30 = "#I %s%s%s%sQ:%zu, alt server url for %s is not received/processed yet, waiting - bail-out";
        uint64_t v31 = v36;
        uint32_t v32 = 62;
        goto LABEL_36;
      }
    }
  }
LABEL_18:
  if (sub_100FA09C4(a1))
  {
    CFTypeRef v16 = *(NSObject **)(a1 + 40);
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v17) {
      return result;
    }
    uint64_t v19 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v20 = *(void *)(a1 + 160);
    if (*(unsigned char *)(a1 + 705)) {
      unsigned int v21 = "companion device";
    }
    else {
      unsigned int v21 = "Internet";
    }
    *(_DWORD *)int buf = 136316418;
    uint64_t v43 = v19;
    __int16 v44 = 2080;
    xpc_object_t v45 = " ";
    __int16 v46 = 2080;
    uint64_t v47 = v20;
    __int16 v48 = 2080;
    __int16 v49 = "";
    __int16 v50 = 2048;
    uint64_t v51 = a3;
    __int16 v52 = 2080;
    __int16 v53 = (void *)v21;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sQ:%zu, Entitlements can go over %s - go ahead", buf, 0x3Eu);
    return 0;
  }
LABEL_27:
  if (*(unsigned char *)(*(void *)(a1 + 144) + 96))
  {
    uint64_t v22 = *(NSObject **)(a1 + 40);
    if (*(unsigned char *)(a1 + 769))
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v24 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136316162;
        uint64_t v43 = v23;
        __int16 v44 = 2080;
        xpc_object_t v45 = " ";
        __int16 v46 = 2080;
        uint64_t v47 = v24;
        __int16 v48 = 2080;
        __int16 v49 = "";
        __int16 v50 = 2048;
        uint64_t v51 = a3;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sQ:%zu, Entitlements can go over dedicated APN - go ahead", buf, 0x34u);
      }
      uint64_t v25 = **(PersonalityInfo ****)(a1 + 128);
      uint64_t v26 = *v25;
      uint64_t v27 = (Registry *)*((unsigned int *)*v25 + 13);
      if (sub_100FA038C(a1, 15, *((_DWORD *)*v25 + 13))) {
        return 0;
      }
      uint64_t v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = PersonalityInfo::logPrefix(v26);
        uint64_t v35 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136316162;
        uint64_t v43 = v34;
        __int16 v44 = 2080;
        xpc_object_t v45 = " ";
        __int16 v46 = 2080;
        uint64_t v47 = v35;
        __int16 v48 = 2080;
        __int16 v49 = "";
        __int16 v50 = 2048;
        uint64_t v51 = a3;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sQ:%zu, Need to activate entitlement service type.", buf, 0x34u);
        uint64_t v27 = (Registry *)*(unsigned int *)(***(void ***)(a1 + 128) + 52);
      }
      sub_1009C783C(v27);
      return 1;
    }
  }
  else
  {
    uint64_t v22 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v29 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136316162;
    uint64_t v43 = v28;
    __int16 v44 = 2080;
    xpc_object_t v45 = " ";
    __int16 v46 = 2080;
    uint64_t v47 = v29;
    __int16 v48 = 2080;
    __int16 v49 = "";
    __int16 v50 = 2048;
    uint64_t v51 = a3;
    uint64_t v30 = "#I %s%s%s%sQ:%zu, No transport to reach Entitlement server - bail-out";
    uint64_t v31 = v22;
    uint32_t v32 = 52;
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
  }
  return 1;
}

void sub_100FA096C(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v3 = *v2;
  *(void *)(v3 + 8) = v2[1];
  *(void *)v2[1] = v3;
  *(void *)(a1 + 16) = v1 - 1;
  uint64_t v4 = (std::__shared_weak_count *)v2[3];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete(v2);
}

BOOL sub_100FA09C4(uint64_t a1)
{
  if ((*(unsigned char *)(*(void *)(a1 + 144) + 96) & 2) == 0) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 704) || *(unsigned char *)(a1 + 705)) {
    return 1;
  }
  subscriber::makeSimSlotRange();
  uint64_t v3 = v14;
  if (v14 != v15)
  {
    do
    {
      if (v16(*v3)) {
        goto LABEL_10;
      }
      ++v3;
    }
    while (v3 != v15);
    uint64_t v3 = v15;
LABEL_10:
    while (v3 != v15)
    {
      if (sub_100FA038C(a1, 0, *v3)) {
        return 1;
      }
      uint64_t v4 = v3 + 1;
      uint64_t v3 = v15;
      if (v4 != v15)
      {
        uint64_t v3 = v4;
        while ((v16(*v3) & 1) == 0)
        {
          if (++v3 == v15)
          {
            uint64_t v3 = v15;
            goto LABEL_10;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)(*(void *)(a1 + 144) + 96) & 1) != 0 && *(unsigned char *)(a1 + 769)) {
    return 0;
  }
  subscriber::makeSimSlotRange();
  int v5 = (unsigned int *)v14;
  if (v14 != v15)
  {
    while ((v16(*v5) & 1) == 0)
    {
      if (++v5 == (unsigned int *)v15)
      {
        int v5 = (unsigned int *)v15;
        break;
      }
    }
    if (v5 != (unsigned int *)v15)
    {
      BOOL v6 = (uint64_t *)(a1 + 832);
      while (1)
      {
        uint64_t v7 = *v6;
        if (*v6)
        {
          signed int v8 = *v5;
          uint64_t v9 = a1 + 832;
          do
          {
            signed int v10 = *(_DWORD *)(v7 + 28);
            BOOL v11 = v10 < v8;
            if (v10 >= v8) {
              uint64_t v12 = (uint64_t *)v7;
            }
            else {
              uint64_t v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if ((uint64_t *)v9 != v6
            && v8 >= *(_DWORD *)(v9 + 28)
            && (ConnectionAvailabilityContainer::available() & 1) != 0)
          {
            return 1;
          }
        }
        int v13 = v5 + 1;
        int v5 = (unsigned int *)v15;
        if (v13 != (unsigned int *)v15)
        {
          int v5 = v13;
          while ((v16(*v5) & 1) == 0)
          {
            if (++v5 == (unsigned int *)v15)
            {
              int v5 = (unsigned int *)v15;
              break;
            }
          }
        }
        if (v5 == (unsigned int *)v15) {
          return *(unsigned char *)(a1 + 768) != 0;
        }
      }
    }
  }
  return *(unsigned char *)(a1 + 768) != 0;
}

void sub_100FA0BA4(uint64_t a1, char a2)
{
  uint64_t v110 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v110);
  if (*(void *)(a1 + 576))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v6;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v7 = "#I %s%s%s%sThere is already a requested query";
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)(a1 + 128);
  signed int v10 = **(PersonalityInfo ***)v9;
  if (!*((unsigned char *)v10 + 48))
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    uint64_t v14 = PersonalityInfo::logPrefix(v10);
    uint64_t v15 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v15;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v7 = "#I %s%s%s%sPersonality is inactive";
    goto LABEL_14;
  }
  if (!*((unsigned char *)v10 + 49) && !*((unsigned char *)v10 + 60))
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    uint64_t v28 = PersonalityInfo::logPrefix(v10);
    uint64_t v29 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v28;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v29;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v25 = "#I %s%s%s%sSIM is not EAP-AKA capable";
    goto LABEL_28;
  }
  if (*(unsigned char *)(a1 + 168))
  {
    if (*(unsigned char *)(a1 + 344))
    {
      BOOL v11 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      uint64_t v12 = PersonalityInfo::logPrefix(v10);
      uint64_t v13 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v118 = 2080;
      uint64_t v119 = v13;
      __int16 v120 = 2080;
      xpc_object_t v121 = "";
      uint64_t v7 = "#I %s%s%s%swaiting for auth token";
      goto LABEL_14;
    }
    if (*(unsigned char *)(a1 + 345))
    {
      BOOL v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = PersonalityInfo::logPrefix(v10);
        uint64_t v27 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v26;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v27;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        uint64_t v7 = "#I %s%s%s%swaiting for service token";
LABEL_14:
        signed int v8 = v11;
        goto LABEL_15;
      }
      goto LABEL_16;
    }
    if (*(char *)(v9 + 407) < 0) {
      uint64_t v36 = *(void *)(v9 + 392);
    }
    else {
      uint64_t v36 = *(unsigned __int8 *)(v9 + 407);
    }
    if (!v36)
    {
      sub_100CEB718(*(void *)(a1 + 144), (uint64_t)buf);
      BOOL v37 = sub_1002E6B08((const void **)buf, "1");
      if (SHIBYTE(v118) < 0) {
        operator delete(*(void **)buf);
      }
      if (!v37)
      {
        uint64_t v4 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_16;
        }
        uint64_t v43 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v44 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v43;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v44;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        uint64_t v7 = "#I %s%s%s%swaiting for unique id";
        goto LABEL_4;
      }
    }
    if (*(void *)(a1 + 536))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      uint64_t v38 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v39 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v38;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v118 = 2080;
      uint64_t v119 = v39;
      __int16 v120 = 2080;
      xpc_object_t v121 = "";
      uint64_t v7 = "#I %s%s%s%sExisting Request in place, delaying subsequent transactions";
      goto LABEL_4;
    }
    if (*(int *)(a1 + 348) >= 5)
    {
      uint64_t v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v42 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v41;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v42;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        uint64_t v25 = "#W %s%s%s%sToo many entitlement failures";
LABEL_53:
        uint64_t v30 = v40;
        goto LABEL_29;
      }
      goto LABEL_30;
    }
    if (*(unsigned char *)(a1 + 356))
    {
      uint64_t v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v45 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v46 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v45;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v46;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        uint64_t v25 = "#W %s%s%s%sSubscriber blocked";
        goto LABEL_53;
      }
LABEL_30:
      uint64_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v33 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v32;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v33;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sRequest cannot be executed - report failure for all requests", buf, 0x2Au);
      }
      buf[0] = 0;
      uint8_t buf[4] = 0;
      sub_100F91C6C(a1, 1, (uint64_t)buf);
    }
    if (*(void *)(a1 + 376))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      uint64_t v47 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v48 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v47;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v118 = 2080;
      uint64_t v119 = v48;
      __int16 v120 = 2080;
      xpc_object_t v121 = "";
      uint64_t v7 = "#I %s%s%s%sCommunication is temporary blocked because of server issues";
LABEL_4:
      signed int v8 = v4;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, 0x2Au);
      goto LABEL_16;
    }
    if (!*(void *)(a1 + 608)) {
      goto LABEL_16;
    }
    uint64_t v49 = 0;
    while (sub_100FA0420(a1, (uint64_t *)(*(void *)(a1 + 600) + 16), v49))
    {
      sub_100116B10((uint64_t *)(a1 + 592), *(void *)(*(void *)(a1 + 600) + 16), *(void *)(*(void *)(a1 + 600) + 24));
      sub_100FA096C(a1 + 592);
      if ((unint64_t)++v49 >= *(void *)(a1 + 608)) {
        goto LABEL_16;
      }
    }
    uint64_t v50 = *(void *)(a1 + 360);
    if (v50)
    {
      int v51 = *(unsigned __int8 *)(a1 + 728);
      __int16 v52 = *(NSObject **)(a1 + 40);
      BOOL v53 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
      if (!v51)
      {
        if (!v53) {
          goto LABEL_19;
        }
        uint64_t v56 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v57 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v56;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v57;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        uint64_t v19 = "#I %s%s%s%sautomatic retry timer in place";
        uint64_t v20 = v52;
        goto LABEL_18;
      }
      if (v53)
      {
        uint64_t v54 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v55 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v54;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v118 = 2080;
        uint64_t v119 = v55;
        __int16 v120 = 2080;
        xpc_object_t v121 = "";
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sForced to make a request - removing 'forced' flag, canceling automatic retry timeout", buf, 0x2Au);
        uint64_t v50 = *(void *)(a1 + 360);
        *(void *)(a1 + 360) = 0;
        if (!v50) {
          goto LABEL_71;
        }
      }
      else
      {
        *(void *)(a1 + 360) = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
    }
LABEL_71:
    *(unsigned char *)(a1 + 728) = 0;
    uint64_t v58 = *(void *)(*(void *)(a1 + 600) + 16);
    if (!v58) {
      __assert_rtn("initiateRequestQuery_sync", "CarrierEntitlementsHTTPCommandDriver.mm", 2873, "fPendingQueryQueue.front()");
    }
    if ((a2 & 1) == 0)
    {
      uint64_t v59 = *(unsigned int *)(v58 + 48);
      if (!*(unsigned char *)(a1 + 644) || *(_DWORD *)(a1 + 640) != v59)
      {
        *(_DWORD *)(a1 + 640) = v59;
        *(unsigned char *)(a1 + 644) = 1;
        v84 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v85 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v86 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v85;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          __int16 v118 = 2080;
          uint64_t v119 = v86;
          __int16 v120 = 2080;
          xpc_object_t v121 = "";
          __int16 v122 = 2048;
          uint64_t v123 = v59;
          _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sscheduling the request of generation:%lu", buf, 0x34u);
        }
        uint64_t v87 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v87 || (uint64_t v88 = *(void *)(a1 + 8), (v89 = std::__shared_weak_count::lock(v87)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v90 = v89;
        atomic_fetch_add_explicit(&v89->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v89);
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 48));
        uint64_t v91 = *(void *)buf;
        sub_100058DB0(__p, "hold outgoing");
        uint64_t v92 = *(NSObject **)(a1 + 24);
        dispatch_object_t object = v92;
        if (v92) {
          dispatch_retain(v92);
        }
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 3321888768;
        aBlock[2] = sub_100FA21AC;
        aBlock[3] = &unk_101A776E8;
        aBlock[4] = a1;
        aBlock[5] = v88;
        uint64_t v105 = v90;
        atomic_fetch_add_explicit(&v90->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v106 = _Block_copy(aBlock);
        sub_100118A44(v91, (uint64_t)__p, 1, 100000, &object, &v106);
        v93 = v114;
        xpc_object_t v114 = 0;
        uint64_t v94 = *(void *)(a1 + 632);
        *(void *)(a1 + 632) = v93;
        if (v94)
        {
          (*(void (**)(uint64_t))(*(void *)v94 + 8))(v94);
          uint64_t v95 = v114;
          xpc_object_t v114 = 0;
          if (v95) {
            (*(void (**)(void *))(*(void *)v95 + 8))(v95);
          }
        }
        if (v106) {
          _Block_release(v106);
        }
        if (object) {
          dispatch_release(object);
        }
        if (v109 < 0) {
          operator delete(__p[0]);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v105) {
          std::__shared_weak_count::__release_weak(v105);
        }
        std::__shared_weak_count::__release_weak(v90);
        goto LABEL_19;
      }
    }
    if (*(void *)(a1 + 632)) {
      goto LABEL_19;
    }
    long long v60 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v62 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v61;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v118 = 2080;
      uint64_t v119 = v62;
      __int16 v120 = 2080;
      xpc_object_t v121 = "";
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%ssending out the request", buf, 0x2Au);
    }
    if (*(unsigned char *)(a1 + 644)) {
      *(unsigned char *)(a1 + 644) = 0;
    }
    uint64_t v63 = *(void *)(a1 + 600);
    uint64_t v65 = *(void *)(v63 + 16);
    uint64_t v64 = *(void *)(v63 + 24);
    if (v64) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v64 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(a1 + 576) = v65;
    CFTypeRef v66 = *(std::__shared_weak_count **)(a1 + 584);
    *(void *)(a1 + 584) = v64;
    if (v66) {
      sub_10004D2C8(v66);
    }
    uint64_t v67 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v68 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v69 = *(void *)(a1 + 160);
      uint64_t v70 = *(void *)(a1 + 608);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v68;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v118 = 2080;
      uint64_t v119 = v69;
      __int16 v120 = 2080;
      xpc_object_t v121 = "";
      __int16 v122 = 2048;
      uint64_t v123 = v70;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTaking first pending query out of %zu, and Sending out!", buf, 0x34u);
    }
    sub_100FA096C(a1 + 592);
    if (!*(void *)(a1 + 608)) {
      sub_100F917E8();
    }
    uint64_t v71 = *(void *)(a1 + 576);
    xpc_object_t v114 = 0;
    uint64_t v115 = 0;
    uint64_t v116 = 0;
    sub_100CEB718(*(void *)(a1 + 144), (uint64_t)&v114);
    memset(&v113, 0, sizeof(v113));
    memset(&v112, 0, sizeof(v112));
    memset(&v111, 0, sizeof(v111));
    uint64_t v72 = HIBYTE(v116);
    if (v116 < 0) {
      uint64_t v72 = v115;
    }
    if (v72 != 1) {
      goto LABEL_94;
    }
    CFTypeRef v73 = &v114;
    if (v116 < 0) {
      CFTypeRef v73 = (void **)v114;
    }
    if (*(unsigned char *)v73 != 49)
    {
LABEL_94:
      std::string::operator=(&v113, (const std::string *)(*(void *)(a1 + 128) + 384));
      std::string::operator=(&v112, (const std::string *)(*(void *)(a1 + 128) + 408));
      uint64_t v74 = *(void *)(a1 + 128);
      uint64_t v75 = *(unsigned __int8 *)(v74 + 383);
      size_t v76 = *(void *)(v74 + 368);
      if ((v75 & 0x80u) == 0) {
        uint64_t v77 = *(unsigned __int8 *)(v74 + 383);
      }
      else {
        uint64_t v77 = *(void *)(v74 + 368);
      }
      uint64_t v78 = *(unsigned __int8 *)(v74 + 407);
      int v79 = (char)v78;
      if ((v78 & 0x80u) != 0) {
        uint64_t v78 = *(void *)(v74 + 392);
      }
      if (v77 == v78)
      {
        uint64_t v80 = (const void **)(v74 + 360);
        __int16 v81 = (unsigned __int8 *)(v74 + 384);
        uint64_t v82 = *(unsigned __int8 **)(v74 + 384);
        if (v79 >= 0) {
          __int16 v83 = v81;
        }
        else {
          __int16 v83 = v82;
        }
        if ((v75 & 0x80) != 0)
        {
          if (!memcmp(*v80, v83, v76)) {
            goto LABEL_131;
          }
        }
        else
        {
          if (!v75) {
            goto LABEL_131;
          }
          while (*(unsigned __int8 *)v80 == *v83)
          {
            uint64_t v80 = (const void **)((char *)v80 + 1);
            ++v83;
            if (!--v75) {
              goto LABEL_131;
            }
          }
        }
      }
      if (sub_100CEA44C(*(void *)(a1 + 144))) {
        std::string::operator=(&v111, (const std::string *)(*(void *)(a1 + 128) + 360));
      }
    }
LABEL_131:
    unsigned int v96 = *(_DWORD *)(a1 + 172);
    if (v96 - 3 >= 3)
    {
      if (v96 - 1 < 2)
      {
        int v97 = *(_DWORD *)(a1 + 176);
        switch(v97)
        {
          case 2:
            goto LABEL_136;
          case 1:
            int v98 = sub_100FC02D0(v71, (uint64_t *)(a1 + 432), (uint64_t *)(a1 + 456));
            if (*(char *)(a1 + 455) < 0)
            {
              **(unsigned char **)(a1 + 432) = 0;
              *(void *)(a1 + 440) = 0;
            }
            else
            {
              *(unsigned char *)(a1 + 432) = 0;
              *(unsigned char *)(a1 + 455) = 0;
            }
            if (*(char *)(a1 + 479) < 0)
            {
              **(unsigned char **)(a1 + 456) = 0;
              *(void *)(a1 + 464) = 0;
            }
            else
            {
              *(unsigned char *)(a1 + 456) = 0;
              *(unsigned char *)(a1 + 479) = 0;
            }
            sub_100FC0248(v71);
            goto LABEL_153;
          case 0:
LABEL_136:
            buf[0] = 0;
            LOBYTE(v119) = 0;
            int v98 = sub_100FBF160(v71, v96, a1 + 208, (uint64_t)&v113, (uint64_t)&v112, (uint64_t)&v111, a1 + 232, (uint64_t)buf);
            if ((_BYTE)v119 && SHIBYTE(v118) < 0) {
              operator delete(*(void **)buf);
            }
            sub_100FC0594(v71);
            goto LABEL_153;
        }
        goto LABEL_143;
      }
      if (v96)
      {
LABEL_143:
        int v98 = 1;
LABEL_153:
        if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v111.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v112.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v113.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v116) < 0) {
          operator delete(v114);
        }
        if (!v98)
        {
          uint64_t v100 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v101 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v102 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v101;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int16 v118 = 2080;
            uint64_t v119 = v102;
            __int16 v120 = 2080;
            xpc_object_t v121 = "";
            _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sfailed to add Authentication - cannot issue request, failing attempt immediately", buf, 0x2Au);
          }
          buf[0] = 0;
          uint8_t buf[4] = 0;
          sub_100F9E344(a1, 0, (uint64_t)buf);
          uint64_t v103 = *(std::__shared_weak_count **)(a1 + 16);
          if (v103 && std::__shared_weak_count::lock(v103)) {
            operator new();
          }
          sub_100088B9C();
        }
        sub_100FA2B0C(a1);
        goto LABEL_19;
      }
      if (*(unsigned char *)(***(void ***)(a1 + 128) + 49) == 2)
      {
        unsigned int v96 = 4;
      }
      else
      {
        if (*(char *)(a1 + 279) < 0) {
          uint64_t v99 = *(void *)(a1 + 264);
        }
        else {
          uint64_t v99 = *(unsigned __int8 *)(a1 + 279);
        }
        if (!v99)
        {
          unsigned int v96 = 0;
          goto LABEL_152;
        }
        unsigned int v96 = 3;
      }
      *(_DWORD *)(a1 + 172) = v96;
    }
LABEL_152:
    int v98 = sub_100FBF160(v71, v96, *(void *)(a1 + 128) + 336, (uint64_t)&v113, (uint64_t)&v112, (uint64_t)&v111, a1 + 256, a1 + 280);
    sub_100FC0594(v71);
    goto LABEL_153;
  }
  int v21 = *(unsigned __int8 *)(v9 + 88);
  BOOL v11 = *(NSObject **)(a1 + 40);
  BOOL v22 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    if (!v22) {
      goto LABEL_30;
    }
    uint64_t v23 = PersonalityInfo::logPrefix(v10);
    uint64_t v24 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v24;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v25 = "#I %s%s%s%sobtained IMSI is not allowed for entitlement communication";
LABEL_28:
    uint64_t v30 = v11;
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v25, buf, 0x2Au);
    goto LABEL_30;
  }
  if (v22)
  {
    uint64_t v34 = PersonalityInfo::logPrefix(v10);
    uint64_t v35 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v34;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v35;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v7 = "#I %s%s%s%swaiting for authentication settings";
    goto LABEL_14;
  }
LABEL_16:
  CFTypeRef v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v18 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v118 = 2080;
    uint64_t v119 = v18;
    __int16 v120 = 2080;
    xpc_object_t v121 = "";
    uint64_t v19 = "#I %s%s%s%sUnable to perform request";
    uint64_t v20 = v16;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, 0x2Au);
  }
LABEL_19:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v110);
}

void sub_100FA1D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (*(unsigned char *)(v45 - 104) && *(char *)(v45 - 105) < 0) {
    operator delete(*(void **)(v45 - 128));
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (*(char *)(v45 - 129) < 0) {
    operator delete(*(void **)(v45 - 152));
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a25);
  _Unwind_Resume(a1);
}

void sub_100FA1EAC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 128));
          uint64_t v8 = *(void *)(v3 + 160);
          int v9 = 136315906;
          uint64_t v10 = v7;
          __int16 v11 = 2080;
          uint64_t v12 = " ";
          __int16 v13 = 2080;
          uint64_t v14 = v8;
          __int16 v15 = 2080;
          CFTypeRef v16 = "";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scancelation re-check timer expired", (uint8_t *)&v9, 0x2Au);
        }
        sub_100F9F270(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100FA1FC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100FA1FD8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v6 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v5 + 128));
          uint64_t v8 = *(void *)(v5 + 160);
          int v10 = 136315906;
          uint64_t v11 = v7;
          __int16 v12 = 2080;
          __int16 v13 = " ";
          __int16 v14 = 2080;
          uint64_t v15 = v8;
          __int16 v16 = 2080;
          uint64_t v17 = "";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________   retry backoff timer expired", (uint8_t *)&v10, 0x2Au);
        }
        uint64_t v9 = *(void *)(v5 + 360);
        *(void *)(v5 + 360) = 0;
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        }
        sub_100F937E8(v5);
        sub_10004D2C8(v4);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100FA2164(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FA2180(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FA219C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FA21AC(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v2 + 128));
    uint64_t v5 = *(void *)(v2 + 160);
    int v11 = 136315906;
    uint64_t v12 = v4;
    __int16 v13 = 2080;
    __int16 v14 = " ";
    __int16 v15 = 2080;
    uint64_t v16 = v5;
    __int16 v17 = 2080;
    uint64_t v18 = "";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sfHoldOutgoingTimer fired", (uint8_t *)&v11, 0x2Au);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = a1[5];
      if (v9)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v10 = *(void *)(v9 + 632);
        *(void *)(v9 + 632) = 0;
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        }
        sub_10004D2C8(v8);
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100FA0BA4(v9, 0);
        sub_10004D2C8(v8);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100FA2318(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100FA2334(uint64_t a1, unsigned int a2)
{
  sub_100CEF618(a1, a2);
  switch(a2)
  {
    case 0u:
      uint64_t v19 = *(uint64_t **)(a1 + 680);
      if (v19 == (uint64_t *)(a1 + 688)) {
        return;
      }
      while (1)
      {
        int v20 = *((_DWORD *)v19 + 8);
        if ((v20 - 6001) > 9) {
          break;
        }
        int v21 = 1 << (v20 - 113);
        if ((v21 & 0x209) != 0)
        {
          BOOL v22 = (uint64_t *)v19[1];
          if (v22)
          {
            do
            {
              uint64_t v23 = v22;
              BOOL v22 = (uint64_t *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              uint64_t v23 = (uint64_t *)v19[2];
              BOOL v14 = *v23 == (void)v19;
              uint64_t v19 = v23;
            }
            while (!v14);
          }
        }
        else
        {
          if ((v21 & 6) == 0) {
            break;
          }
          uint64_t v24 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v25 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v26 = *(void *)(a1 + 160);
            uint64_t v27 = sub_100C895E0(*((_DWORD *)v19 + 7));
            uint64_t v28 = sub_100FB56F4(*((_DWORD *)v19 + 8));
            *(_DWORD *)int buf = 136316674;
            uint64_t v34 = v25;
            __int16 v35 = 2080;
            uint64_t v36 = " ";
            __int16 v37 = 2080;
            uint64_t v38 = v26;
            __int16 v39 = 2080;
            uint64_t v40 = "";
            __int16 v41 = 2080;
            uint64_t v42 = v27;
            __int16 v43 = 2080;
            uint64_t v44 = v28;
            __int16 v45 = 2080;
            uint64_t v46 = "CheckEntitlementsReason::kUserInitiated";
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sremoved vital block for action %s [%s] because of %s", buf, 0x48u);
          }
          uint64_t v23 = sub_10006C514((uint64_t **)(a1 + 680), v19);
          operator delete(v19);
        }
LABEL_47:
        uint64_t v19 = v23;
        if (v23 == (uint64_t *)(a1 + 688)) {
          return;
        }
      }
      uint64_t v29 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
        uint64_t v31 = sub_100FB56F4(v20);
        uint64_t v32 = sub_100C895E0(*((_DWORD *)v19 + 7));
        *(_DWORD *)int buf = 136315394;
        uint64_t v34 = (uint64_t)v31;
        __int16 v35 = 2080;
        uint64_t v36 = v32;
        _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "invalid vital code %s for action %s", buf, 0x16u);
      }
      uint64_t v30 = (uint64_t *)v19[1];
      if (v30)
      {
        do
        {
          uint64_t v23 = v30;
          uint64_t v30 = (uint64_t *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v23 = (uint64_t *)v19[2];
          BOOL v14 = *v23 == (void)v19;
          uint64_t v19 = v23;
        }
        while (!v14);
      }
      goto LABEL_47;
    case 1u:
    case 3u:
    case 7u:
      uint64_t v4 = *(uint64_t **)(a1 + 680);
      if (v4 == (uint64_t *)(a1 + 688)) {
        return;
      }
      break;
    default:
      return;
  }
  do
  {
    int v5 = *((_DWORD *)v4 + 8);
    if ((v5 - 6001) < 3) {
      goto LABEL_6;
    }
    if (v5 == 6004)
    {
      __int16 v13 = (uint64_t *)v4[1];
      if (v13)
      {
        do
        {
          uint64_t v12 = v13;
          __int16 v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v12 = (uint64_t *)v4[2];
          BOOL v14 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }
        while (!v14);
      }
      goto LABEL_11;
    }
    if (v5 == 6010)
    {
LABEL_6:
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v8 = *(void *)(a1 + 160);
        uint64_t v9 = sub_100C895E0(*((_DWORD *)v4 + 7));
        uint64_t v10 = sub_100FB56F4(*((_DWORD *)v4 + 8));
        int v11 = "Reason unknown??";
        if (a2 < 9) {
          int v11 = off_101A78F60[a2];
        }
        *(_DWORD *)int buf = 136316674;
        uint64_t v34 = v7;
        __int16 v35 = 2080;
        uint64_t v36 = " ";
        __int16 v37 = 2080;
        uint64_t v38 = v8;
        __int16 v39 = 2080;
        uint64_t v40 = "";
        __int16 v41 = 2080;
        uint64_t v42 = v9;
        __int16 v43 = 2080;
        uint64_t v44 = v10;
        __int16 v45 = 2080;
        uint64_t v46 = v11;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sremoved vital block for action %s [%s] because of %s", buf, 0x48u);
      }
      uint64_t v12 = sub_10006C514((uint64_t **)(a1 + 680), v4);
      operator delete(v4);
    }
    else
    {
      __int16 v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        __int16 v17 = sub_100FB56F4(v5);
        uint64_t v18 = sub_100C895E0(*((_DWORD *)v4 + 7));
        *(_DWORD *)int buf = 136315394;
        uint64_t v34 = (uint64_t)v17;
        __int16 v35 = 2080;
        uint64_t v36 = v18;
        _os_log_fault_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "invalid vital code %s for action %s", buf, 0x16u);
      }
      uint64_t v16 = (uint64_t *)v4[1];
      if (v16)
      {
        do
        {
          uint64_t v12 = v16;
          uint64_t v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v12 = (uint64_t *)v4[2];
          BOOL v14 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }
        while (!v14);
      }
    }
LABEL_11:
    uint64_t v4 = v12;
  }
  while (v12 != (uint64_t *)(a1 + 688));
}

uint64_t sub_100FA2844(uint64_t a1, int a2, int a3)
{
  if (!*(unsigned char *)(a1 + 356))
  {
    uint64_t v10 = *(void *)(a1 + 688);
    if (!v10) {
      return 0;
    }
    uint64_t v11 = a1 + 688;
    do
    {
      int v12 = *(_DWORD *)(v10 + 28);
      BOOL v13 = v12 < a2;
      if (v12 >= a2) {
        BOOL v14 = (uint64_t *)v10;
      }
      else {
        BOOL v14 = (uint64_t *)(v10 + 8);
      }
      if (!v13) {
        uint64_t v11 = v10;
      }
      uint64_t v10 = *v14;
    }
    while (*v14);
    if (v11 == a1 + 688 || *(_DWORD *)(v11 + 28) > a2) {
      return 0;
    }
    if (a3)
    {
      if (*(_DWORD *)(v11 + 32) >> 1 == 3001) {
        return 0;
      }
      __int16 v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v17 = *(void *)(a1 + 160);
        uint64_t v18 = sub_100C895E0(a2);
        uint64_t v19 = sub_100FB56F4(*(_DWORD *)(v11 + 32));
        int v25 = 136316418;
        uint64_t v26 = v16;
        __int16 v27 = 2080;
        uint64_t v28 = " ";
        __int16 v29 = 2080;
        uint64_t v30 = v17;
        __int16 v31 = 2080;
        uint64_t v32 = "";
        __int16 v33 = 2080;
        uint64_t v34 = v18;
        __int16 v35 = 2080;
        uint64_t v36 = v19;
        int v20 = "#I %s%s%s%sAction %s is not allowed since it had vital failure %s, and failure is unforgivable even being user-initiated";
LABEL_22:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v25, 0x3Eu);
      }
    }
    else
    {
      __int16 v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v22 = *(void *)(a1 + 160);
        uint64_t v23 = sub_100C895E0(a2);
        uint64_t v24 = sub_100FB56F4(*(_DWORD *)(v11 + 32));
        int v25 = 136316418;
        uint64_t v26 = v21;
        __int16 v27 = 2080;
        uint64_t v28 = " ";
        __int16 v29 = 2080;
        uint64_t v30 = v22;
        __int16 v31 = 2080;
        uint64_t v32 = "";
        __int16 v33 = 2080;
        uint64_t v34 = v23;
        __int16 v35 = 2080;
        uint64_t v36 = v24;
        int v20 = "#I %s%s%s%sAction %s is not allowed since it had vital failure %s and action is not user-initiated";
        goto LABEL_22;
      }
    }
    return 1;
  }
  int v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (!v6) {
    return result;
  }
  uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
  uint64_t v9 = *(void *)(a1 + 160);
  int v25 = 136316162;
  uint64_t v26 = v8;
  __int16 v27 = 2080;
  uint64_t v28 = " ";
  __int16 v29 = 2080;
  uint64_t v30 = v9;
  __int16 v31 = 2080;
  uint64_t v32 = "";
  __int16 v33 = 2080;
  uint64_t v34 = sub_100C895E0(a2);
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAction %s is not allowed since subscriber blocked", (uint8_t *)&v25, 0x34u);
  return 0;
}

void sub_100FA2B0C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v4;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s_____________>  Sending HTTP Request, trying", buf, 0x2Au);
  }
  uint64_t v5 = *(void *)(a1 + 576);
  if (v5)
  {
    memset(&__dst, 0, sizeof(__dst));
    if (*(char *)(a1 + 423) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 400), *(void *)(a1 + 408));
      uint64_t v5 = *(void *)(a1 + 576);
    }
    else
    {
      std::string __dst = *(std::string *)(a1 + 400);
    }
    uint64_t v9 = *(void *)(v5 + 120);
    if ((v9 & 0xFF00000000) == 0) {
      goto LABEL_20;
    }
    uint64_t v10 = *(void *)(a1 + 664);
    if (!v10) {
      goto LABEL_20;
    }
    uint64_t v11 = a1 + 664;
    do
    {
      int v12 = *(_DWORD *)(v10 + 32);
      BOOL v13 = v12 < (int)v9;
      if (v12 >= (int)v9) {
        BOOL v14 = (uint64_t *)v10;
      }
      else {
        BOOL v14 = (uint64_t *)(v10 + 8);
      }
      if (!v13) {
        uint64_t v11 = v10;
      }
      uint64_t v10 = *v14;
    }
    while (*v14);
    if (v11 != a1 + 664 && *(_DWORD *)(v11 + 32) <= (int)v9)
    {
      BOOL v51 = *(unsigned char *)(v11 + 64) != 0;
      std::string::operator=(&__dst, (const std::string *)(v11 + 40));
      BOOL v256 = v51;
    }
    else
    {
LABEL_20:
      BOOL v256 = 0;
    }
    __int16 v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v17 = *(void *)(a1 + 160);
      p_dst = &__dst;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v17;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = p_dst;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sSending to Server Address: %{public}s", buf, 0x34u);
    }
    memset(&v273, 0, sizeof(v273));
    if (*(_DWORD *)(a1 + 172) == 2)
    {
      sub_100FA6008(&v273, a1, (uint64_t)&__dst);
    }
    else if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v273, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else
    {
      std::string v273 = __dst;
    }
    v270 = 0;
    v271 = 0;
    v272 = 0;
    if (*(_DWORD *)(a1 + 172) == 2)
    {
      *(_OWORD *)&v284.__r_.__value_.__r.__words[1] = 0uLL;
      v284.__r_.__value_.__r.__words[0] = (std::string::size_type)&v284.__r_.__value_.__l.__size_;
      sub_100058DB0(__str, "\"");
      sub_100FA5F90(&__s1, *(void *)(a1 + 128));
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_s1 = &__s1;
      }
      else {
        p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
      }
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __s1.__r_.__value_.__l.__size_;
      }
      uint64_t v21 = std::string::append(__str, (const std::string::value_type *)p_s1, size);
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      *(void *)&uint8_t buf[16] = *((void *)&v21->__r_.__value_.__l + 2);
      *(_OWORD *)int buf = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      uint64_t v23 = std::string::append((std::string *)buf, "\"", 1uLL);
      std::string::size_type v24 = v23->__r_.__value_.__r.__words[0];
      v304.__r_.__value_.__r.__words[0] = v23->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v304.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v23->__r_.__value_.__r.__words[1] + 7);
      char v25 = HIBYTE(v23->__r_.__value_.__r.__words[2]);
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      sub_100058DB0(&__p, "X-3GPP-Intended-Identity");
      v286.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
      uint64_t v26 = (void **)sub_10014BECC((uint64_t **)&v284, (uint64_t)&__p, (uint64_t)&unk_10144E20E, &v286);
      __int16 v27 = v26;
      if (*((char *)v26 + 79) < 0) {
        operator delete(v26[7]);
      }
      std::string::size_type v28 = v304.__r_.__value_.__r.__words[0];
      v27[7] = (void *)v24;
      v27[8] = (void *)v28;
      *(void **)((char *)v27 + 71) = *(void **)((char *)v304.__r_.__value_.__r.__words + 7);
      *((unsigned char *)v27 + 79) = v25;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s1.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[0].__r_.__value_.__l.__data_);
      }
      if (*(unsigned char *)(a1 + 336))
      {
        sub_100058DB0(buf, "Authorization");
        __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        __int16 v29 = sub_10014BECC((uint64_t **)&v284, (uint64_t)buf, (uint64_t)&unk_10144E20E, __str);
        std::string::operator=((std::string *)((char *)v29 + 56), (const std::string *)(a1 + 312));
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    else
    {
      *(_OWORD *)&v284.__r_.__value_.__r.__words[1] = 0uLL;
      v284.__r_.__value_.__r.__words[0] = (std::string::size_type)&v284.__r_.__value_.__l.__size_;
    }
    memset(&__p, 0, sizeof(__p));
    sub_100CEB718(*(void *)(a1 + 144), (uint64_t)&__p);
    v270 = 0;
    v271 = 0;
    v272 = 0;
    sub_100E79688(buf, "Accept", "application/json");
    sub_100E796DC(&buf[48], "Accept-Encoding", "gzip");
    sub_100637AF8(v298, "Content-Type", "application/json");
    sub_100E79730(v299, "Content-Encoding", "gzip");
    sub_100058DB0(v300, "x-protocol-version");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v300[1], __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      v300[1] = __p;
    }
    sub_1002369E0((uint64_t)&v270, (long long *)buf, 5);
    uint64_t v30 = 0;
    v255 = (uint64_t *)(a1 + 576);
    do
    {
      __int16 v31 = (void **)&buf[v30 * 8];
      if (SHIBYTE(v300[1].__r_.__value_.__r.__words[v30 + 2]) < 0) {
        operator delete(v31[27]);
      }
      if (*((char *)v31 + 215) < 0) {
        operator delete(v31[24]);
      }
      v30 -= 6;
    }
    while (v30 != -30);
    if (*(_DWORD *)(a1 + 172) == 5) {
      goto LABEL_187;
    }
    if (v284.__r_.__value_.__r.__words[2]) {
      sub_1002365B8((char *)&v270, (long long *)v284.__r_.__value_.__l.__data_, (long long *)&v284.__r_.__value_.__r.__words[1]);
    }
    if (!*(_DWORD *)(a1 + 120)
      && !*(unsigned char *)(***(void ***)(a1 + 128) + 49)
      && sub_100CEA2E4(*(void *)(a1 + 144)))
    {
      uint64_t v32 = *(std::__shared_weak_count **)(a1 + 112);
      if (!v32) {
        goto LABEL_103;
      }
      __int16 v33 = std::__shared_weak_count::lock(v32);
      if (!v33) {
        goto LABEL_103;
      }
      uint64_t v34 = v33;
      uint64_t v35 = *(void *)(a1 + 104);
      if (!v35)
      {
LABEL_102:
        sub_10004D2C8(v34);
LABEL_103:
        id v52 = objc_alloc_init((Class)NSISO8601DateFormatter);
        id v53 = objc_msgSend(v52, "stringFromDate:", +[NSDate date](NSDate, "date"));

        sub_100058DB0(buf, (char *)[v53 UTF8String]);
        sub_100058DB0(__str, "x-self-registration-update");
        __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)__str;
        uint64_t v54 = sub_10014BECC(&v270, (uint64_t)__str, (uint64_t)&unk_10144E20E, &__s1);
        uint64_t v55 = (char *)v54 + 56;
        if (*((char *)v54 + 79) < 0) {
          operator delete(*(void **)v55);
        }
        *(_OWORD *)uint64_t v55 = *(_OWORD *)buf;
        *((void *)v55 + 2) = *(void *)&buf[16];
        buf[23] = 0;
        buf[0] = 0;
        if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__str[0].__r_.__value_.__l.__data_);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        goto LABEL_112;
      }
      v304.__r_.__value_.__r.__words[0] = 0;
      uint64_t v36 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v36 || (uint64_t v37 = *(void *)(a1 + 8), (v38 = std::__shared_weak_count::lock(v36)) == 0)) {
        sub_100088B9C();
      }
      *(void *)int buf = v37;
      *(void *)&uint8_t buf[8] = v38;
      (*(void (**)(std::string *__return_ptr, uint64_t, unsigned char *, const __CFString *, uint64_t))(*(void *)v35 + 40))(__str, v35, buf, @"kEntitlementsSelfRegistrationUpdateImsi", 1);
      sub_100056248(&v304, (CFTypeRef *)&__str[0].__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&__str[0].__r_.__value_.__l.__data_);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      v286.__r_.__value_.__r.__words[0] = 0;
      __int16 v39 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v39 || (v40 = *(void *)(a1 + 8), (__int16 v41 = std::__shared_weak_count::lock(v39)) == 0)) {
        sub_100088B9C();
      }
      *(void *)int buf = v40;
      *(void *)&uint8_t buf[8] = v41;
      (*(void (**)(std::string *__return_ptr, uint64_t, unsigned char *, const __CFString *, uint64_t))(*(void *)v35 + 40))(__str, v35, buf, @"kEntitlementsSelfRegistrationUpdateImei", 1);
      sub_100056248(&v286, (CFTypeRef *)&__str[0].__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&__str[0].__r_.__value_.__l.__data_);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      memset(buf, 0, 24);
      ctu::cf::assign();
      __str[0] = *(std::string *)buf;
      memset(buf, 0, 24);
      ctu::cf::assign();
      std::string __s1 = *(std::string *)buf;
      uint64_t v42 = *(void *)(a1 + 128);
      uint64_t v43 = *(void *)(v42 + 24);
      int v44 = *(char *)(v42 + 39);
      char v45 = buf[23];
      if (buf[23] >= 0) {
        uint64_t v46 = buf[23];
      }
      else {
        uint64_t v46 = *(void *)&buf[8];
      }
      if (v44 >= 0) {
        uint64_t v43 = *(unsigned __int8 *)(v42 + 39);
      }
      if (v46 != v43) {
        goto LABEL_92;
      }
      if (v44 >= 0) {
        uint64_t v47 = (unsigned __int8 *)(v42 + 16);
      }
      else {
        uint64_t v47 = *(unsigned __int8 **)(v42 + 16);
      }
      if ((buf[23] & 0x80) != 0)
      {
        uint64_t v50 = (void *)__s1.__r_.__value_.__r.__words[0];
        if (memcmp(__s1.__r_.__value_.__l.__data_, v47, *(size_t *)&buf[8])
          || !sub_10001D294((unsigned __int8 *)__str, (unsigned __int8 *)(v42 + 64)))
        {
          goto LABEL_98;
        }
        operator delete(v50);
      }
      else
      {
        if (buf[23])
        {
          uint64_t v48 = &__s1;
          uint64_t v49 = buf[23];
          while (v48->__r_.__value_.__s.__data_[0] == *v47)
          {
            uint64_t v48 = (std::string *)((char *)v48 + 1);
            ++v47;
            if (!--v49)
            {
              if (sub_10001D294((unsigned __int8 *)__str, (unsigned __int8 *)(v42 + 64))) {
                goto LABEL_109;
              }
              break;
            }
          }
LABEL_92:
          if ((v45 & 0x80) == 0)
          {
LABEL_99:
            if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str[0].__r_.__value_.__l.__data_);
            }
            sub_1000558F4((const void **)&v286.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&v304.__r_.__value_.__l.__data_);
            goto LABEL_102;
          }
          uint64_t v50 = (void *)__s1.__r_.__value_.__r.__words[0];
LABEL_98:
          operator delete(v50);
          goto LABEL_99;
        }
        if (!sub_10001D294((unsigned __int8 *)__str, (unsigned __int8 *)(v42 + 64))) {
          goto LABEL_99;
        }
      }
LABEL_109:
      if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[0].__r_.__value_.__l.__data_);
      }
      sub_1000558F4((const void **)&v286.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v304.__r_.__value_.__l.__data_);
      sub_10004D2C8(v34);
    }
LABEL_112:
    memset(&__s1, 0, sizeof(__s1));
    uint64_t v56 = *(void *)(a1 + 144);
    uint64_t v57 = ***(void ***)(a1 + 128);
    if (*(unsigned char *)(v57 + 49))
    {
      memset(buf, 0, 24);
    }
    else if (*(char *)(v57 + 47) < 0)
    {
      sub_10004FC84(buf, *(void **)(v57 + 24), *(void *)(v57 + 32));
    }
    else
    {
      *(_OWORD *)int buf = *(_OWORD *)(v57 + 24);
      *(void *)&uint8_t buf[16] = *(void *)(v57 + 40);
    }
    sub_100CEA680(v56, (uint64_t)&__s1);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    std::string::size_type v58 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v58 = __s1.__r_.__value_.__l.__size_;
    }
    if (v58)
    {
      sub_100058DB0(buf, "User-Agent");
      __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
      uint64_t v59 = sub_10014BECC(&v270, (uint64_t)buf, (uint64_t)&unk_10144E20E, __str);
      std::string::operator=((std::string *)((char *)v59 + 56), &__s1);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v61 = ServiceMap;
    if (v62 < 0)
    {
      uint64_t v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v64 = 5381;
      do
      {
        uint64_t v62 = v64;
        unsigned int v65 = *v63++;
        uint64_t v64 = (33 * v64) ^ v65;
      }
      while (v65);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int buf = v62;
    CFTypeRef v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
    if (v66)
    {
      uint64_t v68 = v66[3];
      uint64_t v67 = (std::__shared_weak_count *)v66[4];
      if (v67)
      {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v61);
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v67);
        if (!v68)
        {
LABEL_143:
          sub_10004D2C8(v67);
          goto LABEL_144;
        }
      }
      else
      {
        std::mutex::unlock(v61);
        if (!v68) {
          goto LABEL_144;
        }
      }
      memset(__str, 0, 24);
      (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v68 + 64))(__str, v68);
      std::string::size_type v69 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
      if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v69 = __str[0].__r_.__value_.__l.__size_;
      }
      if (v69)
      {
        sub_100058DB0(buf, "Accept-Language");
        v304.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        uint64_t v70 = sub_10014BECC(&v270, (uint64_t)buf, (uint64_t)&unk_10144E20E, &v304);
        std::string::operator=((std::string *)((char *)v70 + 56), __str);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        uint64_t v71 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v72 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v73 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v72;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v73;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno language preferences", buf, 0x2Au);
        }
      }
      if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[0].__r_.__value_.__l.__data_);
      }
      if (v67) {
        goto LABEL_143;
      }
    }
    else
    {
      std::mutex::unlock(v61);
    }
LABEL_144:
    if (*(unsigned char *)(***(void ***)(a1 + 128) + 49) || !sub_100CEB840(*(void *)(a1 + 144)))
    {
      v84 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v85 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v86 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v85;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v86;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = "";
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scurrent location sharing not allowed", buf, 0x2Au);
      }
      goto LABEL_185;
    }
    memset(&v304, 0, sizeof(v304));
    dsema[0] = dispatch_semaphore_create(0);
    uint64_t v74 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v75 = v74;
    if (v76 < 0)
    {
      uint64_t v77 = (unsigned __int8 *)(v76 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v78 = 5381;
      do
      {
        uint64_t v76 = v78;
        unsigned int v79 = *v77++;
        uint64_t v78 = (33 * v78) ^ v79;
      }
      while (v79);
    }
    std::mutex::lock(v74);
    *(void *)int buf = v76;
    uint64_t v80 = sub_10004D37C(&v75[1].__m_.__sig, (unint64_t *)buf);
    if (v80)
    {
      uint64_t v82 = v80[3];
      __int16 v81 = (std::__shared_weak_count *)v80[4];
      if (v81)
      {
        atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v75);
        atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v81);
        char v83 = 0;
        goto LABEL_156;
      }
    }
    else
    {
      uint64_t v82 = 0;
    }
    std::mutex::unlock(v75);
    __int16 v81 = 0;
    char v83 = 1;
LABEL_156:
    uint64_t v87 = *(unsigned int *)(***(void ***)(a1 + 128) + 52);
    __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A78CE8;
    __str[0].__r_.__value_.__l.__size_ = (std::string::size_type)&v304;
    __str[0].__r_.__value_.__r.__words[2] = (std::string::size_type)dsema;
    __str[1].__r_.__value_.__r.__words[0] = (std::string::size_type)__str;
    (*(void (**)(uint64_t, uint64_t, std::string *))(*(void *)v82 + 208))(v82, v87, __str);
    sub_10003DF80(__str);
    if ((v83 & 1) == 0) {
      sub_10004D2C8(v81);
    }
    dispatch_time_t v88 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_semaphore_wait(dsema[0], v88);
    xpc_object_t v89 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v90 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v91 = *(void *)(a1 + 160);
      uint64_t v92 = &v304;
      if ((v304.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v92 = (std::string *)v304.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v90;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v91;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v92;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sobtained network MCC %s", buf, 0x34u);
    }
    memset(&v286, 0, sizeof(v286));
    v93 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v94 = v93;
    if (v95 < 0)
    {
      unsigned int v96 = (unsigned __int8 *)(v95 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v97 = 5381;
      do
      {
        uint64_t v95 = v97;
        unsigned int v98 = *v96++;
        uint64_t v97 = (33 * v97) ^ v98;
      }
      while (v98);
    }
    std::mutex::lock(v93);
    *(void *)int buf = v95;
    uint64_t v99 = sub_10004D37C(&v94[1].__m_.__sig, (unint64_t *)buf);
    if (v99)
    {
      uint64_t v101 = v99[3];
      uint64_t v100 = (std::__shared_weak_count *)v99[4];
      if (v100)
      {
        atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v94);
        atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v100);
        char v102 = 0;
LABEL_170:
        (*(void (**)(std::string *__return_ptr, uint64_t, std::string *))(*(void *)v101 + 24))(&v286, v101, &v304);
        if ((v102 & 1) == 0) {
          sub_10004D2C8(v100);
        }
        std::string::size_type v103 = HIBYTE(v286.__r_.__value_.__r.__words[2]);
        if ((v286.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v103 = v286.__r_.__value_.__l.__size_;
        }
        if (v103)
        {
          sub_100058DB0(buf, "x-country-iso-code");
          v263[0] = buf;
          v104 = sub_10014BECC(&v270, (uint64_t)buf, (uint64_t)&unk_10144E20E, (_OWORD **)v263);
          std::string::operator=((std::string *)((char *)v104 + 56), &v286);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          uint64_t v105 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v106 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v107 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v106;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v107;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scurrent location is unknown", buf, 0x2Au);
          }
        }
        if (SHIBYTE(v286.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v286.__r_.__value_.__l.__data_);
        }
        if (dsema[0]) {
          dispatch_release(dsema[0]);
        }
        if (SHIBYTE(v304.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v304.__r_.__value_.__l.__data_);
        }
LABEL_185:
        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s1.__r_.__value_.__l.__data_);
        }
LABEL_187:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        sub_10010C0E0((uint64_t)&v284, (void *)v284.__r_.__value_.__l.__size_);
        v108 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v109 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v110 = *(void *)(a1 + 160);
          std::string v111 = &v273;
          if ((v273.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string v111 = (std::string *)v273.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v109;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v110;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          *(_WORD *)&buf[42] = 2080;
          *(void *)&buf[44] = v111;
          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%surl: %s", buf, 0x34u);
          v108 = *(NSObject **)(a1 + 40);
        }
        if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v112 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v113 = *(void *)(a1 + 160);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v112;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v113;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%ssend header:", buf, 0x2Au);
        }
        xpc_object_t v114 = v270;
        if (v270 != (uint64_t *)&v271)
        {
          do
          {
            uint64_t v115 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v116 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              xpc_object_t v117 = v114 + 4;
              if (*((char *)v114 + 55) < 0) {
                xpc_object_t v117 = (void *)*v117;
              }
              __int16 v118 = v114 + 7;
              if (*((char *)v114 + 79) < 0) {
                __int16 v118 = (void *)*v118;
              }
              uint64_t v119 = *(void *)(a1 + 160);
              *(_DWORD *)int buf = 136316418;
              *(void *)&uint8_t buf[4] = v116;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = v119;
              *(_WORD *)&unsigned char buf[32] = 2080;
              *(void *)&buf[34] = "";
              *(_WORD *)&buf[42] = 2080;
              *(void *)&buf[44] = v117;
              *(_WORD *)&buf[52] = 2080;
              *(void *)&buf[54] = v118;
              _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  %s: %s", buf, 0x3Eu);
            }
            __int16 v120 = (uint64_t *)v114[1];
            if (v120)
            {
              do
              {
                xpc_object_t v121 = v120;
                __int16 v120 = (uint64_t *)*v120;
              }
              while (v120);
            }
            else
            {
              do
              {
                xpc_object_t v121 = (uint64_t *)v114[2];
                BOOL v122 = *v121 == (void)v114;
                xpc_object_t v114 = v121;
              }
              while (!v122);
            }
            xpc_object_t v114 = v121;
          }
          while (v121 != (uint64_t *)&v271);
        }
        if (SHIBYTE(v273.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v269, v273.__r_.__value_.__l.__data_, v273.__r_.__value_.__l.__size_);
        }
        else {
          std::string v269 = v273;
        }
        v267 = v270;
        v268[0] = v271;
        v268[1] = v272;
        if (v272)
        {
          v271[2] = v268;
          v270 = (uint64_t *)&v271;
          v271 = 0;
          v272 = 0;
        }
        else
        {
          v267 = (uint64_t *)v268;
        }
        uint64_t v123 = *(void *)(a1 + 552);
        uint64_t v124 = *(void *)(a1 + 560);
        if (v124) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)int buf = v123;
        *(void *)&uint8_t buf[8] = v124;
        ctu::Http::HttpRequest::create();
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        long long v125 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
        *(_OWORD *)&__str[0].__r_.__value_.__l.__data_ = 0uLL;
        xpc_object_t v126 = *(std::__shared_weak_count **)(a1 + 544);
        v258 = (void *)(a1 + 536);
        *(_OWORD *)(a1 + 536) = v125;
        if (v126)
        {
          sub_10004D2C8(v126);
          if (__str[0].__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
          }
        }
        sub_10010C0E0((uint64_t)&v267, v268[0]);
        if (SHIBYTE(v269.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v269.__r_.__value_.__l.__data_);
        }
        uint64_t v127 = *v258;
        if (*v258)
        {
          if (*(void *)(a1 + 424)) {
            v128 = sub_100083F10;
          }
          else {
            v128 = 0;
          }
          if (v128)
          {
            (*(void (**)(void))(*(void *)v127 + 72))(*v258);
            uint64_t v127 = *v258;
          }
          sub_100FC0930(*(void *)(a1 + 576), (uint64_t)buf);
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v127 + 56))(v127, buf);
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          (*(void (**)(void, void))(**(void **)(a1 + 536) + 8))(*(void *)(a1 + 536), *(void *)(a1 + 24));
          uint64_t v129 = *(void *)(a1 + 536);
          v265[0] = _NSConcreteStackBlock;
          v265[1] = 3321888768;
          v265[2] = sub_100FA6250;
          v265[3] = &unk_101A77748;
          int64_t v130 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v130 || (uint64_t v131 = *(void *)(a1 + 8), (v132 = std::__shared_weak_count::lock(v130)) == 0)) {
            sub_100088B9C();
          }
          xpc_object_t v133 = v132;
          p_shared_weak_owners = &v132->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v132->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v132);
          v265[4] = a1;
          v265[5] = v131;
          v266 = v133;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          (*(void (**)(uint64_t, void *))(*(void *)v129 + 16))(v129, v265);
          std::__shared_weak_count::__release_weak(v133);
          v263[0] = 0;
          v263[1] = 0;
          uint64_t v264 = 0;
          if (*(char *)(a1 + 535) < 0)
          {
            sub_10004FC84(v263, *(void **)(a1 + 512), *(void *)(a1 + 520));
          }
          else
          {
            *(_OWORD *)v263 = *(_OWORD *)(a1 + 512);
            uint64_t v264 = *(void *)(a1 + 528);
          }
          xpc_object_t v138 = (void *)HIBYTE(v264);
          if (v264 < 0) {
            xpc_object_t v138 = v263[1];
          }
          if (v138)
          {
            uint64_t v139 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v140 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v141 = *(void *)(a1 + 160);
              long long v142 = v263;
              if (v264 < 0) {
                long long v142 = (void **)v263[0];
              }
              *(_DWORD *)int buf = 136316162;
              *(void *)&uint8_t buf[4] = v140;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = v141;
              *(_WORD *)&unsigned char buf[32] = 2080;
              *(void *)&buf[34] = "";
              *(_WORD *)&buf[42] = 2080;
              *(void *)&buf[44] = v142;
              _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIssuing Request (bound to interface '%s')", buf, 0x34u);
            }
          }
          if (!v256 && sub_100FA09C4(a1))
          {
            uint64_t v143 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v144 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
              uint64_t v145 = *(void *)(a1 + 160);
              uint64_t v146 = "iPhone";
              if (!*(unsigned char *)(a1 + 705)) {
                uint64_t v146 = "Internet";
              }
              *(_DWORD *)int buf = 136316162;
              *(void *)&uint8_t buf[4] = v144;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)&unsigned char buf[24] = v145;
              *(_WORD *)&unsigned char buf[32] = 2080;
              *(void *)&buf[34] = "";
              *(_WORD *)&buf[42] = 2080;
              *(void *)&buf[44] = v146;
              _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIssuing Request without interface or service type restrictions (over %s)", buf, 0x34u);
            }
            if (!*(unsigned char *)(a1 + 705))
            {
              if (sub_100FC7808(*v255))
              {
                uint64_t v147 = *v258;
                sub_100058DB0(buf, "com.apple.CommCenter.CellularPlanProvisioning");
                (*(void (**)(uint64_t, unsigned char *))(*(void *)v147 + 160))(v147, buf);
                if ((buf[23] & 0x80000000) != 0) {
                  operator delete(*(void **)buf);
                }
              }
            }
            goto LABEL_261;
          }
          if (*(unsigned char *)(*(void *)(a1 + 144) + 96))
          {
            long long v148 = *(NSObject **)(a1 + 40);
            if (*(unsigned char *)(a1 + 769))
            {
              if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v149 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                uint64_t v150 = *(void *)(a1 + 160);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v149;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)&unsigned char buf[24] = v150;
                *(_WORD *)&unsigned char buf[32] = 2080;
                *(void *)&buf[34] = "";
                _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIssuing Request (over Entitlement service)", buf, 0x2Au);
              }
              (*(void (**)(void, void))(*(void *)*v258 + 152))(*v258, kCTDataConnectionServiceTypeEntitlementTraffic);
              (*(void (**)(void, void))(**(void **)(a1 + 536) + 160))(*(void *)(a1 + 536), ***(void ***)(a1 + 128));
LABEL_261:
              int v151 = sub_100CEB998(*(void *)(a1 + 144));
              if (v151)
              {
                uint64_t v152 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v153 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                  uint64_t v154 = *(void *)(a1 + 160);
                  *(_DWORD *)int buf = 136316162;
                  *(void *)&uint8_t buf[4] = v153;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = v154;
                  *(_WORD *)&unsigned char buf[32] = 2080;
                  *(void *)&buf[34] = "";
                  *(_WORD *)&buf[42] = 1024;
                  *(_DWORD *)&buf[44] = v151;
                  _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRequest timeout set to %d seconds", buf, 0x30u);
                }
                (*(void (**)(double))(*(void *)*v258 + 96))((double)v151);
              }
              (*(void (**)(void, uint64_t))(*(void *)*v258 + 200))(*v258, 75);
              dsema[0] = 0;
              dsema[1] = 0;
              uint64_t v262 = 0;
              xpc_object_t v155 = (wis::MetricFactory *)sub_100F995A0(*(Registry **)(a1 + 48), ***(void ***)(a1 + 128), *(void *)(a1 + 128) + 64, (uint64_t)dsema);
              if (v155)
              {
                if (!*(_DWORD *)(a1 + 120))
                {
                  if (*v255)
                  {
                    *(void *)int buf = _NSConcreteStackBlock;
                    *(void *)&uint8_t buf[8] = 3221225472;
                    *(void *)&uint8_t buf[16] = sub_100FAC7D8;
                    *(void *)&unsigned char buf[24] = &unk_101A77DB0;
                    *(void *)&unsigned char buf[32] = dsema;
                    *(void *)&buf[40] = a1 + 576;
                    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v155);
                    xpc_object_t v157 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800E2u);
                    __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v157;
                    if (v157)
                    {
                      uint64_t v158 = sub_10001C8F4(8);
                      uint64_t v160 = *v158;
                      long long v159 = (std::__shared_weak_count *)v158[1];
                      if (v159) {
                        atomic_fetch_add_explicit(&v159->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      if (v160) {
                        operator new();
                      }
                      if (v159) {
                        sub_10004D2C8(v159);
                      }
                      wis::MetricContainer::~MetricContainer(v157);
                      operator delete();
                    }
                  }
                }
              }
              else
              {
                CFBooleanRef v167 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v250 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                  uint64_t v251 = *(void *)(a1 + 160);
                  *(_DWORD *)int buf = 136315906;
                  *(void *)&uint8_t buf[4] = v250;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = v251;
                  *(_WORD *)&unsigned char buf[32] = 2080;
                  *(void *)&buf[34] = "";
                  _os_log_error_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_ERROR, "#E %s%s%s%sPLMN is not available. Will not submit AWDMetrics", buf, 0x2Au);
                }
              }
              if (!*(void *)(a1 + 736)) {
                operator new();
              }
              uint64_t v168 = *(void *)(a1 + 576);
              CFTypeID v169 = *(std::__shared_weak_count **)(a1 + 584);
              if (v169) {
                atomic_fetch_add_explicit(&v169->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (sub_100FBA740(v168, 29) || (CFArrayRef v170 = (const __CFArray *)sub_100FBC4A8(v168)) == 0)
              {
LABEL_429:
                if (v169) {
                  sub_10004D2C8(v169);
                }
                uint64_t v248 = *v255;
                *(void *)&uint8_t buf[8] = 0;
                *(void *)int buf = 0;
                gettimeofday((timeval *)buf, 0);
                *(void *)(v248 + 80) = 1000 * *(void *)buf + *(int *)&buf[8] / 0x3E8uLL;
                uint64_t v249 = *v258;
                if (SHIBYTE(v264) < 0)
                {
                  sub_10004FC84(v259, v263[0], (unint64_t)v263[1]);
                }
                else
                {
                  *(_OWORD *)v259 = *(_OWORD *)v263;
                  uint64_t v260 = v264;
                }
                (*(void (**)(uint64_t, void **))(*(void *)v249 + 40))(v249, v259);
                if (SHIBYTE(v260) < 0) {
                  operator delete(v259[0]);
                }
                if (SHIBYTE(v262) < 0) {
                  operator delete(dsema[0]);
                }
                if (SHIBYTE(v264) < 0) {
                  operator delete(v263[0]);
                }
                if (v266) {
                  std::__shared_weak_count::__release_weak(v266);
                }
                sub_10010C0E0((uint64_t)&v270, v271);
                if (SHIBYTE(v273.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v273.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
                return;
              }
              std::string::size_type v287 = 0;
              std::to_string(&v304, *(void *)(*(void *)(a1 + 144) + 56));
              v257 = v169;
              if (SHIBYTE(v304.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(__str, v304.__r_.__value_.__l.__data_, v304.__r_.__value_.__l.__size_);
              }
              else {
                __str[0] = v304;
              }
              v286.__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(buf, __str[0].__r_.__value_.__l.__data_, __str[0].__r_.__value_.__l.__size_);
              }
              else {
                *(std::string *)int buf = __str[0];
              }
              __p.__r_.__value_.__r.__words[0] = 0;
              if (ctu::cf::convert_copy())
              {
                std::string::size_type v171 = v286.__r_.__value_.__r.__words[0];
                v286.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
                __s1.__r_.__value_.__r.__words[0] = v171;
                sub_1000558F4((const void **)&__s1.__r_.__value_.__l.__data_);
              }
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              std::string::size_type v287 = v286.__r_.__value_.__r.__words[0];
              v286.__r_.__value_.__r.__words[0] = 0;
              sub_1000558F4((const void **)&v286.__r_.__value_.__l.__data_);
              if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str[0].__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v304.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v304.__r_.__value_.__l.__data_);
              }
              std::string::size_type v172 = v287;
              xpc_object_t v173 = operator new(8uLL);
              v285 = 0;
              v286.__r_.__value_.__r.__words[0] = (std::string::size_type)v173;
              *xpc_object_t v173 = v172;
              v286.__r_.__value_.__l.__size_ = (std::string::size_type)(v173 + 1);
              v286.__r_.__value_.__r.__words[2] = (std::string::size_type)(v173 + 1);
              xpc_object_t v174 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
              std::string::size_type v175 = v174;
              uint64_t v177 = v176;
              if (v176 < 0)
              {
                std::string::size_type v178 = (unsigned __int8 *)(v176 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v179 = 5381;
                do
                {
                  uint64_t v177 = v179;
                  unsigned int v180 = *v178++;
                  uint64_t v179 = (33 * v179) ^ v180;
                }
                while (v180);
              }
              std::mutex::lock(v174);
              *(void *)int buf = v177;
              long long v181 = sub_10004D37C(&v175[1].__m_.__sig, (unint64_t *)buf);
              if (v181)
              {
                uint64_t v183 = v181[3];
                long long v182 = (std::__shared_weak_count *)v181[4];
                if (v182)
                {
                  atomic_fetch_add_explicit(&v182->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v175);
                  atomic_fetch_add_explicit(&v182->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v182);
                  char v184 = 0;
                  goto LABEL_319;
                }
              }
              else
              {
                uint64_t v183 = 0;
              }
              std::mutex::unlock(v175);
              long long v182 = 0;
              char v184 = 1;
LABEL_319:
              uint64_t v185 = kCarrierEntitlementsWalletDomain;
              (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, void, std::string *, uint64_t))(*(void *)v183 + 24))(__str, v183, ***(void ***)(a1 + 128) + 24, @"DaysSinceEpoch", kCarrierEntitlementsWalletDomain, &v286, 3);
              sub_1000842D0(&v285, (CFTypeRef *)&__str[0].__r_.__value_.__l.__data_);
              sub_1000577C4((const void **)&__str[0].__r_.__value_.__l.__data_);
              if ((v184 & 1) == 0) {
                sub_10004D2C8(v182);
              }
              id v186 = objc_msgSend(v285, "unsignedLongLongValue", v255);
              unint64_t v187 = (unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180;
              if ((id)v187 == v186)
              {
                __str[0].__r_.__value_.__r.__words[0] = 0;
                uint64_t v188 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
                v189 = v188;
                uint64_t v190 = v176;
                if (v176 < 0)
                {
                  uint64_t v191 = (unsigned __int8 *)(v176 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v192 = 5381;
                  do
                  {
                    uint64_t v190 = v192;
                    unsigned int v193 = *v191++;
                    uint64_t v192 = (33 * v192) ^ v193;
                  }
                  while (v193);
                }
                std::mutex::lock(v188);
                *(void *)int buf = v190;
                v194 = sub_10004D37C(&v189[1].__m_.__sig, (unint64_t *)buf);
                if (v194)
                {
                  uint64_t v196 = v194[3];
                  v195 = (std::__shared_weak_count *)v194[4];
                  if (v195)
                  {
                    atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v189);
                    atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v195);
                    char v197 = 0;
LABEL_336:
                    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, std::string *, uint64_t))(*(void *)v196 + 24))(&__s1, v196, ***(void ***)(a1 + 128) + 24, @"ActionGetEntitlementToday", v185, &v286, 3);
                    sub_1000842D0(__str, (CFTypeRef *)&__s1.__r_.__value_.__l.__data_);
                    sub_1000577C4((const void **)&__s1.__r_.__value_.__l.__data_);
                    if ((v197 & 1) == 0) {
                      sub_10004D2C8(v195);
                    }
                    *(void *)int buf = 0;
                    ctu::cf::assign((ctu::cf *)buf, (unint64_t *)__str[0].__r_.__value_.__l.__data_, v208);
                    uint64_t v209 = *(void *)buf;
                    sub_1000570E8((const void **)&__str[0].__r_.__value_.__l.__data_);
                    goto LABEL_344;
                  }
                }
                else
                {
                  uint64_t v196 = 0;
                }
                std::mutex::unlock(v189);
                v195 = 0;
                char v197 = 1;
                goto LABEL_336;
              }
              v198 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
              v199 = v198;
              uint64_t v200 = v176;
              if (v176 < 0)
              {
                v201 = (unsigned __int8 *)(v176 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v202 = 5381;
                do
                {
                  uint64_t v200 = v202;
                  unsigned int v203 = *v201++;
                  uint64_t v202 = (33 * v202) ^ v203;
                }
                while (v203);
              }
              std::mutex::lock(v198);
              *(void *)int buf = v200;
              BOOL v204 = sub_10004D37C(&v199[1].__m_.__sig, (unint64_t *)buf);
              if (v204)
              {
                uint64_t v206 = v204[3];
                v205 = (std::__shared_weak_count *)v204[4];
                if (v205)
                {
                  atomic_fetch_add_explicit(&v205->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v199);
                  atomic_fetch_add_explicit(&v205->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v205);
                  char v207 = 0;
LABEL_341:
                  (*(void (**)(uint64_t, uint64_t, const __CFString *, NSNumber *, uint64_t, std::string *, uint64_t, void))(*(void *)v206 + 16))(v206, ***(void ***)(a1 + 128) + 24, @"DaysSinceEpoch", +[NSNumber numberWithUnsignedLongLong:v187], v185, &v286, 3, 0);
                  if ((v207 & 1) == 0) {
                    sub_10004D2C8(v205);
                  }
                  uint64_t v209 = 0;
LABEL_344:
                  v210 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
                  uint64_t v211 = v210;
                  if (v176 < 0)
                  {
                    v212 = (unsigned __int8 *)(v176 & 0x7FFFFFFFFFFFFFFFLL);
                    uint64_t v213 = 5381;
                    do
                    {
                      uint64_t v176 = v213;
                      unsigned int v214 = *v212++;
                      uint64_t v213 = (33 * v213) ^ v214;
                    }
                    while (v214);
                  }
                  std::mutex::lock(v210);
                  *(void *)int buf = v176;
                  v215 = sub_10004D37C(&v211[1].__m_.__sig, (unint64_t *)buf);
                  unint64_t v216 = v209 + 1;
                  if (v215)
                  {
                    uint64_t v218 = v215[3];
                    v217 = (std::__shared_weak_count *)v215[4];
                    if (v217)
                    {
                      atomic_fetch_add_explicit(&v217->__shared_owners_, 1uLL, memory_order_relaxed);
                      std::mutex::unlock(v211);
                      atomic_fetch_add_explicit(&v217->__shared_owners_, 1uLL, memory_order_relaxed);
                      sub_10004D2C8(v217);
                      char v219 = 0;
LABEL_352:
                      (*(void (**)(uint64_t, uint64_t, const __CFString *, NSNumber *, uint64_t, std::string *, uint64_t, void))(*(void *)v218 + 16))(v218, ***(void ***)(a1 + 128) + 24, @"ActionGetEntitlementToday", +[NSNumber numberWithUnsignedLong:v216], v185, &v286, 3, 0);
                      if ((v219 & 1) == 0) {
                        sub_10004D2C8(v217);
                      }
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12FE8, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_101B12FE8))
                      {
                        *(_OWORD *)int buf = *(_OWORD *)"\n";
                        *(void *)&uint8_t buf[16] = 100;
                        sub_100FA616C(buf, 3uLL);
                        __cxa_atexit((void (*)(void *))sub_100FA621C, &qword_101B12FF0, (void *)&_mh_execute_header);
                        __cxa_guard_release(&qword_101B12FE8);
                      }
                      for (int i = (void *)qword_101B12FF0; i != (void *)qword_101B12FF8; ++i)
                      {
                        if (*i == v216) {
                          goto LABEL_361;
                        }
                      }
                      unint64_t v221 = *(void *)(qword_101B12FF8 - 8);
                      if (v216 <= v221 || v216 % v221) {
                        goto LABEL_426;
                      }
LABEL_361:
                      uint64_t v303 = 0;
                      long long v301 = 0u;
                      long long v302 = 0u;
                      memset(v300, 0, sizeof(v300));
                      memset(v299, 0, sizeof(v299));
                      *(_OWORD *)v297 = 0u;
                      memset(v298, 0, sizeof(v298));
                      long long v296 = 0u;
                      memset(buf, 0, sizeof(buf));
                      sub_10004BD84((uint64_t)buf);
                      CFIndex Count = CFArrayGetCount(v170);
                      if (Count)
                      {
                        CFIndex v223 = 0;
                        char v224 = 1;
                        do
                        {
                          ValueAtIndex = CFArrayGetValueAtIndex(v170, v223);
                          if (ValueAtIndex)
                          {
                            CFTypeID v226 = CFGetTypeID(ValueAtIndex);
                            if (v226 == CFStringGetTypeID())
                            {
                              if ((v224 & 1) == 0) {
                                sub_10004B96C(&buf[16], (uint64_t)", ", 2);
                              }
                              memset(__str, 0, 24);
                              ctu::cf::assign();
                              std::string __s1 = __str[0];
                              if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                v227 = &__s1;
                              }
                              else {
                                v227 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                              }
                              if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                std::string::size_type v228 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                              }
                              else {
                                std::string::size_type v228 = __str[0].__r_.__value_.__l.__size_;
                              }
                              sub_10004B96C(&buf[16], (uint64_t)v227, v228);
                              if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__s1.__r_.__value_.__l.__data_);
                              }
                              char v224 = 0;
                            }
                          }
                          ++v223;
                        }
                        while (Count != v223);
                      }
                      __int16 v229 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
                      {
                        std::string::size_type v252 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
                        std::string::size_type v253 = *(void *)(a1 + 160);
                        sub_10004BC98((uint64_t)&buf[24], &__s1);
                        v254 = (__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                             ? &__s1
                             : (std::string *)__s1.__r_.__value_.__r.__words[0];
                        LODWORD(__str[0].__r_.__value_.__l.__data_) = 136316418;
                        *(std::string::size_type *)((char *)__str[0].__r_.__value_.__r.__words + 4) = v252;
                        WORD2(__str[0].__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&__str[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                        HIWORD(__str[0].__r_.__value_.__r.__words[2]) = 2080;
                        __str[1].__r_.__value_.__r.__words[0] = v253;
                        LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&__str[1].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
                        WORD1(__str[1].__r_.__value_.__r.__words[2]) = 2048;
                        *(std::string::size_type *)((char *)&__str[1].__r_.__value_.__r.__words[2] + 4) = v216;
                        WORD2(__str[2].__r_.__value_.__r.__words[0]) = 2082;
                        *(std::string::size_type *)((char *)__str[2].__r_.__value_.__r.__words + 6) = (std::string::size_type)v254;
                        _os_log_error_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, "#E %s%s%s%s***** getEntitlement abuse, issued today %zu times, current contain:[%{public}s]", (uint8_t *)__str, 0x3Eu);
                        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__s1.__r_.__value_.__l.__data_);
                        }
                      }
                      v230 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
                      __int16 v231 = v230;
                      if ((v232 & 0x8000000000000000) != 0)
                      {
                        v233 = (unsigned __int8 *)(v232 & 0x7FFFFFFFFFFFFFFFLL);
                        uint64_t v234 = 5381;
                        do
                        {
                          std::string::size_type v232 = v234;
                          unsigned int v235 = *v233++;
                          uint64_t v234 = (33 * v234) ^ v235;
                        }
                        while (v235);
                      }
                      std::mutex::lock(v230);
                      __str[0].__r_.__value_.__r.__words[0] = v232;
                      long long v236 = sub_10004D37C(&v231[1].__m_.__sig, (unint64_t *)__str);
                      if (v236)
                      {
                        uint64_t v237 = v236[3];
                        uint64_t v238 = (std::__shared_weak_count *)v236[4];
                        if (v238)
                        {
                          atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
                          std::mutex::unlock(v231);
                          atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
                          sub_10004D2C8(v238);
                          char v239 = 0;
                          goto LABEL_386;
                        }
                      }
                      else
                      {
                        uint64_t v237 = 0;
                      }
                      std::mutex::unlock(v231);
                      uint64_t v238 = 0;
                      char v239 = 1;
LABEL_386:
                      if (v237)
                      {
                        *(_OWORD *)&__str[0].__r_.__value_.__r.__words[1] = 0u;
                        memset(&__str[1].__r_.__value_.__r.__words[2], 0, 32);
                        long long v294 = 0u;
                        long long v293 = 0u;
                        memset(&__str[3], 0, sizeof(std::string));
                        uint64_t v292 = 23;
                        qmemcpy((char *)&__str[0].__r_.__value_.__r.__words[2] + 7, "\tCarrierEntitlements", 20);
                        __str[0].__r_.__value_.__s.__data_[8] = 121;
                        __str[0].__r_.__value_.__r.__words[0] = *(void *)"Telephony";
                        *((unsigned char *)&__str[1].__r_.__value_.__s + 23) = 19;
                        sub_10003ECB8(&__str[2], "too many getEntitlement requests", 0x20uLL);
                        sub_100058DB0(&__p, "action requested ");
                        std::to_string(&v284, v216);
                        if ((v284.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          v240 = &v284;
                        }
                        else {
                          v240 = (std::string *)v284.__r_.__value_.__r.__words[0];
                        }
                        if ((v284.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v241 = HIBYTE(v284.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v241 = v284.__r_.__value_.__l.__size_;
                        }
                        v242 = std::string::append(&__p, (const std::string::value_type *)v240, v241);
                        long long v243 = *(_OWORD *)&v242->__r_.__value_.__l.__data_;
                        __s1.__r_.__value_.__r.__words[2] = v242->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__s1.__r_.__value_.__l.__data_ = v243;
                        v242->__r_.__value_.__l.__size_ = 0;
                        v242->__r_.__value_.__r.__words[2] = 0;
                        v242->__r_.__value_.__r.__words[0] = 0;
                        v244 = std::string::append(&__s1, " times within a day", 0x13uLL);
                        std::string::size_type v245 = v244->__r_.__value_.__r.__words[0];
                        v290[0] = v244->__r_.__value_.__l.__size_;
                        *(void *)((char *)v290 + 7) = *(std::string::size_type *)((char *)&v244->__r_.__value_.__r.__words[1]
                                                                                  + 7);
                        char v246 = HIBYTE(v244->__r_.__value_.__r.__words[2]);
                        v244->__r_.__value_.__l.__size_ = 0;
                        v244->__r_.__value_.__r.__words[2] = 0;
                        v244->__r_.__value_.__r.__words[0] = 0;
                        if (SHIBYTE(__str[3].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str[3].__r_.__value_.__l.__data_);
                        }
                        __str[3].__r_.__value_.__r.__words[0] = v245;
                        __str[3].__r_.__value_.__l.__size_ = v290[0];
                        *(std::string::size_type *)((char *)&__str[3].__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v290 + 7);
                        *((unsigned char *)&__str[3].__r_.__value_.__s + 23) = v246;
                        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__s1.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v284.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v284.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        v292 |= 7uLL;
                        sub_1000DB86C((char *)&__s1, (long long *)__str);
                        uint64_t v289 = 0;
                        (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v237 + 16))(v237, &__s1, &__p);
                        sub_1000DBADC(&__p);
                        if (v283 < 0) {
                          operator delete(v282);
                        }
                        if (v281 < 0) {
                          operator delete(v280);
                        }
                        if (v279 < 0) {
                          operator delete(v278);
                        }
                        if (v277 < 0) {
                          operator delete(v276);
                        }
                        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__s1.__r_.__value_.__l.__data_);
                        }
                        if (SBYTE7(v294) < 0) {
                          operator delete((void *)v293);
                        }
                        if (SHIBYTE(__str[3].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str[3].__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str[2].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str[2].__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str[1].__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str[0].__r_.__value_.__l.__data_);
                        }
                      }
                      if ((v239 & 1) == 0) {
                        sub_10004D2C8(v238);
                      }
                      *(void *)&uint8_t buf[16] = v247;
                      if (SHIBYTE(v298[0]) < 0) {
                        operator delete(v297[1]);
                      }
                      std::streambuf::~streambuf();
                      std::iostream::~basic_iostream();
                      std::ios::~ios();
LABEL_426:
                      sub_1000570E8((const void **)&v285);
                      if (v286.__r_.__value_.__r.__words[0])
                      {
                        v286.__r_.__value_.__l.__size_ = v286.__r_.__value_.__r.__words[0];
                        operator delete(v286.__r_.__value_.__l.__data_);
                      }
                      sub_1000558F4((const void **)&v287);
                      CFTypeID v169 = v257;
                      goto LABEL_429;
                    }
                  }
                  else
                  {
                    uint64_t v218 = 0;
                  }
                  std::mutex::unlock(v211);
                  v217 = 0;
                  char v219 = 1;
                  goto LABEL_352;
                }
              }
              else
              {
                uint64_t v206 = 0;
              }
              std::mutex::unlock(v199);
              v205 = 0;
              char v207 = 1;
              goto LABEL_341;
            }
          }
          else
          {
            long long v148 = *(NSObject **)(a1 + 40);
          }
          if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v161 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v162 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v161;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v162;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sno-go. Device cannot use BB and do not have WiFi available", buf, 0x2Au);
          }
          if (SHIBYTE(v264) < 0) {
            operator delete(v263[0]);
          }
          if (v266) {
            std::__shared_weak_count::__release_weak(v266);
          }
        }
        else
        {
          xpc_object_t v135 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v136 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            uint64_t v137 = *(void *)(a1 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v136;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v137;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = "";
            _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate request", buf, 0x2Au);
          }
        }
        sub_10010C0E0((uint64_t)&v270, v271);
        if (SHIBYTE(v273.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v273.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        goto LABEL_283;
      }
    }
    else
    {
      uint64_t v101 = 0;
    }
    std::mutex::unlock(v94);
    uint64_t v100 = 0;
    char v102 = 1;
    goto LABEL_170;
  }
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_287;
  }
  uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
  uint64_t v8 = *(void *)(a1 + 160);
  *(_DWORD *)int buf = 136315906;
  *(void *)&uint8_t buf[4] = v7;
  *(_WORD *)&unsigned char buf[12] = 2080;
  *(void *)&buf[14] = " ";
  *(_WORD *)&unsigned char buf[22] = 2080;
  *(void *)&unsigned char buf[24] = v8;
  *(_WORD *)&unsigned char buf[32] = 2080;
  *(void *)&buf[34] = "";
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sNo Requested Query Object", buf, 0x2Au);
LABEL_283:
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (*(void *)(a1 + 576))
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v163 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v164 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v163;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v164;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to send http request", buf, 0x2Au);
    }
    buf[0] = 0;
    uint8_t buf[4] = 0;
    sub_100F9E344(a1, 0, (uint64_t)buf);
    return;
  }
LABEL_287:
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v165 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v166 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v165;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v166;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sRequest is no longer valid", buf, 0x2Au);
  }
}

void sub_100FA5848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, dispatch_object_t object, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  __cxa_guard_abort(&qword_101B12FE8);
  sub_1000570E8(&a72);
  if (__p)
  {
    a74 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&a75);
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a21 < 0) {
    operator delete(object);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a35) {
    std::__shared_weak_count::__release_weak(a35);
  }
  sub_10010C0E0((uint64_t)&a42, (void *)a43);
  if (a50 < 0) {
    operator delete(a45);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  _Unwind_Resume(a1);
}

void *sub_100FA5F90(void *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 328))
  {
    if ((*(char *)(a2 + 327) & 0x80000000) == 0)
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)(a2 + 304);
      result[2] = *(void *)(a2 + 320);
      return result;
    }
    unint64_t v4 = *(void *)(a2 + 312);
    uint64_t v5 = *(void **)(a2 + 304);
    return sub_10004FC84(result, v5, v4);
  }
  if (*(unsigned char *)(a2 + 296))
  {
    uint64_t v2 = *(long long **)(a2 + 216);
    if (*(long long **)(a2 + 224) != v2)
    {
      if ((*((char *)v2 + 23) & 0x80000000) == 0)
      {
        long long v3 = *v2;
        result[2] = *((void *)v2 + 2);
        *(_OWORD *)uint64_t result = v3;
        return result;
      }
      uint64_t v5 = *(void **)v2;
      unint64_t v4 = *((void *)v2 + 1);
      return sub_10004FC84(result, v5, v4);
    }
  }
  return sub_100058DB0(result, "");
}

void sub_100FA6008(std::string *__dst, uint64_t a2, uint64_t a3)
{
  __dst->__r_.__value_.__r.__words[0] = 0;
  __dst->__r_.__value_.__l.__size_ = 0;
  __dst->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    __dst->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
  }
  uint64_t size = HIBYTE(__dst->__r_.__value_.__r.__words[2]);
  BOOL v6 = (size & 0x80u) != 0;
  if ((size & 0x80u) != 0) {
    uint64_t size = __dst->__r_.__value_.__l.__size_;
  }
  if (v6) {
    uint64_t v7 = (std::string *)__dst->__r_.__value_.__r.__words[0];
  }
  else {
    uint64_t v7 = __dst;
  }
  if (size >= 8)
  {
    uint64_t v8 = (char *)v7 + size;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = (char *)memchr(v9, 36, size - 7);
      if (!v10) {
        break;
      }
      if (*(void *)v10 == 0x6972752D70697324)
      {
        if (v10 != v8)
        {
          std::string::size_type v11 = v10 - (char *)v7;
          if (v11 != -1)
          {
            sub_100FA5F90(__p, *(void *)(a2 + 128));
            if ((v15 & 0x80u) == 0) {
              int v12 = __p;
            }
            else {
              int v12 = (void **)__p[0];
            }
            if ((v15 & 0x80u) == 0) {
              std::string::size_type v13 = v15;
            }
            else {
              std::string::size_type v13 = (std::string::size_type)__p[1];
            }
            std::string::replace(__dst, v11, 8uLL, (const std::string::value_type *)v12, v13);
            if ((char)v15 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        return;
      }
      uint64_t v9 = (std::string *)(v10 + 1);
      uint64_t size = v8 - (char *)v9;
    }
    while (v8 - (char *)v9 >= 8);
  }
}

void sub_100FA6138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100FA616C(void *result, unint64_t a2)
{
  qword_101B12FF0 = 0;
  qword_101B12FF8 = 0;
  qword_101B13000 = 0;
  if (a2)
  {
    if (a2 >> 61) {
      sub_10006A748();
    }
    long long v3 = result;
    unint64_t v4 = sub_10004EF74((uint64_t)&qword_101B13000, a2);
    qword_101B12FF0 = (uint64_t)v4;
    qword_101B12FF8 = (uint64_t)v4;
    qword_101B13000 = (uint64_t)v4 + 8 * v5;
    uint64_t result = memmove(v4, v3, 8 * a2);
    qword_101B12FF8 = (uint64_t)v4 + 8 * a2;
  }
  return result;
}

void sub_100FA61F8(_Unwind_Exception *exception_object)
{
  if (qword_101B12FF0)
  {
    qword_101B12FF8 = qword_101B12FF0;
    operator delete((void *)qword_101B12FF0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FA621C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100FA6250(void *a1, __darwin_time_t *a2)
{
  long long v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = *(void *)(v5 + 576);
        if (v8)
        {
          uint64_t v9 = *(void **)(v8 + 40);
          if (v9)
          {
            if ([v9 count])
            {
              uint64_t v10 = *(void *)(v5 + 576);
              v13.tv_sec = 0;
              *(void *)&v13.tv_usec = 0;
              gettimeofday(&v13, 0);
              *(void *)(v10 + 88) = 1000 * v13.tv_sec + v13.tv_usec / 0x3E8uLL;
            }
          }
        }
        __darwin_time_t v11 = *a2;
        int v12 = (std::__shared_weak_count *)a2[1];
        v13.tv_sec = v11;
        *(void *)&v13.tv_usec = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100F9B8E4(v5, &v13);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100FA6358(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FA6380(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FA63A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FA63B4(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*(void *)a1 + 48));
  unint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_11:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11)
  {
LABEL_7:
    timeval v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v2 + 128));
      uint64_t v15 = *(void *)(v2 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v15;
      __int16 v38 = 2080;
      __int16 v39 = "";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sMissing subscriber controller", buf, 0x2Au);
    }
    char v16 = *(unsigned char *)(a1 + 32);
    v33[0] = 0;
    v33[1] = 0;
    uint64_t v32 = v33;
    sub_100FA6B94(v2, v16, (uint64_t)&v32);
    uint64_t v17 = (void *)v33[0];
    uint64_t v18 = &v32;
    goto LABEL_19;
  }
LABEL_12:
  *(void *)int buf = 0;
  *(_OWORD *)&uint8_t buf[16] = 0u;
  *(void *)&uint8_t buf[8] = &buf[16];
  *(_DWORD *)int buf = *(_DWORD *)(***(void ***)(v2 + 128) + 52);
  *(_DWORD *)&uint8_t buf[4] = 2;
  uint64_t v19 = (char **)sub_100FACFC8(*(uint64_t ***)(a1 + 16), 1u);
  int v31 = 0;
  uint64_t v34 = &v31;
  int v20 = sub_10008CC40((uint64_t **)&buf[8], &v31, (uint64_t)&unk_10144E20E, &v34) + 5;
  if (v20 != (uint64_t **)v19) {
    sub_10006E4A8(v20, *v19, v19[1], v19[1] - *v19);
  }
  uint64_t v21 = (char **)sub_100FACFC8(*(uint64_t ***)(a1 + 16), 2u);
  int v31 = 1;
  uint64_t v34 = &v31;
  long long v22 = sub_10008CC40((uint64_t **)&buf[8], &v31, (uint64_t)&unk_10144E20E, &v34) + 5;
  if (v22 != (uint64_t **)v21) {
    sub_10006E4A8(v22, *v21, v21[1], v21[1] - *v21);
  }
  uint64_t v29 = *(void *)buf;
  sub_10026E7F8(v30, (uint64_t)&buf[8]);
  uint64_t v23 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v23 || (uint64_t v24 = *(void *)(v2 + 8), (v25 = std::__shared_weak_count::lock(v23)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v26 = v25;
  atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = *(unsigned char *)(a1 + 32);
  uint64_t v36 = 0;
  std::string::size_type v28 = operator new(0x28uLL);
  *std::string::size_type v28 = off_101A77DE0;
  v28[1] = v2;
  v28[2] = v24;
  v28[3] = v26;
  *((unsigned char *)v28 + 32) = v27;
  uint64_t v36 = v28;
  (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v11 + 256))(v11, &v29, v35);
  sub_100273F20(v35);
  sub_10026CF54((uint64_t)v30, (void *)v30[1]);
  uint64_t v17 = *(void **)&buf[16];
  uint64_t v18 = &buf[8];
LABEL_19:
  sub_10026CF54((uint64_t)v18, v17);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100FA6744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA67D8(uint64_t a1, uint64_t a2, long long *a3)
{
  xpc_object_t v27 = 0;
  rest::write_rest_value();
  sub_100058DB0(&v25, "/cc/requests/transfer_secure_intent");
  xpc_object_t object = v27;
  xpc_object_t v27 = xpc_null_create();
  long long v15 = *a3;
  char v16 = (std::__shared_weak_count *)*((void *)a3 + 2);
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  char v17 = *((unsigned char *)a3 + 24);
  if (*((char *)a3 + 55) < 0)
  {
    sub_10004FC84(&__p, *((void **)a3 + 4), *((void *)a3 + 5));
  }
  else
  {
    long long __p = a3[2];
    uint64_t v19 = *((void *)a3 + 6);
  }
  unint64_t v4 = (void *)a3 + 9;
  uint64_t v5 = (void *)*((void *)a3 + 9);
  long long v14 = *(long long *)((char *)a3 + 56);
  long long v20 = v14;
  uint64_t v6 = *((void *)a3 + 10);
  uint64_t v21 = v5;
  uint64_t v22 = v6;
  if (v6)
  {
    _OWORD v5[2] = &v21;
    *((void *)a3 + 8) = v4;
    *unint64_t v4 = 0;
    *((void *)a3 + 10) = 0;
  }
  else
  {
    *((void *)&v20 + 1) = &v21;
  }
  char v23 = *((unsigned char *)a3 + 88);
  uint64_t v29 = 0;
  uint64_t v7 = (char *)operator new(0x68uLL);
  *(void *)uint64_t v7 = off_101A78DF0;
  *(_OWORD *)(v7 + 8) = v15;
  *((void *)v7 + 3) = v16;
  v7[32] = v17;
  unsigned int v8 = v7 + 40;
  if (SHIBYTE(v19) < 0)
  {
    sub_10004FC84(v8, (void *)__p, *((unint64_t *)&__p + 1));
    uint64_t v9 = v20;
  }
  else
  {
    *(_OWORD *)unsigned int v8 = __p;
    *((void *)v7 + 7) = v19;
    uint64_t v9 = v14;
  }
  uint64_t v11 = *((void *)&v20 + 1);
  uint64_t v10 = v21;
  *((void *)v7 + 10) = v21;
  char v12 = v7 + 80;
  *((void *)v7 + 8) = v9;
  *((void *)v7 + 9) = v11;
  uint64_t v13 = v22;
  *((void *)v7 + 11) = v22;
  if (v13)
  {
    v10[2] = v12;
    *((void *)&v20 + 1) = &v21;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  else
  {
    *((void *)v7 + 9) = v12;
  }
  v7[96] = v23;
  uint64_t v29 = v7;
  ctu::RestModule::sendRequest();
  sub_10003F600(v28);
  sub_10026CF54((uint64_t)&v20 + 8, v21);
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)__p);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (v26 < 0) {
    operator delete(v25);
  }
  xpc_release(v27);
}

void sub_100FA6A34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  uint64_t v32 = (std::__shared_weak_count *)v29[3];
  if (v32) {
    std::__shared_weak_count::__release_weak(v32);
  }
  operator delete(v29);
  sub_100FA6AE4((uint64_t)&a11);
  xpc_release(object);
  xpc_object_t object = 0;
  if (a29 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v30 - 112));
  _Unwind_Resume(a1);
}

uint64_t sub_100FA6AE4(uint64_t a1)
{
  sub_10026CF54(a1 + 64, *(void **)(a1 + 72));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_100FA6B30(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  long long v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 56) = v3;
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 32) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100FA6B94(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v91 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v91);
  if (*(_DWORD *)(a1 + 172) != 1)
  {
    char v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v25 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v24;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v25;
      LOWORD(v98) = 2080;
      *(void *)((char *)&v98 + 2) = "";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnsupported Authentication Response", buf, 0x2Au);
    }
    goto LABEL_107;
  }
  v90[0] = 0;
  v90[1] = 0;
  xpc_object_t v89 = (uint64_t *)v90;
  uint64_t v7 = (uint64_t *)(a3 + 8);
  uint64_t v6 = *(void *)(a3 + 8);
  if (!v6) {
    goto LABEL_68;
  }
  uint64_t v8 = a3 + 8;
  uint64_t v9 = *(void *)(a3 + 8);
  do
  {
    int v10 = *(_DWORD *)(v9 + 32);
    BOOL v11 = v10 < 5;
    if (v10 >= 5) {
      char v12 = (uint64_t *)v9;
    }
    else {
      char v12 = (uint64_t *)(v9 + 8);
    }
    if (!v11) {
      uint64_t v8 = v9;
    }
    uint64_t v9 = *v12;
  }
  while (*v12);
  if ((uint64_t *)v8 == v7)
  {
    uint64_t v14 = a3 + 8;
  }
  else
  {
    int v13 = *(_DWORD *)(v8 + 32);
    uint64_t v14 = a3 + 8;
    if (v13 <= 5)
    {
      LODWORD(v92.__r_.__value_.__l.__data_) = 5;
      *(void *)int buf = &v92;
      long long v15 = sub_10008CC40((uint64_t **)a3, (int *)&v92, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      buf[0] = 3;
      char v16 = sub_1009F0034(&v89, 3u, buf) + 5;
      if (v16 != v15 + 5) {
        sub_10006E4A8(v16, (char *)v15[5], (char *)v15[6], (char *)v15[6] - (char *)v15[5]);
      }
      sub_10008E4E8(buf, 0x10uLL);
      v92.__r_.__value_.__s.__data_[0] = 11;
      char v17 = sub_1009F0034(&v89, 0xBu, &v92);
      uint64_t v18 = v17[5];
      if (v18)
      {
        v17[6] = v18;
        operator delete(v18);
        v17[5] = 0;
        v17[6] = 0;
        v17[7] = 0;
      }
      *(_OWORD *)(v17 + 5) = *(_OWORD *)buf;
      v17[7] = *(uint64_t **)&buf[16];
      uint64_t v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v21 = *(void *)(a1 + 160);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v20;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v21;
        LOWORD(v98) = 2080;
        *(void *)((char *)&v98 + 2) = "";
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEAP-AKA success", buf, 0x2Au);
      }
      char v22 = 1;
      goto LABEL_35;
    }
  }
  do
  {
    int v26 = *(_DWORD *)(v6 + 32);
    BOOL v27 = v26 < 9;
    if (v26 >= 9) {
      std::string::size_type v28 = (uint64_t *)v6;
    }
    else {
      std::string::size_type v28 = (uint64_t *)(v6 + 8);
    }
    if (!v27) {
      uint64_t v14 = v6;
    }
    uint64_t v6 = *v28;
  }
  while (*v28);
  if ((uint64_t *)v14 == v7 || *(int *)(v14 + 32) > 9)
  {
LABEL_68:
    std::string::size_type v58 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v59 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v60 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v59;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v60;
      LOWORD(v98) = 2080;
      *(void *)((char *)&v98 + 2) = "";
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sEAP-AKA failed", buf, 0x2Au);
    }
    sub_100F94130(a1);
    *(_DWORD *)(a1 + 176) = 0;
    goto LABEL_106;
  }
  LODWORD(v92.__r_.__value_.__l.__data_) = 9;
  *(void *)int buf = &v92;
  uint64_t v29 = sub_10008CC40((uint64_t **)a3, (int *)&v92, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  buf[0] = 4;
  uint64_t v30 = sub_1009F0034(&v89, 4u, buf) + 5;
  if (v30 != v29 + 5) {
    sub_10006E4A8(v30, (char *)v29[5], (char *)v29[6], (char *)v29[6] - (char *)v29[5]);
  }
  *(unsigned char *)(*(void *)(a1 + 736) + 24) = 1;
  int v31 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v33 = *(void *)(a1 + 160);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v33;
    LOWORD(v98) = 2080;
    *(void *)((char *)&v98 + 2) = "";
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEAP-AKA sync fail", buf, 0x2Au);
  }
  char v22 = 4;
LABEL_35:
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v98 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_1010E8BB4((uint64_t)buf, 0, 23, a2, v22, (uint64_t)&v89);
  uint64_t v34 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    std::string::size_type v61 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    sub_1010E99A0((uint64_t)buf, &__p);
    uint64_t v62 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    LODWORD(v92.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v61;
    WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
    std::string::size_type v93 = (std::string::size_type)v62;
    _os_log_debug_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v92, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  memset(&__p, 0, sizeof(__p));
  sub_1010E7AC0(buf, &v92);
  std::string __p = v92;
  uint64_t v35 = v90[0];
  if (v90[0])
  {
    uint64_t v36 = v90;
    do
    {
      uint64_t v37 = v35;
      __int16 v38 = v36;
      unsigned int v39 = *((unsigned __int8 *)v35 + 32);
      uint64_t v40 = v35 + 1;
      if (v39 >= 0xB)
      {
        uint64_t v40 = v37;
        uint64_t v36 = (void **)v37;
      }
      uint64_t v35 = (void *)*v40;
    }
    while (v35);
    if (v36 != v90)
    {
      if (v39 < 0xB) {
        uint64_t v37 = v38;
      }
      if (*((unsigned __int8 *)v37 + 32) <= 0xBu)
      {
        __int16 v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v42 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          std::string::size_type v43 = *(void *)(a1 + 160);
          LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
          *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v42;
          WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
          HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
          std::string::size_type v93 = v43;
          __int16 v94 = 2080;
          uint64_t v95 = "";
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPerforming MAC calculation", (uint8_t *)&v92, 0x2Au);
        }
        uint64_t v44 = *v7;
        if (!*v7) {
          goto LABEL_66;
        }
        uint64_t v45 = a3 + 8;
        uint64_t v46 = *v7;
        do
        {
          int v47 = *(_DWORD *)(v46 + 32);
          BOOL v48 = v47 < 6;
          if (v47 >= 6) {
            uint64_t v49 = (uint64_t *)v46;
          }
          else {
            uint64_t v49 = (uint64_t *)(v46 + 8);
          }
          if (!v48) {
            uint64_t v45 = v46;
          }
          uint64_t v46 = *v49;
        }
        while (*v49);
        if ((uint64_t *)v45 == v7 || *(int *)(v45 + 32) > 6) {
          goto LABEL_66;
        }
        uint64_t v50 = a3 + 8;
        do
        {
          int v51 = *(_DWORD *)(v44 + 32);
          BOOL v52 = v51 < 7;
          if (v51 >= 7) {
            id v53 = (uint64_t *)v44;
          }
          else {
            id v53 = (uint64_t *)(v44 + 8);
          }
          if (!v52) {
            uint64_t v50 = v44;
          }
          uint64_t v44 = *v53;
        }
        while (*v53);
        if ((uint64_t *)v50 == v7 || *(int *)(v50 + 32) >= 8)
        {
LABEL_66:
          uint64_t v54 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v55 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            std::string::size_type v56 = *(void *)(a1 + 160);
            LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
            *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v55;
            WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
            std::string::size_type v93 = v56;
            __int16 v94 = 2080;
            uint64_t v95 = "";
            uint64_t v57 = "#W %s%s%s%sMAC encoding required without necessary values";
LABEL_102:
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v57, (uint8_t *)&v92, 0x2Au);
            goto LABEL_103;
          }
          goto LABEL_103;
        }
        memset(&__str, 0, sizeof(__str));
        int v86 = 6;
        v92.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
        uint64_t v63 = sub_10008CC40((uint64_t **)a3, &v86, (uint64_t)&unk_10144E20E, &v92);
        int v85 = 7;
        v92.__r_.__value_.__r.__words[0] = (std::string::size_type)&v85;
        uint64_t v64 = sub_10008CC40((uint64_t **)a3, &v85, (uint64_t)&unk_10144E20E, &v92);
        sub_10111359C((uint64_t *)(a1 + 184), (uint64_t)&__p, (uint64_t *)v63 + 5, (uint64_t *)v64 + 5, (unint64_t *)&__str);
        long long v65 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
        CFTypeRef v66 = *(NSObject **)(a1 + 40);
        if (__str.__r_.__value_.__r.__words[0] == __str.__r_.__value_.__l.__size_)
        {
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v68 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            std::string::size_type v69 = *(void *)(a1 + 160);
            LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
            *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v68;
            WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
            std::string::size_type v93 = v69;
            __int16 v94 = 2080;
            uint64_t v95 = "";
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sEmpty Mac Data", (uint8_t *)&v92, 0x2Au);
          }
        }
        else
        {
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          {
            std::string::size_type v84 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
            LODWORD(v92.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v84;
            WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(v92.__r_.__value_.__r.__words[2]) = 2048;
            std::string::size_type v93 = __str.__r_.__value_.__l.__size_ - __str.__r_.__value_.__r.__words[0];
            _os_log_debug_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEBUG, "#D %s%sMac Data Size %zu", (uint8_t *)&v92, 0x20u);
          }
          v92.__r_.__value_.__s.__data_[0] = 11;
          uint64_t v67 = (std::string *)(sub_1009F0034(&v89, 0xBu, &v92) + 5);
          if (v67 != &__str) {
            sub_10006E4A8(v67, __str.__r_.__value_.__l.__data_, (char *)__str.__r_.__value_.__l.__size_, __str.__r_.__value_.__l.__size_ - __str.__r_.__value_.__r.__words[0]);
          }
          sub_1010E8BB4((uint64_t)&v92, 0, 23, a2, v22, (uint64_t)&v89);
          sub_100FA7BF4((uint64_t)buf, (uint64_t)&v92);
          v92.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A8C320;
          sub_10026CF54((uint64_t)v96, v96[1]);
          sub_100B63E7C(&v92);
          sub_1010E7AC0(buf, &v92);
          if (__p.__r_.__value_.__r.__words[0]) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = v92;
        }
        if (__str.__r_.__value_.__r.__words[0])
        {
          __str.__r_.__value_.__l.__size_ = __str.__r_.__value_.__r.__words[0];
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if ((void)v65 == *((void *)&v65 + 1)) {
          goto LABEL_103;
        }
      }
    }
  }
  uint64_t v70 = (void *)__p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__r.__words[0] == __p.__r_.__value_.__l.__size_)
  {
    uint64_t v54 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v78 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      std::string::size_type v79 = *(void *)(a1 + 160);
      LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v78;
      WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
      std::string::size_type v93 = v79;
      __int16 v94 = 2080;
      uint64_t v95 = "";
      uint64_t v57 = "#W %s%s%s%sNo Auth Payload to send";
      goto LABEL_102;
    }
    goto LABEL_103;
  }
  id v71 = [objc_alloc((Class)NSData) initWithBytes:__p.__r_.__value_.__r.__words[0] length:__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]];
  uint64_t v72 = v71;
  if (!v71 || ![v71 base64EncodedStringWithOptions:0])
  {
    uint64_t v54 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v76 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      std::string::size_type v77 = *(void *)(a1 + 160);
      LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v76;
      WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
      std::string::size_type v93 = v77;
      __int16 v94 = 2080;
      uint64_t v95 = "";
      uint64_t v57 = "#W %s%s%s%sInvalid result data";
      goto LABEL_102;
    }
LABEL_103:
    if (__p.__r_.__value_.__r.__words[0]) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(void *)int buf = off_101A8C320;
    sub_10026CF54((uint64_t)&v101 + 8, (void *)v102);
    sub_100B63E7C(buf);
LABEL_106:
    sub_10026CF54((uint64_t)&v89, v90[0]);
    goto LABEL_107;
  }
  [v72 base64EncodedStringWithOptions:0];
  memset(&v92, 0, sizeof(v92));
  ctu::cf::assign();
  std::string __str = v92;
  char v73 = HIBYTE(v92.__r_.__value_.__r.__words[2]);
  if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v92.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v92.__r_.__value_.__l.__size_;
  }
  uint64_t v75 = *(NSObject **)(a1 + 40);
  if (size)
  {
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      std::string::size_type v82 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      LODWORD(v92.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v82;
      WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
      std::string::size_type v93 = (std::string::size_type)p_str;
      _os_log_debug_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEBUG, "#D %s%sBase64 postAuth payload: %s", (uint8_t *)&v92, 0x20u);
    }
    std::string::operator=((std::string *)(a1 + 432), &__str);
    char v73 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v80 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    std::string::size_type v81 = *(void *)(a1 + 160);
    LODWORD(v92.__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)v92.__r_.__value_.__r.__words + 4) = v80;
    WORD2(v92.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v92.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(v92.__r_.__value_.__r.__words[2]) = 2080;
    std::string::size_type v93 = v81;
    __int16 v94 = 2080;
    uint64_t v95 = "";
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sError encoding result to base64", (uint8_t *)&v92, 0x2Au);
  }
  if (v73 < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v70) {
    operator delete(v70);
  }
  *(void *)int buf = off_101A8C320;
  sub_10026CF54((uint64_t)&v101 + 8, (void *)v102);
  sub_100B63E7C(buf);
  sub_10026CF54((uint64_t)&v89, v90[0]);
  if (size)
  {
    sub_100F9EE20(a1, 1);
    sub_100FA0BA4(a1, 1);
    goto LABEL_108;
  }
LABEL_107:
  buf[0] = 0;
  uint8_t buf[4] = 0;
  sub_100F9E344(a1, 0, (uint64_t)buf);
  sub_100F937E8(a1);
LABEL_108:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v91);
}

void sub_100FA78D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,char a24,uint64_t a25,uint64_t buf,int a27,__int16 a28,uint64_t a29,__int16 a30,uint64_t a31,__int16 a32,int a33,__int16 a34,__int16 a35,__int16 a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,void *a45,uint64_t a46)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  sub_100FA7C78((uint64_t)&a44);
  sub_10026CF54((uint64_t)&a21, a22);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_100FA7BF4(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  if (a1 != a2)
  {
    sub_10006E4A8((void *)(a1 + 16), *(char **)(a2 + 16), *(char **)(a2 + 24), *(void *)(a2 + 24) - *(void *)(a2 + 16));
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
    sub_10006E4A8((void *)(a1 + 56), *(char **)(a2 + 56), *(char **)(a2 + 64), *(void *)(a2 + 64) - *(void *)(a2 + 56));
    *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
    sub_100FAD4C4((uint64_t **)(a1 + 88), *(uint64_t **)(a2 + 88), (uint64_t *)(a2 + 96));
  }
  return a1;
}

void *sub_100FA7C78(uint64_t a1)
{
  *(void *)a1 = off_101A8C320;
  sub_10026CF54(a1 + 88, *(void **)(a1 + 96));

  return sub_100B63E7C((void *)a1);
}

void sub_100FA7CD0(void *a1, BOOL a2, const std::string *a3)
{
  unint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[5])
      {
        int v10 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v7 + 128));
          uint64_t v12 = *(void *)(v7 + 160);
          uint64_t v13 = asStringBool(a2);
          if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v14 = a3;
          }
          else {
            uint64_t v14 = (const std::string *)a3->__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int buf = 136316418;
          *(void *)&uint8_t buf[4] = v11;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v12;
          __int16 v29 = 2080;
          uint64_t v30 = "";
          __int16 v31 = 2080;
          uint64_t v32 = v13;
          __int16 v33 = 2080;
          uint64_t v34 = v14;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sGBA auth complete with success:%s, response [%s]", buf, 0x3Eu);
        }
        if (*(void *)(v7 + 736))
        {
          if (a2)
          {
            sub_100093B44((std::string *)(v7 + 312), a3);
            long long v15 = *(std::__shared_weak_count **)(v7 + 112);
            if (v15)
            {
              char v16 = std::__shared_weak_count::lock(v15);
              if (v16)
              {
                char v17 = v16;
                uint64_t v18 = *(void *)(v7 + 104);
                if (v18)
                {
                  memset(buf, 0, sizeof(buf));
                  std::string::size_type size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
                  if ((size & 0x80u) != 0) {
                    std::string::size_type size = a3->__r_.__value_.__l.__size_;
                  }
                  if (size) {
                    sub_100093B44((std::string *)buf, a3);
                  }
                  uint64_t v20 = *(std::__shared_weak_count **)(v7 + 16);
                  if (!v20 || (uint64_t v21 = *(void *)(v7 + 8), (v22 = std::__shared_weak_count::lock(v20)) == 0)) {
                    sub_100088B9C();
                  }
                  uint64_t v26 = v21;
                  BOOL v27 = v22;
                  (*(void (**)(uint64_t, uint64_t *, unsigned char *))(*(void *)v18 + 32))(v18, &v26, buf);
                  if (v27) {
                    sub_10004D2C8(v27);
                  }
                  if (buf[24] && (buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                }
                sub_10004D2C8(v17);
              }
            }
            sub_100F9EE20(v7, 1);
            sub_100FA0BA4(v7, 1);
          }
          else
          {
            sub_100F9DEA4(v7, 1);
            buf[0] = 0;
            uint8_t buf[4] = 0;
            sub_100F9E344(v7, 1, (uint64_t)buf);
            sub_100F94130(v7);
            sub_100F937E8(v7);
          }
        }
        else
        {
          char v23 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v24 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v7 + 128));
            uint64_t v25 = *(void *)(v7 + 160);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v24;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v25;
            __int16 v29 = 2080;
            uint64_t v30 = "";
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sGBA auth complete while transaction is already canceled", buf, 0x2Au);
          }
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100FA8018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v18);
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100FA806C(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FA8090(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FA80A0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    (**(void (***)(void **__return_ptr, uint64_t))a1)(&__p, a1);
    uint64_t v5 = (void *)*((void *)__p + 7);
    *(_DWORD *)int buf = 136316162;
    uint64_t v71 = v3;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v4;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2048;
    std::string::size_type v79 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s=|= HttpCommand Driver Info %zu =", buf, 0x34u);
    if (v68) {
      sub_10004D2C8(v68);
    }
  }
  sub_100CEE2EC(a1);
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v8 = *(void *)(a1 + 160);
    uint64_t v9 = (void *)(a1 + 400);
    if (*(char *)(a1 + 423) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    *(_DWORD *)int buf = 136316162;
    uint64_t v71 = v7;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v8;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2082;
    std::string::size_type v79 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Server Address: %{public}s", buf, 0x34u);
  }
  int v10 = *(void **)(a1 + 656);
  if (v10 != (void *)(a1 + 664))
  {
    do
    {
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v13 = *(void *)(a1 + 160);
        uint64_t v14 = sub_100059954(*((_DWORD *)v10 + 8));
        sub_100C8A32C((uint64_t)(v10 + 5), &__p);
        p_p = &__p;
        if (v69 < 0) {
          p_p = __p;
        }
        *(_DWORD *)int buf = 136316418;
        uint64_t v71 = v12;
        __int16 v72 = 2080;
        char v73 = " ";
        __int16 v74 = 2080;
        uint64_t v75 = v13;
        __int16 v76 = 2080;
        std::string::size_type v77 = "";
        __int16 v78 = 2080;
        std::string::size_type v79 = v14;
        __int16 v80 = 2082;
        uint64_t v81 = (uint64_t)p_p;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Alt Server Address: %s: %{public}s", buf, 0x3Eu);
        if (v69 < 0) {
          operator delete(__p);
        }
      }
      char v16 = (void *)v10[1];
      if (v16)
      {
        do
        {
          char v17 = v16;
          char v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          char v17 = (void *)v10[2];
          BOOL v18 = *v17 == (void)v10;
          int v10 = v17;
        }
        while (!v18);
      }
      int v10 = v17;
    }
    while (v17 != (void *)(a1 + 664));
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v21 = *(void *)(a1 + 160);
    uint64_t v66 = *(void *)(*(void *)(a1 + 144) + 96);
    sub_100CE7ECC(&v66, &__p);
    int v22 = v69;
    char v23 = (void **)__p;
    uint64_t v24 = asStringBool(*(unsigned char *)(a1 + 848));
    uint64_t v25 = &__p;
    *(_DWORD *)int buf = 136316418;
    if (v22 < 0) {
      uint64_t v25 = v23;
    }
    uint64_t v71 = v20;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v21;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2082;
    std::string::size_type v79 = v25;
    __int16 v80 = 2080;
    uint64_t v81 = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Transports: [%{public}s], fIsTransportAvailable: %s", buf, 0x3Eu);
    if (v69 < 0) {
      operator delete(__p);
    }
    uint64_t v19 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v27 = *(void *)(a1 + 160);
    uint64_t v28 = asStringBool(*(unsigned char *)(a1 + 568));
    uint64_t v29 = asStringBool(*(unsigned char *)(a1 + 704));
    uint64_t v30 = asStringBool(*(unsigned char *)(a1 + 705));
    uint64_t v31 = asStringBool(*(unsigned char *)(a1 + 768));
    uint64_t v32 = asStringBool(*(unsigned char *)(a1 + 769));
    *(_DWORD *)int buf = 136317186;
    uint64_t v71 = v26;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v27;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2080;
    std::string::size_type v79 = (void *)v28;
    __int16 v80 = 2080;
    uint64_t v81 = v29;
    __int16 v82 = 2080;
    uint64_t v83 = v30;
    __int16 v84 = 2080;
    uint64_t v85 = v31;
    __int16 v86 = 2080;
    uint64_t v87 = v32;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fBBReady: %s, fWifiAvailable: %s, fIPhoneInProximity: %s, fIsInternetDataAvailable: %s, fIsEntitlementDataAvailable: %s", buf, 0x5Cu);
    uint64_t v19 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v34 = *(void *)(a1 + 160);
    if (*(void *)(a1 + 360)) {
      uint64_t v35 = "active";
    }
    else {
      uint64_t v35 = "idle";
    }
    *(_DWORD *)int buf = 136316162;
    uint64_t v71 = v33;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v34;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2080;
    std::string::size_type v79 = v35;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fAutomaticRetryTimer: %s", buf, 0x34u);
  }
  uint64_t v36 = *(void *)(a1 + 576);
  if (v36)
  {
    uint64_t v37 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v39 = *(void *)(a1 + 160);
      *(_DWORD *)int buf = 136315906;
      uint64_t v71 = v38;
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 2080;
      uint64_t v75 = v39;
      __int16 v76 = 2080;
      std::string::size_type v77 = "";
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s-|--Requested query:", buf, 0x2Au);
      uint64_t v36 = *(void *)(a1 + 576);
    }
    sub_100FBBFD8(v36);
  }
  uint64_t v40 = *(void *)(a1 + 600);
  if (v40 != a1 + 592)
  {
    __int16 v41 = 0;
    do
    {
      std::string::size_type v42 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v44 = *(void *)(a1 + 160);
        __int16 v41 = (void *)((char *)v41 + 1);
        *(_DWORD *)int buf = 136316162;
        uint64_t v71 = v43;
        __int16 v72 = 2080;
        char v73 = " ";
        __int16 v74 = 2080;
        uint64_t v75 = v44;
        __int16 v76 = 2080;
        std::string::size_type v77 = "";
        __int16 v78 = 2048;
        std::string::size_type v79 = v41;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s-|--Pending query %zu:", buf, 0x34u);
      }
      sub_100FBBFD8(*(void *)(v40 + 16));
      uint64_t v40 = *(void *)(v40 + 8);
    }
    while (v40 != a1 + 592);
  }
  uint64_t v45 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v46 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v47 = *(void *)(a1 + 160);
    BOOL v48 = *(void **)(a1 + 696);
    *(_DWORD *)int buf = 136316162;
    uint64_t v71 = v46;
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 2080;
    uint64_t v75 = v47;
    __int16 v76 = 2080;
    std::string::size_type v77 = "";
    __int16 v78 = 2048;
    std::string::size_type v79 = v48;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s-|--Action failures: %zu", buf, 0x34u);
  }
  if (*(void *)(a1 + 696))
  {
    uint64_t v49 = *(void **)(a1 + 680);
    if (v49 != (void *)(a1 + 688))
    {
      uint64_t v50 = 0;
      do
      {
        int v51 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v52 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v53 = *(void *)(a1 + 160);
          uint64_t v54 = sub_100C895E0(*((_DWORD *)v49 + 7));
          std::string::size_type v55 = sub_100FB56F4(*((_DWORD *)v49 + 8));
          *(_DWORD *)int buf = 136316674;
          uint64_t v71 = v52;
          __int16 v72 = 2080;
          char v73 = " ";
          __int16 v74 = 2080;
          uint64_t v75 = v53;
          __int16 v76 = 2080;
          std::string::size_type v77 = "";
          __int16 v78 = 2048;
          std::string::size_type v79 = v50;
          __int16 v80 = 2080;
          uint64_t v81 = (uint64_t)v54;
          __int16 v82 = 2080;
          uint64_t v83 = (uint64_t)v55;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s |  %zu) action %s: %s", buf, 0x48u);
          uint64_t v50 = (void *)((char *)v50 + 1);
        }
        std::string::size_type v56 = (void *)v49[1];
        if (v56)
        {
          do
          {
            uint64_t v57 = v56;
            std::string::size_type v56 = (void *)*v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            uint64_t v57 = (void *)v49[2];
            BOOL v18 = *v57 == (void)v49;
            uint64_t v49 = v57;
          }
          while (!v18);
        }
        uint64_t v49 = v57;
      }
      while (v57 != (void *)(a1 + 688));
    }
  }
  if ((*(unsigned char *)(*(void *)(a1 + 144) + 80) & 8) != 0)
  {
    std::string::size_type v58 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v59 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v60 = *(void *)(a1 + 160);
      uint64_t v61 = asStringBool(*(unsigned char *)(a1 + 384));
      *(_DWORD *)int buf = 136316162;
      uint64_t v71 = v59;
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 2080;
      uint64_t v75 = v60;
      __int16 v76 = 2080;
      std::string::size_type v77 = "";
      __int16 v78 = 2080;
      std::string::size_type v79 = (void *)v61;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | UpdatePushToken acknowledged: %s", buf, 0x34u);
    }
  }
  if (*(unsigned char *)(a1 + 504))
  {
    uint64_t v62 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v63 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v64 = (void *)(a1 + 480);
      uint64_t v65 = *(void *)(a1 + 160);
      if (*(char *)(a1 + 503) < 0) {
        uint64_t v64 = (void *)*v64;
      }
      *(_DWORD *)int buf = 136316162;
      uint64_t v71 = v63;
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 2080;
      uint64_t v75 = v65;
      __int16 v76 = 2080;
      std::string::size_type v77 = "";
      __int16 v78 = 2080;
      std::string::size_type v79 = v64;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | nonce: %s", buf, 0x34u);
    }
  }
}

void sub_100FA8ADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA8B00(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    int v5 = 136315906;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    __int16 v11 = 2080;
    uint64_t v12 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sData Support Changed", (uint8_t *)&v5, 0x2Au);
  }
  sub_100F937E8(a1);
}

void sub_100FA8BE4(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 168) = 0;
  uint64_t v4 = *(NSObject **)(a1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v7 = *(void *)(a1 + 160);
      int v10 = 136315906;
      uint64_t v11 = v6;
      __int16 v12 = 2080;
      uint64_t v13 = " ";
      __int16 v14 = 2080;
      uint64_t v15 = v7;
      __int16 v16 = 2080;
      char v17 = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sSubscriber state 'READY'", (uint8_t *)&v10, 0x2Au);
    }
    sub_100CECC5C(a1);
    sub_100F937E8(a1);
  }
  else
  {
    if (v5)
    {
      uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v9 = *(void *)(a1 + 160);
      int v10 = 136315906;
      uint64_t v11 = v8;
      __int16 v12 = 2080;
      uint64_t v13 = " ";
      __int16 v14 = 2080;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      char v17 = "";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sSubscriber state 'not ready' lead to dropping authentication settings", (uint8_t *)&v10, 0x2Au);
    }
    if (*(unsigned char *)(a1 + 336))
    {
      if (*(char *)(a1 + 335) < 0) {
        operator delete(*(void **)(a1 + 312));
      }
      *(unsigned char *)(a1 + 336) = 0;
    }
  }
}

void sub_100FA8D80(uint64_t a1, char a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    int v7 = 136315906;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    int v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    __int16 v13 = 2080;
    __int16 v14 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%shandleIMSInfoReady", (uint8_t *)&v7, 0x2Au);
  }
  if ((a2 & 1) == 0) {
    *(unsigned char *)(a1 + 168) = 0;
  }
  sub_100CECC5C(a1);
  sub_100F937E8(a1);
}

uint64_t sub_100FA8E80(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    if (*((char *)a2 + 23) >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = (uint64_t *)*a2;
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    __int16 v16 = "";
    __int16 v17 = 2080;
    BOOL v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sP-Associated-Uri: %s", (uint8_t *)&v9, 0x34u);
  }
  return 1;
}

void entitlements::CEHTTPDriver::create()
{
}

void sub_100FA90D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FA9130(uint64_t a1, const std::string *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v7 = a2;
    }
    else {
      int v7 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    __int16 v16 = "";
    __int16 v17 = 2080;
    BOOL v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sstoredGBAAuthentication: auth:[%s]", (uint8_t *)&v9, 0x34u);
  }
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (size && !*(unsigned char *)(a1 + 336)) {
    sub_100093B44((std::string *)(a1 + 312), a2);
  }
  sub_100F937E8(a1);
}

uint64_t sub_100FA9264@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 152);
  *a2 = *(void *)(result + 144);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9280(uint64_t a1)
{
  *(void *)a1 = off_101A777D0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA92C4(uint64_t a1)
{
  *(void *)a1 = off_101A777D0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9328@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9344(uint64_t a1)
{
  *(void *)a1 = off_101A77840;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9388(uint64_t a1)
{
  *(void *)a1 = off_101A77840;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA93EC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9408(uint64_t a1)
{
  *(void *)a1 = off_101A778B0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA944C(uint64_t a1)
{
  *(void *)a1 = off_101A778B0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA94B0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA94CC(uint64_t a1)
{
  *(void *)a1 = off_101A77920;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9510(uint64_t a1)
{
  *(void *)a1 = off_101A77920;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9574@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9590(uint64_t a1)
{
  *(void *)a1 = off_101A77990;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA95D4(uint64_t a1)
{
  *(void *)a1 = off_101A77990;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9638@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9654(uint64_t a1)
{
  *(void *)a1 = off_101A77A00;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9698(uint64_t a1)
{
  *(void *)a1 = off_101A77A00;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA96FC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9718(uint64_t a1)
{
  *(void *)a1 = off_101A77A70;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA975C(uint64_t a1)
{
  *(void *)a1 = off_101A77A70;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA97C0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA97DC(uint64_t a1)
{
  *(void *)a1 = off_101A77AE0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9820(uint64_t a1)
{
  *(void *)a1 = off_101A77AE0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9884@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA98A0(uint64_t a1)
{
  *(void *)a1 = off_101A77B50;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA98E4(uint64_t a1)
{
  *(void *)a1 = off_101A77B50;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9948@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9964(uint64_t a1)
{
  *(void *)a1 = off_101A77BC0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA99A8(uint64_t a1)
{
  *(void *)a1 = off_101A77BC0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9A0C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9A28(uint64_t a1)
{
  *(void *)a1 = off_101A77C30;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9A6C(uint64_t a1)
{
  *(void *)a1 = off_101A77C30;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9AD0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9AEC(uint64_t a1)
{
  *(void *)a1 = off_101A77CA0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9B30(uint64_t a1)
{
  *(void *)a1 = off_101A77CA0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9B94@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9BB0(uint64_t a1)
{
  *(void *)a1 = off_101A77D10;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100FA9BF4(uint64_t a1)
{
  *(void *)a1 = off_101A77D10;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_100FA9C58@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FA9C74(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (*(char *)(v2 + 23) < 0) {
    uint64_t v3 = *(void *)(v2 + 8);
  }
  else {
    uint64_t v3 = *(unsigned __int8 *)(v2 + 23);
  }
  BOOL v4 = v3 != 0;
  int v5 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 28) = v5 | 4;
  *(unsigned char *)(a2 + 17) = v4;
  if (*(char *)(v2 + 47) < 0) {
    uint64_t v6 = *(void *)(v2 + 32);
  }
  else {
    uint64_t v6 = *(unsigned __int8 *)(v2 + 47);
  }
  *(unsigned char *)(a2 + 18) = v6 != 0;
  int v7 = *(unsigned __int8 *)(v2 + 48);
  *(_DWORD *)(a2 + 28) = v5 | 0x1C;
  *(_DWORD *)(a2 + 20) = v7;
  return result;
}

void sub_100FA9CD8(void *a1, int a2, _DWORD **a3, uint64_t a4)
{
  int v7 = (uint64_t *)(*(void *)(*(void *)*a1 + 96) + 16 * a2);
  uint64_t v8 = *v7;
  int v9 = (std::__shared_weak_count *)v7[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 40))(v8);
  if (v9) {
    sub_10004D2C8(v9);
  }
  xpc_object_t v20 = xpc_string_create(v10);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  uint64_t v18 = a4;
  uint64_t v19 = "action_type";
  sub_100035E70((uint64_t)&v18, &v20, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_object_t v16 = xpc_int64_create(**a3);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  uint64_t v18 = a4;
  uint64_t v19 = "action_status";
  sub_100035E70((uint64_t)&v18, &v16, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  BOOL v13 = **a3 == 6000
     && (uint64_t v11 = a1[1], *(unsigned char *)(v11 + 4))
     && *(_DWORD *)v11 == 200
     && (uint64_t v12 = a1[2], *(unsigned char *)(v12 + 4))
     && *(_DWORD *)v12 == 0;
  xpc_object_t v14 = xpc_BOOL_create(v13);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  uint64_t v18 = a4;
  uint64_t v19 = "is_action_success";
  sub_100035E70((uint64_t)&v18, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v14);
}

void sub_100FA9ECC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FA9EE4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 168);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000346F8(a1 + 80, *(void **)(a1 + 88));
  sub_10005D0E4(a1 + 56, *(void **)(a1 + 64));
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));
  sub_1000346F8(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void sub_100FA9F60(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(const std::string **)(a1 + 32);
  *(_DWORD *)(a2 + 148) |= 0x80u;
  int v5 = *(std::string **)(a2 + 64);
  if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v5, v4);
  if (*(unsigned char *)(a1 + 68))
  {
    uint64_t v6 = *(int *)(a1 + 64);
    if (v6 <= 3)
    {
      int v7 = dword_1015A3B80[v6];
      *(_DWORD *)(a2 + 148) |= 4u;
      *(_DWORD *)(a2 + 20) = v7;
    }
  }
  if (*(unsigned char *)(a1 + 76))
  {
    int v8 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a2 + 148) |= 2u;
    *(_DWORD *)(a2 + 16) = v8;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    *(_DWORD *)(a2 + 148) |= 0x20u;
    *(void *)(a2 + 56) = v9;
  }
  if (*(unsigned char *)(a1 + 84))
  {
    int v10 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a2 + 148) |= 8u;
    *(_DWORD *)(a2 + 48) = v10;
  }
  uint64_t v11 = **(int ****)(a1 + 56);
  BOOL v13 = *v11;
  uint64_t v12 = (std::__shared_weak_count *)v11[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    int v14 = *v13;
    if (*v13 != 6000 || (xpc_object_t v15 = (unsigned char *)*((void *)v13 + 1)) != 0 && *v15)
    {
      int v16 = *(_DWORD *)(a2 + 36);
      uint64_t v17 = *(int *)(a2 + 32);
      if ((int)v17 >= v16)
      {
        if (v16 == *(_DWORD *)(a2 + 40))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v16 + 1);
          int v16 = *(_DWORD *)(a2 + 36);
        }
        *(_DWORD *)(a2 + 36) = v16 + 1;
        sub_100FAC5FC();
      }
      uint64_t v18 = *(void *)(a2 + 24);
      *(_DWORD *)(a2 + 32) = v17 + 1;
      uint64_t v19 = *(_DWORD **)(v18 + 8 * v17);
      v19[15] |= 3u;
      void v19[2] = 1;
      void v19[3] = v14;
      uint64_t v20 = *((void *)v13 + 1);
      if (v20)
      {
        if ((sub_100022DE8(*((void *)v13 + 1), 5) & 0xFF00000000) != 0)
        {
          int v21 = v19[11];
          uint64_t v22 = (int)v19[10];
          if ((int)v22 >= v21)
          {
            if (v21 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v21 + 1);
              int v21 = v19[11];
            }
            v19[11] = v21 + 1;
            sub_100FAC6D0();
          }
          uint64_t v23 = *((void *)v19 + 4);
          v19[10] = v22 + 1;
          uint64_t v24 = *(_DWORD **)(v23 + 8 * v22);
          int v25 = v24[5];
          v24[5] = v25 | 1;
          v24[2] = 4;
          unint64_t v26 = sub_100C89C88(v20, 5);
          if ((v26 & 0xFF00000000) != 0)
          {
            v24[5] = v25 | 3;
            v24[3] = v26;
          }
        }
        if ((sub_100022DE8(v20, 2) & 0xFF00000000) != 0)
        {
          int v27 = v19[11];
          uint64_t v28 = (int)v19[10];
          if ((int)v28 >= v27)
          {
            if (v27 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v27 + 1);
              int v27 = v19[11];
            }
            v19[11] = v27 + 1;
            sub_100FAC6D0();
          }
          uint64_t v29 = *((void *)v19 + 4);
          v19[10] = v28 + 1;
          uint64_t v30 = *(_DWORD **)(v29 + 8 * v28);
          int v31 = v30[5];
          v30[5] = v31 | 1;
          uint64_t v30[2] = 0;
          unint64_t v32 = sub_100C89C88(v20, 2);
          if ((v32 & 0xFF00000000) != 0)
          {
            v30[5] = v31 | 3;
            uint64_t v30[3] = v32;
          }
        }
        if ((sub_100022DE8(v20, 3) & 0xFF00000000) != 0)
        {
          int v33 = v19[11];
          uint64_t v34 = (int)v19[10];
          if ((int)v34 >= v33)
          {
            if (v33 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v33 + 1);
              int v33 = v19[11];
            }
            v19[11] = v33 + 1;
            sub_100FAC6D0();
          }
          uint64_t v35 = *((void *)v19 + 4);
          v19[10] = v34 + 1;
          uint64_t v36 = *(_DWORD **)(v35 + 8 * v34);
          int v37 = v36[5];
          v36[5] = v37 | 1;
          v36[2] = 1;
          unint64_t v38 = sub_100C89C88(v20, 3);
          if ((v38 & 0xFF00000000) != 0)
          {
            v36[5] = v37 | 3;
            v36[3] = v38;
          }
        }
        if ((sub_100022DE8(v20, 6) & 0xFF00000000) != 0)
        {
          int v39 = v19[11];
          uint64_t v40 = (int)v19[10];
          if ((int)v40 >= v39)
          {
            if (v39 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v39 + 1);
              int v39 = v19[11];
            }
            v19[11] = v39 + 1;
            sub_100FAC6D0();
          }
          uint64_t v41 = *((void *)v19 + 4);
          v19[10] = v40 + 1;
          std::string::size_type v42 = *(_DWORD **)(v41 + 8 * v40);
          int v43 = v42[5];
          v42[5] = v43 | 1;
          v42[2] = 2;
          unint64_t v44 = sub_100C89C88(v20, 6);
          if ((v44 & 0xFF00000000) != 0)
          {
            v42[5] = v43 | 3;
            v42[3] = v44;
          }
        }
        if ((sub_100022DE8(v20, 7) & 0xFF00000000) != 0)
        {
          int v45 = v19[11];
          uint64_t v46 = (int)v19[10];
          if ((int)v46 >= v45)
          {
            if (v45 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v45 + 1);
              int v45 = v19[11];
            }
            v19[11] = v45 + 1;
            sub_100FAC6D0();
          }
          uint64_t v47 = *((void *)v19 + 4);
          v19[10] = v46 + 1;
          BOOL v48 = *(_DWORD **)(v47 + 8 * v46);
          int v49 = v48[5];
          v48[5] = v49 | 1;
          v48[2] = 3;
          unint64_t v50 = sub_100C89C88(v20, 7);
          if ((v50 & 0xFF00000000) != 0)
          {
            v48[5] = v49 | 3;
            v48[3] = v50;
          }
        }
        if ((sub_100022DE8(v20, 8) & 0xFF00000000) != 0)
        {
          int v51 = v19[11];
          uint64_t v52 = (int)v19[10];
          if ((int)v52 >= v51)
          {
            if (v51 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v51 + 1);
              int v51 = v19[11];
            }
            v19[11] = v51 + 1;
            sub_100FAC6D0();
          }
          uint64_t v53 = *((void *)v19 + 4);
          v19[10] = v52 + 1;
          uint64_t v54 = *(_DWORD **)(v53 + 8 * v52);
          int v55 = v54[5];
          v54[5] = v55 | 1;
          v54[2] = 5;
          unint64_t v56 = sub_100C89C88(v20, 8);
          if ((v56 & 0xFF00000000) != 0)
          {
            v54[5] = v55 | 3;
            v54[3] = v56;
          }
        }
        if ((sub_100022DE8(v20, 10) & 0xFF00000000) != 0)
        {
          int v57 = v19[11];
          uint64_t v58 = (int)v19[10];
          if ((int)v58 >= v57)
          {
            if (v57 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v57 + 1);
              int v57 = v19[11];
            }
            v19[11] = v57 + 1;
            sub_100FAC6D0();
          }
          uint64_t v59 = *((void *)v19 + 4);
          v19[10] = v58 + 1;
          uint64_t v60 = *(_DWORD **)(v59 + 8 * v58);
          int v61 = v60[5];
          v60[5] = v61 | 1;
          void v60[2] = 6;
          unint64_t v62 = sub_100C89C88(v20, 10);
          if ((v62 & 0xFF00000000) != 0)
          {
            v60[5] = v61 | 3;
            v60[3] = v62;
          }
        }
        if ((sub_100022DE8(v20, 11) & 0xFF00000000) != 0)
        {
          int v63 = v19[11];
          uint64_t v64 = (int)v19[10];
          if ((int)v64 >= v63)
          {
            if (v63 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v63 + 1);
              int v63 = v19[11];
            }
            v19[11] = v63 + 1;
            sub_100FAC6D0();
          }
          uint64_t v65 = *((void *)v19 + 4);
          v19[10] = v64 + 1;
          uint64_t v66 = *(_DWORD **)(v65 + 8 * v64);
          int v67 = v66[5];
          v66[5] = v67 | 1;
          v66[2] = 7;
          unint64_t v68 = sub_100C89C88(v20, 11);
          if ((v68 & 0xFF00000000) != 0)
          {
            v66[5] = v67 | 3;
            v66[3] = v68;
          }
        }
        if ((sub_100022DE8(v20, 12) & 0xFF00000000) != 0)
        {
          int v69 = v19[11];
          uint64_t v70 = (int)v19[10];
          if ((int)v70 >= v69)
          {
            if (v69 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v69 + 1);
              int v69 = v19[11];
            }
            v19[11] = v69 + 1;
            sub_100FAC6D0();
          }
          uint64_t v71 = *((void *)v19 + 4);
          v19[10] = v70 + 1;
          __int16 v72 = *(_DWORD **)(v71 + 8 * v70);
          int v73 = v72[5];
          v72[5] = v73 | 1;
          v72[2] = 8;
          unint64_t v74 = sub_100C89C88(v20, 12);
          if ((v74 & 0xFF00000000) != 0)
          {
            v72[5] = v73 | 3;
            v72[3] = v74;
          }
        }
        if ((sub_100022DE8(v20, 13) & 0xFF00000000) != 0)
        {
          int v75 = v19[11];
          uint64_t v76 = (int)v19[10];
          if ((int)v76 >= v75)
          {
            if (v75 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v75 + 1);
              int v75 = v19[11];
            }
            v19[11] = v75 + 1;
            sub_100FAC6D0();
          }
          uint64_t v77 = *((void *)v19 + 4);
          v19[10] = v76 + 1;
          __int16 v78 = *(_DWORD **)(v77 + 8 * v76);
          int v79 = v78[5];
          v78[5] = v79 | 1;
          v78[2] = 9;
          unint64_t v80 = sub_100C89C88(v20, 13);
          if ((v80 & 0xFF00000000) != 0)
          {
            v78[5] = v79 | 3;
            v78[3] = v80;
          }
        }
        if ((sub_100022DE8(v20, 14) & 0xFF00000000) != 0)
        {
          int v81 = v19[11];
          uint64_t v82 = (int)v19[10];
          if ((int)v82 >= v81)
          {
            if (v81 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v81 + 1);
              int v81 = v19[11];
            }
            v19[11] = v81 + 1;
            sub_100FAC6D0();
          }
          uint64_t v83 = *((void *)v19 + 4);
          v19[10] = v82 + 1;
          __int16 v84 = *(_DWORD **)(v83 + 8 * v82);
          int v85 = v84[5];
          v84[5] = v85 | 1;
          v84[2] = 10;
          unint64_t v86 = sub_100C89C88(v20, 14);
          if ((v86 & 0xFF00000000) != 0)
          {
            v84[5] = v85 | 3;
            v84[3] = v86;
          }
        }
        if ((sub_100022DE8(v20, 15) & 0xFF00000000) != 0)
        {
          int v87 = v19[11];
          uint64_t v88 = (int)v19[10];
          if ((int)v88 >= v87)
          {
            if (v87 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v87 + 1);
              int v87 = v19[11];
            }
            v19[11] = v87 + 1;
            sub_100FAC6D0();
          }
          uint64_t v89 = *((void *)v19 + 4);
          v19[10] = v88 + 1;
          uint64_t v90 = *(_DWORD **)(v89 + 8 * v88);
          int v91 = v90[5];
          v90[5] = v91 | 1;
          v90[2] = 11;
          unint64_t v92 = sub_100C89C88(v20, 15);
          if ((v92 & 0xFF00000000) != 0)
          {
            v90[5] = v91 | 3;
            v90[3] = v92;
            long long v456 = 0uLL;
            *(void *)&long long v457 = 0;
            sub_1001A0E60((uint64_t)&v456, v20 + 56);
            std::string::size_type v93 = (void *)*((void *)&v456 + 1);
            if (*((void *)&v456 + 1))
            {
              __int16 v94 = (long long *)((char *)&v456 + 8);
              uint64_t v95 = (uint64_t *)*((void *)&v456 + 1);
              do
              {
                unsigned int v96 = v95;
                uint64_t v97 = v94;
                int v98 = *((_DWORD *)v95 + 8);
                if (v98 >= 15) {
                  __int16 v94 = v95;
                }
                else {
                  ++v95;
                }
                uint64_t v95 = (uint64_t *)*v95;
              }
              while (v95);
              if (v94 != (long long *)((char *)&v456 + 8))
              {
                long long v99 = (int *)(v98 >= 15 ? v96 : v97);
                if (v99[8] <= 15)
                {
                  if (v98 < 15) {
                    unsigned int v96 = v97;
                  }
                  long long v100 = (int **)*((void *)v96 + 5);
                  if (v100)
                  {
                    if (*((unsigned char *)v100 + 24))
                    {
                      long long v101 = *v100;
                      v455 = v100[1];
                      if (*v100 != v455)
                      {
                        uint64_t v454 = v20;
                        while (1)
                        {
                          int v102 = *(_DWORD *)(a2 + 132);
                          uint64_t v103 = *(int *)(a2 + 128);
                          if ((int)v103 >= v102)
                          {
                            if (v102 == *(_DWORD *)(a2 + 136))
                            {
                              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 120), v102 + 1);
                              int v102 = *(_DWORD *)(a2 + 132);
                            }
                            *(_DWORD *)(a2 + 132) = v102 + 1;
                            operator new();
                          }
                          uint64_t v104 = *(void *)(a2 + 120);
                          *(_DWORD *)(a2 + 128) = v103 + 1;
                          uint64_t v105 = *(void *)(v104 + 8 * v103);
                          if (!*((unsigned char *)v101 + 4)) {
                            goto LABEL_148;
                          }
                          int v106 = *v101;
                          if (!*v101) {
                            break;
                          }
                          if (v106 == 1)
                          {
                            if (!awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanType_IsValid((awd::metrics *)1, (int)v93))goto LABEL_600; {
LABEL_147:
                            }
                            *(_DWORD *)(v105 + 40) |= 1u;
                            *(_DWORD *)(v105 + 8) = v106;
                          }
LABEL_148:
                          if (*((unsigned char *)v101 + 9))
                          {
                            char v107 = *((unsigned char *)v101 + 8);
                            *(_DWORD *)(v105 + 40) |= 2u;
                            *(unsigned char *)(v105 + 12) = v107;
                          }
                          if (*((unsigned char *)v101 + 16))
                          {
                            int v108 = v101[3];
                            *(_DWORD *)(v105 + 40) |= 4u;
                            *(_DWORD *)(v105 + 32) = v108;
                          }
                          if (*((unsigned char *)v101 + 48))
                          {
                            uint64_t v109 = (int *)*((void *)v101 + 3);
                            uint64_t v110 = (int *)*((void *)v101 + 4);
                            if (v109 != v110)
                            {
                              while (1)
                              {
                                int v111 = *v109;
                                if (*v109 == 1) {
                                  break;
                                }
                                if (!v111)
                                {
                                  if ((awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanSupportedRAT_IsValid(0, (int)v93) & 1) == 0)goto LABEL_340; {
LABEL_159:
                                  }
                                  int v112 = *(_DWORD *)(v105 + 24);
                                  if (v112 == *(_DWORD *)(v105 + 28))
                                  {
                                    sub_1008A4E70(v105 + 16, v112 + 1);
                                    int v112 = *(_DWORD *)(v105 + 24);
                                  }
                                  uint64_t v113 = *(void *)(v105 + 16);
                                  *(_DWORD *)(v105 + 24) = v112 + 1;
                                  *(_DWORD *)(v113 + 4 * v112) = v111;
                                }
                                if (++v109 == v110) {
                                  goto LABEL_163;
                                }
                              }
                              if (!awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanSupportedRAT_IsValid((awd::metrics *)1, (int)v93))LABEL_340:__assert_rtn("add_supportedrats", "CCMetricsCarrierEntitlements.pb.h", 1343, "::awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanSupportedRAT_IsValid(value)"); {
                              goto LABEL_159;
                              }
                            }
                          }
LABEL_163:
                          v101 += 16;
                          if (v101 == v455)
                          {
                            std::string::size_type v93 = (void *)*((void *)&v456 + 1);
                            uint64_t v20 = v454;
                            goto LABEL_165;
                          }
                        }
                        if ((awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanType_IsValid(0, (int)v93) & 1) == 0)LABEL_600:__assert_rtn("set_plan_type", "CCMetricsCarrierEntitlements.pb.h", 1279, "::awd::metrics::CommCenterEntitlementResponse_CommCenter5GEntitlementDetails_CC5GPlanType_IsValid(value)"); {
                        goto LABEL_147;
                        }
                      }
                    }
                  }
                }
              }
            }
LABEL_165:
            sub_10005D0E4((uint64_t)&v456, v93);
          }
        }
        if ((sub_100022DE8(v20, 16) & 0xFF00000000) != 0)
        {
          int v114 = v19[11];
          uint64_t v115 = (int)v19[10];
          if ((int)v115 >= v114)
          {
            if (v114 == v19[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 8), v114 + 1);
              int v114 = v19[11];
            }
            v19[11] = v114 + 1;
            sub_100FAC6D0();
          }
          uint64_t v116 = *((void *)v19 + 4);
          v19[10] = v115 + 1;
          xpc_object_t v117 = *(_DWORD **)(v116 + 8 * v115);
          int v118 = v117[5];
          v117[5] = v118 | 1;
          v117[2] = 12;
          unint64_t v119 = sub_100C89C88(v20, 16);
          if ((v119 & 0xFF00000000) != 0)
          {
            v117[5] = v118 | 3;
            v117[3] = v119;
          }
        }
      }
    }
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v120 = **(void **)(a1 + 56);
  uint64_t v122 = *(void *)(v120 + 16);
  xpc_object_t v121 = *(std::__shared_weak_count **)(v120 + 24);
  if (v121) {
    atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v122)
  {
    int v123 = *(_DWORD *)(a2 + 36);
    uint64_t v124 = *(int *)(a2 + 32);
    if ((int)v124 >= v123)
    {
      if (v123 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v123 + 1);
        int v123 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v123 + 1;
      sub_100FAC5FC();
    }
    uint64_t v125 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v124 + 1;
    xpc_object_t v126 = *(int **)(v125 + 8 * v124);
    int v127 = v126[15];
    v126[2] = 2;
    int v128 = *(_DWORD *)v122;
    v126[15] = v127 | 3;
    v126[3] = v128;
    uint64_t v129 = *(void *)(v122 + 8);
    if (v129)
    {
      v459 = 0;
      long long v457 = 0u;
      long long v458 = 0u;
      long long v456 = 0u;
      sub_1001A0DB0((uint64_t *)&v456, v129);
      sub_1001A0E08((uint64_t *)&v457 + 1, v129 + 24);
      v459 = v126;
      uint64_t v130 = *((void *)&v456 + 1);
      if (*((void *)&v456 + 1))
      {
        uint64_t v131 = (uint64_t *)&v456 + 1;
        do
        {
          xpc_object_t v132 = (uint64_t *)v130;
          xpc_object_t v133 = v131;
          int v134 = *(_DWORD *)(v130 + 28);
          xpc_object_t v135 = (uint64_t *)(v130 + 8);
          if (v134 >= 5)
          {
            xpc_object_t v135 = v132;
            uint64_t v131 = v132;
          }
          uint64_t v130 = *v135;
        }
        while (v130);
        if (v131 != (uint64_t *)((char *)&v456 + 8))
        {
          if (v134 < 5) {
            xpc_object_t v132 = v133;
          }
          if (*((int *)v132 + 7) <= 5)
          {
            int v136 = v126[11];
            uint64_t v137 = v126[10];
            if ((int)v137 >= v136)
            {
              if (v136 == v126[12])
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v126 + 8), v136 + 1);
                int v136 = v126[11];
              }
              v126[11] = v136 + 1;
              sub_100FAC6D0();
            }
            uint64_t v138 = *((void *)v126 + 4);
            v126[10] = v137 + 1;
            uint64_t v139 = *(_DWORD **)(v138 + 8 * v137);
            int v140 = v139[5];
            v139[5] = v140 | 1;
            v139[2] = 4;
            unint64_t v141 = sub_100FAC660((uint64_t)&v456, 5);
            if (HIDWORD(v141))
            {
              v139[5] = v140 | 3;
              v139[3] = v141;
            }
          }
        }
        uint64_t v142 = *((void *)&v456 + 1);
        if (*((void *)&v456 + 1))
        {
          uint64_t v143 = (uint64_t *)&v456 + 1;
          do
          {
            uint64_t v144 = (uint64_t *)v142;
            uint64_t v145 = v143;
            int v146 = *(_DWORD *)(v142 + 28);
            uint64_t v147 = (uint64_t *)(v142 + 8);
            if (v146 >= 2)
            {
              uint64_t v147 = v144;
              uint64_t v143 = v144;
            }
            uint64_t v142 = *v147;
          }
          while (v142);
          if (v143 != (uint64_t *)((char *)&v456 + 8))
          {
            if (v146 < 2) {
              uint64_t v144 = v145;
            }
            if (*((int *)v144 + 7) <= 2)
            {
              long long v148 = v459;
              int v149 = v459[11];
              uint64_t v150 = v459[10];
              if ((int)v150 >= v149)
              {
                if (v149 == v459[12])
                {
                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v149 + 1);
                  int v149 = v148[11];
                }
                v148[11] = v149 + 1;
                sub_100FAC6D0();
              }
              uint64_t v151 = *((void *)v459 + 4);
              v459[10] = v150 + 1;
              uint64_t v152 = *(_DWORD **)(v151 + 8 * v150);
              int v153 = v152[5];
              v152[5] = v153 | 1;
              v152[2] = 0;
              unint64_t v154 = sub_100FAC660((uint64_t)&v456, 2);
              if (HIDWORD(v154))
              {
                v152[5] = v153 | 3;
                v152[3] = v154;
              }
            }
          }
          uint64_t v155 = *((void *)&v456 + 1);
          if (*((void *)&v456 + 1))
          {
            xpc_object_t v156 = (uint64_t *)&v456 + 1;
            do
            {
              xpc_object_t v157 = (uint64_t *)v155;
              uint64_t v158 = v156;
              int v159 = *(_DWORD *)(v155 + 28);
              uint64_t v160 = (uint64_t *)(v155 + 8);
              if (v159 >= 3)
              {
                uint64_t v160 = v157;
                xpc_object_t v156 = v157;
              }
              uint64_t v155 = *v160;
            }
            while (v155);
            if (v156 != (uint64_t *)((char *)&v456 + 8))
            {
              if (v159 < 3) {
                xpc_object_t v157 = v158;
              }
              if (*((int *)v157 + 7) <= 3)
              {
                uint64_t v161 = v459;
                int v162 = v459[11];
                uint64_t v163 = v459[10];
                if ((int)v163 >= v162)
                {
                  if (v162 == v459[12])
                  {
                    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v162 + 1);
                    int v162 = v161[11];
                  }
                  v161[11] = v162 + 1;
                  sub_100FAC6D0();
                }
                uint64_t v164 = *((void *)v459 + 4);
                v459[10] = v163 + 1;
                uint64_t v165 = *(_DWORD **)(v164 + 8 * v163);
                int v166 = v165[5];
                v165[5] = v166 | 1;
                v165[2] = 1;
                unint64_t v167 = sub_100FAC660((uint64_t)&v456, 3);
                if (HIDWORD(v167))
                {
                  v165[5] = v166 | 3;
                  v165[3] = v167;
                }
              }
            }
            uint64_t v168 = *((void *)&v456 + 1);
            if (*((void *)&v456 + 1))
            {
              CFTypeID v169 = (uint64_t *)&v456 + 1;
              do
              {
                CFArrayRef v170 = (uint64_t *)v168;
                std::string::size_type v171 = v169;
                int v172 = *(_DWORD *)(v168 + 28);
                xpc_object_t v173 = (uint64_t *)(v168 + 8);
                if (v172 >= 6)
                {
                  xpc_object_t v173 = v170;
                  CFTypeID v169 = v170;
                }
                uint64_t v168 = *v173;
              }
              while (v168);
              if (v169 != (uint64_t *)((char *)&v456 + 8))
              {
                if (v172 < 6) {
                  CFArrayRef v170 = v171;
                }
                if (*((int *)v170 + 7) <= 6)
                {
                  xpc_object_t v174 = v459;
                  int v175 = v459[11];
                  uint64_t v176 = v459[10];
                  if ((int)v176 >= v175)
                  {
                    if (v175 == v459[12])
                    {
                      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v175 + 1);
                      int v175 = v174[11];
                    }
                    v174[11] = v175 + 1;
                    sub_100FAC6D0();
                  }
                  uint64_t v177 = *((void *)v459 + 4);
                  v459[10] = v176 + 1;
                  std::string::size_type v178 = *(_DWORD **)(v177 + 8 * v176);
                  int v179 = v178[5];
                  v178[5] = v179 | 1;
                  v178[2] = 2;
                  unint64_t v180 = sub_100FAC660((uint64_t)&v456, 6);
                  if (HIDWORD(v180))
                  {
                    v178[5] = v179 | 3;
                    v178[3] = v180;
                  }
                }
              }
              uint64_t v181 = *((void *)&v456 + 1);
              if (*((void *)&v456 + 1))
              {
                long long v182 = (uint64_t *)&v456 + 1;
                do
                {
                  uint64_t v183 = (uint64_t *)v181;
                  char v184 = v182;
                  int v185 = *(_DWORD *)(v181 + 28);
                  id v186 = (uint64_t *)(v181 + 8);
                  if (v185 >= 7)
                  {
                    id v186 = v183;
                    long long v182 = v183;
                  }
                  uint64_t v181 = *v186;
                }
                while (v181);
                if (v182 != (uint64_t *)((char *)&v456 + 8))
                {
                  if (v185 < 7) {
                    uint64_t v183 = v184;
                  }
                  if (*((int *)v183 + 7) <= 7)
                  {
                    unint64_t v187 = v459;
                    int v188 = v459[11];
                    uint64_t v189 = v459[10];
                    if ((int)v189 >= v188)
                    {
                      if (v188 == v459[12])
                      {
                        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v188 + 1);
                        int v188 = v187[11];
                      }
                      v187[11] = v188 + 1;
                      sub_100FAC6D0();
                    }
                    uint64_t v190 = *((void *)v459 + 4);
                    v459[10] = v189 + 1;
                    uint64_t v191 = *(_DWORD **)(v190 + 8 * v189);
                    int v192 = v191[5];
                    v191[5] = v192 | 1;
                    v191[2] = 3;
                    unint64_t v193 = sub_100FAC660((uint64_t)&v456, 7);
                    if (HIDWORD(v193))
                    {
                      v191[5] = v192 | 3;
                      v191[3] = v193;
                    }
                  }
                }
                uint64_t v194 = *((void *)&v456 + 1);
                if (*((void *)&v456 + 1))
                {
                  v195 = (uint64_t *)&v456 + 1;
                  do
                  {
                    uint64_t v196 = (uint64_t *)v194;
                    char v197 = v195;
                    int v198 = *(_DWORD *)(v194 + 28);
                    v199 = (uint64_t *)(v194 + 8);
                    if (v198 >= 8)
                    {
                      v199 = v196;
                      v195 = v196;
                    }
                    uint64_t v194 = *v199;
                  }
                  while (v194);
                  if (v195 != (uint64_t *)((char *)&v456 + 8))
                  {
                    if (v198 < 8) {
                      uint64_t v196 = v197;
                    }
                    if (*((int *)v196 + 7) <= 8)
                    {
                      uint64_t v200 = v459;
                      int v201 = v459[11];
                      uint64_t v202 = v459[10];
                      if ((int)v202 >= v201)
                      {
                        if (v201 == v459[12])
                        {
                          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v201 + 1);
                          int v201 = v200[11];
                        }
                        v200[11] = v201 + 1;
                        sub_100FAC6D0();
                      }
                      uint64_t v203 = *((void *)v459 + 4);
                      v459[10] = v202 + 1;
                      BOOL v204 = *(_DWORD **)(v203 + 8 * v202);
                      int v205 = v204[5];
                      v204[5] = v205 | 1;
                      v204[2] = 5;
                      unint64_t v206 = sub_100FAC660((uint64_t)&v456, 8);
                      if (HIDWORD(v206))
                      {
                        v204[5] = v205 | 3;
                        v204[3] = v206;
                      }
                    }
                  }
                  uint64_t v207 = *((void *)&v456 + 1);
                  if (*((void *)&v456 + 1))
                  {
                    CFNumberRef v208 = (uint64_t *)&v456 + 1;
                    do
                    {
                      uint64_t v209 = (uint64_t *)v207;
                      v210 = v208;
                      int v211 = *(_DWORD *)(v207 + 28);
                      v212 = (uint64_t *)(v207 + 8);
                      if (v211 >= 10)
                      {
                        v212 = v209;
                        CFNumberRef v208 = v209;
                      }
                      uint64_t v207 = *v212;
                    }
                    while (v207);
                    if (v208 != (uint64_t *)((char *)&v456 + 8))
                    {
                      if (v211 < 10) {
                        uint64_t v209 = v210;
                      }
                      if (*((int *)v209 + 7) <= 10)
                      {
                        uint64_t v213 = v459;
                        int v214 = v459[11];
                        uint64_t v215 = v459[10];
                        if ((int)v215 >= v214)
                        {
                          if (v214 == v459[12])
                          {
                            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v214 + 1);
                            int v214 = v213[11];
                          }
                          v213[11] = v214 + 1;
                          sub_100FAC6D0();
                        }
                        uint64_t v216 = *((void *)v459 + 4);
                        v459[10] = v215 + 1;
                        v217 = *(_DWORD **)(v216 + 8 * v215);
                        int v218 = v217[5];
                        v217[5] = v218 | 1;
                        v217[2] = 6;
                        unint64_t v219 = sub_100FAC660((uint64_t)&v456, 10);
                        if (HIDWORD(v219))
                        {
                          v217[5] = v218 | 3;
                          v217[3] = v219;
                        }
                      }
                    }
                    uint64_t v220 = *((void *)&v456 + 1);
                    if (*((void *)&v456 + 1))
                    {
                      unint64_t v221 = (uint64_t *)&v456 + 1;
                      do
                      {
                        v222 = (uint64_t *)v220;
                        CFIndex v223 = v221;
                        int v224 = *(_DWORD *)(v220 + 28);
                        v225 = (uint64_t *)(v220 + 8);
                        if (v224 >= 11)
                        {
                          v225 = v222;
                          unint64_t v221 = v222;
                        }
                        uint64_t v220 = *v225;
                      }
                      while (v220);
                      if (v221 != (uint64_t *)((char *)&v456 + 8))
                      {
                        if (v224 < 11) {
                          v222 = v223;
                        }
                        if (*((int *)v222 + 7) <= 11)
                        {
                          CFTypeID v226 = v459;
                          int v227 = v459[11];
                          uint64_t v228 = v459[10];
                          if ((int)v228 >= v227)
                          {
                            if (v227 == v459[12])
                            {
                              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v227 + 1);
                              int v227 = v226[11];
                            }
                            v226[11] = v227 + 1;
                            sub_100FAC6D0();
                          }
                          uint64_t v229 = *((void *)v459 + 4);
                          v459[10] = v228 + 1;
                          v230 = *(_DWORD **)(v229 + 8 * v228);
                          int v231 = v230[5];
                          v230[5] = v231 | 1;
                          v230[2] = 7;
                          unint64_t v232 = sub_100FAC660((uint64_t)&v456, 11);
                          if (HIDWORD(v232))
                          {
                            v230[5] = v231 | 3;
                            v230[3] = v232;
                          }
                        }
                      }
                      uint64_t v233 = *((void *)&v456 + 1);
                      if (*((void *)&v456 + 1))
                      {
                        uint64_t v234 = (uint64_t *)&v456 + 1;
                        do
                        {
                          unsigned int v235 = (uint64_t *)v233;
                          long long v236 = v234;
                          int v237 = *(_DWORD *)(v233 + 28);
                          uint64_t v238 = (uint64_t *)(v233 + 8);
                          if (v237 >= 12)
                          {
                            uint64_t v238 = v235;
                            uint64_t v234 = v235;
                          }
                          uint64_t v233 = *v238;
                        }
                        while (v233);
                        if (v234 != (uint64_t *)((char *)&v456 + 8))
                        {
                          if (v237 < 12) {
                            unsigned int v235 = v236;
                          }
                          if (*((int *)v235 + 7) <= 12)
                          {
                            char v239 = v459;
                            int v240 = v459[11];
                            uint64_t v241 = v459[10];
                            if ((int)v241 >= v240)
                            {
                              if (v240 == v459[12])
                              {
                                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v240 + 1);
                                int v240 = v239[11];
                              }
                              v239[11] = v240 + 1;
                              sub_100FAC6D0();
                            }
                            uint64_t v242 = *((void *)v459 + 4);
                            v459[10] = v241 + 1;
                            long long v243 = *(_DWORD **)(v242 + 8 * v241);
                            int v244 = v243[5];
                            v243[5] = v244 | 1;
                            v243[2] = 8;
                            unint64_t v245 = sub_100FAC660((uint64_t)&v456, 12);
                            if (HIDWORD(v245))
                            {
                              v243[5] = v244 | 3;
                              v243[3] = v245;
                            }
                          }
                        }
                        uint64_t v246 = *((void *)&v456 + 1);
                        if (*((void *)&v456 + 1))
                        {
                          uint64_t v247 = (uint64_t *)&v456 + 1;
                          do
                          {
                            uint64_t v248 = (uint64_t *)v246;
                            uint64_t v249 = v247;
                            int v250 = *(_DWORD *)(v246 + 28);
                            uint64_t v251 = (uint64_t *)(v246 + 8);
                            if (v250 >= 13)
                            {
                              uint64_t v251 = v248;
                              uint64_t v247 = v248;
                            }
                            uint64_t v246 = *v251;
                          }
                          while (v246);
                          if (v247 != (uint64_t *)((char *)&v456 + 8))
                          {
                            if (v250 < 13) {
                              uint64_t v248 = v249;
                            }
                            if (*((int *)v248 + 7) <= 13)
                            {
                              std::string::size_type v252 = v459;
                              int v253 = v459[11];
                              uint64_t v254 = v459[10];
                              if ((int)v254 >= v253)
                              {
                                if (v253 == v459[12])
                                {
                                  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v253 + 1);
                                  int v253 = v252[11];
                                }
                                v252[11] = v253 + 1;
                                sub_100FAC6D0();
                              }
                              uint64_t v255 = *((void *)v459 + 4);
                              v459[10] = v254 + 1;
                              BOOL v256 = *(_DWORD **)(v255 + 8 * v254);
                              int v257 = v256[5];
                              v256[5] = v257 | 1;
                              v256[2] = 9;
                              unint64_t v258 = sub_100FAC660((uint64_t)&v456, 13);
                              if (HIDWORD(v258))
                              {
                                v256[5] = v257 | 3;
                                v256[3] = v258;
                              }
                            }
                          }
                          uint64_t v259 = *((void *)&v456 + 1);
                          if (*((void *)&v456 + 1))
                          {
                            uint64_t v260 = (uint64_t *)&v456 + 1;
                            do
                            {
                              v261 = (uint64_t *)v259;
                              uint64_t v262 = v260;
                              int v263 = *(_DWORD *)(v259 + 28);
                              uint64_t v264 = (uint64_t *)(v259 + 8);
                              if (v263 >= 14)
                              {
                                uint64_t v264 = v261;
                                uint64_t v260 = v261;
                              }
                              uint64_t v259 = *v264;
                            }
                            while (v259);
                            if (v260 != (uint64_t *)((char *)&v456 + 8))
                            {
                              if (v263 < 14) {
                                v261 = v262;
                              }
                              if (*((int *)v261 + 7) <= 14)
                              {
                                v265 = v459;
                                int v266 = v459[11];
                                uint64_t v267 = v459[10];
                                if ((int)v267 >= v266)
                                {
                                  if (v266 == v459[12])
                                  {
                                    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v266 + 1);
                                    int v266 = v265[11];
                                  }
                                  v265[11] = v266 + 1;
                                  sub_100FAC6D0();
                                }
                                uint64_t v268 = *((void *)v459 + 4);
                                v459[10] = v267 + 1;
                                std::string v269 = *(_DWORD **)(v268 + 8 * v267);
                                int v270 = v269[5];
                                v269[5] = v270 | 1;
                                v269[2] = 10;
                                unint64_t v271 = sub_100FAC660((uint64_t)&v456, 14);
                                if (HIDWORD(v271))
                                {
                                  v269[5] = v270 | 3;
                                  v269[3] = v271;
                                }
                              }
                            }
                            uint64_t v272 = *((void *)&v456 + 1);
                            if (*((void *)&v456 + 1))
                            {
                              std::string v273 = (uint64_t *)&v456 + 1;
                              do
                              {
                                v274 = (uint64_t *)v272;
                                v275 = v273;
                                int v276 = *(_DWORD *)(v272 + 28);
                                char v277 = (uint64_t *)(v272 + 8);
                                if (v276 >= 15)
                                {
                                  char v277 = v274;
                                  std::string v273 = v274;
                                }
                                uint64_t v272 = *v277;
                              }
                              while (v272);
                              if (v273 != (uint64_t *)((char *)&v456 + 8))
                              {
                                if (v276 < 15) {
                                  v274 = v275;
                                }
                                if (*((int *)v274 + 7) <= 15)
                                {
                                  v278 = v459;
                                  int v279 = v459[11];
                                  uint64_t v280 = v459[10];
                                  if ((int)v280 >= v279)
                                  {
                                    if (v279 == v459[12])
                                    {
                                      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v279 + 1);
                                      int v279 = v278[11];
                                    }
                                    v278[11] = v279 + 1;
                                    sub_100FAC6D0();
                                  }
                                  uint64_t v281 = *((void *)v459 + 4);
                                  v459[10] = v280 + 1;
                                  v282 = *(_DWORD **)(v281 + 8 * v280);
                                  int v283 = v282[5];
                                  v282[5] = v283 | 1;
                                  v282[2] = 11;
                                  unint64_t v284 = sub_100FAC660((uint64_t)&v456, 15);
                                  if (HIDWORD(v284))
                                  {
                                    v282[5] = v283 | 3;
                                    v282[3] = v284;
                                  }
                                }
                              }
                              uint64_t v285 = *((void *)&v456 + 1);
                              if (*((void *)&v456 + 1))
                              {
                                std::string v286 = (uint64_t *)&v456 + 1;
                                do
                                {
                                  std::string::size_type v287 = (uint64_t *)v285;
                                  v288 = v286;
                                  int v289 = *(_DWORD *)(v285 + 28);
                                  v290 = (uint64_t *)(v285 + 8);
                                  if (v289 >= 16)
                                  {
                                    v290 = v287;
                                    std::string v286 = v287;
                                  }
                                  uint64_t v285 = *v290;
                                }
                                while (v285);
                                if (v286 != (uint64_t *)((char *)&v456 + 8))
                                {
                                  if (v289 < 16) {
                                    std::string::size_type v287 = v288;
                                  }
                                  if (*((int *)v287 + 7) <= 16)
                                  {
                                    v291 = v459;
                                    int v292 = v459[11];
                                    uint64_t v293 = v459[10];
                                    if ((int)v293 >= v292)
                                    {
                                      if (v292 == v459[12])
                                      {
                                        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v459 + 8), v292 + 1);
                                        int v292 = v291[11];
                                      }
                                      v291[11] = v292 + 1;
                                      sub_100FAC6D0();
                                    }
                                    uint64_t v294 = *((void *)v459 + 4);
                                    v459[10] = v293 + 1;
                                    v295 = *(_DWORD **)(v294 + 8 * v293);
                                    int v296 = v295[5];
                                    v295[5] = v296 | 1;
                                    v295[2] = 12;
                                    unint64_t v297 = sub_100FAC660((uint64_t)&v456, 16);
                                    if (HIDWORD(v297))
                                    {
                                      v295[5] = v296 | 3;
                                      v295[3] = v297;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      sub_1000346F8((uint64_t)&v457 + 8, (void *)v458);
      sub_1000346F8((uint64_t)&v456, *((void **)&v456 + 1));
    }
  }
  if (v121) {
    sub_10004D2C8(v121);
  }
  uint64_t v298 = **(void **)(a1 + 56);
  v300 = *(int **)(v298 + 208);
  v299 = *(std::__shared_weak_count **)(v298 + 216);
  if (v299) {
    atomic_fetch_add_explicit(&v299->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v300)
  {
    int v301 = *(_DWORD *)(a2 + 36);
    uint64_t v302 = *(int *)(a2 + 32);
    if ((int)v302 >= v301)
    {
      if (v301 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v301 + 1);
        int v301 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v301 + 1;
      sub_100FAC5FC();
    }
    uint64_t v303 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v302 + 1;
    std::string v304 = *(_DWORD **)(v303 + 8 * v302);
    LODWORD(v303) = v304[15];
    v304[2] = 6;
    int v305 = *v300;
    v304[15] = v303 | 3;
    v304[3] = v305;
  }
  if (v299) {
    sub_10004D2C8(v299);
  }
  uint64_t v306 = **(void **)(a1 + 56);
  v308 = *(int **)(v306 + 176);
  v307 = *(std::__shared_weak_count **)(v306 + 184);
  if (v307) {
    atomic_fetch_add_explicit(&v307->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v308)
  {
    int v309 = *(_DWORD *)(a2 + 36);
    uint64_t v310 = *(int *)(a2 + 32);
    if ((int)v310 >= v309)
    {
      if (v309 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v309 + 1);
        int v309 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v309 + 1;
      sub_100FAC5FC();
    }
    uint64_t v311 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v310 + 1;
    v312 = *(_DWORD **)(v311 + 8 * v310);
    LODWORD(v311) = v312[15];
    v312[2] = 9;
    int v313 = *v308;
    v312[15] = v311 | 3;
    v312[3] = v313;
  }
  if (v307) {
    sub_10004D2C8(v307);
  }
  uint64_t v314 = **(void **)(a1 + 56);
  v316 = *(int **)(v314 + 448);
  v315 = *(std::__shared_weak_count **)(v314 + 456);
  if (v315) {
    atomic_fetch_add_explicit(&v315->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v316)
  {
    int v317 = *(_DWORD *)(a2 + 36);
    uint64_t v318 = *(int *)(a2 + 32);
    if ((int)v318 >= v317)
    {
      if (v317 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v317 + 1);
        int v317 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v317 + 1;
      sub_100FAC5FC();
    }
    uint64_t v319 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v318 + 1;
    v320 = *(_DWORD **)(v319 + 8 * v318);
    int v321 = v320[15];
    v320[2] = 32;
    int v322 = *v316;
    v320[15] = v321 | 3;
    v320[3] = v322;
    if (v322 == 6000)
    {
      uint64_t v323 = *((void *)v316 + 1);
      if (v323)
      {
        if (*(unsigned char *)(v323 + 32))
        {
          *(_DWORD *)(a2 + 148) |= 0x40u;
          *(unsigned char *)(a2 + 52) = 1;
        }
      }
    }
  }
  if (v315) {
    sub_10004D2C8(v315);
  }
  uint64_t v324 = **(void **)(a1 + 56);
  v326 = *(int **)(v324 + 464);
  v325 = *(std::__shared_weak_count **)(v324 + 472);
  if (v325) {
    atomic_fetch_add_explicit(&v325->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v326)
  {
    int v327 = *(_DWORD *)(a2 + 36);
    uint64_t v328 = *(int *)(a2 + 32);
    if ((int)v328 >= v327)
    {
      if (v327 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v327 + 1);
        int v327 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v327 + 1;
      sub_100FAC5FC();
    }
    uint64_t v329 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v328 + 1;
    v330 = *(_DWORD **)(v329 + 8 * v328);
    int v331 = v330[15];
    v330[2] = 12;
    int v332 = *v326;
    v330[15] = v331 | 3;
    v330[3] = v332;
    if (v332 == 6000)
    {
      uint64_t v333 = *((void *)v326 + 1);
      if (v333)
      {
        if (*(unsigned char *)(v333 + 32))
        {
          *(_DWORD *)(a2 + 148) |= 0x40u;
          *(unsigned char *)(a2 + 52) = 1;
        }
      }
    }
  }
  if (v325) {
    sub_10004D2C8(v325);
  }
  uint64_t v334 = **(void **)(a1 + 56);
  v336 = *(int **)(v334 + 192);
  v335 = *(std::__shared_weak_count **)(v334 + 200);
  if (v335) {
    atomic_fetch_add_explicit(&v335->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v336)
  {
    int v337 = *(_DWORD *)(a2 + 36);
    uint64_t v338 = *(int *)(a2 + 32);
    if ((int)v338 >= v337)
    {
      if (v337 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v337 + 1);
        int v337 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v337 + 1;
      sub_100FAC5FC();
    }
    uint64_t v339 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v338 + 1;
    v340 = *(_DWORD **)(v339 + 8 * v338);
    LODWORD(v339) = v340[15];
    v340[2] = 10;
    int v341 = *v336;
    v340[15] = v339 | 3;
    v340[3] = v341;
  }
  if (v335) {
    sub_10004D2C8(v335);
  }
  uint64_t v342 = **(void **)(a1 + 56);
  v344 = *(int **)(v342 + 32);
  v343 = *(std::__shared_weak_count **)(v342 + 40);
  if (v343) {
    atomic_fetch_add_explicit(&v343->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v344)
  {
    int v345 = *(_DWORD *)(a2 + 36);
    uint64_t v346 = *(int *)(a2 + 32);
    if ((int)v346 >= v345)
    {
      if (v345 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v345 + 1);
        int v345 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v345 + 1;
      sub_100FAC5FC();
    }
    uint64_t v347 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v346 + 1;
    v348 = *(_DWORD **)(v347 + 8 * v346);
    int v349 = v348[15];
    v348[2] = 3;
    int v350 = *v344;
    v348[15] = v349 | 3;
    v348[3] = v350;
    uint64_t v351 = *((void *)v344 + 1);
    if (v351)
    {
      uint64_t v352 = *(void *)(v351 + 8);
      if (v352)
      {
        uint64_t v353 = v351 + 8;
        do
        {
          int v354 = *(_DWORD *)(v352 + 32);
          BOOL v355 = v354 < 8;
          if (v354 >= 8) {
            v356 = (uint64_t *)v352;
          }
          else {
            v356 = (uint64_t *)(v352 + 8);
          }
          if (!v355) {
            uint64_t v353 = v352;
          }
          uint64_t v352 = *v356;
        }
        while (*v356);
        if (v353 != v351 + 8 && *(int *)(v353 + 32) <= 8)
        {
          int v357 = v348[11];
          uint64_t v358 = (int)v348[10];
          if ((int)v358 >= v357)
          {
            if (v357 == v348[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v348 + 8), v357 + 1);
              int v357 = v348[11];
            }
            v348[11] = v357 + 1;
            sub_100FAC6D0();
          }
          uint64_t v359 = *((void *)v348 + 4);
          v348[10] = v358 + 1;
          v360 = *(_DWORD **)(v359 + 8 * v358);
          int v361 = v360[5];
          v360[5] = v361 | 1;
          v360[2] = 5;
          uint64_t v364 = *(void *)(v351 + 32);
          uint64_t v362 = v351 + 32;
          uint64_t v363 = v364;
          if (v364)
          {
            uint64_t v365 = v362;
            do
            {
              int v366 = *(_DWORD *)(v363 + 28);
              BOOL v367 = v366 < 8;
              if (v366 >= 8) {
                v368 = (uint64_t *)v363;
              }
              else {
                v368 = (uint64_t *)(v363 + 8);
              }
              if (!v367) {
                uint64_t v365 = v363;
              }
              uint64_t v363 = *v368;
            }
            while (*v368);
            if (v365 != v362 && *(int *)(v365 + 28) <= 8)
            {
              int v369 = *(_DWORD *)(v365 + 32);
              v360[5] = v361 | 3;
              v360[3] = v369;
            }
          }
        }
      }
    }
  }
  if (v343) {
    sub_10004D2C8(v343);
  }
  uint64_t v370 = **(void **)(a1 + 56);
  v372 = *(int **)(v370 + 48);
  v371 = *(std::__shared_weak_count **)(v370 + 56);
  if (v371) {
    atomic_fetch_add_explicit(&v371->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v372)
  {
    int v373 = *(_DWORD *)(a2 + 36);
    uint64_t v374 = *(int *)(a2 + 32);
    if ((int)v374 >= v373)
    {
      if (v373 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v373 + 1);
        int v373 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v373 + 1;
      sub_100FAC5FC();
    }
    uint64_t v375 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v374 + 1;
    v376 = *(_DWORD **)(v375 + 8 * v374);
    int v377 = v376[15];
    v376[2] = 4;
    int v378 = *v372;
    v376[15] = v377 | 3;
    v376[3] = v378;
    uint64_t v379 = *((void *)v372 + 1);
    if (v379)
    {
      uint64_t v380 = *(void *)(v379 + 8);
      if (v380)
      {
        uint64_t v381 = v379 + 8;
        do
        {
          int v382 = *(_DWORD *)(v380 + 32);
          BOOL v383 = v382 < 8;
          if (v382 >= 8) {
            v384 = (uint64_t *)v380;
          }
          else {
            v384 = (uint64_t *)(v380 + 8);
          }
          if (!v383) {
            uint64_t v381 = v380;
          }
          uint64_t v380 = *v384;
        }
        while (*v384);
        if (v381 != v379 + 8 && *(int *)(v381 + 32) <= 8)
        {
          int v385 = v376[11];
          uint64_t v386 = (int)v376[10];
          if ((int)v386 >= v385)
          {
            if (v385 == v376[12])
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v376 + 8), v385 + 1);
              int v385 = v376[11];
            }
            v376[11] = v385 + 1;
            sub_100FAC6D0();
          }
          uint64_t v387 = *((void *)v376 + 4);
          v376[10] = v386 + 1;
          v388 = *(_DWORD **)(v387 + 8 * v386);
          int v389 = v388[5];
          v388[5] = v389 | 1;
          v388[2] = 5;
          uint64_t v392 = *(void *)(v379 + 32);
          uint64_t v390 = v379 + 32;
          uint64_t v391 = v392;
          if (v392)
          {
            uint64_t v393 = v390;
            do
            {
              int v394 = *(_DWORD *)(v391 + 28);
              BOOL v395 = v394 < 8;
              if (v394 >= 8) {
                v396 = (uint64_t *)v391;
              }
              else {
                v396 = (uint64_t *)(v391 + 8);
              }
              if (!v395) {
                uint64_t v393 = v391;
              }
              uint64_t v391 = *v396;
            }
            while (*v396);
            if (v393 != v390 && *(int *)(v393 + 28) <= 8)
            {
              int v397 = *(_DWORD *)(v393 + 32);
              v388[5] = v389 | 3;
              v388[3] = v397;
            }
          }
        }
      }
    }
  }
  if (v371) {
    sub_10004D2C8(v371);
  }
  uint64_t v398 = **(void **)(a1 + 56);
  v400 = *(int **)(v398 + 64);
  v399 = *(std::__shared_weak_count **)(v398 + 72);
  if (v399) {
    atomic_fetch_add_explicit(&v399->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v400)
  {
    int v401 = *(_DWORD *)(a2 + 36);
    uint64_t v402 = *(int *)(a2 + 32);
    if ((int)v402 >= v401)
    {
      if (v401 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v401 + 1);
        int v401 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v401 + 1;
      sub_100FAC5FC();
    }
    uint64_t v403 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v402 + 1;
    v404 = *(_DWORD **)(v403 + 8 * v402);
    LODWORD(v403) = v404[15];
    v404[2] = 5;
    int v405 = *v400;
    v404[15] = v403 | 3;
    v404[3] = v405;
  }
  if (v399) {
    sub_10004D2C8(v399);
  }
  uint64_t v406 = **(void **)(a1 + 56);
  v408 = *(int **)(v406 + 80);
  v407 = *(std::__shared_weak_count **)(v406 + 88);
  if (v407) {
    atomic_fetch_add_explicit(&v407->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v408)
  {
    int v409 = *(_DWORD *)(a2 + 36);
    uint64_t v410 = *(int *)(a2 + 32);
    if ((int)v410 >= v409)
    {
      if (v409 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v409 + 1);
        int v409 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v409 + 1;
      sub_100FAC5FC();
    }
    uint64_t v411 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v410 + 1;
    v412 = *(_DWORD **)(v411 + 8 * v410);
    LODWORD(v411) = v412[15];
    v412[2] = 7;
    int v413 = *v408;
    v412[15] = v411 | 3;
    v412[3] = v413;
  }
  if (v407) {
    sub_10004D2C8(v407);
  }
  uint64_t v414 = **(void **)(a1 + 56);
  v416 = *(int **)(v414 + 96);
  v415 = *(std::__shared_weak_count **)(v414 + 104);
  if (v415) {
    atomic_fetch_add_explicit(&v415->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v416)
  {
    int v417 = *(_DWORD *)(a2 + 36);
    uint64_t v418 = *(int *)(a2 + 32);
    if ((int)v418 >= v417)
    {
      if (v417 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v417 + 1);
        int v417 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v417 + 1;
      sub_100FAC5FC();
    }
    uint64_t v419 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v418 + 1;
    v420 = *(_DWORD **)(v419 + 8 * v418);
    LODWORD(v419) = v420[15];
    v420[2] = 8;
    int v421 = *v416;
    v420[15] = v419 | 3;
    v420[3] = v421;
  }
  if (v415) {
    sub_10004D2C8(v415);
  }
  uint64_t v422 = **(void **)(a1 + 56);
  v424 = *(int **)(v422 + 224);
  v423 = *(std::__shared_weak_count **)(v422 + 232);
  if (v423) {
    atomic_fetch_add_explicit(&v423->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v424)
  {
    int v425 = *(_DWORD *)(a2 + 36);
    uint64_t v426 = *(int *)(a2 + 32);
    if ((int)v426 >= v425)
    {
      if (v425 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v425 + 1);
        int v425 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v425 + 1;
      sub_100FAC5FC();
    }
    uint64_t v427 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v426 + 1;
    v428 = *(_DWORD **)(v427 + 8 * v426);
    LODWORD(v427) = v428[15];
    v428[2] = 13;
    int v429 = *v424;
    v428[15] = v427 | 3;
    v428[3] = v429;
  }
  if (v423) {
    sub_10004D2C8(v423);
  }
  uint64_t v430 = **(void **)(a1 + 56);
  v432 = *(int **)(v430 + 240);
  v431 = *(std::__shared_weak_count **)(v430 + 248);
  if (v431) {
    atomic_fetch_add_explicit(&v431->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v432)
  {
    int v433 = *(_DWORD *)(a2 + 36);
    uint64_t v434 = *(int *)(a2 + 32);
    if ((int)v434 >= v433)
    {
      if (v433 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v433 + 1);
        int v433 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v433 + 1;
      sub_100FAC5FC();
    }
    uint64_t v435 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v434 + 1;
    v436 = *(_DWORD **)(v435 + 8 * v434);
    LODWORD(v435) = v436[15];
    v436[2] = 14;
    int v437 = *v432;
    v436[15] = v435 | 3;
    v436[3] = v437;
  }
  if (v431) {
    sub_10004D2C8(v431);
  }
  uint64_t v438 = **(void **)(a1 + 56);
  v440 = *(int **)(v438 + 320);
  v439 = *(std::__shared_weak_count **)(v438 + 328);
  if (v439) {
    atomic_fetch_add_explicit(&v439->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v440)
  {
    int v441 = *(_DWORD *)(a2 + 36);
    uint64_t v442 = *(int *)(a2 + 32);
    if ((int)v442 >= v441)
    {
      if (v441 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v441 + 1);
        int v441 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v441 + 1;
      sub_100FAC5FC();
    }
    uint64_t v443 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v442 + 1;
    v444 = *(_DWORD **)(v443 + 8 * v442);
    LODWORD(v443) = v444[15];
    v444[2] = 22;
    int v445 = *v440;
    v444[15] = v443 | 3;
    v444[3] = v445;
  }
  if (v439) {
    sub_10004D2C8(v439);
  }
  uint64_t v446 = **(void **)(a1 + 56);
  v448 = *(int **)(v446 + 288);
  v447 = *(std::__shared_weak_count **)(v446 + 296);
  if (v447) {
    atomic_fetch_add_explicit(&v447->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v448)
  {
    int v449 = *(_DWORD *)(a2 + 36);
    uint64_t v450 = *(int *)(a2 + 32);
    if ((int)v450 >= v449)
    {
      if (v449 == *(_DWORD *)(a2 + 40))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 24), v449 + 1);
        int v449 = *(_DWORD *)(a2 + 36);
      }
      *(_DWORD *)(a2 + 36) = v449 + 1;
      sub_100FAC5FC();
    }
    uint64_t v451 = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = v450 + 1;
    v452 = *(_DWORD **)(v451 + 8 * v450);
    LODWORD(v451) = v452[15];
    v452[2] = 15;
    int v453 = *v448;
    v452[15] = v451 | 3;
    v452[3] = v453;
  }
  if (v447) {
    sub_10004D2C8(v447);
  }
}

void sub_100FAC4F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FAC5C0(uint64_t a1)
{
  return a1;
}

void sub_100FAC5FC()
{
}

void sub_100FAC63C()
{
}

unint64_t sub_100FAC660(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v2 = a1 + 32;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = v2;
    do
    {
      int v6 = *(_DWORD *)(v3 + 28);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        int v8 = (uint64_t *)v3;
      }
      else {
        int v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != v2 && *(_DWORD *)(v5 + 28) <= a2)
    {
      int v11 = *(_DWORD *)(v5 + 32);
      unsigned int v10 = v11 & 0xFFFFFF00;
      LODWORD(v3) = v11;
      uint64_t v9 = &_mh_execute_header;
      return (unint64_t)v9 | v10 | v3;
    }
    uint64_t v9 = 0;
    LODWORD(v3) = 0;
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int v10 = 0;
  return (unint64_t)v9 | v10 | v3;
}

void sub_100FAC6D0()
{
}

void sub_100FAC710()
{
}

void *sub_100FAC734(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(0x1E0uLL);
  a1[2] = v2 + 30;
  *uint64_t v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  v2[3] = 0u;
  v2[4] = 0u;
  v2[5] = 0u;
  v2[6] = 0u;
  v2[7] = 0u;
  char v2[8] = 0u;
  v2[9] = 0u;
  v2[10] = 0u;
  v2[11] = 0u;
  v2[12] = 0u;
  v2[13] = 0u;
  v2[14] = 0u;
  v2[15] = 0u;
  uint8_t v2[16] = 0u;
  v2[17] = 0u;
  v2[18] = 0u;
  v2[19] = 0u;
  v2[20] = 0u;
  v2[21] = 0u;
  v2[22] = 0u;
  v2[23] = 0u;
  v2[24] = 0u;
  v2[25] = 0u;
  v2[26] = 0u;
  v2[27] = 0u;
  v2[28] = 0u;
  v2[29] = 0u;
  *a1 = v2;
  a1[1] = v2 + 30;
  return a1;
}

void sub_100FAC7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10)
{
  a10 = 0;
  sub_10077EE24(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAC7D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const std::string **)(a1 + 32);
  *(_DWORD *)(a2 + 76) |= 0x10u;
  uint64_t v5 = *(std::string **)(a2 + 64);
  if (v5 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v5, v4);
  if (sub_100FBA740(**(void **)(a1 + 40), 0))
  {
    id v6 = sub_100FBC4A8(**(void **)(a1 + 40));
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    id v7 = [v6 countByEnumeratingWithState:&v67 objects:v72 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v68;
      do
      {
        for (int i = 0; i != v7; int i = (char *)i + 1)
        {
          if (*(void *)v68 != v8) {
            objc_enumerationMutation(v6);
          }
          int v10 = sub_100F913B8(*(void **)(*((void *)&v67 + 1) + 8 * i));
          if (v10 != -1)
          {
            int v11 = *(_DWORD *)(a2 + 56);
            if (v11 == *(_DWORD *)(a2 + 60))
            {
              sub_1008A4E70(a2 + 48, v11 + 1);
              int v11 = *(_DWORD *)(a2 + 56);
            }
            uint64_t v12 = *(void *)(a2 + 48);
            *(_DWORD *)(a2 + 56) = v11 + 1;
            *(_DWORD *)(v12 + 4 * v11) = v10;
          }
        }
        id v7 = [v6 countByEnumeratingWithState:&v67 objects:v72 count:16];
      }
      while (v7);
    }
    int v13 = *(_DWORD *)(a2 + 24);
    if (v13 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v13 + 1);
      int v13 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v14 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v13 + 1;
    *(_DWORD *)(v14 + 4 * v13) = 1;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 1))
  {
    id v15 = sub_100FBC464(**(void **)(a1 + 40));
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    id v16 = [v15 countByEnumeratingWithState:&v63 objects:v71 count:16];
    if (v16)
    {
      uint64_t v17 = *(void *)v64;
      do
      {
        for (uint64_t j = 0; j != v16; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v64 != v17) {
            objc_enumerationMutation(v15);
          }
          int v19 = sub_100F913B8(*(void **)(*((void *)&v63 + 1) + 8 * (void)j));
          if (v19 != -1)
          {
            int v20 = *(_DWORD *)(a2 + 40);
            if (v20 == *(_DWORD *)(a2 + 44))
            {
              sub_1008A4E70(a2 + 32, v20 + 1);
              int v20 = *(_DWORD *)(a2 + 40);
            }
            uint64_t v21 = *(void *)(a2 + 32);
            *(_DWORD *)(a2 + 40) = v20 + 1;
            *(_DWORD *)(v21 + 4 * v20) = v19;
          }
        }
        id v16 = [v15 countByEnumeratingWithState:&v63 objects:v71 count:16];
      }
      while (v16);
    }
    int v22 = *(_DWORD *)(a2 + 24);
    if (v22 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v22 + 1);
      int v22 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v23 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v22 + 1;
    *(_DWORD *)(v23 + 4 * v22) = 2;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 2))
  {
    int v24 = *(_DWORD *)(a2 + 24);
    if (v24 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v24 + 1);
      int v24 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v25 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v24 + 1;
    *(_DWORD *)(v25 + 4 * v24) = 3;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 3))
  {
    int v26 = *(_DWORD *)(a2 + 24);
    if (v26 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v26 + 1);
      int v26 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v27 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v26 + 1;
    *(_DWORD *)(v27 + 4 * v26) = 4;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 11))
  {
    int v28 = *(_DWORD *)(a2 + 24);
    if (v28 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v28 + 1);
      int v28 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v29 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v28 + 1;
    *(_DWORD *)(v29 + 4 * v28) = 9;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 13))
  {
    int v30 = *(_DWORD *)(a2 + 24);
    if (v30 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v30 + 1);
      int v30 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v31 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v30 + 1;
    *(_DWORD *)(v31 + 4 * v30) = 6;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 5))
  {
    int v32 = *(_DWORD *)(a2 + 24);
    if (v32 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v32 + 1);
      int v32 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v33 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v32 + 1;
    *(_DWORD *)(v33 + 4 * v32) = 7;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 6))
  {
    int v34 = *(_DWORD *)(a2 + 24);
    if (v34 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v34 + 1);
      int v34 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v35 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v34 + 1;
    *(_DWORD *)(v35 + 4 * v34) = 8;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 4))
  {
    int v36 = *(_DWORD *)(a2 + 24);
    if (v36 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v36 + 1);
      int v36 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v37 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v36 + 1;
    *(_DWORD *)(v37 + 4 * v36) = 5;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 12))
  {
    int v38 = *(_DWORD *)(a2 + 24);
    if (v38 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v38 + 1);
      int v38 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v39 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v38 + 1;
    *(_DWORD *)(v39 + 4 * v38) = 10;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 28))
  {
    int v40 = *(_DWORD *)(a2 + 24);
    if (v40 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v40 + 1);
      int v40 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v41 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v40 + 1;
    *(_DWORD *)(v41 + 4 * v40) = 11;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 29))
  {
    int v42 = *(_DWORD *)(a2 + 24);
    if (v42 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v42 + 1);
      int v42 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v43 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v42 + 1;
    *(_DWORD *)(v43 + 4 * v42) = 12;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 19))
  {
    int v44 = *(_DWORD *)(a2 + 24);
    if (v44 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v44 + 1);
      int v44 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v45 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v44 + 1;
    *(_DWORD *)(v45 + 4 * v44) = 21;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 8))
  {
    int v46 = *(_DWORD *)(a2 + 24);
    if (v46 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v46 + 1);
      int v46 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v47 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v46 + 1;
    *(_DWORD *)(v47 + 4 * v46) = 16;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 18))
  {
    int v48 = *(_DWORD *)(a2 + 24);
    if (v48 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v48 + 1);
      int v48 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v49 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v48 + 1;
    *(_DWORD *)(v49 + 4 * v48) = 15;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 21))
  {
    int v50 = *(_DWORD *)(a2 + 24);
    if (v50 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v50 + 1);
      int v50 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v51 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v50 + 1;
    *(_DWORD *)(v51 + 4 * v50) = 23;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 9))
  {
    int v52 = *(_DWORD *)(a2 + 24);
    if (v52 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v52 + 1);
      int v52 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v53 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v52 + 1;
    *(_DWORD *)(v53 + 4 * v52) = 17;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 10))
  {
    int v54 = *(_DWORD *)(a2 + 24);
    if (v54 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v54 + 1);
      int v54 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v55 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v54 + 1;
    *(_DWORD *)(v55 + 4 * v54) = 18;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 16))
  {
    int v56 = *(_DWORD *)(a2 + 24);
    if (v56 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v56 + 1);
      int v56 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v57 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v56 + 1;
    *(_DWORD *)(v57 + 4 * v56) = 19;
  }
  if (sub_100FBA740(**(void **)(a1 + 40), 17))
  {
    int v58 = *(_DWORD *)(a2 + 24);
    if (v58 == *(_DWORD *)(a2 + 28))
    {
      sub_1008A4E70(a2 + 16, v58 + 1);
      int v58 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v59 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v58 + 1;
    *(_DWORD *)(v59 + 4 * v58) = 20;
  }
  uint64_t result = (uint64_t)sub_100FBA740(**(void **)(a1 + 40), 20);
  if (result)
  {
    int v61 = *(_DWORD *)(a2 + 24);
    if (v61 == *(_DWORD *)(a2 + 28))
    {
      uint64_t result = sub_1008A4E70(a2 + 16, v61 + 1);
      int v61 = *(_DWORD *)(a2 + 24);
    }
    uint64_t v62 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v61 + 1;
    *(_DWORD *)(v62 + 4 * v61) = 22;
  }
  return result;
}

uint64_t *sub_100FACFC8(uint64_t **a1, unsigned __int8 a2)
{
  if (!a1) {
LABEL_7:
  }
    sub_1000C14F0("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      unsigned int v2 = *((unsigned __int8 *)a1 + 32);
      if (v2 <= a2) {
        break;
      }
      a1 = (uint64_t **)*a1;
      if (!a1) {
        goto LABEL_7;
      }
    }
    if (v2 >= a2) {
      return (uint64_t *)(a1 + 5);
    }
    a1 = (uint64_t **)a1[1];
    if (!a1) {
      goto LABEL_7;
    }
  }
}

void *sub_100FAD018(void *a1)
{
  *a1 = off_101A77DE0;
  unsigned int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FAD064(void *a1)
{
  *a1 = off_101A77DE0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FAD0D0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A77DE0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[32] = *(unsigned char *)(a1 + 32);
  return result;
}

uint64_t sub_100FAD13C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A77DE0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a2 + 32) = *(unsigned char *)(result + 32);
  return result;
}

void sub_100FAD184(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FAD194(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FAD1D4(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v5 = a1[1];
    id v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[2])
      {
        id v7 = a2 + 1;
        uint64_t v8 = a2[1];
        uint64_t v10 = v8;
        if (a2[2])
        {
          *(void *)(v8 + 16) = &v10;
          *a2 = v7;
          void *v7 = 0;
          a2[2] = 0;
        }
        uint64_t v9 = *(std::__shared_weak_count **)(v5 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

uint64_t sub_100FAD380(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FAD3C0()
{
}

uint64_t *sub_100FAD3CC(unsigned char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  id v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 736))
  {
    char v3 = v1[8];
    sub_10026E7F8(v7, (uint64_t)(v1 + 16));
    sub_100FA6B94(v2, v3, (uint64_t)v7);
    sub_10026CF54((uint64_t)v7, (void *)v7[1]);
  }
  sub_100FAD470((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100FAD440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t *sub_100FAD470(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10026CF54(v1 + 16, *(void **)(v1 + 24));
    operator delete();
  }
  return result;
}

uint64_t **sub_100FAD4C4(uint64_t **result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    id v6 = *result;
    id v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v14 = result;
    id v15 = v8;
    id v16 = v8;
    if (v8)
    {
      id v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          *((unsigned char *)v8 + 32) = *((unsigned char *)v9 + 32);
          if (v8 != v9)
          {
            sub_10006E4A8(v8 + 5, (char *)v9[5], (char *)v9[6], v9[6] - v9[5]);
            uint64_t v8 = v16;
          }
          sub_100FAD644(v5, (uint64_t)v8);
          uint64_t v8 = v15;
          id v16 = v15;
          if (v15) {
            id v15 = sub_1000EA590((uint64_t)v15);
          }
          uint64_t v10 = (uint64_t *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (uint64_t *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (uint64_t *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    uint64_t result = (uint64_t **)sub_100C774F8((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_100FAD6B4((uint64_t)v5, (uint64_t)(a2 + 4));
      uint64_t v12 = (uint64_t *)a2[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          uint64_t v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (uint64_t *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_100FAD630(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100C774F8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAD644(uint64_t **a1, uint64_t a2)
{
  char v3 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        char v3 = (uint64_t **)v4;
        if (*(unsigned __int8 *)(a2 + 32) >= *((unsigned __int8 *)v4 + 32)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

uint64_t *sub_100FAD6B4(uint64_t a1, uint64_t a2)
{
  memset(v7, 0, sizeof(v7));
  sub_100FAD740(a1, a2, v7);
  char v3 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        char v3 = (uint64_t **)v4;
        if (*((unsigned __int8 *)v7[0] + 32) >= *((unsigned __int8 *)v4 + 32)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  sub_100046C38((uint64_t **)a1, (uint64_t)v3, v5, v7[0]);
  return v7[0];
}

void *sub_100FAD740@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  id v6 = a3 + 1;
  id v7 = operator new(0x40uLL);
  *a3 = v7;
  *id v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  v7[32] = *(unsigned char *)a2;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 7) = 0;
  *((void *)v7 + 5) = 0;
  uint64_t result = sub_10005C928((void *)v7 + 5, *(const void **)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100FAD7C4(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_10026EA0C(v2, v3);
  _Unwind_Resume(a1);
}

void sub_100FAD7E0(uint64_t a1)
{
  *(void *)a1 = off_101A777D0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAD848()
{
}

uint64_t sub_100FAD85C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAD8C0()
{
  return 0;
}

uint64_t sub_100FAD8C8()
{
  return 0;
}

uint64_t sub_100FAD8D0()
{
  return 0;
}

void sub_100FAD8D8(void *a1)
{
  *a1 = off_101A77840;
  operator new();
}

void sub_100FADA88(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100213E84(v1);
  __cxa_rethrow();
}

void sub_100FADA9C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100FADB70(uint64_t a1)
{
  *(void *)a1 = off_101A77840;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FADBD8()
{
}

uint64_t sub_100FADBEC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FADC50()
{
  return 0;
}

uint64_t sub_100FADC58()
{
  return 0;
}

uint64_t sub_100FADC60()
{
  return 0;
}

void sub_100FADC68(uint64_t a1)
{
  *(void *)a1 = off_101A778B0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FADCD0()
{
}

uint64_t sub_100FADCE4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FADD48()
{
  return 0;
}

uint64_t sub_100FADD50()
{
  return 0;
}

uint64_t sub_100FADD58()
{
  return 0;
}

void sub_100FADD60(uint64_t a1)
{
  *(void *)a1 = off_101A77920;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FADDC8()
{
}

uint64_t sub_100FADDDC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FADE40()
{
  return 0;
}

uint64_t sub_100FADE48()
{
  return 0;
}

uint64_t sub_100FADE50()
{
  return 0;
}

void sub_100FADE58(uint64_t a1)
{
  *(void *)a1 = off_101A77990;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FADEC0()
{
}

uint64_t sub_100FADED4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FADF38()
{
  return 0;
}

uint64_t sub_100FADF40()
{
  return 0;
}

uint64_t sub_100FADF48()
{
  return 0;
}

void sub_100FADF50(uint64_t a1)
{
  *(void *)a1 = off_101A77A00;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FADFB8()
{
}

uint64_t sub_100FADFCC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE030()
{
  return 0;
}

uint64_t sub_100FAE038()
{
  return 0;
}

uint64_t sub_100FAE040()
{
  return 0;
}

void sub_100FAE048(uint64_t a1)
{
  *(void *)a1 = off_101A77A70;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE0B0()
{
}

uint64_t sub_100FAE0C4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE128()
{
  return 0;
}

uint64_t sub_100FAE130()
{
  return 0;
}

uint64_t sub_100FAE138()
{
  return 0;
}

void sub_100FAE140(uint64_t a1)
{
  *(void *)a1 = off_101A77AE0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE1A8()
{
}

uint64_t sub_100FAE1BC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE220()
{
  return 0;
}

uint64_t sub_100FAE228()
{
  return 0;
}

uint64_t sub_100FAE230()
{
  return 0;
}

void sub_100FAE238(uint64_t a1)
{
  *(void *)a1 = off_101A77B50;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE2A0()
{
}

uint64_t sub_100FAE2B4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE318()
{
  return 0;
}

uint64_t sub_100FAE320()
{
  return 0;
}

uint64_t sub_100FAE328()
{
  return 0;
}

void sub_100FAE330(uint64_t a1)
{
  *(void *)a1 = off_101A77BC0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE398()
{
}

uint64_t sub_100FAE3AC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE410()
{
  return 0;
}

uint64_t sub_100FAE418()
{
  return 0;
}

uint64_t sub_100FAE420()
{
  return 0;
}

void sub_100FAE428(uint64_t a1)
{
  *(void *)a1 = off_101A77C30;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE490()
{
}

uint64_t sub_100FAE4A4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10005D144(*(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE508()
{
  return 0;
}

uint64_t sub_100FAE510()
{
  return 0;
}

uint64_t sub_100FAE518()
{
  return 0;
}

void sub_100FAE524()
{
}

uint64_t sub_100FAE538(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE59C()
{
  return 0;
}

uint64_t sub_100FAE5A4()
{
  return 0;
}

uint64_t sub_100FAE5AC()
{
  return 0;
}

void sub_100FAE5B8()
{
}

uint64_t sub_100FAE5CC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE630()
{
  return 0;
}

uint64_t sub_100FAE638()
{
  return 0;
}

uint64_t sub_100FAE640()
{
  return 0;
}

void sub_100FAE648(uint64_t a1)
{
  *(void *)a1 = off_101A77CA0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAE6B0()
{
}

uint64_t sub_100FAE6C4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAE728()
{
  return 0;
}

uint64_t sub_100FAE730()
{
  return 0;
}

uint64_t sub_100FAE738()
{
  return 0;
}

void sub_100FAE740(void *a1)
{
  *a1 = off_101A77D10;
  operator new();
}

void sub_100FAE8F0(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100213E84(v1);
  __cxa_rethrow();
}

void sub_100FAE904(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100FAE9D8(uint64_t a1)
{
  *(void *)a1 = off_101A77D10;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

void sub_100FAEA40()
{
}

uint64_t sub_100FAEA54(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100FAEAB8()
{
  return 0;
}

uint64_t sub_100FAEAC0()
{
  return 0;
}

uint64_t sub_100FAEAC8()
{
  return 0;
}

void *sub_100FAEAD0(void *a1)
{
  *a1 = off_101A78740;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FAEB1C(void *a1)
{
  *a1 = off_101A78740;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FAEB88(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A78740;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FAEBEC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A78740;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FAEC2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FAEC3C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FAEC7C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v45 = (void **)*v3;
  int v46 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v46;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v45 = &v46;
  }
  sub_100318E34((uint64_t)v3, a2);
  id v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    uint64_t v7 = a1[2];
    uint64_t v8 = std::__shared_weak_count::lock(v6);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[3])
      {
        uint64_t v10 = ***(void ***)(v7 + 128);
        if (!*(unsigned char *)(v10 + 49))
        {
          BOOL v11 = v46;
          if (!v46) {
            goto LABEL_20;
          }
          int v12 = *(_DWORD *)(v10 + 52);
          int v13 = &v46;
          do
          {
            uint64_t v14 = v11;
            id v15 = v13;
            int v16 = *((_DWORD *)v11 + 8);
            if (v16 >= v12) {
              int v13 = (void **)v11;
            }
            else {
              ++v11;
            }
            BOOL v11 = (void *)*v11;
          }
          while (v11);
          if (v13 == &v46) {
            goto LABEL_20;
          }
          if (v16 < v12) {
            uint64_t v14 = v15;
          }
          if (v12 < *((_DWORD *)v14 + 8)) {
LABEL_20:
          }
            int v13 = &v46;
          uint64_t v17 = *(void *)(v7 + 784);
          if (v17)
          {
            int v18 = *(_DWORD *)(v10 + 52);
            uint64_t v19 = v7 + 784;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = v17;
              }
              uint64_t v17 = *v22;
            }
            while (*v22);
            if (v19 != v7 + 784 && v18 >= *(_DWORD *)(v19 + 32))
            {
              uint64_t v25 = *(void *)(v19 + 48);
              uint64_t v23 = v19 + 48;
              uint64_t v24 = v25;
              if (v25)
              {
                uint64_t v26 = v23;
                do
                {
                  int v27 = *(_DWORD *)(v24 + 32);
                  BOOL v28 = v27 < 15;
                  if (v27 >= 15) {
                    uint64_t v29 = (uint64_t *)v24;
                  }
                  else {
                    uint64_t v29 = (uint64_t *)(v24 + 8);
                  }
                  if (!v28) {
                    uint64_t v26 = v24;
                  }
                  uint64_t v24 = *v29;
                }
                while (*v29);
                if (v26 != v23 && *(int *)(v26 + 32) <= 15)
                {
                  int v30 = *(_DWORD *)(v26 + 44);
                  if (v13 == &v46) {
                    goto LABEL_56;
                  }
                  uint64_t v33 = v13[6];
                  uint64_t v31 = v13 + 6;
                  int v32 = v33;
                  if (!v33) {
                    goto LABEL_56;
                  }
                  int v34 = v31;
                  do
                  {
                    uint64_t v35 = v32;
                    int v36 = v34;
                    int v37 = *((_DWORD *)v32 + 8);
                    int v38 = v32 + 1;
                    if (v37 >= 15)
                    {
                      int v38 = v35;
                      int v34 = (void **)v35;
                    }
                    int v32 = (void *)*v38;
                  }
                  while (v32);
                  if (v34 == v31 || (v37 >= 15 ? (uint64_t v39 = (int *)v35) : (uint64_t v39 = (int *)v36), v39[8] > 15))
                  {
LABEL_56:
                    BOOL v41 = 0;
                  }
                  else
                  {
                    if (v37 >= 15) {
                      int v40 = v35;
                    }
                    else {
                      int v40 = v36;
                    }
                    BOOL v41 = *((_DWORD *)v40 + 11) == 2;
                  }
                  if (v30 == 2 && !v41)
                  {
                    int v42 = *(NSObject **)(v7 + 40);
                    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v43 = PersonalityInfo::logPrefix((PersonalityInfo *)v10);
                      uint64_t v44 = *(void *)(v7 + 160);
                      *(_DWORD *)int buf = 136315906;
                      uint64_t v49 = v43;
                      __int16 v50 = 2080;
                      uint64_t v51 = " ";
                      __int16 v52 = 2080;
                      uint64_t v53 = v44;
                      __int16 v54 = 2080;
                      uint64_t v55 = "";
                      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sInitiate pending query on context activate", buf, 0x2Au);
                    }
                    sub_100F937E8(v7);
                  }
                }
              }
            }
          }
        }
      }
      sub_10004D2C8(v9);
    }
  }
  sub_10024D10C((uint64_t)&v45, v46);
}

void sub_100FAEF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_10004D2C8(v11);
  sub_10024D10C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAEF68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FAEFA8()
{
}

void *sub_100FAEFB4(void *a1)
{
  *a1 = off_101A787C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FAF000(void *a1)
{
  *a1 = off_101A787C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FAF06C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A787C0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FAF0D0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A787C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FAF110(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FAF120(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FAF160(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      id v6 = v5;
      if (a1[3]) {
        sub_100F96F10(v4);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100FAF1DC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAF1F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FAF230()
{
}

void *sub_100FAF23C(void *a1)
{
  *a1 = off_101A78840;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FAF288(void *a1)
{
  *a1 = off_101A78840;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FAF2F4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A78840;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FAF358(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A78840;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FAF398(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FAF3A8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FAF3E8(uint64_t *a1, xpc_object_t *a2)
{
  sub_1005BEA0C(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      id v6 = v5;
      if (a1[3]) {
        sub_100F92B8C(v4);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100FAF464(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAF478(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FAF4B8()
{
}

void *sub_100FAF4C4(void *a1)
{
  *a1 = off_101A788C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FAF510(void *a1)
{
  *a1 = off_101A788C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FAF57C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A788C0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FAF5E0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A788C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FAF620(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FAF630(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FAF670(uint64_t a1)
{
  read_rest_value();
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

void sub_100FAF7FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FAF818(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FAF858()
{
}

uint64_t sub_100FAF864(uint64_t a1)
{
  sub_100FB0B08((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100FAF8A4(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100FAF99C(a1, v3);
}

void sub_100FAF96C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FAF99C(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100FAFA94(a1, a2);
}

void sub_100FAFA7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100FAFA94(uint64_t *a1, void *a2)
{
}

void sub_100FAFB08()
{
}

uint64_t *sub_100FAFB2C(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_100A95E0C(a1, a2, 1, 2);
}

void sub_100FAFC28()
{
}

void sub_100FAFC4C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A78940;
  operator new();
}

void sub_100FAFD60(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100FAFDC8(uint64_t a1)
{
  sub_100FB017C(a1);

  operator delete();
}

BOOL sub_100FAFE00(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100FB01EC((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100FAFEB0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FAFEE0(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100FAFF0C(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100FAFF38@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100FAFF94(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100FB0000(&v2);
}

void sub_100FAFFEC(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100FB0000(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100FB0070(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100FB0098(v1);
  __cxa_rethrow();
}

void sub_100FB0084(_Unwind_Exception *a1)
{
}

uint64_t sub_100FB0098(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100FB0B08((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100FB00F8()
{
}

uint64_t sub_100FB010C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100FB0B08((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100FB0164()
{
  return 0;
}

uint64_t sub_100FB016C()
{
  return 0;
}

uint64_t sub_100FB0174()
{
  return 0;
}

uint64_t sub_100FB017C(uint64_t a1)
{
  *(void *)a1 = off_101A78940;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100FB01EC(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (int i = *(atomic_uint **)sub_100A960EC((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100A960EC(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100FB02D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100FB02F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100FB035C(&v2);
}

void sub_100FB0348(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100FB035C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100FB03CC(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100FB0404(_Unwind_Exception *a1)
{
}

void sub_100FB041C()
{
}

uint64_t sub_100FB0430(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100FB0460()
{
  return 0;
}

uint64_t sub_100FB0468()
{
  return 0;
}

uint64_t sub_100FB0470()
{
  return 0;
}

uint64_t *sub_100FB0478(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100FB0A48((uint64_t)v4, result);
    sub_100FB0A48(v3, a2);
    sub_100FB0A48((uint64_t)a2, (uint64_t *)v4);
    return sub_100FB0B08((uint64_t *)v4);
  }
  return result;
}

void sub_100FB04E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100FB04F4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_4EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_4EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100FB0630(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 8);
  uint64_t v2 = *(void *)(*(void *)a1 + 16);
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)a1 + 24);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = v2;
    long long v7 = v3;
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    long long v7 = 0;
  }
  uint64_t v4 = off_101A78A68;
  uint64_t v5 = v1;
  operator new();
}

void sub_100FB07EC()
{
}

uint64_t sub_100FB082C(uint64_t a1)
{
  sub_100A96174(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100FB0B08(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_100FB08D4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    long long v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_4" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_4" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100FB09B8(uint64_t *a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (v3)
    {
      uint64_t v4 = *a1;
      uint64_t v5 = std::__shared_weak_count::lock(v3);
      if (v5)
      {
        uint64_t v6 = v5;
        if (a1[1]) {
          sub_100F933F0(v4);
        }
        sub_10004D2C8(v6);
      }
    }
  }
}

void sub_100FB0A34(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB0A48(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100FB0AE4(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100FB0AF4(_Unwind_Exception *a1)
{
}

uint64_t *sub_100FB0B08(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100FB0B5C(void *a1)
{
  *a1 = off_101A78A98;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FB0BA8(void *a1)
{
  *a1 = off_101A78A98;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100FB0C14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100FB0CC4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FB0CDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100FB0CFC()
{
}

void *sub_100FB0D68(void *a1)
{
  *a1 = off_101A78AE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100FB0DB4(void *a1)
{
  *a1 = off_101A78AE8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100FB0E20()
{
}

uint64_t sub_100FB0E8C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_5EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_5EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100FB0FC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 8);
  uint64_t v2 = *(void *)(*(void *)a1 + 16);
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)a1 + 24);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = v2;
    long long v7 = v3;
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)a1 + 16);
    long long v7 = 0;
  }
  uint64_t v4 = off_101A78B58;
  uint64_t v5 = v1;
  sub_1009FB060();
}

void sub_100FB10A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1009FB7C0(&a9);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100FB10C8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    long long v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_5" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN12entitlements12CEHTTPDriver15initialize_syncEvE3$_5" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100FB11AC(uint64_t *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[1]) {
        sub_100F933F0(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100FB1220(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100FB1234(void *a1)
{
  *a1 = off_101A78B88;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FB1280(void *a1)
{
  *a1 = off_101A78B88;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FB12EC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A78B88;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FB1350(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A78B88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FB1390(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FB13A0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FB13E0(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      long long v7 = v6;
      if (a1[2] && *(unsigned __int8 *)(v5 + 705) != v4)
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v5 + 128));
          uint64_t v10 = *(void *)(v5 + 160);
          uint64_t v11 = asStringBool(*(unsigned char *)(v5 + 705));
          int v15 = 136316418;
          uint64_t v16 = v9;
          __int16 v17 = 2080;
          int v18 = " ";
          __int16 v19 = 2080;
          uint64_t v20 = v10;
          __int16 v21 = 2080;
          int v22 = "";
          __int16 v23 = 2080;
          uint64_t v24 = v11;
          __int16 v25 = 2080;
          uint64_t v26 = asStringBool(v4 != 0);
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%siPhone proximity is changing from %s to %s", (uint8_t *)&v15, 0x3Eu);
        }
        *(unsigned char *)(v5 + 705) = v4;
        sub_100F92DE8(v5);
        if (*(unsigned char *)(v5 + 705))
        {
          sub_100CECA44(v5, (uint64_t)"handleNearbyDevicesChanged", 0);
          int v12 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v5 + 128));
            uint64_t v14 = *(void *)(v5 + 160);
            int v15 = 136315906;
            uint64_t v16 = v13;
            __int16 v17 = 2080;
            int v18 = " ";
            __int16 v19 = 2080;
            uint64_t v20 = v14;
            __int16 v21 = 2080;
            int v22 = "";
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%siPhone is in proximity, issuing any pending transactions", (uint8_t *)&v15, 0x2Au);
          }
          sub_100F937E8(v5);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100FB1630(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB1644(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FB1684()
{
}

void *sub_100FB1690(void *a1)
{
  *a1 = off_101A78C08;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FB16DC(void *a1)
{
  *a1 = off_101A78C08;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100FB1748(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A78C08;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100FB17AC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A78C08;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100FB17EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100FB17FC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100FB183C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        uint64_t v5 = a1[3];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 16);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100FB1974(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100FB19B4()
{
}

uint64_t *sub_100FB19C0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        int v6 = *(unsigned __int8 *)(v1 + 24);
        *(unsigned char *)(v3 + 568) = v6;
        if (v6)
        {
          long long v7 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v8 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(v3 + 128));
            uint64_t v9 = *(void *)(v3 + 160);
            *(_DWORD *)int buf = 136315906;
            uint64_t v14 = v8;
            __int16 v15 = 2080;
            uint64_t v16 = " ";
            __int16 v17 = 2080;
            uint64_t v18 = v9;
            __int16 v19 = 2080;
            uint64_t v20 = "";
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sBaseband activated, initiating any pending transactions", buf, 0x2Au);
          }
          sub_100F937E8(v3);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100E570EC(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100FB1AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100E570EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100FB1B1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A78ED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FB1B3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A78ED0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FB1B90(uint64_t a1)
{
}

void sub_100FB1B9C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 592) && *(char *)(a1 + 591) < 0) {
    operator delete(*(void **)(a1 + 568));
  }
  if (*(unsigned char *)(a1 + 560)) {
    sub_10019D6E8(a1 + 104);
  }
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void sub_100FB1C44(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100FB1F80(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100B3948C((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        uint64_t v8 = *(_DWORD **)sub_100B39F3C((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_100B39F3C(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_100B39F3C(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100B3948C((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100B3948C((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100FB1F80(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100FB1F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB1F80(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100FB1FC0(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_100B39448(v2);
    if (sub_100B3A7AC(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_100B39448(v2);
      uint64_t v9 = *(uint64_t **)(sub_100B3A7AC(v7) + 8);
      sub_100B396B0(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100FB212C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FB2188(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100FB225C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_100FB227C@<X0>(int *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x30uLL);
  uint64_t result = sub_100FB22E0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100FB22CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100FB22E0(void *a1, int *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A78F20;
  sub_1003B16D8((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_100FB2328(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100FB233C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A78F20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FB235C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A78F20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FB23B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_100FB23C4(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_100FB99A4(result);
    operator delete();
  }
  return result;
}

void sub_100FB2418(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FB2450(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100FB99A4(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100FB2498(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_100FB24DC(void **a1)
{
  uint64_t v1 = a1;
  sub_100F937E8(**a1);
  operator delete();
}

void sub_100FB2530()
{
}

void sub_100FB2560()
{
}

__n128 sub_100FB2574(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A78CE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100FB25C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A78CE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

intptr_t sub_100FB25F0(uint64_t a1, MCC *this)
{
  MCC::getStringValue((uint64_t *)&v6, this);
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(char *)(v3 + 23) < 0) {
    operator delete(*(void **)v3);
  }
  long long v4 = v6;
  *(void *)(v3 + 16) = v7;
  *(_OWORD *)uint64_t v3 = v4;
  return dispatch_semaphore_signal(**(dispatch_semaphore_t **)(a1 + 16));
}

uint64_t sub_100FB2654(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FB2694()
{
}

void sub_100FB26A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FB26DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_100FB26FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100FB2740(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  long long v4 = a2 + 1;
  long long v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unsigned int v6 = *((unsigned __int8 *)v5 + 32);
      uint64_t v7 = *(uint64_t **)(a1 + 8);
      uint64_t v8 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v9 = *(void *)(a1 + 8);
      uint64_t v10 = v3;
      if (v7)
      {
        do
        {
          uint64_t v8 = (uint64_t **)v9;
          uint64_t v9 = *(void *)(v9 + 8);
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v8 = (uint64_t **)v10[2];
          BOOL v11 = *v8 == (uint64_t *)v10;
          uint64_t v10 = v8;
        }
        while (v11);
      }
      if (*((unsigned __int8 *)v8 + 32) < v6)
      {
LABEL_8:
        if (v7) {
          uint64_t v12 = v8;
        }
        else {
          uint64_t v12 = v3;
        }
        if (v7) {
          uint64_t v13 = v8 + 1;
        }
        else {
          uint64_t v13 = v3;
        }
        if (*v13) {
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v13 = v3;
        uint64_t v12 = v3;
        if (v7)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v7;
              unsigned int v14 = *((unsigned __int8 *)v7 + 32);
              if (v14 <= v6) {
                break;
              }
              uint64_t v7 = *v12;
              uint64_t v13 = v12;
              if (!*v12) {
                goto LABEL_23;
              }
            }
            if (v14 >= v6) {
              goto LABEL_24;
            }
            uint64_t v7 = v12[1];
            if (!v7)
            {
              uint64_t v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_23:
      memset(v18, 0, sizeof(v18));
      sub_100FAD740(a1, (uint64_t)(v5 + 4), v18);
      sub_100046C38((uint64_t **)a1, (uint64_t)v12, v13, v18[0]);
LABEL_24:
      uint64_t v15 = (void *)v5[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v11 = *v16 == (void)v5;
          long long v5 = v16;
        }
        while (!v11);
      }
      long long v5 = v16;
    }
    while (v16 != v4);
  }
  return a1;
}

void sub_100FB28A8(_Unwind_Exception *a1)
{
  sub_10026CF54(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100FB28C0(uint64_t a1)
{
  *(void *)a1 = off_101A78DF0;
  sub_10026CF54(a1 + 72, *(void **)(a1 + 80));
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FB2924(uint64_t a1)
{
  *(void *)a1 = off_101A78DF0;
  sub_10026CF54(a1 + 72, *(void **)(a1 + 80));
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100FB29A8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  *uint64_t v2 = off_101A78DF0;
  sub_100FB2F04((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100FB29FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FB2A10(uint64_t a1, void *a2)
{
  *a2 = off_101A78DF0;
  return sub_100FB2F04((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100FB2A3C(uint64_t a1)
{
}

void sub_100FB2A44(void *a1)
{
  sub_100FB2FD8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100FB2A80(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v11 = 0;
  long long v9 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  long long v8 = 0u;
  rest::read_rest_value();
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      if (*(void *)(a1 + 16))
      {
        uint64_t v12 = v4;
        char v13 = *(unsigned char *)(a1 + 32);
        LOBYTE(v14) = 0;
        char v16 = 0;
        if (BYTE8(v9))
        {
          long long v14 = v8;
          uint64_t v15 = v9;
          if ((void)v9)
          {
            *(void *)(*((void *)&v8 + 1) + 16) = (char *)&v14 + 8;
            *(void *)&long long v8 = (char *)&v8 + 8;
            *((void *)&v8 + 1) = 0;
            *(void *)&long long v9 = 0;
          }
          else
          {
            *(void *)&long long v14 = (char *)&v14 + 8;
          }
          char v16 = 1;
        }
        *(_OWORD *)uint64_t v17 = *(_OWORD *)v10;
        uint64_t v18 = v11;
        v10[1] = 0;
        uint64_t v11 = 0;
        v10[0] = 0;
        if (*(char *)(a1 + 63) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
          __p[2] = *(void **)(a1 + 56);
        }
        __p[3] = *(void **)(a1 + 64);
        sub_100FB2740((uint64_t)v20, (void *)(a1 + 72));
        v20[24] = *(unsigned char *)(a1 + 96);
        unsigned int v6 = *(std::__shared_weak_count **)(v4 + 16);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v5);
    }
  }
  if (v10[0])
  {
    v10[1] = v10[0];
    operator delete(v10[0]);
  }
  if (BYTE8(v9)) {
    sub_10026CF54((uint64_t)&v8, *((void **)&v8 + 1));
  }
  xpc_release(object);
}

void sub_100FB2DEC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *__p,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  uint64_t v35 = *(void **)(v32 + 48);
  if (v35)
  {
    *(void *)(v32 + 56) = v35;
    operator delete(v35);
  }
  if (*(unsigned char *)(v32 + 40)) {
    sub_10026CF54(v33, *(void **)(v32 + 24));
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100FB2EB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FB2EF8()
{
}

uint64_t sub_100FB2F04(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  sub_100FB2740(a1 + 64, (void *)(a2 + 64));
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 88);
  return a1;
}

void sub_100FB2FA8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FB2FD8(uint64_t a1)
{
  sub_10026CF54(a1 + 64, *(void **)(a1 + 72));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_100FB3038(unsigned char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  long long v8 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 736))
  {
    if (v1[40])
    {
      ctu::base64::encode();
      uint64_t v3 = (uint64_t)(v1 + 16);
      uint64_t v4 = (void **)(v2 + 456);
      if (*(char *)(v2 + 479) < 0) {
        operator delete(*v4);
      }
      *(_OWORD *)uint64_t v4 = v9;
      *(void *)(v2 + 472) = v10;
      char v5 = v1[8];
      sub_10026E7F8((uint64_t *)&v9, v3);
      sub_100FA6B94(v2, v5, (uint64_t)&v9);
      sub_10026CF54((uint64_t)&v9, *((void **)&v9 + 1));
    }
    else
    {
      sub_100FA63B4((uint64_t)(v1 + 96));
    }
  }
  sub_100FB312C((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100FB30FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t *sub_100FB312C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10026CF54(v1 + 104, *(void **)(v1 + 112));
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    uint64_t v2 = *(void **)(v1 + 48);
    if (v2)
    {
      *(void *)(v1 + 56) = v2;
      operator delete(v2);
    }
    if (*(unsigned char *)(v1 + 40)) {
      sub_10026CF54(v1 + 16, *(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_100FB31B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100FB3280(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100FB3358);
  __cxa_rethrow();
}

void sub_100FB32A8(_Unwind_Exception *a1)
{
}

void sub_100FB32C0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FB32F8(uint64_t a1)
{
}

uint64_t sub_100FB3314(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100FB3358(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 416))();
  }
  return result;
}

void sub_100FB338C()
{
  event::entitlements::authentication_response = (uint64_t)off_101A777D0;
  operator new();
}

void sub_100FB4D68(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB4D9C(_Unwind_Exception *a1)
{
}

void sub_100FB4DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB4DD4()
{
}

void sub_100FB4DF8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740(v2);
  operator delete();
}

void sub_100FB4E2C()
{
}

void sub_100FB4E44()
{
}

void sub_100FB4E64(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 24));
  sub_10000A740(v2);
  operator delete();
}

void sub_100FB4E98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  __cxa_end_catch();
  sub_10000A740(v15);
  sub_10005D144(a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB4EC0(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10005D144(*(void **)(v1 + 32));
  sub_100162A90((atomic_uint **)v1);
  operator delete();
}

void sub_100FB4EF4()
{
  __cxa_end_catch();
  sub_10000A740(v0);
  JUMPOUT(0x100FB56ACLL);
}

void sub_100FB4F10()
{
}

void sub_100FB4F1C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB4F50()
{
}

void sub_100FB4F6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB4F88()
{
}

void sub_100FB4FAC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB4FE0()
{
}

void sub_100FB4FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB5018()
{
}

void sub_100FB503C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB5070()
{
}

void sub_100FB508C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB50A8()
{
}

void sub_100FB50CC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB5100()
{
}

void sub_100FB511C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB5138()
{
}

void sub_100FB515C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB5190()
{
}

void sub_100FB51AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB51C8()
{
}

void sub_100FB51EC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB5220()
{
}

void sub_100FB523C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB5258()
{
}

void sub_100FB527C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB52B0()
{
}

void sub_100FB52CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB52E8()
{
}

void sub_100FB530C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB5340()
{
}

void sub_100FB535C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  sub_1000346F8(v15, a15);
  sub_100162A90(&a11);
  JUMPOUT(0x100FB56D4);
}

void sub_100FB5378()
{
}

void sub_100FB539C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_100FB53D0()
{
}

void sub_100FB53EC()
{
}

const char *sub_100FB56F4(int a1)
{
  if (a1 > 6200)
  {
    if (a1 > 6300)
    {
      if (a1 == 6301) {
        return "STATUS_AUTH_ID_REQUEST";
      }
      if (a1 == 6302) {
        return "STATUS_AUTH_CHALLENGE";
      }
    }
    else
    {
      if (a1 == 6201) {
        return "STATUS_BEARER_FAILURE";
      }
      if (a1 == 6300) {
        return "STATUS_AUTH_FAILED";
      }
    }
    return "????";
  }
  else
  {
    int v1 = a1 - 6000;
    uint64_t result = "STATUS_SUCCESS";
    switch(v1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "STATUS_UNSUPPORTED_ACTION";
        break;
      case 2:
        uint64_t result = "STATUS_DISALLOWED_ACTION";
        break;
      case 3:
        uint64_t result = "STATUS_UNKNOWN_DEVICE";
        break;
      case 4:
        uint64_t result = "STATUS_UNKNOWN_SUBSCRIBER";
        break;
      case 5:
        uint64_t result = "STATUS_TEMPORARY_FAILURE";
        break;
      case 6:
        uint64_t result = "STATUS_SRVCTOKEN_EXPIRED";
        break;
      case 8:
        uint64_t result = "STATUS_MAX_DEVICES_REACHED";
        break;
      case 9:
        uint64_t result = "STATUS_MAX_ICCIDS_REACHED";
        break;
      case 10:
        uint64_t result = "STATUS_PERMANENT_FAILURE";
        break;
      case 11:
        uint64_t result = "STATUS_ACCESS_TOKEN_INVALID";
        break;
      case 12:
        uint64_t result = "STATUS_OPTIN_REQUIRED";
        break;
      case 13:
        uint64_t result = "STATUS_TRANSFERSIMSERVICE_REDIRECT";
        break;
      case 20:
        uint64_t result = "STATUS_PNR_NOT_AVAILABLE";
        break;
      default:
        return "????";
    }
  }
  return result;
}

const char *sub_100FB58A0(int a1)
{
  switch(a1)
  {
    case 6100:
      uint64_t result = "STATUS_ENABLED_ENTITLEMENT";
      break;
    case 6101:
      uint64_t result = "STATUS_DISABLED_ENTITLEMENT";
      break;
    case 6102:
      uint64_t result = "STATUS_INVALID_ENTITLEMENT";
      break;
    case 6103:
      uint64_t result = "STATUS_PROVISIONING_ENTITLEMENT";
      break;
    case 6104:
      uint64_t result = "STATUS_BIZACCT_ENTITLEMENT";
      break;
    case 6105:
      uint64_t result = "STATUS_PPACCT_ENTITLEMENT";
      break;
    case 6106:
      uint64_t result = "STATUS_INCOMPATIBLE_ENTITLEMENT";
      break;
    default:
      if (a1 == -1) {
        uint64_t result = "STATUS_UNKNOWN_ENTITLEMENT";
      }
      else {
        uint64_t result = "????";
      }
      break;
  }
  return result;
}

__CFString *sub_100FB595C(int a1)
{
  if ((a1 - 2) > 0x13) {
    return 0;
  }
  else {
    return off_101A7BBD0[a1 - 2];
  }
}

uint64_t sub_100FB5980(void *a1)
{
  if ([a1 isEqualToString:@"facetime"]) {
    return 2;
  }
  if ([a1 isEqualToString:@"tethering"]) {
    return 3;
  }
  if ([a1 isEqualToString:@"VoLTE"]) {
    return 6;
  }
  if ([a1 isEqualToString:@"VoWiFi"]) {
    return 7;
  }
  if ([a1 isEqualToString:@"iCloudVoWiFi"]) {
    return 8;
  }
  if ([a1 isEqualToString:@"Multi-SIM"]) {
    return 10;
  }
  if ([a1 isEqualToString:@"sa-watch"]) {
    return 11;
  }
  if ([a1 isEqualToString:@"sa-watch-transfer"]) {
    return 14;
  }
  if ([a1 isEqualToString:@"MultiSIM-transfer"]) {
    return 12;
  }
  if ([a1 isEqualToString:@"iphone-plan-transfer"]) {
    return 13;
  }
  if ([a1 isEqualToString:@"5g-service"]) {
    return 15;
  }
  if ([a1 isEqualToString:@"ipad-signup"]) {
    return 16;
  }
  if ([a1 isEqualToString:@"custom-qos"]) {
    return 17;
  }
  if ([a1 isEqualToString:@"private-net-provisioning"]) {
    return 18;
  }
  if ([a1 isEqualToString:@"nt-carrier-service"]) {
    return 19;
  }
  if ([a1 isEqualToString:@"hera-service"]) {
    return 20;
  }
  if ([a1 isEqualToString:@"enhanced-throughput"]) {
    return 21;
  }
  return 0xFFFFFFFFLL;
}

id sub_100FB5B78(void *a1)
{
  id v2 = +[NSMutableArray array];
  uint64_t v3 = sub_100022E58();
  uint64_t v4 = v3 + 1;
  char v5 = (void *)*v3;
  if ((uint64_t *)*v3 != v3 + 1)
  {
    do
    {
      int v6 = *((_DWORD *)v5 + 7);
      if ((*a1 >> v6))
      {
        uint64_t v7 = sub_100FB595C(v6);
        if (v7) {
          [v2 addObject:v7];
        }
      }
      long long v8 = (uint64_t *)v5[1];
      if (v8)
      {
        do
        {
          long long v9 = v8;
          long long v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          long long v9 = (uint64_t *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          char v5 = v9;
        }
        while (!v10);
      }
      char v5 = v9;
    }
    while (v9 != v4);
  }
  return v2;
}

id sub_100FB5C24(void *a1)
{
  id v2 = +[NSMutableArray array];
  uint64_t v3 = sub_100022E58();
  uint64_t v4 = v3 + 1;
  char v5 = (void *)*v3;
  if ((uint64_t *)*v3 != v3 + 1)
  {
    do
    {
      unsigned int v6 = *((_DWORD *)v5 + 7);
      if (v6 >= 0x16) {
        sub_1000C14F0("bitset test argument out of range");
      }
      if ((*a1 >> v6))
      {
        uint64_t v7 = sub_100FB595C(v6);
        if (v7) {
          [v2 addObject:v7];
        }
      }
      long long v8 = (uint64_t *)v5[1];
      if (v8)
      {
        do
        {
          long long v9 = v8;
          long long v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          long long v9 = (uint64_t *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          char v5 = v9;
        }
        while (!v10);
      }
      char v5 = v9;
    }
    while (v9 != v4);
  }
  return v2;
}

id sub_100FB5CE4(uint64_t a1)
{
  id v2 = +[NSMutableArray array];
  uint64_t v3 = sub_100022E58();
  uint64_t v4 = v3 + 1;
  char v5 = (void *)*v3;
  if ((uint64_t *)*v3 != v3 + 1)
  {
    unsigned int v6 = (void *)(a1 + 8);
    do
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        int v8 = *((_DWORD *)v5 + 7);
        long long v9 = v6;
        do
        {
          int v10 = *(_DWORD *)(v7 + 32);
          BOOL v11 = v10 < v8;
          if (v10 >= v8) {
            uint64_t v12 = (uint64_t *)v7;
          }
          else {
            uint64_t v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            long long v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 != v6 && *((_DWORD *)v9 + 8) <= v8)
        {
          char v13 = sub_100FB595C(*((_DWORD *)v5 + 7));
          if (v13)
          {
            long long v14 = v13;
            id v15 = +[NSMutableDictionary dictionary];
            [v15 setObject:v14 forKey:@"name"];
            objc_msgSend(v15, "setObject:forKey:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(v9[5] + 8)), @"state");
            if (v8 == 8)
            {
              uint64_t v17 = v9[5];
              char v16 = (std::__shared_weak_count *)v9[6];
              if (v16) {
                atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              id v25 = 0;
              id v18 = +[NSMutableDictionary dictionary];
              long long v24 = &v25;
              id v25 = v18;
              sub_100FB5F6C((const void **)&v24, @"CSR", v17 + 16);
              sub_100FB5F6C((const void **)&v24, @"sip-reg-uri", v17 + 48);
              sub_100FB5F6C((const void **)&v24, @"apn", v17 + 80);
              sub_100FB5F6C((const void **)&v24, @"sip-username", v17 + 112);
              sub_100FB5F6C((const void **)&v24, @"sip-password", v17 + 144);
              sub_100FB5F6C((const void **)&v24, @"imsi", v17 + 176);
              sub_100FB5F6C((const void **)&v24, @"public-id", v17 + 208);
              sub_100FB5F6C((const void **)&v24, @"pcscf-address", v17 + 240);
              if ([v25 count])
              {
                id v19 = +[NSMutableArray array];
                [v19 addObject:v25];
                [v15 setObject:v19 forKey:@"data"];
              }
              if (v16) {
                sub_10004D2C8(v16);
              }
            }
            [v2 addObject:v15];
          }
        }
      }
      long long v20 = (uint64_t *)v5[1];
      if (v20)
      {
        do
        {
          long long v21 = v20;
          long long v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          long long v21 = (uint64_t *)v5[2];
          BOOL v22 = *v21 == (void)v5;
          char v5 = v21;
        }
        while (!v22);
      }
      char v5 = v21;
    }
    while (v21 != v4);
  }
  return v2;
}

void sub_100FB5F4C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100FB5F6C(const void **result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 24))
  {
    uint64_t v4 = (id **)result;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
      uint64_t v8 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v8) < 0)
    {
      sub_10004FC84(__dst, v7[0], (unint64_t)v7[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v7;
      uint64_t v12 = v8;
    }
    int v10 = 0;
    if (SHIBYTE(v12) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v14 = v12;
    }
    id v15 = 0;
    if (ctu::cf::convert_copy())
    {
      char v5 = v10;
      int v10 = v15;
      char v16 = v5;
      sub_1000558F4(&v16);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    unsigned int v6 = v10;
    long long v9 = v10;
    int v10 = 0;
    sub_1000558F4(&v10);
    if (SHIBYTE(v12) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v8) < 0) {
      operator delete(v7[0]);
    }
    objc_msgSend(**v4, "setObject:forKey:", v6, a2, v7[0]);
    return sub_1000558F4(&v9);
  }
  return result;
}

void sub_100FB60C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB6124(uint64_t a1, int a2, uint64_t a3)
{
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  if (a2)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      unint64_t v7 = *(void *)(a3 + 8);
      if (!v7) {
        goto LABEL_43;
      }
      BOOL v22 = 0;
      sub_10004FC84(__dst, *(void **)a3, v7);
    }
    else
    {
      if (!*(unsigned char *)(a3 + 23)) {
        goto LABEL_43;
      }
      BOOL v22 = 0;
      *(_OWORD *)std::string __dst = *(_OWORD *)a3;
      uint64_t v21 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v25 = v21;
    }
    long long v23 = 0;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&v26, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v26 = *(_OWORD *)__p;
      uint64_t v27 = v25;
    }
    long long v28 = 0;
    if (ctu::cf::convert_copy())
    {
      long long v9 = v23;
      long long v23 = v28;
      long long v29 = v9;
      sub_1000558F4(&v29);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)v26);
    }
    BOOL v22 = v23;
    long long v23 = 0;
    sub_1000558F4(&v23);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(__dst[0]);
    }
    [v6 setObject:v22 forKey:@"unique-id"];
  }
  else
  {
    if (*(char *)(a1 + 23) < 0)
    {
      unint64_t v8 = *(void *)(a1 + 8);
      if (!v8) {
        goto LABEL_43;
      }
      BOOL v22 = 0;
      sub_10004FC84(v18, *(void **)a1, v8);
    }
    else
    {
      if (!*(unsigned char *)(a1 + 23)) {
        goto LABEL_43;
      }
      BOOL v22 = 0;
      *(_OWORD *)id v18 = *(_OWORD *)a1;
      uint64_t v19 = *(void *)(a1 + 16);
    }
    if (SHIBYTE(v19) < 0)
    {
      sub_10004FC84(__p, v18[0], (unint64_t)v18[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v18;
      uint64_t v25 = v19;
    }
    long long v23 = 0;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&v26, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v26 = *(_OWORD *)__p;
      uint64_t v27 = v25;
    }
    long long v28 = 0;
    if (ctu::cf::convert_copy())
    {
      int v10 = v23;
      long long v23 = v28;
      long long v29 = v10;
      sub_1000558F4(&v29);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)v26);
    }
    BOOL v22 = v23;
    long long v23 = 0;
    sub_1000558F4(&v23);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(v18[0]);
    }
    [v6 setObject:v22 forKey:@"display-name"];
  }
  sub_1000558F4(&v22);
LABEL_43:
  BOOL v11 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    unint64_t v12 = *(void *)(a1 + 32);
    if (!v12) {
      return v6;
    }
    sub_10004FC84(v16, *v11, v12);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 47)) {
      return v6;
    }
    *(_OWORD *)char v16 = *(_OWORD *)v11;
    uint64_t v17 = *(void *)(a1 + 40);
  }
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(__p, v16[0], (unint64_t)v16[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v16;
    uint64_t v25 = v17;
  }
  long long v23 = 0;
  if (SHIBYTE(v25) < 0)
  {
    sub_10004FC84(&v26, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v26 = *(_OWORD *)__p;
    uint64_t v27 = v25;
  }
  long long v28 = 0;
  if (ctu::cf::convert_copy())
  {
    char v13 = v23;
    long long v23 = v28;
    long long v29 = v13;
    sub_1000558F4(&v29);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete((void *)v26);
  }
  uint64_t v14 = v23;
  BOOL v22 = v23;
  long long v23 = 0;
  sub_1000558F4(&v23);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  objc_msgSend(v6, "setObject:forKey:", v14, @"sip-username", v16[0]);
  sub_1000558F4(&v22);
  return v6;
}

void sub_100FB64F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30,int a31,const void *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

id sub_100FB65F8(uint64_t *a1)
{
  id v2 = +[NSMutableArray array];
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (*a1 != v4)
  {
    do
    {
      int v5 = *(_DWORD *)v3 - 1;
      if (v5 <= 9)
      {
        uint64_t v6 = *((void *)&off_101A7BC70 + v5);
        id v7 = +[NSMutableDictionary dictionary];
        [v7 setObject:v6 forKey:@"notification-name"];
        if (*(unsigned char *)(v3 + 32))
        {
          uint64_t v17 = 0;
          if (*(char *)(v3 + 31) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v3 + 8), *(void *)(v3 + 16));
          }
          else
          {
            long long v8 = *(_OWORD *)(v3 + 8);
            uint64_t v16 = *(void *)(v3 + 24);
            *(_OWORD *)std::string __dst = v8;
          }
          if (SHIBYTE(v16) < 0)
          {
            sub_10004FC84(v19, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)uint64_t v19 = *(_OWORD *)__dst;
            uint64_t v20 = v16;
          }
          id v18 = 0;
          if (SHIBYTE(v20) < 0)
          {
            sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v19;
            uint64_t v22 = v20;
          }
          long long v23 = 0;
          if (ctu::cf::convert_copy())
          {
            long long v9 = v18;
            id v18 = v23;
            v24[0] = v9;
            sub_1000558F4(v24);
          }
          if (SHIBYTE(v22) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v17 = v18;
          id v18 = 0;
          sub_1000558F4(&v18);
          if (SHIBYTE(v20) < 0) {
            operator delete(v19[0]);
          }
          if (SHIBYTE(v16) < 0) {
            operator delete(__dst[0]);
          }
          objc_msgSend(v7, "setObject:forKey:", v17, @"old-apns-token", v13[0]);
          sub_1000558F4(&v17);
        }
        if (*(unsigned char *)(v3 + 64))
        {
          uint64_t v17 = 0;
          if (*(char *)(v3 + 63) < 0)
          {
            sub_10004FC84(v13, *(void **)(v3 + 40), *(void *)(v3 + 48));
          }
          else
          {
            long long v10 = *(_OWORD *)(v3 + 40);
            uint64_t v14 = *(void *)(v3 + 56);
            *(_OWORD *)char v13 = v10;
          }
          if (SHIBYTE(v14) < 0)
          {
            sub_10004FC84(v19, v13[0], (unint64_t)v13[1]);
          }
          else
          {
            *(_OWORD *)uint64_t v19 = *(_OWORD *)v13;
            uint64_t v20 = v14;
          }
          id v18 = 0;
          if (SHIBYTE(v20) < 0)
          {
            sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v19;
            uint64_t v22 = v20;
          }
          long long v23 = 0;
          if (ctu::cf::convert_copy())
          {
            BOOL v11 = v18;
            id v18 = v23;
            v24[0] = v11;
            sub_1000558F4(v24);
          }
          if (SHIBYTE(v22) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v17 = v18;
          id v18 = 0;
          sub_1000558F4(&v18);
          if (SHIBYTE(v20) < 0) {
            operator delete(v19[0]);
          }
          if (SHIBYTE(v14) < 0) {
            operator delete(v13[0]);
          }
          objc_msgSend(v7, "setObject:forKey:", v17, @"apns-token", v13[0]);
          sub_1000558F4(&v17);
        }
        [v2 addObject:v7];
      }
      v3 += 72;
    }
    while (v3 != v4);
  }
  return v2;
}

void sub_100FB6908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,int a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB69BC(uint64_t *a1)
{
  id v2 = +[NSMutableArray array];
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (*a1 != v4)
  {
    do
    {
      int v5 = *(_DWORD *)v3 - 1;
      if (v5 <= 9)
      {
        uint64_t v6 = *((void *)&off_101A7BC70 + v5);
        id v7 = +[NSMutableDictionary dictionary];
        [v7 setObject:v6 forKey:@"notification-name"];
        if (*(unsigned char *)(v3 + 32))
        {
          char v13 = 0;
          if (*(char *)(v3 + 31) < 0)
          {
            sub_10004FC84(v11, *(void **)(v3 + 8), *(void *)(v3 + 16));
          }
          else
          {
            long long v8 = *(_OWORD *)(v3 + 8);
            uint64_t v12 = *(void *)(v3 + 24);
            *(_OWORD *)BOOL v11 = v8;
          }
          if (SHIBYTE(v12) < 0)
          {
            sub_10004FC84(__dst, v11[0], (unint64_t)v11[1]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)v11;
            uint64_t v16 = v12;
          }
          uint64_t v14 = 0;
          if (SHIBYTE(v16) < 0)
          {
            sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)__dst;
            uint64_t v18 = v16;
          }
          uint64_t v19 = 0;
          if (ctu::cf::convert_copy())
          {
            long long v9 = v14;
            uint64_t v14 = v19;
            uint64_t v20 = v9;
            sub_1000558F4(&v20);
          }
          if (SHIBYTE(v18) < 0) {
            operator delete(__p[0]);
          }
          char v13 = v14;
          uint64_t v14 = 0;
          sub_1000558F4(&v14);
          if (SHIBYTE(v16) < 0) {
            operator delete(__dst[0]);
          }
          if (SHIBYTE(v12) < 0) {
            operator delete(v11[0]);
          }
          objc_msgSend(v7, "setObject:forKey:", v13, @"apns-token", v11[0]);
          sub_1000558F4(&v13);
        }
        [v2 addObject:v7];
      }
      v3 += 40;
    }
    while (v3 != v4);
  }
  return v2;
}

void sub_100FB6BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB6C10(uint64_t **a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1]) {
      goto LABEL_7;
    }
    uint64_t v3 = *a1;
    goto LABEL_6;
  }
  uint64_t v3 = (uint64_t *)a1;
  if (*((unsigned char *)a1 + 23)) {
LABEL_6:
  }
    objc_msgSend(v2, "setObject:forKey:", +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v3, 1), @"client-nonce");
LABEL_7:
  if (*((unsigned __int8 *)a1 + 24) - 3 <= 1) {
    objc_msgSend(v2, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"), @"signing-version");
  }
  return v2;
}

id sub_100FB6CBC(uint64_t *a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a1 + 23)) {
      return v2;
    }
    goto LABEL_6;
  }
  if (a1[1])
  {
    a1 = (uint64_t *)*a1;
LABEL_6:
    objc_msgSend(v2, "setObject:forKey:", +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a1, 4), @"apns-token");
  }
  return v2;
}

id sub_100FB6D38(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void *)(a1 + 8);
    if (!v3) {
      goto LABEL_21;
    }
    long long v24 = 0;
    sub_10004FC84(__dst, *(void **)a1, v3);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 23)) {
      goto LABEL_21;
    }
    long long v24 = 0;
    *(_OWORD *)std::string __dst = *(_OWORD *)a1;
    uint64_t v23 = *(void *)(a1 + 16);
  }
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v27 = v23;
  }
  uint64_t v25 = 0;
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v28 = *(_OWORD *)__p;
    uint64_t v29 = v27;
  }
  long long v30 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v4 = v25;
    uint64_t v25 = v30;
    uint64_t v31 = v4;
    sub_1000558F4(&v31);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete((void *)v28);
  }
  long long v24 = v25;
  uint64_t v25 = 0;
  sub_1000558F4(&v25);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
  [v2 setObject:v24 forKey:@"primary-iccid"];
  sub_1000558F4(&v24);
LABEL_21:
  if (*(unsigned char *)(a1 + 48))
  {
    long long v24 = 0;
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(v20, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)uint64_t v20 = *(_OWORD *)(a1 + 24);
      uint64_t v21 = *(void *)(a1 + 40);
    }
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84(__p, v20[0], (unint64_t)v20[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v20;
      uint64_t v27 = v21;
    }
    uint64_t v25 = 0;
    if (SHIBYTE(v27) < 0)
    {
      sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v28 = *(_OWORD *)__p;
      uint64_t v29 = v27;
    }
    long long v30 = 0;
    if (ctu::cf::convert_copy())
    {
      int v5 = v25;
      uint64_t v25 = v30;
      uint64_t v31 = v5;
      sub_1000558F4(&v31);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete((void *)v28);
    }
    long long v24 = v25;
    uint64_t v25 = 0;
    sub_1000558F4(&v25);
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(v20[0]);
    }
    [v2 setObject:v24 forKey:@"eid"];
    sub_1000558F4(&v24);
  }
  uint64_t v6 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
  {
    unint64_t v7 = *(void *)(a1 + 64);
    if (!v7) {
      goto LABEL_60;
    }
    sub_10004FC84(v18, *v6, v7);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 79)) {
      goto LABEL_60;
    }
    *(_OWORD *)uint64_t v18 = *(_OWORD *)v6;
    uint64_t v19 = *(void *)(a1 + 72);
  }
  if (SHIBYTE(v19) < 0)
  {
    sub_10004FC84(__p, v18[0], (unint64_t)v18[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v18;
    uint64_t v27 = v19;
  }
  uint64_t v25 = 0;
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v28 = *(_OWORD *)__p;
    uint64_t v29 = v27;
  }
  long long v30 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v8 = v25;
    uint64_t v25 = v30;
    uint64_t v31 = v8;
    sub_1000558F4(&v31);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete((void *)v28);
  }
  long long v9 = v25;
  long long v24 = v25;
  uint64_t v25 = 0;
  sub_1000558F4(&v25);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  objc_msgSend(v2, "setObject:forKey:", v9, @"imei", v18[0]);
  sub_1000558F4(&v24);
LABEL_60:
  if (*(void *)(a1 + 80) != *(void *)(a1 + 88))
  {
    id v10 = (id)objc_opt_new();
    BOOL v11 = *(uint64_t **)(a1 + 80);
    for (int i = *(uint64_t **)(a1 + 88); v11 != i; v11 += 3)
    {
      char v13 = v11;
      if (*((char *)v11 + 23) < 0) {
        char v13 = (uint64_t *)*v11;
      }
      objc_msgSend(v10, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13));
    }
    [v2 setValue:v10 forKey:@"secondary-device-iccids"];
  }
  if (*(unsigned char *)(a1 + 168))
  {
    id v14 = +[NSMutableDictionary dictionary];
    if (*(unsigned char *)(a1 + 140)) {
      objc_msgSend(v14, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 136)), @"associated-subscription");
    }
    if (*(unsigned char *)(a1 + 132)) {
      objc_msgSend(v14, "setObject:forKey:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 128)), @"associated-plans");
    }
    id v15 = (void *)(a1 + 104);
    if (*(char *)(a1 + 127) < 0)
    {
      if (!*(void *)(a1 + 112)) {
        goto LABEL_77;
      }
      id v15 = (void *)*v15;
    }
    else if (!*(unsigned char *)(a1 + 127))
    {
LABEL_77:
      uint64_t v16 = (void *)(a1 + 144);
      if (*(char *)(a1 + 167) < 0)
      {
        if (!*(void *)(a1 + 152)) {
          goto LABEL_83;
        }
        uint64_t v16 = (void *)*v16;
      }
      else if (!*(unsigned char *)(a1 + 167))
      {
LABEL_83:
        if (objc_msgSend(v14, "count", v16)) {
          [v2 setObject:v14 forKey:@"subscription-query"];
        }
        return v2;
      }
      objc_msgSend(v14, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16), @"device-type");
      goto LABEL_83;
    }
    objc_msgSend(v14, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15), @"iccid");
    goto LABEL_77;
  }
  return v2;
}

void sub_100FB7278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30,int a31,const void *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB737C(uint64_t a1)
{
  uint64_t v17 = &v18;
  id v18 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v16 = 0;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a1;
    uint64_t v15 = *(void *)(a1 + 16);
  }
  if (SHIBYTE(v15) < 0)
  {
    sub_10004FC84(&v20, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    long long v20 = *(_OWORD *)__dst;
    uint64_t v21 = v15;
  }
  uint64_t v19 = 0;
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__p, (void *)v20, *((unint64_t *)&v20 + 1));
  }
  else
  {
    *(_OWORD *)std::string __p = v20;
    uint64_t v12 = v21;
  }
  uint64_t v22 = 0;
  if (ctu::cf::convert_copy())
  {
    id v2 = v19;
    uint64_t v19 = v22;
    *(void *)std::string __str = v2;
    sub_1000558F4((const void **)__str);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v16 = v19;
  uint64_t v19 = 0;
  sub_1000558F4(&v19);
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)v20);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
  [v18 setObject:v16 forKey:@"primary-iccid"];
  sub_100FB7824((const void **)&v17, @"eid", a1 + 24);
  sub_100FB7824((const void **)&v17, @"secondary-device-imei", a1 + 88);
  if (*(unsigned char *)(a1 + 241))
  {
    if (*(unsigned char *)(a1 + 240)) {
      unint64_t v3 = &__kCFBooleanTrue;
    }
    else {
      unint64_t v3 = &__kCFBooleanFalse;
    }
    [v18 setValue:v3 forKey:@"euicc-pairing"];
  }
  sub_100FB7824((const void **)&v17, @"secondary-device-meid", a1 + 120);
  sub_100FB7824((const void **)&v17, @"secondary-device-type", a1 + 152);
  sub_100FB7824((const void **)&v17, @"service", a1 + 192);
  if (*(unsigned char *)(a1 + 188))
  {
    uint64_t v4 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 184)];
    [v18 setObject:v4 forKeyedSubscript:@"associated-subscription"];
  }
  __int16 v24 = 0;
  *(void *)std::string __str = 0;
  if (*(unsigned char *)(a1 + 228))
  {
    snprintf(__str, 0xAuLL, "%d.%d.%d", BYTE2(*(_DWORD *)(a1 + 224)), BYTE1(*(_DWORD *)(a1 + 224)), *(_DWORD *)(a1 + 224));
    sub_100058DB0(&v20, __str);
    *(_OWORD *)std::string __p = v20;
    uint64_t v12 = v21;
    uint64_t v21 = 0;
    long long v20 = 0uLL;
    char v13 = 1;
    sub_100FB7824((const void **)&v17, @"sim-alliance-profile-version", (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)v20);
    }
  }
  if (*(unsigned char *)(a1 + 236))
  {
    snprintf(__str, 0xAuLL, "%d.%d.%d", BYTE2(*(_DWORD *)(a1 + 232)), BYTE1(*(_DWORD *)(a1 + 232)), *(_DWORD *)(a1 + 232));
    sub_100058DB0(&v20, __str);
    *(_OWORD *)std::string __p = v20;
    uint64_t v12 = v21;
    uint64_t v21 = 0;
    long long v20 = 0uLL;
    char v13 = 1;
    sub_100FB7824((const void **)&v17, @"gsma-sgp22-version", (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)v20);
    }
  }
  if (*(unsigned char *)(a1 + 80))
  {
    id v5 = (id)objc_opt_new();
    unint64_t v7 = *(uint64_t **)(a1 + 56);
    for (int i = *(uint64_t **)(a1 + 64); v7 != i; v7 += 3)
    {
      long long v8 = v7;
      if (*((char *)v7 + 23) < 0) {
        long long v8 = (uint64_t *)*v7;
      }
      objc_msgSend(v5, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v8));
    }
    [v18 setValue:v5 forKey:@"secondary-device-iccids"];
  }
  id v9 = v18;
  sub_1000558F4(&v16);
  return v9;
}

void sub_100FB777C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27)
{
  sub_1000558F4((const void **)(v27 - 104));
  if (*(char *)(v27 - 73) < 0) {
    operator delete(*(void **)(v27 - 96));
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **sub_100FB7824(const void **result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 24))
  {
    uint64_t v4 = (id **)result;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)unint64_t v7 = *(_OWORD *)a3;
      uint64_t v8 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v8) < 0)
    {
      sub_10004FC84(__dst, v7[0], (unint64_t)v7[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v7;
      uint64_t v12 = v8;
    }
    id v10 = 0;
    if (SHIBYTE(v12) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v14 = v12;
    }
    uint64_t v15 = 0;
    if (ctu::cf::convert_copy())
    {
      id v5 = v10;
      id v10 = v15;
      uint64_t v16 = v5;
      sub_1000558F4(&v16);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v6 = v10;
    id v9 = v10;
    id v10 = 0;
    sub_1000558F4(&v10);
    if (SHIBYTE(v12) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v8) < 0) {
      operator delete(v7[0]);
    }
    objc_msgSend(**v4, "setObject:forKey:", v6, a2, v7[0]);
    return sub_1000558F4(&v9);
  }
  return result;
}

void sub_100FB7978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB79DC(uint64_t **a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  id v3 = (id)objc_opt_new();
  if (*((unsigned char *)a1 + 24))
  {
    uint64_t v4 = *a1;
    id v5 = a1[1];
    if (*a1 != v5)
    {
      do
      {
        id v6 = objc_alloc_init((Class)NSMutableDictionary);
        unint64_t v7 = v4;
        if (*((char *)v4 + 23) < 0) {
          unint64_t v7 = (uint64_t *)*v4;
        }
        objc_msgSend(v6, "setObject:forKey:", +[NSString stringWithCString:](NSString, "stringWithCString:", v7), @"profile-name");
        uint64_t v8 = v4 + 3;
        if (*((char *)v4 + 47) < 0) {
          uint64_t v8 = (void *)*v8;
        }
        objc_msgSend(v6, "setObject:forKey:", +[NSString stringWithCString:](NSString, "stringWithCString:", v8), @"version");
        [v3 addObject:v6];
        v4 += 9;
      }
      while (v4 != v5);
    }
  }
  [v2 setObject:v3 forKey:@"configuration-profiles"];
  return v2;
}

id sub_100FB7AFC(uint64_t **a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  id v3 = (id)objc_opt_new();
  id v5 = *a1;
  for (int i = a1[1]; v5 != i; v5 += 3)
  {
    id v6 = v5;
    if (*((char *)v5 + 23) < 0) {
      id v6 = (uint64_t *)*v5;
    }
    objc_msgSend(v3, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6));
  }
  [v2 setObject:v3 forKey:@"service-names"];
  return v2;
}

id sub_100FB7BAC(uint64_t ***a1)
{
  id v16 = objc_alloc_init((Class)NSMutableDictionary);
  id v2 = (id)objc_opt_new();
  uint64_t v4 = *a1;
  id v3 = a1[1];
  if (*a1 != v3)
  {
    do
    {
      id v5 = objc_alloc_init((Class)NSMutableDictionary);
      id v6 = (id)objc_opt_new();
      unint64_t v7 = *v4;
      uint64_t v8 = v4[1];
      while (v7 != v8)
      {
        id v9 = v7;
        if (*((char *)v7 + 23) < 0) {
          id v9 = (uint64_t *)*v7;
        }
        objc_msgSend(v6, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9));
        v7 += 3;
      }
      [v5 setObject:v6 forKey:@"blind-token"];
      id v10 = (id)objc_opt_new();
      BOOL v11 = v4[3];
      uint64_t v12 = v4[4];
      while (v11 != v12)
      {
        char v13 = v11;
        if (*((char *)v11 + 23) < 0) {
          char v13 = (uint64_t *)*v11;
        }
        objc_msgSend(v10, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13));
        v11 += 3;
      }
      [v5 setObject:v10 forKey:@"scopes"];
      uint64_t v14 = v4 + 6;
      if (*((char *)v4 + 71) < 0) {
        uint64_t v14 = (void *)*v14;
      }
      objc_msgSend(v5, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14), @"device-type");
      [v2 addObject:v5];
      v4 += 9;
    }
    while (v4 != v3);
  }
  [v16 setObject:v2 forKey:@"blinded-messages"];
  return v16;
}

id sub_100FB7D5C(uint64_t *a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  id v3 = (id)objc_opt_new();
  if (*((char *)a1 + 47) >= 0) {
    uint64_t v4 = (uint64_t)(a1 + 3);
  }
  else {
    uint64_t v4 = a1[3];
  }
  objc_msgSend(v2, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4), @"device-type");
  if (*((char *)a1 + 23) >= 0) {
    id v5 = a1;
  }
  else {
    id v5 = (uint64_t *)*a1;
  }
  objc_msgSend(v2, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5), @"service-name");
  id v6 = (uint64_t *)a1[6];
  for (int i = (uint64_t *)a1[7]; v6 != i; v6 += 6)
  {
    id v8 = objc_alloc_init((Class)NSMutableDictionary);
    id v9 = v6;
    if (*((char *)v6 + 23) < 0) {
      id v9 = (uint64_t *)*v6;
    }
    objc_msgSend(v8, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9), @"name");
    id v10 = v6 + 3;
    if (*((char *)v6 + 47) < 0) {
      id v10 = (void *)*v10;
    }
    objc_msgSend(v8, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10), @"metadata-value");
    [v3 addObject:v8];
  }
  [v2 setObject:v3 forKey:@"service-metadata"];
  return v2;
}

id sub_100FB7ED0(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)id v6 = *(_OWORD *)a1;
    uint64_t v7 = *(void *)(a1 + 16);
  }
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(__p, v6[0], (unint64_t)v6[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v6;
    uint64_t v11 = v7;
  }
  id v9 = 0;
  if (SHIBYTE(v11) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v13 = v11;
  }
  uint64_t v14 = 0;
  if (ctu::cf::convert_copy())
  {
    id v3 = v9;
    id v9 = v14;
    uint64_t v15 = v3;
    sub_1000558F4(&v15);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v4 = v9;
  id v8 = v9;
  id v9 = 0;
  sub_1000558F4(&v9);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  objc_msgSend(v2, "setObject:forKey:", v4, @"signature", v6[0]);
  sub_1000558F4(&v8);
  return v2;
}

void sub_100FB8028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

id sub_100FB808C(int a1)
{
  id v2 = +[NSMutableArray array];
  id v3 = v2;
  if (a1) {
    CFStringRef v4 = 0;
  }
  else {
    CFStringRef v4 = @"wifi-pseudonym";
  }
  [v2 addObject:v4];
  return v3;
}

void sub_100FB80D4(uint64_t a1, void *a2, const char *a3, uint64_t a4, uint64_t a5, void *a6)
{
  *(void *)a1 = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 8) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 16) = *a6;
  uint64_t v7 = a6[1];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = ++dword_101B13028;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, a3);
  operator new();
}

void sub_100FB990C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_100FC27D8(v12);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v14);
  sub_10005CBF0(&a9);
  sub_100119D1C(v10, 0);
  uint64_t v15 = *(std::__shared_weak_count **)(v9 + 24);
  if (v15) {
    sub_10004D2C8(v15);
  }
  id v16 = *(std::__shared_weak_count **)(v9 + 8);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FB99A4(uint64_t a1)
{
  id v5 = (void **)(a1 + 96);
  sub_10005CBF0(&v5);
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 56), 0);
  id v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100FB9A10(uint64_t a1, uint64_t a2, void *a3)
{
  if (a3 && a2 && *(void *)(a1 + 40))
  {
    id v7 = a3;
    uint64_t v8 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v10 = *(void *)(a1 + 64);
      uint64_t v11 = *(void *)(a1 + 72);
      id v12 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "description"), "UTF8String");
      *(_DWORD *)int buf = 136316162;
      uint64_t v41 = v9;
      __int16 v42 = 2080;
      uint64_t v43 = " ";
      __int16 v44 = 2080;
      uint64_t v45 = v10;
      __int16 v46 = 2080;
      uint64_t v47 = v11;
      __int16 v48 = 2080;
      id v49 = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sExisting Requests: %s", buf, 0x34u);
    }
    id v13 = sub_100FB9EE4(a1, a2);
    if (v13)
    {
      uint64_t v14 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v17 = *(void *)(a1 + 64);
        uint64_t v16 = *(void *)(a1 + 72);
        id v18 = objc_msgSend(objc_msgSend(v13, "description"), "UTF8String");
        *(_DWORD *)int buf = 136316162;
        uint64_t v41 = v15;
        __int16 v42 = 2080;
        uint64_t v43 = " ";
        __int16 v44 = 2080;
        uint64_t v45 = v17;
        __int16 v46 = 2080;
        uint64_t v47 = v16;
        __int16 v48 = 2080;
        id v49 = v18;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRemoving: %s", buf, 0x34u);
      }
      objc_msgSend(*(id *)(a1 + 40), "removeObjectForKey:", objc_msgSend(v13, "identifier"));
    }
    ++*(_DWORD *)(a1 + 32);
    objc_msgSend(a3, "setIdentifier:");
    *(_DWORD *)(a1 + 48) = ++dword_101B13028;
    uint64_t v19 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v22 = *(void *)(a1 + 64);
      uint64_t v21 = *(void *)(a1 + 72);
      id v23 = objc_msgSend(objc_msgSend(a3, "description"), "UTF8String");
      *(_DWORD *)int buf = 136316162;
      uint64_t v41 = v20;
      __int16 v42 = 2080;
      uint64_t v43 = " ";
      __int16 v44 = 2080;
      uint64_t v45 = v22;
      __int16 v46 = 2080;
      uint64_t v47 = v21;
      __int16 v48 = 2080;
      id v49 = v23;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdding: %s", buf, 0x34u);
    }
    objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", a3, objc_msgSend(a3, "identifier"));
    __int16 v24 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v27 = *(void *)(a1 + 64);
      uint64_t v26 = *(void *)(a1 + 72);
      id v28 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "description"), "UTF8String");
      *(_DWORD *)int buf = 136316162;
      uint64_t v41 = v25;
      __int16 v42 = 2080;
      uint64_t v43 = " ";
      __int16 v44 = 2080;
      uint64_t v45 = v27;
      __int16 v46 = 2080;
      uint64_t v47 = v26;
      __int16 v48 = 2080;
      id v49 = v28;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sResulting Requests: %s", buf, 0x34u);
      __int16 v24 = **(NSObject ***)(a1 + 56);
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v31 = *(void *)(a1 + 64);
      uint64_t v30 = *(void *)(a1 + 72);
      id v32 = objc_msgSend(objc_msgSend(a3, "action"), "UTF8String");
      sub_100FBA118(a1, __p);
      if (v39 >= 0) {
        uint64_t v33 = __p;
      }
      else {
        uint64_t v33 = (void **)__p[0];
      }
      *(_DWORD *)int buf = 136316418;
      uint64_t v41 = v29;
      __int16 v42 = 2080;
      uint64_t v43 = " ";
      __int16 v44 = 2080;
      uint64_t v45 = v31;
      __int16 v46 = 2080;
      uint64_t v47 = v30;
      __int16 v48 = 2080;
      id v49 = v32;
      __int16 v50 = 2082;
      uint64_t v51 = v33;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdded %s, query become %{public}s", buf, 0x3Eu);
      if (v39 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    int v34 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v36 = *(void *)(a1 + 64);
      uint64_t v37 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      uint64_t v41 = v35;
      __int16 v42 = 2080;
      uint64_t v43 = " ";
      __int16 v44 = 2080;
      uint64_t v45 = v36;
      __int16 v46 = 2080;
      uint64_t v47 = v37;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sInvalid Add Request", buf, 0x2Au);
    }
  }
}

id sub_100FB9EE4(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    id v12 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v14 = *(void *)(a1 + 64);
      uint64_t v15 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      uint64_t v27 = v13;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v14;
      __int16 v32 = 2080;
      uint64_t v33 = v15;
      uint64_t v16 = "#W %s%s%s%sNo type to get";
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v16, buf, 0x2Au);
    }
    return 0;
  }
  if (!*(void *)(a1 + 40))
  {
    id v12 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v18 = *(void *)(a1 + 64);
      uint64_t v19 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      uint64_t v27 = v17;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v18;
      __int16 v32 = 2080;
      uint64_t v33 = v19;
      uint64_t v16 = "#W %s%s%s%sgetRequest, fRequests is empty";
      goto LABEL_18;
    }
    return 0;
  }
  id v5 = [*(id *)(a1 + 40) objectEnumerator];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v6 = [v5 countByEnumeratingWithState:&v21 objects:v25 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v22;
    while (2)
    {
      for (int i = 0; i != v7; int i = (char *)i + 1)
      {
        if (*(void *)v22 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        if (objc_msgSend(objc_msgSend(v10, "action"), "isEqualToString:", a2))
        {
          id v11 = v10;
          goto LABEL_15;
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v21 objects:v25 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  id v11 = 0;
LABEL_15:
  return v11;
}

uint64_t sub_100FBA118@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  sub_10004BD84((uint64_t)&v13);
  [*(id *)(a1 + 40) count];
  id v5 = (void *)std::ostream::operator<<();
  sub_10004B96C(v5, (uint64_t)" elems: ", 8);
  id v6 = [*(id *)(a1 + 40) objectEnumerator];
  for (int i = 0; ; --i)
  {
    id v8 = [v6 nextObject];
    if (!v8) {
      break;
    }
    if (i) {
      sub_10004B96C(v14, (uint64_t)", ", 2);
    }
    uint64_t v9 = (const char *)objc_msgSend(objc_msgSend(v8, "action"), "UTF8String");
    size_t v10 = strlen(v9);
    sub_10004B96C(v14, (uint64_t)v9, v10);
  }
  sub_10004BC98((uint64_t)v14 + 8, a2);
  *(void *)((char *)&v14[-1]
  *(void *)&v14[0] = v11;
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100FBA354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FBA370(uint64_t a1, uint64_t a2)
{
  id v5 = sub_100FB9EE4(a1, a2);
  if (v5) {
    sub_100FBA3D4(a1, v5);
  }
}

void sub_100FBA3D4(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v5 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = *(void *)(a1 + 72);
      int v9 = 136316162;
      uint64_t v10 = v6;
      __int16 v11 = 2080;
      id v12 = " ";
      __int16 v13 = 2080;
      uint64_t v14 = v7;
      __int16 v15 = 2080;
      uint64_t v16 = v8;
      __int16 v17 = 2080;
      id v18 = objc_msgSend(objc_msgSend(a2, "description"), "cStringUsingEncoding:", 4);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRemoving %s", (uint8_t *)&v9, 0x34u);
    }
    objc_msgSend(*(id *)(a1 + 40), "removeObjectForKey:", objc_msgSend(a2, "identifier"));
  }
}

const void **sub_100FBA50C@<X0>(uint64_t a1@<X0>, int a2@<W1>, const void **a3@<X8>)
{
  __int16 v13 = 0;
  uint64_t v14 = 0;
  id v12 = 0;
  sub_100FBA648(a1, a2, &v15);
  id v5 = sub_100FB9EE4(a1, (uint64_t)v15);
  sub_1000558F4(&v15);
  if (v5)
  {
    id v6 = [v5 info];
    if (v6)
    {
      CFTypeRef v11 = v6;
      __int16 v15 = 0;
      uint64_t v7 = (const void **)sub_10004EFE4(&v15, &v11);
      uint64_t v8 = v14;
      uint64_t v14 = v15;
      __int16 v15 = v8;
      sub_100057D78(v7);
    }
    __int16 v15 = v5;
    sub_100057DAC(&v13, &v15);
    id v9 = [v5 annotation];
    if (v9)
    {
      __int16 v15 = v9;
      sub_100057DAC(&v12, &v15);
    }
  }
  sub_100058198(a3, &v14);
  sub_1000584C8(a3 + 1, &v13);
  sub_1000584C8(a3 + 2, &v12);
  sub_1000577C4(&v12);
  sub_1000577C4(&v13);
  return sub_100057D78(&v14);
}

void sub_100FBA600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  CFStringRef v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  id v6 = va_arg(va2, const void *);
  sub_1000577C4((const void **)va);
  sub_1000577C4((const void **)va1);
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_100FBA648@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  CFStringRef v4 = (uint64_t *)(*(void *)(a1 + 96) + 16 * a2);
  uint64_t v5 = *v4;
  id v6 = (std::__shared_weak_count *)v4[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (const __CFString **)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
  CFTypeRef v11 = 0;
  id v12 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v12, v8, (const char *)0x8000100, kCFAllocatorDefault, v7))
  {
    id v9 = v11;
    CFTypeRef v11 = v12;
    __int16 v13 = v9;
    sub_1000558F4(&v13);
  }
  *a3 = v11;
  CFTypeRef v11 = 0;
  return sub_1000558F4(&v11);
}

void sub_100FBA718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBA740(uint64_t a1, int a2)
{
  sub_100FBA648(a1, a2, &v5);
  id v3 = sub_100FB9EE4(a1, v5);
  sub_1000558F4((const void **)&v5);
  return v3;
}

void sub_100FBA78C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100FBA7A0(uint64_t a1)
{
  id v3 = *(void **)(a1 + 40);
  if (v3)
  {
    id v4 = [v3 objectEnumerator];
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v5 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v10;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v10 != v7) {
            objc_enumerationMutation(v4);
          }
          [*(id *)(*((void *)&v9 + 1) + 8 * (void)v8) decreaseAttempts];
          uint64_t v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        id v6 = [v4 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }
      while (v6);
    }
  }
}

void sub_100FBA8A0(uint64_t a1, uint64_t a2)
{
  uint64_t v82 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v82);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  *(void *)&long long v6 = 136315138;
  long long v80 = v6;
  uint64_t v81 = a1;
  do
  {
    switch((int)v5)
    {
      case 0:
        id v22 = sub_100FBA740(a2, 0);
        long long v23 = v22;
        if (v22)
        {
          if ([v22 info])
          {
            [v23 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              long long v24 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v26 = *(void *)(a1 + 64);
                uint64_t v27 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v25;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v26;
                __int16 v88 = 2080;
                uint64_t v89 = v27;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging getEntitlements", buf, 0x2Au);
              }
              sub_100FBB504(a1, objc_msgSend(objc_msgSend(v23, "info", v80), "objectForKey:", @"entitlement-names"));
            }
          }
        }
        break;
      case 1:
        id v28 = sub_100FBA740(a2, 1);
        uint64_t v29 = v28;
        if (v28)
        {
          if ([v28 info])
          {
            [v29 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              __int16 v30 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v32 = *(void *)(a1 + 64);
                uint64_t v33 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v31;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v32;
                __int16 v88 = 2080;
                uint64_t v89 = v33;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging setEntitlements", buf, 0x2Au);
              }
              sub_100FBB57C(a1, objc_msgSend(objc_msgSend(v29, "info", v80), "objectForKey:", @"entitlement-names"));
            }
          }
        }
        break;
      case 2:
        id v34 = sub_100FBA740(a2, 2);
        uint64_t v35 = v34;
        if (v34)
        {
          if ([v34 info])
          {
            [v35 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              uint64_t v36 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v37 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v38 = *(void *)(a1 + 64);
                uint64_t v39 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v37;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v38;
                __int16 v88 = 2080;
                uint64_t v89 = v39;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging getProvisioning", buf, 0x2Au);
              }
              sub_100FBB5F4(a1, objc_msgSend(objc_msgSend(v35, "info", v80), "objectForKey:", @"provisioning-names"));
            }
          }
        }
        break;
      case 3:
        id v40 = sub_100FBA740(a2, 3);
        uint64_t v41 = v40;
        if (v40)
        {
          if ([v40 info])
          {
            [v41 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              __int16 v42 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v43 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v44 = *(void *)(a1 + 64);
                uint64_t v45 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v43;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v44;
                __int16 v88 = 2080;
                uint64_t v89 = v45;
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging setProvisioning", buf, 0x2Au);
              }
              sub_100FBB66C(a1, objc_msgSend(objc_msgSend(v41, "info", v80), "objectForKey:", @"provisioning-elements"));
            }
          }
        }
        break;
      case 4:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        id v7 = sub_100FBA740(a2, v5);
        if (v7)
        {
          uint64_t v8 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            uint64_t v10 = *(void *)(a1 + 64);
            uint64_t v11 = *(void *)(a1 + 72);
            long long v12 = (uint64_t *)(*(void *)(a1 + 96) + v4);
            uint64_t v13 = *v12;
            uint64_t v14 = (std::__shared_weak_count *)v12[1];
            if (v14) {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
            if (v14) {
              sub_10004D2C8(v14);
            }
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v9;
            __int16 v84 = 2080;
            int v85 = " ";
            __int16 v86 = 2080;
            uint64_t v87 = v10;
            __int16 v88 = 2080;
            uint64_t v89 = v11;
            __int16 v90 = 2080;
            uint64_t v91 = v15;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging %s", buf, 0x34u);
            a1 = v81;
          }
          if (*(void *)(a1 + 40))
          {
            id v16 = [v7 action];
            id v17 = sub_100FB9EE4(a1, (uint64_t)v16);
            if (v17)
            {
              if (objc_msgSend(v17, "matchContent:", objc_msgSend(v7, "info"))) {
                break;
              }
              id v18 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v20 = *(void *)(a1 + 64);
                uint64_t v21 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136316162;
                *(void *)&uint8_t buf[4] = v19;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v20;
                __int16 v88 = 2080;
                uint64_t v89 = v21;
                __int16 v90 = 2112;
                uint64_t v91 = (uint64_t)v16;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRemoving the existing %@", buf, 0x34u);
              }
              sub_100FBA3D4(a1, v17);
            }
            sub_100FB9A10(a1, (uint64_t)v16, v7);
          }
        }
        break;
      case 5:
        id v64 = sub_100FBA740(a2, 5);
        long long v65 = v64;
        if (v64)
        {
          if ([v64 info])
          {
            [v65 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              long long v66 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v67 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v68 = *(void *)(a1 + 64);
                uint64_t v69 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v67;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v68;
                __int16 v88 = 2080;
                uint64_t v89 = v69;
                _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging EnablePushNotification", buf, 0x2Au);
              }
              goto LABEL_69;
            }
          }
        }
        break;
      case 6:
        id v70 = sub_100FBA740(a2, 6);
        long long v65 = v70;
        if (v70)
        {
          if ([v70 info])
          {
            [v65 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              uint64_t v71 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v72 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v73 = *(void *)(a1 + 64);
                uint64_t v74 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v72;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v73;
                __int16 v88 = 2080;
                uint64_t v89 = v74;
                _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smerging DisablePushNotification", buf, 0x2Au);
              }
LABEL_69:
              sub_100FBBE6C(a1, objc_msgSend(objc_msgSend(v65, "info", v80), "objectForKey:", @"notifications"));
            }
          }
        }
        break;
      case 7:
        id v46 = sub_100FBA740(a2, 7);
        uint64_t v47 = v46;
        if (v46)
        {
          if ([v46 info])
          {
            [v47 info];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              __int16 v48 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v49 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v50 = *(void *)(a1 + 64);
                uint64_t v51 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v49;
                __int16 v84 = 2080;
                int v85 = " ";
                __int16 v86 = 2080;
                uint64_t v87 = v50;
                __int16 v88 = 2080;
                uint64_t v89 = v51;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMerging getVVMAccountStatus", buf, 0x2Au);
              }
              id v52 = objc_msgSend(objc_msgSend(v47, "info", v80), "objectForKey:", @"commands");
              if ([v52 count])
              {
                id v53 = sub_100FBA740(a1, 7);
                __int16 v54 = v53;
                if (v53)
                {
                  if ([v53 info])
                  {
                    id v55 = objc_msgSend(objc_msgSend(v54, "info"), "objectForKey:", @"commands");
                    if (v55)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        *(void *)int buf = 0;
                        ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)buf);
                        int v56 = +[NSMutableSet setWithArray:v55];
                        uint64_t v57 = v56;
                        if (v56)
                        {
                          [(NSMutableSet *)v56 addObjectsFromArray:v52];
                          objc_msgSend(objc_msgSend(v54, "info"), "setObject:forKey:", -[NSMutableSet allObjects](v57, "allObjects"), @"commands");
                        }
                        ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)buf);
                      }
                    }
                  }
                }
                else
                {
                  sub_100FBC380(a1, (uint64_t)v52);
                }
              }
            }
          }
        }
        break;
      case 21:
        id v58 = sub_100FBA740(a2, 21);
        if (v58)
        {
          uint64_t v59 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v60 = (uint64_t *)(*(void *)(a1 + 96) + v4);
            uint64_t v61 = *v60;
            uint64_t v62 = (std::__shared_weak_count *)v60[1];
            if (v62) {
              atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v63 = (*(uint64_t (**)(uint64_t))(*(void *)v61 + 40))(v61);
            if (v62) {
              sub_10004D2C8(v62);
            }
            *(_DWORD *)int buf = v80;
            *(void *)&uint8_t buf[4] = v63;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I merging %s", buf, 0xCu);
            a1 = v81;
          }
          sub_100FBBF60(a1, objc_msgSend(objc_msgSend(v58, "info", v80), "objectForKey:", @"token-scopes"));
        }
        break;
      default:
        break;
    }
    ++v5;
    v4 += 16;
  }
  while (v5 != 28);
  int v75 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v77 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v78 = *(void *)(a1 + 64);
    uint64_t v79 = *(void *)(a1 + 72);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v77;
    __int16 v84 = 2080;
    int v85 = " ";
    __int16 v86 = 2080;
    uint64_t v87 = v78;
    __int16 v88 = 2080;
    uint64_t v89 = v79;
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s=== DUMPING MERGE RESULT", buf, 0x2Au);
  }
  sub_100FBBFD8(a1);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v82);
}

void sub_100FBB3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va1);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

id sub_100FBB504(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 0, &v6);
  id v4 = sub_100FBC6B8(a1, a2, v6, @"entitlement-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBB568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBB57C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 1, &v6);
  id v4 = sub_100FBC6B8(a1, a2, v6, @"entitlement-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBB5E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBB5F4(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 2, &v6);
  id v4 = sub_100FBC6B8(a1, a2, v6, @"provisioning-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBB658(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBB66C(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  uint64_t v72 = 0;
  sub_100FBA648(a1, 3, &v72);
  uint64_t v4 = 0;
  if (a2 && *(void *)(v3 + 40))
  {
    id v58 = v72;
    if ([a2 count])
    {
      id v5 = sub_100FB9EE4(v3, (uint64_t)v58);
      if (v5) {
        goto LABEL_8;
      }
      long long v6 = **(NSObject ***)(v3 + 56);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
        uint64_t v9 = *(void **)(v3 + 64);
        uint64_t v8 = *(void *)(v3 + 72);
        id v10 = [v58 cStringUsingEncoding:4];
        *(_DWORD *)int buf = 136316162;
        uint64_t v76 = v7;
        __int16 v77 = 2080;
        uint64_t v78 = " ";
        __int16 v79 = 2080;
        id v80 = v9;
        __int16 v81 = 2080;
        uint64_t v82 = v8;
        __int16 v83 = 2080;
        id v84 = v10;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo existing %s action to append - adding", buf, 0x34u);
      }
      id v5 = +[SubscriberRequestTransactionElement requestWithAction:v58 andAnnotation:0];
      if (v5)
      {
LABEL_8:
        id v55 = v5;
        id v11 = objc_msgSend(objc_msgSend(v5, "info"), "objectForKey:", @"provisioning-elements");
        long long v12 = v11;
        if (v11)
        {
          if ([v11 isEqual:a2])
          {
            uint64_t v13 = **(NSObject ***)(v3 + 56);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
              id v16 = *(void **)(v3 + 64);
              uint64_t v15 = *(void *)(v3 + 72);
              id v17 = [v58 cStringUsingEncoding:4];
              *(_DWORD *)int buf = 136316162;
              uint64_t v76 = v14;
              __int16 v77 = 2080;
              uint64_t v78 = " ";
              __int16 v79 = 2080;
              id v80 = v16;
              __int16 v81 = 2080;
              uint64_t v82 = v15;
              __int16 v83 = 2080;
              id v84 = v17;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEntitlement arrays %s are the same, nothing to be done", buf, 0x34u);
            }
            goto LABEL_54;
          }
          id v63 = [v12 mutableCopy];
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          id v18 = [a2 countByEnumeratingWithState:&v68 objects:v74 count:16];
          if (v18)
          {
            uint64_t v60 = *(void *)v69;
            CFStringRef v20 = @"data";
            *(void *)&long long v19 = 136315650;
            long long v54 = v19;
            int v56 = a2;
            uint64_t v57 = v3;
            do
            {
              uint64_t v62 = 0;
              id v59 = v18;
              do
              {
                if (*(void *)v69 != v60) {
                  objc_enumerationMutation(a2);
                }
                uint64_t v61 = *(void **)(*((void *)&v68 + 1) + 8 * (void)v62);
                id v21 = objc_msgSend(v61, "objectForKey:", @"name", v54);
                if (v21)
                {
                  for (int i = 0; ; ++i)
                  {
                    CFStringRef v23 = v20;
                    if (i >= [v63 count]) {
                      goto LABEL_40;
                    }
                    id v24 = [v63 objectAtIndex:i];
                    id v25 = [v24 objectForKey:@"name"];
                    if (v25)
                    {
                      if ([v25 isEqual:v21]) {
                        break;
                      }
                    }
                  }
                  id v26 = [v24 objectForKey:@"state"];
                  id v27 = [v61 objectForKey:@"state"];
                  if (!v27 || !v26 || ![v27 isEqual:v26])
                  {
                    uint64_t v37 = **(NSObject ***)(v3 + 56);
                    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_40;
                    }
                    uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                    uint64_t v44 = *(void **)(v3 + 64);
                    uint64_t v43 = *(void *)(v3 + 72);
                    id v45 = [v21 cStringUsingEncoding:4];
                    *(_DWORD *)int buf = 136316162;
                    uint64_t v76 = v42;
                    __int16 v77 = 2080;
                    uint64_t v78 = " ";
                    __int16 v79 = 2080;
                    id v80 = v44;
                    __int16 v81 = 2080;
                    uint64_t v82 = v43;
                    __int16 v83 = 2080;
                    id v84 = v45;
                    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "#E %s%s%s%ssetProvisioning '%s' state is missing or mismatch", buf, 0x34u);
LABEL_50:
                    id v18 = v59;
                    goto LABEL_40;
                  }
                  id v28 = [v24 objectForKey:v20];
                  id v29 = [v61 objectForKey:v20];
                  if (!v28)
                  {
                    uint64_t v38 = **(NSObject ***)(v3 + 56);
                    if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
                      goto LABEL_40;
                    }
                    uint64_t v39 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                    id v40 = [v21 cStringUsingEncoding:4];
                    *(_DWORD *)int buf = v54;
                    uint64_t v76 = v39;
                    __int16 v77 = 2080;
                    uint64_t v78 = " ";
                    __int16 v79 = 2080;
                    id v80 = v40;
                    _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "#D %s%sskip adding. Existing setProvisioning '%s' cover everything", buf, 0x20u);
                    goto LABEL_50;
                  }
                  __int16 v30 = v29;
                  if (v29)
                  {
                    id v31 = [v28 mutableCopy];
                    long long v66 = 0u;
                    long long v67 = 0u;
                    long long v64 = 0u;
                    long long v65 = 0u;
                    id v32 = [v30 countByEnumeratingWithState:&v64 objects:v73 count:16];
                    if (v32)
                    {
                      uint64_t v33 = *(void *)v65;
                      do
                      {
                        for (uint64_t j = 0; j != v32; uint64_t j = (char *)j + 1)
                        {
                          if (*(void *)v65 != v33) {
                            objc_enumerationMutation(v30);
                          }
                          uint64_t v35 = *(void *)(*((void *)&v64 + 1) + 8 * (void)j);
                          if (([v28 containsObject:v35] & 1) == 0) {
                            [v31 addObject:v35];
                          }
                        }
                        id v32 = [v30 countByEnumeratingWithState:&v64 objects:v73 count:16];
                      }
                      while (v32);
                    }
                    a2 = v56;
                    uint64_t v3 = v57;
                    id v18 = v59;
                    id v36 = [v24 mutableCopy];
                    [v36 setValue:v31 forKey:v23];
                    [v63 replaceObjectAtIndex:i withObject:v36];
                  }
                  else
                  {
                    uint64_t v41 = **(NSObject ***)(v3 + 56);
                    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v46 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                      id v47 = [v21 cStringUsingEncoding:4];
                      *(_DWORD *)int buf = v54;
                      uint64_t v76 = v46;
                      __int16 v77 = 2080;
                      uint64_t v78 = " ";
                      __int16 v79 = 2080;
                      id v80 = v47;
                      _os_log_debug_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "#D %s%sreplace existing setProvisioning '%s' with new one since it covers everything", buf, 0x20u);
                      id v18 = v59;
                    }
                    [v63 replaceObjectAtIndex:i withObject:v61];
                  }
LABEL_40:
                  CFStringRef v20 = v23;
                  if ([v63 count] == i) {
                    [v63 addObject:v61];
                  }
                }
                uint64_t v62 = (char *)v62 + 1;
              }
              while (v62 != v18);
              id v48 = [a2 countByEnumeratingWithState:&v68 objects:v74 count:16];
              id v18 = v48;
            }
            while (v48);
          }
          objc_msgSend(objc_msgSend(v55, "info"), "setValue:forKey:", v63, @"provisioning-elements");
        }
        else
        {
          objc_msgSend(objc_msgSend(v55, "info"), "setValue:forKey:", a2, @"provisioning-elements");
        }
        sub_100FB9A10(v3, (uint64_t)v58, v55);
LABEL_54:
        uint64_t v4 = 1;
        goto LABEL_58;
      }
      uint64_t v49 = **(NSObject ***)(v3 + 56);
      uint64_t v4 = 0;
      if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_58;
      }
      uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
      uint64_t v51 = *(void **)(v3 + 64);
      uint64_t v52 = *(void *)(v3 + 72);
      *(_DWORD *)int buf = 136315906;
      uint64_t v76 = v50;
      __int16 v77 = 2080;
      uint64_t v78 = " ";
      __int16 v79 = 2080;
      id v80 = v51;
      __int16 v81 = 2080;
      uint64_t v82 = v52;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate entitlement request", buf, 0x2Au);
    }
    uint64_t v4 = 0;
  }
LABEL_58:
  sub_1000558F4((const void **)&v72);
  return v4;
}

void sub_100FBBDE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,const void *a40)
{
}

uint64_t sub_100FBBE6C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 5, &v6);
  uint64_t v4 = sub_100FBCD58(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBBEC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBBEDC(uint64_t a1, int a2)
{
  id v2 = (uint64_t *)(a1 + 16 * a2);
  uint64_t v3 = *v2;
  uint64_t v4 = (std::__shared_weak_count *)v2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v5;
}

void sub_100FBBF48(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

id sub_100FBBF60(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 21, &v6);
  id v4 = sub_100FBC6B8(a1, a2, v6, @"token-scopes");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBBFC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100FBBFD8(uint64_t a1)
{
  uint64_t v3 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v6 = *(void *)(a1 + 64);
    uint64_t v5 = *(void *)(a1 + 72);
    sub_100FBA118(a1, __p);
    if (v18 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136316162;
    uint64_t v20 = v4;
    __int16 v21 = 2080;
    id v22 = " ";
    __int16 v23 = 2080;
    uint64_t v24 = v6;
    __int16 v25 = 2080;
    uint64_t v26 = v5;
    __int16 v27 = 2082;
    *(void *)id v28 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Query has %{public}s", buf, 0x34u);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v3 = **(NSObject ***)(a1 + 56);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v10 = *(void *)(a1 + 64);
    uint64_t v9 = *(void *)(a1 + 72);
    id v11 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "description"), "cStringUsingEncoding:", 4);
    *(_DWORD *)int buf = 136316162;
    uint64_t v20 = v8;
    __int16 v21 = 2080;
    id v22 = " ";
    __int16 v23 = 2080;
    uint64_t v24 = v10;
    __int16 v25 = 2080;
    uint64_t v26 = v9;
    __int16 v27 = 2080;
    *(void *)id v28 = v11;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Requests: %s", buf, 0x34u);
    uint64_t v3 = **(NSObject ***)(a1 + 56);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v13 = *(void *)(a1 + 64);
    uint64_t v14 = *(void *)(a1 + 72);
    int v15 = *(_DWORD *)(a1 + 32);
    int v16 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)int buf = 136316418;
    uint64_t v20 = v12;
    __int16 v21 = 2080;
    id v22 = " ";
    __int16 v23 = 2080;
    uint64_t v24 = v13;
    __int16 v25 = 2080;
    uint64_t v26 = v14;
    __int16 v27 = 1024;
    *(_DWORD *)id v28 = v15;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = v16;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Current Transaction ID: %d, generation: %u", buf, 0x36u);
  }
}

uint64_t sub_100FBC250(uint64_t a1, unsigned char *a2)
{
  if ((*a2 & 0x20) == 0 || sub_100FB9EE4(a1, @"authenticate")) {
    return 0;
  }
  id v4 = +[SubscriberRequestTransactionElement requestWithAction:@"authenticate" andAnnotation:0];
  uint64_t v5 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 72);
    int v9 = 136315906;
    uint64_t v10 = v6;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v7;
    __int16 v15 = 2080;
    uint64_t v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sadding AuthOnly action", (uint8_t *)&v9, 0x2Au);
  }
  sub_100FB9A10(a1, @"authenticate", v4);
  return 1;
}

BOOL sub_100FBC380(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v9 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v9);
  uint64_t v8 = 0;
  sub_100FBA648(a1, 7, &v8);
  id v4 = +[SubscriberRequestTransactionElement requestWithAction:v8 andAnnotation:0];
  uint64_t v5 = v4;
  BOOL v6 = v4 != 0;
  if (v4)
  {
    objc_msgSend(objc_msgSend(v4, "info"), "setObject:forKey:", a2, @"commands");
    sub_100FB9A10(a1, (uint64_t)v8, v5);
  }
  sub_1000558F4(&v8);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v9);
  return v6;
}

void sub_100FBC440(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

id sub_100FBC464(uint64_t a1)
{
  id result = sub_100FBA740(a1, 1);
  if (result)
  {
    id v2 = [result info];
    return [v2 objectForKey:@"entitlement-names"];
  }
  return result;
}

id sub_100FBC4A8(uint64_t a1)
{
  id result = sub_100FBA740(a1, 0);
  if (result)
  {
    id v2 = [result info];
    return [v2 objectForKey:@"entitlement-names"];
  }
  return result;
}

id sub_100FBC4EC(uint64_t a1, void *a2)
{
  if (!*(void *)(a1 + 40)) {
    return 0;
  }
  id v4 = sub_100FB9EE4(a1, (uint64_t)a2);
  if (!v4)
  {
    uint64_t v5 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = *(void *)(a1 + 72);
      int v14 = 136316162;
      uint64_t v15 = v6;
      __int16 v16 = 2080;
      id v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v7;
      __int16 v20 = 2080;
      uint64_t v21 = v8;
      __int16 v22 = 2080;
      id v23 = [a2 cStringUsingEncoding:4];
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo existing %s action to append - adding", (uint8_t *)&v14, 0x34u);
    }
    id v4 = +[SubscriberRequestTransactionElement requestWithAction:a2 andAnnotation:0];
    if (!v4)
    {
      uint64_t v9 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v11 = *(void *)(a1 + 64);
        uint64_t v12 = *(void *)(a1 + 72);
        int v14 = 136315906;
        uint64_t v15 = v10;
        __int16 v16 = 2080;
        id v17 = " ";
        __int16 v18 = 2080;
        uint64_t v19 = v11;
        __int16 v20 = 2080;
        uint64_t v21 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate entitlement request", (uint8_t *)&v14, 0x2Au);
      }
      return 0;
    }
  }
  sub_100FB9A10(a1, (uint64_t)a2, v4);
  return v4;
}

id sub_100FBC6B8(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v4 = 0;
  if (!a2 || !*(void *)(a1 + 40)) {
    return v4;
  }
  if (![a2 count]) {
    return 0;
  }
  id v4 = sub_100FB9EE4(a1, (uint64_t)a3);
  if (!v4)
  {
    uint64_t v9 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v11 = *(void *)(a1 + 64);
      uint64_t v12 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136316162;
      uint64_t v47 = v10;
      __int16 v48 = 2080;
      uint64_t v49 = " ";
      __int16 v50 = 2080;
      uint64_t v51 = v11;
      __int16 v52 = 2080;
      uint64_t v53 = v12;
      __int16 v54 = 2080;
      id v55 = [a3 cStringUsingEncoding:4];
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo existing %s action to append - adding", buf, 0x34u);
    }
    id v4 = +[SubscriberRequestTransactionElement requestWithAction:a3 andAnnotation:0];
    if (!v4)
    {
      id v32 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v34 = *(void *)(a1 + 64);
        uint64_t v35 = *(void *)(a1 + 72);
        *(_DWORD *)int buf = 136315906;
        uint64_t v47 = v33;
        __int16 v48 = 2080;
        uint64_t v49 = " ";
        __int16 v50 = 2080;
        uint64_t v51 = v34;
        __int16 v52 = 2080;
        uint64_t v53 = v35;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate entitlement request", buf, 0x2Au);
      }
      return 0;
    }
  }
  id v13 = objc_msgSend(objc_msgSend(v4, "info"), "objectForKey:", a4);
  if (!v13)
  {
    objc_msgSend(objc_msgSend(v4, "info"), "setValue:forKey:", a2, a4);
LABEL_25:
    sub_100FB9A10(a1, (uint64_t)a3, v4);
    return v4;
  }
  int v14 = v13;
  if (![v13 isEqual:a2])
  {
    uint64_t v37 = a4;
    uint64_t v38 = v4;
    uint64_t v39 = a3;
    id v20 = [v14 mutableCopy];
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    id v21 = [a2 countByEnumeratingWithState:&v41 objects:v45 count:16];
    if (v21)
    {
      id v22 = v21;
      uint64_t v23 = *(void *)v42;
      id v40 = v20;
      do
      {
        for (int i = 0; i != v22; int i = (char *)i + 1)
        {
          if (*(void *)v42 != v23) {
            objc_enumerationMutation(a2);
          }
          __int16 v25 = *(void **)(*((void *)&v41 + 1) + 8 * i);
          if (([v20 containsObject:v25] & 1) == 0)
          {
            uint64_t v26 = **(NSObject ***)(a1 + 56);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
              id v28 = v22;
              uint64_t v29 = *(void *)(a1 + 64);
              uint64_t v30 = *(void *)(a1 + 72);
              id v31 = [v25 cStringUsingEncoding:4];
              *(_DWORD *)int buf = 136316162;
              uint64_t v47 = v27;
              __int16 v48 = 2080;
              uint64_t v49 = " ";
              __int16 v50 = 2080;
              uint64_t v51 = v29;
              id v22 = v28;
              id v20 = v40;
              __int16 v52 = 2080;
              uint64_t v53 = v30;
              __int16 v54 = 2080;
              id v55 = v31;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAdding %s", buf, 0x34u);
            }
            [v20 addObject:v25];
          }
        }
        id v22 = [a2 countByEnumeratingWithState:&v41 objects:v45 count:16];
      }
      while (v22);
    }
    id v4 = v38;
    objc_msgSend(objc_msgSend(v38, "info"), "setValue:forKey:", v20, v37);
    a3 = v39;
    goto LABEL_25;
  }
  uint64_t v15 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v18 = *(void *)(a1 + 64);
    uint64_t v17 = *(void *)(a1 + 72);
    id v19 = [a3 cStringUsingEncoding:4];
    *(_DWORD *)int buf = 136316162;
    uint64_t v47 = v16;
    __int16 v48 = 2080;
    uint64_t v49 = " ";
    __int16 v50 = 2080;
    uint64_t v51 = v18;
    __int16 v52 = 2080;
    uint64_t v53 = v17;
    __int16 v54 = 2080;
    id v55 = v19;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEntitlement arrays %s are the same, nothing to be done", buf, 0x34u);
  }
  return v4;
}

id sub_100FBCB1C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  obuint64_t j = a2;
  if (a2)
  {
    if (*(void *)(a1 + 40))
    {
      if ([a2 count])
      {
        id v6 = sub_100FB9EE4(a1, (uint64_t)a3);
        if (v6)
        {
          id v7 = objc_msgSend(objc_msgSend(v6, "info"), "objectForKey:", a4);
          if (v7)
          {
            uint64_t v8 = v7;
            id v9 = (id)objc_opt_new();
            long long v28 = 0u;
            long long v29 = 0u;
            long long v30 = 0u;
            long long v31 = 0u;
            id v10 = [obj countByEnumeratingWithState:&v28 objects:v44 count:16];
            if (v10)
            {
              id v12 = v10;
              uint64_t v13 = *(void *)v29;
              *(void *)&long long v11 = 136316418;
              long long v24 = v11;
              __int16 v25 = v8;
              do
              {
                for (int i = 0; i != v12; int i = (char *)i + 1)
                {
                  if (*(void *)v29 != v13) {
                    objc_enumerationMutation(obj);
                  }
                  uint64_t v15 = *(void **)(*((void *)&v28 + 1) + 8 * i);
                  if (objc_msgSend(v8, "containsObject:", v15, v24))
                  {
                    uint64_t v16 = **(NSObject ***)(a1 + 56);
                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                      id v18 = v9;
                      uint64_t v20 = *(void *)(a1 + 64);
                      uint64_t v19 = *(void *)(a1 + 72);
                      id v21 = [v15 cStringUsingEncoding:4];
                      id v22 = [a3 cStringUsingEncoding:4];
                      *(_DWORD *)int buf = v24;
                      uint64_t v33 = v17;
                      __int16 v34 = 2080;
                      uint64_t v35 = " ";
                      __int16 v36 = 2080;
                      uint64_t v37 = v20;
                      id v9 = v18;
                      __int16 v38 = 2080;
                      uint64_t v39 = v19;
                      uint64_t v8 = v25;
                      __int16 v40 = 2080;
                      id v41 = v21;
                      __int16 v42 = 2080;
                      id v43 = v22;
                      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%staking out %s from %s - already queried", buf, 0x3Eu);
                    }
                  }
                  else
                  {
                    [v9 addObject:v15];
                  }
                }
                id v12 = [obj countByEnumeratingWithState:&v28 objects:v44 count:16];
              }
              while (v12);
            }
            return v9;
          }
        }
      }
    }
  }
  return obj;
}

uint64_t sub_100FBCD58(uint64_t a1, void *a2, void *a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (*(void *)(a1 + 40))
    {
      uint64_t result = (uint64_t)[a2 count];
      if (result)
      {
        id v7 = sub_100FB9EE4(a1, (uint64_t)a3);
        if (v7) {
          goto LABEL_8;
        }
        uint64_t v8 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v10 = *(void *)(a1 + 64);
          uint64_t v11 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136316162;
          uint64_t v42 = v9;
          __int16 v43 = 2080;
          long long v44 = " ";
          __int16 v45 = 2080;
          uint64_t v46 = v10;
          __int16 v47 = 2080;
          uint64_t v48 = v11;
          __int16 v49 = 2080;
          id v50 = [a3 cStringUsingEncoding:4];
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo existing %s action to append - adding", buf, 0x34u);
        }
        id v7 = +[SubscriberRequestTransactionElement requestWithAction:a3 andAnnotation:0];
        if (v7)
        {
LABEL_8:
          id v12 = objc_msgSend(objc_msgSend(v7, "info"), "objectForKey:", @"notifications");
          if (v12)
          {
            uint64_t v13 = v12;
            if ([v12 isEqual:a2])
            {
              int v14 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v17 = *(void *)(a1 + 64);
                uint64_t v16 = *(void *)(a1 + 72);
                id v18 = [a3 cStringUsingEncoding:4];
                *(_DWORD *)int buf = 136316162;
                uint64_t v42 = v15;
                __int16 v43 = 2080;
                long long v44 = " ";
                __int16 v45 = 2080;
                uint64_t v46 = v17;
                __int16 v47 = 2080;
                uint64_t v48 = v16;
                __int16 v49 = 2080;
                id v50 = v18;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEntitlement arrays %s are the same, nothing to be done", buf, 0x34u);
              }
              return 1;
            }
            __int16 v34 = v7;
            uint64_t v35 = a3;
            id v19 = [v13 mutableCopy];
            long long v36 = 0u;
            long long v37 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            id v20 = [a2 countByEnumeratingWithState:&v36 objects:v40 count:16];
            if (v20)
            {
              id v21 = v20;
              uint64_t v22 = *(void *)v37;
              do
              {
                for (int i = 0; i != v21; int i = (char *)i + 1)
                {
                  if (*(void *)v37 != v22) {
                    objc_enumerationMutation(a2);
                  }
                  long long v24 = *(void **)(*((void *)&v36 + 1) + 8 * i);
                  id v25 = [v24 objectForKey:@"notification-name"];
                  if (v25)
                  {
                    id v26 = v25;
                    uint64_t v27 = 0;
                    if ([v19 count])
                    {
                      while (1)
                      {
                        id v28 = objc_msgSend(objc_msgSend(v19, "objectAtIndex:", v27), "objectForKey:", @"notification-name");
                        if (v28)
                        {
                          if ([v28 isEqual:v26]) {
                            break;
                          }
                        }
                        if (++v27 >= [v19 count]) {
                          goto LABEL_25;
                        }
                      }
                      [v19 replaceObjectAtIndex:v27 withObject:v24];
                    }
LABEL_25:
                    if (v27 == [v19 count]) {
                      [v19 addObject:v24];
                    }
                  }
                }
                id v21 = [a2 countByEnumeratingWithState:&v36 objects:v40 count:16];
              }
              while (v21);
            }
            id v7 = v34;
            objc_msgSend(objc_msgSend(v34, "info"), "setValue:forKey:", v19, @"notifications");
            a3 = v35;
          }
          else
          {
            objc_msgSend(objc_msgSend(v7, "info"), "setValue:forKey:", a2, @"notifications");
          }
          sub_100FB9A10(a1, (uint64_t)a3, v7);
          return 1;
        }
        long long v29 = **(NSObject ***)(a1 + 56);
        BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (v30)
        {
          uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v32 = *(void *)(a1 + 64);
          uint64_t v33 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136315906;
          uint64_t v42 = v31;
          __int16 v43 = 2080;
          long long v44 = " ";
          __int16 v45 = 2080;
          uint64_t v46 = v32;
          __int16 v47 = 2080;
          uint64_t v48 = v33;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate entitlement request", buf, 0x2Au);
          return 0;
        }
      }
    }
  }
  return result;
}

id sub_100FBD184(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (*(void *)(a1 + 40))
    {
      if ([a2 count])
      {
        id v5 = sub_100FB9EE4(a1, (uint64_t)a3);
        if (v5)
        {
          id v6 = objc_msgSend(objc_msgSend(v5, "info"), "objectForKey:", @"notifications");
          if (v6)
          {
            id v7 = v6;
            id v8 = (id)objc_opt_new();
            long long v30 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            long long v33 = 0u;
            id v29 = [v3 countByEnumeratingWithState:&v30 objects:v46 count:16];
            if (v29)
            {
              uint64_t v28 = *(void *)v31;
              *(void *)&long long v9 = 136316418;
              long long v24 = v9;
              id v25 = v8;
              do
              {
                for (int i = 0; i != v29; int i = (char *)i + 1)
                {
                  if (*(void *)v31 != v28) {
                    objc_enumerationMutation(v3);
                  }
                  uint64_t v11 = *(void **)(*((void *)&v30 + 1) + 8 * i);
                  id v12 = objc_msgSend(v11, "objectForKey:", @"notification-name", v24);
                  if (v12)
                  {
                    uint64_t v13 = v12;
                    for (uint64_t j = 0; j < [v7 count]; ++j)
                    {
                      id v15 = [v7 objectAtIndex:j];
                      id v16 = [v15 objectForKey:@"notification-name"];
                      if (v16
                        && [v16 isEqual:v13]
                        && ([v15 isEqual:v11] & 1) != 0)
                      {
                        break;
                      }
                    }
                    if (j == [v7 count])
                    {
                      [v8 addObject:v11];
                    }
                    else
                    {
                      uint64_t v17 = **(NSObject ***)(a1 + 56);
                      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                        id v19 = v3;
                        uint64_t v20 = *(void *)(a1 + 64);
                        uint64_t v27 = *(void *)(a1 + 72);
                        id v21 = [v13 cStringUsingEncoding:4];
                        id v22 = [a3 cStringUsingEncoding:4];
                        *(_DWORD *)int buf = v24;
                        uint64_t v35 = v18;
                        __int16 v36 = 2080;
                        long long v37 = " ";
                        __int16 v38 = 2080;
                        uint64_t v39 = v20;
                        uint64_t v3 = v19;
                        id v8 = v25;
                        __int16 v40 = 2080;
                        uint64_t v41 = v27;
                        __int16 v42 = 2080;
                        id v43 = v21;
                        __int16 v44 = 2080;
                        id v45 = v22;
                        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%staking out %s from %s - already queried", buf, 0x3Eu);
                      }
                    }
                  }
                }
                id v29 = [v3 countByEnumeratingWithState:&v30 objects:v46 count:16];
              }
              while (v29);
            }
            return v8;
          }
        }
      }
    }
  }
  return v3;
}

void *sub_100FBD44C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v4 = 0;
  if (a2 && *(void *)(a1 + 40))
  {
    if (![a2 count]) {
      return 0;
    }
    id v9 = sub_100FB9EE4(a1, (uint64_t)a3);
    if (!v9)
    {
LABEL_9:
      id v14 = +[SubscriberRequestTransactionElement requestWithAction:a3 andAnnotation:a4];
      if (v14)
      {
        id v4 = v14;
        objc_msgSend(objc_msgSend(v14, "info"), "addEntriesFromDictionary:", a2);
        sub_100FB9A10(a1, (uint64_t)a3, v4);
        return v4;
      }
      id v15 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v17 = *(void *)(a1 + 64);
        uint64_t v18 = *(void *)(a1 + 72);
        int v20 = 136315906;
        uint64_t v21 = v16;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        __int16 v24 = 2080;
        uint64_t v25 = v17;
        __int16 v26 = 2080;
        uint64_t v27 = v18;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate entitlement request", (uint8_t *)&v20, 0x2Au);
      }
      return 0;
    }
    id v4 = v9;
    if (([v9 matchContent:a2] & 1) == 0)
    {
      uint64_t v10 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v12 = *(void *)(a1 + 64);
        uint64_t v13 = *(void *)(a1 + 72);
        int v20 = 136316162;
        uint64_t v21 = v11;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        __int16 v24 = 2080;
        uint64_t v25 = v12;
        __int16 v26 = 2080;
        uint64_t v27 = v13;
        __int16 v28 = 2080;
        id v29 = [a3 cStringUsingEncoding:4];
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRemoving the existing %s", (uint8_t *)&v20, 0x34u);
      }
      sub_100FBA3D4(a1, v4);
      goto LABEL_9;
    }
  }
  return v4;
}

void *sub_100FBD670(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (*(void *)(a1 + 40))
    {
      if ([a2 count])
      {
        id v6 = sub_100FB9EE4(a1, (uint64_t)a3);
        if (v6)
        {
          if ([v6 matchContent:v3])
          {
            id v7 = **(NSObject ***)(a1 + 56);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
              uint64_t v10 = *(void *)(a1 + 64);
              uint64_t v9 = *(void *)(a1 + 72);
              int v12 = 136316162;
              uint64_t v13 = v8;
              __int16 v14 = 2080;
              id v15 = " ";
              __int16 v16 = 2080;
              uint64_t v17 = v10;
              __int16 v18 = 2080;
              uint64_t v19 = v9;
              __int16 v20 = 2080;
              id v21 = [a3 cStringUsingEncoding:4];
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%staking out %s - already queried", (uint8_t *)&v12, 0x34u);
            }
            return 0;
          }
        }
      }
    }
  }
  return v3;
}

void *sub_100FBD7B0(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 24, &v6);
  id v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBD810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBD824(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 24, &v6);
  id v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBD880(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBD894(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 25, &v6);
  id v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBD8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBD908(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 25, &v6);
  id v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBD964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBD978(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 26, &v6);
  id v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBD9D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBD9EC(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 26, &v6);
  id v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDA48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBDA5C(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 27, &v6);
  id v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDABC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBDAD0(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 27, &v6);
  id v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDB2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBDB40(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 0, &v6);
  id v4 = sub_100FBCB1C(a1, a2, v6, @"entitlement-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDBA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBDBB8(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 1, &v6);
  id v4 = sub_100FBCB1C(a1, a2, v6, @"entitlement-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDC1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBDC30(uint64_t a1, void *a2)
{
  id v6 = 0;
  sub_100FBA648(a1, 2, &v6);
  id v4 = sub_100FBCB1C(a1, a2, v6, @"provisioning-names");
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBDC94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBDCA8(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  long long v71 = 0;
  sub_100FBA648(a1, 3, &v71);
  if (a2)
  {
    if (*(void *)(v3 + 40))
    {
      uint64_t v53 = v71;
      if ([a2 count])
      {
        id v4 = sub_100FB9EE4(v3, (uint64_t)v53);
        if (v4)
        {
          id v5 = objc_msgSend(objc_msgSend(v4, "info"), "objectForKey:", @"provisioning-elements");
          if (v5)
          {
            id v56 = (id)objc_opt_new();
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            id v58 = [a2 countByEnumeratingWithState:&v67 objects:v85 count:16];
            if (v58)
            {
              uint64_t v57 = *(void *)v68;
              CFStringRef v7 = @"state";
              CFStringRef v8 = @"data";
              *(void *)&long long v6 = 136316418;
              long long v52 = v6;
              uint64_t v54 = v3;
              id v55 = a2;
              do
              {
                for (int i = 0; i != v58; int i = (char *)i + 1)
                {
                  if (*(void *)v68 != v57) {
                    objc_enumerationMutation(a2);
                  }
                  uint64_t v62 = *(void **)(*((void *)&v67 + 1) + 8 * i);
                  id v9 = objc_msgSend(v62, "objectForKey:", @"name", v52);
                  if (v9)
                  {
                    for (uint64_t j = 0; ; ++j)
                    {
                      CFStringRef v11 = v8;
                      CFStringRef v12 = v7;
                      if (j >= [v5 count]) {
                        goto LABEL_43;
                      }
                      id v13 = [v5 objectAtIndex:j];
                      id v14 = [v13 objectForKey:@"name"];
                      if (v14)
                      {
                        if ([v14 isEqual:v9]
                          && [v13 isEqual:v62])
                        {
                          break;
                        }
                      }
                    }
                    id v15 = [v13 objectForKey:v7];
                    id v16 = [v62 objectForKey:v12];
                    if (v16 && v15 && [v16 isEqual:v15])
                    {
                      id v17 = [v13 objectForKey:v8];
                      id v18 = [v62 objectForKey:v8];
                      if (!v17)
                      {
                        __int16 v34 = **(NSObject ***)(v3 + 56);
                        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_43;
                        }
                        uint64_t v35 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                        uint64_t v37 = *(void *)(v54 + 64);
                        uint64_t v36 = *(void *)(v54 + 72);
                        id v38 = [v9 cStringUsingEncoding:4];
                        id v39 = [v53 cStringUsingEncoding:4];
                        *(_DWORD *)int buf = v52;
                        uint64_t v74 = v35;
                        __int16 v75 = 2080;
                        uint64_t v76 = " ";
                        __int16 v77 = 2080;
                        uint64_t v78 = v37;
                        __int16 v79 = 2080;
                        uint64_t v80 = v36;
                        __int16 v81 = 2080;
                        id v82 = v38;
                        __int16 v83 = 2080;
                        id v84 = v39;
                        __int16 v26 = v34;
                        uint64_t v27 = "#I %s%s%s%staking out %s from %s - wide one already queried";
                        goto LABEL_42;
                      }
                      uint64_t v19 = v18;
                      if (!v18)
                      {
                        [v56 addObject:v62];
                        goto LABEL_43;
                      }
                      if ([v17 isEqual:v18])
                      {
                        __int16 v20 = **(NSObject ***)(v3 + 56);
                        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_43;
                        }
                        uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                        uint64_t v23 = *(void *)(v54 + 64);
                        uint64_t v22 = *(void *)(v54 + 72);
                        id v24 = [v9 cStringUsingEncoding:4];
                        id v25 = [v53 cStringUsingEncoding:4];
                        *(_DWORD *)int buf = v52;
                        uint64_t v74 = v21;
                        __int16 v75 = 2080;
                        uint64_t v76 = " ";
                        __int16 v77 = 2080;
                        uint64_t v78 = v23;
                        __int16 v79 = 2080;
                        uint64_t v80 = v22;
                        __int16 v81 = 2080;
                        id v82 = v24;
                        __int16 v83 = 2080;
                        id v84 = v25;
                        __int16 v26 = v20;
                        uint64_t v27 = "#I %s%s%s%staking out %s from %s - already queried";
                        goto LABEL_42;
                      }
                      id v59 = (id)objc_opt_new();
                      long long v65 = 0u;
                      long long v66 = 0u;
                      long long v63 = 0u;
                      long long v64 = 0u;
                      obuint64_t j = v19;
                      id v40 = [v19 countByEnumeratingWithState:&v63 objects:v72 count:16];
                      if (v40)
                      {
                        uint64_t v41 = *(void *)v64;
                        do
                        {
                          for (k = 0; k != v40; k = (char *)k + 1)
                          {
                            if (*(void *)v64 != v41) {
                              objc_enumerationMutation(obj);
                            }
                            uint64_t v43 = *(void *)(*((void *)&v63 + 1) + 8 * (void)k);
                            if (([v17 containsObject:v43] & 1) == 0) {
                              [v59 addObject:v43];
                            }
                          }
                          id v40 = [obj countByEnumeratingWithState:&v63 objects:v72 count:16];
                        }
                        while (v40);
                      }
                      id v44 = [v62 mutableCopy];
                      [v44 setValue:v59 forKey:v11];
                      [v56 addObject:v44];
                      uint64_t v3 = v54;
                      id v45 = **(NSObject ***)(v54 + 56);
                      a2 = v55;
                      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v46 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v54 + 16));
                        uint64_t v48 = *(void *)(v54 + 64);
                        uint64_t v47 = *(void *)(v54 + 72);
                        id v49 = [v9 cStringUsingEncoding:4];
                        id v50 = [v53 cStringUsingEncoding:4];
                        *(_DWORD *)int buf = v52;
                        uint64_t v74 = v46;
                        __int16 v75 = 2080;
                        uint64_t v76 = " ";
                        __int16 v77 = 2080;
                        uint64_t v78 = v48;
                        __int16 v79 = 2080;
                        uint64_t v80 = v47;
                        __int16 v81 = 2080;
                        id v82 = v49;
                        __int16 v83 = 2080;
                        id v84 = v50;
                        __int16 v26 = v45;
                        uint64_t v27 = "#I %s%s%s%sreplace %s in %s with wide one";
LABEL_42:
                        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, 0x3Eu);
                        uint64_t v3 = v54;
                      }
                    }
                    else
                    {
                      __int16 v28 = **(NSObject ***)(v3 + 56);
                      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
                        uint64_t v30 = v3;
                        uint64_t v32 = *(void *)(v3 + 64);
                        uint64_t v31 = *(void *)(v3 + 72);
                        id v33 = [v9 cStringUsingEncoding:4];
                        *(_DWORD *)int buf = 136316162;
                        uint64_t v74 = v29;
                        __int16 v75 = 2080;
                        uint64_t v76 = " ";
                        __int16 v77 = 2080;
                        uint64_t v78 = v32;
                        __int16 v79 = 2080;
                        uint64_t v80 = v31;
                        __int16 v81 = 2080;
                        id v82 = v33;
                        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%ssetProvisioning '%s' state is missing or mismatch. Ignore", buf, 0x34u);
                        uint64_t v3 = v30;
                        a2 = v55;
                      }
                    }
LABEL_43:
                    CFStringRef v7 = v12;
                    CFStringRef v8 = v11;
                    if ([v5 count] == j) {
                      [v56 addObject:v62];
                    }
                  }
                }
                id v58 = [a2 countByEnumeratingWithState:&v67 objects:v85 count:16];
              }
              while (v58);
            }
            a2 = v56;
          }
        }
      }
    }
  }
  sub_1000558F4((const void **)&v71);
  return a2;
}

void sub_100FBE31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,const void *a40)
{
}

void *sub_100FBE398(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 4, &v6);
  id v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE3F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE40C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 4, &v6);
  id v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBE47C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 5, &v6);
  id v4 = sub_100FBD184(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE4D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBE4EC(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 6, &v6);
  uint64_t v4 = sub_100FBCD58(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBE55C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 6, &v6);
  id v4 = sub_100FBD184(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE5B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBE5CC(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 13, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0) != 0;
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE630(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE644(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 13, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE6A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBE6B4(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 12, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0) != 0;
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE72C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 12, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE788(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE79C(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 14, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE7FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE810(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 14, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE86C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE880(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 15, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE8E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE8F4(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 15, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBE950(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBE964(uint64_t a1)
{
  BOOL v4 = 0;
  sub_100FBA648(a1, 16, &v4);
  id v2 = sub_100FBC4EC(a1, v4);
  sub_1000558F4((const void **)&v4);
  return v2;
}

void sub_100FBE9B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBE9CC(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 17, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEA2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEA40(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 17, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEA9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEAB0(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 18, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEB10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEB24(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 20, &v6);
  BOOL v4 = sub_100FBD44C(a1, a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEB84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEB98(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 18, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEBF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEC08(uint64_t a1, void *a2)
{
  long long v6 = 0;
  sub_100FBA648(a1, 20, &v6);
  BOOL v4 = sub_100FBD670(a1, a2, v6);
  sub_1000558F4((const void **)&v6);
  return v4;
}

void sub_100FBEC64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBEC78(uint64_t a1)
{
  BOOL v4 = 0;
  sub_100FBA648(a1, 19, &v4);
  BOOL v2 = sub_100FBC4EC(a1, v4) != 0;
  sub_1000558F4((const void **)&v4);
  return v2;
}

void sub_100FBECD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBECE4(uint64_t a1)
{
  BOOL v4 = 0;
  sub_100FBA648(a1, 8, &v4);
  BOOL v2 = sub_100FBC4EC(a1, v4) != 0;
  sub_1000558F4((const void **)&v4);
  return v2;
}

void sub_100FBED3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBED50(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  id v9 = 0;
  sub_100FBA648(a1, a2, &v9);
  BOOL v7 = sub_100FBD44C(a1, a3, v9, a4) != 0;
  sub_1000558F4((const void **)&v9);
  return v7;
}

void sub_100FBEDBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100FBEDD0(uint64_t a1, int a2, void *a3)
{
  BOOL v7 = 0;
  sub_100FBA648(a1, a2, &v7);
  id v5 = sub_100FBD670(a1, a3, v7);
  sub_1000558F4((const void **)&v7);
  return v5;
}

void sub_100FBEE28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FBEE3C(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  id v9 = 0;
  sub_100FBA648(a1, a2, &v9);
  BOOL v7 = sub_100FBD44C(a1, a3, v9, a4) != 0;
  sub_1000558F4((const void **)&v9);
  return v7;
}

void sub_100FBEEA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_100FBEEBC(uint64_t a1, int a2, int a3)
{
  uint64_t v18 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v18);
  if (*(void *)(a1 + 40))
  {
    id v6 = sub_100FBA740(a1, 11);
    id v17 = 0;
    sub_100FBA648(a1, 11, &v17);
    id v7 = v6;
    if (v6
      || (id v7 = +[SubscriberRequestTransactionElement requestWithAction:v17 andAnnotation:0]) != 0)
    {
      if (a3)
      {
        CFStringRef v8 = (capabilities::ct *)[v7 info];
        if (capabilities::ct::supportsVoiceCall(v8)) {
          id v9 = +[NSArray arrayWithObjects:@"voice", @"data", @"message", 0];
        }
        else {
          id v9 = +[NSArray arrayWithObjects:@"data", 0];
        }
        [(capabilities::ct *)v8 setObject:v9 forKey:@"usage-types"];
      }
      if (a2)
      {
        uint64_t v10 = (capabilities::ct *)[v7 info];
        if (capabilities::ct::supportsVoiceCall(v10)) {
          CFStringRef v11 = +[NSArray arrayWithObjects:@"voice", @"data", @"message", @"account-info", 0];
        }
        else {
          CFStringRef v11 = +[NSArray arrayWithObjects:@"data", @"account-info", 0];
        }
        [(capabilities::ct *)v10 setObject:v11 forKey:@"subscription-types"];
      }
      if (!v6) {
        sub_100FB9A10(a1, (uint64_t)v17, v7);
      }
    }
    else
    {
      CFStringRef v12 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v14 = *(void *)(a1 + 64);
        uint64_t v15 = *(void *)(a1 + 72);
        *(_DWORD *)int buf = 136315906;
        uint64_t v20 = v13;
        __int16 v21 = 2080;
        uint64_t v22 = " ";
        __int16 v23 = 2080;
        uint64_t v24 = v14;
        __int16 v25 = 2080;
        uint64_t v26 = v15;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate subscription and usage status request", buf, 0x2Au);
      }
      id v7 = 0;
    }
    sub_1000558F4(&v17);
  }
  else
  {
    id v7 = 0;
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v18);
  return v7;
}

void sub_100FBF12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  id v6 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100FBF160(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v119 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v119);
  if (*(void *)(a1 + 40))
  {
    if (a2)
    {
      int v118 = 0;
      sub_100FBA648(a1, 28, &v118);
      id v16 = +[SubscriberRequestTransactionElement requestWithAction:v118 andAnnotation:0];
      id v17 = v16;
      if (!v16)
      {
        __int16 v25 = **(NSObject ***)(a1 + 56);
        uint64_t v21 = 0;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v27 = *(void *)(a1 + 64);
          uint64_t v28 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v26;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v128 = v27;
          __int16 v129 = 2080;
          uint64_t v130 = v28;
          uint64_t v29 = "#W %s%s%s%sUnable to allocation authentication request";
          uint64_t v30 = v25;
          uint32_t v31 = 42;
LABEL_104:
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
LABEL_112:
          uint64_t v21 = 0;
          goto LABEL_113;
        }
        goto LABEL_113;
      }
      id v18 = [v16 info];
      if (a2 > 5) {
        CFStringRef v19 = @"???";
      }
      else {
        CFStringRef v19 = (const __CFString *)*((void *)&off_101A7BCC0 + (int)(a2 - 1));
      }
      [v18 setValue:v19 forKey:@"auth-type"];
      unsigned int v32 = a2 - 3;
      if (a2 - 3 > 2)
      {
        if (a2 <= 2)
        {
          id v40 = [*(id *)(a1 + 40) objectEnumerator];
          uint64_t v41 = v40;
          long long v101 = v17;
          if (v40)
          {
            long long v125 = 0u;
            long long v126 = 0u;
            *(_OWORD *)std::string __p = 0u;
            long long v124 = 0u;
            __int16 v42 = (char *)[v40 countByEnumeratingWithState:__p objects:buf count:16];
            if (v42)
            {
              uint64_t v43 = *(void *)v124;
              uint64_t v100 = a6;
              while (2)
              {
                for (int i = 0; i != v42; ++i)
                {
                  if (*(void *)v124 != v43) {
                    objc_enumerationMutation(v41);
                  }
                  if ([*((id *)__p[1] + i) requiresSecureIntent])
                  {
                    a6 = v100;
                    id v17 = v101;
                    objc_msgSend(objc_msgSend(v101, "info"), "setValue:forKey:", &__kCFBooleanTrue, @"retrieve-nonce");
                    goto LABEL_70;
                  }
                }
                __int16 v42 = (char *)[v41 countByEnumeratingWithState:__p objects:buf count:16];
                a6 = v100;
                if (v42) {
                  continue;
                }
                break;
              }
            }
          }
          id v17 = v101;
          uint64_t v45 = *(unsigned __int8 *)(a7 + 23);
          if ((v45 & 0x80u) != 0) {
            uint64_t v45 = *(void *)(a7 + 8);
          }
          if (v45 && (sub_100FC012C(a1) & 1) == 0)
          {
            CFTypeRef cf = 0;
            __p[0] = 0;
            if ((ctu::cf::convert_copy() & 1) == 0)
            {
              long long v65 = **(NSObject ***)(a1 + 56);
              if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_111;
              }
              uint64_t v94 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
              uint64_t v95 = *(void *)(a1 + 64);
              uint64_t v96 = *(void *)(a1 + 72);
              *(_DWORD *)int buf = 136315906;
              *(void *)&uint8_t buf[4] = v94;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              uint64_t v128 = v95;
              __int16 v129 = 2080;
              uint64_t v130 = v96;
              long long v69 = "#W %s%s%s%sError converting token";
              goto LABEL_81;
            }
            CFTypeRef v46 = cf;
            CFTypeRef cf = __p[0];
            *(void *)int buf = v46;
            sub_1000558F4((const void **)buf);
            id v47 = [v101 info];
            sub_100083DA4(&v107, &cf);
            [v47 setValue:v107 forKey:@"token"];
            sub_1000558F4(&v107);
            sub_1000558F4(&cf);
          }
        }
LABEL_70:
        uint64_t v59 = *(unsigned __int8 *)(a3 + 23);
        if ((v59 & 0x80u) != 0) {
          uint64_t v59 = *(void *)(a3 + 8);
        }
        if (!v59)
        {
          uint64_t v36 = **(NSObject ***)(a1 + 56);
          uint64_t v21 = 0;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v63 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            if (a2 > 5) {
              long long v64 = "";
            }
            else {
              long long v64 = off_101A7BD00[a2];
            }
            uint64_t v86 = *(void *)(a1 + 64);
            uint64_t v85 = *(void *)(a1 + 72);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v63;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v128 = v86;
            __int16 v129 = 2080;
            uint64_t v130 = v85;
            __int16 v131 = 2080;
            xpc_object_t v132 = v64;
            uint64_t v29 = "#W %s%s%s%sAuthType is '%s' but SubscriberID is missing";
            goto LABEL_103;
          }
LABEL_113:
          sub_1000558F4(&v118);
          goto LABEL_114;
        }
        CFTypeRef cf = 0;
        __p[0] = 0;
        if (ctu::cf::convert_copy())
        {
          CFTypeRef v60 = cf;
          CFTypeRef cf = __p[0];
          *(void *)int buf = v60;
          sub_1000558F4((const void **)buf);
          id v61 = [v17 info];
          CFTypeRef v106 = cf;
          if (cf)
          {
            CFRetain(cf);
            uint64_t v62 = v106;
          }
          else
          {
            uint64_t v62 = 0;
          }
          [v61 setValue:v62 forKey:@"subscriber-id"];
          sub_1000558F4(&v106);
          uint64_t v70 = *(unsigned __int8 *)(a4 + 23);
          if ((v70 & 0x80u) != 0) {
            uint64_t v70 = *(void *)(a4 + 8);
          }
          if (v70)
          {
            xpc_object_t v121 = 0;
            __p[0] = 0;
            if ((ctu::cf::convert_copy() & 1) == 0)
            {
              uint64_t v80 = **(NSObject ***)(a1 + 56);
              if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v81 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
                uint64_t v82 = *(void *)(a1 + 64);
                uint64_t v83 = *(void *)(a1 + 72);
                *(_DWORD *)int buf = 136315906;
                *(void *)&uint8_t buf[4] = v81;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                *(_WORD *)&unsigned char buf[22] = 2080;
                uint64_t v128 = v82;
                __int16 v129 = 2080;
                uint64_t v130 = v83;
                id v84 = "#W %s%s%s%sError converting uniqueId";
LABEL_109:
                _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, v84, buf, 0x2Au);
              }
LABEL_110:
              sub_1000558F4(&v121);
              goto LABEL_111;
            }
            long long v71 = v121;
            xpc_object_t v121 = __p[0];
            *(void *)int buf = v71;
            sub_1000558F4((const void **)buf);
            id v72 = [v17 info];
            sub_100083DA4(&v105, &v121);
            [v72 setValue:v105 forKey:@"unique-id"];
            sub_1000558F4(&v105);
            sub_1000558F4(&v121);
          }
          uint64_t v73 = *(unsigned __int8 *)(a5 + 23);
          if ((v73 & 0x80u) != 0) {
            uint64_t v73 = *(void *)(a5 + 8);
          }
          if (!v73) {
            goto LABEL_93;
          }
          xpc_object_t v121 = 0;
          __p[0] = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v74 = v121;
            xpc_object_t v121 = __p[0];
            *(void *)int buf = v74;
            sub_1000558F4((const void **)buf);
            id v75 = [v17 info];
            sub_100083DA4(&v104, &v121);
            [v75 setValue:v104 forKey:@"alias-id"];
            sub_1000558F4(&v104);
            sub_1000558F4(&v121);
LABEL_93:
            uint64_t v76 = *(unsigned __int8 *)(a6 + 23);
            if ((v76 & 0x80u) != 0) {
              uint64_t v76 = *(void *)(a6 + 8);
            }
            if (!v76) {
              goto LABEL_98;
            }
            xpc_object_t v121 = 0;
            __p[0] = 0;
            if (ctu::cf::convert_copy())
            {
              __int16 v77 = v121;
              xpc_object_t v121 = __p[0];
              *(void *)int buf = v77;
              sub_1000558F4((const void **)buf);
              id v78 = [v17 info];
              sub_100083DA4(&v103, &v121);
              [v78 setValue:v103 forKey:@"device-account-identifier"];
              sub_1000558F4(&v103);
              sub_1000558F4(&v121);
LABEL_98:
              p_CFTypeRef cf = &cf;
LABEL_133:
              sub_1000558F4(p_cf);
              sub_100FB9A10(a1, (uint64_t)v118, v17);
              uint64_t v21 = 1;
              goto LABEL_113;
            }
            uint64_t v80 = **(NSObject ***)(a1 + 56);
            if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_110;
            }
            uint64_t v90 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            uint64_t v91 = *(void *)(a1 + 64);
            uint64_t v92 = *(void *)(a1 + 72);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v90;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v128 = v91;
            __int16 v129 = 2080;
            uint64_t v130 = v92;
            id v84 = "#W %s%s%s%sError converting deviceAccountId";
            goto LABEL_109;
          }
          uint64_t v80 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v87 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            uint64_t v88 = *(void *)(a1 + 64);
            uint64_t v89 = *(void *)(a1 + 72);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v87;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v128 = v88;
            __int16 v129 = 2080;
            uint64_t v130 = v89;
            id v84 = "#W %s%s%s%sError converting aliasId";
            goto LABEL_109;
          }
          goto LABEL_110;
        }
        long long v65 = **(NSObject ***)(a1 + 56);
        if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
LABEL_111:
          sub_1000558F4(&cf);
          goto LABEL_112;
        }
        uint64_t v66 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v67 = *(void *)(a1 + 64);
        uint64_t v68 = *(void *)(a1 + 72);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v66;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v128 = v67;
        __int16 v129 = 2080;
        uint64_t v130 = v68;
        long long v69 = "#W %s%s%s%sError converting subscriber string";
LABEL_81:
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, v69, buf, 0x2Au);
        goto LABEL_111;
      }
      uint64_t v33 = *(unsigned __int8 *)(a7 + 23);
      int v34 = (char)v33;
      unint64_t v35 = *(void *)(a7 + 8);
      if ((v33 & 0x80u) != 0) {
        uint64_t v33 = *(void *)(a7 + 8);
      }
      if (!v33)
      {
        uint64_t v36 = **(NSObject ***)(a1 + 56);
        uint64_t v21 = 0;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v48 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          if (v32 > 2) {
            id v49 = "";
          }
          else {
            id v49 = off_101A7BCE8[v32];
          }
          uint64_t v55 = *(void *)(a1 + 64);
          uint64_t v54 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v48;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v128 = v55;
          __int16 v129 = 2080;
          uint64_t v130 = v54;
          __int16 v131 = 2080;
          xpc_object_t v132 = v49;
          uint64_t v29 = "#I %s%s%s%sAuthType is '%s' but token-element is missing";
          goto LABEL_103;
        }
        goto LABEL_113;
      }
      if (a2 == 5 && !*(unsigned char *)(a8 + 24))
      {
        uint64_t v36 = **(NSObject ***)(a1 + 56);
        uint64_t v21 = 0;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v39 = *(void *)(a1 + 64);
          uint64_t v38 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v128 = v39;
          __int16 v129 = 2080;
          uint64_t v130 = v38;
          __int16 v131 = 2080;
          xpc_object_t v132 = "blind-signature";
          uint64_t v29 = "#I %s%s%s%sAuthType is '%s' but token-element association is missing";
LABEL_103:
          uint64_t v30 = v36;
          uint32_t v31 = 52;
          goto LABEL_104;
        }
        goto LABEL_113;
      }
      int64_t value = 0;
      if (v34 < 0)
      {
        sub_10004FC84(__dst, *(void **)a7, v35);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)a7;
        uint64_t v116 = *(void *)(a7 + 16);
      }
      if (SHIBYTE(v116) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        *(void *)&long long v124 = v116;
      }
      uint64_t v120 = 0;
      if (SBYTE7(v124) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)int buf = *(_OWORD *)__p;
        *(void *)&uint8_t buf[16] = v124;
      }
      xpc_object_t v121 = 0;
      if (ctu::cf::convert_copy())
      {
        id v50 = v120;
        uint64_t v120 = (void *)v121;
        CFTypeRef cf = v50;
        sub_1000558F4(&cf);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      int64_t value = v120;
      uint64_t v120 = 0;
      sub_1000558F4((const void **)&v120);
      if (SBYTE7(v124) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v116) < 0) {
        operator delete(__dst[0]);
      }
      switch(a2)
      {
        case 3u:
          id v56 = [v17 info];
          uint64_t v57 = &v114;
          sub_100083DA4(&v114, (const void **)&value);
          [v56 setValue:v114 forKey:@"service-token"];
          break;
        case 4u:
          id v58 = [v17 info];
          uint64_t v57 = &v113;
          sub_100083DA4(&v113, (const void **)&value);
          [v58 setValue:v113 forKey:@"transfer-token"];
          break;
        case 5u:
          CFMutableDictionaryRef theDict = 0;
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            CFMutableDictionaryRef v52 = theDict;
            CFMutableDictionaryRef theDict = Mutable;
            *(void *)int buf = v52;
            sub_10005717C((const void **)buf);
          }
          CFDictionarySetValue(theDict, @"unblinded-sig", value);
          uint64_t v53 = theDict;
          if (*(char *)(a8 + 23) < 0)
          {
            sub_10004FC84(v109, *(void **)a8, *(void *)(a8 + 8));
          }
          else
          {
            *(_OWORD *)uint64_t v109 = *(_OWORD *)a8;
            uint64_t v110 = *(void *)(a8 + 16);
          }
          if (SHIBYTE(v110) < 0)
          {
            sub_10004FC84(__p, v109[0], (unint64_t)v109[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v109;
            *(void *)&long long v124 = v110;
          }
          uint64_t v120 = 0;
          if (SBYTE7(v124) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)int buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v124;
          }
          xpc_object_t v121 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v97 = v120;
            uint64_t v120 = (void *)v121;
            CFTypeRef cf = v97;
            sub_1000558F4(&cf);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          int v98 = v120;
          int v111 = v120;
          uint64_t v120 = 0;
          sub_1000558F4((const void **)&v120);
          if (SBYTE7(v124) < 0) {
            operator delete(__p[0]);
          }
          CFDictionarySetValue(v53, @"unblinded-token", v98);
          sub_1000558F4(&v111);
          if (SHIBYTE(v110) < 0) {
            operator delete(v109[0]);
          }
          id v99 = [v17 info];
          sub_100057240(&v108, (const void **)&theDict);
          [v99 setValue:v108 forKey:@"unblinded-data"];
          sub_10005717C(&v108);
          sub_10005717C((const void **)&theDict);
          p_CFTypeRef cf = (const void **)&value;
          goto LABEL_133;
        default:
          goto LABEL_69;
      }
      sub_1000558F4(v57);
LABEL_69:
      sub_1000558F4((const void **)&value);
      goto LABEL_70;
    }
    uint64_t v21 = 1;
  }
  else
  {
    uint64_t v20 = **(NSObject ***)(a1 + 56);
    uint64_t v21 = 0;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v23 = *(void *)(a1 + 64);
      uint64_t v24 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v128 = v23;
      __int16 v129 = 2080;
      uint64_t v130 = v24;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%s'fRequests' empty - nothing to add Authentication to - bail-out", buf, 0x2Au);
      uint64_t v21 = 0;
    }
  }
LABEL_114:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v119);
  return v21;
}

void sub_100FBFF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,const void *a32,__int16 a33,uint64_t a34,uint64_t a35,const void *a36)
{
}

uint64_t sub_100FC012C(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 40) objectEnumerator];
  if (v3
    && (BOOL v4 = v3,
        long long v13 = 0u,
        long long v14 = 0u,
        long long v11 = 0u,
        long long v12 = 0u,
        (id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16]) != 0))
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    while (2)
    {
      for (int i = 0; i != v6; int i = (char *)i + 1)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        if ([*(id *)(*((void *)&v11 + 1) + 8 * i) requiresFullAuthentication])
        {
          uint64_t v9 = 1;
          goto LABEL_13;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      uint64_t v9 = 0;
      if (v6) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
LABEL_13:
  return v9;
}

void sub_100FC0248(uint64_t a1)
{
  uint64_t v3 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v3);
  uint64_t v2 = 0;
  sub_100FBA648(a1, 28, &v2);
  sub_100FBA370(a1, v2);
  sub_1000558F4((const void **)&v2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v3);
}

void sub_100FC02AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, char a10)
{
}

BOOL sub_100FC02D0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v25 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v25);
  uint64_t v6 = *((unsigned __int8 *)a2 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = a2[1];
  }
  if (v6)
  {
    uint64_t v24 = 0;
    sub_100FBA648(a1, 29, &v24);
    id v7 = +[SubscriberRequestTransactionElement requestWithAction:v24 andAnnotation:0];
    CFStringRef v8 = v7;
    BOOL v9 = v7 != 0;
    if (v7)
    {
      id v10 = [v7 info];
      if (*((char *)a2 + 23) >= 0) {
        long long v11 = a2;
      }
      else {
        long long v11 = (uint64_t *)*a2;
      }
      objc_msgSend(v10, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11), @"payload");
      uint64_t v12 = *((unsigned __int8 *)a3 + 23);
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = a3[1];
      }
      if (v12)
      {
        id v13 = [v8 info];
        if (*((char *)a3 + 23) >= 0) {
          long long v14 = a3;
        }
        else {
          long long v14 = (uint64_t *)*a3;
        }
        objc_msgSend(v13, "setObject:forKey:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14), @"euicc-signature");
      }
      sub_100FB9A10(a1, (uint64_t)v24, v8);
    }
    else
    {
      CFStringRef v19 = **(NSObject ***)(a1 + 56);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
        uint64_t v21 = *(void *)(a1 + 64);
        uint64_t v22 = *(void *)(a1 + 72);
        *(_DWORD *)int buf = 136315906;
        uint64_t v27 = v20;
        __int16 v28 = 2080;
        uint64_t v29 = " ";
        __int16 v30 = 2080;
        uint64_t v31 = v21;
        __int16 v32 = 2080;
        uint64_t v33 = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to allocate challenge request", buf, 0x2Au);
      }
    }
    sub_1000558F4(&v24);
  }
  else
  {
    uint64_t v15 = **(NSObject ***)(a1 + 56);
    BOOL v9 = 0;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v17 = *(void *)(a1 + 64);
      uint64_t v18 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      uint64_t v27 = v16;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v17;
      __int16 v32 = 2080;
      uint64_t v33 = v18;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sChallenge Payload is invalid", buf, 0x2Au);
      BOOL v9 = 0;
    }
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v25);
  return v9;
}

void sub_100FC0560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, char a10)
{
}

void sub_100FC0594(uint64_t a1)
{
  uint64_t v3 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v3);
  sub_100FBA648(a1, 29, &v2);
  sub_100FBA370(a1, v2);
  sub_1000558F4((const void **)&v2);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v3);
}

void sub_100FC05F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, char a10)
{
}

uint64_t sub_100FC0618(uint64_t a1, void *a2)
{
  uint64_t v25 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v25);
  if (!a2[2])
  {
    id v13 = **(NSObject ***)(a1 + 56);
    uint64_t v4 = 0;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    long long v14 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = *(void *)(a1 + 72);
    LODWORD(__p[0]) = 136315906;
    *(void **)((char *)__p + 4) = v14;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    uint64_t v27 = v15;
    __int16 v28 = 2080;
    uint64_t v29 = v16;
    uint64_t v17 = "#W %s%s%s%sVVM command is invalid";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)__p, 0x2Au);
    uint64_t v4 = 0;
    goto LABEL_27;
  }
  uint64_t v4 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:");
  if (!v4)
  {
    id v13 = **(NSObject ***)(a1 + 56);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    uint64_t v18 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v19 = *(void *)(a1 + 64);
    uint64_t v20 = *(void *)(a1 + 72);
    LODWORD(__p[0]) = 136315906;
    *(void **)((char *)__p + 4) = v18;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    uint64_t v27 = v19;
    __int16 v28 = 2080;
    uint64_t v29 = v20;
    uint64_t v17 = "#W %s%s%s%sUnable to allocate VVM command array";
    goto LABEL_26;
  }
  id v7 = (void *)*a2;
  id v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      CFStringRef v8 = (void *)*((unsigned __int8 *)v6 + 25);
      if (v8 != 4)
      {
        memset(__p, 0, sizeof(__p));
        sub_100C8DF84(v8, __p);
        if (SHIBYTE(__p[2]) < 0)
        {
          if (!__p[1]) {
            goto LABEL_11;
          }
          BOOL v9 = (void **)__p[0];
        }
        else
        {
          if (!HIBYTE(__p[2])) {
            goto LABEL_12;
          }
          BOOL v9 = __p;
        }
        objc_msgSend((id)v4, "addObject:", +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v9, 1));
        if (SHIBYTE(__p[2]) < 0) {
LABEL_11:
        }
          operator delete(__p[0]);
      }
LABEL_12:
      id v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          id v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v11 = (void *)v6[2];
          BOOL v12 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v12);
      }
      uint64_t v6 = v11;
    }
    while (v11 != v5);
  }
  if (![(id)v4 count])
  {
    id v13 = **(NSObject ***)(a1 + 56);
    uint64_t v4 = 0;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    uint64_t v21 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v22 = *(void *)(a1 + 64);
    uint64_t v23 = *(void *)(a1 + 72);
    LODWORD(__p[0]) = 136315906;
    *(void **)((char *)__p + 4) = v21;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    HIWORD(__p[2]) = 2080;
    uint64_t v27 = v22;
    __int16 v28 = 2080;
    uint64_t v29 = v23;
    uint64_t v17 = "#W %s%s%s%sVVM command array contained no commands";
    goto LABEL_26;
  }
  uint64_t v4 = sub_100FBC380(a1, v4);
LABEL_27:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v25);
  return v4;
}

void sub_100FC08EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_100FC0930(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)uint64_t v53 = a2;
  uint64_t v56 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v56);
  id v3 = (id)objc_opt_new();
  id v4 = (id)objc_opt_new();
  id v5 = (id)objc_opt_new();
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  id v6 = [*(id *)(a1 + 40) allValues];
  id v7 = [v6 countByEnumeratingWithState:&v71 objects:v88 count:16];
  if (!v7)
  {
    id v55 = 0;
    goto LABEL_19;
  }
  id v55 = 0;
  uint64_t v8 = *(void *)v72;
  do
  {
    for (int i = 0; i != v7; int i = (char *)i + 1)
    {
      if (*(void *)v72 != v8) {
        objc_enumerationMutation(v6);
      }
      id v10 = *(void **)(*((void *)&v71 + 1) + 8 * i);
      id v11 = objc_msgSend(v10, "action", *(void *)v53);
      sub_100FBA648(a1, 28, v87);
      if ([v11 isEqualToString:v87[0]])
      {
        sub_1000558F4(v87);
        BOOL v12 = v3;
      }
      else
      {
        id v13 = [v10 action];
        sub_100FBA648(a1, 29, v86);
        LODWORD(v13) = [v13 isEqualToString:v86[0]];
        sub_1000558F4(v86);
        sub_1000558F4(v87);
        BOOL v12 = v3;
        if (!v13)
        {
          id v14 = [v10 action];
          sub_100FBA648(a1, 4, v87);
          LODWORD(v14) = [v14 isEqualToString:v87[0]];
          sub_1000558F4(v87);
          if (v14)
          {
            id v55 = v10;
            continue;
          }
          if (objc_msgSend(objc_msgSend(v10, "action"), "hasPrefix:", @"get")) {
            BOOL v12 = v5;
          }
          else {
            BOOL v12 = v4;
          }
        }
      }
      [v12 addObject:v10];
    }
    id v7 = [v6 countByEnumeratingWithState:&v71 objects:v88 count:16];
  }
  while (v7);
LABEL_19:
  objc_msgSend(*(id *)(a1 + 40), "removeAllObjects", *(void *)v53);
  id v15 = (id)objc_opt_new();
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  id v16 = [v3 countByEnumeratingWithState:&v67 objects:v87 count:16];
  if (v16)
  {
    uint64_t v17 = *(void *)v68;
    do
    {
      for (uint64_t j = 0; j != v16; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v68 != v17) {
          objc_enumerationMutation(v3);
        }
        uint64_t v19 = *(void **)(*((void *)&v67 + 1) + 8 * (void)j);
        ++*(_DWORD *)(a1 + 32);
        objc_msgSend(v19, "setIdentifier:");
        objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v19, objc_msgSend(v19, "identifier"));
        objc_msgSend(v15, "addObject:", objc_msgSend(v19, "info"));
      }
      id v16 = [v3 countByEnumeratingWithState:&v67 objects:v87 count:16];
    }
    while (v16);
  }
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  id v20 = [v4 countByEnumeratingWithState:&v63 objects:v86 count:16];
  if (v20)
  {
    uint64_t v21 = *(void *)v64;
    do
    {
      for (k = 0; k != v20; k = (char *)k + 1)
      {
        if (*(void *)v64 != v21) {
          objc_enumerationMutation(v4);
        }
        uint64_t v23 = *(void **)(*((void *)&v63 + 1) + 8 * (void)k);
        ++*(_DWORD *)(a1 + 32);
        objc_msgSend(v23, "setIdentifier:");
        objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v23, objc_msgSend(v23, "identifier"));
        objc_msgSend(v15, "addObject:", objc_msgSend(v23, "info"));
      }
      id v20 = [v4 countByEnumeratingWithState:&v63 objects:v86 count:16];
    }
    while (v20);
  }
  if (v55)
  {
    ++*(_DWORD *)(a1 + 32);
    objc_msgSend(v55, "setIdentifier:");
    objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v55, objc_msgSend(v55, "identifier"));
    objc_msgSend(v15, "addObject:", objc_msgSend(v55, "info"));
  }
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  id v24 = [v5 countByEnumeratingWithState:&v59 objects:v85 count:16];
  if (v24)
  {
    uint64_t v25 = *(void *)v60;
    do
    {
      for (m = 0; m != v24; m = (char *)m + 1)
      {
        if (*(void *)v60 != v25) {
          objc_enumerationMutation(v5);
        }
        uint64_t v27 = *(void **)(*((void *)&v59 + 1) + 8 * (void)m);
        ++*(_DWORD *)(a1 + 32);
        objc_msgSend(v27, "setIdentifier:");
        objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v27, objc_msgSend(v27, "identifier"));
        objc_msgSend(v15, "addObject:", objc_msgSend(v27, "info"));
      }
      id v24 = [v5 countByEnumeratingWithState:&v59 objects:v85 count:16];
    }
    while (v24);
  }
  __int16 v28 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v31 = *(void *)(a1 + 64);
    uint64_t v30 = *(void *)(a1 + 72);
    sub_100FBA118(a1, __p);
    __int16 v32 = v58 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)int buf = 136316162;
    uint64_t v76 = v29;
    __int16 v77 = 2080;
    id v78 = " ";
    __int16 v79 = 2080;
    uint64_t v80 = v31;
    __int16 v81 = 2080;
    uint64_t v82 = v30;
    __int16 v83 = 2082;
    id v84 = v32;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sFinal request includes %{public}s", buf, 0x34u);
    if (v58 < 0) {
      operator delete(__p[0]);
    }
  }
  *uint64_t v54 = 0;
  v54[1] = 0;
  v54[2] = 0;
  if (!v15
    || ![v15 count]
    || !+[NSJSONSerialization isValidJSONObject:v15])
  {
    uint64_t v41 = **(NSObject ***)(a1 + 56);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_60;
    }
    uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v43 = *(unsigned char **)(a1 + 64);
    uint64_t v44 = *(void *)(a1 + 72);
    *(_DWORD *)uint64_t v88 = 136315906;
    *(void *)&v88[4] = v42;
    *(_WORD *)&v88[12] = 2080;
    *(void *)&v88[14] = " ";
    __int16 v89 = 2080;
    uint64_t v90 = v43;
    __int16 v91 = 2080;
    uint64_t v92 = v44;
    uint64_t v45 = "#W %s%s%s%sInvalid JSON Object";
    goto LABEL_59;
  }
  v87[0] = 0;
  uint64_t v33 = +[NSJSONSerialization dataWithJSONObject:v15 options:1 error:v87];
  int v34 = v33;
  if (!v33 || ![(NSData *)v33 length])
  {
    uint64_t v41 = **(NSObject ***)(a1 + 56);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_60;
    }
    uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v51 = *(unsigned char **)(a1 + 64);
    uint64_t v52 = *(void *)(a1 + 72);
    *(_DWORD *)uint64_t v88 = 136315906;
    *(void *)&v88[4] = v50;
    *(_WORD *)&v88[12] = 2080;
    *(void *)&v88[14] = " ";
    __int16 v89 = 2080;
    uint64_t v90 = v51;
    __int16 v91 = 2080;
    uint64_t v92 = v52;
    uint64_t v45 = "#W %s%s%s%sUnable to serialize properly";
LABEL_59:
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v45, v88, 0x2Au);
    goto LABEL_60;
  }
  v54[1] = 0;
  unint64_t v35 = [(NSData *)v34 bytes];
  if (v35)
  {
    uint64_t v36 = [(NSData *)v34 length];
    sub_10016A4CC((uint64_t)v54, 0, v35, &v36[(void)v35], (int64_t)v36);
    uint64_t v37 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v39 = *(unsigned char **)(a1 + 64);
      uint64_t v40 = *(void *)(a1 + 72);
      *(_DWORD *)uint64_t v88 = 136315906;
      *(void *)&v88[4] = v38;
      *(_WORD *)&v88[12] = 2080;
      *(void *)&v88[14] = " ";
      __int16 v89 = 2080;
      uint64_t v90 = v39;
      __int16 v91 = 2080;
      uint64_t v92 = v40;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sGenerated Request:", v88, 0x2Au);
    }
    *(void *)uint64_t v88 = off_101A79380;
    *(void *)&v88[8] = a1;
    uint64_t v90 = v88;
    logger::CFTypeRefLogger();
    sub_10012C330(v88);
    goto LABEL_62;
  }
LABEL_60:
  CFTypeRef v46 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v48 = *(unsigned char **)(a1 + 64);
    uint64_t v49 = *(void *)(a1 + 72);
    *(_DWORD *)uint64_t v88 = 136315906;
    *(void *)&v88[4] = v47;
    *(_WORD *)&v88[12] = 2080;
    *(void *)&v88[14] = " ";
    __int16 v89 = 2080;
    uint64_t v90 = v48;
    __int16 v91 = 2080;
    uint64_t v92 = v49;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sUnable to generate JSON request", v88, 0x2Au);
  }
LABEL_62:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v56);
}

void sub_100FC119C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10012C330((void *)(v3 - 240));
  id v5 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v5;
    operator delete(v5);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)va);
  _Unwind_Resume(a1);
}

BOOL sub_100FC1234(uint64_t a1, const __CFData *a2, uint64_t *a3)
{
  uint64_t v189 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v189);
  if (a2) {
    CFIndex Length = CFDataGetLength(a2);
  }
  else {
    CFIndex Length = 0;
  }
  id v7 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v168 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = v168;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2048;
    unint64_t v193 = (uint8_t *)Length;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#D %s%sReceived %zu bytes of data", buf, 0x20u);
    id v7 = **(NSObject ***)(a1 + 56);
  }
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!Length)
  {
    if (v8)
    {
      uint64_t v145 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      int v146 = *(uint8_t **)(a1 + 64);
      uint64_t v147 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v145;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      unint64_t v193 = v146;
      __int16 v194 = 2080;
      uint64_t v195 = v147;
      long long v148 = "#W %s%s%s%sError with input data";
LABEL_128:
      int v149 = v7;
LABEL_133:
      uint32_t v154 = 42;
      goto LABEL_134;
    }
LABEL_135:
    uint64_t v17 = 0;
    goto LABEL_136;
  }
  if (v8)
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    id v10 = *(uint8_t **)(a1 + 64);
    uint64_t v11 = *(void *)(a1 + 72);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    unint64_t v193 = v10;
    __int16 v194 = 2080;
    uint64_t v195 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRAW JSON Response:", buf, 0x2Au);
  }
  *(void *)int buf = off_101A79400;
  *(void *)&uint8_t buf[8] = a1;
  unint64_t v193 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  uint64_t v188 = 0;
  id v12 = +[NSJSONSerialization JSONObjectWithData:a2 options:0 error:&v188];
  if (!v12)
  {
    uint64_t v150 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v151 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      uint64_t v152 = *(uint8_t **)(a1 + 64);
      uint64_t v153 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v151;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      unint64_t v193 = v152;
      __int16 v194 = 2080;
      uint64_t v195 = v153;
      __int16 v196 = 2112;
      uint64_t v197 = v188;
      long long v148 = "#W %s%s%s%sInvalid JSON response, error: %@";
      int v149 = v150;
      uint32_t v154 = 52;
LABEL_134:
      _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, v148, buf, v154);
      goto LABEL_135;
    }
    goto LABEL_135;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    uint64_t v155 = **(NSObject ***)(a1 + 56);
    if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v156 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
      xpc_object_t v157 = *(uint8_t **)(a1 + 64);
      uint64_t v158 = *(void *)(a1 + 72);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v156;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      unint64_t v193 = v157;
      __int16 v194 = 2080;
      uint64_t v195 = v158;
      long long v148 = "#W %s%s%s%sUnexpected JSON format, should be Array";
      int v149 = v155;
      goto LABEL_133;
    }
    goto LABEL_135;
  }
  id v13 = [v12 count];
  int v14 = (int)v13;
  unint64_t v15 = (void)v13 << 32;
  id v7 = **(NSObject ***)(a1 + 56);
  BOOL v16 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_135;
    }
    uint64_t v165 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    int v166 = *(uint8_t **)(a1 + 64);
    uint64_t v167 = *(void *)(a1 + 72);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v165;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    unint64_t v193 = v166;
    __int16 v194 = 2080;
    uint64_t v195 = v167;
    long long v148 = "#W %s%s%s%sEmpty JSON response";
    goto LABEL_128;
  }
  uint64_t v17 = v14;
  if (v16)
  {
    uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v19 = *(uint8_t **)(a1 + 64);
    uint64_t v20 = *(void *)(a1 + 72);
    uint64_t v21 = "";
    if (v15 > (unint64_t)&_mh_execute_header) {
      uint64_t v21 = "s";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v18;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    unint64_t v193 = v19;
    __int16 v194 = 2080;
    uint64_t v195 = v20;
    __int16 v196 = 2048;
    uint64_t v197 = v14;
    __int16 v198 = 2080;
    *(void *)v199 = v21;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived %lu Response%s", buf, 0x3Eu);
  }
  long long v186 = 0u;
  long long v187 = 0u;
  long long v184 = 0u;
  long long v185 = 0u;
  id v22 = [v12 countByEnumeratingWithState:&v184 objects:v200 count:16];
  if (v22)
  {
    uint64_t v170 = v14;
    int v174 = 0;
    uint64_t v182 = *(void *)v185;
    *(void *)&long long v23 = 136316418;
    long long v169 = v23;
    id v180 = v12;
    int v175 = a3;
    while (1)
    {
      id v24 = 0;
      id v176 = v22;
      do
      {
        if (*(void *)v185 != v182) {
          objc_enumerationMutation(v12);
        }
        uint64_t v25 = *(void *)(*((void *)&v184 + 1) + 8 * (void)v24);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v40 = **(NSObject ***)(a1 + 56);
          if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_44;
          }
          uint64_t v41 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v42 = *(uint8_t **)(a1 + 64);
          uint64_t v43 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          unint64_t v193 = v42;
          __int16 v194 = 2080;
          uint64_t v195 = v43;
          uint64_t v44 = v40;
          uint64_t v45 = "#W %s%s%s%sInvalid action response, skipping";
          goto LABEL_42;
        }
        id v26 = +[SubscriberResponseTransactionElement responseWithInfo:v25];
        [v26 identifier];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          CFTypeRef v46 = **(NSObject ***)(a1 + 56);
          if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_44;
          }
          uint64_t v47 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v48 = *(uint8_t **)(a1 + 64);
          uint64_t v49 = *(void *)(a1 + 72);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v47;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          unint64_t v193 = v48;
          __int16 v194 = 2080;
          uint64_t v195 = v49;
          uint64_t v44 = v46;
          uint64_t v45 = "#W %s%s%s%sResponse identifier is not a number";
LABEL_42:
          uint32_t v50 = 42;
          goto LABEL_43;
        }
        id v27 = objc_msgSend(*(id *)(a1 + 40), "objectForKey:", objc_msgSend(v26, "identifier"));
        id v28 = v27;
        uint64_t v181 = v26;
        if (!v27)
        {
          uint64_t v53 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            uint64_t v125 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            int v127 = *(uint8_t **)(a1 + 64);
            uint64_t v126 = *(void *)(a1 + 72);
            uint64_t v128 = (int *)[v26 identifier];
            __int16 v129 = v128;
            LODWORD(v190) = 0;
            if (v128)
            {
              CFTypeID v130 = CFGetTypeID(v128);
              if (v130 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&v190, v129, v131);
              }
            }
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v125;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v127;
            __int16 v194 = 2080;
            uint64_t v195 = v126;
            __int16 v196 = 1024;
            LODWORD(v197) = v190;
            _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "#E %s%s%s%sUnable to find matching request for response %d", buf, 0x30u);
            id v12 = v180;
            id v22 = v176;
            id v26 = v181;
          }
          id v54 = objc_msgSend(objc_msgSend(v26, "description", v169), "cStringUsingEncoding:", 4);
          if (v54)
          {
            id v55 = **(NSObject ***)(a1 + 56);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              uint64_t v56 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
              uint64_t v57 = *(uint8_t **)(a1 + 64);
              uint64_t v58 = *(void *)(a1 + 72);
              *(_DWORD *)int buf = 136316162;
              *(void *)&uint8_t buf[4] = v56;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              unint64_t v193 = v57;
              __int16 v194 = 2080;
              uint64_t v195 = v58;
              __int16 v196 = 2080;
              uint64_t v197 = (uint64_t)v54;
              _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "#E %s%s%s%sresponse: %s", buf, 0x34u);
            }
          }
          goto LABEL_44;
        }
        objc_msgSend(v26, "setAction:", objc_msgSend(v27, "action"));
        [v26 action];
        int v179 = v28;
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        uint64_t v29 = 0;
        unint64_t v30 = 0;
        int v31 = 0;
        long long v190 = *(_OWORD *)buf;
        uint64_t v191 = *(void *)&buf[16];
        int v32 = (char)buf[23];
        if ((buf[23] & 0x80u) == 0) {
          size_t v33 = HIBYTE(*(void *)&buf[16]);
        }
        else {
          size_t v33 = *(void *)&buf[8];
        }
        std::string __p = *(void **)buf;
        if ((buf[23] & 0x80u) == 0) {
          int v34 = &v190;
        }
        else {
          int v34 = *(long long **)buf;
        }
        while (1)
        {
          unint64_t v35 = (uint64_t *)(*(void *)(a1 + 96) + v29);
          uint64_t v36 = *v35;
          uint64_t v37 = (std::__shared_weak_count *)v35[1];
          if (v37) {
            atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v38 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v36 + 40))(v36);
          if (v37) {
            sub_10004D2C8(v37);
          }
          if (v33 == strlen(v38) && !memcmp(v34, v38, v33)) {
            break;
          }
          int v31 = v30 > 0x1C;
          v29 += 16;
          if (++v30 == 30)
          {
            int v31 = 1;
            int v39 = 30;
            goto LABEL_54;
          }
        }
        int v39 = v30;
LABEL_54:
        long long v59 = v175;
        id v12 = v180;
        long long v60 = v181;
        if (v32 < 0) {
          operator delete(__p);
        }
        if (((v39 != 30) & ~v31) == 0)
        {
          long long v61 = **(NSObject ***)(a1 + 56);
          id v22 = v176;
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v62 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            long long v64 = *(uint8_t **)(a1 + 64);
            uint64_t v63 = *(void *)(a1 + 72);
            id v65 = objc_msgSend(objc_msgSend(v181, "action"), "UTF8String");
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v62;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v64;
            __int16 v194 = 2080;
            uint64_t v195 = v63;
            __int16 v196 = 2080;
            uint64_t v197 = (uint64_t)v65;
            uint64_t v44 = v61;
            uint64_t v45 = "#I %s%s%s%sSkipping unknown action '%s'";
            uint32_t v50 = 52;
LABEL_43:
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, buf, v50);
          }
LABEL_44:
          char v51 = 0;
LABEL_45:
          uint64_t v52 = context;
          goto LABEL_46;
        }
        int __pa = v39;
        if (objc_msgSend(objc_msgSend(v179, "description"), "length"))
        {
          long long v67 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v68 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            long long v69 = *(uint8_t **)(a1 + 64);
            uint64_t v171 = *(void *)(a1 + 72);
            long long v70 = (uint64_t *)(*(void *)(a1 + 96) + 16 * __pa);
            uint64_t v71 = *v70;
            long long v72 = (std::__shared_weak_count *)v70[1];
            if (v72) {
              atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)v71 + 40))(v71);
            if (v72) {
              sub_10004D2C8(v72);
            }
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v68;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v69;
            __int16 v194 = 2080;
            uint64_t v195 = v171;
            __int16 v196 = 2080;
            uint64_t v197 = v73;
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s request:", buf, 0x34u);
            long long v59 = v175;
            long long v60 = v181;
          }
          *(void *)int buf = off_101A79480;
          *(void *)&uint8_t buf[8] = a1;
          unint64_t v193 = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
          int v39 = __pa;
        }
        long long v74 = **(NSObject ***)(a1 + 56);
        BOOL v75 = os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT);
        if (v39 == 19)
        {
          if (v75)
          {
            uint64_t v76 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            int v172 = v66;
            id v78 = *(uint8_t **)(a1 + 64);
            uint64_t v77 = *(void *)(a1 + 72);
            uint64_t v79 = *(void *)(a1 + 96);
            uint64_t v80 = *(void *)(v79 + 304);
            __int16 v81 = *(std::__shared_weak_count **)(v79 + 312);
            if (v81) {
              atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v82 = (*(uint64_t (**)(uint64_t))(*(void *)v80 + 40))(v80);
            if (v81) {
              sub_10004D2C8(v81);
            }
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v76;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v78;
            __int16 v194 = 2080;
            uint64_t v195 = v77;
            __int16 v196 = 2080;
            uint64_t v197 = v82;
            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s response: received", buf, 0x34u);
            long long v60 = v181;
            int v39 = __pa;
            long long v66 = v172;
          }
        }
        else
        {
          if (v75)
          {
            uint64_t v83 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            xpc_object_t v173 = v66;
            uint64_t v85 = *(uint8_t **)(a1 + 64);
            uint64_t v84 = *(void *)(a1 + 72);
            uint64_t v86 = (uint64_t *)(*(void *)(a1 + 96) + 16 * __pa);
            uint64_t v87 = *v86;
            uint64_t v88 = (std::__shared_weak_count *)v86[1];
            if (v88) {
              atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v89 = (*(uint64_t (**)(uint64_t))(*(void *)v87 + 40))(v87);
            if (v88) {
              sub_10004D2C8(v88);
            }
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v83;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v85;
            __int16 v194 = 2080;
            uint64_t v195 = v84;
            __int16 v196 = 2080;
            uint64_t v197 = v89;
            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s response:", buf, 0x34u);
            long long v60 = v181;
            int v39 = __pa;
            long long v66 = v173;
          }
          objc_msgSend(v60, "description", v169);
          *(void *)int buf = off_101A79500;
          *(void *)&uint8_t buf[8] = a1;
          unint64_t v193 = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
        }
        sub_100FBA648(a1, v39, &v190);
        uint64_t v90 = (void *)v190;
        id v91 = objc_msgSend(objc_msgSend(v60, "info"), "objectForKey:", @"status");
        if (!v91)
        {
          CFTypeRef v106 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v107 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            uint64_t v109 = *(uint8_t **)(a1 + 64);
            uint64_t v108 = *(void *)(a1 + 72);
            id v110 = [v90 UTF8String];
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v107;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v109;
            __int16 v194 = 2080;
            uint64_t v195 = v108;
            __int16 v196 = 2080;
            uint64_t v197 = (uint64_t)v110;
            int v111 = v106;
            int v112 = "#W %s%s%s%s%s, no action atatus in response";
            goto LABEL_97;
          }
LABEL_99:
          sub_1000558F4((const void **)&v190);
          char v51 = 1;
          id v12 = v180;
          id v22 = v176;
          goto LABEL_45;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v113 = **(NSObject ***)(a1 + 56);
          if (!os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_99;
          }
          uint64_t v114 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v116 = *(uint8_t **)(a1 + 64);
          uint64_t v115 = *(void *)(a1 + 72);
          id v117 = [v90 UTF8String];
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v114;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          unint64_t v193 = v116;
          __int16 v194 = 2080;
          uint64_t v195 = v115;
          __int16 v196 = 2080;
          uint64_t v197 = (uint64_t)v117;
          int v111 = v113;
          int v112 = "#W %s%s%s%s%s, invalid action status format, expected number";
LABEL_97:
          uint32_t v118 = 52;
LABEL_98:
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, v112, buf, v118);
          goto LABEL_99;
        }
        id v92 = [v91 intValue];
        id v93 = v92;
        if (((v92 - 6000) > 0x14 || ((1 << ((_BYTE)v92 - 112)) & 0x103F7F) == 0)
          && (v92 - 6300) >= 3
          && v92 != 6201)
        {
          uint64_t v120 = **(NSObject ***)(a1 + 56);
          if (!os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_99;
          }
          uint64_t v121 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          int v123 = *(uint8_t **)(a1 + 64);
          uint64_t v122 = *(void *)(a1 + 72);
          id v124 = [v90 UTF8String];
          *(_DWORD *)int buf = v169;
          *(void *)&uint8_t buf[4] = v121;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          unint64_t v193 = v123;
          __int16 v194 = 2080;
          uint64_t v195 = v122;
          __int16 v196 = 2080;
          uint64_t v197 = (uint64_t)v124;
          __int16 v198 = 1024;
          *(_DWORD *)v199 = v93;
          int v111 = v120;
          int v112 = "#W %s%s%s%s%s, unknown action status: %d";
          uint32_t v118 = 58;
          goto LABEL_98;
        }
        uint64_t v94 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v95 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
          uint64_t v97 = *(uint8_t **)(a1 + 64);
          uint64_t v96 = *(void *)(a1 + 72);
          id v98 = [v90 UTF8String];
          id v99 = sub_100FB56F4((int)v93);
          *(_DWORD *)int buf = v169;
          *(void *)&uint8_t buf[4] = v95;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          unint64_t v193 = v97;
          __int16 v194 = 2080;
          uint64_t v195 = v96;
          __int16 v196 = 2080;
          uint64_t v197 = (uint64_t)v98;
          __int16 v198 = 2080;
          *(void *)v199 = v99;
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s, action status: %s", buf, 0x3Eu);
        }
        sub_1000558F4((const void **)&v190);
        uint64_t v100 = (uint64_t *)(*(void *)(a1 + 96) + 16 * __pa);
        uint64_t v101 = *v100;
        int v102 = (std::__shared_weak_count *)v100[1];
        if (v102) {
          atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v101)
        {
          long long v190 = 0uLL;
          id v22 = v176;
          (*(void (**)(long long *__return_ptr, uint64_t, id, id, id, uint64_t *))(*(void *)v101 + 16))(&v190, v101, v93, [v181 info], objc_msgSend(v179, "info"), v59);
          uint64_t v103 = v190;
          if ((void)v190)
          {
            uint64_t v104 = (std::__shared_weak_count *)*((void *)&v190 + 1);
            if (*((void *)&v190 + 1))
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v190 + 1) + 8), 1uLL, memory_order_relaxed);
              uint64_t v105 = *v59;
              atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            else
            {
              uint64_t v105 = *v59;
            }
            uint64_t v137 = (void *)(v105 + 16 * __pa);
            uint64_t v138 = (std::__shared_weak_count *)v137[1];
            void *v137 = v103;
            v137[1] = v104;
            if (v138) {
              sub_10004D2C8(v138);
            }
            if (v104) {
              sub_10004D2C8(v104);
            }
            ++v174;
          }
          else
          {
            xpc_object_t v132 = **(NSObject ***)(a1 + 56);
            if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v133 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
              xpc_object_t v135 = *(uint8_t **)(a1 + 64);
              uint64_t v134 = *(void *)(a1 + 72);
              uint64_t v136 = sub_100FBBEDC(*(void *)(a1 + 96), __pa);
              *(_DWORD *)int buf = 136316162;
              *(void *)&uint8_t buf[4] = v133;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2080;
              unint64_t v193 = v135;
              __int16 v194 = 2080;
              uint64_t v195 = v134;
              __int16 v196 = 2080;
              uint64_t v197 = v136;
              _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%saction %s response parsed to DevNull", buf, 0x34u);
            }
          }
          uint64_t v52 = context;
          if (*((void *)&v190 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v190 + 1));
          }
        }
        else
        {
          uint64_t v119 = **(NSObject ***)(a1 + 56);
          id v22 = v176;
          if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
          {
            uint64_t v139 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
            unint64_t v141 = *(uint8_t **)(a1 + 64);
            uint64_t v140 = *(void *)(a1 + 72);
            uint64_t v142 = sub_100FBBEDC(*(void *)(a1 + 96), __pa);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v139;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            unint64_t v193 = v141;
            __int16 v194 = 2080;
            uint64_t v195 = v140;
            __int16 v196 = 2080;
            uint64_t v197 = v142;
            _os_log_error_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "#E %s%s%s%sprocessor not found for action %s", buf, 0x34u);
          }
          uint64_t v52 = context;
        }
        if (v102) {
          sub_10004D2C8(v102);
        }
        char v51 = 0;
        id v12 = v180;
LABEL_46:
        if (v51) {
          goto LABEL_125;
        }
        id v24 = (char *)v24 + 1;
      }
      while (v24 != v22);
      id v143 = [v12 countByEnumeratingWithState:&v184 objects:v200 count:16];
      id v22 = v143;
      if (!v143)
      {
LABEL_125:
        uint64_t v17 = v170;
        int v144 = v174;
        goto LABEL_137;
      }
    }
  }
LABEL_136:
  int v144 = 0;
LABEL_137:
  int v159 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v160 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    uint64_t v161 = *(uint8_t **)(a1 + 64);
    uint64_t v162 = *(void *)(a1 + 72);
    uint64_t v163 = "";
    if (!v144) {
      uint64_t v163 = " not";
    }
    *(_DWORD *)int buf = 136316674;
    *(void *)&uint8_t buf[4] = v160;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    unint64_t v193 = v161;
    __int16 v194 = 2080;
    uint64_t v195 = v162;
    __int16 v196 = 2080;
    uint64_t v197 = (uint64_t)v163;
    __int16 v198 = 1024;
    *(_DWORD *)v199 = v144;
    *(_WORD *)&v199[4] = 2048;
    *(void *)&v199[6] = v17;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sEntitlement Response was%s successfully parsed %d responses out of %lu", buf, 0x44u);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v189);
  return v144 != 0;
}

void sub_100FC26B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,int a39,__int16 a40,char a41,char a42,std::__shared_weak_count *a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a43) {
    sub_10004D2C8(a43);
  }
  if (v51) {
    sub_10004D2C8(v51);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a38);
  _Unwind_Resume(a1);
}

void *sub_100FC27D8(void *a1)
{
  *a1 = off_101A78FD8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_100FC2838(uint64_t a1, CFDictionaryRef theDict, void *key)
{
  *(_OWORD *)std::string __p = 0u;
  long long v18 = 0u;
  CFBooleanRef Value = CFDictionaryGetValue(theDict, key);
  sub_100FC2A7C(__p, a1, Value, key);
  if (!BYTE8(v18)) {
    return 0xFFFFFFFFLL;
  }
  if ((SBYTE7(v18) & 0x80u) == 0) {
    id v7 = __p;
  }
  else {
    id v7 = (void **)__p[0];
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v20, (const __CFString **)v7, (const char *)0x8000100, kCFAllocatorDefault, v6))
  {
    BOOL v8 = v19;
    uint64_t v19 = v20;
    *(void *)int buf = v8;
    sub_1000558F4((const void **)buf);
  }
  uint64_t v9 = (void *)v19;
  BOOL v16 = v19;
  uint64_t v19 = 0;
  sub_1000558F4(&v19);
  uint64_t v10 = sub_100FB5980(v9);
  sub_1000558F4(&v16);
  if (v10 == -1)
  {
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v14 = __p;
      if (SBYTE7(v18) < 0) {
        int v14 = (void **)__p[0];
      }
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v22 = 2080;
      long long v23 = " ";
      __int16 v24 = 2080;
      uint64_t v25 = v13;
      __int16 v26 = 2080;
      id v27 = ", ";
      __int16 v28 = 2080;
      uint64_t v29 = v14;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUnsupported EntitlementType value: %s", buf, 0x34u);
    }
  }
  if (BYTE8(v18) && SBYTE7(v18) < 0) {
    operator delete(__p[0]);
  }
  return v10;
}

void sub_100FC2A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC2A7C(_OWORD *a1, uint64_t a2, CFTypeRef cf, void *a4)
{
  *a1 = 0u;
  a1[1] = 0u;
  if (cf)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v12 = 0;
      sub_10008BE4C((uint64_t)a1, (long long *)__p);
      if (SHIBYTE(v12) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      BOOL v8 = **(NSObject ***)(a2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v14 = v10;
        __int16 v15 = 2080;
        BOOL v16 = ", ";
        __int16 v17 = 2080;
        id v18 = [a4 UTF8String];
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected string", buf, 0x34u);
      }
    }
  }
}

void sub_100FC2C1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  if (*(unsigned char *)(v21 + 24))
  {
    if (*(char *)(v21 + 23) < 0) {
      operator delete(*(void **)v21);
    }
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100FC2C68(uint64_t a1, CFDictionaryRef theDict, void *key)
{
  CFBooleanRef Value = (void *)CFDictionaryGetValue(theDict, key);
  unint64_t v6 = sub_100FC2DC4(a1, Value, key);
  if (!HIDWORD(v6)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = v6;
  if ((v6 - 6100) >= 7)
  {
    BOOL v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v12 = 136316162;
      uint64_t v13 = v9;
      __int16 v14 = 2080;
      __int16 v15 = " ";
      __int16 v16 = 2080;
      uint64_t v17 = v10;
      __int16 v18 = 2080;
      uint64_t v19 = ", ";
      __int16 v20 = 1024;
      int v21 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sInvalid EntitlementStatus value: %d", (uint8_t *)&v12, 0x30u);
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

unint64_t sub_100FC2DC4(uint64_t a1, void *cf, void *a3)
{
  if (!cf)
  {
LABEL_8:
    uint64_t v13 = 0;
    int v12 = 0;
    unsigned int v11 = 0;
    return (unint64_t)v13 | v11 | v12;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFNumberGetTypeID())
  {
    __int16 v14 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v18 = 136316162;
      uint64_t v19 = v16;
      __int16 v20 = 2080;
      int v21 = " ";
      __int16 v22 = 2080;
      uint64_t v23 = v17;
      __int16 v24 = 2080;
      uint64_t v25 = ", ";
      __int16 v26 = 2080;
      id v27 = [a3 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected number", (uint8_t *)&v18, 0x34u);
    }
    goto LABEL_8;
  }
  int v18 = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  int v10 = 0;
  if (v7 == TypeID)
  {
    ctu::cf::assign((ctu::cf *)&v18, (int *)cf, v9);
    int v10 = v18;
  }
  unsigned int v11 = v10 & 0xFFFFFF00;
  int v12 = v10;
  uint64_t v13 = &_mh_execute_header;
  return (unint64_t)v13 | v11 | v12;
}

uint64_t sub_100FC2F60(uint64_t a1, int a2, int a3, uint64_t **a4)
{
  switch(a3)
  {
    case 6100:
      unsigned int v7 = 2;
      unsigned int v24 = 1;
      break;
    case 6101:
      unsigned int v24 = 0;
      unsigned int v7 = 1;
      break;
    case 6102:
    case 6104:
    case 6105:
    case 6106:
      unsigned int v24 = 0;
      unsigned int v7 = 6;
      break;
    case 6103:
      unsigned int v24 = 0;
      unsigned int v7 = 5;
      break;
    default:
      unsigned int v24 = 0;
      unsigned int v7 = 3;
      break;
  }
  BOOL v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    unsigned int v11 = sub_100059954(a2);
    int v12 = off_101A7BD30[v7 - 1];
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v28 = 2080;
    uint64_t v29 = v10;
    __int16 v30 = 2080;
    int v31 = ", ";
    __int16 v32 = 2080;
    size_t v33 = v11;
    __int16 v34 = 2080;
    unint64_t v35 = v12;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUpdate entitlement %s with %s", buf, 0x3Eu);
  }
  uint64_t v13 = **a4;
  __int16 v14 = (std::__shared_weak_count *)(*a4)[1];
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = a4;
  __int16 v15 = (char *)operator new(0x80uLL);
  *((void *)v15 + 1) = 0;
  *((void *)v15 + 2) = 0;
  *(void *)__int16 v15 = off_101A79580;
  v15[24] = 0;
  uint64_t v16 = v15 + 24;
  *((void *)v15 + 5) = 0;
  *((void *)v15 + 4) = v15 + 40;
  *((void *)v15 + 6) = 0;
  *((void *)v15 + 8) = 0;
  *((void *)v15 + 7) = v15 + 64;
  *((void *)v15 + 11) = 0;
  *((void *)v15 + 9) = 0;
  *((void *)v15 + 10) = v15 + 88;
  *((void *)v15 + 12) = 0;
  *((void *)v15 + 14) = 0;
  *((void *)v15 + 13) = v15 + 112;
  *((void *)v15 + 15) = 0;
  if (v13)
  {
    uint64_t v17 = *(void *)(v13 + 8);
    if (v17)
    {
      unsigned char *v16 = *(unsigned char *)v17;
      if (v16 != (unsigned char *)v17)
      {
        sub_10005D87C((uint64_t **)v15 + 4, *(void **)(v17 + 8), (void *)(v17 + 16));
        sub_10005D718((uint64_t **)v15 + 7, *(void **)(v17 + 32), (void *)(v17 + 40));
        sub_10005D5A4((uint64_t **)v15 + 10, *(int **)(v17 + 56), (int *)(v17 + 64));
        sub_10005D440((uint64_t **)v15 + 13, *(void **)(v17 + 80), (void *)(v17 + 88));
      }
    }
  }
  sub_100C89E6C((uint64_t)v16, a2, v7, a3, 1);
  *(void *)int buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  if (v13) {
    int v18 = *(_DWORD *)v13;
  }
  else {
    int v18 = 6000;
  }
  sub_100FC9420(buf, v18, (uint64_t)v16, (std::__shared_weak_count *)v15);
  uint64_t v19 = *(void *)buf;
  __int16 v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    int v21 = *v25;
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    int v21 = *v25;
  }
  __int16 v22 = (std::__shared_weak_count *)v21[1];
  *int v21 = v19;
  v21[1] = (uint64_t)v20;
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (v20)
  {
    sub_10004D2C8(v20);
    sub_10004D2C8(v20);
  }
  sub_10004D2C8((std::__shared_weak_count *)v15);
  if (v14) {
    sub_10004D2C8(v14);
  }
  return v24;
}

void sub_100FC32BC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FC3304(uint64_t a1, CFDictionaryRef theDict)
{
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  CFBooleanRef Value = CFDictionaryGetValue(theDict, @"notification-name");
  sub_100FC2A7C(__p, a1, Value, @"notification-name");
  if (!BYTE8(v15)) {
    return 0;
  }
  if ((SBYTE7(v15) & 0x80u) == 0) {
    id v5 = __p;
  }
  else {
    id v5 = (void **)__p[0];
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v17, (const __CFString **)v5, (const char *)0x8000100, kCFAllocatorDefault, v4))
  {
    CFTypeID v6 = v16;
    uint64_t v16 = v17;
    *(void *)int buf = v6;
    sub_1000558F4((const void **)buf);
  }
  uint64_t v13 = (void *)v16;
  uint64_t v16 = 0;
  sub_1000558F4(&v16);
  if ([v13 isEqualToString:@"VoWiFi"])
  {
    uint64_t v7 = 1;
  }
  else if ([v13 isEqualToString:@"VVM"])
  {
    uint64_t v7 = 2;
  }
  else if ([v13 isEqualToString:@"Multi-SIM"])
  {
    uint64_t v7 = 3;
  }
  else if ([v13 isEqualToString:@"PreferredNetworks"])
  {
    uint64_t v7 = 4;
  }
  else if ([v13 isEqualToString:@"CarrierSpace"])
  {
    uint64_t v7 = 5;
  }
  else if ([v13 isEqualToString:@"sa-watch"])
  {
    uint64_t v7 = 6;
  }
  else if ([v13 isEqualToString:@"esim-profile-released"])
  {
    uint64_t v7 = 7;
  }
  else if ([v13 isEqualToString:@"AuthorizationTokens"])
  {
    uint64_t v7 = 8;
  }
  else if ([v13 isEqualToString:@"geofence-data"])
  {
    uint64_t v7 = 9;
  }
  else
  {
    if (![v13 isEqualToString:@"msisdn-event"])
    {
      sub_1000558F4((const void **)&v13);
      uint64_t v9 = **(NSObject ***)(a1 + 40);
      uint64_t v7 = 0;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        int v12 = __p;
        if (SBYTE7(v15) < 0) {
          int v12 = (void **)__p[0];
        }
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v10;
        __int16 v19 = 2080;
        __int16 v20 = " ";
        __int16 v21 = 2080;
        uint64_t v22 = v11;
        __int16 v23 = 2080;
        unsigned int v24 = ", ";
        __int16 v25 = 2080;
        __int16 v26 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUnsupported EntitlementTopicType value: %s", buf, 0x34u);
        uint64_t v7 = 0;
      }
      goto LABEL_29;
    }
    uint64_t v7 = 10;
  }
  sub_1000558F4((const void **)&v13);
LABEL_29:
  if (BYTE8(v15) && SBYTE7(v15) < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_100FC361C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC3664(uint64_t a1, void *cf, void *a3)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFNumberGetTypeID())
  {
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)__int16 v14 = 136316162;
      *(void *)&_OWORD v14[4] = v12;
      __int16 v15 = 2080;
      uint64_t v16 = " ";
      __int16 v17 = 2080;
      uint64_t v18 = v13;
      __int16 v19 = 2080;
      __int16 v20 = ", ";
      __int16 v21 = 2080;
      id v22 = [a3 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected number", v14, 0x34u);
    }
    return 0;
  }
  *(void *)__int16 v14 = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v7 == TypeID)
  {
    ctu::cf::assign((ctu::cf *)v14, (double *)cf, v8);
    return *(void *)v14;
  }
  return result;
}

unint64_t sub_100FC37E8(uint64_t a1, void *cf, void *a3)
{
  if (!cf)
  {
LABEL_8:
    unint64_t v11 = 0;
    uint64_t v10 = 0;
    return v10 | v11;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFNumberGetTypeID())
  {
    uint64_t v12 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)uint64_t v16 = 136316162;
      *(void *)&v16[4] = v14;
      __int16 v17 = 2080;
      uint64_t v18 = " ";
      __int16 v19 = 2080;
      uint64_t v20 = v15;
      __int16 v21 = 2080;
      id v22 = ", ";
      __int16 v23 = 2080;
      id v24 = [a3 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected number", v16, 0x34u);
    }
    goto LABEL_8;
  }
  *(void *)uint64_t v16 = 0;
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t v10 = 0;
  if (v7 == TypeID)
  {
    ctu::cf::assign((ctu::cf *)v16, (uint64_t *)cf, v9);
    uint64_t v10 = *(void *)v16;
  }
  unint64_t v11 = v10 & 0xFFFFFFFFFFFFFF00;
  uint64_t v10 = v10;
  return v10 | v11;
}

uint64_t sub_100FC3980(uint64_t a1, CFTypeRef cf, void *a3)
{
  if (!cf)
  {
LABEL_6:
    BOOL v7 = 0;
    int v8 = 0;
    return v7 | (v8 << 8);
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFBooleanGetTypeID())
  {
    CFNumberRef v9 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v13 = 136316162;
      uint64_t v14 = v11;
      __int16 v15 = 2080;
      uint64_t v16 = " ";
      __int16 v17 = 2080;
      uint64_t v18 = v12;
      __int16 v19 = 2080;
      uint64_t v20 = ", ";
      __int16 v21 = 2080;
      id v22 = [a3 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected BOOLean", (uint8_t *)&v13, 0x34u);
    }
    goto LABEL_6;
  }
  BOOL v7 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
  int v8 = 1;
  return v7 | (v8 << 8);
}

const void **sub_100FC3AEC(const void **result, CFTypeRef cf)
{
  *uint64_t result = 0;
  result[1] = 0;
  if (cf)
  {
    uint64_t v3 = (uint64_t)result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = (const void **)CFArrayGetTypeID();
    if ((const void **)v4 == result)
    {
      CFTypeRef v6 = cf;
      if (*(unsigned char *)(v3 + 8))
      {
        BOOL v7 = 0;
        sub_100044D6C(&v7, &v6);
        id v5 = *(const void **)v3;
        *(void *)uint64_t v3 = v7;
        BOOL v7 = v5;
        return sub_100044D00(&v7);
      }
      else
      {
        uint64_t result = (const void **)sub_100044D6C((void *)v3, &v6);
        *(unsigned char *)(v3 + 8) = 1;
      }
    }
  }
  return result;
}

void sub_100FC3B8C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 8)) {
    sub_100044D00((const void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC3BAC(void *a1, uint64_t a2, CFTypeRef cf, void *a4, int a5)
{
  *a1 = 0;
  a1[1] = 0;
  if (cf)
  {
    CFTypeID v9 = CFGetTypeID(cf);
    if (v9 == CFDictionaryGetTypeID())
    {
      CFTypeRef v17 = cf;
      if (*((unsigned char *)a1 + 8))
      {
        *(void *)int buf = 0;
        sub_10004EFE4(buf, &v17);
        uint64_t v10 = *a1;
        *a1 = *(void *)buf;
        *(void *)int buf = v10;
        sub_100057D78((const void **)buf);
      }
      else
      {
        sub_10004EFE4(a1, &v17);
        *((unsigned char *)a1 + 8) = 1;
      }
    }
    else
    {
      uint64_t v14 = **(NSObject ***)(a2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v15;
        __int16 v19 = 2080;
        uint64_t v20 = " ";
        __int16 v21 = 2080;
        uint64_t v22 = v16;
        __int16 v23 = 2080;
        id v24 = ", ";
        __int16 v25 = 2080;
        id v26 = [a4 UTF8String];
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "#E %s%s%s%selement %s is of wrong format, expected dictionary", buf, 0x34u);
      }
    }
  }
  else if (a5)
  {
    uint64_t v11 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v19 = 2080;
      uint64_t v20 = " ";
      __int16 v21 = 2080;
      uint64_t v22 = v13;
      __int16 v23 = 2080;
      id v24 = ", ";
      __int16 v25 = 2080;
      id v26 = [a4 UTF8String];
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sMissing element %s", buf, 0x34u);
    }
  }
}

void sub_100FC3E1C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 8)) {
    sub_100057D78((const void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100FC3E44(uint64_t a1)
{
  *(void *)a1 = off_101A79018;

  return sub_100FC27D8((void *)a1);
}

const void **sub_100FC3EA8(uint64_t *a1, uint64_t a2, CFDictionaryRef theDict)
{
  uint64_t v302 = 0;
  long long v300 = 0u;
  long long v301 = 0u;
  long long v298 = 0u;
  long long v299 = 0u;
  uint64_t v296 = 0;
  uint64_t v297 = 0;
  long long v290 = 0u;
  uint64_t v288 = 0;
  int v289 = (double *)&v290;
  v291 = &v292;
  int v292 = 0;
  uint64_t v294 = &v295;
  v295 = 0;
  uint64_t v293 = 0;
  CFDictionaryRef theDicta = 0;
  CFBooleanRef Value = CFDictionaryGetValue(theDict, *(const void **)(a2 + 48));
  sub_100FC3BAC(&theDicta, a2, Value, *(void **)(a2 + 48), 0);
  if (!(_BYTE)v288)
  {
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_361;
  }
  CFTypeRef cf = 0;
  uint64_t v286 = 0;
  CFTypeRef v6 = CFDictionaryGetValue(theDicta, *(const void **)(a2 + 56));
  sub_100FC3BAC(&cf, a2, v6, *(void **)(a2 + 56), 0);
  char v277 = a1;
  if (!(_BYTE)v286)
  {
LABEL_206:
    char v162 = 0;
    goto LABEL_239;
  }
  BOOL v7 = (void *)cf;
  CFTypeRef v284 = cf;
  if (cf)
  {
    CFRetain(cf);
    BOOL v7 = (void *)v284;
  }
  id v8 = [v7 objectForKey:@"voice"];
  if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    long long v308 = 0u;
    long long v309 = 0u;
    long long v306 = 0u;
    long long v307 = 0u;
    id v9 = [v8 countByEnumeratingWithState:&v306 objects:v310 count:16];
    if (!v9)
    {
      int v34 = 1;
      goto LABEL_48;
    }
    uint64_t v275 = *(void *)v307;
LABEL_9:
    id v272 = v9;
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v307 != v275) {
        objc_enumerationMutation(v8);
      }
      uint64_t v11 = *(void **)(*((void *)&v306 + 1) + 8 * v10);
      long long v303 = 0x100000001uLL;
      char v12 = sub_100FC79C8(a2, v11, @"timestamp", (double *)&v303 + 1);
      uint64_t v13 = **(NSObject ***)(a2 + 40);
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if ((v12 & 1) == 0) {
        break;
      }
      if (v14)
      {
        uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v15;
        __int16 v322 = 2080;
        uint64_t v323 = " ";
        __int16 v324 = 2080;
        uint64_t v325 = v16;
        __int16 v326 = 2080;
        int v327 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived voice usage information", buf, 0x2Au);
      }
      id v17 = [v11 objectForKey:@"category-id"];
      if (!v17
        || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
        || (uint64_t)[v17 integerValue] <= 0)
      {
        unint64_t v35 = **(NSObject ***)(a2 + 40);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        uint64_t v142 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v143 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v142;
        __int16 v322 = 2080;
        uint64_t v323 = " ";
        __int16 v324 = 2080;
        uint64_t v325 = v143;
        __int16 v326 = 2080;
        int v327 = ", ";
        int v39 = "#I %s%s%s%svoice usage category not present or invalid";
        uint64_t v40 = buf;
        goto LABEL_45;
      }
      signed int v18 = [v17 intValue];
      id v19 = [v11 objectForKey:@"voice-capacity"];
      if (v19)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v20 = [v19 intValue];
          LODWORD(v303) = v20;
          __int16 v21 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v22;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v23;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v20;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%svoice capacity %d", buf, 0x30u);
          }
          LODWORD(v19) = 1;
        }
        else
        {
          LODWORD(v19) = 0;
        }
      }
      id v24 = [v11 objectForKey:@"voice-used"];
      if (v24 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        unsigned int v25 = [v24 intValue];
        DWORD1(v303) = v25;
        id v26 = **(NSObject ***)(a2 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v27;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v28;
          __int16 v326 = 2080;
          int v327 = ", ";
          __int16 v328 = 1024;
          unsigned int v329 = v25;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%svoice used %d", buf, 0x30u);
        }
      }
      else if (!v19)
      {
        goto LABEL_47;
      }
      uint64_t v29 = (char *)v290;
      __int16 v30 = (char **)&v290;
      int v31 = (char **)&v290;
      if ((void)v290)
      {
        while (1)
        {
          while (1)
          {
            int v31 = (char **)v29;
            signed int v32 = *((_DWORD *)v29 + 8);
            if (v32 <= v18) {
              break;
            }
            uint64_t v29 = *v31;
            __int16 v30 = v31;
            if (!*v31) {
              goto LABEL_36;
            }
          }
          if (v32 >= v18) {
            break;
          }
          uint64_t v29 = v31[1];
          if (!v29)
          {
            __int16 v30 = v31 + 1;
            goto LABEL_36;
          }
        }
      }
      else
      {
LABEL_36:
        size_t v33 = (char *)operator new(0x38uLL);
        *((_DWORD *)v33 + 8) = v18;
        *(_OWORD *)(v33 + 40) = v303;
        *(void *)size_t v33 = 0;
        *((void *)v33 + 1) = 0;
        *((void *)v33 + 2) = v31;
        NSObject *v30 = v33;
        if (*(void *)v289)
        {
          int v289 = *(double **)v289;
          size_t v33 = *v30;
        }
        sub_100046C90((uint64_t *)v290, (uint64_t *)v33);
        ++*((void *)&v290 + 1);
      }
      if ((id)++v10 == v272)
      {
        id v9 = [v8 countByEnumeratingWithState:&v306 objects:v310 count:16];
        int v34 = 1;
        if (v9) {
          goto LABEL_9;
        }
        goto LABEL_48;
      }
    }
    if (!v14) {
      goto LABEL_47;
    }
    uint64_t v151 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v152 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v151;
    __int16 v322 = 2080;
    uint64_t v323 = " ";
    __int16 v324 = 2080;
    uint64_t v325 = v152;
    __int16 v326 = 2080;
    int v327 = ", ";
    int v39 = "#I %s%s%s%sInvalid voice usage information, missing timestamp, skipping parsing";
    uint64_t v40 = buf;
    uint64_t v41 = v13;
  }
  else
  {
    unint64_t v35 = **(NSObject ***)(a2 + 40);
    BOOL v36 = os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
    int v34 = 0;
    if (!v36) {
      goto LABEL_48;
    }
    uint64_t v37 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v37;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v38;
    __int16 v315 = 2080;
    v316 = ", ";
    int v39 = "#I %s%s%s%sReceived invalid voice usage information/array, skipping parsing";
    uint64_t v40 = v310;
LABEL_45:
    uint64_t v41 = v35;
  }
  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v39, v40, 0x2Au);
LABEL_47:
  int v34 = 0;
LABEL_48:
  int v276 = v34;
  sub_100057D78(&v284);
  uint64_t v42 = (void *)cf;
  CFTypeRef v283 = cf;
  if (cf)
  {
    CFRetain(cf);
    uint64_t v42 = (void *)v283;
  }
  id v43 = [v42 objectForKey:@"data"];
  if (v43)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      long long v308 = 0u;
      long long v309 = 0u;
      long long v306 = 0u;
      long long v307 = 0u;
      id v44 = [v43 countByEnumeratingWithState:&v306 objects:v310 count:16];
      if (!v44)
      {
        int v74 = 1;
        goto LABEL_101;
      }
      id v270 = v44;
      uint64_t v274 = *(void *)v307;
LABEL_54:
      uint64_t v45 = 0;
      while (1)
      {
        if (*(void *)v307 != v274) {
          objc_enumerationMutation(v43);
        }
        CFTypeRef v46 = *(void **)(*((void *)&v306 + 1) + 8 * v45);
        HIDWORD(v303) = 0;
        *(_DWORD *)((char *)&v303 + 9) = 0;
        *(void *)&long long v303 = 0x100000001;
        BYTE8(v303) = 0;
        *(void *)&long long v304 = 0;
        if (!v46 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          uint64_t v48 = **(NSObject ***)(a2 + 40);
          if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_100;
          }
          uint64_t v149 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v150 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v149;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v150;
          __int16 v326 = 2080;
          int v327 = ", ";
          uint64_t v77 = "#I %s%s%s%sOne of the data usage array's is invalid, skipping parsing";
          goto LABEL_318;
        }
        char v47 = sub_100FC79C8(a2, v46, @"timestamp", (double *)&v304);
        uint64_t v48 = **(NSObject ***)(a2 + 40);
        BOOL v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
        if ((v47 & 1) == 0)
        {
          if (!v49) {
            goto LABEL_100;
          }
          uint64_t v239 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v240 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v239;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v240;
          __int16 v326 = 2080;
          int v327 = ", ";
          uint64_t v77 = "#I %s%s%s%sInvalid data usage information, missing timestamp, skipping parsing";
          goto LABEL_318;
        }
        if (v49)
        {
          uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v50;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v51;
          __int16 v326 = 2080;
          int v327 = ", ";
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived data usage information", buf, 0x2Au);
        }
        id v52 = [v46 objectForKey:@"category-id"];
        if (!v52
          || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
          || (uint64_t)[v52 integerValue] <= 0)
        {
          uint64_t v48 = **(NSObject ***)(a2 + 40);
          if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_100;
          }
          uint64_t v147 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v148 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v147;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v148;
          __int16 v326 = 2080;
          int v327 = ", ";
          uint64_t v77 = "#I %s%s%s%sdata usage category not present or invalid";
LABEL_318:
          id v78 = buf;
          goto LABEL_99;
        }
        signed int v53 = [v52 intValue];
        id v54 = [v46 objectForKey:@"data-capacity"];
        if (v54 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          unsigned int v55 = [v54 intValue];
          LODWORD(v303) = v55;
          uint64_t v56 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v57 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v57;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v58;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v55;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTotal data available %d", buf, 0x30u);
          }
          int v59 = 1;
        }
        else
        {
          int v59 = 0;
        }
        id v60 = [v46 objectForKey:@"data-used"];
        if (v60)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            unsigned int v61 = [v60 intValue];
            DWORD1(v303) = v61;
            uint64_t v62 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v63 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              *(_DWORD *)int buf = 136316162;
              *(void *)&uint8_t buf[4] = v63;
              __int16 v322 = 2080;
              uint64_t v323 = " ";
              __int16 v324 = 2080;
              uint64_t v325 = v64;
              __int16 v326 = 2080;
              int v327 = ", ";
              __int16 v328 = 1024;
              unsigned int v329 = v61;
              _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTotal data used %d", buf, 0x30u);
            }
            int v59 = 1;
          }
        }
        id v65 = [v46 objectForKey:@"use-for-alert"];
        if (!v65) {
          break;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          BYTE8(v303) = [v65 BOOLValue];
          if ((v59 & 1) == 0) {
            goto LABEL_100;
          }
        }
        else
        {
          long long v66 = **(NSObject ***)(a2 + 40);
          if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
            break;
          }
          uint64_t v67 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v68 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v67;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v68;
          __int16 v326 = 2080;
          int v327 = ", ";
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sunable to parse use-for-alert info", buf, 0x2Au);
          if ((v59 & 1) == 0) {
            goto LABEL_100;
          }
        }
LABEL_84:
        long long v69 = v295;
        for (int i = &v295; ; v69 = *i)
        {
          uint64_t v71 = i;
          if (!v69) {
            break;
          }
          while (1)
          {
            int i = (uint64_t **)v69;
            signed int v72 = *((_DWORD *)v69 + 8);
            if (v72 > v53) {
              break;
            }
            if (v72 >= v53) {
              goto LABEL_94;
            }
            long long v69 = i[1];
            if (!v69)
            {
              uint64_t v71 = i + 1;
              goto LABEL_91;
            }
          }
        }
LABEL_91:
        uint64_t v73 = (char *)operator new(0x40uLL);
        *((_DWORD *)v73 + 8) = v53;
        *(_OWORD *)(v73 + 40) = v303;
        *((void *)v73 + 7) = v304;
        *(void *)uint64_t v73 = 0;
        *((void *)v73 + 1) = 0;
        *((void *)v73 + 2) = i;
        *uint64_t v71 = (uint64_t *)v73;
        if (*v294)
        {
          uint64_t v294 = (uint64_t **)*v294;
          uint64_t v73 = (char *)*v71;
        }
        sub_100046C90(v295, (uint64_t *)v73);
        ++v296;
LABEL_94:
        if ((id)++v45 == v270)
        {
          int v74 = 1;
          id v270 = [v43 countByEnumeratingWithState:&v306 objects:v310 count:16];
          if (v270) {
            goto LABEL_54;
          }
          goto LABEL_101;
        }
      }
      if (!v59) {
        goto LABEL_100;
      }
      goto LABEL_84;
    }
  }
  uint64_t v48 = **(NSObject ***)(a2 + 40);
  int v74 = 0;
  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v75 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v76 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v75;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v76;
    __int16 v315 = 2080;
    v316 = ", ";
    uint64_t v77 = "#I %s%s%s%sReceived invalid data usage information/array, skipping parsing";
    id v78 = v310;
LABEL_99:
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v77, v78, 0x2Au);
LABEL_100:
    int v74 = 0;
  }
LABEL_101:
  sub_100057D78(&v283);
  uint64_t v79 = (void *)cf;
  CFTypeRef v282 = cf;
  if (cf)
  {
    CFRetain(cf);
    uint64_t v79 = (void *)v282;
  }
  id v80 = [v79 objectForKey:@"message"];
  if (!v80 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v139 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v140 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v141 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v140;
      __int16 v322 = 2080;
      uint64_t v323 = " ";
      __int16 v324 = 2080;
      uint64_t v325 = v141;
      __int16 v326 = 2080;
      int v327 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived invalid message usage information/array, skipping parsing", buf, 0x2Au);
    }
LABEL_188:
    sub_100057D78(&v282);
    if (v276 | v74) {
      goto LABEL_189;
    }
    goto LABEL_206;
  }
  long long v308 = 0u;
  long long v309 = 0u;
  long long v306 = 0u;
  long long v307 = 0u;
  id v81 = [v80 countByEnumeratingWithState:&v306 objects:v310 count:16];
  if (!v81) {
    goto LABEL_169;
  }
  uint64_t v273 = *(void *)v307;
  int v268 = v74;
  obuint64_t j = v80;
  while (2)
  {
    id v271 = v81;
    for (uint64_t j = 0; j != v271; uint64_t j = (char *)j + 1)
    {
      if (*(void *)v307 != v273) {
        objc_enumerationMutation(obj);
      }
      uint64_t v83 = *(void **)(*((void *)&v306 + 1) + 8 * (void)j);
      *(void *)&long long v84 = 0x100000001;
      *((void *)&v84 + 1) = 0x100000001;
      long long v303 = v84;
      long long v304 = v84;
      v305[0] = 0.0;
      char v85 = sub_100FC79C8(a2, v83, @"timestamp", v305);
      uint64_t v86 = **(NSObject ***)(a2 + 40);
      BOOL v87 = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
      if ((v85 & 1) == 0)
      {
        if (v87)
        {
          uint64_t v153 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v154 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v153;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v154;
          __int16 v326 = 2080;
          int v327 = ", ";
          int v146 = "#I %s%s%s%sInvalid message usage information, missing timestamp, skipping parsing";
          goto LABEL_186;
        }
LABEL_187:
        int v74 = v268;
        goto LABEL_188;
      }
      if (v87)
      {
        uint64_t v88 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v89 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v88;
        __int16 v322 = 2080;
        uint64_t v323 = " ";
        __int16 v324 = 2080;
        uint64_t v325 = v89;
        __int16 v326 = 2080;
        int v327 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived message usage information", buf, 0x2Au);
      }
      id v90 = [v83 objectForKey:@"category-id"];
      if (!v90
        || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
        || (uint64_t)[v90 integerValue] <= 0)
      {
        uint64_t v86 = **(NSObject ***)(a2 + 40);
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v144 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v145 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v144;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v145;
          __int16 v326 = 2080;
          int v327 = ", ";
          int v146 = "#I %s%s%s%svoice usage category not present or invalid";
LABEL_186:
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, v146, buf, 0x2Au);
          goto LABEL_187;
        }
        goto LABEL_187;
      }
      signed int v91 = [v90 intValue];
      id v92 = [v83 objectForKey:@"mo-sms"];
      if (v92 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        unsigned int v93 = [v92 intValue];
        LODWORD(v303) = v93;
        uint64_t v94 = **(NSObject ***)(a2 + 40);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v95 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v96 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v95;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v96;
          __int16 v326 = 2080;
          int v327 = ", ";
          __int16 v328 = 1024;
          unsigned int v329 = v93;
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMO SMS: %d", buf, 0x30u);
        }
        int v97 = 1;
      }
      else
      {
        int v97 = 0;
      }
      id v98 = [v83 objectForKey:@"mt-sms"];
      if (v98)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v99 = [v98 intValue];
          DWORD1(v303) = v99;
          uint64_t v100 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v101 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v102 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v101;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v102;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v99;
            _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT SMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v103 = [v83 objectForKey:@"sms-capacity"];
      if (v103)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v104 = [v103 intValue];
          HIDWORD(v303) = v104;
          uint64_t v105 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v106 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v107 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v106;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v107;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v104;
            _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT MMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v108 = [v83 objectForKey:@"total-sms"];
      if (v108)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v109 = [v108 intValue];
          DWORD2(v303) = v109;
          id v110 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v111 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v112 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v111;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v112;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v109;
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT MMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v113 = [v83 objectForKey:@"mo-mms"];
      if (v113)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v114 = [v113 intValue];
          LODWORD(v304) = v114;
          uint64_t v115 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v116 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v117 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v116;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v117;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v114;
            _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMO MMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v118 = [v83 objectForKey:@"mt-mms"];
      if (v118)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v119 = [v118 intValue];
          DWORD1(v304) = v119;
          uint64_t v120 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v121 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v122 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v121;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v122;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v119;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT MMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v123 = [v83 objectForKey:@"mms-capacity"];
      if (v123)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          unsigned int v124 = [v123 intValue];
          HIDWORD(v304) = v124;
          uint64_t v125 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v126 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v127 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v126;
            __int16 v322 = 2080;
            uint64_t v323 = " ";
            __int16 v324 = 2080;
            uint64_t v325 = v127;
            __int16 v326 = 2080;
            int v327 = ", ";
            __int16 v328 = 1024;
            unsigned int v329 = v124;
            _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT MMS: %d", buf, 0x30u);
          }
          int v97 = 1;
        }
      }
      id v128 = [v83 objectForKey:@"total-mms"];
      if (v128 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        unsigned int v129 = [v128 intValue];
        DWORD2(v304) = v129;
        CFTypeID v130 = **(NSObject ***)(a2 + 40);
        if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v131 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
          uint64_t v132 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v131;
          __int16 v322 = 2080;
          uint64_t v323 = " ";
          __int16 v324 = 2080;
          uint64_t v325 = v132;
          __int16 v326 = 2080;
          int v327 = ", ";
          __int16 v328 = 1024;
          unsigned int v329 = v129;
          _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMT MMS: %d", buf, 0x30u);
        }
      }
      else if (!v97)
      {
        goto LABEL_187;
      }
      uint64_t v133 = v292;
      uint64_t v134 = &v292;
      xpc_object_t v135 = &v292;
      if (v292)
      {
        while (1)
        {
          while (1)
          {
            xpc_object_t v135 = (uint64_t **)v133;
            signed int v136 = *((_DWORD *)v133 + 8);
            if (v136 <= v91) {
              break;
            }
            uint64_t v133 = *v135;
            uint64_t v134 = v135;
            if (!*v135) {
              goto LABEL_164;
            }
          }
          if (v136 >= v91) {
            break;
          }
          uint64_t v133 = v135[1];
          if (!v133)
          {
            uint64_t v134 = v135 + 1;
            goto LABEL_164;
          }
        }
      }
      else
      {
LABEL_164:
        uint64_t v137 = (char *)operator new(0x50uLL);
        *((_DWORD *)v137 + 8) = v91;
        long long v138 = v304;
        *(_OWORD *)(v137 + 40) = v303;
        *(_OWORD *)(v137 + 56) = v138;
        *((double *)v137 + 9) = v305[0];
        *(void *)uint64_t v137 = 0;
        *((void *)v137 + 1) = 0;
        *((void *)v137 + 2) = v135;
        *uint64_t v134 = (uint64_t *)v137;
        if (*v291)
        {
          v291 = (uint64_t **)*v291;
          uint64_t v137 = (char *)*v134;
        }
        sub_100046C90(v292, (uint64_t *)v137);
        ++v293;
      }
    }
    id v81 = [obj countByEnumeratingWithState:&v306 objects:v310 count:16];
    if (v81) {
      continue;
    }
    break;
  }
LABEL_169:
  sub_100057D78(&v282);
LABEL_189:
  uint64_t v155 = v289;
  if (v289 == (double *)&v290)
  {
    double v156 = 0.0;
  }
  else
  {
    double v156 = 0.0;
    do
    {
      double v157 = v155[6];
      BOOL v158 = v157 < v156 || v156 == 0.0;
      if (v158 && v157 != 0.0) {
        double v156 = v155[6];
      }
      uint64_t v160 = (double *)*((void *)v155 + 1);
      if (v160)
      {
        do
        {
          uint64_t v161 = v160;
          uint64_t v160 = *(double **)v160;
        }
        while (v160);
      }
      else
      {
        do
        {
          uint64_t v161 = (double *)*((void *)v155 + 2);
          BOOL v158 = *(void *)v161 == (void)v155;
          uint64_t v155 = v161;
        }
        while (!v158);
      }
      uint64_t v155 = v161;
    }
    while (v161 != (double *)&v290);
  }
  uint64_t v163 = v294;
  if (v294 != &v295)
  {
    do
    {
      double v164 = *((double *)v163 + 7);
      if ((v164 < v156 || v156 == 0.0) && v164 != 0.0) {
        double v156 = *((double *)v163 + 7);
      }
      uint64_t v167 = v163[1];
      if (v167)
      {
        do
        {
          uint64_t v168 = (uint64_t **)v167;
          uint64_t v167 = (uint64_t *)*v167;
        }
        while (v167);
      }
      else
      {
        do
        {
          uint64_t v168 = (uint64_t **)v163[2];
          BOOL v158 = *v168 == (uint64_t *)v163;
          uint64_t v163 = v168;
        }
        while (!v158);
      }
      uint64_t v163 = v168;
    }
    while (v168 != &v295);
  }
  long long v169 = v291;
  if (v291 != &v292)
  {
    do
    {
      double v170 = *((double *)v169 + 9);
      if ((v170 < v156 || v156 == 0.0) && v170 != 0.0) {
        double v156 = *((double *)v169 + 9);
      }
      xpc_object_t v173 = v169[1];
      if (v173)
      {
        do
        {
          int v174 = (uint64_t **)v173;
          xpc_object_t v173 = (uint64_t *)*v173;
        }
        while (v173);
      }
      else
      {
        do
        {
          int v174 = (uint64_t **)v169[2];
          BOOL v158 = *v174 == (uint64_t *)v169;
          long long v169 = v174;
        }
        while (!v158);
      }
      long long v169 = v174;
    }
    while (v174 != &v292);
  }
  *((double *)&v301 + 1) = v156;
  char v162 = 1;
  LOBYTE(v297) = 1;
  LOBYTE(v302) = 1;
LABEL_239:
  long long v306 = 0uLL;
  int v175 = CFDictionaryGetValue(theDicta, *(const void **)(a2 + 64));
  sub_100FC3BAC(&v306, a2, v175, *(void **)(a2 + 64), 0);
  if (!BYTE8(v306)) {
    goto LABEL_294;
  }
  id v176 = (void *)v306;
  uint64_t v281 = (void *)v306;
  if ((void)v306)
  {
    CFRetain((CFTypeRef)v306);
    id v176 = v281;
  }
  id v177 = [v176 objectForKey:@"voice"];
  if (v177 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    std::string::size_type v178 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v179 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v180 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v179;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v180;
      __int16 v315 = 2080;
      v316 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v178, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived voice subscription information", v310, 0x2Au);
    }
    *(void *)int buf = 0;
    *(void *)&long long v303 = 0;
    if (!sub_100FC7C60(a2, v177, buf, &v303)) {
      goto LABEL_252;
    }
    int v181 = sub_10114DFC0(*(const __CFString **)buf);
    LODWORD(v300) = v300 | v181;
    if (v181)
    {
      *(void *)uint64_t v310 = v303;
      sub_100013168((const void **)&v298, (CFTypeRef *)v310);
      int v182 = 1;
      goto LABEL_253;
    }
    uint64_t v183 = **(NSObject ***)(a2 + 40);
    int v182 = 0;
    if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v229 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v230 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v229;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v230;
      __int16 v315 = 2080;
      v316 = ", ";
      long long v186 = "#I %s%s%s%sUnable to parse voice subscription status";
LABEL_251:
      _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, v186, v310, 0x2Au);
LABEL_252:
      int v182 = 0;
    }
  }
  else
  {
    uint64_t v183 = **(NSObject ***)(a2 + 40);
    int v182 = 0;
    if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v184 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v185 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v184;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v185;
      __int16 v315 = 2080;
      v316 = ", ";
      long long v186 = "#I %s%s%s%sReceived invalid voice subscription information, skipping parsing";
      goto LABEL_251;
    }
  }
LABEL_253:
  sub_100057D78((const void **)&v281);
  long long v187 = (void *)v306;
  uint64_t v280 = (void *)v306;
  if ((void)v306)
  {
    CFRetain((CFTypeRef)v306);
    long long v187 = v280;
  }
  id v188 = [v187 objectForKey:@"data"];
  if (!v188 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v197 = **(NSObject ***)(a2 + 40);
    int v198 = 0;
    if (!os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_268;
    }
    uint64_t v199 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v200 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v199;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v200;
    __int16 v315 = 2080;
    v316 = ", ";
    int v201 = "#I %s%s%s%sReceived invalid data subscription information, skipping parsing";
LABEL_266:
    _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, v201, v310, 0x2Au);
LABEL_267:
    int v198 = 0;
    goto LABEL_268;
  }
  uint64_t v189 = **(NSObject ***)(a2 + 40);
  if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v190 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v191 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v190;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v191;
    __int16 v315 = 2080;
    v316 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived data subscription information", v310, 0x2Au);
  }
  *(void *)int buf = 0;
  *(void *)&long long v303 = 0;
  if (!sub_100FC7C60(a2, v188, buf, &v303)) {
    goto LABEL_267;
  }
  int v192 = (__CFString *)[v188 objectForKey:@"plan-mgt-type"];
  if (v192 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    unint64_t v193 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v194 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v195 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      id v196 = [(__CFString *)v192 cStringUsingEncoding:4];
      *(_DWORD *)uint64_t v310 = 136316162;
      *(void *)&v310[4] = v194;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v195;
      __int16 v315 = 2080;
      v316 = ", ";
      __int16 v317 = 2080;
      id v318 = v196;
      _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived subscription plan management type: %s", v310, 0x34u);
    }
  }
  else
  {
    CFIndex v223 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v223, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v224 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v225 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v224;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v225;
      __int16 v315 = 2080;
      v316 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v223, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno plan management type assume not cambio", v310, 0x2Au);
    }
    int v192 = @"unknown-plan-mgt";
  }
  int v226 = sub_10114DFC0(*(const __CFString **)buf);
  LODWORD(v300) = v300 | (v226 << 8);
  if (v226)
  {
    *(void *)uint64_t v310 = v303;
    sub_100013168((const void **)&v298 + 1, (CFTypeRef *)v310);
    *(void *)uint64_t v310 = v192;
    sub_100013168((const void **)&v299, (CFTypeRef *)v310);
    int v198 = 1;
    goto LABEL_268;
  }
  uint64_t v197 = **(NSObject ***)(a2 + 40);
  int v198 = 0;
  if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v231 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v232 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v231;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v232;
    __int16 v315 = 2080;
    v316 = ", ";
    int v201 = "#I %s%s%s%sUnable to parse data subscription status";
    goto LABEL_266;
  }
LABEL_268:
  sub_100057D78((const void **)&v280);
  uint64_t v202 = (void *)v306;
  int v279 = (const void *)v306;
  if ((void)v306) {
    CFRetain((CFTypeRef)v306);
  }
  id v203 = [v202 objectForKey:@"message"];
  if (v203 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    BOOL v204 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v205 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v206 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v205;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v206;
      __int16 v315 = 2080;
      v316 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived message subscription information", v310, 0x2Au);
    }
    *(void *)int buf = 0;
    *(void *)&long long v303 = 0;
    if (!sub_100FC7C60(a2, v203, buf, &v303)) {
      goto LABEL_280;
    }
    int v207 = sub_10114DFC0(*(const __CFString **)buf);
    LODWORD(v300) = v300 | (v207 << 16);
    if (v207)
    {
      *(void *)uint64_t v310 = v303;
      sub_100013168((const void **)&v299 + 1, (CFTypeRef *)v310);
      int v208 = 1;
      goto LABEL_281;
    }
    uint64_t v209 = **(NSObject ***)(a2 + 40);
    int v208 = 0;
    if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v233 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v234 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v233;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v234;
      __int16 v315 = 2080;
      v316 = ", ";
      v212 = "#I %s%s%s%sUnable to parse message subscription status";
LABEL_279:
      _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_DEFAULT, v212, v310, 0x2Au);
LABEL_280:
      int v208 = 0;
    }
  }
  else
  {
    uint64_t v209 = **(NSObject ***)(a2 + 40);
    int v208 = 0;
    if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v210 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v211 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v310 = 136315906;
      *(void *)&v310[4] = v210;
      __int16 v311 = 2080;
      v312 = " ";
      __int16 v313 = 2080;
      uint64_t v314 = v211;
      __int16 v315 = 2080;
      v316 = ", ";
      v212 = "#I %s%s%s%sReceived invalid message subscription information, skipping parsing";
      goto LABEL_279;
    }
  }
LABEL_281:
  sub_100057D78(&v279);
  uint64_t v213 = (void *)v306;
  v278 = (const void *)v306;
  if ((void)v306) {
    CFRetain((CFTypeRef)v306);
  }
  id v214 = [v213 objectForKey:@"account-info"];
  if (v214)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v215 = **(NSObject ***)(a2 + 40);
      if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v216 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v217 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)uint64_t v310 = 136315906;
        *(void *)&v310[4] = v216;
        __int16 v311 = 2080;
        v312 = " ";
        __int16 v313 = 2080;
        uint64_t v314 = v217;
        __int16 v315 = 2080;
        v316 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived account subscription information", v310, 0x2Au);
      }
      id v218 = [v214 objectForKey:@"stacking"];
      if (v218)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if ([v218 isEqualToString:@"yes"])
          {
            int v219 = DWORD1(v300);
            goto LABEL_303;
          }
          if ([v218 isEqualToString:@"no"])
          {
            int v219 = DWORD1(v300);
LABEL_312:
            int v228 = v219 | 0x20;
            goto LABEL_313;
          }
          unsigned int v235 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v235, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v241 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v242 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)uint64_t v310 = 136315906;
            *(void *)&v310[4] = v241;
            __int16 v311 = 2080;
            v312 = " ";
            __int16 v313 = 2080;
            uint64_t v314 = v242;
            __int16 v315 = 2080;
            v316 = ", ";
            uint64_t v238 = "#W %s%s%s%sstacking has invalid string";
LABEL_321:
            _os_log_impl((void *)&_mh_execute_header, v235, OS_LOG_TYPE_DEFAULT, v238, v310, 0x2Au);
          }
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            unsigned int v227 = [v218 BOOLValue];
            int v219 = DWORD1(v300);
            if (!v227) {
              goto LABEL_312;
            }
LABEL_303:
            int v228 = v219 | 0x10;
LABEL_313:
            DWORD1(v300) = v228;
          }
          else
          {
            unsigned int v235 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v235, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v236 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v237 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              *(_DWORD *)uint64_t v310 = 136315906;
              *(void *)&v310[4] = v236;
              __int16 v311 = 2080;
              v312 = " ";
              __int16 v313 = 2080;
              uint64_t v314 = v237;
              __int16 v315 = 2080;
              v316 = ", ";
              uint64_t v238 = "#W %s%s%s%sunable to parse stacking info";
              goto LABEL_321;
            }
          }
        }
      }
      id v243 = [v214 objectForKey:@"auto-renew"];
      if (v243)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if ([v243 isEqualToString:@"yes"])
          {
            int v244 = DWORD1(v300);
            goto LABEL_328;
          }
          if ([v243 isEqualToString:@"no"])
          {
            int v244 = DWORD1(v300);
LABEL_331:
            int v246 = v244 | 8;
            goto LABEL_332;
          }
          uint64_t v247 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v251 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v252 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)uint64_t v310 = 136315906;
            *(void *)&v310[4] = v251;
            __int16 v311 = 2080;
            v312 = " ";
            __int16 v313 = 2080;
            uint64_t v314 = v252;
            __int16 v315 = 2080;
            v316 = ", ";
            int v250 = "#W %s%s%s%sauto-renew has invalid string";
LABEL_337:
            _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_DEFAULT, v250, v310, 0x2Au);
          }
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            unsigned int v245 = [v243 BOOLValue];
            int v244 = DWORD1(v300);
            if (!v245) {
              goto LABEL_331;
            }
LABEL_328:
            int v246 = v244 | 4;
LABEL_332:
            DWORD1(v300) = v246;
          }
          else
          {
            uint64_t v247 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v248 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v249 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              *(_DWORD *)uint64_t v310 = 136315906;
              *(void *)&v310[4] = v248;
              __int16 v311 = 2080;
              v312 = " ";
              __int16 v313 = 2080;
              uint64_t v314 = v249;
              __int16 v315 = 2080;
              v316 = ", ";
              int v250 = "#W %s%s%s%sunable to parse auto-renew info";
              goto LABEL_337;
            }
          }
        }
      }
      id v253 = [v214 objectForKey:@"plan-type"];
      if (v253 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        if ([v253 isEqualToString:@"bucket"])
        {
          int v254 = DWORD1(v300) | 1;
          goto LABEL_347;
        }
        if ([v253 isEqualToString:@"time"])
        {
          int v254 = DWORD1(v300) | 2;
LABEL_347:
          DWORD1(v300) = v254;
LABEL_348:
          *(void *)int buf = 0;
          *(void *)&long long v303 = 0;
          if (sub_100FC79C8(a2, v214, @"billing-cycle-start-date", (double *)buf))
          {
            if (sub_100FC79C8(a2, v214, @"billing-cycle-end-date", (double *)&v303))
            {
              uint64_t v259 = *(void **)buf;
              uint64_t v260 = v303;
              *((void *)&v300 + 1) = *(void *)buf;
              *(void *)&long long v301 = v303;
              v261 = **(NSObject ***)(a2 + 40);
              if (os_log_type_enabled(v261, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v262 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
                uint64_t v263 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
                *(_DWORD *)uint64_t v310 = 136316418;
                *(void *)&v310[4] = v262;
                __int16 v311 = 2080;
                v312 = " ";
                __int16 v313 = 2080;
                uint64_t v314 = v263;
                __int16 v315 = 2080;
                v316 = ", ";
                __int16 v317 = 2048;
                id v318 = v259;
                __int16 v319 = 2048;
                uint64_t v320 = v260;
                _os_log_impl((void *)&_mh_execute_header, v261, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived billing start time: %f and billing end time: %f", v310, 0x3Eu);
              }
            }
          }
          sub_100057D78(&v278);
LABEL_353:
          LOBYTE(v302) = 1;
LABEL_354:
          uint64_t v264 = operator new(0xB0uLL);
          v264[1] = 0;
          v264[2] = 0;
          *uint64_t v264 = off_101A798D0;
          *char v277 = sub_10114E0F4((uint64_t)(v264 + 3), (uint64_t)&v298, (uint64_t)&v289);
          v277[1] = (uint64_t)v264;
          goto LABEL_355;
        }
        uint64_t v255 = **(NSObject ***)(a2 + 40);
        if (!os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_348;
        }
        uint64_t v266 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v267 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)uint64_t v310 = 136315906;
        *(void *)&v310[4] = v266;
        __int16 v311 = 2080;
        v312 = " ";
        __int16 v313 = 2080;
        uint64_t v314 = v267;
        __int16 v315 = 2080;
        v316 = ", ";
        unint64_t v258 = "#I %s%s%s%sinvalid data plan type";
      }
      else
      {
        uint64_t v255 = **(NSObject ***)(a2 + 40);
        if (!os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_348;
        }
        uint64_t v256 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v257 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        *(_DWORD *)uint64_t v310 = 136315906;
        *(void *)&v310[4] = v256;
        __int16 v311 = 2080;
        v312 = " ";
        __int16 v313 = 2080;
        uint64_t v314 = v257;
        __int16 v315 = 2080;
        v316 = ", ";
        unint64_t v258 = "#I %s%s%s%ssubscription does not have valid plan type";
      }
      _os_log_impl((void *)&_mh_execute_header, v255, OS_LOG_TYPE_DEFAULT, v258, v310, 0x2Au);
      goto LABEL_348;
    }
  }
  uint64_t v220 = **(NSObject ***)(a2 + 40);
  if (os_log_type_enabled(v220, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v221 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v222 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    *(_DWORD *)uint64_t v310 = 136315906;
    *(void *)&v310[4] = v221;
    __int16 v311 = 2080;
    v312 = " ";
    __int16 v313 = 2080;
    uint64_t v314 = v222;
    __int16 v315 = 2080;
    v316 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v220, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived invalid account subscription information, skipping parsing", v310, 0x2Au);
  }
  sub_100057D78(&v278);
  if (v182 | v198 | v208) {
    goto LABEL_353;
  }
LABEL_294:
  if (v162) {
    goto LABEL_354;
  }
  *char v277 = 0;
  v277[1] = 0;
LABEL_355:
  if (BYTE8(v306)) {
    sub_100057D78((const void **)&v306);
  }
  if ((_BYTE)v286) {
    sub_100057D78(&cf);
  }
  if ((_BYTE)v288) {
    sub_100057D78((const void **)&theDicta);
  }
LABEL_361:
  sub_1000346F8((uint64_t)&v294, v295);
  sub_1000346F8((uint64_t)&v291, v292);
  sub_1000346F8((uint64_t)&v289, (void *)v290);
  sub_1000558F4((const void **)&v299 + 1);
  sub_1000558F4((const void **)&v299);
  sub_1000558F4((const void **)&v298 + 1);
  return sub_1000558F4((const void **)&v298);
}

void sub_100FC7130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,const void *a31,uint64_t a32,const void *a33,char a34,const void *a35,char a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47)
{
  if (a34) {
    sub_100057D78(&a33);
  }
  if (a36) {
    sub_100057D78(&a35);
  }
  sub_100FC7240(&a37);
  sub_1001A2238(&a47);
  _Unwind_Resume(a1);
}

void **sub_100FC7240(void **a1)
{
  return a1;
}

BOOL sub_100FC7288(void *a1, uint64_t *a2)
{
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id v3 = [a1 countByEnumeratingWithState:&v28 objects:v32 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v29;
    do
    {
      for (int i = 0; i != v3; int i = (char *)i + 1)
      {
        if (*(void *)v29 != v4) {
          objc_enumerationMutation(a1);
        }
        CFTypeRef v6 = *(void **)(*((void *)&v28 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v7 = [v6 objectForKey:@"plmn"];
          if (v7)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v8 = [v7 objectForKey:@"mcc"];
              if (v8)
              {
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  id v9 = [v7 objectForKey:@"mnc"];
                  if (v9)
                  {
                    objc_opt_class();
                    if (objc_opt_isKindOfClass())
                    {
                      id v10 = [v6 objectForKey:@"rat-mask"];
                      if (v10)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass())
                        {
                          id v11 = [v6 objectForKey:@"priority"];
                          if (v11)
                          {
                            objc_opt_class();
                            if (objc_opt_isKindOfClass())
                            {
                              memset(&__str, 0, sizeof(__str));
                              sub_100058DB0(&__str, (char *)[v8 cStringUsingEncoding:4]);
                              memset(&__p, 0, sizeof(__p));
                              sub_100058DB0(&__p, (char *)[v9 cStringUsingEncoding:4]);
                              unsigned int v12 = [v10 unsignedIntValue];
                              unsigned int v13 = [v11 unsignedIntValue];
                              uint64_t v25 = 0;
                              long long v24 = 0u;
                              memset(v23, 0, sizeof(v23));
                              std::string::operator=((std::string *)v23, &__str);
                              sub_100093B44((std::string *)&v23[24], &__p);
                              uint64_t v22 = 0;
                              long long v20 = 0u;
                              long long v21 = 0u;
                              memset(v19, 0, sizeof(v19));
                              std::string::operator=((std::string *)v19, (const std::string *)v23);
                              sub_100179AF8((std::string *)&v19[24], (const std::string *)&v23[24]);
                              *((void *)&v21 + 1) = __PAIR64__(v13, v12);
                              LOBYTE(v22) = 1;
                              unint64_t v14 = a2[1];
                              if (v14 >= a2[2])
                              {
                                uint64_t v15 = sub_100C9238C(a2, (long long *)v19);
                                uint64_t v16 = a2;
                              }
                              else
                              {
                                sub_100C924AC((void *)a2[1], (long long *)v19);
                                uint64_t v15 = v14 + 72;
                                uint64_t v16 = a2;
                                a2[1] = v14 + 72;
                              }
                              v16[1] = v15;
                              if ((_BYTE)v21 && SHIBYTE(v20) < 0) {
                                operator delete(*(void **)&v19[24]);
                              }
                              if ((v19[23] & 0x80000000) != 0) {
                                operator delete(*(void **)v19);
                              }
                              if ((_BYTE)v25 && SHIBYTE(v24) < 0) {
                                operator delete(*(void **)&v23[24]);
                              }
                              if ((v23[23] & 0x80000000) != 0) {
                                operator delete(*(void **)v23);
                              }
                              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__p.__r_.__value_.__l.__data_);
                              }
                              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                                operator delete(__str.__r_.__value_.__l.__data_);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      id v3 = [a1 countByEnumeratingWithState:&v28 objects:v32 count:16];
    }
    while (v3);
  }
  return *a2 != a2[1];
}

void sub_100FC7618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  *(void *)(a12 + 8) = v42;
  sub_1001F8E8C((uint64_t)&a13);
  sub_1001F8E8C((uint64_t)&a23);
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100FC7688(uint64_t a1, std::string **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if ((std::string **)a1 != a2) {
      sub_1001A06BC(a1, *a2, a2[1], 0x8E38E38E38E38E39 * (((char *)a2[1] - (char *)*a2) >> 3));
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_10019E620((void *)a1, (uint64_t)*a2, (uint64_t)a2[1], 0x8E38E38E38E38E39 * (((char *)a2[1] - (char *)*a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100FC7728(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC77AC(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  id v3 = (void **)(a1 + 32);
  sub_100047F64(&v3);
  id v3 = (void **)(a1 + 8);
  sub_100047F64(&v3);
  return a1;
}

uint64_t sub_100FC7808(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 40) objectEnumerator];
  if (v3
    && (uint64_t v4 = v3,
        long long v13 = 0u,
        long long v14 = 0u,
        long long v11 = 0u,
        long long v12 = 0u,
        (id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16]) != 0))
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    while (2)
    {
      for (int i = 0; i != v6; int i = (char *)i + 1)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        if ([*(id *)(*((void *)&v11 + 1) + 8 * i) bootstrapDataAllowed])
        {
          uint64_t v9 = 1;
          goto LABEL_13;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      uint64_t v9 = 0;
      if (v6) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
LABEL_13:
  return v9;
}

uint64_t sub_100FC7924(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 256;
    sub_1003AA7DC(i - 256);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC7974(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_100FC79C8(uint64_t a1, void *a2, void *a3, double *a4)
{
  id v7 = objc_msgSend(a2, "objectForKey:");
  if (v7 && (id v8 = v7, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    id v9 = [*(id *)(a1 + 72) dateFromString:v8];
    if (v9)
    {
      [v9 timeIntervalSinceReferenceDate];
      if (v10 != 0.0)
      {
        *a4 = v10;
        return 1;
      }
    }
    else
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v21 = 0;
      sub_100058DB0(__p, (char *)[a3 cStringUsingEncoding:4]);
      uint64_t v16 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        id v19 = __p;
        if (v21 < 0) {
          id v19 = (void **)__p[0];
        }
        *(_DWORD *)int buf = 136316162;
        uint64_t v23 = v17;
        __int16 v24 = 2080;
        uint64_t v25 = " ";
        __int16 v26 = 2080;
        uint64_t v27 = v18;
        __int16 v28 = 2080;
        long long v29 = ", ";
        __int16 v30 = 2080;
        long long v31 = v19;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sFailed to parse date for key %s", buf, 0x34u);
      }
      if (SHIBYTE(v21) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    long long v12 = **(NSObject ***)(a1 + 40);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    uint64_t v23 = v14;
    __int16 v24 = 2080;
    uint64_t v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v15;
    __int16 v28 = 2080;
    long long v29 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUnable to parse date since it is not a string", buf, 0x2Au);
  }
  return 0;
}

void sub_100FC7C3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC7C60(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8 = [a2 objectForKey:@"subscription-status"];
  if (!v8 || (id v9 = v8, objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    id v19 = **(NSObject ***)(a1 + 40);
    BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v20) {
      return result;
    }
    uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v27 = 136315906;
    uint64_t v28 = v21;
    __int16 v29 = 2080;
    __int16 v30 = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v22;
    __int16 v33 = 2080;
    int v34 = ", ";
    uint64_t v23 = "#I %s%s%s%sSubscription status is invalid";
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v27, 0x2Au);
    return 0;
  }
  if (![v9 length])
  {
    id v19 = **(NSObject ***)(a1 + 40);
    BOOL v24 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v24) {
      return result;
    }
    uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v27 = 136315906;
    uint64_t v28 = v25;
    __int16 v29 = 2080;
    __int16 v30 = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v26;
    __int16 v33 = 2080;
    int v34 = ", ";
    uint64_t v23 = "#I %s%s%s%sReceived an empty value for subscription status";
    goto LABEL_13;
  }
  *a3 = v9;
  double v10 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v27 = 136316162;
    uint64_t v28 = v11;
    __int16 v29 = 2080;
    __int16 v30 = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v12;
    __int16 v33 = 2080;
    int v34 = ", ";
    __int16 v35 = 2080;
    id v36 = [v9 cStringUsingEncoding:4];
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived subscription status: %s", (uint8_t *)&v27, 0x34u);
  }
  uint64_t result = (uint64_t)[a2 objectForKey:@"plan-type"];
  if (result)
  {
    uint64_t v14 = (void *)result;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      *a4 = v14;
      uint64_t v15 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        id v18 = [v14 cStringUsingEncoding:4];
        int v27 = 136316162;
        uint64_t v28 = v16;
        __int16 v29 = 2080;
        __int16 v30 = " ";
        __int16 v31 = 2080;
        uint64_t v32 = v17;
        __int16 v33 = 2080;
        int v34 = ", ";
        __int16 v35 = 2080;
        id v36 = v18;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived subscription plan type: %s", (uint8_t *)&v27, 0x34u);
      }
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_100FC804C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_100FC824C(v4 - 192);
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100FC80D0(uint64_t a1, long long *a2)
{
  uint64_t v4 = sub_1000593FC(a1, a2);
  sub_1000593FC(v4 + 32, a2 + 2);
  sub_1000593FC(a1 + 64, a2 + 4);
  sub_1000593FC(a1 + 96, a2 + 6);
  sub_1000593FC(a1 + 128, a2 + 8);
  sub_1000593FC(a1 + 160, a2 + 10);
  return a1;
}

void sub_100FC8158(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 152) && *(char *)(v1 + 151) < 0) {
    operator delete(*v5);
  }
  if (*(unsigned char *)(v1 + 120) && *(char *)(v1 + 119) < 0) {
    operator delete(*v4);
  }
  if (*(unsigned char *)(v1 + 88) && *(char *)(v1 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC81FC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 192;
    sub_100FC824C(i - 192);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC824C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 184) && *(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100FC8300(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_100FC8570(v4 - 264);
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100FC8384(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1000593FC(a1, (long long *)a2);
  sub_1000593FC(v4 + 32, (long long *)(a2 + 32));
  sub_1000593FC(a1 + 64, (long long *)(a2 + 64));
  sub_1000593FC(a1 + 96, (long long *)(a2 + 96));
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  sub_1000593FC(a1 + 136, (long long *)(a2 + 136));
  sub_1000593FC(a1 + 168, (long long *)(a2 + 168));
  sub_1000593FC(a1 + 200, (long long *)(a2 + 200));
  sub_1000593FC(a1 + 232, (long long *)(a2 + 232));
  return a1;
}

void sub_100FC843C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 224) && *(char *)(v1 + 223) < 0) {
    operator delete(*v7);
  }
  if (*(unsigned char *)(v1 + 192) && *(char *)(v1 + 191) < 0) {
    operator delete(*v6);
  }
  if (*(unsigned char *)(v1 + 160) && *(char *)(v1 + 159) < 0) {
    operator delete(*v5);
  }
  if (*(unsigned char *)(v1 + 120) && *(char *)(v1 + 119) < 0) {
    operator delete(*v4);
  }
  if (*(unsigned char *)(v1 + 88) && *(char *)(v1 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC8520(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 264;
    sub_100FC8570(i - 264);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC8570(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 256) && *(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(unsigned char *)(a1 + 224) && *(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  if (*(unsigned char *)(a1 + 192) && *(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(unsigned char *)(a1 + 160) && *(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC8654(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136) && *(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100FC86D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136) && *(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100FC8770(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 160;
        sub_100FC86D8(v4);
      }
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100FC87F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1000593FC(a1, (long long *)a2);
  sub_1000593FC(v4 + 32, (long long *)(a2 + 32));
  *(_WORD *)(a1 + 64) = *(_WORD *)(a2 + 64);
  sub_1000593FC(a1 + 72, (long long *)(a2 + 72));
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  sub_1000593FC(a1 + 112, (long long *)(a2 + 112));
  uint64_t v5 = *(void *)(a2 + 144);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  *(void *)(a1 + 144) = v5;
  return a1;
}

void sub_100FC8874(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 96) && *(char *)(v1 + 95) < 0) {
    operator delete(*v3);
  }
  if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC88D8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 160;
    sub_100FC86D8(i - 160);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FC8928(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 48;
      *(void *)(a1 + 16) = v2 - 48;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100FC898C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  *((void *)__dst + 6) = 0;
  *((void *)__dst + 7) = 0;
  *((void *)__dst + 8) = 0;
  sub_10019F548((void *)__dst + 6, *((void *)a2 + 6), *((void *)a2 + 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 4));
  return __dst;
}

void sub_100FC8A3C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FC8A70(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1000302C0((char *)(a1 + 8), *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000302C0((char *)(a1 + 32), *(long long **)(a2 + 32), *(long long **)(a2 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  long long v4 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)long long v4 = v5;
  }
  return a1;
}

void sub_100FC8B38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_100FC8B64(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = (void **)(a1 + 32);
  sub_100047F64(&v2);
  uint64_t v2 = (void **)(a1 + 8);
  sub_100047F64(&v2);
}

uint64_t sub_100FC8BBC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_100FC8B64(i - 80);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100FC8C10()
{
}

void *sub_100FC8C24(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79380;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC8C6C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79380;
  a2[1] = v2;
  return result;
}

void sub_100FC8C98(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *(void *)(v3 + 72);
    if (*((char *)a2 + 23) >= 0) {
      id v8 = a2;
    }
    else {
      id v8 = (uint64_t *)*a2;
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    id v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v9, 0x34u);
  }
}

uint64_t sub_100FC8D90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FC8DD0()
{
}

void sub_100FC8DE0()
{
}

void *sub_100FC8DF4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79400;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC8E3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79400;
  a2[1] = v2;
  return result;
}

void sub_100FC8E68(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *(void *)(v3 + 72);
    if (*((char *)a2 + 23) >= 0) {
      id v8 = a2;
    }
    else {
      id v8 = (uint64_t *)*a2;
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    id v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v9, 0x34u);
  }
}

uint64_t sub_100FC8F60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FC8FA0()
{
}

void sub_100FC8FB0()
{
}

void *sub_100FC8FC4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79480;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC900C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79480;
  a2[1] = v2;
  return result;
}

void sub_100FC9038(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *(void *)(v3 + 72);
    if (*((char *)a2 + 23) >= 0) {
      id v8 = a2;
    }
    else {
      id v8 = (uint64_t *)*a2;
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    id v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v9, 0x34u);
  }
}

uint64_t sub_100FC9130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FC9170()
{
}

void sub_100FC9180()
{
}

void *sub_100FC9194(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79500;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC91DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79500;
  a2[1] = v2;
  return result;
}

void sub_100FC9208(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 16));
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = *(void *)(v3 + 72);
    if (*((char *)a2 + 23) >= 0) {
      id v8 = a2;
    }
    else {
      id v8 = (uint64_t *)*a2;
    }
    int v9 = 136316162;
    uint64_t v10 = v5;
    __int16 v11 = 2080;
    uint64_t v12 = " ";
    __int16 v13 = 2080;
    uint64_t v14 = v6;
    __int16 v15 = 2080;
    uint64_t v16 = v7;
    __int16 v17 = 2080;
    id v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v9, 0x34u);
  }
}

uint64_t sub_100FC9300(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FC9340()
{
}

void sub_100FC934C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79580;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC936C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79580;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC93C0(uint64_t a1)
{
  sub_1000346F8(a1 + 104, *(void **)(a1 + 112));
  sub_10005D0E4(a1 + 80, *(void **)(a1 + 88));
  sub_1000346F8(a1 + 56, *(void **)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 40);

  sub_1000346F8(a1 + 32, v2);
}

void sub_100FC9420(void *a1, int a2, uint64_t a3, std::__shared_weak_count *a4)
{
  id v8 = operator new(0x30uLL);
  int v9 = v8;
  v8[1] = 0;
  _DWORD v8[2] = 0;
  void *v8 = off_101A795D0;
  uint64_t v10 = (char *)(v8 + 3);
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v8 + 6) = a2;
    v8[4] = a3;
    v8[5] = a4;
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(a4);
  }
  else
  {
    *((_DWORD *)v8 + 6) = a2;
    v8[4] = a3;
    v8[5] = 0;
  }
  *a1 = v10;
  a1[1] = v9;
}

void sub_100FC94C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A795D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC94E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A795D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC9534(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FC954C()
{
}

void *sub_100FC9560(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79620;
  result[1] = v3;
  return result;
}

uint64_t sub_100FC95A8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79620;
  a2[1] = v2;
  return result;
}

void sub_100FC95D4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 24));
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    int v8 = 136316162;
    uint64_t v9 = v5;
    __int16 v10 = 2080;
    __int16 v11 = " ";
    __int16 v12 = 2080;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    __int16 v15 = ", ";
    __int16 v16 = 2080;
    __int16 v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v8, 0x34u);
  }
}

uint64_t sub_100FC96FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FC973C()
{
}

void sub_100FC9748(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A796A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9768(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A796A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC97BC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = (void **)(a1 + 24);
    sub_1001A14F4(&v2);
  }
}

void sub_100FC9818(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A796F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9838(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A796F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC988C(uint64_t a1)
{
  uint64_t v2 = a1 + 24;
  sub_1000346F8(a1 + 48, *(void **)(a1 + 56));
  uint64_t v3 = *(void **)(a1 + 32);

  sub_1000346F8(v2, v3);
}

void sub_100FC98D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79740;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC98F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79740;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC994C(uint64_t a1)
{
  sub_1000346F8(a1 + 48, *(void **)(a1 + 56));
  uint64_t v2 = *(char **)(a1 + 32);

  sub_100FC9990(v2);
}

void sub_100FC9990(char *a1)
{
  if (a1)
  {
    sub_100FC9990(*(void *)a1);
    sub_100FC9990(*((void *)a1 + 1));
    sub_100FC7974((uint64_t)(a1 + 72));
    if (a1[64])
    {
      uint64_t v2 = (void **)(a1 + 40);
      sub_100C92308(&v2);
    }
    operator delete(a1);
  }
}

char *sub_100FC9A04(uint64_t a1, uint64_t a2, char *__dst)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_100179AF8((std::string *)__dst, (const std::string *)v5);
      sub_100179AF8((std::string *)(__dst + 32), (const std::string *)(v5 + 32));
      sub_100179AF8((std::string *)(__dst + 64), (const std::string *)(v5 + 64));
      sub_100179AF8((std::string *)__dst + 4, (const std::string *)(v5 + 96));
      sub_100179AF8((std::string *)(__dst + 128), (const std::string *)(v5 + 128));
      sub_100179AF8((std::string *)(__dst + 160), (const std::string *)(v5 + 160));
      sub_100179AF8((std::string *)__dst + 8, (const std::string *)(v5 + 192));
      sub_100179AF8((std::string *)(__dst + 224), (const std::string *)(v5 + 224));
      __dst += 256;
      v5 += 256;
    }
    while (v5 != a2);
  }
  return __dst;
}

void sub_100FC9AB0(std::string *__dst, std::string *__str)
{
  if (__dst[2].__r_.__value_.__s.__data_[8] == __str[2].__r_.__value_.__s.__data_[8])
  {
    if (__dst[2].__r_.__value_.__s.__data_[8])
    {
      std::string::operator=(__dst, __str);
      sub_100179AF8(__dst + 1, __str + 1);
    }
  }
  else if (__dst[2].__r_.__value_.__s.__data_[8])
  {
    sub_100FC9B50((uint64_t)__dst);
  }
  else
  {
    sub_100FC9BA4(__dst, (long long *)__str);
    __dst[2].__r_.__value_.__s.__data_[8] = 1;
  }
}

void sub_100FC9B50(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 56) = 0;
  }
}

void *sub_100FC9BA4(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_1000593FC((uint64_t)(__dst + 3), (long long *)((char *)a2 + 24));
  return __dst;
}

void sub_100FC9C00(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FC9C1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9C3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79790;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FC9C90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 8))();
}

void sub_100FC9CB8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A797E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9CD8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A797E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC9D2C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168) && *(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(unsigned char *)(a1 + 136) && *(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void sub_100FC9DC8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9DE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79830;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC9E3C(uint64_t a1)
{
}

void sub_100FC9E48(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9E68(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79880;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FC9EBC(uint64_t a1)
{
}

void sub_100FC9EC8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A798D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9EE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A798D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_100FC9F3C(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 24);
  uint64_t v3 = a1 + 96;
  sub_1000346F8(a1 + 144, *(void **)(a1 + 152));
  sub_1000346F8(a1 + 120, *(void **)(a1 + 128));
  sub_1000346F8(v3, *(void **)(a1 + 104));
  sub_1000558F4((const void **)(a1 + 48));
  sub_1000558F4((const void **)(a1 + 40));
  sub_1000558F4((const void **)(a1 + 32));

  return sub_1000558F4(v2);
}

void sub_100FC9FC0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FC9FE0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79920;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCA034(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void sub_100FCA0A4()
{
}

void *sub_100FCA0B8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A79970;
  result[1] = v3;
  return result;
}

uint64_t sub_100FCA100(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A79970;
  a2[1] = v2;
  return result;
}

void sub_100FCA12C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = **(NSObject ***)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v3 + 24));
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    int v8 = 136316162;
    uint64_t v9 = v5;
    __int16 v10 = 2080;
    __int16 v11 = " ";
    __int16 v12 = 2080;
    uint64_t v13 = v6;
    __int16 v14 = 2080;
    __int16 v15 = ", ";
    __int16 v16 = 2080;
    __int16 v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s", (uint8_t *)&v8, 0x34u);
  }
}

uint64_t sub_100FCA254(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FCA294()
{
}

char *sub_100FCA2A0(char *__dst, uint64_t a2)
{
  if (__dst[456])
  {
    sub_100179AF8((std::string *)__dst, (const std::string *)a2);
    sub_100179D50((uint64_t)(__dst + 32), a2 + 32);
    sub_100179D50((uint64_t)(__dst + 64), a2 + 64);
    sub_100179AF8((std::string *)__dst + 4, (const std::string *)(a2 + 96));
    sub_1001A1DB8((uint64_t)(__dst + 128), a2 + 128);
    sub_100179AF8((std::string *)(__dst + 160), (const std::string *)(a2 + 160));
    sub_100179AF8((std::string *)__dst + 8, (const std::string *)(a2 + 192));
    sub_1001A2098(__dst + 224, a2 + 224);
  }
  else
  {
    sub_1001A1708((uint64_t)__dst, (long long *)a2);
    __dst[456] = 1;
  }
  return __dst;
}

char *sub_100FCA348(void *a1)
{
  uint64_t v2 = operator new(0x270uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = off_101A78ED0;
  *((unsigned char *)v2 + 32) = 0;
  *((unsigned char *)v2 + 56) = 0;
  *((unsigned char *)v2 + 64) = 0;
  *((unsigned char *)v2 + 88) = 0;
  *((unsigned char *)v2 + 96) = 0;
  *((unsigned char *)v2 + 120) = 0;
  *((unsigned char *)v2 + 128) = 0;
  *((unsigned char *)v2 + 584) = 0;
  *((unsigned char *)v2 + 592) = 0;
  *((unsigned char *)v2 + 616) = 0;
  a1[1] = v2;
  *((unsigned char *)v2 + 24) = 0;
  uint64_t result = (char *)(v2 + 3);
  *a1 = result;
  return result;
}

uint64_t sub_100FCA3C4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_1001A1FC0((void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100FCA440(int64x2_t *a1, long long *a2)
{
  unint64_t v6 = a1[1].u64[0];
  uint64_t i64 = (uint64_t)a1[1].i64;
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(i64 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - a1->i64[0]) >> 6;
    if ((unint64_t)(v10 + 1) >> 58) {
      sub_10006A748();
    }
    uint64_t v11 = v5 - a1->i64[0];
    uint64_t v12 = v11 >> 5;
    if (v11 >> 5 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v30 = i64;
    if (v13) {
      __int16 v14 = (char *)sub_1001A14BC(i64, v13);
    }
    else {
      __int16 v14 = 0;
    }
    int v27 = v14;
    v28.i64[0] = (uint64_t)&v14[64 * v10];
    __int16 v29 = &v14[64 * v13];
    sub_100FCA608(v28.i64[0], a2);
    uint64_t v15 = v28.i64[0];
    uint64_t v9 = v28.i64[0] + 64;
    v28.i64[1] = v28.i64[0] + 64;
    uint64_t v17 = a1->i64[0];
    unint64_t v16 = a1->u64[1];
    if (v16 == a1->i64[0])
    {
      int64x2_t v25 = vdupq_n_s64(v16);
    }
    else
    {
      uint64_t v18 = 0;
      do
      {
        uint64_t v19 = v15 + v18;
        *(unsigned char *)(v15 + v18 - 64) = 0;
        uint64_t v20 = v16 + v18;
        *(unsigned char *)(v15 + v18 - 40) = 0;
        if (*(unsigned char *)(v16 + v18 - 40))
        {
          uint64_t v21 = (void *)(v20 - 64);
          long long v22 = *(_OWORD *)(v20 - 64);
          *(void *)(v15 + v18 - 48) = *(void *)(v20 - 48);
          *(_OWORD *)(v15 + v18 - 64) = v22;
          v21[1] = 0;
          _OWORD v21[2] = 0;
          *uint64_t v21 = 0;
          *(unsigned char *)(v19 - 40) = 1;
        }
        *(unsigned char *)(v19 - 32) = 0;
        *(unsigned char *)(v19 - 8) = 0;
        if (*(unsigned char *)(v20 - 8))
        {
          uint64_t v23 = v16 + v18;
          long long v24 = *(_OWORD *)(v16 + v18 - 32);
          *(void *)(v19 - 16) = *(void *)(v16 + v18 - 16);
          *(_OWORD *)(v19 - 32) = v24;
          *(void *)(v23 - 24) = 0;
          *(void *)(v23 - 16) = 0;
          *(void *)(v23 - 32) = 0;
          *(unsigned char *)(v19 - 8) = 1;
        }
        v18 -= 64;
      }
      while (v16 + v18 != v17);
      int64x2_t v25 = *a1;
      uint64_t v9 = v28.i64[1];
      v15 += v18;
    }
    a1->i64[0] = v15;
    a1->i64[1] = v9;
    int64x2_t v28 = v25;
    uint64_t v26 = (char *)a1[1].i64[0];
    a1[1].i64[0] = (uint64_t)v29;
    __int16 v29 = v26;
    int v27 = (char *)v25.i64[0];
    uint64_t result = sub_100FCA664((uint64_t)&v27);
  }
  else
  {
    uint64_t result = sub_100FCA608(*(void *)(i64 - 8), a2);
    uint64_t v9 = v7 + 64;
    a1->i64[1] = v7 + 64;
  }
  a1->i64[1] = v9;
  return result;
}

void sub_100FCA5E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100FCA664((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100FCA608(uint64_t a1, long long *a2)
{
  uint64_t v4 = sub_1000593FC(a1, a2);
  sub_1000593FC(v4 + 32, a2 + 2);
  return a1;
}

void sub_100FCA640(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FCA664(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    sub_10019D91C(i - 64);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 sub_100FCA6B4(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1001A1FC0((void **)a1);
      __n128 result = *a2;
      *(__n128 *)a1 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      a2->n128_u64[0] = 0;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    unint64_t v5 = (void **)a1;
    sub_10019D898(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

void sub_100FCA758(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 224) == a2[14].n128_u8[0])
  {
    if (*(unsigned char *)(a1 + 224))
    {
      sub_1003AA440(a1, a2);
    }
  }
  else if (*(unsigned char *)(a1 + 224))
  {
    sub_10019D7CC(a1);
    *(unsigned char *)(a1 + 224) = 0;
  }
  else
  {
    sub_1003AA4D0(a1, a2);
    *(unsigned char *)(a1 + 224) = 1;
  }
}

void sub_100FCA7CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A799F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCA7EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A799F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCA840(uint64_t a1)
{
}

void sub_100FCA84C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79A40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCA86C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79A40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCA8C0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    uint64_t v3 = (void **)(a1 + 152);
    sub_100FC8770(&v3);
  }
  if (*(unsigned char *)(a1 + 144))
  {
    uint64_t v3 = (void **)(a1 + 120);
    sub_100FC8300(&v3);
  }
  if (*(unsigned char *)(a1 + 112))
  {
    uint64_t v3 = (void **)(a1 + 88);
    sub_100FC804C(&v3);
  }
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void sub_100FCA980(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79A90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCA9A0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79A90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCA9F4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void sub_100FCAA68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79AE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAA88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79AE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCAADC(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_100FCAAF4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79B30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAB14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79B30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCAB68(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_100FCAB80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCABA0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79B80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCABF4(uint64_t a1)
{
}

void sub_100FCAC00(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79BD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAC20(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79BD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FCAC74(uint64_t a1)
{
  return sub_1008C2D48(a1 + 24);
}

void sub_100FCAC80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79C20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCACA0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79C20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCACF4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    uint64_t v2 = (void **)(a1 + 88);
    sub_10019E86C(&v2);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t v2 = (void **)(a1 + 56);
    sub_10019E86C(&v2);
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = (void **)(a1 + 24);
    sub_10019E86C(&v2);
  }
}

void sub_100FCAD68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79C70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAD88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79C70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCADDC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v1 = (void **)(a1 + 32);
    sub_100C9274C(&v1);
  }
}

void sub_100FCAE14(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79CC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAE34(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79CC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCAE88(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 32;
        unint64_t v6 = (void **)(v3 - 24);
        sub_100047F64(&v6);
        uint64_t v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void sub_100FCAF00(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79D10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAF20(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79D10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCAF74(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_10019F8BC(&v1);
}

void sub_100FCAFA4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79D60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCAFC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79D60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCB018(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_1000D82FC(&v1);
}

void sub_100FCB048(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCB068(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCB0BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        v3 -= 80;
        sub_100FC8B64(v3);
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void sub_100FCB13C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79E00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCB15C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79E00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FCB1B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79E50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCB1D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79E50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FCB22C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FCB258(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FCB290(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v108 = 0;
  unsigned int v109 = 0;
  sub_100FCA348(&v108);
  if (a2 <= 6005)
  {
    if ((a2 - 6003) < 2)
    {
LABEL_7:
      int v8 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v10;
        LOWORD(v148[0]) = 2080;
        *(void *)((char *)v148 + 2) = ", ";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping parsing because of status", buf, 0x2Au);
      }
LABEL_200:
      char v20 = 1;
      goto LABEL_201;
    }
    if (a2 != 6000) {
      goto LABEL_21;
    }
LABEL_10:
    *(_OWORD *)uint64_t v116 = 0u;
    long long v117 = 0u;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"challenge");
    sub_100FC2A7C(v116, a1, Value, @"challenge");
    if (BYTE8(v117))
    {
      uint64_t v12 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v99 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        *(_DWORD *)int buf = 136315394;
        *(void *)&uint8_t buf[4] = v99;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#D %s%sfound a challenge", buf, 0x16u);
      }
      uint64_t v13 = v108;
      sub_100093B44((std::string *)(v108 + 40), (const std::string *)v116);
      memset(buf, 0, sizeof(buf));
      __int16 v14 = CFDictionaryGetValue(a3, @"nonce");
      sub_100FC2A7C(buf, a1, v14, @"nonce");
      if (!buf[24]) {
        goto LABEL_197;
      }
      sub_100093B44((std::string *)(v13 + 568), (const std::string *)buf);
      if (!buf[24] || (buf[23] & 0x80000000) == 0) {
        goto LABEL_197;
      }
      uint64_t v15 = *(void **)buf;
    }
    else
    {
      *(_OWORD *)unsigned int v114 = 0u;
      long long v115 = 0u;
      unint64_t v16 = CFDictionaryGetValue(a3, @"token");
      sub_100FC2A7C(v114, a1, v16, @"token");
      uint64_t v17 = **(NSObject ***)(a1 + 40);
      if (BYTE8(v115))
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v100 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v100;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#D %s%sfound a valid token", buf, 0x16u);
        }
        sub_100093B44((std::string *)(v108 + 8), (const std::string *)v114);
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v24;
        LOWORD(v148[0]) = 2080;
        *(void *)((char *)v148 + 2) = ", ";
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno token, no big deal", buf, 0x2Au);
      }
      *(_OWORD *)uint64_t v112 = 0u;
      long long v113 = 0u;
      int64x2_t v25 = CFDictionaryGetValue(a3, @"app-token");
      sub_100FC2A7C(v112, a1, v25, @"app-token");
      if (BYTE8(v113))
      {
        sub_100093B44((std::string *)(v108 + 72), (const std::string *)v112);
      }
      else
      {
        uint64_t v26 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v27;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v28;
          LOWORD(v148[0]) = 2080;
          *(void *)((char *)v148 + 2) = ", ";
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno app token, no big deal", buf, 0x2Au);
        }
      }
      __int16 v29 = CFDictionaryGetValue(a3, @"service-tokens");
      uint64_t v30 = CFDictionaryGetValue(a3, @"subscriber-ids");
      obuint64_t j = (id)CFDictionaryGetValue(a3, @"connectivity-auth-type");
      id v103 = CFDictionaryGetValue(a3, @"certificate-info");
      CFTypeRef cf = CFDictionaryGetValue(a3, @"mschap-credentials");
      CFTypeRef v102 = CFDictionaryGetValue(a3, @"gateway-address");
      CFTypeRef v101 = CFDictionaryGetValue(a3, @"entitlement-server-address");
      uint64_t v155 = 0;
      memset(v154, 0, sizeof(v154));
      memset(v153, 0, sizeof(v153));
      memset(v152, 0, sizeof(v152));
      memset(v151, 0, sizeof(v151));
      memset(v150, 0, sizeof(v150));
      memset(v149, 0, sizeof(v149));
      memset(v148, 0, sizeof(v148));
      memset(buf, 0, sizeof(buf));
      __n128 __dst = 0u;
      long long v157 = 0u;
      theArray[0] = 0;
      theArray[1] = 0;
      sub_100FC3AEC((const void **)theArray, v29);
      int v105 = a2;
      uint64_t v31 = a1;
      if (LOBYTE(theArray[1]))
      {
        uint64_t v32 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v33 = a4;
          unint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v36 = v126[1].n128_i8[7];
          unint64_t v37 = v126[0].n128_u64[0];
          CFIndex Count = CFArrayGetCount(theArray[0]);
          int v39 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v36 < 0) {
            int v39 = (void **)v37;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v34;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v35;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v39;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = Count;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          a4 = v33;
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef v40 = theArray[0];
        id v41 = -[__CFArray countByEnumeratingWithState:objects:count:](theArray[0], "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101, v102);
        if (v41)
        {
          uint64_t v42 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (uint64_t i = 0; i != v41; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v42) {
                objc_enumerationMutation(v40);
              }
              id v44 = *(const void **)(v126[0].n128_u64[1] + 8 * i);
              if (!BYTE8(v157))
              {
                memset(__p, 0, 24);
                sub_100558E34((uint64_t)&__dst, (uint64_t)__p);
                CFArrayRef v123 = (CFArrayRef)__p;
                sub_100047F64((void ***)&v123);
              }
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(__p, v31, v44, @"service-tokens");
              if (LOBYTE(__p[3]))
              {
                uint64_t v45 = (_OWORD *)__dst.n128_u64[1];
                if (__dst.n128_u64[1] >= (unint64_t)v157)
                {
                  uint64_t v47 = sub_100048008((uint64_t *)&__dst, (long long *)__p);
                }
                else
                {
                  if (SHIBYTE(__p[2]) < 0)
                  {
                    sub_10004FC84((unsigned char *)__dst.n128_u64[1], __p[0], (unint64_t)__p[1]);
                  }
                  else
                  {
                    long long v46 = *(_OWORD *)__p;
                    *(void **)(__dst.n128_u64[1] + 16) = __p[2];
                    _OWORD *v45 = v46;
                  }
                  uint64_t v47 = (uint64_t)v45 + 24;
                }
                __dst.n128_u64[1] = v47;
                if (LOBYTE(__p[3]))
                {
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
            id v41 = [(__CFArray *)v40 countByEnumeratingWithState:v126 objects:v139 count:16];
          }
          while (v41);
        }
        a2 = v105;
        a1 = v31;
        if (LOBYTE(theArray[1])) {
          sub_100044D00((const void **)theArray);
        }
      }
      sub_100179A54((uint64_t)v148, &__dst);
      if (BYTE8(v157))
      {
        v139[0].n128_u64[0] = (unint64_t)&__dst;
        sub_100047F64((void ***)v139);
      }
      __n128 __dst = 0u;
      long long v157 = 0u;
      theArray[0] = 0;
      theArray[1] = 0;
      sub_100FC3AEC((const void **)theArray, v30);
      if (LOBYTE(theArray[1]))
      {
        uint64_t v48 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v49 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v51 = v126[1].n128_i8[7];
          unint64_t v52 = v126[0].n128_u64[0];
          CFIndex v53 = CFArrayGetCount(theArray[0]);
          id v54 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v51 < 0) {
            id v54 = (void **)v52;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v49;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v50;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v54;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = v53;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef v55 = theArray[0];
        id v56 = -[__CFArray countByEnumeratingWithState:objects:count:](theArray[0], "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101);
        if (v56)
        {
          uint64_t v57 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (uint64_t j = 0; j != v56; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v57) {
                objc_enumerationMutation(v55);
              }
              int v59 = *(const void **)(v126[0].n128_u64[1] + 8 * (void)j);
              if (!BYTE8(v157))
              {
                memset(__p, 0, 24);
                sub_100558E34((uint64_t)&__dst, (uint64_t)__p);
                CFArrayRef v123 = (CFArrayRef)__p;
                sub_100047F64((void ***)&v123);
              }
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(__p, v31, v59, @"subscriber-ids");
              if (LOBYTE(__p[3]))
              {
                id v60 = (_OWORD *)__dst.n128_u64[1];
                if (__dst.n128_u64[1] >= (unint64_t)v157)
                {
                  uint64_t v62 = sub_100048008((uint64_t *)&__dst, (long long *)__p);
                }
                else
                {
                  if (SHIBYTE(__p[2]) < 0)
                  {
                    sub_10004FC84((unsigned char *)__dst.n128_u64[1], __p[0], (unint64_t)__p[1]);
                  }
                  else
                  {
                    long long v61 = *(_OWORD *)__p;
                    *(void **)(__dst.n128_u64[1] + 16) = __p[2];
                    *id v60 = v61;
                  }
                  uint64_t v62 = (uint64_t)v60 + 24;
                }
                __dst.n128_u64[1] = v62;
                if (LOBYTE(__p[3]))
                {
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
            id v56 = [(__CFArray *)v55 countByEnumeratingWithState:v126 objects:v139 count:16];
          }
          while (v56);
        }
        a2 = v105;
        a1 = v31;
        if (LOBYTE(theArray[1])) {
          sub_100044D00((const void **)theArray);
        }
      }
      sub_100179A54((uint64_t)v149, &__dst);
      if (BYTE8(v157))
      {
        v139[0].n128_u64[0] = (unint64_t)&__dst;
        sub_100047F64((void ***)v139);
      }
      memset(v126, 0, sizeof(v126));
      memset(v139, 0, sizeof(v139));
      sub_100FC2A7C(v139, a1, obj, @"connectivity-auth-type");
      if (v139[1].n128_u8[8])
      {
        if (v139[1].n128_i8[7] < 0)
        {
          sub_10004FC84(theArray, (void *)v139[0].n128_u64[0], v139[0].n128_u64[1]);
        }
        else
        {
          *(__n128 *)theArray = v139[0];
          *(void *)&long long v111 = v139[1].n128_u64[0];
        }
        if (SBYTE7(v111) < 0)
        {
          sub_10004FC84(&__dst, theArray[0], (unint64_t)theArray[1]);
        }
        else
        {
          __n128 __dst = *(__n128 *)theArray;
          *(void *)&long long v157 = v111;
        }
        unsigned int v119 = 0;
        if (SBYTE7(v157) < 0)
        {
          sub_10004FC84(__p, (void *)__dst.n128_u64[0], __dst.n128_u64[1]);
        }
        else
        {
          *(__n128 *)std::string __p = __dst;
          __p[2] = (void *)v157;
        }
        p_dst = 0;
        if (ctu::cf::convert_copy())
        {
          CFArrayRef v63 = (const __CFArray *)v119;
          unsigned int v119 = p_dst;
          CFArrayRef v123 = v63;
          sub_1000558F4((const void **)&v123);
        }
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v64 = (DataUtils *)v119;
        id v118 = v119;
        unsigned int v119 = 0;
        sub_1000558F4((const void **)&v119);
        if (SBYTE7(v157) < 0) {
          operator delete((void *)__dst.n128_u64[0]);
        }
        uint64_t MatchingEAPMethod = DataUtils::getMatchingEAPMethod(v64, v65);
        sub_1000558F4((const void **)&v118);
        if (SBYTE7(v111) < 0) {
          operator delete(theArray[0]);
        }
        if (MatchingEAPMethod)
        {
          memset(__p, 0, 24);
          ctu::cf::assign();
          uint64_t v67 = __p[0];
          __dst.n128_u64[0] = (unint64_t)__p[1];
          *(unint64_t *)((char *)__dst.n128_u64 + 7) = *(unint64_t *)((char *)&__p[1] + 7);
          unsigned __int8 v68 = HIBYTE(__p[2]);
          if (v126[1].n128_u8[8])
          {
            if (v126[1].n128_i8[7] < 0) {
              operator delete((void *)v126[0].n128_u64[0]);
            }
            v126[0].n128_u64[0] = (unint64_t)v67;
            v126[0].n128_u64[1] = __dst.n128_u64[0];
            *(unint64_t *)((char *)&v126[0].n128_u64[1] + 7) = *(unint64_t *)((char *)__dst.n128_u64 + 7);
            v126[1].n128_u8[7] = v68;
          }
          else
          {
            v126[0].n128_u64[0] = (unint64_t)__p[0];
            v126[0].n128_u64[1] = __dst.n128_u64[0];
            *(unint64_t *)((char *)&v126[0].n128_u64[1] + 7) = *(unint64_t *)((char *)__dst.n128_u64 + 7);
            v126[1].n128_u8[7] = HIBYTE(__p[2]);
            v126[1].n128_u8[8] = 1;
          }
          a1 = v31;
        }
        if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
          operator delete((void *)v139[0].n128_u64[0]);
        }
      }
      sub_100179CB0((uint64_t)v150, v126);
      if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
        operator delete((void *)v126[0].n128_u64[0]);
      }
      *(_OWORD *)theArray = 0u;
      long long v111 = 0u;
      CFArrayRef v123 = 0;
      uint64_t v124 = 0;
      sub_100FC3AEC((const void **)&v123, cf);
      if ((_BYTE)v124)
      {
        long long v69 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v70 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v71 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v72 = v126[1].n128_i8[7];
          unint64_t v73 = v126[0].n128_u64[0];
          CFIndex v74 = CFArrayGetCount(v123);
          uint64_t v75 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v72 < 0) {
            uint64_t v75 = (void **)v73;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v70;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v71;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v75;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = v74;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef obja = v123;
        id v76 = -[__CFArray countByEnumeratingWithState:objects:count:](v123, "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101);
        if (v76)
        {
          uint64_t v77 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (k = 0; k != v76; k = (char *)k + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v77) {
                objc_enumerationMutation(obja);
              }
              uint64_t v79 = *(void **)(v126[0].n128_u64[1] + 8 * (void)k);
              id v80 = [v79 objectForKey:@"mschap-username"];
              id v81 = [v79 objectForKey:@"mschap-password"];
              *(_OWORD *)uint64_t v121 = 0u;
              long long v122 = 0u;
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(&__dst, v31, v80, @"mschap-credentials");
              sub_100179CB0((uint64_t)__p, &__dst);
              if (BYTE8(v157) && SBYTE7(v157) < 0) {
                operator delete((void *)__dst.n128_u64[0]);
              }
              sub_100FC2A7C(&__dst, v31, v81, @"mschap-credentials");
              *(void *)&double v82 = sub_100179CB0((uint64_t)v121, &__dst).n128_u64[0];
              if (BYTE8(v157) && SBYTE7(v157) < 0) {
                operator delete((void *)__dst.n128_u64[0]);
              }
              if (LOBYTE(__p[3]) | BYTE8(v122))
              {
                if (!BYTE8(v111))
                {
                  __n128 __dst = 0uLL;
                  *(void *)&long long v157 = 0;
                  sub_100FCA3C4((uint64_t)theArray, (uint64_t)&__dst);
                  p_dst = &__dst;
                  sub_10019D898((void ***)&p_dst);
                }
                sub_100FCA440((int64x2_t *)theArray, (long long *)__p);
                if (BYTE8(v122) && SBYTE7(v122) < 0) {
                  operator delete(v121[0]);
                }
              }
              if (LOBYTE(__p[3]) && SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
            }
            id v76 = -[__CFArray countByEnumeratingWithState:objects:count:](obja, "countByEnumeratingWithState:objects:count:", v126, v139, 16, v82);
          }
          while (v76);
        }
        a2 = v105;
        a1 = v31;
        if ((_BYTE)v124) {
          sub_100044D00((const void **)&v123);
        }
      }
      sub_100FCA6B4((uint64_t)v151, (__n128 *)theArray);
      if (BYTE8(v111))
      {
        v139[0].n128_u64[0] = (unint64_t)theArray;
        sub_10019D898((void ***)v139);
      }
      sub_100FC2A7C(v139, a1, v102, @"gateway-address");
      sub_100179CB0((uint64_t)v152, v139);
      if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
        operator delete((void *)v139[0].n128_u64[0]);
      }
      sub_100FC2A7C(v139, a1, v101, @"entitlement-server-address");
      sub_100179CB0((uint64_t)v153, v139);
      if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
        operator delete((void *)v139[0].n128_u64[0]);
      }
      uint64_t v146 = 0;
      memset(v145, 0, sizeof(v145));
      memset(v144, 0, sizeof(v144));
      memset(v143, 0, sizeof(v143));
      memset(v142, 0, sizeof(v142));
      memset(v141, 0, sizeof(v141));
      memset(v140, 0, sizeof(v140));
      memset(v139, 0, sizeof(v139));
      __n128 __dst = 0uLL;
      sub_100FC3BAC(&__dst, a1, v103, @"certificate-info", 0);
      if (v103)
      {
        long long v137 = 0u;
        long long v138 = 0u;
        long long v135 = 0u;
        long long v136 = 0u;
        long long v133 = 0u;
        long long v134 = 0u;
        long long v131 = 0u;
        long long v132 = 0u;
        long long v129 = 0u;
        long long v130 = 0u;
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        sub_1003A58F0((uint64_t)v139, v126);
        sub_10019D7CC((uint64_t)v126);
        memset(__p, 0, 24);
        if (__dst.n128_u8[8])
        {
          CFDictionaryRef v83 = (const __CFDictionary *)__dst.n128_u64[0];
          __p[0] = (void *)__dst.n128_u64[0];
          if (__dst.n128_u64[0])
          {
            CFRetain((CFTypeRef)__dst.n128_u64[0]);
            CFDictionaryRef v83 = (const __CFDictionary *)__p[0];
          }
          LOBYTE(__p[1]) = 1;
        }
        else
        {
          CFDictionaryRef v83 = 0;
        }
        __p[2] = (void *)a1;
        long long v84 = CFDictionaryGetValue(v83, @"dn");
        sub_100FC2A7C(v126, a1, v84, @"dn");
        sub_100179CB0((uint64_t)v139, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        char v85 = __p[2];
        uint64_t v86 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"organization");
        sub_100FC2A7C(v126, (uint64_t)v85, v86, @"organization");
        sub_100179CB0((uint64_t)v140, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        BOOL v87 = __p[2];
        uint64_t v88 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"department");
        sub_100FC2A7C(v126, (uint64_t)v87, v88, @"department");
        sub_100179CB0((uint64_t)v141, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        uint64_t v89 = __p[2];
        id v90 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"city");
        sub_100FC2A7C(v126, (uint64_t)v89, v90, @"city");
        sub_100179CB0((uint64_t)v142, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        signed int v91 = __p[2];
        id v92 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"state");
        sub_100FC2A7C(v126, (uint64_t)v91, v92, @"state");
        sub_100179CB0((uint64_t)v143, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        unsigned int v93 = __p[2];
        uint64_t v94 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"country");
        sub_100FC2A7C(v126, (uint64_t)v93, v94, @"country");
        sub_100179CB0((uint64_t)v144, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        uint64_t v95 = __p[2];
        uint64_t v96 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"email");
        sub_100FC2A7C(v126, (uint64_t)v95, v96, @"email");
        sub_100179CB0((uint64_t)v145, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        if (LOBYTE(__p[1])) {
          sub_100057D78((const void **)__p);
        }
      }
      if (__dst.n128_u8[8]) {
        sub_100057D78((const void **)&__dst);
      }
      sub_100FCA758((uint64_t)v154, v139);
      if ((_BYTE)v146) {
        sub_10019D7CC((uint64_t)v139);
      }
      sub_100FCA2A0((char *)(v108 + 104), (uint64_t)buf);
      sub_10019D6E8((uint64_t)buf);
      if (BYTE8(v113) && SBYTE7(v113) < 0) {
        operator delete(v112[0]);
      }
      if (!BYTE8(v115) || (SBYTE7(v115) & 0x80000000) == 0) {
        goto LABEL_197;
      }
      uint64_t v15 = v114[0];
    }
    operator delete(v15);
LABEL_197:
    if (BYTE8(v117) && SBYTE7(v117) < 0) {
      operator delete(v116[0]);
    }
    goto LABEL_200;
  }
  if ((a2 - 6301) < 2 || a2 == 6006) {
    goto LABEL_10;
  }
  if (a2 == 6300) {
    goto LABEL_7;
  }
LABEL_21:
  uint64_t v18 = **(NSObject ***)(a1 + 40);
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  char v20 = 0;
  if (v19)
  {
    uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v22;
    LOWORD(v148[0]) = 2080;
    *(void *)((char *)v148 + 2) = ", ";
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%signore response because of status", buf, 0x2Au);
    char v20 = 0;
  }
LABEL_201:
  uint64_t v97 = v108;
  id v98 = v109;
  *(unsigned char *)uint64_t v108 = v20;
  sub_100FCD1A8(buf, a2, v97, v98);
  *a4 = *(_OWORD *)buf;
  if (v98) {
    sub_10004D2C8(v98);
  }
}

void sub_100FCC83C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100FCCC04(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int64x2_t v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    __int16 v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)int buf = v15;
      *(void *)&uint8_t buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)int buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100FB227C(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    __int16 v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FCCE40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FCCE64(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    unint64_t v34 = ", ";
    __int16 v35 = 2080;
    int v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1006BA4B0(v22, a2, a4, buf, &v29, &v28);
        }
        if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019CCF0(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FCD130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FCD19C()
{
  return "getAuthentication";
}

void sub_100FCD1A8(void *a1, int a2, uint64_t a3, std::__shared_weak_count *a4)
{
  int v8 = operator new(0x30uLL);
  uint64_t v9 = v8;
  v8[1] = 0;
  _DWORD v8[2] = 0;
  void *v8 = off_101A78F20;
  uint64_t v10 = (char *)(v8 + 3);
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v8 + 6) = a2;
    v8[4] = a3;
    v8[5] = a4;
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(a4);
  }
  else
  {
    *((_DWORD *)v8 + 6) = a2;
    v8[4] = a3;
    v8[5] = 0;
  }
  *a1 = v10;
  a1[1] = v9;
}

void sub_100FCD248(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79EF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCD268(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79EF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FCD2BC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FCD2E8(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FCD320(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v108 = 0;
  unsigned int v109 = 0;
  sub_100FCA348(&v108);
  if (a2 <= 6005)
  {
    if ((a2 - 6003) < 2)
    {
LABEL_7:
      int v8 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v10;
        LOWORD(v148[0]) = 2080;
        *(void *)((char *)v148 + 2) = ", ";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping parsing because of status", buf, 0x2Au);
      }
LABEL_200:
      char v20 = 1;
      goto LABEL_201;
    }
    if (a2 != 6000) {
      goto LABEL_21;
    }
LABEL_10:
    *(_OWORD *)uint64_t v116 = 0u;
    long long v117 = 0u;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"challenge");
    sub_100FC2A7C(v116, a1, Value, @"challenge");
    if (BYTE8(v117))
    {
      uint64_t v12 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v99 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        *(_DWORD *)int buf = 136315394;
        *(void *)&uint8_t buf[4] = v99;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#D %s%sfound a challenge", buf, 0x16u);
      }
      uint64_t v13 = v108;
      sub_100093B44((std::string *)(v108 + 40), (const std::string *)v116);
      memset(buf, 0, sizeof(buf));
      __int16 v14 = CFDictionaryGetValue(a3, @"nonce");
      sub_100FC2A7C(buf, a1, v14, @"nonce");
      if (!buf[24]) {
        goto LABEL_197;
      }
      sub_100093B44((std::string *)(v13 + 568), (const std::string *)buf);
      if (!buf[24] || (buf[23] & 0x80000000) == 0) {
        goto LABEL_197;
      }
      uint64_t v15 = *(void **)buf;
    }
    else
    {
      *(_OWORD *)unsigned int v114 = 0u;
      long long v115 = 0u;
      uint64_t v16 = CFDictionaryGetValue(a3, @"token");
      sub_100FC2A7C(v114, a1, v16, @"token");
      int v17 = **(NSObject ***)(a1 + 40);
      if (BYTE8(v115))
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v100 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v100;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#D %s%sfound a valid token", buf, 0x16u);
        }
        sub_100093B44((std::string *)(v108 + 8), (const std::string *)v114);
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v24;
        LOWORD(v148[0]) = 2080;
        *(void *)((char *)v148 + 2) = ", ";
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno token, no big deal", buf, 0x2Au);
      }
      *(_OWORD *)uint64_t v112 = 0u;
      long long v113 = 0u;
      int v25 = CFDictionaryGetValue(a3, @"app-token");
      sub_100FC2A7C(v112, a1, v25, @"app-token");
      if (BYTE8(v113))
      {
        sub_100093B44((std::string *)(v108 + 72), (const std::string *)v112);
      }
      else
      {
        CFTypeRef v26 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v27;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v28;
          LOWORD(v148[0]) = 2080;
          *(void *)((char *)v148 + 2) = ", ";
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sno app token, no big deal", buf, 0x2Au);
        }
      }
      CFTypeRef v29 = CFDictionaryGetValue(a3, @"service-tokens");
      uint64_t v30 = CFDictionaryGetValue(a3, @"subscriber-ids");
      obuint64_t j = (id)CFDictionaryGetValue(a3, @"connectivity-auth-type");
      id v103 = CFDictionaryGetValue(a3, @"certificate-info");
      CFTypeRef cf = CFDictionaryGetValue(a3, @"mschap-credentials");
      CFTypeRef v102 = CFDictionaryGetValue(a3, @"gateway-address");
      CFTypeRef v101 = CFDictionaryGetValue(a3, @"entitlement-server-address");
      uint64_t v155 = 0;
      memset(v154, 0, sizeof(v154));
      memset(v153, 0, sizeof(v153));
      memset(v152, 0, sizeof(v152));
      memset(v151, 0, sizeof(v151));
      memset(v150, 0, sizeof(v150));
      memset(v149, 0, sizeof(v149));
      memset(v148, 0, sizeof(v148));
      memset(buf, 0, sizeof(buf));
      __n128 __dst = 0u;
      long long v157 = 0u;
      theArray[0] = 0;
      theArray[1] = 0;
      sub_100FC3AEC((const void **)theArray, v29);
      int v105 = a2;
      uint64_t v31 = a1;
      if (LOBYTE(theArray[1]))
      {
        uint64_t v32 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v33 = a4;
          unint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v36 = v126[1].n128_i8[7];
          unint64_t v37 = v126[0].n128_u64[0];
          CFIndex Count = CFArrayGetCount(theArray[0]);
          int v39 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v36 < 0) {
            int v39 = (void **)v37;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v34;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v35;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v39;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = Count;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          a4 = v33;
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef v40 = theArray[0];
        id v41 = -[__CFArray countByEnumeratingWithState:objects:count:](theArray[0], "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101, v102);
        if (v41)
        {
          uint64_t v42 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (uint64_t i = 0; i != v41; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v42) {
                objc_enumerationMutation(v40);
              }
              id v44 = *(const void **)(v126[0].n128_u64[1] + 8 * i);
              if (!BYTE8(v157))
              {
                memset(__p, 0, 24);
                sub_100558E34((uint64_t)&__dst, (uint64_t)__p);
                CFArrayRef v123 = (CFArrayRef)__p;
                sub_100047F64((void ***)&v123);
              }
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(__p, v31, v44, @"service-tokens");
              if (LOBYTE(__p[3]))
              {
                uint64_t v45 = (_OWORD *)__dst.n128_u64[1];
                if (__dst.n128_u64[1] >= (unint64_t)v157)
                {
                  uint64_t v47 = sub_100048008((uint64_t *)&__dst, (long long *)__p);
                }
                else
                {
                  if (SHIBYTE(__p[2]) < 0)
                  {
                    sub_10004FC84((unsigned char *)__dst.n128_u64[1], __p[0], (unint64_t)__p[1]);
                  }
                  else
                  {
                    long long v46 = *(_OWORD *)__p;
                    *(void **)(__dst.n128_u64[1] + 16) = __p[2];
                    _OWORD *v45 = v46;
                  }
                  uint64_t v47 = (uint64_t)v45 + 24;
                }
                __dst.n128_u64[1] = v47;
                if (LOBYTE(__p[3]))
                {
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
            id v41 = [(__CFArray *)v40 countByEnumeratingWithState:v126 objects:v139 count:16];
          }
          while (v41);
        }
        a2 = v105;
        a1 = v31;
        if (LOBYTE(theArray[1])) {
          sub_100044D00((const void **)theArray);
        }
      }
      sub_100179A54((uint64_t)v148, &__dst);
      if (BYTE8(v157))
      {
        v139[0].n128_u64[0] = (unint64_t)&__dst;
        sub_100047F64((void ***)v139);
      }
      __n128 __dst = 0u;
      long long v157 = 0u;
      theArray[0] = 0;
      theArray[1] = 0;
      sub_100FC3AEC((const void **)theArray, v30);
      if (LOBYTE(theArray[1]))
      {
        uint64_t v48 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v49 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v51 = v126[1].n128_i8[7];
          unint64_t v52 = v126[0].n128_u64[0];
          CFIndex v53 = CFArrayGetCount(theArray[0]);
          id v54 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v51 < 0) {
            id v54 = (void **)v52;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v49;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v50;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v54;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = v53;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef v55 = theArray[0];
        id v56 = -[__CFArray countByEnumeratingWithState:objects:count:](theArray[0], "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101);
        if (v56)
        {
          uint64_t v57 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (uint64_t j = 0; j != v56; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v57) {
                objc_enumerationMutation(v55);
              }
              int v59 = *(const void **)(v126[0].n128_u64[1] + 8 * (void)j);
              if (!BYTE8(v157))
              {
                memset(__p, 0, 24);
                sub_100558E34((uint64_t)&__dst, (uint64_t)__p);
                CFArrayRef v123 = (CFArrayRef)__p;
                sub_100047F64((void ***)&v123);
              }
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(__p, v31, v59, @"subscriber-ids");
              if (LOBYTE(__p[3]))
              {
                id v60 = (_OWORD *)__dst.n128_u64[1];
                if (__dst.n128_u64[1] >= (unint64_t)v157)
                {
                  uint64_t v62 = sub_100048008((uint64_t *)&__dst, (long long *)__p);
                }
                else
                {
                  if (SHIBYTE(__p[2]) < 0)
                  {
                    sub_10004FC84((unsigned char *)__dst.n128_u64[1], __p[0], (unint64_t)__p[1]);
                  }
                  else
                  {
                    long long v61 = *(_OWORD *)__p;
                    *(void **)(__dst.n128_u64[1] + 16) = __p[2];
                    *id v60 = v61;
                  }
                  uint64_t v62 = (uint64_t)v60 + 24;
                }
                __dst.n128_u64[1] = v62;
                if (LOBYTE(__p[3]))
                {
                  if (SHIBYTE(__p[2]) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
            id v56 = [(__CFArray *)v55 countByEnumeratingWithState:v126 objects:v139 count:16];
          }
          while (v56);
        }
        a2 = v105;
        a1 = v31;
        if (LOBYTE(theArray[1])) {
          sub_100044D00((const void **)theArray);
        }
      }
      sub_100179A54((uint64_t)v149, &__dst);
      if (BYTE8(v157))
      {
        v139[0].n128_u64[0] = (unint64_t)&__dst;
        sub_100047F64((void ***)v139);
      }
      memset(v126, 0, sizeof(v126));
      memset(v139, 0, sizeof(v139));
      sub_100FC2A7C(v139, a1, obj, @"connectivity-auth-type");
      if (v139[1].n128_u8[8])
      {
        if (v139[1].n128_i8[7] < 0)
        {
          sub_10004FC84(theArray, (void *)v139[0].n128_u64[0], v139[0].n128_u64[1]);
        }
        else
        {
          *(__n128 *)theArray = v139[0];
          *(void *)&long long v111 = v139[1].n128_u64[0];
        }
        if (SBYTE7(v111) < 0)
        {
          sub_10004FC84(&__dst, theArray[0], (unint64_t)theArray[1]);
        }
        else
        {
          __n128 __dst = *(__n128 *)theArray;
          *(void *)&long long v157 = v111;
        }
        unsigned int v119 = 0;
        if (SBYTE7(v157) < 0)
        {
          sub_10004FC84(__p, (void *)__dst.n128_u64[0], __dst.n128_u64[1]);
        }
        else
        {
          *(__n128 *)std::string __p = __dst;
          __p[2] = (void *)v157;
        }
        p_dst = 0;
        if (ctu::cf::convert_copy())
        {
          CFArrayRef v63 = (const __CFArray *)v119;
          unsigned int v119 = p_dst;
          CFArrayRef v123 = v63;
          sub_1000558F4((const void **)&v123);
        }
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v64 = (DataUtils *)v119;
        id v118 = v119;
        unsigned int v119 = 0;
        sub_1000558F4((const void **)&v119);
        if (SBYTE7(v157) < 0) {
          operator delete((void *)__dst.n128_u64[0]);
        }
        uint64_t MatchingEAPMethod = DataUtils::getMatchingEAPMethod(v64, v65);
        sub_1000558F4((const void **)&v118);
        if (SBYTE7(v111) < 0) {
          operator delete(theArray[0]);
        }
        if (MatchingEAPMethod)
        {
          memset(__p, 0, 24);
          ctu::cf::assign();
          uint64_t v67 = __p[0];
          __dst.n128_u64[0] = (unint64_t)__p[1];
          *(unint64_t *)((char *)__dst.n128_u64 + 7) = *(unint64_t *)((char *)&__p[1] + 7);
          unsigned __int8 v68 = HIBYTE(__p[2]);
          if (v126[1].n128_u8[8])
          {
            if (v126[1].n128_i8[7] < 0) {
              operator delete((void *)v126[0].n128_u64[0]);
            }
            v126[0].n128_u64[0] = (unint64_t)v67;
            v126[0].n128_u64[1] = __dst.n128_u64[0];
            *(unint64_t *)((char *)&v126[0].n128_u64[1] + 7) = *(unint64_t *)((char *)__dst.n128_u64 + 7);
            v126[1].n128_u8[7] = v68;
          }
          else
          {
            v126[0].n128_u64[0] = (unint64_t)__p[0];
            v126[0].n128_u64[1] = __dst.n128_u64[0];
            *(unint64_t *)((char *)&v126[0].n128_u64[1] + 7) = *(unint64_t *)((char *)__dst.n128_u64 + 7);
            v126[1].n128_u8[7] = HIBYTE(__p[2]);
            v126[1].n128_u8[8] = 1;
          }
          a1 = v31;
        }
        if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
          operator delete((void *)v139[0].n128_u64[0]);
        }
      }
      sub_100179CB0((uint64_t)v150, v126);
      if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
        operator delete((void *)v126[0].n128_u64[0]);
      }
      *(_OWORD *)theArray = 0u;
      long long v111 = 0u;
      CFArrayRef v123 = 0;
      uint64_t v124 = 0;
      sub_100FC3AEC((const void **)&v123, cf);
      if ((_BYTE)v124)
      {
        long long v69 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v70 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v71 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          memset(v126, 0, 24);
          ctu::cf::assign();
          __p[2] = (void *)v126[1].n128_u64[0];
          *(__n128 *)std::string __p = v126[0];
          int v72 = v126[1].n128_i8[7];
          unint64_t v73 = v126[0].n128_u64[0];
          CFIndex v74 = CFArrayGetCount(v123);
          uint64_t v75 = __p;
          v139[0].n128_u32[0] = 136316418;
          if (v72 < 0) {
            uint64_t v75 = (void **)v73;
          }
          *(unint64_t *)((char *)v139[0].n128_u64 + 4) = v70;
          v139[0].n128_u16[6] = 2080;
          *(unint64_t *)((char *)&v139[0].n128_u64[1] + 6) = (unint64_t)" ";
          v139[1].n128_u16[3] = 2080;
          v139[1].n128_u64[1] = v71;
          LOWORD(v140[0]) = 2080;
          *(void *)((char *)v140 + 2) = ", ";
          WORD5(v140[0]) = 2080;
          *(void *)((char *)v140 + 12) = v75;
          WORD2(v140[1]) = 2048;
          *(void *)((char *)&v140[1] + 6) = v74;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of elements in %s: %lu", (uint8_t *)v139, 0x3Eu);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        CFArrayRef obja = v123;
        id v76 = -[__CFArray countByEnumeratingWithState:objects:count:](v123, "countByEnumeratingWithState:objects:count:", v126, v139, 16, v101);
        if (v76)
        {
          uint64_t v77 = *(void *)v126[1].n128_u64[0];
          do
          {
            for (k = 0; k != v76; k = (char *)k + 1)
            {
              if (*(void *)v126[1].n128_u64[0] != v77) {
                objc_enumerationMutation(obja);
              }
              uint64_t v79 = *(void **)(v126[0].n128_u64[1] + 8 * (void)k);
              id v80 = [v79 objectForKey:@"mschap-username"];
              id v81 = [v79 objectForKey:@"mschap-password"];
              *(_OWORD *)uint64_t v121 = 0u;
              long long v122 = 0u;
              memset(__p, 0, sizeof(__p));
              sub_100FC2A7C(&__dst, v31, v80, @"mschap-credentials");
              sub_100179CB0((uint64_t)__p, &__dst);
              if (BYTE8(v157) && SBYTE7(v157) < 0) {
                operator delete((void *)__dst.n128_u64[0]);
              }
              sub_100FC2A7C(&__dst, v31, v81, @"mschap-credentials");
              *(void *)&double v82 = sub_100179CB0((uint64_t)v121, &__dst).n128_u64[0];
              if (BYTE8(v157) && SBYTE7(v157) < 0) {
                operator delete((void *)__dst.n128_u64[0]);
              }
              if (LOBYTE(__p[3]) | BYTE8(v122))
              {
                if (!BYTE8(v111))
                {
                  __n128 __dst = 0uLL;
                  *(void *)&long long v157 = 0;
                  sub_100FCA3C4((uint64_t)theArray, (uint64_t)&__dst);
                  p_dst = &__dst;
                  sub_10019D898((void ***)&p_dst);
                }
                sub_100FCA440((int64x2_t *)theArray, (long long *)__p);
                if (BYTE8(v122) && SBYTE7(v122) < 0) {
                  operator delete(v121[0]);
                }
              }
              if (LOBYTE(__p[3]) && SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
            }
            id v76 = -[__CFArray countByEnumeratingWithState:objects:count:](obja, "countByEnumeratingWithState:objects:count:", v126, v139, 16, v82);
          }
          while (v76);
        }
        a2 = v105;
        a1 = v31;
        if ((_BYTE)v124) {
          sub_100044D00((const void **)&v123);
        }
      }
      sub_100FCA6B4((uint64_t)v151, (__n128 *)theArray);
      if (BYTE8(v111))
      {
        v139[0].n128_u64[0] = (unint64_t)theArray;
        sub_10019D898((void ***)v139);
      }
      sub_100FC2A7C(v139, a1, v102, @"gateway-address");
      sub_100179CB0((uint64_t)v152, v139);
      if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
        operator delete((void *)v139[0].n128_u64[0]);
      }
      sub_100FC2A7C(v139, a1, v101, @"entitlement-server-address");
      sub_100179CB0((uint64_t)v153, v139);
      if (v139[1].n128_u8[8] && v139[1].n128_i8[7] < 0) {
        operator delete((void *)v139[0].n128_u64[0]);
      }
      uint64_t v146 = 0;
      memset(v145, 0, sizeof(v145));
      memset(v144, 0, sizeof(v144));
      memset(v143, 0, sizeof(v143));
      memset(v142, 0, sizeof(v142));
      memset(v141, 0, sizeof(v141));
      memset(v140, 0, sizeof(v140));
      memset(v139, 0, sizeof(v139));
      __n128 __dst = 0uLL;
      sub_100FC3BAC(&__dst, a1, v103, @"certificate-info", 0);
      if (v103)
      {
        long long v137 = 0u;
        long long v138 = 0u;
        long long v135 = 0u;
        long long v136 = 0u;
        long long v133 = 0u;
        long long v134 = 0u;
        long long v131 = 0u;
        long long v132 = 0u;
        long long v129 = 0u;
        long long v130 = 0u;
        long long v127 = 0u;
        long long v128 = 0u;
        memset(v126, 0, sizeof(v126));
        sub_1003A58F0((uint64_t)v139, v126);
        sub_10019D7CC((uint64_t)v126);
        memset(__p, 0, 24);
        if (__dst.n128_u8[8])
        {
          CFDictionaryRef v83 = (const __CFDictionary *)__dst.n128_u64[0];
          __p[0] = (void *)__dst.n128_u64[0];
          if (__dst.n128_u64[0])
          {
            CFRetain((CFTypeRef)__dst.n128_u64[0]);
            CFDictionaryRef v83 = (const __CFDictionary *)__p[0];
          }
          LOBYTE(__p[1]) = 1;
        }
        else
        {
          CFDictionaryRef v83 = 0;
        }
        __p[2] = (void *)a1;
        long long v84 = CFDictionaryGetValue(v83, @"dn");
        sub_100FC2A7C(v126, a1, v84, @"dn");
        sub_100179CB0((uint64_t)v139, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        char v85 = __p[2];
        uint64_t v86 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"organization");
        sub_100FC2A7C(v126, (uint64_t)v85, v86, @"organization");
        sub_100179CB0((uint64_t)v140, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        BOOL v87 = __p[2];
        uint64_t v88 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"department");
        sub_100FC2A7C(v126, (uint64_t)v87, v88, @"department");
        sub_100179CB0((uint64_t)v141, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        uint64_t v89 = __p[2];
        id v90 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"city");
        sub_100FC2A7C(v126, (uint64_t)v89, v90, @"city");
        sub_100179CB0((uint64_t)v142, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        signed int v91 = __p[2];
        id v92 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"state");
        sub_100FC2A7C(v126, (uint64_t)v91, v92, @"state");
        sub_100179CB0((uint64_t)v143, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        unsigned int v93 = __p[2];
        uint64_t v94 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"country");
        sub_100FC2A7C(v126, (uint64_t)v93, v94, @"country");
        sub_100179CB0((uint64_t)v144, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        uint64_t v95 = __p[2];
        uint64_t v96 = CFDictionaryGetValue((CFDictionaryRef)__p[0], @"email");
        sub_100FC2A7C(v126, (uint64_t)v95, v96, @"email");
        sub_100179CB0((uint64_t)v145, v126);
        if (v126[1].n128_u8[8] && v126[1].n128_i8[7] < 0) {
          operator delete((void *)v126[0].n128_u64[0]);
        }
        if (LOBYTE(__p[1])) {
          sub_100057D78((const void **)__p);
        }
      }
      if (__dst.n128_u8[8]) {
        sub_100057D78((const void **)&__dst);
      }
      sub_100FCA758((uint64_t)v154, v139);
      if ((_BYTE)v146) {
        sub_10019D7CC((uint64_t)v139);
      }
      sub_100FCA2A0((char *)(v108 + 104), (uint64_t)buf);
      sub_10019D6E8((uint64_t)buf);
      if (BYTE8(v113) && SBYTE7(v113) < 0) {
        operator delete(v112[0]);
      }
      if (!BYTE8(v115) || (SBYTE7(v115) & 0x80000000) == 0) {
        goto LABEL_197;
      }
      uint64_t v15 = v114[0];
    }
    operator delete(v15);
LABEL_197:
    if (BYTE8(v117) && SBYTE7(v117) < 0) {
      operator delete(v116[0]);
    }
    goto LABEL_200;
  }
  if ((a2 - 6301) < 2 || a2 == 6006) {
    goto LABEL_10;
  }
  if (a2 == 6300) {
    goto LABEL_7;
  }
LABEL_21:
  long long v18 = **(NSObject ***)(a1 + 40);
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  char v20 = 0;
  if (v19)
  {
    uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v21;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v22;
    LOWORD(v148[0]) = 2080;
    *(void *)((char *)v148 + 2) = ", ";
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%signore response because of status", buf, 0x2Au);
    char v20 = 0;
  }
LABEL_201:
  uint64_t v97 = v108;
  id v98 = v109;
  *(unsigned char *)uint64_t v108 = v20;
  sub_100FCD1A8(buf, a2, v97, v98);
  *a4 = *(_OWORD *)buf;
  if (v98) {
    sub_10004D2C8(v98);
  }
}

void sub_100FCE8CC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100FCEC94(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    __int16 v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)int buf = v15;
      *(void *)&uint8_t buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)int buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100FB227C(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    __int16 v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FCEED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FCEEF4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    unint64_t v34 = ", ";
    __int16 v35 = 2080;
    int v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1006BA664(v22, a2, a4, buf, &v29, &v28);
        }
        if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019CFAC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FCF1C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FCF22C()
{
  return "postChallenge";
}

void sub_100FCF238(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A79FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FCF258(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A79FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FCF2AC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FCF2D8(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FCF310(CFDictionaryRef theDict@<X2>, uint64_t a2@<X0>, int a3@<W1>, uint64_t **a4@<X4>, void *a5@<X8>)
{
  if (a3 != 6000)
  {
    int v17 = **(NSObject ***)(a2 + 40);
    int v119 = a3;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)uint64_t v143 = 136315906;
      uint64_t v144 = v18;
      __int16 v145 = 2080;
      uint64_t v146 = " ";
      __int16 v147 = 2080;
      uint64_t v148 = v19;
      __int16 v149 = 2080;
      uint64_t v150 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", v143, 0x2Au);
    }
    __int16 v14 = 0;
    uint64_t v124 = 0;
    goto LABEL_177;
  }
  CFArrayRef theArray = 0;
  uint64_t v138 = 0;
  CFBooleanRef Value = CFDictionaryGetValue(theDict, @"response");
  sub_100FC3AEC((const void **)&theArray, Value);
  if (!(_BYTE)v138)
  {
    __int16 v14 = 0;
    goto LABEL_179;
  }
  int v119 = 6000;
  int v8 = **(NSObject ***)(a2 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    CFIndex Count = CFArrayGetCount(theArray);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v10;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = ", ";
    *(_WORD *)&buf[42] = 2048;
    *(void *)&buf[44] = Count;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sthere are %lu entitlement responses", buf, 0x34u);
  }
  uint64_t v13 = **a4;
  uint64_t v12 = (std::__shared_weak_count *)(*a4)[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v118 = v12;
  __int16 v14 = (char *)operator new(0x80uLL);
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 2) = 0;
  *(void *)__int16 v14 = off_101A79580;
  v14[24] = 1;
  uint64_t v124 = v14 + 24;
  *((void *)v14 + 5) = 0;
  *((void *)v14 + 4) = v14 + 40;
  *((void *)v14 + 6) = 0;
  *((void *)v14 + 8) = 0;
  *((void *)v14 + 7) = v14 + 64;
  *((void *)v14 + 11) = 0;
  *((void *)v14 + 9) = 0;
  *((void *)v14 + 10) = v14 + 88;
  *((void *)v14 + 12) = 0;
  *((void *)v14 + 14) = 0;
  *((void *)v14 + 13) = v14 + 112;
  long long v122 = (uint64_t **)(v14 + 104);
  *((void *)v14 + 15) = 0;
  if (v13)
  {
    uint64_t v15 = *(void *)(v13 + 8);
    if (v15)
    {
      unsigned char *v124 = *(unsigned char *)v15;
      if (v124 != (unsigned char *)v15)
      {
        sub_10005D87C((uint64_t **)v14 + 4, *(void **)(v15 + 8), (void *)(v15 + 16));
        sub_10005D718((uint64_t **)v14 + 7, *(void **)(v15 + 32), (void *)(v15 + 40));
        sub_10005D5A4((uint64_t **)v14 + 10, *(int **)(v15 + 56), (int *)(v15 + 64));
        sub_10005D440(v122, *(void **)(v15 + 80), (void *)(v15 + 88));
      }
      unsigned char *v124 = 1;
    }
  }
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  CFArrayRef v132 = theArray;
  if (theArray)
  {
    CFRetain(theArray);
    CFArrayRef v16 = v132;
  }
  else
  {
    CFArrayRef v16 = 0;
  }
  sub_100044D00((const void **)&v132);
  id v20 = [(__CFArray *)v16 countByEnumeratingWithState:&v133 objects:v143 count:16];
  if (v20)
  {
    obuint64_t j = v16;
    uint64_t v126 = *(void *)v134;
    uint64_t v21 = v14;
LABEL_21:
    uint64_t v130 = 0;
    id v123 = v20;
LABEL_22:
    if (*(void *)v134 != v126) {
      objc_enumerationMutation(obj);
    }
    CFDictionaryRef v22 = *(const __CFDictionary **)(*((void *)&v133 + 1) + 8 * v130);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v128 = sub_100FC2838(a2, v22, @"entitlement-name");
      if (v128 == -1) {
        goto LABEL_162;
      }
      int v129 = sub_100FC2C68(a2, v22, @"entitlement-status");
      uint64_t v23 = **(NSObject ***)(a2 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
        uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
        CFTypeRef v26 = sub_100059954(v128);
        uint64_t v27 = sub_100FB58A0(v129);
        *(_DWORD *)int buf = 136316418;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v25;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = v26;
        *(_WORD *)&buf[52] = 2080;
        *(void *)&buf[54] = v27;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s with Status %s", buf, 0x3Eu);
        id v20 = v123;
      }
      CFTypeRef v28 = (char *)operator new(0x68uLL);
      *((void *)v28 + 1) = 0;
      *((void *)v28 + 2) = 0;
      *(void *)CFTypeRef v28 = off_101A796A0;
      *(_OWORD *)(v28 + 24) = 0u;
      *(_OWORD *)(v28 + 40) = 0u;
      *(_OWORD *)(v28 + 56) = 0u;
      *(_OWORD *)(v28 + 72) = 0u;
      *(_OWORD *)(v28 + 88) = 0u;
      uint64_t v125 = (uint64_t *)(v28 + 24);
      v131[0] = (uint64_t *)(v28 + 24);
      v131[1] = (uint64_t *)v28;
      if (v129 == -1)
      {
        int v127 = 0;
LABEL_50:
        int v45 = 3;
        goto LABEL_161;
      }
      CFTypeRef v29 = (void *)CFDictionaryGetValue(v22, @"periods-to-skip");
      unint64_t v30 = sub_100FC2DC4(a2, v29, @"periods-to-skip");
      if (v30 <= (unint64_t)&_mh_execute_header) {
        __int16 v31 = &_mh_execute_header;
      }
      else {
        LODWORD(v31) = v30;
      }
      int v127 = (int)v31;
      if (v128 == 13)
      {
        id v110 = CFDictionaryGetValue(v22, @"primary-account-holder");
        *((_WORD *)v28 + 48) = sub_100FC3980(a2, v110, @"primary-account-holder");
        goto LABEL_159;
      }
      if (v128 != 15)
      {
        if (v128 == 17)
        {
          uint64_t v32 = **(NSObject ***)(a2 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
            uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v33;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v34;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = ", ";
            *(_WORD *)&buf[42] = 2112;
            *(void *)&buf[44] = @"alternate-server-property";
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%slooking for KEY:%@", buf, 0x34u);
          }
          *(void *)int buf = off_101A79620;
          *(void *)&uint8_t buf[8] = a2;
          *(void *)&uint8_t buf[24] = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
          *(void *)CFDictionaryRef theDicta = 0;
          *(void *)&theDicta[8] = 0;
          __int16 v35 = CFDictionaryGetValue(v22, @"alternate-server-property");
          sub_100FC3BAC(theDicta, a2, v35, @"alternate-server-property", 1);
          if (theDicta[8])
          {
            int v36 = CFDictionaryGetValue(*(CFDictionaryRef *)theDicta, @"alternate-server");
            if (v36)
            {
              CFTypeID v37 = CFGetTypeID(v36);
              if (v37 == CFStringGetTypeID())
              {
                memset(buf, 0, 32);
                sub_100C8B5B4((uint64_t)(v28 + 56), (long long *)buf);
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
                memset(buf, 0, 24);
                ctu::cf::assign();
                uint64_t v38 = *(void *)buf;
                *(void *)&long long v159 = *(void *)&buf[8];
                *(void *)((char *)&v159 + 7) = *(void *)&buf[15];
                uint8_t v39 = buf[23];
                if (v28[79] < 0) {
                  operator delete(*((void **)v28 + 7));
                }
                uint64_t v40 = v159;
                *((void *)v28 + 7) = v38;
                *((void *)v28 + 8) = v40;
                *(void *)(v28 + 71) = *(void *)((char *)&v159 + 7);
                v28[79] = v39;
                id v41 = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)theDicta, @"use-3gpp-rat");
                uint64_t v42 = v41;
                if (v41)
                {
                  CFTypeID v43 = CFGetTypeID(v41);
                  if (v43 == CFBooleanGetTypeID())
                  {
                    buf[0] = 0;
                    ctu::cf::assign((ctu::cf *)buf, v42, v44);
                    v28[80] = buf[0];
                  }
                }
              }
            }
            if (theDicta[8]) {
              sub_100057D78((const void **)theDicta);
            }
          }
        }
        goto LABEL_159;
      }
      CFArrayRef v141 = 0;
      uint64_t v142 = 0;
      long long v46 = CFDictionaryGetValue(v22, @"5g-property");
      sub_100FC3AEC((const void **)&v141, v46);
      if (!(_BYTE)v142) {
        goto LABEL_159;
      }
      memset(buf, 0, 24);
      sub_100C8B538((uint64_t)v125, (uint64_t)buf);
      *(void *)CFDictionaryRef theDicta = buf;
      sub_1001A14F4((void ***)theDicta);
      unint64_t v47 = CFArrayGetCount(v141);
      uint64_t v48 = *((void *)v28 + 3);
      if (v47 > (*((void *)v28 + 5) - v48) >> 6)
      {
        if (v47 >> 58) {
          sub_10006A748();
        }
        uint64_t v49 = *((void *)v28 + 4);
        *(void *)&unsigned char buf[32] = v28 + 40;
        *(void *)int buf = sub_1001A14BC((uint64_t)(v28 + 40), v47);
        *(void *)&uint8_t buf[8] = *(void *)buf + v49 - v48;
        *(void *)&uint8_t buf[16] = *(void *)&buf[8];
        *(void *)&uint8_t buf[24] = *(void *)buf + (v50 << 6);
        sub_100C91E64(v125, buf);
        sub_1003B7684((uint64_t)buf);
      }
      for (unint64_t i = 0; ; ++i)
      {
        if (i >= CFArrayGetCount(v141))
        {
          if ((_BYTE)v142) {
            sub_100044D00((const void **)&v141);
          }
LABEL_159:
          id v20 = v123;
          switch(v129)
          {
            case 6100:
              int v45 = 2;
              break;
            case 6101:
              int v45 = 1;
              break;
            case 6102:
            case 6104:
            case 6105:
            case 6106:
              int v45 = 6;
              break;
            case 6103:
              int v45 = 5;
              break;
            default:
              goto LABEL_50;
          }
LABEL_161:
          sub_100C89F4C((uint64_t)v124, v128, v45, v129, v131);
          *(_DWORD *)CFDictionaryRef theDicta = v128;
          *(void *)int buf = theDicta;
          *((_DWORD *)sub_10030B04C(v122, (int *)theDicta, (uint64_t)&unk_10144E20E, (unsigned int **)buf) + 8) = v127;
          sub_10004D2C8((std::__shared_weak_count *)v28);
LABEL_162:
          if ((id)++v130 == v20)
          {
            id v111 = [(__CFArray *)obj countByEnumeratingWithState:&v133 objects:v143 count:16];
            id v20 = v111;
            if (!v111) {
              goto LABEL_172;
            }
            goto LABEL_21;
          }
          goto LABEL_22;
        }
        memset(buf, 0, 64);
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v141, i);
        CFDictionaryRef v53 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v54 = CFGetTypeID(ValueAtIndex);
          if (v54 == CFDictionaryGetTypeID()) {
            break;
          }
        }
LABEL_152:
        if (buf[48] && *(void *)&buf[24])
        {
          *(void *)&unsigned char buf[32] = *(void *)&buf[24];
          operator delete(*(void **)&buf[24]);
        }
      }
      long long v159 = 0u;
      long long v160 = 0u;
      CFArrayRef v55 = CFDictionaryGetValue(v53, @"plan-type");
      sub_100FC2A7C(&v159, a2, v55, @"plan-type");
      if (BYTE8(v160))
      {
        uint64_t v56 = BYTE7(v160);
        if (SBYTE7(v160) < 0) {
          uint64_t v56 = *((void *)&v159 + 1);
        }
        if (v56 == 9)
        {
          long long v61 = &v159;
          if (SBYTE7(v160) < 0) {
            long long v61 = (long long *)v159;
          }
          uint64_t v62 = *(void *)v61;
          int v63 = *((unsigned __int8 *)v61 + 8);
          if (v62 != 0x65726574656D6E75 || v63 != 100) {
            goto LABEL_78;
          }
          *(_DWORD *)int buf = 1;
        }
        else
        {
          if (v56 != 7) {
            goto LABEL_78;
          }
          uint64_t v57 = (int *)&v159;
          if (SBYTE7(v160) < 0) {
            uint64_t v57 = (int *)v159;
          }
          int v58 = *v57;
          int v59 = *(int *)((char *)v57 + 3);
          if (v58 != 1702126957 || v59 != 1684370021)
          {
LABEL_78:
            CFStringRef v65 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v66 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v67 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              CFStringRef v68 = (const __CFString *)&v159;
              if (SBYTE7(v160) < 0) {
                CFStringRef v68 = (const __CFString *)v159;
              }
              *(_DWORD *)CFDictionaryRef theDicta = 136316162;
              *(void *)&theDicta[4] = v66;
              *(_WORD *)&theDicta[12] = 2080;
              *(void *)&theDicta[14] = " ";
              *(_WORD *)&theDicta[22] = 2080;
              uint64_t v152 = v67;
              __int16 v153 = 2080;
              uint64_t v154 = ", ";
              __int16 v155 = 2080;
              CFStringRef v156 = v68;
              _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sinvalid plan type received - %s, ignored", theDicta, 0x34u);
              __int16 v14 = v21;
            }
            goto LABEL_84;
          }
          *(_DWORD *)int buf = 0;
        }
        uint8_t buf[4] = 1;
      }
LABEL_84:
      long long v69 = CFDictionaryGetValue(v53, @"5g-experience");
      unsigned __int16 v70 = sub_100FC3980(a2, v69, @"5g-experience");
      if (v70 >= 0x100u) {
        *(_WORD *)&uint8_t buf[8] = v70 | 0x100;
      }
      uint64_t v71 = (void *)CFDictionaryGetValue(v53, @"volume-cap");
      unint64_t v72 = sub_100FC2DC4(a2, v71, @"volume-cap");
      if (HIDWORD(v72))
      {
        *(_DWORD *)&unsigned char buf[12] = v72;
        uint8_t buf[16] = 1;
      }
      CFArrayRef v139 = 0;
      uint64_t v140 = 0;
      unint64_t v73 = CFDictionaryGetValue(v53, @"supported-rat");
      sub_100FC3AEC((const void **)&v139, v73);
      if ((_BYTE)v140)
      {
        memset(theDicta, 0, sizeof(theDicta));
        sub_100195D74((uint64_t)&buf[24], (__n128 *)theDicta);
        if (*(void *)theDicta)
        {
          *(void *)&theDicta[8] = *(void *)theDicta;
          operator delete(*(void **)theDicta);
        }
        unint64_t v74 = 0;
        while (2)
        {
          if (v74 >= CFArrayGetCount(v139))
          {
            if (*(void *)&buf[24] == *(void *)&buf[32] && buf[48] != 0)
            {
              if (*(void *)&buf[24])
              {
                *(void *)&unsigned char buf[32] = *(void *)&buf[24];
                operator delete(*(void **)&buf[24]);
              }
              buf[48] = 0;
            }
            goto LABEL_142;
          }
          CFStringRef v75 = (const __CFString *)CFArrayGetValueAtIndex(v139, v74);
          CFStringRef v76 = v75;
          if (!v75 || (CFTypeID v77 = CFGetTypeID(v75), v77 != CFStringGetTypeID()))
          {
            long long v84 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v85 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v86 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              BOOL v87 = CFArrayGetValueAtIndex(v139, v74);
              *(_DWORD *)CFDictionaryRef theDicta = 136316418;
              *(void *)&theDicta[4] = v85;
              *(_WORD *)&theDicta[12] = 2080;
              *(void *)&theDicta[14] = " ";
              *(_WORD *)&theDicta[22] = 2080;
              uint64_t v152 = v86;
              __int16 v153 = 2080;
              uint64_t v154 = ", ";
              __int16 v155 = 2112;
              CFStringRef v156 = @"sub6";
              __int16 v157 = 2112;
              BOOL v158 = v87;
              id v81 = v84;
              double v82 = "#W %s%s%s%sarray %@ has a value of incorrect type: %@";
              uint32_t v83 = 62;
LABEL_101:
              _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, v82, theDicta, v83);
            }
LABEL_134:
            ++v74;
            __int16 v14 = v21;
            continue;
          }
          break;
        }
        if (CFStringCompare(v76, @"mmw", 0))
        {
          if (CFStringCompare(v76, @"sub6", 0))
          {
            id v78 = **(NSObject ***)(a2 + 40);
            if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v79 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
              uint64_t v80 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
              *(_DWORD *)CFDictionaryRef theDicta = 136316162;
              *(void *)&theDicta[4] = v79;
              *(_WORD *)&theDicta[12] = 2080;
              *(void *)&theDicta[14] = " ";
              *(_WORD *)&theDicta[22] = 2080;
              uint64_t v152 = v80;
              __int16 v153 = 2080;
              uint64_t v154 = ", ";
              __int16 v155 = 2112;
              CFStringRef v156 = v76;
              id v81 = v78;
              double v82 = "#W %s%s%s%sinvalid supported rat received - %@, ignored";
              uint32_t v83 = 52;
              goto LABEL_101;
            }
            goto LABEL_134;
          }
          id v90 = *(char **)&buf[32];
          if (*(void *)&buf[32] < *(void *)&buf[40])
          {
            **(_DWORD **)&unsigned char buf[32] = 1;
            uint64_t v89 = v90 + 4;
LABEL_106:
            signed int v91 = v89;
LABEL_133:
            *(void *)&unsigned char buf[32] = v91;
            goto LABEL_134;
          }
          id v92 = *(char **)&buf[24];
          uint64_t v98 = (uint64_t)(*(void *)&buf[32] - *(void *)&buf[24]) >> 2;
          unint64_t v99 = v98 + 1;
          if ((unint64_t)(v98 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v100 = *(void *)&buf[40] - *(void *)&buf[24];
          if ((uint64_t)(*(void *)&buf[40] - *(void *)&buf[24]) >> 1 > v99) {
            unint64_t v99 = v100 >> 1;
          }
          if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v96 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v96 = v99;
          }
          if (v96)
          {
            uint64_t v97 = (char *)sub_10005ECD8((uint64_t)&buf[40], v96);
            id v92 = *(char **)&buf[24];
            id v90 = *(char **)&buf[32];
          }
          else
          {
            uint64_t v97 = 0;
          }
          CFTypeRef v101 = &v97[4 * v98];
          *(_DWORD *)CFTypeRef v101 = 1;
          signed int v91 = v101 + 4;
          while (v90 != v92)
          {
            int v103 = *((_DWORD *)v90 - 1);
            v90 -= 4;
            *((_DWORD *)v101 - 1) = v103;
            v101 -= 4;
          }
        }
        else
        {
          uint64_t v88 = *(char **)&buf[32];
          if (*(void *)&buf[32] < *(void *)&buf[40])
          {
            **(_DWORD **)&unsigned char buf[32] = 0;
            uint64_t v89 = v88 + 4;
            goto LABEL_106;
          }
          id v92 = *(char **)&buf[24];
          uint64_t v93 = (uint64_t)(*(void *)&buf[32] - *(void *)&buf[24]) >> 2;
          unint64_t v94 = v93 + 1;
          if ((unint64_t)(v93 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v95 = *(void *)&buf[40] - *(void *)&buf[24];
          if ((uint64_t)(*(void *)&buf[40] - *(void *)&buf[24]) >> 1 > v94) {
            unint64_t v94 = v95 >> 1;
          }
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v96 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v96 = v94;
          }
          if (v96)
          {
            uint64_t v97 = (char *)sub_10005ECD8((uint64_t)&buf[40], v96);
            id v92 = *(char **)&buf[24];
            uint64_t v88 = *(char **)&buf[32];
          }
          else
          {
            uint64_t v97 = 0;
          }
          CFTypeRef v101 = &v97[4 * v93];
          *(_DWORD *)CFTypeRef v101 = 0;
          signed int v91 = v101 + 4;
          while (v88 != v92)
          {
            int v102 = *((_DWORD *)v88 - 1);
            v88 -= 4;
            *((_DWORD *)v101 - 1) = v102;
            v101 -= 4;
          }
        }
        *(void *)&uint8_t buf[24] = v101;
        *(void *)&unsigned char buf[32] = v91;
        *(void *)&buf[40] = &v97[4 * v96];
        if (v92) {
          operator delete(v92);
        }
        goto LABEL_133;
      }
LABEL_142:
      int v105 = CFDictionaryGetValue(v53, @"sa-provisioned");
      unsigned __int16 v106 = sub_100FC3980(a2, v105, @"sa-provisioned");
      if (v106 >= 0x100u) {
        *(_WORD *)&uint8_t buf[56] = v106 | 0x100;
      }
      unint64_t v107 = *((void *)v28 + 4);
      if (v107 >= *((void *)v28 + 5))
      {
        uint64_t v109 = sub_100C91D64(v125, (long long *)buf);
      }
      else
      {
        long long v108 = *(_OWORD *)buf;
        *(unsigned char *)(v107 + 16) = buf[16];
        *(_OWORD *)unint64_t v107 = v108;
        sub_1001A118C(v107 + 24, (uint64_t)&buf[24]);
        *(_WORD *)(v107 + 56) = *(_WORD *)&buf[56];
        uint64_t v109 = v107 + 64;
        *((void *)v28 + 4) = v107 + 64;
      }
      *((void *)v28 + 4) = v109;
      if ((_BYTE)v140) {
        sub_100044D00((const void **)&v139);
      }
      if (BYTE8(v160) && SBYTE7(v160) < 0) {
        operator delete((void *)v159);
      }
      goto LABEL_152;
    }
    uint64_t v112 = **(NSObject ***)(a2 + 40);
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v113 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a2 + 24));
      uint64_t v114 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v113;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v114;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sinvalid format, expected dictionary", buf, 0x2Au);
    }
    sub_10004D2C8((std::__shared_weak_count *)v14);
    uint64_t v124 = 0;
    __int16 v14 = 0;
  }
LABEL_172:
  if (v118) {
    sub_10004D2C8(v118);
  }
  if ((_BYTE)v138) {
    sub_100044D00((const void **)&theArray);
  }
  if (!v124)
  {
LABEL_179:
    *a5 = 0;
    a5[1] = 0;
    if (!v14) {
      return;
    }
    goto LABEL_183;
  }
LABEL_177:
  long long v115 = operator new(0x30uLL);
  uint64_t v116 = v115;
  v115[1] = 0;
  v115[2] = 0;
  void *v115 = off_101A795D0;
  long long v117 = (char *)(v115 + 3);
  if (v14)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v115 + 6) = v119;
    v115[4] = v124;
    v115[5] = v14;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v14);
  }
  else
  {
    *((_DWORD *)v115 + 6) = v119;
    v115[4] = v124;
    v115[5] = 0;
  }
  *a5 = v117;
  a5[1] = v116;
  if (v14) {
LABEL_183:
  }
    sub_10004D2C8((std::__shared_weak_count *)v14);
}

void sub_100FD05B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,const void *a41,__int16 a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  if (*(char *)(v66 - 153) < 0) {
    operator delete(*(void **)(v66 - 176));
  }
  if ((_BYTE)a64) {
    sub_100057D78((const void **)&__p);
  }
  sub_10004D2C8(v65);
  sub_10004D2C8(v64);
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((_BYTE)a42) {
    sub_100044D00(&a41);
  }
  _Unwind_Resume(a1);
}

void sub_100FD07CC(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)uint64_t v19 = 136316162;
    *(void *)&v19[4] = v9;
    *(_WORD *)&v19[12] = 2080;
    *(void *)&v19[14] = " ";
    __int16 v20 = 2080;
    uint64_t v21 = v10;
    __int16 v22 = 2080;
    uint64_t v23 = ", ";
    __int16 v24 = 2080;
    uint64_t v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", v19, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    sub_100FC9420(v19, v17, 0, 0);
    uint64_t v13 = *(void *)v19;
    uint64_t v18 = *(std::__shared_weak_count **)&v19[8];
    if (v12) {
      sub_10004D2C8(v12);
    }
    uint64_t v12 = v18;
    goto LABEL_17;
  }
  __int16 v14 = *(std::__shared_weak_count **)(v13 + 16);
  if (!v14)
  {
    *(void *)(v13 + 16) = 0;
LABEL_17:
    *a4 = v13;
    a4[1] = v12;
    return;
  }
  uint64_t v15 = *(void *)(v13 + 8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  CFArrayRef v16 = *(std::__shared_weak_count **)(v13 + 16);
  *(void *)(v13 + 8) = v15;
  *(void *)(v13 + 16) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD09D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD09F0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      uint64_t v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      uint64_t v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    int v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1001985D8(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD0CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD0D54()
{
  return "getEntitlement";
}

void sub_100FD0D60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD0D80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A048;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD0DD4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD0E00(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD0E38(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, uint64_t **a4@<X4>, void *a5@<X8>)
{
  if (a2 != 6000)
  {
    uint64_t v15 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      uint64_t v67 = v16;
      __int16 v68 = 2080;
      long long v69 = " ";
      __int16 v70 = 2080;
      uint64_t v71 = v17;
      __int16 v72 = 2080;
      unint64_t v73 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v18 = 0;
    int v8 = 0;
    goto LABEL_36;
  }
  unint64_t v7 = operator new(0x48uLL);
  v7[1] = 0;
  v7[2] = 0;
  void *v7 = off_101A796F0;
  _OWORD v7[4] = 0;
  uint64_t v7[3] = v7 + 4;
  int v8 = (uint64_t **)(v7 + 3);
  v7[5] = 0;
  v7[7] = 0;
  void v7[6] = v7 + 7;
  CFTypeID v43 = (uint64_t **)(v7 + 6);
  uint64_t v38 = (std::__shared_weak_count *)v7;
  v7[8] = 0;
  CFArrayRef theArray = 0;
  uint64_t v52 = 0;
  CFBooleanRef Value = CFDictionaryGetValue(a3, @"response");
  sub_100FC3AEC((const void **)&theArray, Value);
  if (!(_BYTE)v52)
  {
    int v8 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = v38;
LABEL_34:
    sub_10004D2C8(v19);
    goto LABEL_35;
  }
  uint64_t v10 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    CFIndex Count = CFArrayGetCount(theArray);
    *(_DWORD *)int buf = 136316162;
    uint64_t v67 = v11;
    __int16 v68 = 2080;
    long long v69 = " ";
    __int16 v70 = 2080;
    uint64_t v71 = v12;
    __int16 v72 = 2080;
    unint64_t v73 = ", ";
    __int16 v74 = 2048;
    CFIndex v75 = Count;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sthere are %lu entitlement responses", buf, 0x34u);
  }
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  CFArrayRef v46 = theArray;
  if (theArray)
  {
    CFRetain(theArray);
    CFArrayRef v14 = v46;
  }
  else
  {
    CFArrayRef v14 = 0;
  }
  sub_100044D00((const void **)&v46);
  id v20 = [(__CFArray *)v14 countByEnumeratingWithState:&v47 objects:buf count:16];
  if (v20)
  {
    uint64_t v45 = *(void *)v48;
    CFArrayRef v41 = v14;
    while (2)
    {
      uint64_t v21 = 0;
      id v42 = v20;
      do
      {
        if (*(void *)v48 != v45) {
          objc_enumerationMutation(v14);
        }
        CFDictionaryRef v22 = *(const __CFDictionary **)(*((void *)&v47 + 1) + 8 * (void)v21);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v32 = **(NSObject ***)(a1 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            *(_DWORD *)CFArrayRef v55 = 136315906;
            *(void *)&v55[4] = v33;
            __int16 v56 = 2080;
            uint64_t v57 = " ";
            __int16 v58 = 2080;
            uint64_t v59 = v34;
            __int16 v60 = 2080;
            long long v61 = ", ";
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sinvalid item format, expected dictionary", v55, 0x2Au);
          }
          int v8 = 0;
          uint64_t v18 = 0;
          uint64_t v19 = v38;
          goto LABEL_31;
        }
        int v23 = sub_100FC2838(a1, v22, @"entitlement-name");
        if (v23 != -1)
        {
          int v24 = sub_100FC2C68(a1, v22, @"entitlement-status");
          int v25 = **(NSObject ***)(a1 + 40);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            CFTypeRef v26 = v8;
            uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            CFTypeRef v29 = sub_100059954(v23);
            unint64_t v30 = sub_100FB58A0(v24);
            *(_DWORD *)CFArrayRef v55 = 136316418;
            *(void *)&v55[4] = v27;
            __int16 v56 = 2080;
            uint64_t v57 = " ";
            __int16 v58 = 2080;
            uint64_t v59 = v28;
            __int16 v60 = 2080;
            long long v61 = ", ";
            __int16 v62 = 2080;
            int v63 = v29;
            __int16 v64 = 2080;
            CFStringRef v65 = v30;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s%s with Status %s", v55, 0x3Eu);
            int v8 = v26;
            CFArrayRef v14 = v41;
            id v20 = v42;
          }
          if ((v24 - 6100) > 6) {
            int v31 = 3;
          }
          else {
            int v31 = dword_1015A7B24[v24 - 6100];
          }
          int v53 = v23;
          int v54 = v23;
          *(void *)CFArrayRef v55 = &v54;
          *((_DWORD *)sub_10030B04C(v8, &v54, (uint64_t)&unk_10144E20E, (unsigned int **)v55) + 8) = v31;
          *(void *)CFArrayRef v55 = &v53;
          *((_DWORD *)sub_10030B04C(v43, &v53, (uint64_t)&unk_10144E20E, (unsigned int **)v55) + 8) = v24;
          sub_100FC2F60(a1, v23, v24, a4);
        }
        uint64_t v21 = (char *)v21 + 1;
      }
      while (v20 != v21);
      id v20 = [(__CFArray *)v14 countByEnumeratingWithState:&v47 objects:buf count:16];
      if (v20) {
        continue;
      }
      break;
    }
  }
  uint64_t v18 = v38;
  uint64_t v19 = 0;
LABEL_31:
  if ((_BYTE)v52) {
    sub_100044D00((const void **)&theArray);
  }
  if (v19) {
    goto LABEL_34;
  }
LABEL_35:
  if (!v8)
  {
    *a5 = 0;
    a5[1] = 0;
    if (!v18) {
      return;
    }
    goto LABEL_40;
  }
LABEL_36:
  __int16 v35 = operator new(0x30uLL);
  int v36 = v35;
  v35[1] = 0;
  v35[2] = 0;
  void *v35 = off_101A7A120;
  __int16 v37 = (char *)(v35 + 3);
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v35 + 6) = a2;
    void v35[4] = v8;
    v35[5] = v18;
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v18);
  }
  else
  {
    *((_DWORD *)v35 + 6) = a2;
    void v35[4] = v8;
    v35[5] = 0;
  }
  *a5 = v37;
  a5[1] = v36;
  if (v18) {
LABEL_40:
  }
    sub_10004D2C8(v18);
}

void sub_100FD14E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29,char a30)
{
  if (a30) {
    sub_100044D00(&a29);
  }
  sub_10004D2C8(a9);
  _Unwind_Resume(a1);
}

void sub_100FD1550(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    id v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A120;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  CFArrayRef v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    id v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD1780(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD1798(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  CFArrayRef v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    int v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    id v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100198894(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD1A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD1AFC()
{
  return "setEntitlement";
}

void sub_100FD1B08(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A120;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD1B28(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A120;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD1B7C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD1B90(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A170;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD1BB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A170;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD1C04(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD1C30(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD1C68(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, uint64_t **a4@<X4>, void *a5@<X8>)
{
  int v5 = a2;
  if (a2 == 6000)
  {
    CFArrayRef v14 = (std::__shared_weak_count *)operator new(0x48uLL);
    v14->__shared_owners_ = 0;
    v14->__shared_weak_owners_ = 0;
    v14->__vftable = (std::__shared_weak_count_vtbl *)off_101A79740;
    v14[1].__shared_owners_ = 0;
    p_shared_owners = &v14[1].__shared_owners_;
    v14[1].__vftable = (std::__shared_weak_count_vtbl *)&v14[1].__shared_owners_;
    uint64_t v112 = v14 + 1;
    v14[1].__shared_weak_owners_ = 0;
    v14[2].__shared_owners_ = 0;
    v14[2].__vftable = (std::__shared_weak_count_vtbl *)&v14[2].__shared_owners_;
    long long v115 = (uint64_t **)&v14[2];
    v14[2].__shared_weak_owners_ = 0;
    CFArrayRef theArray = 0;
    uint64_t v139 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"provisioning-elements");
    sub_100FC3AEC((const void **)&theArray, Value);
    if (!(_BYTE)v139)
    {
      sub_10004D2C8(v14);
      *a5 = 0;
      a5[1] = 0;
      return;
    }
    id v111 = a5;
    int v18 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      CFIndex Count = CFArrayGetCount(theArray);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v20;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      *(_WORD *)&buf[42] = 2048;
      *(void *)&buf[44] = Count;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sthere are %lu provisioning elements", buf, 0x34u);
    }
    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    CFArrayRef v133 = theArray;
    if (theArray)
    {
      CFRetain(theArray);
      CFArrayRef v22 = v133;
    }
    else
    {
      CFArrayRef v22 = 0;
    }
    sub_100044D00((const void **)&v133);
    id v23 = [(__CFArray *)v22 countByEnumeratingWithState:&v134 objects:v158 count:16];
    if (!v23)
    {
LABEL_181:
      if ((_BYTE)v139) {
        sub_100044D00((const void **)&theArray);
      }
      a5 = v111;
      int v5 = 6000;
      goto LABEL_184;
    }
    uint64_t v121 = *(void *)v135;
    id v118 = v14;
    CFArrayRef v113 = v22;
    uint64_t v114 = a4;
LABEL_17:
    uint64_t v24 = 0;
    id v117 = v23;
    while (1)
    {
      if (*(void *)v135 != v121) {
        objc_enumerationMutation(v22);
      }
      CFDictionaryRef v25 = *(const __CFDictionary **)(*((void *)&v134 + 1) + 8 * v24);
      objc_opt_class();
      uint64_t v124 = v24;
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        __int16 v64 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v65 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v65;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v66;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = ", ";
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sinvalid provisioning-element format, expected dictionary - skipped", buf, 0x2Au);
        }
        goto LABEL_179;
      }
      int v122 = sub_100FC2838(a1, v25, @"name");
      if (v122 != -1) {
        break;
      }
LABEL_179:
      uint64_t v24 = v124 + 1;
      if ((id)(v124 + 1) == v23)
      {
        id v23 = [(__CFArray *)v22 countByEnumeratingWithState:&v134 objects:v158 count:16];
        if (!v23) {
          goto LABEL_181;
        }
        goto LABEL_17;
      }
    }
    CFDictionaryRef v120 = v25;
    int v119 = sub_100FC2C68(a1, v25, @"status");
    int v26 = sub_100FC2F60(a1, v122, v119, a4);
    long long v132 = 0u;
    memset(v131, 0, sizeof(v131));
    long long v129 = 0u;
    long long v130 = 0u;
    if (v26)
    {
      uint64_t v27 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v29;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sExtracting data of IMS Credential", buf, 0x2Au);
      }
      id v30 = [(__CFDictionary *)v25 objectForKey:@"data"];
      if (v30)
      {
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();
        uint64_t v32 = **(NSObject ***)(a1 + 40);
        BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
        if (isKindOfClass)
        {
          if (v33)
          {
            uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            id v36 = [v30 count];
            *(_DWORD *)int buf = 136316162;
            *(void *)&uint8_t buf[4] = v34;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v35;
            *(_WORD *)&unsigned char buf[32] = 2080;
            *(void *)&buf[34] = ", ";
            *(_WORD *)&buf[42] = 2048;
            *(void *)&buf[44] = v36;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sThere are %lu provisioning-data responses", buf, 0x34u);
          }
          long long v127 = 0u;
          long long v128 = 0u;
          long long v125 = 0u;
          long long v126 = 0u;
          id v37 = [v30 countByEnumeratingWithState:&v125 objects:v157 count:16];
          if (v37)
          {
            uint64_t v38 = *(void *)v126;
            do
            {
              for (unint64_t i = 0; i != v37; unint64_t i = (char *)i + 1)
              {
                if (*(void *)v126 != v38) {
                  objc_enumerationMutation(v30);
                }
                uint64_t v40 = *(void **)(*((void *)&v125 + 1) + 8 * i);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  *(_OWORD *)__int16 v155 = 0u;
                  long long v156 = 0u;
                  *(_OWORD *)__int16 v153 = 0u;
                  long long v154 = 0u;
                  *(_OWORD *)uint64_t v151 = 0u;
                  long long v152 = 0u;
                  *(_OWORD *)__int16 v149 = 0u;
                  long long v150 = 0u;
                  *(_OWORD *)__int16 v147 = 0u;
                  long long v148 = 0u;
                  *(_OWORD *)__int16 v145 = 0u;
                  long long v146 = 0u;
                  memset(buf, 0, sizeof(buf));
                  CFArrayRef v41 = (objc_object *)[v40 objectForKey:@"CSR"];
                  if (v41)
                  {
                    asString((uint64_t *)v141, v41);
                    if (buf[24])
                    {
                      if ((buf[23] & 0x80000000) != 0) {
                        operator delete(*(void **)buf);
                      }
                      *(_OWORD *)int buf = *(_OWORD *)v141;
                      *(void *)&uint8_t buf[16] = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)int buf = *(_OWORD *)v141;
                      *(void *)&uint8_t buf[16] = *(void *)&v141[16];
                      uint8_t buf[24] = 1;
                    }
                  }
                  uint64_t v45 = (objc_object *)[v40 objectForKey:@"sip-reg-uri"];
                  if (v45)
                  {
                    asString((uint64_t *)v141, v45);
                    if (buf[56])
                    {
                      if ((buf[55] & 0x80000000) != 0) {
                        operator delete(*(void **)&buf[32]);
                      }
                      *(_OWORD *)&unsigned char buf[32] = *(_OWORD *)v141;
                      *(void *)&buf[48] = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)&unsigned char buf[32] = *(_OWORD *)v141;
                      *(void *)&buf[48] = *(void *)&v141[16];
                      uint8_t buf[56] = 1;
                    }
                  }
                  CFArrayRef v46 = (objc_object *)[v40 objectForKey:@"apn"];
                  if (v46)
                  {
                    asString((uint64_t *)v141, v46);
                    if (BYTE8(v146))
                    {
                      if (SBYTE7(v146) < 0) {
                        operator delete(v145[0]);
                      }
                      *(_OWORD *)__int16 v145 = *(_OWORD *)v141;
                      *(void *)&long long v146 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v145 = *(_OWORD *)v141;
                      *(void *)&long long v146 = *(void *)&v141[16];
                      BYTE8(v146) = 1;
                    }
                  }
                  long long v47 = (objc_object *)[v40 objectForKey:@"sip-username"];
                  if (v47)
                  {
                    asString((uint64_t *)v141, v47);
                    if (BYTE8(v148))
                    {
                      if (SBYTE7(v148) < 0) {
                        operator delete(v147[0]);
                      }
                      *(_OWORD *)__int16 v147 = *(_OWORD *)v141;
                      *(void *)&long long v148 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v147 = *(_OWORD *)v141;
                      *(void *)&long long v148 = *(void *)&v141[16];
                      BYTE8(v148) = 1;
                    }
                  }
                  long long v48 = (objc_object *)[v40 objectForKey:@"sip-password"];
                  if (v48)
                  {
                    asString((uint64_t *)v141, v48);
                    if (BYTE8(v150))
                    {
                      if (SBYTE7(v150) < 0) {
                        operator delete(v149[0]);
                      }
                      *(_OWORD *)__int16 v149 = *(_OWORD *)v141;
                      *(void *)&long long v150 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v149 = *(_OWORD *)v141;
                      *(void *)&long long v150 = *(void *)&v141[16];
                      BYTE8(v150) = 1;
                    }
                  }
                  long long v49 = (objc_object *)[v40 objectForKey:@"imsi"];
                  if (v49)
                  {
                    asString((uint64_t *)v141, v49);
                    if (BYTE8(v152))
                    {
                      if (SBYTE7(v152) < 0) {
                        operator delete(v151[0]);
                      }
                      *(_OWORD *)uint64_t v151 = *(_OWORD *)v141;
                      *(void *)&long long v152 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)uint64_t v151 = *(_OWORD *)v141;
                      *(void *)&long long v152 = *(void *)&v141[16];
                      BYTE8(v152) = 1;
                    }
                  }
                  long long v50 = (objc_object *)[v40 objectForKey:@"public-id"];
                  if (v50)
                  {
                    asString((uint64_t *)v141, v50);
                    if (BYTE8(v154))
                    {
                      if (SBYTE7(v154) < 0) {
                        operator delete(v153[0]);
                      }
                      *(_OWORD *)__int16 v153 = *(_OWORD *)v141;
                      *(void *)&long long v154 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v153 = *(_OWORD *)v141;
                      *(void *)&long long v154 = *(void *)&v141[16];
                      BYTE8(v154) = 1;
                    }
                  }
                  int v51 = (objc_object *)[v40 objectForKey:@"pcscf-address"];
                  if (v51)
                  {
                    asString((uint64_t *)v141, v51);
                    if (BYTE8(v156))
                    {
                      if (SBYTE7(v156) < 0) {
                        operator delete(v155[0]);
                      }
                      *(_OWORD *)__int16 v155 = *(_OWORD *)v141;
                      *(void *)&long long v156 = *(void *)&v141[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v155 = *(_OWORD *)v141;
                      *(void *)&long long v156 = *(void *)&v141[16];
                      BYTE8(v156) = 1;
                    }
                  }
                  if (!BYTE8(v130))
                  {
                    *(void *)&long long v130 = 0;
                    long long v129 = 0uLL;
                    memset(v141, 0, sizeof(v141));
                    BYTE8(v130) = 1;
                    uint64_t v140 = v141;
                    sub_100C92308((void ***)&v140);
                  }
                  uint64_t v52 = *((void *)&v129 + 1);
                  if (*((void *)&v129 + 1) >= (unint64_t)v130)
                  {
                    uint64_t v54 = (uint64_t)(*((void *)&v129 + 1) - v129) >> 8;
                    if ((unint64_t)(v54 + 1) >> 56) {
                      sub_10006A748();
                    }
                    unint64_t v55 = (uint64_t)(v130 - v129) >> 7;
                    if (v55 <= v54 + 1) {
                      unint64_t v55 = v54 + 1;
                    }
                    if ((void)v130 - (void)v129 >= 0x7FFFFFFFFFFFFF00uLL) {
                      unint64_t v56 = 0xFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v56 = v55;
                    }
                    v143[0] = &v130;
                    if (v56) {
                      uint64_t v57 = (char *)sub_100C920B8((uint64_t)&v130, v56);
                    }
                    else {
                      uint64_t v57 = 0;
                    }
                    *(void *)CFArrayRef v141 = v57;
                    *(void *)&v141[8] = &v57[256 * v54];
                    *(void *)&v141[16] = *(void *)&v141[8];
                    uint64_t v142 = &v57[256 * v56];
                    sub_100C92174(*(uint64_t *)&v141[8], (long long *)buf);
                    __int16 v58 = (__n128 *)*((void *)&v129 + 1);
                    uint64_t v59 = (__n128 *)v129;
                    uint64_t v60 = *(void *)&v141[8];
                    uint64_t v61 = *(void *)&v141[16];
                    if (*((void *)&v129 + 1) == (void)v129)
                    {
                      int64x2_t v62 = vdupq_n_s64(*((unint64_t *)&v129 + 1));
                    }
                    else
                    {
                      do
                      {
                        v60 -= 256;
                        v58 -= 16;
                        sub_1003AA63C(v60, v58);
                      }
                      while (v58 != v59);
                      int64x2_t v62 = (int64x2_t)v129;
                    }
                    uint64_t v53 = v61 + 256;
                    *(void *)&long long v129 = v60;
                    *((void *)&v129 + 1) = v53;
                    *(int64x2_t *)&v141[8] = v62;
                    int v63 = (char *)v130;
                    *(void *)&long long v130 = v142;
                    uint64_t v142 = v63;
                    *(void *)CFArrayRef v141 = v62.i64[0];
                    sub_100FC7924((uint64_t)v141);
                  }
                  else
                  {
                    sub_100C92174(*((uint64_t *)&v129 + 1), (long long *)buf);
                    uint64_t v53 = v52 + 256;
                  }
                  *((void *)&v129 + 1) = v53;
                  sub_1003AA7DC((uint64_t)buf);
                }
                else
                {
                  id v42 = **(NSObject ***)(a1 + 40);
                  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v43 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                    uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                    *(_DWORD *)int buf = 136315906;
                    *(void *)&uint8_t buf[4] = v43;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = " ";
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)&uint8_t buf[24] = v44;
                    *(_WORD *)&unsigned char buf[32] = 2080;
                    *(void *)&buf[34] = ", ";
                    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sIMS Credential is not a dictionary", buf, 0x2Au);
                  }
                }
              }
              id v37 = [v30 countByEnumeratingWithState:&v125 objects:v157 count:16];
            }
            while (v37);
          }
          goto LABEL_114;
        }
        if (v33)
        {
          uint64_t v72 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v72;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v73;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = ", ";
          __int16 v70 = v32;
          uint64_t v71 = "#W %s%s%s%sInvalid provisioning data format - skipped";
          goto LABEL_113;
        }
      }
      else
      {
        uint64_t v67 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v68 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v69 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v68;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v69;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = ", ";
          __int16 v70 = v67;
          uint64_t v71 = "#W %s%s%s%sNo provisioning data - skipped";
LABEL_113:
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, v71, buf, 0x2Au);
        }
      }
    }
LABEL_114:
    __int16 v74 = (objc_object *)[(__CFDictionary *)v120 objectForKey:@"service-mgmt-url"];
    if (v74)
    {
      memset(buf, 0, 56);
      asString((uint64_t *)v141, v74);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      *(_OWORD *)int buf = *(_OWORD *)v141;
      *(void *)&uint8_t buf[16] = *(void *)&v141[16];
      CFIndex v75 = (objc_object *)[(__CFDictionary *)v120 objectForKey:@"service-mgmt-url-postdata"];
      if (v75)
      {
        asString((uint64_t *)v141, v75);
        if (buf[48])
        {
          if ((buf[47] & 0x80000000) != 0) {
            operator delete(*(void **)&buf[24]);
          }
          *(_OWORD *)&uint8_t buf[24] = *(_OWORD *)v141;
          *(void *)&buf[40] = *(void *)&v141[16];
        }
        else
        {
          *(_OWORD *)&uint8_t buf[24] = *(_OWORD *)v141;
          *(void *)&buf[40] = *(void *)&v141[16];
          buf[48] = 1;
        }
      }
      else
      {
        uint64_t v79 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v80 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v81 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)CFArrayRef v141 = 136315906;
          *(void *)&v141[4] = v80;
          *(_WORD *)&v141[12] = 2080;
          *(void *)&v141[14] = " ";
          *(_WORD *)&v141[22] = 2080;
          uint64_t v142 = (char *)v81;
          LOWORD(v143[0]) = 2080;
          *(void *)((char *)v143 + 2) = ", ";
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sNo service-mgmt-url data", v141, 0x2Au);
        }
      }
      if (BYTE8(v132))
      {
        std::string::operator=(v131, (const std::string *)buf);
        sub_100179AF8(&v131[1], (const std::string *)&buf[24]);
      }
      else
      {
        if ((buf[23] & 0x80000000) != 0) {
          sub_10004FC84(v131, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else {
          v131[0] = *(std::string *)buf;
        }
        sub_1000593FC((uint64_t)&v131[1], (long long *)&buf[24]);
        BYTE8(v132) = 1;
      }
      if (buf[48] && (buf[47] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[24]);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      CFStringRef v76 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v77 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v78 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v77;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v78;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sNo service-mgmt-url data", buf, 0x2Au);
      }
    }
    double v82 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v83 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v84 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      uint64_t v85 = sub_100059954(v122);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v83;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v84;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v85;
      _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sadding response for %s", buf, 0x34u);
    }
    LODWORD(v140) = v122;
    uint64_t v86 = (uint64_t **)p_shared_owners;
    while (1)
    {
      BOOL v87 = *v86;
      uint64_t v88 = v86;
      if (!*v86) {
        break;
      }
      while (1)
      {
        uint64_t v86 = (uint64_t **)v87;
        int v89 = *((_DWORD *)v87 + 8);
        if (v89 > v122) {
          break;
        }
        if (v89 >= v122)
        {
          id v92 = (char *)v86;
          goto LABEL_150;
        }
        BOOL v87 = v86[1];
        if (!v87)
        {
          uint64_t v88 = v86 + 1;
          goto LABEL_147;
        }
      }
    }
LABEL_147:
    id v92 = (char *)operator new(0x88uLL);
    *((_DWORD *)v92 + 8) = v122;
    *(_OWORD *)(v92 + 40) = 0u;
    *(_OWORD *)(v92 + 56) = 0u;
    *(_OWORD *)(v92 + 72) = 0u;
    *(_OWORD *)(v92 + 88) = 0u;
    *(_OWORD *)(v92 + 104) = 0u;
    *(_OWORD *)(v92 + 120) = 0u;
    *(void *)id v92 = 0;
    *((void *)v92 + 1) = 0;
    *((void *)v92 + 2) = v86;
    char *v88 = (uint64_t *)v92;
    id v90 = (uint64_t *)v92;
    signed int v91 = v112->~__shared_weak_count;
    if (v91)
    {
      v112->__vftable = (std::__shared_weak_count_vtbl *)v91;
      id v90 = *v88;
    }
    sub_100046C90((uint64_t *)v118[1].__shared_owners_, v90);
    ++v118[1].__shared_weak_owners_;
LABEL_150:
    uint64_t v93 = (long long *)(v92 + 40);
    if (v92[64] != BYTE8(v130))
    {
      if (v92[64])
      {
        *(void *)int buf = v92 + 40;
        sub_100C92308((void ***)buf);
        v92[64] = 0;
      }
      else
      {
        *(void *)uint64_t v93 = 0;
        *((void *)v92 + 6) = 0;
        *((void *)v92 + 7) = 0;
        sub_100C91FEC((void *)v92 + 5, v129, *((uint64_t *)&v129 + 1), (uint64_t)(*((void *)&v129 + 1) - v129) >> 8);
        v92[64] = 1;
      }
      goto LABEL_176;
    }
    if (v93 != &v129 && v92[64])
    {
      uint64_t v94 = *((void *)&v129 + 1);
      uint64_t v95 = *((void *)&v129 + 1) - v129;
      unint64_t v96 = (uint64_t)(*((void *)&v129 + 1) - v129) >> 8;
      uint64_t v97 = *((void *)v92 + 7);
      uint64_t v98 = *((void *)v92 + 5);
      if (v96 <= (v97 - v98) >> 8)
      {
        unint64_t v104 = (*((void *)v92 + 6) - v98) >> 8;
        if (v104 >= v96)
        {
          unsigned __int16 v106 = sub_100FC9A04(v129, *((uint64_t *)&v129 + 1), *((char **)v92 + 5));
          for (uint64_t j = *((void *)v92 + 6); (char *)j != v106; uint64_t j = sub_1003AA7DC(j - 256))
            ;
          *((void *)v92 + 6) = v106;
          goto LABEL_176;
        }
        uint64_t v105 = v129 + (v104 << 8);
        sub_100FC9A04(v129, v105, *((char **)v92 + 5));
        uint64_t v103 = sub_100C920F0((uint64_t)(v92 + 56), v105, v94, *((void *)v92 + 6));
      }
      else
      {
        uint64_t v123 = v129;
        if (v98)
        {
          uint64_t v99 = *((void *)v92 + 6);
          uint64_t v100 = (void *)*((void *)v92 + 5);
          if (v99 != v98)
          {
            do
              uint64_t v99 = sub_1003AA7DC(v99 - 256);
            while (v99 != v98);
            uint64_t v100 = *(void **)v93;
          }
          *((void *)v92 + 6) = v98;
          operator delete(v100);
          uint64_t v97 = 0;
          *(void *)uint64_t v93 = 0;
          *((void *)v92 + 6) = 0;
          *((void *)v92 + 7) = 0;
        }
        if (v95 < 0) {
          sub_10006A748();
        }
        uint64_t v101 = v97 >> 7;
        if (v97 >> 7 <= v96) {
          uint64_t v101 = v96;
        }
        if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFF00) {
          unint64_t v102 = 0xFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v102 = v101;
        }
        sub_100C92074((void *)v92 + 5, v102);
        uint64_t v103 = sub_100C920F0((uint64_t)(v92 + 56), v123, v94, *((void *)v92 + 6));
      }
      *((void *)v92 + 6) = v103;
    }
LABEL_176:
    sub_100FC9AB0((std::string *)v92 + 3, v131);
    *(void *)CFArrayRef v141 = &v140;
    *((_DWORD *)sub_10030B04C(v115, (int *)&v140, (uint64_t)&unk_10144E20E, (unsigned int **)v141) + 8) = v119;
    sub_100FC7974((uint64_t)v131);
    if (BYTE8(v130))
    {
      *(void *)int buf = &v129;
      sub_100C92308((void ***)buf);
    }
    id v23 = v117;
    CFArrayRef v14 = v118;
    CFArrayRef v22 = v113;
    a4 = v114;
    goto LABEL_179;
  }
  if (a2 == 6008)
  {
    int v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v10;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smax number of devices reached", buf, 0x2Au);
    }
  }
  uint64_t v11 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v13;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = ", ";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  CFArrayRef v14 = 0;
  uint64_t v112 = 0;
LABEL_184:
  long long v108 = operator new(0x30uLL);
  uint64_t v109 = v108;
  v108[1] = 0;
  v108[2] = 0;
  void *v108 = off_101A7A248;
  id v110 = (char *)(v108 + 3);
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v108 + 6) = v5;
    v108[4] = v112;
    v108[5] = v14;
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    *a5 = v110;
    a5[1] = v109;
    sub_10004D2C8(v14);
  }
  else
  {
    *((_DWORD *)v108 + 6) = v5;
    v108[4] = v112;
    v108[5] = 0;
    *a5 = v110;
    a5[1] = v108;
  }
}

void sub_100FD3184(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100FD32C4(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    CFDictionaryRef v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    uint64_t v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    uint64_t v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A248;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  CFArrayRef v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    uint64_t v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD34F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD350C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  CFArrayRef v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    id v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    uint64_t v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100198B50(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD3800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD3870()
{
  return "getProvisioning";
}

void sub_100FD387C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A248;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD389C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A248;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD38F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD3904(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A298;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD3924(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A298;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD3978(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD39A4(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD39DC(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, uint64_t **a4@<X4>, void *a5@<X8>)
{
  int v5 = a2;
  if (a2 == 6000)
  {
    int v17 = (std::__shared_weak_count *)operator new(0x48uLL);
    v17->__shared_owners_ = 0;
    v17->__shared_weak_owners_ = 0;
    v17->__vftable = (std::__shared_weak_count_vtbl *)off_1019A8F28;
    v17[1].__shared_owners_ = 0;
    v17[1].__vftable = (std::__shared_weak_count_vtbl *)&v17[1].__shared_owners_;
    uint64_t v66 = (uint64_t **)&v17[1];
    v17[1].__shared_weak_owners_ = 0;
    v17[2].__shared_owners_ = 0;
    v17[2].__vftable = (std::__shared_weak_count_vtbl *)&v17[2].__shared_owners_;
    uint64_t v65 = (uint64_t **)&v17[2];
    v17[2].__shared_weak_owners_ = 0;
    CFArrayRef theArray = 0;
    uint64_t v81 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"provisioning-response");
    sub_100FC3AEC((const void **)&theArray, Value);
    if (!(_BYTE)v81)
    {
      sub_10004D2C8(v17);
      *a5 = 0;
      a5[1] = 0;
      return;
    }
    int64x2_t v62 = v17;
    uint64_t v19 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      CFIndex Count = CFArrayGetCount(theArray);
      *(_DWORD *)id v90 = 136316162;
      *(void *)&v90[4] = v20;
      *(_WORD *)&v90[12] = 2080;
      *(void *)&v90[14] = " ";
      *(_WORD *)&v90[22] = 2080;
      uint64_t v91 = v21;
      __int16 v92 = 2080;
      uint64_t v93 = ", ";
      __int16 v94 = 2048;
      CFIndex v95 = Count;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sthere are %lu provisioning elements", v90, 0x34u);
    }
    int v63 = a4;
    uint64_t v61 = a5;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    CFArrayRef v23 = theArray;
    id v24 = [(__CFArray *)theArray countByEnumeratingWithState:&v76 objects:buf count:16];
    if (v24)
    {
      uint64_t v67 = *(void *)v77;
      do
      {
        for (unint64_t i = 0; i != v24; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v77 != v67) {
            objc_enumerationMutation(v23);
          }
          CFDictionaryRef v26 = *(const __CFDictionary **)(*((void *)&v76 + 1) + 8 * i);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            int v27 = sub_100FC2838(a1, v26, @"name");
            if (v27 != -1 || (int v27 = sub_100FC2838(a1, v26, @"provisioning-name"), v27 != -1))
            {
              CFTypeRef v28 = (capabilities::ct *)sub_100FC2C68(a1, v26, @"status");
              int v29 = (int)v28;
              if (v28 == -1)
              {
                CFTypeRef v28 = (capabilities::ct *)sub_100FC2C68(a1, v26, @"provisioning-status");
                int v29 = (int)v28;
              }
              if (v27 == 8)
              {
                if (capabilities::ct::supportsThumperSourcing(v28)) {
                  int v30 = 1;
                }
                else {
                  int v30 = sub_100FC2F60(a1, 8, v29, v63);
                }
                __int16 v35 = (char *)operator new(0xA0uLL);
                id v36 = v35;
                *((void *)v35 + 1) = 0;
                *((void *)v35 + 2) = 0;
                *(void *)__int16 v35 = off_101A79790;
                __int16 v37 = v35 + 24;
                *((_OWORD *)v35 + 2) = 0u;
                uint64_t v38 = (std::string *)(v35 + 32);
                *((_OWORD *)v35 + 3) = 0u;
                *((_OWORD *)v35 + 4) = 0u;
                *((_OWORD *)v35 + 5) = 0u;
                *((_OWORD *)v35 + 6) = 0u;
                *((_OWORD *)v35 + 7) = 0u;
                *((_OWORD *)v35 + 8) = 0u;
                *((_OWORD *)v35 + 9) = 0u;
                *((void *)v35 + 3) = off_101A4D3B8;
                if (v30)
                {
                  __int16 v64 = v35 + 24;
                  uint8_t v39 = **(NSObject ***)(a1 + 40);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v40 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                    uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                    *(_DWORD *)id v90 = 136315906;
                    *(void *)&v90[4] = v40;
                    *(_WORD *)&v90[12] = 2080;
                    *(void *)&v90[14] = " ";
                    *(_WORD *)&v90[22] = 2080;
                    uint64_t v91 = v41;
                    __int16 v92 = 2080;
                    uint64_t v93 = ", ";
                    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sExtracting data of certificate", v90, 0x2Au);
                  }
                  *(_OWORD *)__int16 v74 = 0u;
                  long long v75 = 0u;
                  id v42 = [(__CFDictionary *)v26 objectForKey:@"certificate"];
                  if (v42 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    asString((uint64_t *)v90, v42);
                    if (BYTE8(v75))
                    {
                      if (SBYTE7(v75) < 0) {
                        operator delete(v74[0]);
                      }
                      *(_OWORD *)__int16 v74 = *(_OWORD *)v90;
                      *(void *)&long long v75 = *(void *)&v90[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v74 = *(_OWORD *)v90;
                      *(void *)&long long v75 = *(void *)&v90[16];
                      BYTE8(v75) = 1;
                    }
                  }
                  else
                  {
                    uint64_t v43 = **(NSObject ***)(a1 + 40);
                    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v44 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                      uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                      *(_DWORD *)id v90 = 136315906;
                      *(void *)&v90[4] = v44;
                      *(_WORD *)&v90[12] = 2080;
                      *(void *)&v90[14] = " ";
                      *(_WORD *)&v90[22] = 2080;
                      uint64_t v91 = v45;
                      __int16 v92 = 2080;
                      uint64_t v93 = ", ";
                      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo provisioning certificate", v90, 0x2Au);
                    }
                  }
                  *(_OWORD *)std::string __p = 0u;
                  long long v73 = 0u;
                  id v46 = [(__CFDictionary *)v26 objectForKey:@"gateway-local-id"];
                  if (v46 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    sub_100058DB0(v90, (char *)[v46 cStringUsingEncoding:4]);
                    if (BYTE8(v73))
                    {
                      if (SBYTE7(v73) < 0) {
                        operator delete(__p[0]);
                      }
                      *(_OWORD *)std::string __p = *(_OWORD *)v90;
                      *(void *)&long long v73 = *(void *)&v90[16];
                    }
                    else
                    {
                      *(_OWORD *)std::string __p = *(_OWORD *)v90;
                      *(void *)&long long v73 = *(void *)&v90[16];
                      BYTE8(v73) = 1;
                    }
                  }
                  else
                  {
                    long long v47 = **(NSObject ***)(a1 + 40);
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v48 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                      uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                      *(_DWORD *)id v90 = 136315906;
                      *(void *)&v90[4] = v48;
                      *(_WORD *)&v90[12] = 2080;
                      *(void *)&v90[14] = " ";
                      *(_WORD *)&v90[22] = 2080;
                      uint64_t v91 = v49;
                      __int16 v92 = 2080;
                      uint64_t v93 = ", ";
                      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo provisioning gateway-local-id", v90, 0x2Au);
                    }
                  }
                  *(_OWORD *)__int16 v70 = 0u;
                  long long v71 = 0u;
                  id v50 = [(__CFDictionary *)v26 objectForKey:@"ims-private-identity"];
                  if (v50 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    sub_100058DB0(v90, (char *)[v50 cStringUsingEncoding:4]);
                    if (BYTE8(v71))
                    {
                      if (SBYTE7(v71) < 0) {
                        operator delete(v70[0]);
                      }
                      *(_OWORD *)__int16 v70 = *(_OWORD *)v90;
                      *(void *)&long long v71 = *(void *)&v90[16];
                    }
                    else
                    {
                      *(_OWORD *)__int16 v70 = *(_OWORD *)v90;
                      *(void *)&long long v71 = *(void *)&v90[16];
                      BYTE8(v71) = 1;
                    }
                  }
                  else
                  {
                    int v51 = **(NSObject ***)(a1 + 40);
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v52 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                      uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                      *(_DWORD *)id v90 = 136315906;
                      *(void *)&v90[4] = v52;
                      *(_WORD *)&v90[12] = 2080;
                      *(void *)&v90[14] = " ";
                      *(_WORD *)&v90[22] = 2080;
                      uint64_t v91 = v53;
                      __int16 v92 = 2080;
                      uint64_t v93 = ", ";
                      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo ims-private-identity", v90, 0x2Au);
                    }
                  }
                  *(_OWORD *)uint64_t v68 = 0u;
                  long long v69 = 0u;
                  id v54 = [(__CFDictionary *)v26 objectForKey:@"ims-public-identity"];
                  if (v54 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    sub_100058DB0(v90, (char *)[v54 cStringUsingEncoding:4]);
                    if (BYTE8(v69))
                    {
                      if (SBYTE7(v69) < 0) {
                        operator delete(v68[0]);
                      }
                      *(_OWORD *)uint64_t v68 = *(_OWORD *)v90;
                      *(void *)&long long v69 = *(void *)&v90[16];
                    }
                    else
                    {
                      *(_OWORD *)uint64_t v68 = *(_OWORD *)v90;
                      *(void *)&long long v69 = *(void *)&v90[16];
                      BYTE8(v69) = 1;
                    }
                  }
                  else
                  {
                    unint64_t v55 = **(NSObject ***)(a1 + 40);
                    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v56 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                      uint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                      *(_DWORD *)id v90 = 136315906;
                      *(void *)&v90[4] = v56;
                      *(_WORD *)&v90[12] = 2080;
                      *(void *)&v90[14] = " ";
                      *(_WORD *)&v90[22] = 2080;
                      uint64_t v91 = v57;
                      __int16 v92 = 2080;
                      uint64_t v93 = ", ";
                      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo ims-public-identity", v90, 0x2Au);
                    }
                  }
                  sub_100179AF8(v38, (const std::string *)v74);
                  sub_100179AF8((std::string *)(v36 + 64), (const std::string *)__p);
                  sub_100179AF8((std::string *)v36 + 4, (const std::string *)v70);
                  sub_100179AF8((std::string *)(v36 + 128), (const std::string *)v68);
                  if (BYTE8(v69) && SBYTE7(v69) < 0) {
                    operator delete(v68[0]);
                  }
                  if (BYTE8(v71) && SBYTE7(v71) < 0) {
                    operator delete(v70[0]);
                  }
                  if (BYTE8(v73) && SBYTE7(v73) < 0) {
                    operator delete(__p[0]);
                  }
                  if (BYTE8(v75) && SBYTE7(v75) < 0) {
                    operator delete(v74[0]);
                  }
                  __int16 v37 = v64;
                }
                *(void *)id v90 = v37;
                *(void *)&v90[8] = v36;
                atomic_fetch_add_explicit((atomic_ullong *volatile)v36 + 1, 1uLL, memory_order_relaxed);
                LODWORD(__p[0]) = 8;
                sub_1001B0A44(v66, 8, (uint64_t **)v90);
                v74[0] = __p;
                *((_DWORD *)sub_10030B04C(v65, (int *)__p, (uint64_t)&unk_10144E20E, (unsigned int **)v74) + 8) = v29;
                if (*(void *)&v90[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&v90[8]);
                }
                sub_10004D2C8((std::__shared_weak_count *)v36);
              }
            }
          }
          else
          {
            __int16 v31 = **(NSObject ***)(a1 + 40);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v32 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
              uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
              v74[0] = 0;
              v74[1] = 0;
              *(void *)&long long v75 = 0;
              ctu::cf::assign();
              *(_OWORD *)std::string __p = *(_OWORD *)v74;
              *(void *)&long long v73 = v75;
              uint64_t v34 = (void **)v74[0];
              if ((SBYTE7(v75) & 0x80u) == 0) {
                uint64_t v34 = __p;
              }
              *(_DWORD *)id v90 = 136316162;
              *(void *)&v90[4] = v32;
              *(_WORD *)&v90[12] = 2080;
              *(void *)&v90[14] = " ";
              *(_WORD *)&v90[22] = 2080;
              uint64_t v91 = v33;
              __int16 v92 = 2080;
              uint64_t v93 = ", ";
              __int16 v94 = 2080;
              CFIndex v95 = (CFIndex)v34;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sInvalid '%s' format", v90, 0x34u);
              if (SBYTE7(v73) < 0) {
                operator delete(__p[0]);
              }
            }
          }
        }
        id v24 = [(__CFArray *)v23 countByEnumeratingWithState:&v76 objects:buf count:16];
      }
      while (v24);
    }
    if ((_BYTE)v81) {
      sub_100044D00((const void **)&theArray);
    }
    a5 = v61;
    CFArrayRef v14 = v62;
    int v5 = 6000;
  }
  else
  {
    if (a2 == 6008)
    {
      int v8 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        uint64_t v83 = v9;
        __int16 v84 = 2080;
        uint64_t v85 = " ";
        __int16 v86 = 2080;
        uint64_t v87 = v10;
        __int16 v88 = 2080;
        int v89 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smax number of devices reached", buf, 0x2Au);
      }
    }
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      uint64_t v83 = v12;
      __int16 v84 = 2080;
      uint64_t v85 = " ";
      __int16 v86 = 2080;
      uint64_t v87 = v13;
      __int16 v88 = 2080;
      int v89 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    CFArrayRef v14 = 0;
    uint64_t v66 = 0;
  }
  __int16 v58 = operator new(0x30uLL);
  uint64_t v59 = v58;
  v58[1] = 0;
  v58[2] = 0;
  *__int16 v58 = off_1019A8F88;
  uint64_t v60 = (char *)(v58 + 3);
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v58 + 6) = v5;
    v58[4] = v66;
    v58[5] = v14;
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    *a5 = v60;
    a5[1] = v59;
    sub_10004D2C8(v14);
  }
  else
  {
    *((_DWORD *)v58 + 6) = v5;
    v58[4] = v66;
    v58[5] = 0;
    *a5 = v60;
    a5[1] = v58;
  }
}

void sub_100FD47A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,const void *a59,__int16 a60,char a61,char a62)
{
  if ((_BYTE)a60) {
    sub_100044D00(&a59);
  }
  sub_10004D2C8(a11);
  _Unwind_Resume(a1);
}

void sub_100FD48F8(uint64_t a1@<X0>, uint64_t *a2@<X1>, const __CFDictionary **a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    uint64_t v52 = v11;
    __int16 v53 = 2080;
    id v54 = " ";
    __int16 v55 = 2080;
    uint64_t v56 = v12;
    __int16 v57 = 2080;
    __int16 v58 = ", ";
    __int16 v59 = 2080;
    uint64_t v60 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v15 = *a2;
  CFArrayRef v14 = (std::__shared_weak_count *)a2[1];
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v43 = v14;
  uint64_t v39 = a4;
  uint64_t v41 = v15;
  if (!v15)
  {
    id v42 = 0;
    CFDictionaryRef v18 = *a3;
    goto LABEL_10;
  }
  int v17 = *(uint64_t ***)(v15 + 8);
  uint64_t v16 = *(std::__shared_weak_count **)(v15 + 16);
  if (!v16)
  {
    id v42 = 0;
    uint64_t v44 = 0;
    CFDictionaryRef v18 = *a3;
    if (v17) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  CFDictionaryRef v18 = *a3;
  id v42 = v16;
  if (!v17)
  {
LABEL_10:
    uint64_t v19 = operator new(0x48uLL);
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_1019A8F28;
    v19[4] = 0;
    void v19[3] = v19 + 4;
    int v17 = (uint64_t **)(v19 + 3);
    unsigned char v19[8] = 0;
    v19[7] = 0;
    v19[5] = 0;
    void v19[6] = v19 + 7;
    uint64_t v44 = (std::__shared_weak_count *)v19;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v44 = v16;
LABEL_11:
  uint64_t v40 = a5;
  if (v18)
  {
    CFBooleanRef Value = (void *)CFDictionaryGetValue(v18, @"provisioning-elements");
    uint64_t v21 = Value;
    if (Value)
    {
      CFTypeID v22 = CFGetTypeID(Value);
      if (v22 == CFArrayGetTypeID())
      {
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        id v23 = [v21 countByEnumeratingWithState:&v47 objects:buf count:16];
        if (v23)
        {
          uint64_t v24 = *(void *)v48;
          int v25 = v17 + 1;
          do
          {
            for (unint64_t i = 0; i != v23; unint64_t i = (char *)i + 1)
            {
              if (*(void *)v48 != v24) {
                objc_enumerationMutation(v21);
              }
              CFDictionaryRef v27 = *(const __CFDictionary **)(*((void *)&v47 + 1) + 8 * i);
              if (v27)
              {
                CFTypeID v28 = CFGetTypeID(*(CFTypeRef *)(*((void *)&v47 + 1) + 8 * i));
                if (v28 == CFDictionaryGetTypeID())
                {
                  int v29 = sub_100FC2838(a1, v27, @"name");
                  if (v29 != -1)
                  {
                    int v30 = *v25;
                    if (!*v25) {
                      goto LABEL_32;
                    }
                    __int16 v31 = v17 + 1;
                    do
                    {
                      int v32 = *((_DWORD *)v30 + 8);
                      BOOL v33 = v32 < v29;
                      if (v32 >= v29) {
                        uint64_t v34 = v30;
                      }
                      else {
                        uint64_t v34 = v30 + 1;
                      }
                      if (!v33) {
                        __int16 v31 = (uint64_t **)v30;
                      }
                      int v30 = (uint64_t *)*v34;
                    }
                    while (*v34);
                    if (v31 == v25 || *((_DWORD *)v31 + 8) > v29)
                    {
LABEL_32:
                      uint64_t v45 = 0;
                      id v46 = 0;
                      sub_1001B0A44(v17, v29, &v45);
                      if (v46) {
                        sub_10004D2C8(v46);
                      }
                    }
                  }
                }
              }
            }
            id v23 = [v21 countByEnumeratingWithState:&v47 objects:buf count:16];
          }
          while (v23);
        }
      }
    }
  }
  if (v41)
  {
    if (v42) {
      sub_10004D2C8(v42);
    }
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    __int16 v35 = *(std::__shared_weak_count **)(v41 + 16);
    *(void *)(v41 + 8) = v17;
    *(void *)(v41 + 16) = v44;
    if (v35) {
      sub_10004D2C8(v35);
    }
    id v36 = v44;
    if (!v44)
    {
      void *v40 = v41;
      v40[1] = v43;
      return;
    }
    sub_10004D2C8(v44);
    void *v40 = v41;
    v40[1] = v43;
    goto LABEL_59;
  }
  if (v42) {
    sub_10004D2C8(v42);
  }
  if (*(unsigned char *)(v39 + 4)) {
    int v37 = *(_DWORD *)v39;
  }
  else {
    int v37 = 6005;
  }
  uint64_t v38 = operator new(0x30uLL);
  v38[1] = 0;
  v38[2] = 0;
  *uint64_t v38 = off_1019A8F88;
  if (v44)
  {
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v38 + 6) = v37;
    v38[4] = v17;
    v38[5] = v44;
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v44);
  }
  else
  {
    *((_DWORD *)v38 + 6) = v37;
    v38[4] = v17;
    v38[5] = 0;
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  void *v40 = v38 + 3;
  v40[1] = v38;
  id v36 = v44;
  if (v44) {
LABEL_59:
  }
    sub_10004D2C8(v36);
}

void sub_100FD4D7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, std::__shared_weak_count *a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD4DF0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  CFArrayRef v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      CFDictionaryRef v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      CFDictionaryRef v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    id v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    uint64_t v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        uint64_t v24 = *(int **)a5;
        id v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100198E0C(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD50E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD5154()
{
  return "setProvisioning";
}

void sub_100FD5160(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD5180(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A370;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD51D4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD5200(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD5238(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X2>, void *a4@<X8>)
{
  if (a2 != 6000)
  {
    CFTypeRef v26 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v27;
      __int16 v67 = 2080;
      uint64_t v68 = " ";
      __int16 v69 = 2080;
      uint64_t v70 = v28;
      __int16 v71 = 2080;
      uint64_t v72 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    int v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_38;
  }
  int v8 = (char *)operator new(0xB0uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)int v8 = off_101A797E0;
  *(_OWORD *)(v8 + 24) = 0u;
  uint64_t v9 = (std::string *)(v8 + 24);
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *((void *)v8 + 21) = 0;
  id v10 = [a3 objectForKey:@"address-status"];
  id v11 = [a3 objectForKey:@"tc-status"];
  uint64_t v12 = (NSNumber *)[a3 objectForKey:@"provisioning-status"];
  uint64_t v13 = [a3 objectForKey:@"address-update-url"];
  __int16 v55 = [a3 objectForKey:@"address-update-url-post-data"];
  __int16 v57 = [a3 objectForKey:@"address-ref-id"];
  uint64_t v56 = [a3 objectForKey:@"address-ref-id-expiry"];
  if (!v10 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v32 = **(NSObject ***)(a1 + 40);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_46;
    }
    uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v33;
    __int16 v67 = 2080;
    uint64_t v68 = " ";
    __int16 v69 = 2080;
    uint64_t v70 = v34;
    __int16 v71 = 2080;
    uint64_t v72 = ", ";
    __int16 v35 = "#W %s%s%s%sInvalid Response: no address status";
LABEL_45:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v35, buf, 0x2Au);
    goto LABEL_46;
  }
  if (!v11 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    uint64_t v32 = **(NSObject ***)(a1 + 40);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_46;
    }
    uint64_t v36 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v36;
    __int16 v67 = 2080;
    uint64_t v68 = " ";
    __int16 v69 = 2080;
    uint64_t v70 = v37;
    __int16 v71 = 2080;
    uint64_t v72 = ", ";
    __int16 v35 = "#W %s%s%s%sInvalid Response: no TC status";
    goto LABEL_45;
  }
  if (!v12 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    CFArrayRef v14 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v54 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v54;
      __int16 v67 = 2080;
      uint64_t v68 = " ";
      __int16 v69 = 2080;
      uint64_t v70 = v15;
      __int16 v71 = 2080;
      uint64_t v72 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sprovisioning-status not present - assume NotRequired", buf, 0x2Au);
    }
    uint64_t v12 = +[NSNumber numberWithInt:2];
  }
  unsigned int v16 = [v10 intValue];
  unsigned int v17 = [v11 intValue];
  unsigned int v18 = [(NSNumber *)v12 intValue];
  uint64_t v19 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v53 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    unsigned int v64 = v16;
    sub_100C90F88(&v64, &v65);
    unsigned int v50 = v17;
    unsigned int v51 = v16;
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v20 = &v65;
    }
    else {
      uint64_t v20 = (std::string *)v65.__r_.__value_.__r.__words[0];
    }
    long long v49 = v20;
    unsigned int v61 = v17;
    sub_100C910FC(&v61, v62);
    int v21 = v63;
    uint64_t v22 = (void **)v62[0];
    unsigned int v58 = v18;
    sub_100C91270(&v58, __p);
    id v23 = v62;
    if (v21 < 0) {
      id v23 = v22;
    }
    uint64_t v24 = __p;
    if (v60 < 0) {
      uint64_t v24 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136317442;
    *(void *)&uint8_t buf[4] = v53;
    __int16 v67 = 2080;
    uint64_t v68 = " ";
    __int16 v69 = 2080;
    uint64_t v70 = v52;
    __int16 v71 = 2080;
    uint64_t v72 = ", ";
    __int16 v73 = 1024;
    unsigned int v17 = v50;
    unsigned int v16 = v51;
    unsigned int v74 = v51;
    __int16 v75 = 2080;
    long long v76 = v49;
    __int16 v77 = 1024;
    unsigned int v78 = v50;
    __int16 v79 = 2080;
    uint64_t v80 = v23;
    __int16 v81 = 1024;
    unsigned int v82 = v18;
    __int16 v83 = 2080;
    __int16 v84 = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived address Status of: (%d) %s, TC status: (%d) %s, Provisioning status: (%d) %s", buf, 0x5Au);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
    if (v63 < 0) {
      operator delete(v62[0]);
    }
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
  }
  if (v16 >= 4)
  {
    uint64_t v38 = **(NSObject ***)(a1 + 40);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    uint64_t v39 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v40 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v39;
    __int16 v67 = 2080;
    uint64_t v68 = " ";
    __int16 v69 = 2080;
    uint64_t v70 = v40;
    __int16 v71 = 2080;
    uint64_t v72 = ", ";
    __int16 v73 = 1024;
    unsigned int v74 = v16;
    uint64_t v41 = "#E %s%s%s%sInvalid emergency address status (%d)";
LABEL_54:
    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v41, buf, 0x30u);
    goto LABEL_46;
  }
  if (v17 >= 4)
  {
    uint64_t v38 = **(NSObject ***)(a1 + 40);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v42;
    __int16 v67 = 2080;
    uint64_t v68 = " ";
    __int16 v69 = 2080;
    uint64_t v70 = v43;
    __int16 v71 = 2080;
    uint64_t v72 = ", ";
    __int16 v73 = 1024;
    unsigned int v74 = v17;
    uint64_t v41 = "#E %s%s%s%sInvalid TC status (%d)";
    goto LABEL_54;
  }
  if (v18 >= 5)
  {
    uint64_t v38 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v44;
      __int16 v67 = 2080;
      uint64_t v68 = " ";
      __int16 v69 = 2080;
      uint64_t v70 = v45;
      __int16 v71 = 2080;
      uint64_t v72 = ", ";
      __int16 v73 = 1024;
      unsigned int v74 = v18;
      uint64_t v41 = "#E %s%s%s%sInvalid Provisioining status (%d)";
      goto LABEL_54;
    }
LABEL_46:
    sub_10004D2C8((std::__shared_weak_count *)v8);
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  *((_DWORD *)v8 + 22) = v16;
  v8[92] = 1;
  *((_DWORD *)v8 + 24) = v17;
  v8[100] = 1;
  *((_DWORD *)v8 + 26) = v18;
  v8[108] = 1;
  if (v13)
  {
    memset(&v65, 0, sizeof(v65));
    asString((uint64_t *)&v65, v13);
    std::string::size_type size = HIBYTE(v65.__r_.__value_.__r.__words[2]);
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v65.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      sub_100093B44(v9, &v65);
      if (v55)
      {
        asString((uint64_t *)buf, v55);
        sub_10008BE4C((uint64_t)(v8 + 56), (long long *)buf);
        if (SHIBYTE(v69) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    else
    {
      id v46 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v47 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v48 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)int buf = 136315906;
        *(void *)&uint8_t buf[4] = v47;
        __int16 v67 = 2080;
        uint64_t v68 = " ";
        __int16 v69 = 2080;
        uint64_t v70 = v48;
        __int16 v71 = 2080;
        uint64_t v72 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sIgnore address-update-url since it is empty", buf, 0x2Au);
      }
    }
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
  }
  if (v57)
  {
    asString((uint64_t *)buf, v57);
    sub_10008BE4C((uint64_t)(v8 + 112), (long long *)buf);
    if (SHIBYTE(v69) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v56)
  {
    asString((uint64_t *)buf, v56);
    sub_10008BE4C((uint64_t)(v8 + 144), (long long *)buf);
    if (SHIBYTE(v69) < 0) {
      operator delete(*(void **)buf);
    }
  }
LABEL_38:
  CFTypeRef v29 = operator new(0x30uLL);
  int v30 = v29;
  v29[1] = 0;
  v29[2] = 0;
  *CFTypeRef v29 = off_101A7A448;
  __int16 v31 = (char *)(v29 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v9;
    v29[5] = v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v8);
    *a4 = v31;
    a4[1] = v30;
    sub_10004D2C8((std::__shared_weak_count *)v8);
  }
  else
  {
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v9;
    v29[5] = 0;
    *a4 = v31;
    a4[1] = v29;
  }
}

void sub_100FD5CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v40);
  _Unwind_Resume(a1);
}

void sub_100FD5DC8(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    uint64_t v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A448;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  CFArrayRef v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    uint64_t v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  unsigned int v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD5FF8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD6010(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  CFArrayRef v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    uint64_t v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1001990C8(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD6304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD6374()
{
  return "getPhoneServicesAccountStatus";
}

void sub_100FD6380(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A448;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD63A0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A448;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD63F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD6408(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A498;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD6428(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A498;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD647C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD64A8(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD64E0(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    unint64_t v6 = (std::__shared_weak_count *)operator new(0x30uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A79830;
    v6[1].__shared_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1].__shared_owners_;
    unint64_t v7 = (uint64_t **)&v6[1];
    v6[1].__shared_weak_owners_ = 0;
    CFArrayRef theArray = 0;
    uint64_t v39 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
    sub_100FC3AEC((const void **)&theArray, Value);
    if ((_BYTE)v39)
    {
      uint64_t v9 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        CFIndex Count = CFArrayGetCount(theArray);
        *(_DWORD *)int buf = 136316162;
        uint64_t v49 = v10;
        __int16 v50 = 2080;
        unsigned int v51 = " ";
        __int16 v52 = 2080;
        uint64_t v53 = v11;
        __int16 v54 = 2080;
        __int16 v55 = ", ";
        __int16 v56 = 2048;
        CFIndex v57 = Count;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sThere are %lu notification-responses", buf, 0x34u);
      }
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      CFArrayRef v13 = theArray;
      id v14 = [(__CFArray *)theArray countByEnumeratingWithState:&v34 objects:buf count:16];
      if (v14)
      {
        uint64_t v15 = *(void *)v35;
        while (2)
        {
          for (unint64_t i = 0; i != v14; unint64_t i = (char *)i + 1)
          {
            if (*(void *)v35 != v15) {
              objc_enumerationMutation(v13);
            }
            CFDictionaryRef v17 = *(const __CFDictionary **)(*((void *)&v34 + 1) + 8 * i);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              CFTypeRef v26 = **(NSObject ***)(a1 + 40);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                *(_DWORD *)uint64_t v40 = 136315906;
                uint64_t v41 = v27;
                __int16 v42 = 2080;
                uint64_t v43 = " ";
                __int16 v44 = 2080;
                uint64_t v45 = v28;
                __int16 v46 = 2080;
                uint64_t v47 = ", ";
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sInvalid item format, expected dictionary", v40, 0x2Au);
              }
              unint64_t v7 = 0;
              int v21 = 0;
              goto LABEL_25;
            }
            int v18 = sub_100FC3304(a1, v17);
            *(_DWORD *)uint64_t v40 = v18;
            if (v18)
            {
              unsigned int v19 = sub_100FC2C68(a1, v17, @"notification-status") - 6100;
              if (v19 > 6) {
                int v20 = 3;
              }
              else {
                int v20 = dword_1015A7B24[v19];
              }
              *((_DWORD *)sub_1005BD92C(v7, v18, v40) + 8) = v20;
            }
          }
          id v14 = [(__CFArray *)v13 countByEnumeratingWithState:&v34 objects:buf count:16];
          if (v14) {
            continue;
          }
          break;
        }
      }
      int v21 = v6;
      unint64_t v6 = 0;
LABEL_25:
      if ((_BYTE)v39) {
        sub_100044D00((const void **)&theArray);
      }
      if (!v6)
      {
        if (v7)
        {
LABEL_29:
          int v25 = v21;
          goto LABEL_30;
        }
LABEL_38:
        *a4 = 0;
        a4[1] = 0;
        int v25 = v21;
        if (!v21) {
          return;
        }
        goto LABEL_34;
      }
    }
    else
    {
      unint64_t v7 = 0;
      int v21 = 0;
    }
    sub_10004D2C8(v6);
    if (v7) {
      goto LABEL_29;
    }
    goto LABEL_38;
  }
  uint64_t v22 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    uint64_t v49 = v23;
    __int16 v50 = 2080;
    unsigned int v51 = " ";
    __int16 v52 = 2080;
    uint64_t v53 = v24;
    __int16 v54 = 2080;
    __int16 v55 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  int v25 = 0;
  unint64_t v7 = 0;
LABEL_30:
  CFTypeRef v29 = operator new(0x30uLL);
  __int16 v30 = v29;
  v29[1] = 0;
  v29[2] = 0;
  *CFTypeRef v29 = off_101A7A540;
  __int16 v31 = (char *)(v29 + 3);
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v7;
    v29[5] = v25;
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v25);
  }
  else
  {
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v7;
    v29[5] = 0;
  }
  *a4 = v31;
  a4[1] = v30;
  if (v25) {
LABEL_34:
  }
    sub_10004D2C8(v25);
}

void sub_100FD69DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, char a20)
{
  if (a20) {
    sub_100044D00(&a19);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100FD6A30(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  CFArrayRef v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    unsigned int v19 = operator new(0x30uLL);
    int v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A540;
    *((_DWORD *)v19 + 6) = v21;
    CFArrayRef v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    int v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD6C60(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD6C78(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  unsigned int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    int v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100199384(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD6F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD6FDC()
{
  return "enablePushNotification";
}

void sub_100FD6FE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A540;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD7008(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A540;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD705C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD7070(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A590;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD7090(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A590;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD70E4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD7110(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD7148(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    unint64_t v6 = (std::__shared_weak_count *)operator new(0x30uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A79880;
    v6[1].__shared_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1].__shared_owners_;
    unint64_t v7 = (uint64_t **)&v6[1];
    v6[1].__shared_weak_owners_ = 0;
    CFArrayRef theArray = 0;
    uint64_t v39 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
    sub_100FC3AEC((const void **)&theArray, Value);
    if ((_BYTE)v39)
    {
      uint64_t v9 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        CFIndex Count = CFArrayGetCount(theArray);
        *(_DWORD *)int buf = 136316162;
        uint64_t v49 = v10;
        __int16 v50 = 2080;
        unsigned int v51 = " ";
        __int16 v52 = 2080;
        uint64_t v53 = v11;
        __int16 v54 = 2080;
        __int16 v55 = ", ";
        __int16 v56 = 2048;
        CFIndex v57 = Count;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sThere are %lu notification-responses", buf, 0x34u);
      }
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      CFArrayRef v13 = theArray;
      id v14 = [(__CFArray *)theArray countByEnumeratingWithState:&v34 objects:buf count:16];
      if (v14)
      {
        uint64_t v15 = *(void *)v35;
        while (2)
        {
          for (unint64_t i = 0; i != v14; unint64_t i = (char *)i + 1)
          {
            if (*(void *)v35 != v15) {
              objc_enumerationMutation(v13);
            }
            CFDictionaryRef v17 = *(const __CFDictionary **)(*((void *)&v34 + 1) + 8 * i);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              CFTypeRef v26 = **(NSObject ***)(a1 + 40);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                *(_DWORD *)uint64_t v40 = 136315906;
                uint64_t v41 = v27;
                __int16 v42 = 2080;
                uint64_t v43 = " ";
                __int16 v44 = 2080;
                uint64_t v45 = v28;
                __int16 v46 = 2080;
                uint64_t v47 = ", ";
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sInvalid item format, expected dictionary", v40, 0x2Au);
              }
              unint64_t v7 = 0;
              int v21 = 0;
              goto LABEL_25;
            }
            int v18 = sub_100FC3304(a1, v17);
            *(_DWORD *)uint64_t v40 = v18;
            if (v18)
            {
              unsigned int v19 = sub_100FC2C68(a1, v17, @"notification-status") - 6100;
              if (v19 > 6) {
                int v20 = 3;
              }
              else {
                int v20 = dword_1015A7B24[v19];
              }
              *((_DWORD *)sub_1005BD92C(v7, v18, v40) + 8) = v20;
            }
          }
          id v14 = [(__CFArray *)v13 countByEnumeratingWithState:&v34 objects:buf count:16];
          if (v14) {
            continue;
          }
          break;
        }
      }
      int v21 = v6;
      unint64_t v6 = 0;
LABEL_25:
      if ((_BYTE)v39) {
        sub_100044D00((const void **)&theArray);
      }
      if (!v6)
      {
        if (v7)
        {
LABEL_29:
          int v25 = v21;
          goto LABEL_30;
        }
LABEL_38:
        *a4 = 0;
        a4[1] = 0;
        int v25 = v21;
        if (!v21) {
          return;
        }
        goto LABEL_34;
      }
    }
    else
    {
      unint64_t v7 = 0;
      int v21 = 0;
    }
    sub_10004D2C8(v6);
    if (v7) {
      goto LABEL_29;
    }
    goto LABEL_38;
  }
  uint64_t v22 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    uint64_t v49 = v23;
    __int16 v50 = 2080;
    unsigned int v51 = " ";
    __int16 v52 = 2080;
    uint64_t v53 = v24;
    __int16 v54 = 2080;
    __int16 v55 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  int v25 = 0;
  unint64_t v7 = 0;
LABEL_30:
  CFTypeRef v29 = operator new(0x30uLL);
  __int16 v30 = v29;
  v29[1] = 0;
  v29[2] = 0;
  *CFTypeRef v29 = off_101A7A638;
  __int16 v31 = (char *)(v29 + 3);
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v7;
    v29[5] = v25;
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v25);
  }
  else
  {
    *((_DWORD *)v29 + 6) = a2;
    v29[4] = v7;
    v29[5] = 0;
  }
  *a4 = v31;
  a4[1] = v30;
  if (v25) {
LABEL_34:
  }
    sub_10004D2C8(v25);
}

void sub_100FD7644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, char a20)
{
  if (a20) {
    sub_100044D00(&a19);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100FD7698(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  CFArrayRef v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    unsigned int v19 = operator new(0x30uLL);
    int v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A638;
    *((_DWORD *)v19 + 6) = v21;
    CFArrayRef v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    int v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD78C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD78E0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  unsigned int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    int v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100199640(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD7BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD7C44()
{
  return "disablePushNotification";
}

void sub_100FD7C50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A638;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD7C70(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A638;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD7CC4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD7CD8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A688;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD7CF8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A688;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD7D4C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD7D78(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD7DB0(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    unint64_t v7 = (std::__shared_weak_count *)operator new(0x30uLL);
    v7->__shared_owners_ = 0;
    v7->__shared_weak_owners_ = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)off_101A799F0;
    v7[1].__shared_owners_ = 0;
    p_shared_owners = &v7[1].__shared_owners_;
    __int16 v35 = v7;
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)&v7[1].__shared_owners_;
    int v8 = v7 + 1;
    v7[1].__shared_weak_owners_ = 0;
    __int16 v44 = 0;
    uint64_t v45 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"command-payloads");
    sub_100FC3AEC((const void **)&v44, Value);
    if (!(_BYTE)v45) {
      goto LABEL_40;
    }
    __int16 v33 = v8;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v10 = v44;
    id v11 = [v44 countByEnumeratingWithState:&v40 objects:buf count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v41;
      do
      {
        CFArrayRef v13 = 0;
        do
        {
          if (*(void *)v41 != v12) {
            objc_enumerationMutation(v10);
          }
          id v14 = *(void **)(*((void *)&v40 + 1) + 8 * (void)v13);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            id v15 = [v14 objectForKey:@"command"];
            if (v15)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                id v16 = [v14 objectForKey:@"payload"];
                if (v16)
                {
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    sub_100058DB0(&__p, (char *)[v15 cStringUsingEncoding:4]);
                    unsigned int v17 = sub_100C8DDD4((unint64_t *)&__p);
                    if (SHIBYTE(v39) < 0) {
                      operator delete(__p);
                    }
                    if (v17 != 4)
                    {
                      sub_100058DB0(&__p, (char *)[v16 cStringUsingEncoding:4]);
                      long long v36 = __p;
                      int v18 = (char **)p_shared_owners;
                      v46[0] = v39;
                      *(void *)((char *)v46 + 7) = *(void *)((char *)&v39 + 7);
                      int v37 = SHIBYTE(v39);
                      std::string __p = 0;
                      long long v39 = 0uLL;
                      while (1)
                      {
                        unsigned int v19 = *v18;
                        int v20 = v18;
                        if (!*v18) {
                          break;
                        }
                        while (1)
                        {
                          int v18 = (char **)v19;
                          unsigned int v21 = v19[32];
                          if (v21 > v17) {
                            break;
                          }
                          if (v21 >= v17)
                          {
                            if (v37 < 0) {
                              operator delete(v36);
                            }
                            goto LABEL_25;
                          }
                          unsigned int v19 = v18[1];
                          if (!v19)
                          {
                            int v20 = v18 + 1;
                            goto LABEL_22;
                          }
                        }
                      }
LABEL_22:
                      uint64_t v22 = (char *)operator new(0x40uLL);
                      v22[32] = v17;
                      uint64_t v23 = v46[0];
                      *((void *)v22 + 5) = v36;
                      *((void *)v22 + 6) = v23;
                      *(void *)(v22 + 55) = *(void *)((char *)v46 + 7);
                      v22[63] = v37;
                      v46[0] = 0;
                      *(void *)((char *)v46 + 7) = 0;
                      *(void *)uint64_t v22 = 0;
                      *((void *)v22 + 1) = 0;
                      *((void *)v22 + 2) = v18;
                      std::__shared_weak_count *v20 = v22;
                      __int16 v24 = v33->~__shared_weak_count;
                      if (v24)
                      {
                        v33->__vftable = (std::__shared_weak_count_vtbl *)v24;
                        uint64_t v22 = *v20;
                      }
                      sub_100046C90((uint64_t *)v35[1].__shared_owners_, (uint64_t *)v22);
                      ++v35[1].__shared_weak_owners_;
LABEL_25:
                      if (SHIBYTE(v39) < 0) {
                        operator delete(__p);
                      }
                    }
                  }
                }
              }
            }
          }
          CFArrayRef v13 = (char *)v13 + 1;
        }
        while (v13 != v11);
        id v25 = [v10 countByEnumeratingWithState:&v40 objects:buf count:16];
        id v11 = v25;
      }
      while (v25);
    }
    uint64_t shared_weak_owners = v35[1].__shared_weak_owners_;
    if ((_BYTE)v45) {
      sub_100044D00((const void **)&v44);
    }
    uint64_t v27 = v33;
    if (!shared_weak_owners)
    {
LABEL_40:
      sub_10004D2C8(v35);
      __int16 v35 = 0;
LABEL_48:
      *a4 = 0;
      a4[1] = 0;
      goto LABEL_45;
    }
    if (!v33) {
      goto LABEL_48;
    }
  }
  else
  {
    CFTypeRef v29 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      uint64_t v48 = v30;
      __int16 v49 = 2080;
      __int16 v50 = " ";
      __int16 v51 = 2080;
      uint64_t v52 = v31;
      __int16 v53 = 2080;
      __int16 v54 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    __int16 v35 = 0;
    uint64_t v27 = 0;
  }
  uint64_t v32 = operator new(0x30uLL);
  v32[1] = 0;
  v32[2] = 0;
  void *v32 = off_101A7A760;
  if (v35)
  {
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v32 + 6) = a2;
    void v32[4] = v27;
    v32[5] = v35;
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v35);
  }
  else
  {
    *((_DWORD *)v32 + 6) = a2;
    void v32[4] = v27;
    v32[5] = 0;
  }
  *a4 = v32 + 3;
  a4[1] = v32;
LABEL_45:
  if (v35) {
    sub_10004D2C8(v35);
  }
}

void sub_100FD8280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, int a17, int a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,const void *a33,__int16 a34,char a35,char a36)
{
  if ((_BYTE)a34) {
    sub_100044D00(&a33);
  }
  sub_10004D2C8(a15);
  _Unwind_Resume(a1);
}

void sub_100FD82FC(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    id v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  CFArrayRef v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    unsigned int v19 = operator new(0x30uLL);
    int v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A760;
    *((_DWORD *)v19 + 6) = v21;
    CFArrayRef v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    int v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  id v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD852C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD8544(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  unsigned int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    int v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1001998FC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD8838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD88A8()
{
  return "getVVMAccountStatus";
}

void sub_100FD88B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A760;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD88D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A760;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD8928(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD893C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A7B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD895C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A7B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD89B0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD89DC(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD8A14(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  if (a2 == 6000)
  {
    int v8 = (char *)operator new(0x40uLL);
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *(void *)int v8 = off_101A79C70;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *((void *)v8 + 7) = 0;
    CFBooleanRef Value = (void *)CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
    unint64_t v10 = sub_100FC2DC4(a1, Value, *(void **)(a1 + 48));
    if (v8[28] == BYTE4(v10))
    {
      if (v8[28]) {
        *((_DWORD *)v8 + 6) = v10;
      }
    }
    else if (v8[28])
    {
      v8[28] = 0;
    }
    else
    {
      *((_DWORD *)v8 + 6) = v10;
      v8[28] = 1;
    }
    unsigned int v58 = 0;
    uint64_t v59 = 0;
    uint64_t v15 = CFDictionaryGetValue(a3, *(const void **)(a1 + 56));
    sub_100FC3AEC((const void **)&v58, v15);
    __int16 v46 = v8;
    uint64_t v45 = a4;
    __int16 v44 = v8 + 24;
    if ((_BYTE)v59)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v48 = (uint64_t *)(v8 + 32);
      sub_100C90A38((uint64_t)(v8 + 32), (uint64_t)buf);
      *(void *)char v60 = buf;
      sub_100C9274C((void ***)v60);
      *(_OWORD *)__int16 v54 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      uint64_t v16 = v58;
      int v17 = (char *)[v58 countByEnumeratingWithState:v54 objects:buf count:16];
      if (v17)
      {
        uint64_t v18 = *(void *)v55;
        unsigned int v19 = v61;
        int v20 = v62;
        int v21 = v64;
        do
        {
          uint64_t v22 = 0;
          uint64_t v47 = v17;
          do
          {
            if (*(void *)v55 != v18) {
              objc_enumerationMutation(v16);
            }
            CFDictionaryRef v23 = (const __CFDictionary *)*((void *)v54[1] + (void)v22);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              *(_OWORD *)unsigned int v64 = 0u;
              long long v65 = 0u;
              *(_OWORD *)int64x2_t v62 = 0u;
              long long v63 = 0u;
              memset(v61, 0, sizeof(v61));
              memset(v60, 0, sizeof(v60));
              __int16 v24 = CFDictionaryGetValue(v23, *(const void **)(a1 + 64));
              sub_100FC2A7C(__p, a1, v24, *(void **)(a1 + 64));
              sub_100179CB0((uint64_t)v60, (__n128 *)__p);
              if (v53 && SHIBYTE(v52) < 0) {
                operator delete(__p[0]);
              }
              int v25 = CFDictionaryGetValue(v23, *(const void **)(a1 + 72));
              sub_100FC2A7C(__p, a1, v25, *(void **)(a1 + 72));
              sub_100179CB0((uint64_t)v19, (__n128 *)__p);
              if (v53 && SHIBYTE(v52) < 0) {
                operator delete(__p[0]);
              }
              CFTypeRef v26 = CFDictionaryGetValue(v23, *(const void **)(a1 + 88));
              sub_100FC2A7C(__p, a1, v26, *(void **)(a1 + 88));
              sub_100179CB0((uint64_t)v20, (__n128 *)__p);
              if (v53 && SHIBYTE(v52) < 0) {
                operator delete(__p[0]);
              }
              uint64_t v27 = CFDictionaryGetValue(v23, *(const void **)(a1 + 80));
              sub_100FC2A7C(__p, a1, v27, *(void **)(a1 + 80));
              sub_100179CB0((uint64_t)v21, (__n128 *)__p);
              if (v53 && SHIBYTE(v52) < 0) {
                operator delete(__p[0]);
              }
              sub_100C90AB4(v48, (long long *)v60);
              if (BYTE8(v65) && SBYTE7(v65) < 0) {
                operator delete(v64[0]);
              }
              if (BYTE8(v63) && SBYTE7(v63) < 0) {
                operator delete(v62[0]);
              }
              if (LOBYTE(v61[3]) && SHIBYTE(v61[2]) < 0) {
                operator delete(v61[0]);
              }
              if (v60[24] && (char)v60[23] < 0) {
                operator delete(*(void **)v60);
              }
            }
            else
            {
              CFTypeRef v28 = **(NSObject ***)(a1 + 40);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v29 = v18;
                __int16 v30 = v21;
                __int16 v31 = v16;
                uint64_t v32 = v20;
                __int16 v33 = v19;
                uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
                uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
                __p[0] = 0;
                __p[1] = 0;
                uint64_t v52 = 0;
                ctu::cf::assign();
                *(_OWORD *)__int16 v49 = *(_OWORD *)__p;
                uint64_t v50 = v52;
                long long v36 = (void **)__p[0];
                if (v52 >= 0) {
                  long long v36 = v49;
                }
                *(_DWORD *)char v60 = 136316162;
                *(void *)&v60[4] = v34;
                *(_WORD *)&v60[12] = 2080;
                *(void *)&v60[14] = " ";
                *(_WORD *)&v60[22] = 2080;
                *(void *)&v60[24] = v35;
                LOWORD(v61[0]) = 2080;
                *(void **)((char *)v61 + 2) = ", ";
                WORD1(v61[1]) = 2080;
                *(void **)((char *)&v61[1] + 4) = v36;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%s'%s' has element of incorrect type", v60, 0x34u);
                if (SHIBYTE(v50) < 0) {
                  operator delete(v49[0]);
                }
                unsigned int v19 = v33;
                int v20 = v32;
                uint64_t v16 = v31;
                int v21 = v30;
                uint64_t v18 = v29;
                int v8 = v46;
                int v17 = v47;
              }
            }
            ++v22;
          }
          while (v17 != v22);
          int v17 = (char *)[v16 countByEnumeratingWithState:v54 objects:buf count:16];
        }
        while (v17);
      }
    }
    else
    {
      __int16 v37 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        memset(v60, 0, 24);
        ctu::cf::assign();
        *(_OWORD *)__int16 v54 = *(_OWORD *)v60;
        *(void *)&long long v55 = *(void *)&v60[16];
        long long v40 = v54;
        if ((v60[23] & 0x80u) != 0) {
          long long v40 = *(void ***)v60;
        }
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v67 = v39;
        __int16 v68 = 2080;
        __int16 v69 = ", ";
        __int16 v70 = 2080;
        __int16 v71 = v40;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sresponse is missing element '%s' - treated as empty", buf, 0x34u);
        if (SBYTE7(v55) < 0) {
          operator delete(v54[0]);
        }
        int v8 = v46;
      }
    }
    if ((_BYTE)v59) {
      sub_100044D00((const void **)&v58);
    }
    a4 = v45;
    int v4 = 6000;
    id v14 = v44;
  }
  else
  {
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v67 = v13;
      __int16 v68 = 2080;
      __int16 v69 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    int v8 = 0;
    id v14 = 0;
  }
  long long v41 = operator new(0x30uLL);
  long long v42 = v41;
  v41[1] = 0;
  v41[2] = 0;
  *long long v41 = off_101A7A858;
  long long v43 = (char *)(v41 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v41 + 6) = v4;
    v41[4] = v14;
    v41[5] = v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v8);
    sub_10004D2C8((std::__shared_weak_count *)v8);
  }
  else
  {
    *((_DWORD *)v41 + 6) = v4;
    v41[4] = v14;
    v41[5] = 0;
  }
  *a4 = v43;
  a4[1] = v42;
}

void sub_100FD9164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,const void *a38,__int16 a39,char a40,char a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  if ((_BYTE)a39) {
    sub_100044D00(&a38);
  }
  sub_10004D2C8(a16);
  _Unwind_Resume(a1);
}

void sub_100FD9234(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    uint64_t v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    unsigned int v19 = operator new(0x30uLL);
    int v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7A858;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    int v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FD9464(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD947C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  unsigned int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    int v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100199BB8(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FD9770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FD97E0()
{
  return "getPhoneServiceDeviceList";
}

void sub_100FD97EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD980C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A858;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FD9860(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FD9874(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A8A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FD9894(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A8A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FD98E8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FD9914(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FD994C(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  int v15 = a2;
  uint64_t v13 = 0;
  id v14 = 0;
  if (a2 == 6000 || a2 == 6012)
  {
    unint64_t v7 = (std::__shared_weak_count *)operator new(0x20uLL);
    v7->__shared_owners_ = 0;
    v7->__shared_weak_owners_ = 0;
    v7[1].__vftable = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
    CFDictionaryRemoveValue(MutableCopy, @"status");
    sub_10004EFE4(&v16, (CFTypeRef *)&MutableCopy);
    *(void *)int buf = v7[1].__vftable;
    v7[1].__vftable = v16;
    uint64_t v16 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v16);
    sub_10005717C((const void **)&MutableCopy);
    uint64_t v13 = v7 + 1;
    id v14 = v7;
  }
  else
  {
    uint64_t v9 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v19 = 2080;
      uint64_t v20 = v12;
      __int16 v21 = 2080;
      uint64_t v22 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
  }
  sub_1003B1590(&v15, (uint64_t *)&v13, buf);
  *a4 = *(_OWORD *)buf;
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100FD9B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10005717C((const void **)va);
  sub_10004D2C8(v6);
  _Unwind_Resume(a1);
}

void sub_100FD9B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (!a11) {
    JUMPOUT(0x100FD9B58);
  }
  JUMPOUT(0x100FD9B54);
}

void sub_100FD9B70(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    id v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)int buf = v15;
      *(void *)&uint8_t buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)int buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100625330(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    id v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FD9DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FD9DD0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      __int16 v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_100199E74(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDA0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDA134()
{
  return "getCarrierSpaceUpdates";
}

void sub_100FDA140(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDA160(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7A980;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDA1B4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDA1E0(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDA218(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  int v13 = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (a2 == 6000)
  {
    unint64_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
    CFDictionaryRemoveValue(MutableCopy, @"status");
    sub_10004EFE4(&v14, (CFTypeRef *)&MutableCopy);
    *(void *)int buf = v6[1].__vftable;
    v6[1].__vftable = v14;
    id v14 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v14);
    sub_10005717C((const void **)&MutableCopy);
    uint64_t v11 = v6 + 1;
    uint64_t v12 = v6;
  }
  else
  {
    int v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v17 = 2080;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      long long v20 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
  }
  sub_1003B1590(&v13, (uint64_t *)&v11, buf);
  *a4 = *(_OWORD *)buf;
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100FDA3FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10005717C((const void **)va);
  sub_10004D2C8(v6);
  _Unwind_Resume(a1);
}

void sub_100FDA434(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  int v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    id v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)int buf = v15;
      *(void *)&uint8_t buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)int buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100625330(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    id v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FDA670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDA694(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      __int16 v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019A130(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDA988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDA9F8()
{
  return "updateAccountWithFeatureOrService";
}

void sub_100FDAA04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AA58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDAA24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AA58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDAA78(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDAAA4(uint64_t a1)
{
  sub_100FC3E44(a1);

  operator delete();
}

void sub_100FDAADC(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    sub_100FC3EA8((uint64_t *)v15, a1, a3);
    uint64_t v8 = *(void *)v15;
    unint64_t v7 = *(std::__shared_weak_count **)&v15[8];
    if (!*(void *)v15)
    {
      *a4 = 0;
      a4[1] = 0;
      if (!v7) {
        return;
      }
LABEL_12:
      sub_10004D2C8(v7);
      return;
    }
  }
  else
  {
    uint64_t v9 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)uint64_t v15 = 136315906;
      *(void *)&v15[4] = v10;
      *(_WORD *)&v15[12] = 2080;
      *(void *)&v15[14] = " ";
      __int16 v16 = 2080;
      uint64_t v17 = v11;
      __int16 v18 = 2080;
      int v19 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", v15, 0x2Au);
    }
    unint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  uint64_t v12 = operator new(0x30uLL);
  uint64_t v13 = v12;
  v12[1] = 0;
  int v12[2] = 0;
  void *v12 = off_101A7AB00;
  id v14 = (char *)(v12 + 3);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v12 + 6) = a2;
    void v12[4] = v8;
    void v12[5] = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v7);
  }
  else
  {
    *((_DWORD *)v12 + 6) = a2;
    void v12[4] = v8;
    void v12[5] = 0;
  }
  *a4 = v14;
  a4[1] = v13;
  if (v7) {
    goto LABEL_12;
  }
}

void sub_100FDAC9C(_Unwind_Exception *exception_object)
{
}

void sub_100FDACBC(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    int v19 = operator new(0x30uLL);
    long long v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7AB00;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    long long v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  __int16 v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FDAEEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDAF04(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019A3EC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDB1F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDB268()
{
  return "getSubscriptionAndUsageStatus";
}

void sub_100FDB274(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AB00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDB294(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AB00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FDB2E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FDB2FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AB50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDB31C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AB50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDB370(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDB39C(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDB3D4(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 == 6000)
  {
    int v5 = (std::__shared_weak_count *)operator new(0x20uLL);
    v5->__shared_owners_ = 0;
    v5->__shared_weak_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
    LOBYTE(v5[1].__vftable) = 1;
    unint64_t v6 = v5 + 1;
  }
  else
  {
    uint64_t v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v14 = 136315906;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      int v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v10;
      __int16 v20 = 2080;
      int v21 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", (uint8_t *)&v14, 0x2Au);
    }
    int v5 = 0;
    unint64_t v6 = 0;
  }
  uint64_t v11 = operator new(0x30uLL);
  uint64_t v12 = v11;
  v11[1] = 0;
  v11[2] = 0;
  void *v11 = off_101A7AC28;
  uint64_t v13 = (char *)(v11 + 3);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v11 + 6) = a2;
    v11[4] = v6;
    v11[5] = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
    sub_10004D2C8(v5);
  }
  else
  {
    *((_DWORD *)v11 + 6) = a2;
    v11[4] = v6;
    v11[5] = 0;
  }
  *a3 = v13;
  a3[1] = v12;
}

void sub_100FDB5AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDB5C4(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7AC28;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  int v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  __int16 v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FDB7F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDB80C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  int v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019A6A8(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDBB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDBB70()
{
  return "updatePushToken";
}

void sub_100FDBB7C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AC28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDBB9C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AC28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FDBBF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FDBC04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AC78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDBC24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AC78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDBC78(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDBCA4(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDBCDC(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, const __CFDictionary *a4@<X3>, void *a5@<X8>)
{
  if (a2 != 6000)
  {
    __int16 v20 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v48 = (uint8_t *)v22;
      __int16 v49 = 2080;
      uint64_t v50 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v23 = 0;
    uint64_t v11 = 0;
LABEL_52:
    __int16 v37 = operator new(0x30uLL);
    uint64_t v38 = v37;
    v37[1] = 0;
    v37[2] = 0;
    *__int16 v37 = off_101A7AD50;
    uint64_t v39 = (char *)(v37 + 3);
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      *((_DWORD *)v37 + 6) = a2;
      v37[4] = v11;
      v37[5] = v23;
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
    }
    else
    {
      *((_DWORD *)v37 + 6) = a2;
      v37[4] = v11;
      v37[5] = 0;
    }
    *a5 = v39;
    a5[1] = v38;
    if (v23) {
      goto LABEL_56;
    }
    return;
  }
  uint64_t v10 = (char *)operator new(0x68uLL);
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *(void *)uint64_t v10 = off_101A79920;
  *(_OWORD *)(v10 + 24) = 0u;
  uint64_t v11 = (std::string *)(v10 + 24);
  *((void *)v10 + 9) = 0;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  *((void *)v10 + 10) = 0;
  uint64_t v12 = (void **)(v10 + 80);
  v10[72] = 2;
  *((void *)v10 + 11) = 0;
  *((void *)v10 + 12) = 0;
  memset(__str, 0, sizeof(__str));
  CFBooleanRef Value = CFDictionaryGetValue(a3, @"phone-number");
  sub_100FC2A7C(__str, a1, Value, @"phone-number");
  if (!__str[24])
  {
    uint64_t v11 = 0;
    __int16 v24 = 0;
LABEL_49:
    sub_10004D2C8((std::__shared_weak_count *)v10);
    goto LABEL_50;
  }
  int v14 = CFDictionaryGetValue(a3, @"signature");
  memset(v45, 0, sizeof(v45));
  sub_100FC2A7C(v45, a1, v14, @"signature");
  if (!v45[24])
  {
    uint64_t v11 = 0;
    __int16 v24 = 0;
    goto LABEL_45;
  }
  *(_OWORD *)std::string __p = 0u;
  long long v44 = 0u;
  uint64_t v15 = CFDictionaryGetValue(a3, @"imsi");
  sub_100FC2A7C(__p, a1, v15, @"imsi");
  if (!BYTE8(v44)) {
    goto LABEL_8;
  }
  uint64_t v16 = (void *)BYTE7(v44);
  if (SBYTE7(v44) < 0) {
    uint64_t v16 = __p[1];
  }
  if (!v16)
  {
    int v25 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v26;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v48 = (uint8_t *)v27;
      __int16 v49 = 2080;
      uint64_t v50 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sIMSI key is present with no value", buf, 0x2Au);
    }
  }
  else
  {
LABEL_8:
    int v17 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v40 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      long long v41 = (uint8_t *)__str[23];
      if (__str[23] < 0) {
        long long v41 = *(uint8_t **)&__str[8];
      }
      long long v42 = (const char *)v45[23];
      if (v45[23] < 0) {
        long long v42 = *(const char **)&v45[8];
      }
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2048;
      uint64_t v48 = v41;
      __int16 v49 = 2048;
      uint64_t v50 = v42;
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#D %s%sPhone number has length: %zu, signature has length: %zu", buf, 0x2Au);
    }
    uint64_t v18 = __str[23];
    if (__str[23] < 0) {
      uint64_t v18 = *(void *)&__str[8];
    }
    if (v18)
    {
      uint64_t v19 = v45[23];
      if (v45[23] < 0) {
        uint64_t v19 = *(void *)&v45[8];
      }
      if (v19)
      {
        std::string::operator=(v11, (const std::string *)__str);
        std::string::operator=((std::string *)v10 + 2, (const std::string *)v45);
        if (BYTE8(v44))
        {
          if (SBYTE7(v44) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)int buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v44;
          }
        }
        else
        {
          memset(buf, 0, sizeof(buf));
        }
        if (v10[103] < 0) {
          operator delete(*v12);
        }
        *(_OWORD *)uint64_t v12 = *(_OWORD *)buf;
        *((void *)v10 + 12) = *(void *)&buf[16];
        CFTypeRef v28 = (void *)CFDictionaryGetValue(a4, @"signing-version");
        unint64_t v29 = sub_100FC2DC4(a1, v28, @"signing-version");
        if (HIDWORD(v29)) {
          v10[72] = v29;
        }
        if (v45[24])
        {
          __int16 v30 = **(NSObject ***)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v31;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v48 = (uint8_t *)v32;
            __int16 v49 = 2080;
            uint64_t v50 = ", ";
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPNR Signature:", buf, 0x2Au);
          }
          *(void *)int buf = off_101A79970;
          *(void *)&uint8_t buf[8] = a1;
          uint64_t v48 = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
        }
        __int16 v33 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          uint64_t v36 = asString();
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v34;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v48 = (uint8_t *)v35;
          __int16 v49 = 2080;
          uint64_t v50 = ", ";
          __int16 v51 = 2080;
          uint64_t v52 = v36;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sGet Phone Number signing version is %s", buf, 0x34u);
        }
        __int16 v24 = (std::__shared_weak_count *)v10;
        uint64_t v10 = 0;
        goto LABEL_39;
      }
    }
  }
  uint64_t v11 = 0;
  __int16 v24 = 0;
LABEL_39:
  if (BYTE8(v44) && SBYTE7(v44) < 0) {
    operator delete(__p[0]);
  }
  if (v45[24] && (v45[23] & 0x80000000) != 0) {
    operator delete(*(void **)v45);
  }
LABEL_45:
  if (__str[24] && (__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (v10) {
    goto LABEL_49;
  }
LABEL_50:
  if (v11)
  {
    uint64_t v23 = v24;
    goto LABEL_52;
  }
  *a5 = 0;
  a5[1] = 0;
  uint64_t v23 = v24;
  if (v24) {
LABEL_56:
  }
    sub_10004D2C8(v23);
}

void sub_100FDC430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22 && a21 < 0) {
    operator delete(a16);
  }
  if (a29)
  {
    if (a28 < 0) {
      operator delete(a23);
    }
  }
  sub_10004D2C8(v33);
  _Unwind_Resume(a1);
}

void sub_100FDC4DC(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    unint64_t v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7AD50;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  int v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FDC70C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDC724(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  int v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019A964(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDCA18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDCA88()
{
  return "getPhoneNumber";
}

void sub_100FDCA94(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AD50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDCAB4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AD50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FDCB08(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FDCB1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7ADA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDCB3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7ADA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDCB90(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDCBBC(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDCBF4(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  uint64_t v5 = a1;
  if (a2 != 6000)
  {
    char v60 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v62 = v5;
      unint64_t v63 = v61;
      uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)v62 + 40))(v62);
      __p[0].n128_u32[0] = 136315906;
      *(unint64_t *)((char *)__p[0].n128_u64 + 4) = v63;
      __p[0].n128_u16[6] = 2080;
      *(unint64_t *)((char *)&__p[0].n128_u64[1] + 6) = (unint64_t)" ";
      __p[1].n128_u16[3] = 2080;
      __p[1].n128_u64[1] = v64;
      LOWORD(v220[0]) = 2080;
      *(void **)((char *)v220 + 2) = ", ";
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", (uint8_t *)__p, 0x2Au);
    }
    uint64_t v189 = 0;
    uint64_t v190 = 0;
    goto LABEL_302;
  }
  uint64_t v8 = (char *)operator new(0xB8uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)uint64_t v8 = off_101A79A40;
  *(_OWORD *)(v8 + 24) = 0u;
  uint64_t v189 = (uint64_t)(v8 + 24);
  uint64_t v190 = v8;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  CFBooleanRef Value = CFDictionaryGetValue(a3, @"manage-account-url");
  sub_100FC2A7C(__p, v5, Value, @"manage-account-url");
  sub_100179CB0(v189, __p);
  if (__p[1].n128_u8[8] && __p[1].n128_i8[7] < 0) {
    operator delete((void *)__p[0].n128_u64[0]);
  }
  uint64_t v10 = CFDictionaryGetValue(a3, @"manage-account-url-post-data");
  sub_100FC2A7C(__p, v5, v10, @"manage-account-url-post-data");
  sub_100179CB0((uint64_t)(v190 + 56), __p);
  if (__p[1].n128_u8[8] && __p[1].n128_i8[7] < 0) {
    operator delete((void *)__p[0].n128_u64[0]);
  }
  uint64_t v11 = CFDictionaryGetValue(a3, @"secondary-devices-paired");
  int64x2_t v206 = 0u;
  long long v207 = 0u;
  CFArrayRef theArray = 0;
  uint64_t v213 = 0;
  sub_100FC3AEC((const void **)&theArray, v11);
  long long v187 = a4;
  CFDictionaryRef theDict = a3;
  uint64_t v205 = v5;
  if ((_BYTE)v213)
  {
    uint64_t v12 = **(NSObject ***)(v5 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v205 + 40))(v205);
      CFIndex Count = (void *)CFArrayGetCount(theArray);
      __p[0].n128_u32[0] = 136316162;
      *(unint64_t *)((char *)__p[0].n128_u64 + 4) = v13;
      __p[0].n128_u16[6] = 2080;
      *(unint64_t *)((char *)&__p[0].n128_u64[1] + 6) = (unint64_t)" ";
      __p[1].n128_u16[3] = 2080;
      __p[1].n128_u64[1] = v14;
      LOWORD(v220[0]) = 2080;
      *(void **)((char *)v220 + 2) = ", ";
      WORD1(v220[1]) = 2048;
      *(void **)((char *)&v220[1] + 4) = Count;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of paired devices: %lu", (uint8_t *)__p, 0x34u);
    }
    long long v210 = 0u;
    long long v211 = 0u;
    long long v208 = 0u;
    long long v209 = 0u;
    obuint64_t j = theArray;
    id v16 = [(__CFArray *)theArray countByEnumeratingWithState:&v208 objects:v231 count:16];
    if (v16)
    {
      id v17 = v16;
      CFTypeRef cf = *(CFTypeRef *)v209;
      CFStringRef v18 = @"iccid";
      do
      {
        for (unint64_t i = 0; i != v17; unint64_t i = (char *)i + 1)
        {
          if (*(CFTypeRef *)v209 != cf) {
            objc_enumerationMutation(obj);
          }
          __int16 v20 = *(void **)(*((void *)&v208 + 1) + 8 * i);
          id v21 = [v20 objectForKey:@"eid"];
          id v22 = [v20 objectForKey:@"imei"];
          id v23 = [v20 objectForKey:@"meid"];
          __int16 v24 = (__CFString *)v18;
          id v25 = [v20 objectForKey:v18];
          id v26 = [v20 objectForKey:@"activation-status"];
          id v27 = [v20 objectForKey:@"alt-smdp-fqdn"];
          *(_OWORD *)unsigned int v227 = 0u;
          long long v228 = 0u;
          *(_OWORD *)uint64_t v225 = 0u;
          long long v226 = 0u;
          *(_OWORD *)CFIndex v223 = 0u;
          *(_OWORD *)uint64_t v224 = 0u;
          *(_OWORD *)uint64_t v221 = 0u;
          long long v222 = 0u;
          memset(v220, 0, sizeof(v220));
          memset(__p, 0, sizeof(__p));
          sub_100FC2A7C(&v215, v205, v21, @"eid");
          sub_100179CB0((uint64_t)__p, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v22, @"imei");
          sub_100179CB0((uint64_t)v220, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v23, @"meid");
          sub_100179CB0((uint64_t)v221, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          CFTypeRef v28 = v25;
          CFStringRef v18 = v24;
          sub_100FC2A7C(&v215, v205, v28, v24);
          sub_100179CB0((uint64_t)v223, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          if (LOBYTE(v224[1]))
          {
            if ((SHIBYTE(v224[0]) & 0x80000000) == 0)
            {
              CFTypeRef v29 = (void *)HIBYTE(v224[0]);
              if (HIBYTE(v224[0]) > 0x12u) {
                goto LABEL_34;
              }
LABEL_33:
              std::string::append((std::string *)v223, 19 - (void)v29, 102);
              goto LABEL_34;
            }
            CFTypeRef v29 = v223[1];
            if (v223[1] < (void *)0x13) {
              goto LABEL_33;
            }
          }
LABEL_34:
          sub_100FC2A7C(&v215, v205, v26, @"activation-status");
          sub_100179CB0((uint64_t)v225, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v27, @"alt-smdp-fqdn");
          sub_100179CB0((uint64_t)v227, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          if (!BYTE8(v207))
          {
            *(void *)&long long v207 = 0;
            int64x2_t v206 = 0uLL;
            int64x2_t v216 = 0uLL;
            BYTE8(v207) = 1;
            id v214 = &v215;
            uint64_t v215 = 0;
            sub_100FC804C(&v214);
          }
          if (v206.i64[1] >= (unint64_t)v207)
          {
            unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((v206.i64[1] - v206.i64[0]) >> 6) + 1;
            if (v31 > 0x155555555555555) {
              sub_10006A748();
            }
            if (0x5555555555555556 * ((uint64_t)(v207 - v206.i64[0]) >> 6) > v31) {
              unint64_t v31 = 0x5555555555555556 * ((uint64_t)(v207 - v206.i64[0]) >> 6);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v207 - v206.i64[0]) >> 6) >= 0xAAAAAAAAAAAAAALL) {
              unint64_t v32 = 0x155555555555555;
            }
            else {
              unint64_t v32 = v31;
            }
            id v218 = &v207;
            if (v32)
            {
              if (v32 > 0x155555555555555) {
                sub_10006A7CC();
              }
              __int16 v33 = (char *)operator new(192 * v32);
            }
            else
            {
              __int16 v33 = 0;
            }
            uint64_t v215 = v33;
            v216.i64[0] = (uint64_t)&v33[64 * ((v206.i64[1] - v206.i64[0]) >> 6)];
            v216.i64[1] = v216.i64[0];
            uint64_t v217 = &v33[192 * v32];
            sub_100FC80D0(v216.i64[0], (long long *)__p);
            uint64_t v34 = v216.i64[0];
            uint64_t v30 = v216.i64[1] + 192;
            v216.i64[1] += 192;
            int64x2_t v35 = v206;
            if (v206.i64[1] == v206.i64[0])
            {
              int64x2_t v53 = vdupq_n_s64(v206.u64[1]);
            }
            else
            {
              uint64_t v36 = 0;
              do
              {
                uint64_t v37 = v34 + v36;
                *(unsigned char *)(v34 + v36 - 192) = 0;
                uint64_t v38 = v35.i64[1] + v36;
                *(unsigned char *)(v34 + v36 - 168) = 0;
                if (*(unsigned char *)(v35.i64[1] + v36 - 168))
                {
                  uint64_t v39 = (void *)(v38 - 192);
                  long long v40 = *(_OWORD *)(v38 - 192);
                  *(void *)(v34 + v36 - 176) = *(void *)(v38 - 176);
                  *(_OWORD *)(v34 + v36 - 192) = v40;
                  v39[1] = 0;
                  v39[2] = 0;
                  void *v39 = 0;
                  *(unsigned char *)(v37 - 168) = 1;
                }
                *(unsigned char *)(v37 - 160) = 0;
                *(unsigned char *)(v37 - 136) = 0;
                if (*(unsigned char *)(v38 - 136))
                {
                  uint64_t v41 = v35.i64[1] + v36;
                  long long v42 = *(_OWORD *)(v35.i64[1] + v36 - 160);
                  *(void *)(v37 - 144) = *(void *)(v35.i64[1] + v36 - 144);
                  *(_OWORD *)(v37 - 160) = v42;
                  *(void *)(v41 - 152) = 0;
                  *(void *)(v41 - 144) = 0;
                  *(void *)(v41 - 160) = 0;
                  *(unsigned char *)(v37 - 136) = 1;
                }
                uint64_t v43 = v34 + v36;
                *(unsigned char *)(v34 + v36 - 128) = 0;
                *(unsigned char *)(v34 + v36 - 104) = 0;
                uint64_t v44 = v35.i64[1] + v36;
                if (*(unsigned char *)(v35.i64[1] + v36 - 104))
                {
                  long long v45 = *(_OWORD *)(v44 - 128);
                  *(void *)(v34 + v36 - 112) = *(void *)(v44 - 112);
                  *(_OWORD *)(v34 + v36 - 128) = v45;
                  *(void *)(v44 - 120) = 0;
                  *(void *)(v44 - 112) = 0;
                  *(void *)(v44 - 128) = 0;
                  *(unsigned char *)(v43 - 104) = 1;
                }
                *(unsigned char *)(v43 - 96) = 0;
                *(unsigned char *)(v43 - 72) = 0;
                if (*(unsigned char *)(v44 - 72))
                {
                  uint64_t v46 = v35.i64[1] + v36;
                  long long v47 = *(_OWORD *)(v35.i64[1] + v36 - 96);
                  *(void *)(v43 - 80) = *(void *)(v35.i64[1] + v36 - 80);
                  *(_OWORD *)(v43 - 96) = v47;
                  *(void *)(v46 - 88) = 0;
                  *(void *)(v46 - 80) = 0;
                  *(void *)(v46 - 96) = 0;
                  *(unsigned char *)(v43 - 72) = 1;
                }
                uint64_t v48 = v34 + v36;
                *(unsigned char *)(v34 + v36 - 64) = 0;
                *(unsigned char *)(v34 + v36 - 40) = 0;
                uint64_t v49 = v35.i64[1] + v36;
                if (*(unsigned char *)(v35.i64[1] + v36 - 40))
                {
                  long long v50 = *(_OWORD *)(v49 - 64);
                  *(void *)(v34 + v36 - 48) = *(void *)(v49 - 48);
                  *(_OWORD *)(v34 + v36 - 64) = v50;
                  *(void *)(v49 - 56) = 0;
                  *(void *)(v49 - 48) = 0;
                  *(void *)(v49 - 64) = 0;
                  *(unsigned char *)(v48 - 40) = 1;
                }
                *(unsigned char *)(v48 - 32) = 0;
                *(unsigned char *)(v48 - 8) = 0;
                if (*(unsigned char *)(v49 - 8))
                {
                  uint64_t v51 = v35.i64[1] + v36;
                  long long v52 = *(_OWORD *)(v35.i64[1] + v36 - 32);
                  *(void *)(v48 - 16) = *(void *)(v35.i64[1] + v36 - 16);
                  *(_OWORD *)(v48 - 32) = v52;
                  *(void *)(v51 - 24) = 0;
                  *(void *)(v51 - 16) = 0;
                  *(void *)(v51 - 32) = 0;
                  *(unsigned char *)(v48 - 8) = 1;
                }
                v36 -= 192;
              }
              while (v35.i64[1] + v36 != v35.i64[0]);
              int64x2_t v53 = v206;
              uint64_t v30 = v216.i64[1];
              v34 += v36;
            }
            v206.i64[0] = v34;
            v206.i64[1] = v30;
            int64x2_t v216 = v53;
            __int16 v54 = (char *)v207;
            *(void *)&long long v207 = v217;
            uint64_t v217 = v54;
            uint64_t v215 = (void *)v53.i64[0];
            sub_100FC81FC((uint64_t)&v215);
          }
          else
          {
            sub_100FC80D0(v206.i64[1], (long long *)__p);
            uint64_t v30 = v206.i64[1] + 192;
          }
          v206.i64[1] = v30;
          if (BYTE8(v228) && SBYTE7(v228) < 0) {
            operator delete(v227[0]);
          }
          if (BYTE8(v226) && SBYTE7(v226) < 0) {
            operator delete(v225[0]);
          }
          if (LOBYTE(v224[1]) && SHIBYTE(v224[0]) < 0) {
            operator delete(v223[0]);
          }
          if (BYTE8(v222) && SBYTE7(v222) < 0) {
            operator delete(v221[0]);
          }
          if (LOBYTE(v220[3]) && SHIBYTE(v220[2]) < 0) {
            operator delete(v220[0]);
          }
          if (__p[1].n128_u8[8] && __p[1].n128_i8[7] < 0) {
            operator delete((void *)__p[0].n128_u64[0]);
          }
        }
        id v17 = [(__CFArray *)obj countByEnumeratingWithState:&v208 objects:v231 count:16];
      }
      while (v17);
    }
    a4 = v187;
    uint64_t v5 = v205;
    if ((_BYTE)v213) {
      sub_100044D00((const void **)&theArray);
    }
  }
  long long v55 = (void **)(v190 + 88);
  if (v190[112] == BYTE8(v207))
  {
    if (!v190[112]) {
      goto LABEL_110;
    }
    long long v56 = *v55;
    long long v57 = v190;
    if (*v55)
    {
      uint64_t v58 = *((void *)v190 + 12);
      uint64_t v59 = *v55;
      if ((void *)v58 != v56)
      {
        do
          uint64_t v58 = sub_100FC824C(v58 - 192);
        while ((void *)v58 != v56);
        uint64_t v59 = *v55;
      }
      long long v57 = v190;
      *((void *)v190 + 12) = v56;
      operator delete(v59);
      *long long v55 = 0;
      *((void *)v190 + 12) = 0;
      *((void *)v190 + 13) = 0;
    }
    *(int64x2_t *)(v57 + 88) = v206;
    *((void *)v57 + 13) = v207;
    *(void *)&long long v207 = 0;
    int64x2_t v206 = 0uLL;
    uint64_t v5 = v205;
  }
  else if (v190[112])
  {
    __p[0].n128_u64[0] = (unint64_t)(v190 + 88);
    sub_100FC804C((void ***)__p);
    v190[112] = 0;
  }
  else
  {
    *(int64x2_t *)(v190 + 88) = v206;
    *((void *)v190 + 13) = v207;
    *(void *)&long long v207 = 0;
    int64x2_t v206 = 0uLL;
    v190[112] = 1;
  }
  if (BYTE8(v207))
  {
    __p[0].n128_u64[0] = (unint64_t)&v206;
    sub_100FC804C((void ***)__p);
  }
LABEL_110:
  long long v65 = CFDictionaryGetValue(theDict, @"subscription");
  int64x2_t v206 = 0u;
  long long v207 = 0u;
  CFArrayRef theArray = 0;
  uint64_t v213 = 0;
  sub_100FC3AEC((const void **)&theArray, v65);
  if ((_BYTE)v213)
  {
    uint64_t v66 = **(NSObject ***)(v5 + 40);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v67 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v68 = (*(uint64_t (**)(uint64_t))(*(void *)v205 + 40))(v205);
      __int16 v69 = (void *)CFArrayGetCount(theArray);
      __p[0].n128_u32[0] = 136316162;
      *(unint64_t *)((char *)__p[0].n128_u64 + 4) = v67;
      __p[0].n128_u16[6] = 2080;
      *(unint64_t *)((char *)&__p[0].n128_u64[1] + 6) = (unint64_t)" ";
      __p[1].n128_u16[3] = 2080;
      __p[1].n128_u64[1] = v68;
      LOWORD(v220[0]) = 2080;
      *(void **)((char *)v220 + 2) = ", ";
      WORD1(v220[1]) = 2048;
      *(void **)((char *)&v220[1] + 4) = v69;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of subscription states: %lu", (uint8_t *)__p, 0x34u);
      uint64_t v5 = v205;
    }
    long long v210 = 0u;
    long long v211 = 0u;
    long long v208 = 0u;
    long long v209 = 0u;
    CFArrayRef v191 = theArray;
    __int16 v70 = (std::string *)[(__CFArray *)theArray countByEnumeratingWithState:&v208 objects:v231 count:16];
    if (v70)
    {
      uint64_t v195 = *(void *)v209;
      CFStringRef v71 = @"iccid";
      do
      {
        id v203 = 0;
        uint64_t v197 = v70;
        do
        {
          if (*(void *)v209 != v195) {
            objc_enumerationMutation(v191);
          }
          uint64_t v72 = *(void **)(*((void *)&v208 + 1) + 8 * (void)v203);
          id v73 = [v72 objectForKey:@"eid"];
          id v74 = [v72 objectForKey:@"imei"];
          __int16 v75 = (__CFString *)v71;
          id v76 = [v72 objectForKey:v71];
          id v77 = [v72 objectForKey:@"activation-status"];
          id v78 = [v72 objectForKey:@"associated-subscription"];
          id v79 = [v72 objectForKey:@"activated-by"];
          id v80 = [v72 objectForKey:@"alt-smdp-fqdn"];
          CFTypeRef cfa = [v72 objectForKey:@"manage-account-url"];
          id v81 = [v72 objectForKey:@"manage-account-url-post-data"];
          uint64_t v230 = 0;
          memset(v229, 0, sizeof(v229));
          *(_OWORD *)unsigned int v227 = 0u;
          long long v228 = 0u;
          *(_OWORD *)uint64_t v225 = 0u;
          long long v226 = 0u;
          *(_OWORD *)CFIndex v223 = 0u;
          *(_OWORD *)uint64_t v224 = 0u;
          *(_OWORD *)uint64_t v221 = 0u;
          long long v222 = 0u;
          memset(v220, 0, sizeof(v220));
          memset(__p, 0, sizeof(__p));
          sub_100FC2A7C(&v215, v205, v73, @"eid");
          sub_100179CB0((uint64_t)__p, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v74, @"imei");
          sub_100179CB0((uint64_t)v220, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          unsigned int v82 = v76;
          CFStringRef v71 = v75;
          sub_100FC2A7C(&v215, v205, v82, v75);
          sub_100179CB0((uint64_t)v221, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          if (BYTE8(v222))
          {
            if ((SBYTE7(v222) & 0x80000000) == 0)
            {
              __int16 v83 = (void *)BYTE7(v222);
              if (BYTE7(v222) > 0x12u) {
                goto LABEL_133;
              }
LABEL_132:
              std::string::append((std::string *)v221, 19 - (void)v83, 102);
              goto LABEL_133;
            }
            __int16 v83 = v221[1];
            if (v221[1] < (void *)0x13) {
              goto LABEL_132;
            }
          }
LABEL_133:
          sub_100FC2A7C(&v215, v205, v77, @"activation-status");
          sub_100179CB0((uint64_t)v223, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          unint64_t v84 = sub_100FC2DC4(v205, v78, @"associated-subscription");
          if (BYTE4(v225[0]) == BYTE4(v84))
          {
            if (BYTE4(v225[0])) {
              LODWORD(v225[0]) = v84;
            }
          }
          else if (BYTE4(v225[0]))
          {
            BYTE4(v225[0]) = 0;
          }
          else
          {
            LODWORD(v225[0]) = v84;
            BYTE4(v225[0]) = 1;
          }
          sub_100FC2A7C(&v215, v205, v79, @"activated-by");
          sub_100179CB0((uint64_t)&v225[1], (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v80, @"alt-smdp-fqdn");
          sub_100179CB0((uint64_t)&v227[1], (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, cfa, @"manage-account-url");
          sub_100179CB0((uint64_t)v229 + 8, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v81, @"manage-account-url-post-data");
          sub_100179CB0((uint64_t)&v229[2] + 8, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          if (!BYTE8(v207))
          {
            *(void *)&long long v207 = 0;
            int64x2_t v206 = 0uLL;
            int64x2_t v216 = 0uLL;
            BYTE8(v207) = 1;
            id v214 = &v215;
            uint64_t v215 = 0;
            sub_100FC8300(&v214);
          }
          uint64_t v85 = v206.i64[1];
          if (v206.i64[1] >= (unint64_t)v207)
          {
            uint64_t v87 = 0xF83E0F83E0F83E1 * ((v206.i64[1] - v206.i64[0]) >> 3);
            unint64_t v88 = v87 + 1;
            if ((unint64_t)(v87 + 1) > 0xF83E0F83E0F83ELL) {
              sub_10006A748();
            }
            if (0x1F07C1F07C1F07C2 * ((uint64_t)(v207 - v206.i64[0]) >> 3) > v88) {
              unint64_t v88 = 0x1F07C1F07C1F07C2 * ((uint64_t)(v207 - v206.i64[0]) >> 3);
            }
            if ((unint64_t)(0xF83E0F83E0F83E1 * ((uint64_t)(v207 - v206.i64[0]) >> 3)) >= 0x7C1F07C1F07C1FLL) {
              unint64_t v89 = 0xF83E0F83E0F83ELL;
            }
            else {
              unint64_t v89 = v88;
            }
            id v218 = &v207;
            if (v89)
            {
              if (v89 > 0xF83E0F83E0F83ELL) {
                sub_10006A7CC();
              }
              id v90 = (char *)operator new(264 * v89);
            }
            else
            {
              id v90 = 0;
            }
            uint64_t v215 = v90;
            v216.i64[0] = (uint64_t)&v90[264 * v87];
            v216.i64[1] = v216.i64[0];
            uint64_t v217 = &v90[264 * v89];
            sub_100FC8384(v216.i64[0], (uint64_t)__p);
            uint64_t v91 = v216.i64[0];
            uint64_t v86 = v216.i64[1] + 264;
            v216.i64[1] += 264;
            int64x2_t v92 = v206;
            uint64_t v5 = v205;
            if (v206.i64[1] == v206.i64[0])
            {
              int64x2_t v116 = vdupq_n_s64(v206.u64[1]);
            }
            else
            {
              uint64_t v93 = 0;
              do
              {
                uint64_t v94 = v91 + v93;
                CFIndex v95 = (unsigned char *)(v91 + v93 - 264);
                uint64_t v96 = v92.i64[1] + v93;
                unsigned char *v95 = 0;
                *(unsigned char *)(v91 + v93 - 240) = 0;
                if (*(unsigned char *)(v92.i64[1] + v93 - 240))
                {
                  uint64_t v97 = (void *)(v96 - 264);
                  long long v98 = *(_OWORD *)(v96 - 264);
                  *(void *)(v91 + v93 - 248) = *(void *)(v96 - 248);
                  *(_OWORD *)CFIndex v95 = v98;
                  v97[1] = 0;
                  v97[2] = 0;
                  void *v97 = 0;
                  *(unsigned char *)(v94 - 240) = 1;
                }
                *(unsigned char *)(v94 - 232) = 0;
                *(unsigned char *)(v94 - 208) = 0;
                if (*(unsigned char *)(v96 - 208))
                {
                  uint64_t v99 = v92.i64[1] + v93;
                  long long v100 = *(_OWORD *)(v92.i64[1] + v93 - 232);
                  *(void *)(v94 - 216) = *(void *)(v92.i64[1] + v93 - 216);
                  *(_OWORD *)(v94 - 232) = v100;
                  *(void *)(v99 - 224) = 0;
                  *(void *)(v99 - 216) = 0;
                  *(void *)(v99 - 232) = 0;
                  *(unsigned char *)(v94 - 208) = 1;
                }
                uint64_t v101 = v91 + v93;
                *(unsigned char *)(v91 + v93 - 200) = 0;
                *(unsigned char *)(v91 + v93 - 176) = 0;
                uint64_t v102 = v92.i64[1] + v93;
                if (*(unsigned char *)(v92.i64[1] + v93 - 176))
                {
                  long long v103 = *(_OWORD *)(v102 - 200);
                  *(void *)(v91 + v93 - 184) = *(void *)(v102 - 184);
                  *(_OWORD *)(v91 + v93 - 200) = v103;
                  *(void *)(v102 - 192) = 0;
                  *(void *)(v102 - 184) = 0;
                  *(void *)(v102 - 200) = 0;
                  *(unsigned char *)(v101 - 176) = 1;
                }
                *(unsigned char *)(v101 - 168) = 0;
                *(unsigned char *)(v101 - 144) = 0;
                if (*(unsigned char *)(v102 - 144))
                {
                  uint64_t v104 = v92.i64[1] + v93;
                  long long v105 = *(_OWORD *)(v92.i64[1] + v93 - 168);
                  *(void *)(v101 - 152) = *(void *)(v92.i64[1] + v93 - 152);
                  *(_OWORD *)(v101 - 168) = v105;
                  *(void *)(v104 - 160) = 0;
                  *(void *)(v104 - 152) = 0;
                  *(void *)(v104 - 168) = 0;
                  *(unsigned char *)(v101 - 144) = 1;
                }
                uint64_t v106 = v91 + v93;
                uint64_t v107 = v92.i64[1] + v93;
                *(void *)(v106 - 136) = *(void *)(v92.i64[1] + v93 - 136);
                *(unsigned char *)(v91 + v93 - 128) = 0;
                *(unsigned char *)(v106 - 104) = 0;
                if (*(unsigned char *)(v92.i64[1] + v93 - 104))
                {
                  long long v108 = *(_OWORD *)(v107 - 128);
                  *(void *)(v91 + v93 - 112) = *(void *)(v107 - 112);
                  *(_OWORD *)(v91 + v93 - 128) = v108;
                  *(void *)(v107 - 120) = 0;
                  *(void *)(v107 - 112) = 0;
                  *(void *)(v107 - 128) = 0;
                  *(unsigned char *)(v106 - 104) = 1;
                }
                *(unsigned char *)(v106 - 96) = 0;
                *(unsigned char *)(v106 - 72) = 0;
                if (*(unsigned char *)(v107 - 72))
                {
                  uint64_t v109 = v92.i64[1] + v93;
                  long long v110 = *(_OWORD *)(v92.i64[1] + v93 - 96);
                  *(void *)(v106 - 80) = *(void *)(v92.i64[1] + v93 - 80);
                  *(_OWORD *)(v106 - 96) = v110;
                  *(void *)(v109 - 88) = 0;
                  *(void *)(v109 - 80) = 0;
                  *(void *)(v109 - 96) = 0;
                  *(unsigned char *)(v106 - 72) = 1;
                }
                uint64_t v111 = v91 + v93;
                *(unsigned char *)(v91 + v93 - 64) = 0;
                *(unsigned char *)(v91 + v93 - 40) = 0;
                uint64_t v112 = v92.i64[1] + v93;
                if (*(unsigned char *)(v92.i64[1] + v93 - 40))
                {
                  long long v113 = *(_OWORD *)(v112 - 64);
                  *(void *)(v91 + v93 - 48) = *(void *)(v112 - 48);
                  *(_OWORD *)(v91 + v93 - 64) = v113;
                  *(void *)(v112 - 56) = 0;
                  *(void *)(v112 - 48) = 0;
                  *(void *)(v112 - 64) = 0;
                  *(unsigned char *)(v111 - 40) = 1;
                }
                *(unsigned char *)(v111 - 32) = 0;
                *(unsigned char *)(v111 - 8) = 0;
                if (*(unsigned char *)(v112 - 8))
                {
                  uint64_t v114 = v92.i64[1] + v93;
                  long long v115 = *(_OWORD *)(v92.i64[1] + v93 - 32);
                  *(void *)(v111 - 16) = *(void *)(v92.i64[1] + v93 - 16);
                  *(_OWORD *)(v111 - 32) = v115;
                  *(void *)(v114 - 24) = 0;
                  *(void *)(v114 - 16) = 0;
                  *(void *)(v114 - 32) = 0;
                  *(unsigned char *)(v111 - 8) = 1;
                }
                v93 -= 264;
              }
              while (v92.i64[1] + v93 != v92.i64[0]);
              int64x2_t v116 = v206;
              uint64_t v86 = v216.i64[1];
              v91 += v93;
            }
            v206.i64[0] = v91;
            v206.i64[1] = v86;
            int64x2_t v216 = v116;
            id v117 = (char *)v207;
            *(void *)&long long v207 = v217;
            uint64_t v217 = v117;
            uint64_t v215 = (void *)v116.i64[0];
            sub_100FC8520((uint64_t)&v215);
          }
          else
          {
            sub_100FC8384(v206.i64[1], (uint64_t)__p);
            uint64_t v86 = v85 + 264;
            uint64_t v5 = v205;
          }
          v206.i64[1] = v86;
          sub_100FC8570((uint64_t)__p);
          id v203 = (std::string *)((char *)v203 + 1);
        }
        while (v203 != v197);
        __int16 v70 = (std::string *)[(__CFArray *)v191 countByEnumeratingWithState:&v208 objects:v231 count:16];
      }
      while (v70);
    }
    a4 = v187;
    int v4 = 6000;
    if ((_BYTE)v213) {
      sub_100044D00((const void **)&theArray);
    }
  }
  id v118 = (void **)(v190 + 120);
  if (v190[144] != BYTE8(v207))
  {
    if (v190[144])
    {
      __p[0].n128_u64[0] = (unint64_t)(v190 + 120);
      sub_100FC8300((void ***)__p);
      v190[144] = 0;
    }
    else
    {
      *(int64x2_t *)(v190 + 120) = v206;
      *((void *)v190 + 17) = v207;
      *(void *)&long long v207 = 0;
      int64x2_t v206 = 0uLL;
      v190[144] = 1;
    }
LABEL_205:
    if (BYTE8(v207))
    {
      __p[0].n128_u64[0] = (unint64_t)&v206;
      sub_100FC8300((void ***)__p);
    }
    goto LABEL_207;
  }
  if (v190[144])
  {
    int v119 = *v118;
    CFDictionaryRef v120 = v190;
    if (*v118)
    {
      uint64_t v121 = *((void *)v190 + 16);
      int v122 = *v118;
      if ((void *)v121 != v119)
      {
        do
          uint64_t v121 = sub_100FC8570(v121 - 264);
        while ((void *)v121 != v119);
        int v122 = *v118;
      }
      CFDictionaryRef v120 = v190;
      *((void *)v190 + 16) = v119;
      operator delete(v122);
      std::__shared_weak_count *v118 = 0;
      *((void *)v190 + 16) = 0;
      *((void *)v190 + 17) = 0;
    }
    *(int64x2_t *)(v120 + 120) = v206;
    *((void *)v120 + 17) = v207;
    *(void *)&long long v207 = 0;
    int64x2_t v206 = 0uLL;
    uint64_t v5 = v205;
    goto LABEL_205;
  }
LABEL_207:
  uint64_t v123 = CFDictionaryGetValue(theDict, @"add-on-plans");
  int64x2_t v206 = 0u;
  long long v207 = 0u;
  CFArrayRef theArray = 0;
  uint64_t v213 = 0;
  sub_100FC3AEC((const void **)&theArray, v123);
  if ((_BYTE)v213)
  {
    uint64_t v124 = **(NSObject ***)(v5 + 40);
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v125 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v126 = (*(uint64_t (**)(uint64_t))(*(void *)v205 + 40))(v205);
      long long v127 = (void *)CFArrayGetCount(theArray);
      __p[0].n128_u32[0] = 136316162;
      *(unint64_t *)((char *)__p[0].n128_u64 + 4) = v125;
      __p[0].n128_u16[6] = 2080;
      *(unint64_t *)((char *)&__p[0].n128_u64[1] + 6) = (unint64_t)" ";
      __p[1].n128_u16[3] = 2080;
      __p[1].n128_u64[1] = v126;
      LOWORD(v220[0]) = 2080;
      *(void **)((char *)v220 + 2) = ", ";
      WORD1(v220[1]) = 2048;
      *(void **)((char *)&v220[1] + 4) = v127;
      _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNumber of available add on data plans: %lu", (uint8_t *)__p, 0x34u);
    }
    long long v210 = 0u;
    long long v211 = 0u;
    long long v208 = 0u;
    long long v209 = 0u;
    CFArrayRef v192 = theArray;
    long long v128 = (std::string *)[(__CFArray *)theArray countByEnumeratingWithState:&v208 objects:v231 count:16];
    if (v128)
    {
      uint64_t v194 = *(void *)v209;
      CFStringRef v129 = @"plan-cost";
      CFStringRef v130 = @"plan-currency";
      CFStringRef v131 = @"plan-data-amount";
      CFStringRef v132 = @"plan-data-measure-unit";
      do
      {
        BOOL v204 = 0;
        id v196 = v128;
        do
        {
          if (*(void *)v209 != v194) {
            objc_enumerationMutation(v192);
          }
          CFArrayRef v133 = *(void **)(*((void *)&v208 + 1) + 8 * (void)v204);
          id v134 = [v133 objectForKey:@"plan-carrier"];
          long long v135 = (__CFString *)v129;
          id v136 = [v133 objectForKey:v129];
          long long v137 = (__CFString *)v130;
          id v138 = [v133 objectForKey:v130];
          uint64_t v139 = (__CFString *)v131;
          id v140 = [v133 objectForKey:v131];
          CFArrayRef v141 = (__CFString *)v132;
          id v142 = [v133 objectForKey:v132];
          CFTypeRef cfb = [v133 objectForKey:@"plan-id"];
          CFTypeRef v199 = [v133 objectForKey:@"plan-name"];
          id v198 = [v133 objectForKey:@"plan-type"];
          id v143 = [v133 objectForKey:@"plan-purchase-type"];
          *(_OWORD *)uint64_t v225 = 0u;
          long long v226 = 0u;
          *(_OWORD *)CFIndex v223 = 0u;
          *(_OWORD *)uint64_t v224 = 0u;
          *(_OWORD *)uint64_t v221 = 0u;
          long long v222 = 0u;
          memset(v220, 0, sizeof(v220));
          memset(__p, 0, sizeof(__p));
          sub_100FC2A7C(&v215, v205, v134, @"plan-carrier");
          sub_100179CB0((uint64_t)&v221[1], (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          uint64_t v144 = v136;
          CFStringRef v129 = v135;
          unint64_t v145 = sub_100FC2DC4(v205, v144, v135);
          LODWORD(v223[1]) = v145;
          BYTE4(v223[1]) = BYTE4(v145);
          long long v146 = v138;
          CFStringRef v130 = v137;
          sub_100FC2A7C(&v215, v205, v146, v137);
          sub_100179CB0((uint64_t)v224, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          __int16 v147 = v140;
          CFStringRef v131 = v139;
          unint64_t v148 = sub_100FC2DC4(v205, v147, v139);
          LODWORD(v226) = v148;
          BYTE4(v226) = BYTE4(v148);
          __int16 v149 = v142;
          CFStringRef v132 = v141;
          unint64_t v150 = sub_100FC2DC4(v205, v149, v141);
          if (BYTE9(v226) == BYTE4(v150))
          {
            uint64_t v151 = cfb;
            if (BYTE9(v226)) {
              BYTE8(v226) = v150;
            }
          }
          else
          {
            uint64_t v151 = cfb;
            if (BYTE9(v226))
            {
              BYTE9(v226) = 0;
            }
            else
            {
              BYTE8(v226) = v150;
              BYTE9(v226) = 1;
            }
          }
          sub_100FC2A7C(&v215, v205, v151, @"plan-id");
          sub_100179CB0((uint64_t)__p, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          sub_100FC2A7C(&v215, v205, v199, @"plan-name");
          sub_100179CB0((uint64_t)v220, (__n128 *)&v215);
          if ((_BYTE)v217 && v216.i8[15] < 0) {
            operator delete(v215);
          }
          unint64_t v152 = sub_100FC2DC4(v205, v198, @"plan-type");
          if (BYTE11(v226) == BYTE4(v152))
          {
            if (BYTE11(v226)) {
              BYTE10(v226) = v152;
            }
          }
          else if (BYTE11(v226))
          {
            BYTE11(v226) = 0;
          }
          else
          {
            BYTE10(v226) = v152;
            BYTE11(v226) = 1;
          }
          unint64_t v153 = sub_100FC2DC4(v205, v143, @"plan-purchase-type");
          if (BYTE1(v221[0]) == BYTE4(v153))
          {
            if (BYTE1(v221[0])) {
              LOBYTE(v221[0]) = v153;
            }
          }
          else if (BYTE1(v221[0]))
          {
            BYTE1(v221[0]) = 0;
          }
          else
          {
            LOBYTE(v221[0]) = v153;
            BYTE1(v221[0]) = 1;
          }
          if (!BYTE8(v207))
          {
            *(void *)&long long v207 = 0;
            int64x2_t v206 = 0uLL;
            int64x2_t v216 = 0uLL;
            BYTE8(v207) = 1;
            id v214 = &v215;
            uint64_t v215 = 0;
            sub_100FC8770(&v214);
          }
          uint64_t v154 = v206.i64[1];
          if (v206.i64[1] >= (unint64_t)v207)
          {
            unint64_t v157 = 0xCCCCCCCCCCCCCCCDLL * ((v206.i64[1] - v206.i64[0]) >> 5);
            unint64_t v158 = v157 + 1;
            if (v157 + 1 > 0x199999999999999) {
              sub_10006A748();
            }
            if (0x999999999999999ALL * ((uint64_t)(v207 - v206.i64[0]) >> 5) > v158) {
              unint64_t v158 = 0x999999999999999ALL * ((uint64_t)(v207 - v206.i64[0]) >> 5);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v207 - v206.i64[0]) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
              unint64_t v159 = 0x199999999999999;
            }
            else {
              unint64_t v159 = v158;
            }
            id v218 = &v207;
            if (v159)
            {
              if (v159 > 0x199999999999999) {
                sub_10006A7CC();
              }
              long long v160 = (char *)operator new(160 * v159);
            }
            else
            {
              long long v160 = 0;
            }
            uint64_t v215 = v160;
            v216.i64[0] = (uint64_t)&v160[160 * v157];
            v216.i64[1] = v216.i64[0];
            uint64_t v217 = &v160[160 * v159];
            sub_100FC87F4(v216.i64[0], (uint64_t)__p);
            uint64_t v161 = v216.i64[0];
            uint64_t v155 = v216.i64[1] + 160;
            v216.i64[1] += 160;
            int64x2_t v162 = v206;
            long long v156 = v196;
            if (v206.i64[1] == v206.i64[0])
            {
              int64x2_t v177 = vdupq_n_s64(v206.u64[1]);
            }
            else
            {
              uint64_t v163 = 0;
              do
              {
                uint64_t v164 = v161 + v163;
                *(unsigned char *)(v161 + v163 - 160) = 0;
                uint64_t v165 = v162.i64[1] + v163;
                *(unsigned char *)(v161 + v163 - 136) = 0;
                if (*(unsigned char *)(v162.i64[1] + v163 - 136))
                {
                  int v166 = (void *)(v165 - 160);
                  long long v167 = *(_OWORD *)(v165 - 160);
                  *(void *)(v161 + v163 - 144) = *(void *)(v165 - 144);
                  *(_OWORD *)(v161 + v163 - 160) = v167;
                  v166[1] = 0;
                  v166[2] = 0;
                  *int v166 = 0;
                  *(unsigned char *)(v164 - 136) = 1;
                }
                *(unsigned char *)(v164 - 128) = 0;
                *(unsigned char *)(v164 - 104) = 0;
                if (*(unsigned char *)(v165 - 104))
                {
                  uint64_t v168 = v162.i64[1] + v163;
                  long long v169 = *(_OWORD *)(v162.i64[1] + v163 - 128);
                  *(void *)(v164 - 112) = *(void *)(v162.i64[1] + v163 - 112);
                  *(_OWORD *)(v164 - 128) = v169;
                  *(void *)(v168 - 120) = 0;
                  *(void *)(v168 - 112) = 0;
                  *(void *)(v168 - 128) = 0;
                  *(unsigned char *)(v164 - 104) = 1;
                }
                uint64_t v170 = v161 + v163;
                uint64_t v171 = v162.i64[1] + v163;
                *(_WORD *)(v170 - 96) = *(_WORD *)(v162.i64[1] + v163 - 96);
                *(unsigned char *)(v161 + v163 - 88) = 0;
                *(unsigned char *)(v170 - 64) = 0;
                if (*(unsigned char *)(v162.i64[1] + v163 - 64))
                {
                  long long v172 = *(_OWORD *)(v171 - 88);
                  *(void *)(v161 + v163 - 72) = *(void *)(v171 - 72);
                  *(_OWORD *)(v161 + v163 - 88) = v172;
                  *(void *)(v171 - 80) = 0;
                  *(void *)(v171 - 72) = 0;
                  *(void *)(v171 - 88) = 0;
                  *(unsigned char *)(v170 - 64) = 1;
                }
                *(void *)(v170 - 56) = *(void *)(v171 - 56);
                *(unsigned char *)(v170 - 48) = 0;
                *(unsigned char *)(v170 - 24) = 0;
                if (*(unsigned char *)(v171 - 24))
                {
                  uint64_t v173 = v162.i64[1] + v163;
                  long long v174 = *(_OWORD *)(v162.i64[1] + v163 - 48);
                  *(void *)(v170 - 32) = *(void *)(v162.i64[1] + v163 - 32);
                  *(_OWORD *)(v170 - 48) = v174;
                  *(void *)(v173 - 40) = 0;
                  *(void *)(v173 - 32) = 0;
                  *(void *)(v173 - 48) = 0;
                  *(unsigned char *)(v170 - 24) = 1;
                }
                uint64_t v175 = v161 + v163;
                uint64_t v176 = *(void *)(v162.i64[1] + v163 - 16);
                *(_DWORD *)(v175 - 8) = *(_DWORD *)(v162.i64[1] + v163 - 8);
                *(void *)(v175 - 16) = v176;
                v163 -= 160;
              }
              while (v162.i64[1] + v163 != v162.i64[0]);
              int64x2_t v177 = v206;
              uint64_t v155 = v216.i64[1];
              v161 += v163;
            }
            v206.i64[0] = v161;
            v206.i64[1] = v155;
            int64x2_t v216 = v177;
            std::string::size_type v178 = (char *)v207;
            *(void *)&long long v207 = v217;
            uint64_t v217 = v178;
            uint64_t v215 = (void *)v177.i64[0];
            sub_100FC88D8((uint64_t)&v215);
          }
          else
          {
            sub_100FC87F4(v206.i64[1], (uint64_t)__p);
            uint64_t v155 = v154 + 160;
            long long v156 = v196;
          }
          v206.i64[1] = v155;
          if (LOBYTE(v225[1]) && SHIBYTE(v225[0]) < 0) {
            operator delete(v224[0]);
          }
          if (LOBYTE(v223[0]) && SHIBYTE(v222) < 0) {
            operator delete(v221[1]);
          }
          if (LOBYTE(v220[3]) && SHIBYTE(v220[2]) < 0) {
            operator delete(v220[0]);
          }
          if (__p[1].n128_u8[8] && __p[1].n128_i8[7] < 0) {
            operator delete((void *)__p[0].n128_u64[0]);
          }
          BOOL v204 = (std::string *)((char *)v204 + 1);
        }
        while (v204 != v156);
        long long v128 = (std::string *)[(__CFArray *)v192 countByEnumeratingWithState:&v208 objects:v231 count:16];
      }
      while (v128);
    }
    a4 = v187;
    int v4 = 6000;
    if ((_BYTE)v213) {
      sub_100044D00((const void **)&theArray);
    }
  }
  uint64_t v179 = (void **)(v190 + 152);
  if (v190[176] == BYTE8(v207))
  {
    if (!v190[176]) {
      goto LABEL_302;
    }
    uint64_t v180 = *v179;
    int v181 = v190;
    if (*v179)
    {
      uint64_t v182 = *((void *)v190 + 20);
      uint64_t v183 = *v179;
      if ((void *)v182 != v180)
      {
        do
        {
          v182 -= 160;
          sub_100FC86D8(v182);
        }
        while ((void *)v182 != v180);
        uint64_t v183 = *v179;
      }
      int v181 = v190;
      *((void *)v190 + 20) = v180;
      operator delete(v183);
      *uint64_t v179 = 0;
      *((void *)v190 + 20) = 0;
      *((void *)v190 + 21) = 0;
    }
    *(int64x2_t *)(v181 + 152) = v206;
    *((void *)v181 + 21) = v207;
    *(void *)&long long v207 = 0;
    int64x2_t v206 = 0uLL;
  }
  else if (v190[176])
  {
    __p[0].n128_u64[0] = (unint64_t)(v190 + 152);
    sub_100FC8770((void ***)__p);
    v190[176] = 0;
  }
  else
  {
    *(int64x2_t *)(v190 + 152) = v206;
    *((void *)v190 + 21) = v207;
    *(void *)&long long v207 = 0;
    int64x2_t v206 = 0uLL;
    v190[176] = 1;
  }
  if (BYTE8(v207))
  {
    __p[0].n128_u64[0] = (unint64_t)&v206;
    sub_100FC8770((void ***)__p);
  }
LABEL_302:
  uint64_t v184 = operator new(0x30uLL);
  uint64_t v185 = v184;
  v184[1] = 0;
  v184[2] = 0;
  *uint64_t v184 = off_101A7AE48;
  long long v186 = (char *)(v184 + 3);
  if (v190)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v190 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v184 + 6) = v4;
    v184[4] = v189;
    v184[5] = v190;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v190 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v190);
    sub_10004D2C8((std::__shared_weak_count *)v190);
  }
  else
  {
    *((_DWORD *)v184 + 6) = v4;
    v184[4] = v189;
    v184[5] = 0;
  }
  *a4 = v186;
  a4[1] = v185;
}

void sub_100FDE8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,const void *a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void **a49)
{
  if (a42) {
    sub_100044D00(&a41);
  }
  if (a32)
  {
    a49 = (void **)&a29;
    sub_100FC8770(&a49);
  }
  sub_10004D2C8(a14);
  _Unwind_Resume(a1);
}

void sub_100FDEB64(uint64_t a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100FDEB5CLL);
}

void sub_100FDEB78(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    id v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  unint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7AE48;
    *((_DWORD *)v19 + 6) = v21;
    unint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  id v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FDEDA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDEDC0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019AC20(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDF0B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDF124()
{
  return "getSIMStatus";
}

void sub_100FDF130(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AE48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDF150(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AE48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FDF1A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FDF1B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AE98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDF1D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AE98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDF22C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDF258(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDF290(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    uint64_t v8 = (char *)operator new(0x70uLL);
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *(void *)uint64_t v8 = off_101A79A90;
    *(_OWORD *)(v8 + 24) = 0u;
    uint64_t v9 = (void **)(v8 + 24);
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *((void *)v8 + 13) = 0;
    memset(buf, 0, sizeof(buf));
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"signup-url");
    sub_100FC2A7C(buf, a1, Value, @"signup-url");
    *(_OWORD *)CFTypeRef v26 = 0u;
    long long v27 = 0u;
    uint64_t v11 = CFDictionaryGetValue(a3, @"signup-url-post-data");
    sub_100FC2A7C(v26, a1, v11, @"signup-url-post-data");
    *(_OWORD *)std::string __p = 0u;
    long long v25 = 0u;
    uint64_t v12 = CFDictionaryGetValue(a3, @"iccid");
    sub_100FC2A7C(__p, a1, v12, @"iccid");
    unint64_t v13 = CFDictionaryGetValue(a3, @"use-ds");
    __int16 v14 = sub_100FC3980(a1, v13, @"use-ds");
    if (buf[24])
    {
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(&v22, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long v22 = *(_OWORD *)buf;
        uint64_t v23 = *(void *)&buf[16];
      }
    }
    else
    {
      long long v22 = 0uLL;
      uint64_t v23 = 0;
    }
    if (v8[47] < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = v22;
    *((void *)v8 + 5) = v23;
    if (BYTE8(v27))
    {
      if (SBYTE7(v27) < 0)
      {
        sub_10004FC84(&v22, v26[0], (unint64_t)v26[1]);
      }
      else
      {
        long long v22 = *(_OWORD *)v26;
        uint64_t v23 = v27;
      }
    }
    else
    {
      long long v22 = 0uLL;
      uint64_t v23 = 0;
    }
    int v18 = (void **)(v8 + 48);
    if (v8[71] < 0) {
      operator delete(*v18);
    }
    *(_OWORD *)int v18 = v22;
    *((void *)v8 + 8) = v23;
    sub_100179AF8((std::string *)v8 + 3, (const std::string *)__p);
    *((_WORD *)v8 + 52) = v14;
    if (BYTE8(v25) && SBYTE7(v25) < 0) {
      operator delete(__p[0]);
    }
    if (BYTE8(v27) && SBYTE7(v27) < 0) {
      operator delete(v26[0]);
    }
    if (buf[24] && (char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v15 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v17;
      __int16 v29 = 2080;
      __int16 v30 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  uint64_t v19 = operator new(0x30uLL);
  __int16 v20 = v19;
  v19[1] = 0;
  void v19[2] = 0;
  void *v19 = off_101A7AF70;
  int v21 = (char *)(v19 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v19 + 6) = a2;
    v19[4] = v9;
    v19[5] = v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v8);
    sub_10004D2C8((std::__shared_weak_count *)v8);
  }
  else
  {
    *((_DWORD *)v19 + 6) = a2;
    v19[4] = v9;
    v19[5] = 0;
  }
  *a4 = v21;
  a4[1] = v20;
}

void sub_100FDF648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a19 && a18 < 0) {
    operator delete(__p);
  }
  if (a26 && a25 < 0) {
    operator delete(a20);
  }
  if (a33)
  {
    if (a32 < 0) {
      operator delete(a27);
    }
  }
  sub_10004D2C8(v33);
  _Unwind_Resume(a1);
}

void sub_100FDF6D0(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    long long v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    __int16 v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  unint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7AF70;
    *((_DWORD *)v19 + 6) = v21;
    unint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  __int16 v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FDF900(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FDF918(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019AEDC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FDFC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FDFC7C()
{
  return "signUpForSIMService";
}

void sub_100FDFC88(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AF70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDFCA8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AF70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FDFCFC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FDFD10(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AFC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FDFD30(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7AFC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FDFD84(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FDFDB0(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FDFDE8(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    uint64_t v8 = (std::__shared_weak_count *)operator new(0x30uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = 0;
    uint64_t v9 = (void **)&v8[1].__vftable;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79AE0;
    v8[1].__shared_owners_ = 0;
    v8[1].__shared_weak_owners_ = 0;
    memset(buf, 0, sizeof(buf));
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"authorization-nonce");
    sub_100FC2A7C(buf, a1, Value, @"authorization-nonce");
    if (buf[24])
    {
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(&v17, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long v17 = *(_OWORD *)buf;
        uint64_t v18 = *(void *)&buf[16];
      }
    }
    else
    {
      long long v17 = 0uLL;
      uint64_t v18 = 0;
    }
    if (SHIBYTE(v8[1].__shared_weak_owners_) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = v17;
    v8[1].__shared_weak_owners_ = v18;
    if (buf[24] && (char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v13;
      __int16 v20 = 2080;
      int v21 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  __int16 v14 = operator new(0x30uLL);
  uint64_t v15 = v14;
  v14[1] = 0;
  void v14[2] = 0;
  void *v14 = off_101A7B098;
  uint64_t v16 = (char *)(v14 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v14 + 6) = a2;
    _OWORD v14[4] = v9;
    void v14[5] = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  else
  {
    *((_DWORD *)v14 + 6) = a2;
    _OWORD v14[4] = v9;
    void v14[5] = 0;
  }
  *a4 = v16;
  a4[1] = v15;
}

void sub_100FE0068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_100FE00A8(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7B098;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  __int16 v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE02D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE02F0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019B198(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE05E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE0654()
{
  return "getCarrierAuthorizationNonce";
}

void sub_100FE0660(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B098;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE0680(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B098;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE06D4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE06E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B0E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE0708(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B0E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE075C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE0788(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE07C0(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    uint64_t v8 = (std::__shared_weak_count *)operator new(0x30uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = 0;
    uint64_t v9 = (void **)&v8[1].__vftable;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79B30;
    v8[1].__shared_owners_ = 0;
    v8[1].__shared_weak_owners_ = 0;
    memset(buf, 0, sizeof(buf));
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"authorization-token");
    sub_100FC2A7C(buf, a1, Value, @"authorization-token");
    if (buf[24])
    {
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(&v17, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long v17 = *(_OWORD *)buf;
        uint64_t v18 = *(void *)&buf[16];
      }
    }
    else
    {
      long long v17 = 0uLL;
      uint64_t v18 = 0;
    }
    if (SHIBYTE(v8[1].__shared_weak_owners_) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = v17;
    v8[1].__shared_weak_owners_ = v18;
    if (buf[24] && (char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v11 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v13;
      __int16 v20 = 2080;
      int v21 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  __int16 v14 = operator new(0x30uLL);
  uint64_t v15 = v14;
  v14[1] = 0;
  void v14[2] = 0;
  void *v14 = off_101A7B1C0;
  uint64_t v16 = (char *)(v14 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v14 + 6) = a2;
    _OWORD v14[4] = v9;
    void v14[5] = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  else
  {
    *((_DWORD *)v14 + 6) = a2;
    _OWORD v14[4] = v9;
    void v14[5] = 0;
  }
  *a4 = v16;
  a4[1] = v15;
}

void sub_100FE0A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_100FE0A80(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7B1C0;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  __int16 v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE0CB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE0CC8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  __int16 v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019B454(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE0FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE102C()
{
  return "authenticateTrustFlag";
}

void sub_100FE1038(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B1C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE1058(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B1C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE10AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE10C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B210;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE10E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B210;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE1134(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE1160(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE1198(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
LABEL_5:
    uint64_t v11 = (char *)operator new(0xB0uLL);
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = 0;
    *(void *)uint64_t v11 = off_101A79B80;
    *(_OWORD *)(v11 + 24) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 72) = 0u;
    *(_OWORD *)(v11 + 88) = 0u;
    *(_OWORD *)(v11 + 104) = 0u;
    *(_OWORD *)(v11 + 120) = 0u;
    *(_OWORD *)(v11 + 136) = 0u;
    *(_OWORD *)(v11 + 152) = 0u;
    *((void *)v11 + 21) = 0;
    id v81 = v11 + 24;
    unsigned int v82 = (std::__shared_weak_count *)v11;
    codec::fromJSONObject<entitlements::TransferSIMResponse>((uint64_t)(v11 + 24), a3);
    uint64_t v12 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v14;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferSIMService response: {", buf, 0x2Au);
      uint64_t v12 = **(NSObject ***)(a1 + 40);
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v17 = sub_100FB56F4(a2);
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v16;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sstatus:%{public}s : {", buf, 0x34u);
      uint64_t v12 = **(NSObject ***)(a1 + 40);
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v19;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIccidStates: [", buf, 0x2Au);
    }
    __int16 v20 = (long long *)*((void *)v11 + 3);
    for (unint64_t i = (long long *)*((void *)v11 + 4); v20 != i; v20 += 6)
    {
      long long v95 = 0u;
      long long v96 = 0u;
      memset(buf, 0, sizeof(buf));
      if (*((char *)v20 + 23) < 0)
      {
        sub_10004FC84(buf, *(void **)v20, *((void *)v20 + 1));
      }
      else
      {
        long long v21 = *v20;
        *(void *)&uint8_t buf[16] = *((void *)v20 + 2);
        *(_OWORD *)int buf = v21;
      }
      sub_1000593FC((uint64_t)&buf[24], (long long *)((char *)v20 + 24));
      sub_1000593FC((uint64_t)&buf[56], (long long *)((char *)v20 + 56));
      WORD4(v96) = *((_WORD *)v20 + 44);
      uint64_t v22 = *(os_log_t **)(a1 + 40);
      uint64_t v23 = *v22;
      if (os_log_type_enabled(*v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)unint64_t v84 = 136315906;
        uint64_t v85 = v24;
        __int16 v86 = 2080;
        uint64_t v87 = " ";
        __int16 v88 = 2080;
        uint64_t v89 = v25;
        __int16 v90 = 2080;
        uint64_t v91 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s{", v84, 0x2Au);
        uint64_t v22 = *(os_log_t **)(a1 + 40);
        uint64_t v23 = *v22;
      }
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        CFTypeRef v28 = buf;
        if ((buf[23] & 0x80u) != 0) {
          CFTypeRef v28 = *(uint8_t **)buf;
        }
        *(_DWORD *)unint64_t v84 = 136316162;
        uint64_t v85 = v26;
        __int16 v86 = 2080;
        uint64_t v87 = " ";
        __int16 v88 = 2080;
        uint64_t v89 = v27;
        __int16 v90 = 2080;
        uint64_t v91 = ", ";
        __int16 v92 = 2080;
        uint64_t v93 = v28;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%siccid: %s", v84, 0x34u);
        uint64_t v22 = *(os_log_t **)(a1 + 40);
      }
      if (buf[48])
      {
        CFTypeRef v29 = *v22;
        if (os_log_type_enabled(*v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v30 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          if (!buf[48]) {
            sub_10016C840();
          }
          if ((buf[47] & 0x80u) == 0) {
            uint64_t v32 = &buf[24];
          }
          else {
            uint64_t v32 = *(uint8_t **)&buf[24];
          }
          *(_DWORD *)unint64_t v84 = 136316162;
          uint64_t v85 = v30;
          __int16 v86 = 2080;
          uint64_t v87 = " ";
          __int16 v88 = 2080;
          uint64_t v89 = v31;
          __int16 v90 = 2080;
          uint64_t v91 = ", ";
          __int16 v92 = 2082;
          uint64_t v93 = v32;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%simei: %{public}s", v84, 0x34u);
          uint64_t v22 = *(os_log_t **)(a1 + 40);
        }
      }
      if ((_BYTE)v96)
      {
        __int16 v33 = *v22;
        if (os_log_type_enabled(*v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          if (!(_BYTE)v96) {
            sub_10016C840();
          }
          if (v95 >= 0) {
            uint64_t v36 = &buf[56];
          }
          else {
            uint64_t v36 = *(uint8_t **)&buf[56];
          }
          *(_DWORD *)unint64_t v84 = 136316162;
          uint64_t v85 = v34;
          __int16 v86 = 2080;
          uint64_t v87 = " ";
          __int16 v88 = 2080;
          uint64_t v89 = v35;
          __int16 v90 = 2080;
          uint64_t v91 = ", ";
          __int16 v92 = 2082;
          uint64_t v93 = v36;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smeid: %{public}s", v84, 0x34u);
          uint64_t v22 = *(os_log_t **)(a1 + 40);
        }
      }
      if (BYTE9(v96))
      {
        __int16 v37 = *v22;
        if (os_log_type_enabled(*v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          if (!BYTE9(v96)) {
            sub_10016C840();
          }
          *(_DWORD *)unint64_t v84 = 136316162;
          uint64_t v85 = v38;
          __int16 v86 = 2080;
          uint64_t v87 = " ";
          __int16 v88 = 2080;
          uint64_t v89 = v39;
          __int16 v90 = 2080;
          uint64_t v91 = ", ";
          __int16 v92 = 1026;
          LODWORD(v93) = BYTE8(v96);
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sprofileRelease: %{public}d", v84, 0x30u);
          uint64_t v22 = *(os_log_t **)(a1 + 40);
        }
      }
      long long v40 = *v22;
      if (os_log_type_enabled(*v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v42 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)unint64_t v84 = 136315906;
        uint64_t v85 = v41;
        __int16 v86 = 2080;
        uint64_t v87 = " ";
        __int16 v88 = 2080;
        uint64_t v89 = v42;
        __int16 v90 = 2080;
        uint64_t v91 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", v84, 0x2Au);
      }
      if ((_BYTE)v96 && SHIBYTE(v95) < 0) {
        operator delete(*(void **)&buf[56]);
      }
      if (buf[48] && (char)buf[47] < 0) {
        operator delete(*(void **)&buf[24]);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    uint64_t v43 = *(os_log_t **)(a1 + 40);
    uint64_t v44 = *v43;
    long long v45 = v82;
    if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v46 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v46;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v47;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s]", buf, 0x2Au);
      uint64_t v43 = *(os_log_t **)(a1 + 40);
    }
    if (LOBYTE(v82[3].__vftable))
    {
      uint64_t v48 = *v43;
      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v49 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v50 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v82[3].__vftable)) {
          sub_10016C840();
        }
        uint64_t v51 = &v82[2].__vftable;
        if (SHIBYTE(v82[2].__shared_weak_owners_) < 0) {
          uint64_t v51 = (void *)*v51;
        }
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v49;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v50;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v51;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferURL: %{public}s", buf, 0x34u);
        uint64_t v43 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v82[4].__shared_owners_))
    {
      long long v56 = *v43;
      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v57 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v82[4].__shared_owners_)) {
          sub_10016C840();
        }
        p_shared_owners = &v82[3].__shared_owners_;
        if (SHIBYTE(v82[4].__vftable) < 0) {
          p_shared_owners = (uint64_t *)*p_shared_owners;
        }
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v57;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v58;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = p_shared_owners;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferUrlPostData: %s", buf, 0x34u);
        uint64_t v43 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v82[5].__shared_weak_owners_))
    {
      char v60 = *v43;
      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v61 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v62 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v82[5].__shared_weak_owners_)) {
          sub_10016C840();
        }
        p_uint64_t shared_weak_owners = &v82[4].__shared_weak_owners_;
        if (SHIBYTE(v82[5].__shared_owners_) < 0) {
          p_uint64_t shared_weak_owners = (uint64_t *)*p_shared_weak_owners;
        }
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v61;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v62;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = p_shared_weak_owners;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAltSmdpFqdn: %{public}s", buf, 0x34u);
        uint64_t v43 = *(os_log_t **)(a1 + 40);
      }
    }
    if (BYTE1(v82[6].__vftable))
    {
      uint64_t v64 = *v43;
      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v65 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!BYTE1(v82[6].__vftable)) {
          sub_10016C840();
        }
        int v67 = LOBYTE(v82[6].__vftable);
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v65;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v66;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 1026;
        *(_DWORD *)&buf[44] = v67;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUseDS: %{public}d", buf, 0x30u);
        uint64_t v43 = *(os_log_t **)(a1 + 40);
      }
    }
    if (BYTE3(v82[6].__vftable))
    {
      uint64_t v68 = *v43;
      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v69 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!BYTE3(v82[6].__vftable)) {
          sub_10016C840();
        }
        int v71 = BYTE2(v82[6].__vftable);
        *(_DWORD *)int buf = 136316162;
        *(void *)&uint8_t buf[4] = v69;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v70;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 1026;
        *(_DWORD *)&buf[44] = v71;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIsWebView: %{public}d", buf, 0x30u);
        uint64_t v43 = *(os_log_t **)(a1 + 40);
      }
    }
    uint64_t v72 = *v43;
    if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v73 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v74 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      __int16 v75 = &v82[6].__shared_owners_;
      if (SHIBYTE(v82[7].__vftable) < 0) {
        __int16 v75 = (uint64_t *)*v75;
      }
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = v73;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v74;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = v75;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sErrorCode: %{public}s", buf, 0x34u);
      uint64_t v72 = **(NSObject ***)(a1 + 40);
    }
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v76 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v77 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v76;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v77;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", buf, 0x2Au);
    }
    long long v55 = v81;
    goto LABEL_88;
  }
  if (a2 == 6013)
  {
    uint64_t v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v10;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%stransfer SIM response redirecting to websheet", buf, 0x2Au);
    }
    goto LABEL_5;
  }
  long long v52 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v53 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = v53;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v54;
    *(_WORD *)&uint8_t buf[32] = 2080;
    *(void *)&buf[34] = ", ";
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  long long v45 = 0;
  long long v55 = 0;
LABEL_88:
  id v78 = operator new(0x30uLL);
  id v79 = v78;
  v78[1] = 0;
  v78[2] = 0;
  void *v78 = off_101A7B2E8;
  id v80 = (char *)(v78 + 3);
  if (v45)
  {
    atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v78 + 6) = a2;
    v78[4] = v55;
    v78[5] = v45;
    atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v45);
    sub_10004D2C8(v45);
  }
  else
  {
    *((_DWORD *)v78 + 6) = a2;
    v78[4] = v55;
    v78[5] = 0;
  }
  *a4 = v80;
  a4[1] = v79;
}

void sub_100FE2248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
}

void sub_100FE230C(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    uint64_t v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    uint64_t v19 = operator new(0x30uLL);
    __int16 v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    void v19[2] = 0;
    void *v19 = off_101A7B2E8;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    __int16 v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE253C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE2554(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)int buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    uint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  uint64_t v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    __int16 v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)int buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)int buf = v24;
          *(void *)&uint8_t buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019B710(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE2848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE28B8()
{
  return "transferSIMService";
}

void sub_100FE28C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B2E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE28E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B2E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE2938(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE294C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B338;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE296C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B338;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE29C0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE29EC(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE2A24(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    uint64_t v8 = (char *)operator new(0x78uLL);
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *(void *)uint64_t v8 = off_101A79C20;
    *(_OWORD *)(v8 + 24) = 0u;
    uint64_t v9 = (uint64_t)(v8 + 24);
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *(_OWORD *)(v8 + 104) = 0u;
    CFDictionaryRef theDict = 0;
    uint64_t v53 = 0;
    CFBooleanRef Value = CFDictionaryGetValue(a3, @"plmn-priority-list");
    sub_100FC3BAC(&theDict, a1, Value, @"plmn-priority-list", 0);
    if (!(_BYTE)v53)
    {
      sub_10004D2C8((std::__shared_weak_count *)v8);
      *a4 = 0;
      a4[1] = 0;
      return;
    }
    CFTypeRef cf = 0;
    uint64_t v51 = 0;
    uint64_t v11 = CFDictionaryGetValue(theDict, @"unlimited");
    sub_100FC3AEC(&cf, v11);
    if ((_BYTE)v51)
    {
      uint64_t v47 = 0;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      uint64_t v12 = (void *)cf;
      CFTypeRef v46 = cf;
      if (cf)
      {
        CFRetain(cf);
        uint64_t v12 = (void *)v46;
      }
      BOOL v13 = sub_100FC7288(v12, (uint64_t *)&v47);
      sub_100044D00(&v46);
      if (v13)
      {
        sub_100FC7688(v9, &v47);
      }
      else
      {
        int v17 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          long long v54 = 0uLL;
          uint64_t v55 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v54;
          uint64_t v45 = v55;
          __int16 v20 = (void **)v54;
          if (v55 >= 0) {
            __int16 v20 = __p;
          }
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v18;
          __int16 v57 = 2080;
          uint64_t v58 = " ";
          __int16 v59 = 2080;
          uint64_t v60 = v19;
          __int16 v61 = 2080;
          uint64_t v62 = ", ";
          __int16 v63 = 2080;
          uint64_t v64 = v20;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scould not parse %s element, skipping parsing", buf, 0x34u);
          if (SHIBYTE(v45) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      *(void *)int buf = &v47;
      sub_10019E86C((void ***)buf);
    }
    CFTypeRef v42 = 0;
    uint64_t v43 = 0;
    int v21 = CFDictionaryGetValue(theDict, @"metered");
    sub_100FC3AEC(&v42, v21);
    if ((_BYTE)v43)
    {
      uint64_t v47 = 0;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      uint64_t v22 = (void *)v42;
      CFTypeRef v41 = v42;
      if (v42)
      {
        CFRetain(v42);
        uint64_t v22 = (void *)v41;
      }
      BOOL v23 = sub_100FC7288(v22, (uint64_t *)&v47);
      sub_100044D00(&v41);
      if (v23)
      {
        sub_100FC7688((uint64_t)(v8 + 56), &v47);
      }
      else
      {
        __int16 v24 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          long long v54 = 0uLL;
          uint64_t v55 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v54;
          uint64_t v45 = v55;
          uint64_t v27 = (void **)v54;
          if (v55 >= 0) {
            uint64_t v27 = __p;
          }
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v25;
          __int16 v57 = 2080;
          uint64_t v58 = " ";
          __int16 v59 = 2080;
          uint64_t v60 = v26;
          __int16 v61 = 2080;
          uint64_t v62 = ", ";
          __int16 v63 = 2080;
          uint64_t v64 = v27;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scould not parse %s element, skipping parsing", buf, 0x34u);
          if (SHIBYTE(v45) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      *(void *)int buf = &v47;
      sub_10019E86C((void ***)buf);
    }
    CFTypeRef v39 = 0;
    uint64_t v40 = 0;
    CFTypeRef v28 = CFDictionaryGetValue(theDict, @"others");
    sub_100FC3AEC(&v39, v28);
    if ((_BYTE)v40)
    {
      uint64_t v47 = 0;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      CFTypeRef v29 = (void *)v39;
      CFTypeRef v38 = v39;
      if (v39)
      {
        CFRetain(v39);
        CFTypeRef v29 = (void *)v38;
      }
      BOOL v30 = sub_100FC7288(v29, (uint64_t *)&v47);
      sub_100044D00(&v38);
      if (v30)
      {
        sub_100FC7688((uint64_t)(v8 + 88), &v47);
      }
      else
      {
        __int16 v31 = **(NSObject ***)(a1 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          long long v54 = 0uLL;
          uint64_t v55 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v54;
          uint64_t v45 = v55;
          uint64_t v34 = __p;
          if (v55 < 0) {
            uint64_t v34 = (void **)__p[0];
          }
          *(_DWORD *)int buf = 136316162;
          *(void *)&uint8_t buf[4] = v32;
          __int16 v57 = 2080;
          uint64_t v58 = " ";
          __int16 v59 = 2080;
          uint64_t v60 = v33;
          __int16 v61 = 2080;
          uint64_t v62 = ", ";
          __int16 v63 = 2080;
          uint64_t v64 = v34;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%scould not parse %s element, skipping parsing", buf, 0x34u);
          if (SHIBYTE(v45) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      *(void *)int buf = &v47;
      sub_10019E86C((void ***)buf);
      if ((_BYTE)v40) {
        sub_100044D00(&v39);
      }
    }
    if ((_BYTE)v43) {
      sub_100044D00(&v42);
    }
    if ((_BYTE)v51) {
      sub_100044D00(&cf);
    }
    if ((_BYTE)v53) {
      sub_100057D78((const void **)&theDict);
    }
  }
  else
  {
    uint64_t v14 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v57 = 2080;
      uint64_t v58 = " ";
      __int16 v59 = 2080;
      uint64_t v60 = v16;
      __int16 v61 = 2080;
      uint64_t v62 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  __int16 v35 = operator new(0x30uLL);
  uint64_t v36 = v35;
  v35[1] = 0;
  v35[2] = 0;
  void *v35 = off_101A7B3E0;
  __int16 v37 = (char *)(v35 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v35 + 6) = a2;
    void v35[4] = v9;
    v35[5] = v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v8);
    *a4 = v37;
    a4[1] = v36;
    sub_10004D2C8((std::__shared_weak_count *)v8);
  }
  else
  {
    *((_DWORD *)v35 + 6) = a2;
    void v35[4] = v9;
    v35[5] = 0;
    *a4 = v37;
    a4[1] = v35;
  }
}